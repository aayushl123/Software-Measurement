<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TestAbstractHierarchicalConfiguration.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">commons_configuration2$Unnamed.exec</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.configuration2</a> &gt; <span class="el_source">TestAbstractHierarchicalConfiguration.java</span></div><h1>TestAbstractHierarchicalConfiguration.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.commons.configuration2;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertSame;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.apache.commons.configuration2.convert.DefaultListDelimiterHandler;
import org.apache.commons.configuration2.event.ConfigurationEvent;
import org.apache.commons.configuration2.event.EventListener;
import org.apache.commons.configuration2.event.EventListenerTestImpl;
import org.apache.commons.configuration2.tree.DefaultConfigurationKey;
import org.apache.commons.configuration2.tree.DefaultExpressionEngine;
import org.apache.commons.configuration2.tree.DefaultExpressionEngineSymbols;
import org.apache.commons.configuration2.tree.ExpressionEngine;
import org.apache.commons.configuration2.tree.ImmutableNode;
import org.apache.commons.configuration2.tree.InMemoryNodeModel;
import org.apache.commons.configuration2.tree.NodeHandler;
import org.apache.commons.configuration2.tree.NodeModel;
import org.apache.commons.configuration2.tree.NodeStructureHelper;
import org.junit.Before;
import org.junit.Test;

/**
 * Test class for {@code AbstractHierarchicalConfiguration}.
 *
 * @version $Id$
 */
<span class="fc" id="L58">public class TestAbstractHierarchicalConfiguration</span>
{
    /** The test configuration. */
    private AbstractHierarchicalConfiguration&lt;ImmutableNode&gt; config;

    @Before
    public void setUp() throws Exception
    {
<span class="fc" id="L66">        ImmutableNode root =</span>
<span class="fc" id="L67">                new ImmutableNode.Builder(1).addChild(</span>
<span class="fc" id="L68">                        NodeStructureHelper.ROOT_TABLES_TREE).create();</span>
<span class="fc" id="L69">        config =</span>
                new AbstractHierarchicalConfigurationTestImpl(
                        new InMemoryNodeModel(root));
<span class="fc" id="L72">    }</span>

    /**
     * Convenience method for obtaining the root node of the test configuration.
     *
     * @return the root node of the test configuration
     */
    private ImmutableNode getRootNode()
    {
<span class="fc" id="L81">        return config.getModel().getNodeHandler().getRootNode();</span>
    }

    @Test
    public void testIsEmptyFalse()
    {
<span class="fc" id="L87">        assertFalse(config.isEmpty());</span>
<span class="fc" id="L88">    }</span>

    /**
     * Tests isEmpty() if only the root node exists.
     */
    @Test
    public void testIsEmptyRootOnly()
    {
<span class="fc" id="L96">        config =</span>
                new AbstractHierarchicalConfigurationTestImpl(
                        new InMemoryNodeModel());
<span class="fc" id="L99">        assertTrue(&quot;Not empty&quot;, config.isEmpty());</span>
<span class="fc" id="L100">    }</span>

    /**
     * Tests isEmpty() if the structure contains some nodes without values.
     */
    @Test
    public void testIsEmptyNodesWithNoValues()
    {
<span class="fc" id="L108">        ImmutableNode.Builder rootBuilder = new ImmutableNode.Builder(1);</span>
<span class="fc" id="L109">        ImmutableNode.Builder nodeBuilder = new ImmutableNode.Builder(1);</span>
<span class="fc" id="L110">        nodeBuilder.addChild(NodeStructureHelper.createNode(&quot;child&quot;, null));</span>
<span class="fc" id="L111">        rootBuilder.addChild(nodeBuilder.create());</span>
<span class="fc" id="L112">        config =</span>
                new AbstractHierarchicalConfigurationTestImpl(
<span class="fc" id="L114">                        new InMemoryNodeModel(rootBuilder.create()));</span>
<span class="fc" id="L115">        assertTrue(&quot;Not empty&quot;, config.isEmpty());</span>
<span class="fc" id="L116">    }</span>

    private static void checkGetProperty(AbstractHierarchicalConfiguration&lt;?&gt; testConfig)
    {
<span class="fc" id="L120">        assertNull(testConfig.getProperty(&quot;tables.table.resultset&quot;));</span>
<span class="fc" id="L121">        assertNull(testConfig.getProperty(&quot;tables.table.fields.field&quot;));</span>

<span class="fc" id="L123">        Object prop = testConfig.getProperty(&quot;tables.table(0).fields.field.name&quot;);</span>
<span class="fc" id="L124">        assertNotNull(prop);</span>
<span class="fc" id="L125">        assertTrue(prop instanceof Collection);</span>
<span class="fc" id="L126">        assertEquals(NodeStructureHelper.fieldsLength(0), ((Collection&lt;?&gt;) prop).size());</span>

<span class="fc" id="L128">        prop = testConfig.getProperty(&quot;tables.table.fields.field.name&quot;);</span>
<span class="fc" id="L129">        assertNotNull(prop);</span>
<span class="fc" id="L130">        assertTrue(prop instanceof Collection);</span>
<span class="fc" id="L131">        assertEquals(totalFieldCount(), ((Collection&lt;?&gt;) prop).size());</span>

<span class="fc" id="L133">        prop = testConfig.getProperty(&quot;tables.table.fields.field(3).name&quot;);</span>
<span class="fc" id="L134">        assertNotNull(prop);</span>
<span class="fc" id="L135">        assertTrue(prop instanceof Collection);</span>
<span class="fc" id="L136">        assertEquals(2, ((Collection&lt;?&gt;) prop).size());</span>

<span class="fc" id="L138">        prop = testConfig.getProperty(&quot;tables.table(1).fields.field(2).name&quot;);</span>
<span class="fc" id="L139">        assertNotNull(prop);</span>
<span class="fc" id="L140">        assertEquals(&quot;creationDate&quot;, prop.toString());</span>
<span class="fc" id="L141">    }</span>

    @Test
    public void testGetProperty()
    {
<span class="fc" id="L146">        checkGetProperty(config);</span>
<span class="fc" id="L147">    }</span>

    @Test
    public void testSetProperty()
    {
<span class="fc" id="L152">        config.setListDelimiterHandler(new DefaultListDelimiterHandler(','));</span>
<span class="fc" id="L153">        config.setProperty(&quot;tables.table(0).name&quot;, &quot;resources&quot;);</span>
<span class="fc" id="L154">        assertEquals(&quot;resources&quot;, config.getString(&quot;tables.table(0).name&quot;));</span>
<span class="fc" id="L155">        config.setProperty(&quot;tables.table.name&quot;, &quot;tab1,tab2&quot;);</span>
<span class="fc" id="L156">        assertEquals(&quot;tab1&quot;, config.getString(&quot;tables.table(0).name&quot;));</span>
<span class="fc" id="L157">        assertEquals(&quot;tab2&quot;, config.getString(&quot;tables.table(1).name&quot;));</span>

<span class="fc" id="L159">        config.setProperty(&quot;test.items.item&quot;, new int[] { 2, 4, 8, 16 });</span>
<span class="fc" id="L160">        assertEquals(3, config.getMaxIndex(&quot;test.items.item&quot;));</span>
<span class="fc" id="L161">        assertEquals(8, config.getInt(&quot;test.items.item(2)&quot;));</span>
<span class="fc" id="L162">        config.setProperty(&quot;test.items.item(2)&quot;, new Integer(6));</span>
<span class="fc" id="L163">        assertEquals(6, config.getInt(&quot;test.items.item(2)&quot;));</span>
<span class="fc" id="L164">        config.setProperty(&quot;test.items.item(2)&quot;, new int[] { 7, 9, 11 });</span>
<span class="fc" id="L165">        assertEquals(5, config.getMaxIndex(&quot;test.items.item&quot;));</span>

<span class="fc" id="L167">        config.setProperty(&quot;test&quot;, Boolean.TRUE);</span>
<span class="fc" id="L168">        config.setProperty(&quot;test.items&quot;, &quot;01/01/05&quot;);</span>
<span class="fc" id="L169">        assertEquals(5, config.getMaxIndex(&quot;test.items.item&quot;));</span>
<span class="fc" id="L170">        assertTrue(config.getBoolean(&quot;test&quot;));</span>
<span class="fc" id="L171">        assertEquals(&quot;01/01/05&quot;, config.getProperty(&quot;test.items&quot;));</span>

<span class="fc" id="L173">        config.setProperty(&quot;test.items.item&quot;, new Integer(42));</span>
<span class="fc" id="L174">        assertEquals(0, config.getMaxIndex(&quot;test.items.item&quot;));</span>
<span class="fc" id="L175">        assertEquals(42, config.getInt(&quot;test.items.item&quot;));</span>
<span class="fc" id="L176">    }</span>

    @Test
    public void testClear()
    {
<span class="fc" id="L181">        config.setProperty(null, &quot;value&quot;);</span>
<span class="fc" id="L182">        config.addProperty(&quot;[@attr]&quot;, &quot;defined&quot;);</span>
<span class="fc" id="L183">        config.clear();</span>
<span class="fc" id="L184">        assertTrue(&quot;Configuration not empty&quot;, config.isEmpty());</span>
<span class="fc" id="L185">    }</span>

    @Test
    public void testClearProperty()
    {
<span class="fc" id="L190">        config.clearProperty(&quot;tables.table(0).fields.field(0).name&quot;);</span>
<span class="fc" id="L191">        assertEquals(&quot;uname&quot;, config.getProperty(&quot;tables.table(0).fields.field(0).name&quot;));</span>
<span class="fc" id="L192">        config.clearProperty(&quot;tables.table(0).name&quot;);</span>
<span class="fc" id="L193">        assertFalse(config.containsKey(&quot;tables.table(0).name&quot;));</span>
<span class="fc" id="L194">        assertEquals(&quot;firstName&quot;, config.getProperty(&quot;tables.table(0).fields.field(1).name&quot;));</span>
<span class="fc" id="L195">        assertEquals(&quot;documents&quot;, config.getProperty(&quot;tables.table.name&quot;));</span>
<span class="fc" id="L196">        config.clearProperty(&quot;tables.table&quot;);</span>
<span class="fc" id="L197">        assertEquals(&quot;documents&quot;, config.getProperty(&quot;tables.table.name&quot;));</span>

<span class="fc" id="L199">        config.addProperty(&quot;test&quot;, &quot;first&quot;);</span>
<span class="fc" id="L200">        config.addProperty(&quot;test.level&quot;, &quot;second&quot;);</span>
<span class="fc" id="L201">        config.clearProperty(&quot;test&quot;);</span>
<span class="fc" id="L202">        assertEquals(&quot;second&quot;, config.getString(&quot;test.level&quot;));</span>
<span class="fc" id="L203">        assertFalse(config.containsKey(&quot;test&quot;));</span>
<span class="fc" id="L204">    }</span>

    @Test
    public void testClearTree()
    {
<span class="fc" id="L209">        Object prop = config.getProperty(&quot;tables.table(0).fields.field.name&quot;);</span>
<span class="fc" id="L210">        assertNotNull(prop);</span>
<span class="fc" id="L211">        config.clearTree(&quot;tables.table(0).fields.field(3)&quot;);</span>
<span class="fc" id="L212">        prop = config.getProperty(&quot;tables.table(0).fields.field.name&quot;);</span>
<span class="fc" id="L213">        assertNotNull(prop);</span>
<span class="fc" id="L214">        assertTrue(prop instanceof Collection);</span>
<span class="fc" id="L215">        assertEquals(4, ((Collection&lt;?&gt;) prop).size());</span>

<span class="fc" id="L217">        config.clearTree(&quot;tables.table(0).fields&quot;);</span>
<span class="fc" id="L218">        assertNull(config.getProperty(&quot;tables.table(0).fields.field.name&quot;));</span>
<span class="fc" id="L219">        prop = config.getProperty(&quot;tables.table.fields.field.name&quot;);</span>
<span class="fc" id="L220">        assertNotNull(prop);</span>
<span class="fc" id="L221">        assertTrue(prop instanceof Collection);</span>
<span class="fc" id="L222">        assertEquals(NodeStructureHelper.fieldsLength(1), ((Collection&lt;?&gt;) prop).size());</span>

<span class="fc" id="L224">        config.clearTree(&quot;tables.table(1)&quot;);</span>
<span class="fc" id="L225">        assertNull(config.getProperty(&quot;tables.table.fields.field.name&quot;));</span>
<span class="fc" id="L226">    }</span>

    /**
     * Tests removing more complex node structures.
     */
    @Test
    public void testClearTreeComplex()
    {
<span class="fc" id="L234">        final int count = 5;</span>
        // create the structure
<span class="fc bfc" id="L236" title="All 2 branches covered.">        for (int idx = 0; idx &lt; count; idx++)</span>
        {
<span class="fc" id="L238">            config.addProperty(&quot;indexList.index(-1)[@default]&quot;, Boolean.FALSE);</span>
<span class="fc" id="L239">            config.addProperty(&quot;indexList.index[@name]&quot;, &quot;test&quot; + idx);</span>
<span class="fc" id="L240">            config.addProperty(&quot;indexList.index.dir&quot;, &quot;testDir&quot; + idx);</span>
        }
<span class="fc" id="L242">        assertEquals(&quot;Wrong number of nodes&quot;, count - 1, config</span>
<span class="fc" id="L243">                .getMaxIndex(&quot;indexList.index[@name]&quot;));</span>

        // Remove a sub tree
<span class="fc" id="L246">        boolean found = false;</span>
<span class="fc" id="L247">        for (int idx = 0; true; idx++)</span>
        {
<span class="fc" id="L249">            String name = config.getString(&quot;indexList.index(&quot; + idx</span>
                    + &quot;)[@name]&quot;);
<span class="fc bfc" id="L251" title="All 2 branches covered.">            if (name == null)</span>
            {
<span class="fc" id="L253">                break;</span>
            }
<span class="fc bfc" id="L255" title="All 2 branches covered.">            if (&quot;test3&quot;.equals(name))</span>
            {
<span class="fc" id="L257">                assertEquals(&quot;Wrong dir&quot;, &quot;testDir3&quot;, config</span>
<span class="fc" id="L258">                        .getString(&quot;indexList.index(&quot; + idx + &quot;).dir&quot;));</span>
<span class="fc" id="L259">                config.clearTree(&quot;indexList.index(&quot; + idx + &quot;)&quot;);</span>
<span class="fc" id="L260">                found = true;</span>
            }
        }
<span class="fc" id="L263">        assertTrue(&quot;Key to remove not found&quot;, found);</span>
<span class="fc" id="L264">        assertEquals(&quot;Wrong number of nodes after remove&quot;, count - 2, config</span>
<span class="fc" id="L265">                .getMaxIndex(&quot;indexList.index[@name]&quot;));</span>
<span class="fc" id="L266">        assertEquals(&quot;Wrong number of dir nodes after remove&quot;, count - 2,</span>
<span class="fc" id="L267">                config.getMaxIndex(&quot;indexList.index.dir&quot;));</span>

        // Verify
<span class="fc" id="L270">        for (int idx = 0; true; idx++)</span>
        {
<span class="fc" id="L272">            String name = config.getString(&quot;indexList.index(&quot; + idx</span>
                    + &quot;)[@name]&quot;);
<span class="fc bfc" id="L274" title="All 2 branches covered.">            if (name == null)</span>
            {
<span class="fc" id="L276">                break;</span>
            }
<span class="pc bpc" id="L278" title="1 of 2 branches missed.">            if (&quot;test3&quot;.equals(name))</span>
            {
<span class="nc" id="L280">                fail(&quot;Key was not removed!&quot;);</span>
            }
        }
<span class="fc" id="L283">    }</span>

    /**
     * Tests the clearTree() method on a hierarchical structure of nodes. This
     * is a test case for CONFIGURATION-293.
     */
    @Test
    public void testClearTreeHierarchy()
    {
<span class="fc" id="L292">        config.addProperty(&quot;a.b.c&quot;, &quot;c&quot;);</span>
<span class="fc" id="L293">        config.addProperty(&quot;a.b.c.d&quot;, &quot;d&quot;);</span>
<span class="fc" id="L294">        config.addProperty(&quot;a.b.c.d.e&quot;, &quot;e&quot;);</span>
<span class="fc" id="L295">        config.clearTree(&quot;a.b.c&quot;);</span>
<span class="fc" id="L296">        assertFalse(&quot;Property not removed&quot;, config.containsKey(&quot;a.b.c&quot;));</span>
<span class="fc" id="L297">        assertFalse(&quot;Sub property not removed&quot;, config.containsKey(&quot;a.b.c.d&quot;));</span>
<span class="fc" id="L298">    }</span>

    @Test
    public void testContainsKey()
    {
<span class="fc" id="L303">        assertTrue(config.containsKey(&quot;tables.table(0).name&quot;));</span>
<span class="fc" id="L304">        assertTrue(config.containsKey(&quot;tables.table(1).name&quot;));</span>
<span class="fc" id="L305">        assertFalse(config.containsKey(&quot;tables.table(2).name&quot;));</span>

<span class="fc" id="L307">        assertTrue(config.containsKey(&quot;tables.table(0).fields.field.name&quot;));</span>
<span class="fc" id="L308">        assertFalse(config.containsKey(&quot;tables.table(0).fields.field&quot;));</span>
<span class="fc" id="L309">        config.clearTree(&quot;tables.table(0).fields&quot;);</span>
<span class="fc" id="L310">        assertFalse(config.containsKey(&quot;tables.table(0).fields.field.name&quot;));</span>

<span class="fc" id="L312">        assertTrue(config.containsKey(&quot;tables.table.fields.field.name&quot;));</span>
<span class="fc" id="L313">    }</span>

    @Test
    public void testGetKeys()
    {
<span class="fc" id="L318">        List&lt;String&gt; keys = new ArrayList&lt;String&gt;();</span>
<span class="fc bfc" id="L319" title="All 2 branches covered.">        for (Iterator&lt;String&gt; it = config.getKeys(); it.hasNext();)</span>
        {
<span class="fc" id="L321">            keys.add(it.next());</span>
        }

<span class="fc" id="L324">        assertEquals(2, keys.size());</span>
<span class="fc" id="L325">        assertTrue(keys.contains(&quot;tables.table.name&quot;));</span>
<span class="fc" id="L326">        assertTrue(keys.contains(&quot;tables.table.fields.field.name&quot;));</span>
<span class="fc" id="L327">    }</span>

    /**
     * Tests whether keys are returned in a defined order.
     */
    @Test
    public void testGetKeysOrder()
    {
<span class="fc" id="L335">        config.addProperty(&quot;order.key1&quot;, &quot;value1&quot;);</span>
<span class="fc" id="L336">        config.addProperty(&quot;order.key2&quot;, &quot;value2&quot;);</span>
<span class="fc" id="L337">        config.addProperty(&quot;order.key3&quot;, &quot;value3&quot;);</span>

<span class="fc" id="L339">        Iterator&lt;String&gt; it = config.getKeys(&quot;order&quot;);</span>
<span class="fc" id="L340">        assertEquals(&quot;1st key&quot;, &quot;order.key1&quot;, it.next());</span>
<span class="fc" id="L341">        assertEquals(&quot;2nd key&quot;, &quot;order.key2&quot;, it.next());</span>
<span class="fc" id="L342">        assertEquals(&quot;3rd key&quot;, &quot;order.key3&quot;, it.next());</span>
<span class="fc" id="L343">    }</span>

    /**
     * Tests whether attribute keys are contained in the iteration of keys.
     */
    @Test
    public void testGetKeysAttribute()
    {
<span class="fc" id="L351">        config.addProperty(&quot;tables.table(0)[@type]&quot;, &quot;system&quot;);</span>
<span class="fc" id="L352">        Set&lt;String&gt; keys = new HashSet&lt;String&gt;();</span>
<span class="fc bfc" id="L353" title="All 2 branches covered.">        for (Iterator&lt;String&gt; it = config.getKeys(); it.hasNext();)</span>
        {
<span class="fc" id="L355">            keys.add(it.next());</span>
        }
<span class="fc" id="L357">        assertTrue(&quot;Attribute key not found: &quot; + keys, keys.contains(&quot;tables.table[@type]&quot;));</span>
<span class="fc" id="L358">    }</span>

    /**
     * Tests whether a prefix that points to an attribute is correctly handled.
     */
    @Test
    public void testGetKeysAttributePrefix()
    {
<span class="fc" id="L366">        config.addProperty(&quot;tables.table(0)[@type]&quot;, &quot;system&quot;);</span>
<span class="fc" id="L367">        Iterator&lt;String&gt; itKeys = config.getKeys(&quot;tables.table[@type]&quot;);</span>
<span class="fc" id="L368">        assertEquals(&quot;Wrong key&quot;, &quot;tables.table[@type]&quot;, itKeys.next());</span>
<span class="fc" id="L369">        assertFalse(&quot;Too many keys&quot;, itKeys.hasNext());</span>
<span class="fc" id="L370">    }</span>

    @Test
    public void testGetKeysString()
    {
        // add some more properties to make it more interesting
<span class="fc" id="L376">        config.addProperty(&quot;tables.table(0).fields.field(1).type&quot;, &quot;VARCHAR&quot;);</span>
<span class="fc" id="L377">        config.addProperty(&quot;tables.table(0)[@type]&quot;, &quot;system&quot;);</span>
<span class="fc" id="L378">        config.addProperty(&quot;tables.table(0).size&quot;, &quot;42&quot;);</span>
<span class="fc" id="L379">        config.addProperty(&quot;tables.table(0).fields.field(0).size&quot;, &quot;128&quot;);</span>
<span class="fc" id="L380">        config.addProperty(&quot;connections.connection.param.url&quot;, &quot;url1&quot;);</span>
<span class="fc" id="L381">        config.addProperty(&quot;connections.connection.param.user&quot;, &quot;me&quot;);</span>
<span class="fc" id="L382">        config.addProperty(&quot;connections.connection.param.pwd&quot;, &quot;secret&quot;);</span>
<span class="fc" id="L383">        config.addProperty(&quot;connections.connection(-1).param.url&quot;, &quot;url2&quot;);</span>
<span class="fc" id="L384">        config.addProperty(&quot;connections.connection(1).param.user&quot;, &quot;guest&quot;);</span>

<span class="fc" id="L386">        checkKeys(&quot;tables.table(1)&quot;, new String[] { &quot;name&quot;, &quot;fields.field.name&quot; });</span>
<span class="fc" id="L387">        checkKeys(&quot;tables.table(0)&quot;,</span>
                new String[]{&quot;name&quot;, &quot;fields.field.name&quot;, &quot;tables.table(0)[@type]&quot;, &quot;size&quot;, &quot;fields.field.type&quot;, &quot;fields.field.size&quot;});
<span class="fc" id="L389">        checkKeys(&quot;connections.connection(0).param&quot;,</span>
                new String[]{&quot;url&quot;, &quot;user&quot;, &quot;pwd&quot;});
<span class="fc" id="L391">        checkKeys(&quot;connections.connection(1).param&quot;,</span>
                new String[]{&quot;url&quot;, &quot;user&quot;});
<span class="fc" id="L393">    }</span>

    /**
     * Tests getKeys() with a prefix when the prefix matches exactly a key.
     */
    @Test
    public void testGetKeysWithKeyAsPrefix()
    {
<span class="fc" id="L401">        config.addProperty(&quot;order.key1&quot;, &quot;value1&quot;);</span>
<span class="fc" id="L402">        config.addProperty(&quot;order.key2&quot;, &quot;value2&quot;);</span>
<span class="fc" id="L403">        Iterator&lt;String&gt; it = config.getKeys(&quot;order.key1&quot;);</span>
<span class="fc" id="L404">        assertTrue(&quot;no key found&quot;, it.hasNext());</span>
<span class="fc" id="L405">        assertEquals(&quot;1st key&quot;, &quot;order.key1&quot;, it.next());</span>
<span class="fc" id="L406">        assertFalse(&quot;more keys than expected&quot;, it.hasNext());</span>
<span class="fc" id="L407">    }</span>

    /**
     * Tests getKeys() with a prefix when the prefix matches exactly a key, and
     * there are multiple keys starting with this prefix.
     */
    @Test
    public void testGetKeysWithKeyAsPrefixMultiple()
    {
<span class="fc" id="L416">        config.addProperty(&quot;order.key1&quot;, &quot;value1&quot;);</span>
<span class="fc" id="L417">        config.addProperty(&quot;order.key1.test&quot;, &quot;value2&quot;);</span>
<span class="fc" id="L418">        config.addProperty(&quot;order.key1.test.complex&quot;, &quot;value2&quot;);</span>
<span class="fc" id="L419">        Iterator&lt;String&gt; it = config.getKeys(&quot;order.key1&quot;);</span>
<span class="fc" id="L420">        assertEquals(&quot;Wrong key 1&quot;, &quot;order.key1&quot;, it.next());</span>
<span class="fc" id="L421">        assertEquals(&quot;Wrong key 2&quot;, &quot;order.key1.test&quot;, it.next());</span>
<span class="fc" id="L422">        assertEquals(&quot;Wrong key 3&quot;, &quot;order.key1.test.complex&quot;, it.next());</span>
<span class="fc" id="L423">        assertFalse(&quot;More keys than expected&quot;, it.hasNext());</span>
<span class="fc" id="L424">    }</span>

    /**
     * Tests whether the correct size is calculated.
     */
    @Test
    public void testSize()
    {
<span class="fc" id="L432">        assertEquals(&quot;Wrong size&quot;, 2, config.size());</span>
<span class="fc" id="L433">    }</span>

    @Test
    public void testAddProperty()
    {
<span class="fc" id="L438">        config.addProperty(&quot;tables.table(0).fields.field(-1).name&quot;, &quot;phone&quot;);</span>
<span class="fc" id="L439">        Object prop = config.getProperty(&quot;tables.table(0).fields.field.name&quot;);</span>
<span class="fc" id="L440">        assertNotNull(prop);</span>
<span class="fc" id="L441">        assertTrue(prop instanceof Collection);</span>
<span class="fc" id="L442">        assertEquals(6, ((Collection&lt;?&gt;) prop).size());</span>

<span class="fc" id="L444">        config.addProperty(&quot;tables.table(0).fields.field.name&quot;, &quot;fax&quot;);</span>
<span class="fc" id="L445">        prop = config.getProperty(&quot;tables.table.fields.field(5).name&quot;);</span>
<span class="fc" id="L446">        assertNotNull(prop);</span>
<span class="fc" id="L447">        assertTrue(prop instanceof List);</span>
<span class="fc" id="L448">        List&lt;?&gt; list = (List&lt;?&gt;) prop;</span>
<span class="fc" id="L449">        assertEquals(&quot;phone&quot;, list.get(0));</span>
<span class="fc" id="L450">        assertEquals(&quot;fax&quot;, list.get(1));</span>

<span class="fc" id="L452">        config.addProperty(&quot;tables.table(-1).name&quot;, &quot;config&quot;);</span>
<span class="fc" id="L453">        prop = config.getProperty(&quot;tables.table.name&quot;);</span>
<span class="fc" id="L454">        assertNotNull(prop);</span>
<span class="fc" id="L455">        assertTrue(prop instanceof Collection);</span>
<span class="fc" id="L456">        assertEquals(3, ((Collection&lt;?&gt;) prop).size());</span>
<span class="fc" id="L457">        config.addProperty(&quot;tables.table(2).fields.field(0).name&quot;, &quot;cid&quot;);</span>
<span class="fc" id="L458">        config.addProperty(&quot;tables.table(2).fields.field(-1).name&quot;,</span>
        &quot;confName&quot;);
<span class="fc" id="L460">        prop = config.getProperty(&quot;tables.table(2).fields.field.name&quot;);</span>
<span class="fc" id="L461">        assertNotNull(prop);</span>
<span class="fc" id="L462">        assertTrue(prop instanceof Collection);</span>
<span class="fc" id="L463">        assertEquals(2, ((Collection&lt;?&gt;) prop).size());</span>
<span class="fc" id="L464">        assertEquals(&quot;confName&quot;,</span>
<span class="fc" id="L465">        config.getProperty(&quot;tables.table(2).fields.field(1).name&quot;));</span>

<span class="fc" id="L467">        config.addProperty(&quot;connection.user&quot;, &quot;scott&quot;);</span>
<span class="fc" id="L468">        config.addProperty(&quot;connection.passwd&quot;, &quot;tiger&quot;);</span>
<span class="fc" id="L469">        assertEquals(&quot;tiger&quot;, config.getProperty(&quot;connection.passwd&quot;));</span>

<span class="fc" id="L471">        DefaultConfigurationKey key = createConfigurationKey();</span>
<span class="fc" id="L472">        key.append(&quot;tables&quot;).append(&quot;table&quot;).appendIndex(0);</span>
<span class="fc" id="L473">        key.appendAttribute(&quot;tableType&quot;);</span>
<span class="fc" id="L474">        config.addProperty(key.toString(), &quot;system&quot;);</span>
<span class="fc" id="L475">        assertEquals(&quot;system&quot;, config.getProperty(key.toString()));</span>
<span class="fc" id="L476">    }</span>

    /**
     * Creates a {@code DefaultConfigurationKey} object.
     *
     * @return the new key object
     */
    private static DefaultConfigurationKey createConfigurationKey()
    {
<span class="fc" id="L485">        return new DefaultConfigurationKey(DefaultExpressionEngine.INSTANCE);</span>
    }

    @Test(expected = IllegalArgumentException.class)
    public void testAddPropertyInvalidKey()
    {
<span class="nc" id="L491">        config.addProperty(&quot;.&quot;, &quot;InvalidKey&quot;);</span>
<span class="nc" id="L492">    }</span>

    @Test
    public void testGetMaxIndex()
    {
<span class="fc" id="L497">        assertEquals(NodeStructureHelper.fieldsLength(0) - 1,</span>
<span class="fc" id="L498">                config.getMaxIndex(&quot;tables.table(0).fields.field&quot;));</span>
<span class="fc" id="L499">        assertEquals(NodeStructureHelper.fieldsLength(1) - 1,</span>
<span class="fc" id="L500">                config.getMaxIndex(&quot;tables.table(1).fields.field&quot;));</span>
<span class="fc" id="L501">        assertEquals(1, config.getMaxIndex(&quot;tables.table&quot;));</span>
<span class="fc" id="L502">        assertEquals(1, config.getMaxIndex(&quot;tables.table.name&quot;));</span>
<span class="fc" id="L503">        assertEquals(0, config.getMaxIndex(&quot;tables.table(0).name&quot;));</span>
<span class="fc" id="L504">        assertEquals(0, config.getMaxIndex(&quot;tables.table(1).fields.field(1)&quot;));</span>
<span class="fc" id="L505">        assertEquals(-1, config.getMaxIndex(&quot;tables.table(2).fields&quot;));</span>

<span class="fc" id="L507">        int maxIdx = config.getMaxIndex(&quot;tables.table(0).fields.field.name&quot;);</span>
<span class="fc bfc" id="L508" title="All 2 branches covered.">        for(int i = 0; i &lt;= maxIdx; i++)</span>
        {
<span class="fc" id="L510">            DefaultConfigurationKey key =</span>
                    new DefaultConfigurationKey(DefaultExpressionEngine.INSTANCE,
                            &quot;tables.table(0).fields&quot;);
<span class="fc" id="L513">            key.append(&quot;field&quot;).appendIndex(i).append(&quot;name&quot;);</span>
<span class="fc" id="L514">            assertNotNull(config.getProperty(key.toString()));</span>
        }
<span class="fc" id="L516">    }</span>

    @Test
    public void testClone()
    {
<span class="fc" id="L521">        Configuration copy = (Configuration) config.clone();</span>
<span class="fc" id="L522">        assertTrue(&quot;Wrong clone result&quot;, copy instanceof AbstractHierarchicalConfiguration);</span>
<span class="fc" id="L523">        checkContent(copy);</span>
<span class="fc" id="L524">    }</span>

    /**
     * Tests whether registered event handlers are handled correctly when a
     * configuration is cloned. They should not be registered at the clone.
     */
    @Test
    public void testCloneWithEventListeners()
    {
<span class="fc" id="L533">        EventListener&lt;ConfigurationEvent&gt; l = new EventListenerTestImpl(null);</span>
<span class="fc" id="L534">        config.addEventListener(ConfigurationEvent.ANY, l);</span>
<span class="fc" id="L535">        AbstractHierarchicalConfiguration&lt;?&gt; copy =</span>
<span class="fc" id="L536">                (AbstractHierarchicalConfiguration&lt;?&gt;) config.clone();</span>
<span class="fc" id="L537">        assertFalse(&quot;Event listener registered at clone&quot;, copy</span>
<span class="fc" id="L538">                .getEventListeners(ConfigurationEvent.ANY).contains(l));</span>
<span class="fc" id="L539">    }</span>

    /**
     * Tests whether interpolation works as expected after cloning.
     */
    @Test
    public void testCloneInterpolation()
    {
<span class="fc" id="L547">        final String keyAnswer = &quot;answer&quot;;</span>
<span class="fc" id="L548">        final String keyValue = &quot;value&quot;;</span>
<span class="fc" id="L549">        config.addProperty(keyAnswer, &quot;The answer is ${&quot; + keyValue + &quot;}.&quot;);</span>
<span class="fc" id="L550">        config.addProperty(keyValue, 42);</span>
<span class="fc" id="L551">        Configuration clone = (Configuration) config.clone();</span>
<span class="fc" id="L552">        clone.setProperty(keyValue, 43);</span>
<span class="fc" id="L553">        assertEquals(&quot;Wrong interpolation in original&quot;, &quot;The answer is 42.&quot;,</span>
<span class="fc" id="L554">                config.getString(keyAnswer));</span>
<span class="fc" id="L555">        assertEquals(&quot;Wrong interpolation in clone&quot;, &quot;The answer is 43.&quot;,</span>
<span class="fc" id="L556">                clone.getString(keyAnswer));</span>
<span class="fc" id="L557">    }</span>

    @Test
    public void testAddNodes()
    {
<span class="fc" id="L562">        Collection&lt;ImmutableNode&gt; nodes = new ArrayList&lt;ImmutableNode&gt;();</span>
<span class="fc" id="L563">        nodes.add(NodeStructureHelper.createFieldNode(&quot;birthDate&quot;));</span>
<span class="fc" id="L564">        nodes.add(NodeStructureHelper.createFieldNode(&quot;lastLogin&quot;));</span>
<span class="fc" id="L565">        nodes.add(NodeStructureHelper.createFieldNode(&quot;language&quot;));</span>
<span class="fc" id="L566">        config.addNodes(&quot;tables.table(0).fields&quot;, nodes);</span>
<span class="fc" id="L567">        assertEquals(7, config.getMaxIndex(&quot;tables.table(0).fields.field&quot;));</span>
<span class="fc" id="L568">        assertEquals(&quot;birthDate&quot;, config.getString(&quot;tables.table(0).fields.field(5).name&quot;));</span>
<span class="fc" id="L569">        assertEquals(&quot;lastLogin&quot;, config.getString(&quot;tables.table(0).fields.field(6).name&quot;));</span>
<span class="fc" id="L570">        assertEquals(&quot;language&quot;, config.getString(&quot;tables.table(0).fields.field(7).name&quot;));</span>
<span class="fc" id="L571">    }</span>

    /**
     * Tests the addNodes() method if the provided key does not exist. In
     * this case, a new node (or even a completely new branch) is created.
     */
    @Test
    public void testAddNodesForNonExistingKey()
    {
<span class="fc" id="L580">        Collection&lt;ImmutableNode&gt; nodes = new ArrayList&lt;ImmutableNode&gt;();</span>
<span class="fc" id="L581">        ImmutableNode newNode =</span>
<span class="fc" id="L582">                new ImmutableNode.Builder().name(&quot;usr&quot;).value(&quot;scott&quot;)</span>
<span class="fc" id="L583">                        .addAttribute(&quot;pwd&quot;, &quot;tiger&quot;).create();</span>
<span class="fc" id="L584">        nodes.add(newNode);</span>
<span class="fc" id="L585">        config.addNodes(&quot;database.connection.settings&quot;, nodes);</span>

<span class="fc" id="L587">        assertEquals(&quot;Usr node not found&quot;, &quot;scott&quot;,</span>
<span class="fc" id="L588">                config.getString(&quot;database.connection.settings.usr&quot;));</span>
<span class="fc" id="L589">        assertEquals(&quot;Pwd node not found&quot;, &quot;tiger&quot;,</span>
<span class="fc" id="L590">                config.getString(&quot;database.connection.settings.usr[@pwd]&quot;));</span>
<span class="fc" id="L591">    }</span>

    /**
     * Tests the addNodes() method when the new nodes should be added to an
     * attribute node. This is not allowed.
     */
    @Test(expected = IllegalArgumentException.class)
    public void testAddNodesWithAttributeKey()
    {
<span class="fc" id="L600">        Collection&lt;ImmutableNode&gt; nodes = new ArrayList&lt;ImmutableNode&gt;();</span>
<span class="fc" id="L601">        nodes.add(NodeStructureHelper.createNode(&quot;testNode&quot;, &quot;yes&quot;));</span>
<span class="nc" id="L602">        config.addNodes(&quot;database.connection[@settings]&quot;, nodes);</span>
<span class="nc" id="L603">    }</span>

    /**
     * Tests copying nodes from one configuration to another one.
     */
    @Test
    public void testAddNodesCopy()
    {
<span class="fc" id="L611">        AbstractHierarchicalConfigurationTestImpl configDest =</span>
                new AbstractHierarchicalConfigurationTestImpl(
                        new InMemoryNodeModel());
<span class="fc" id="L614">        configDest.addProperty(&quot;test&quot;, &quot;TEST&quot;);</span>
<span class="fc" id="L615">        Collection&lt;ImmutableNode&gt; nodes = getRootNode().getChildren();</span>
<span class="fc" id="L616">        assertEquals(&quot;Wrong number of children&quot;, 1, nodes.size());</span>
<span class="fc" id="L617">        configDest.addNodes(&quot;newNodes&quot;, nodes);</span>
<span class="fc bfc" id="L618" title="All 2 branches covered.">        for (int i = 0; i &lt; NodeStructureHelper.tablesLength(); i++)</span>
        {
<span class="fc" id="L620">            String keyTab = &quot;newNodes.tables.table(&quot; + i + &quot;).&quot;;</span>
<span class="fc" id="L621">            assertEquals(&quot;Table &quot; + i + &quot; not found&quot;,</span>
<span class="fc" id="L622">                    NodeStructureHelper.table(i),</span>
<span class="fc" id="L623">                    configDest.getString(keyTab + &quot;name&quot;));</span>
<span class="fc bfc" id="L624" title="All 2 branches covered.">            for (int j = 0; j &lt; NodeStructureHelper.fieldsLength(i); j++)</span>
            {
<span class="fc" id="L626">                assertEquals(</span>
                        &quot;Invalid field &quot; + j + &quot; in table &quot; + i,
<span class="fc" id="L628">                        NodeStructureHelper.field(i, j),</span>
<span class="fc" id="L629">                        configDest.getString(keyTab + &quot;fields.field(&quot; + j</span>
                                + &quot;).name&quot;));
            }
        }
<span class="fc" id="L633">    }</span>

    /**
     * Tests setting a custom expression engine, which uses a slightly different
     * syntax.
     */
    @Test
    public void testSetExpressionEngine()
    {
<span class="fc" id="L642">        config.setExpressionEngine(null);</span>
<span class="fc" id="L643">        assertNotNull(&quot;Expression engine is null&quot;, config.getExpressionEngine());</span>
<span class="fc" id="L644">        assertSame(&quot;Default engine is not used&quot;,</span>
<span class="fc" id="L645">                DefaultExpressionEngine.INSTANCE, config.getExpressionEngine());</span>

<span class="fc" id="L647">        config.setExpressionEngine(createAlternativeExpressionEngine());</span>
<span class="fc" id="L648">        checkAlternativeSyntax();</span>
<span class="fc" id="L649">    }</span>

    /**
     * Tests interpolation facilities.
     */
    @Test
    public void testInterpolation()
    {
<span class="fc" id="L657">        config.addProperty(&quot;base.dir&quot;, &quot;/home/foo&quot;);</span>
<span class="fc" id="L658">        config.addProperty(&quot;test.absolute.dir.dir1&quot;, &quot;${base.dir}/path1&quot;);</span>
<span class="fc" id="L659">        config.addProperty(&quot;test.absolute.dir.dir2&quot;, &quot;${base.dir}/path2&quot;);</span>
<span class="fc" id="L660">        config.addProperty(&quot;test.absolute.dir.dir3&quot;, &quot;${base.dir}/path3&quot;);</span>
<span class="fc" id="L661">        Configuration sub = config.subset(&quot;test.absolute.dir&quot;);</span>
<span class="fc bfc" id="L662" title="All 2 branches covered.">        for (int i = 1; i &lt; 4; i++)</span>
        {
<span class="fc" id="L664">            assertEquals(&quot;Wrong interpolation in parent&quot;, &quot;/home/foo/path&quot; + i,</span>
<span class="fc" id="L665">                    config.getString(&quot;test.absolute.dir.dir&quot; + i));</span>
<span class="fc" id="L666">            assertEquals(&quot;Wrong interpolation in subnode&quot;,</span>
<span class="fc" id="L667">                    &quot;/home/foo/path&quot; + i, sub.getString(&quot;dir&quot; + i));</span>
        }
<span class="fc" id="L669">    }</span>

    /**
     * Basic interpolation tests.
     */
    @Test
    public void testInterpolationBasic()
    {
<span class="fc" id="L677">        InterpolationTestHelper.testInterpolation(config);</span>
<span class="fc" id="L678">    }</span>

    /**
     * Tests multiple levels of interpolation.
     */
    @Test
    public void testInterpolationMultipleLevels()
    {
<span class="fc" id="L686">        InterpolationTestHelper.testMultipleInterpolation(config);</span>
<span class="fc" id="L687">    }</span>

    /**
     * Tests an invalid interpolation that causes an endless loop.
     */
    @Test
    public void testInterpolationLoop()
    {
<span class="fc" id="L695">        InterpolationTestHelper.testInterpolationLoop(config);</span>
<span class="fc" id="L696">    }</span>

    /**
     * Tests interpolation with a subset.
     */
    @Test
    public void testInterpolationSubset()
    {
<span class="fc" id="L704">        InterpolationTestHelper.testInterpolationSubset(config);</span>
<span class="fc" id="L705">    }</span>

    /**
     * Tests whether interpolation with a subset configuration works over
     * multiple layers.
     */
    @Test
    public void testInterpolationSubsetMultipleLayers()
    {
<span class="fc" id="L714">        config.clear();</span>
<span class="fc" id="L715">        config.addProperty(&quot;var&quot;, &quot;value&quot;);</span>
<span class="fc" id="L716">        config.addProperty(&quot;prop2.prop[@attr]&quot;, &quot;${var}&quot;);</span>
<span class="fc" id="L717">        Configuration sub1 = config.subset(&quot;prop2&quot;);</span>
<span class="fc" id="L718">        Configuration sub2 = sub1.subset(&quot;prop&quot;);</span>
<span class="fc" id="L719">        assertEquals(&quot;Wrong value&quot;, &quot;value&quot;, sub2.getString(&quot;[@attr]&quot;));</span>
<span class="fc" id="L720">    }</span>

    /**
     * Tests interpolation of a variable, which cannot be resolved.
     */
    @Test
    public void testInterpolationUnknownProperty()
    {
<span class="fc" id="L728">        InterpolationTestHelper.testInterpolationUnknownProperty(config);</span>
<span class="fc" id="L729">    }</span>

    /**
     * Tests interpolation with system properties.
     */
    @Test
    public void testInterpolationSysProperties()
    {
<span class="fc" id="L737">        InterpolationTestHelper.testInterpolationSystemProperties(config);</span>
<span class="fc" id="L738">    }</span>

    /**
     * Tests interpolation with constant values.
     */
    @Test
    public void testInterpolationConstants()
    {
<span class="fc" id="L746">        InterpolationTestHelper.testInterpolationConstants(config);</span>
<span class="fc" id="L747">    }</span>

    /**
     * Tests escaping variables.
     */
    @Test
    public void testInterpolationEscaped()
    {
<span class="fc" id="L755">        InterpolationTestHelper.testInterpolationEscaped(config);</span>
<span class="fc" id="L756">    }</span>

    /**
     * Tests manipulating the interpolator.
     */
    @Test
    public void testInterpolator()
    {
<span class="fc" id="L764">        InterpolationTestHelper.testGetInterpolator(config);</span>
<span class="fc" id="L765">    }</span>

    /**
     * Tests obtaining a configuration with all variables substituted.
     */
    @Test
    public void testInterpolatedConfiguration()
    {
<span class="fc" id="L773">        config.setListDelimiterHandler(new DefaultListDelimiterHandler(','));</span>
<span class="fc" id="L774">        AbstractHierarchicalConfiguration&lt;?&gt; c = (AbstractHierarchicalConfiguration&lt;?&gt;) InterpolationTestHelper</span>
<span class="fc" id="L775">                .testInterpolatedConfiguration(config);</span>

        // tests whether the hierarchical structure has been maintained
<span class="fc" id="L778">        checkGetProperty(c);</span>
<span class="fc" id="L779">    }</span>

    /**
     * Tests the copy constructor when a null reference is passed.
     */
    @Test
    public void testInitCopyNull()
    {
<span class="fc" id="L787">        BaseHierarchicalConfiguration copy =</span>
                new BaseHierarchicalConfiguration(
                        (BaseHierarchicalConfiguration) null);
<span class="fc" id="L790">        assertTrue(&quot;Configuration not empty&quot;, copy.isEmpty());</span>
<span class="fc" id="L791">    }</span>

    /**
     * Tests whether keys that contains brackets can be used.
     */
    @Test
    public void testGetPropertyKeyWithBrackets()
    {
<span class="fc" id="L799">        final String key = &quot;test.directory.platform(x86)&quot;;</span>
<span class="fc" id="L800">        config.addProperty(key, &quot;C:\\Temp&quot;);</span>
<span class="fc" id="L801">        assertEquals(&quot;Wrong property value&quot;, &quot;C:\\Temp&quot;, config.getString(key));</span>
<span class="fc" id="L802">    }</span>

    /**
     * Tests whether list handling works correctly when adding properties.
     */
    @Test
    public void testAddPropertyWithListHandling()
    {
<span class="fc" id="L810">        config.setListDelimiterHandler(new DefaultListDelimiterHandler(','));</span>
<span class="fc" id="L811">        final String key = &quot;list.delimiter.value&quot;;</span>
<span class="fc" id="L812">        config.addProperty(key + &quot;.escaped&quot;, &quot;3\\,1415&quot;);</span>
<span class="fc" id="L813">        config.addProperty(key + &quot;.elements&quot;, &quot;3,1415&quot;);</span>
<span class="fc" id="L814">        assertEquals(&quot;Wrong escaped property&quot;, &quot;3,1415&quot;, config.getString(key + &quot;.escaped&quot;));</span>
<span class="fc" id="L815">        assertEquals(&quot;Wrong list property&quot;, &quot;3&quot;, config.getString(key + &quot;.elements&quot;));</span>
<span class="fc" id="L816">    }</span>

    /**
     * Tests whether node keys can be resolved.
     */
    @Test
    public void testResolveNodeKey()
    {
<span class="fc" id="L824">        List&lt;ImmutableNode&gt; nodes =</span>
<span class="fc" id="L825">                config.resolveNodeKey(getRootNode(),</span>
<span class="fc" id="L826">                        &quot;tables.table.name&quot;, config.getModel().getNodeHandler());</span>
<span class="fc" id="L827">        assertEquals(&quot;Wrong number of nodes&quot;,</span>
<span class="fc" id="L828">                NodeStructureHelper.tablesLength(), nodes.size());</span>
<span class="fc bfc" id="L829" title="All 2 branches covered.">        for (int i = 0; i &lt; NodeStructureHelper.tablesLength(); i++)</span>
        {
<span class="fc" id="L831">            assertEquals(&quot;Wrong node value at &quot; + i,</span>
<span class="fc" id="L832">                    NodeStructureHelper.table(i), nodes.get(i).getValue());</span>
        }
<span class="fc" id="L834">    }</span>

    /**
     * Tests whether attribute keys are filtered out when resolving node keys.
     */
    @Test
    public void testResolveNodeKeyAttribute()
    {
<span class="fc" id="L842">        String attrKey = &quot;tables.table(0)[@type]&quot;;</span>
<span class="fc" id="L843">        config.addProperty(attrKey, &quot;system&quot;);</span>
<span class="fc" id="L844">        assertTrue(</span>
                &quot;Got attribute results&quot;,
<span class="fc" id="L846">                config.resolveNodeKey(getRootNode(), attrKey,</span>
<span class="fc" id="L847">                        config.getModel().getNodeHandler()).isEmpty());</span>
<span class="fc" id="L848">    }</span>

    /**
     * Tests whether a correct node key is generated if no data is contained in
     * the cache.
     */
    @Test
    public void testNodeKeyEmptyCache()
    {
<span class="fc" id="L857">        Map&lt;ImmutableNode, String&gt; cache = new HashMap&lt;ImmutableNode, String&gt;();</span>
<span class="fc" id="L858">        ImmutableNode nodeTabName =</span>
<span class="fc" id="L859">                NodeStructureHelper.nodeForKey(getRootNode(),</span>
                        &quot;tables/table(0)/name&quot;);
<span class="fc" id="L861">        ImmutableNode nodeFldName =</span>
<span class="fc" id="L862">                NodeStructureHelper.nodeForKey(getRootNode(),</span>
                        &quot;tables/table(0)/fields/field(1)/name&quot;);
<span class="fc" id="L864">        assertEquals(&quot;Wrong key (1)&quot;, &quot;tables(0).table(0).name(0)&quot;,</span>
<span class="fc" id="L865">                config.nodeKey(nodeTabName, cache, config.getModel()</span>
<span class="fc" id="L866">                        .getNodeHandler()));</span>
<span class="fc" id="L867">        assertEquals(&quot;Wrong key (2)&quot;,</span>
                &quot;tables(0).table(0).fields(0).field(1).name(0)&quot;,
<span class="fc" id="L869">                config.nodeKey(nodeFldName, cache, config.getModel()</span>
<span class="fc" id="L870">                        .getNodeHandler()));</span>
<span class="fc" id="L871">    }</span>

    /**
     * Tests whether the cache map is filled while generating node keys.
     */
    @Test
    public void testNodeKeyCachePopulated()
    {
<span class="fc" id="L879">        Map&lt;ImmutableNode, String&gt; cache = new HashMap&lt;ImmutableNode, String&gt;();</span>
<span class="fc" id="L880">        ImmutableNode nodeTabName =</span>
<span class="fc" id="L881">                NodeStructureHelper.nodeForKey(getRootNode(),</span>
                        &quot;tables/table(0)/name&quot;);
<span class="fc" id="L883">        NodeHandler&lt;ImmutableNode&gt; handler = config.getModel().getNodeHandler();</span>
<span class="fc" id="L884">        config.nodeKey(nodeTabName, cache, handler);</span>
<span class="fc" id="L885">        assertEquals(&quot;Wrong number of elements&quot;, 4, cache.size());</span>
<span class="fc" id="L886">        assertEquals(&quot;Wrong entry (1)&quot;, &quot;tables(0).table(0).name(0)&quot;,</span>
<span class="fc" id="L887">                cache.get(nodeTabName));</span>
<span class="fc" id="L888">        assertEquals(&quot;Wrong entry (2)&quot;, &quot;tables(0).table(0)&quot;,</span>
<span class="fc" id="L889">                cache.get(handler.getParent(nodeTabName)));</span>
<span class="fc" id="L890">        assertEquals(&quot;Wrong entry (3)&quot;, &quot;tables(0)&quot;,</span>
<span class="fc" id="L891">                cache.get(handler.getParent(handler.getParent(nodeTabName))));</span>
<span class="fc" id="L892">        assertEquals(&quot;Wrong root entry&quot;, &quot;&quot;, cache.get(getRootNode()));</span>
<span class="fc" id="L893">    }</span>

    /**
     * Tests whether the cache is used by nodeKey().
     */
    @Test
    public void testNodeKeyCacheUsage()
    {
<span class="fc" id="L901">        Map&lt;ImmutableNode, String&gt; cache = new HashMap&lt;ImmutableNode, String&gt;();</span>
<span class="fc" id="L902">        ImmutableNode nodeTabName =</span>
<span class="fc" id="L903">                NodeStructureHelper.nodeForKey(getRootNode(),</span>
                        &quot;tables/table(0)/name&quot;);
<span class="fc" id="L905">        NodeHandler&lt;ImmutableNode&gt; handler = config.getModel().getNodeHandler();</span>
<span class="fc" id="L906">        cache.put(handler.getParent(nodeTabName), &quot;somePrefix&quot;);</span>
<span class="fc" id="L907">        assertEquals(&quot;Wrong key&quot;, &quot;somePrefix.name(0)&quot;,</span>
<span class="fc" id="L908">                config.nodeKey(nodeTabName, cache, handler));</span>
<span class="fc" id="L909">    }</span>

    /**
     * Tests whether a node key for the root node can be generated.
     */
    @Test
    public void testNodeKeyRootNode()
    {
<span class="fc" id="L917">        Map&lt;ImmutableNode, String&gt; cache = new HashMap&lt;ImmutableNode, String&gt;();</span>
<span class="fc" id="L918">        assertEquals(&quot;Wrong root node key&quot;, &quot;&quot;,</span>
<span class="fc" id="L919">                config.nodeKey(getRootNode(), cache, config.getModel()</span>
<span class="fc" id="L920">                        .getNodeHandler()));</span>
<span class="fc" id="L921">    }</span>

    /**
     * Tests nodeKey() if the key is directly found in the cache.
     */
    @Test
    public void testNodeKeyCacheHit()
    {
<span class="fc" id="L929">        Map&lt;ImmutableNode, String&gt; cache = new HashMap&lt;ImmutableNode, String&gt;();</span>
<span class="fc" id="L930">        final String key = &quot;someResultKey&quot;;</span>
<span class="fc" id="L931">        cache.put(getRootNode(), key);</span>
<span class="fc" id="L932">        assertEquals(&quot;Wrong result&quot;, key, config.nodeKey(getRootNode(),</span>
<span class="fc" id="L933">                cache, config.getModel().getNodeHandler()));</span>
<span class="fc" id="L934">    }</span>

    /**
     * Tests whether the configuration's node model can be correctly accessed.
     */
    @Test
    public void testGetNodeModel()
    {
<span class="fc" id="L942">        SynchronizerTestImpl sync = new SynchronizerTestImpl();</span>
<span class="fc" id="L943">        config.setSynchronizer(sync);</span>
<span class="fc" id="L944">        NodeModel&lt;ImmutableNode&gt; model = config.getNodeModel();</span>

<span class="fc" id="L946">        assertTrue(&quot;Wrong node model: &quot; + model,</span>
                model instanceof InMemoryNodeModel);
<span class="fc" id="L948">        ImmutableNode rootNode = model.getNodeHandler().getRootNode();</span>
<span class="fc" id="L949">        assertEquals(&quot;Wrong number of children of root node&quot;, 1, rootNode</span>
<span class="fc" id="L950">                .getChildren().size());</span>
<span class="fc" id="L951">        assertTrue(&quot;Wrong children of root node&quot;, rootNode.getChildren()</span>
<span class="fc" id="L952">                .contains(NodeStructureHelper.ROOT_TABLES_TREE));</span>
<span class="fc" id="L953">        sync.verify(SynchronizerTestImpl.Methods.BEGIN_READ,</span>
                SynchronizerTestImpl.Methods.END_READ);
<span class="fc" id="L955">    }</span>

    /**
     * Helper method for testing the getKeys(String) method.
     *
     * @param prefix the key to pass into getKeys()
     * @param expected the expected result
     */
    private void checkKeys(String prefix, String[] expected)
    {
<span class="fc" id="L965">        Set&lt;String&gt; values = new HashSet&lt;String&gt;();</span>
<span class="fc bfc" id="L966" title="All 2 branches covered.">        for (String anExpected : expected) {</span>
<span class="fc bfc" id="L967" title="All 2 branches covered.">            values.add((anExpected.startsWith(prefix)) ? anExpected : prefix + &quot;.&quot; + anExpected);</span>
        }

<span class="fc" id="L970">        Iterator&lt;String&gt; itKeys = config.getKeys(prefix);</span>
<span class="fc bfc" id="L971" title="All 2 branches covered.">        while(itKeys.hasNext())</span>
        {
<span class="fc" id="L973">            String key = itKeys.next();</span>
<span class="pc bpc" id="L974" title="1 of 2 branches missed.">            if(!values.contains(key))</span>
            {
<span class="nc" id="L976">                fail(&quot;Found unexpected key: &quot; + key);</span>
            }
            else
            {
<span class="fc" id="L980">                values.remove(key);</span>
            }
<span class="fc" id="L982">        }</span>

<span class="fc" id="L984">        assertTrue(&quot;Remaining keys &quot; + values, values.isEmpty());</span>
<span class="fc" id="L985">    }</span>

    /**
     * Helper method for checking keys using an alternative syntax.
     */
    private void checkAlternativeSyntax()
    {
<span class="fc" id="L992">        assertNull(config.getProperty(&quot;tables/table/resultset&quot;));</span>
<span class="fc" id="L993">        assertNull(config.getProperty(&quot;tables/table/fields/field&quot;));</span>

<span class="fc" id="L995">        Object prop = config.getProperty(&quot;tables/table[0]/fields/field/name&quot;);</span>
<span class="fc" id="L996">        assertNotNull(prop);</span>
<span class="fc" id="L997">        assertTrue(prop instanceof Collection);</span>
<span class="fc" id="L998">        assertEquals(NodeStructureHelper.fieldsLength(0), ((Collection&lt;?&gt;) prop).size());</span>

<span class="fc" id="L1000">        prop = config.getProperty(&quot;tables/table/fields/field/name&quot;);</span>
<span class="fc" id="L1001">        assertNotNull(prop);</span>
<span class="fc" id="L1002">        assertTrue(prop instanceof Collection);</span>
<span class="fc" id="L1003">        assertEquals(totalFieldCount(), ((Collection&lt;?&gt;) prop).size());</span>

<span class="fc" id="L1005">        prop = config.getProperty(&quot;tables/table/fields/field[3]/name&quot;);</span>
<span class="fc" id="L1006">        assertNotNull(prop);</span>
<span class="fc" id="L1007">        assertTrue(prop instanceof Collection);</span>
<span class="fc" id="L1008">        assertEquals(2, ((Collection&lt;?&gt;) prop).size());</span>

<span class="fc" id="L1010">        prop = config.getProperty(&quot;tables/table[1]/fields/field[2]/name&quot;);</span>
<span class="fc" id="L1011">        assertNotNull(prop);</span>
<span class="fc" id="L1012">        assertEquals(&quot;creationDate&quot;, prop.toString());</span>

<span class="fc" id="L1014">        Set&lt;String&gt; keys = ConfigurationAssert.keysToSet(config);</span>
<span class="fc" id="L1015">        assertEquals(&quot;Wrong number of defined keys&quot;, 2, keys.size());</span>
<span class="fc" id="L1016">        assertTrue(&quot;Key not found&quot;, keys.contains(&quot;tables/table/name&quot;));</span>
<span class="fc" id="L1017">        assertTrue(&quot;Key not found&quot;, keys</span>
<span class="fc" id="L1018">                .contains(&quot;tables/table/fields/field/name&quot;));</span>
<span class="fc" id="L1019">    }</span>

    /**
     * Returns the total number of fields in the test data structure.
     *
     * @return the total number of fields
     */
    private static int totalFieldCount()
    {
<span class="fc" id="L1028">        int fieldCount = 0;</span>
<span class="fc bfc" id="L1029" title="All 2 branches covered.">        for (int i = 0; i &lt; NodeStructureHelper.tablesLength(); i++)</span>
        {
<span class="fc" id="L1031">            fieldCount += NodeStructureHelper.fieldsLength(i);</span>
        }
<span class="fc" id="L1033">        return fieldCount;</span>
    }

    /**
     * Checks the content of the passed in configuration object. Used by some
     * tests that copy a configuration.
     *
     * @param c the configuration to check
     */
    private static void checkContent(Configuration c)
    {
<span class="fc bfc" id="L1044" title="All 2 branches covered.">        for (int i = 0; i &lt; NodeStructureHelper.tablesLength(); i++)</span>
        {
<span class="fc" id="L1046">            assertEquals(NodeStructureHelper.table(i),</span>
<span class="fc" id="L1047">                    c.getString(&quot;tables.table(&quot; + i + &quot;).name&quot;));</span>
<span class="fc bfc" id="L1048" title="All 2 branches covered.">            for (int j = 0; j &lt; NodeStructureHelper.fieldsLength(i); j++)</span>
            {
<span class="fc" id="L1050">                assertEquals(</span>
<span class="fc" id="L1051">                        NodeStructureHelper.field(i, j),</span>
<span class="fc" id="L1052">                        c.getString(&quot;tables.table(&quot; + i + &quot;).fields.field(&quot; + j</span>
                                + &quot;).name&quot;));
            }
        }
<span class="fc" id="L1056">    }</span>

    private ExpressionEngine createAlternativeExpressionEngine()
    {
<span class="fc" id="L1060">        return new DefaultExpressionEngine(</span>
                new DefaultExpressionEngineSymbols.Builder(
                        DefaultExpressionEngineSymbols.DEFAULT_SYMBOLS)
<span class="fc" id="L1063">                        .setPropertyDelimiter(&quot;/&quot;).setIndexStart(&quot;[&quot;)</span>
<span class="fc" id="L1064">                        .setIndexEnd(&quot;]&quot;).create());</span>
    }

    /**
     * A concrete test implementation of
     * {@code AbstractHierarchicalConfiguration}.
     */
    private static class AbstractHierarchicalConfigurationTestImpl extends
            AbstractHierarchicalConfiguration&lt;ImmutableNode&gt;
    {
        public AbstractHierarchicalConfigurationTestImpl(InMemoryNodeModel model)
        {
<span class="fc" id="L1076">            super(model);</span>
<span class="fc" id="L1077">        }</span>

        @Override
        protected NodeModel&lt;ImmutableNode&gt; cloneNodeModel()
        {
<span class="fc" id="L1082">            return new InMemoryNodeModel(getModel().getNodeHandler().getRootNode());</span>
        }

        @Override
        public SubnodeConfiguration configurationAt(String key,
                boolean supportUpdates)
        {
<span class="nc" id="L1089">            throw new UnsupportedOperationException(&quot;Unexpected method call!&quot;);</span>
        }

        @Override
        public SubnodeConfiguration configurationAt(String key)
        {
<span class="nc" id="L1095">            throw new UnsupportedOperationException(&quot;Unexpected method call!&quot;);</span>
        }

        @Override
        public List&lt;HierarchicalConfiguration&lt;ImmutableNode&gt;&gt; configurationsAt(String key)
        {
<span class="nc" id="L1101">            throw new UnsupportedOperationException(&quot;Unexpected method call!&quot;);</span>
        }

        @Override
        public List&lt;HierarchicalConfiguration&lt;ImmutableNode&gt;&gt; configurationsAt(String key, boolean supportUpdates) {
<span class="nc" id="L1106">            throw new UnsupportedOperationException(&quot;Unexpected method call!&quot;);</span>
        }

        @Override
        public List&lt;HierarchicalConfiguration&lt;ImmutableNode&gt;&gt; childConfigurationsAt(String key)
        {
<span class="nc" id="L1112">            throw new UnsupportedOperationException(&quot;Unexpected method call!&quot;);</span>
        }

        @Override
        public List&lt;HierarchicalConfiguration&lt;ImmutableNode&gt;&gt; childConfigurationsAt(String key, boolean supportUpdates) {
<span class="nc" id="L1117">            throw new UnsupportedOperationException(&quot;Unexpected method call!&quot;);</span>
        }

        @Override
        public ImmutableHierarchicalConfiguration immutableConfigurationAt(
                String key, boolean supportUpdates)
        {
<span class="nc" id="L1124">            throw new UnsupportedOperationException(&quot;Unexpected method call!&quot;);</span>
        }

        @Override
        public ImmutableHierarchicalConfiguration immutableConfigurationAt(
                String key)
        {
<span class="nc" id="L1131">            throw new UnsupportedOperationException(&quot;Unexpected method call!&quot;);</span>
        }

        @Override
        public List&lt;ImmutableHierarchicalConfiguration&gt; immutableConfigurationsAt(
                String key)
        {
<span class="nc" id="L1138">            throw new UnsupportedOperationException(&quot;Unexpected method call!&quot;);</span>
        }

        @Override
        public List&lt;ImmutableHierarchicalConfiguration&gt; immutableChildConfigurationsAt(
                String key)
        {
<span class="nc" id="L1145">            throw new UnsupportedOperationException(&quot;Unexpected method call!&quot;);</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>