<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TestCombinedConfigurationBuilder.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">commons_configuration2$Unnamed.exec</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.configuration2.builder.combined</a> &gt; <span class="el_source">TestCombinedConfigurationBuilder.java</span></div><h1>TestCombinedConfigurationBuilder.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.commons.configuration2.builder.combined;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNotSame;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertSame;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import java.io.File;
import java.io.IOException;
import java.net.URL;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.CountDownLatch;

import org.apache.commons.configuration2.BaseHierarchicalConfiguration;
import org.apache.commons.configuration2.CombinedConfiguration;
import org.apache.commons.configuration2.Configuration;
import org.apache.commons.configuration2.ConfigurationAssert;
import org.apache.commons.configuration2.ConfigurationDecoder;
import org.apache.commons.configuration2.DynamicCombinedConfiguration;
import org.apache.commons.configuration2.HierarchicalConfiguration;
import org.apache.commons.configuration2.PropertiesConfiguration;
import org.apache.commons.configuration2.XMLConfiguration;
import org.apache.commons.configuration2.XMLPropertiesConfiguration;
import org.apache.commons.configuration2.builder.BasicConfigurationBuilder;
import org.apache.commons.configuration2.builder.BuilderEventListenerImpl;
import org.apache.commons.configuration2.builder.ConfigurationBuilder;
import org.apache.commons.configuration2.builder.ConfigurationBuilderEvent;
import org.apache.commons.configuration2.builder.CopyObjectDefaultHandler;
import org.apache.commons.configuration2.builder.FileBasedBuilderParametersImpl;
import org.apache.commons.configuration2.builder.FileBasedBuilderProperties;
import org.apache.commons.configuration2.builder.FileBasedConfigurationBuilder;
import org.apache.commons.configuration2.builder.PropertiesBuilderParametersImpl;
import org.apache.commons.configuration2.builder.ReloadingFileBasedConfigurationBuilder;
import org.apache.commons.configuration2.builder.XMLBuilderParametersImpl;
import org.apache.commons.configuration2.builder.XMLBuilderProperties;
import org.apache.commons.configuration2.builder.fluent.CombinedBuilderParameters;
import org.apache.commons.configuration2.builder.fluent.FileBasedBuilderParameters;
import org.apache.commons.configuration2.builder.fluent.Parameters;
import org.apache.commons.configuration2.builder.fluent.XMLBuilderParameters;
import org.apache.commons.configuration2.convert.DefaultListDelimiterHandler;
import org.apache.commons.configuration2.convert.ListDelimiterHandler;
import org.apache.commons.configuration2.event.ConfigurationEvent;
import org.apache.commons.configuration2.event.Event;
import org.apache.commons.configuration2.event.EventListener;
import org.apache.commons.configuration2.ex.ConfigurationException;
import org.apache.commons.configuration2.interpol.ConfigurationInterpolator;
import org.apache.commons.configuration2.interpol.Lookup;
import org.apache.commons.configuration2.io.DefaultFileSystem;
import org.apache.commons.configuration2.io.FileHandler;
import org.apache.commons.configuration2.io.FileLocatorUtils;
import org.apache.commons.configuration2.io.FileSystem;
import org.apache.commons.configuration2.reloading.ReloadingController;
import org.apache.commons.configuration2.reloading.ReloadingControllerSupport;
import org.apache.commons.configuration2.resolver.CatalogResolver;
import org.apache.commons.configuration2.tree.DefaultExpressionEngine;
import org.apache.commons.configuration2.tree.DefaultExpressionEngineSymbols;
import org.apache.commons.configuration2.tree.ImmutableNode;
import org.apache.commons.configuration2.tree.xpath.XPathExpressionEngine;
import org.easymock.EasyMock;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;

/**
 * Test class for {@code CombinedConfigurationBuilder}.
 *
 * @version $Id$
 */
<span class="fc" id="L94">public class TestCombinedConfigurationBuilder</span>
{
    /** Test configuration definition file. */
<span class="fc" id="L97">    private static final File TEST_FILE = ConfigurationAssert</span>
<span class="fc" id="L98">            .getTestFile(&quot;testDigesterConfiguration.xml&quot;);</span>

    /** Test file name for a sub configuration. */
    private static final String TEST_SUB_XML = &quot;test.xml&quot;;

    /** Constant for a named builder. */
    private static final String BUILDER_NAME = &quot;subBuilderName&quot;;

    /**
     * The name of the system property for selecting a file managed by a
     * MultiFileConfigurationBuilder.
     */
    private static final String MULTI_FILE_PROPERTY = &quot;Id&quot;;

    /** A helper object for creating builder parameters. */
    protected Parameters parameters;

    /** Stores the object to be tested. */
    protected CombinedConfigurationBuilder builder;

    @Before
    public void setUp() throws Exception
    {
<span class="fc" id="L121">        System.setProperty(&quot;java.naming.factory.initial&quot;,</span>
                &quot;org.apache.commons.configuration2.MockInitialContextFactory&quot;);
<span class="fc" id="L123">        System.setProperty(&quot;test_file_xml&quot;, TEST_SUB_XML);</span>
<span class="fc" id="L124">        System.setProperty(&quot;test_file_combine&quot;, &quot;testcombine1.xml&quot;);</span>
<span class="fc" id="L125">        parameters = new Parameters();</span>
<span class="fc" id="L126">        builder = new CombinedConfigurationBuilder();</span>
<span class="fc" id="L127">    }</span>

    @After
    public void tearDown() throws Exception
    {
<span class="fc" id="L132">        System.getProperties().remove(MULTI_FILE_PROPERTY);</span>
<span class="fc" id="L133">    }</span>

    /**
     * Creates a configuration builder for the definition configuration which
     * always returns the passed in definition configuration.
     *
     * @param defConfig the definition configuration
     * @return the definition builder
     */
    protected static BasicConfigurationBuilder&lt;? extends BaseHierarchicalConfiguration&gt; createDefinitionBuilder(
            final BaseHierarchicalConfiguration defConfig)
    {
<span class="fc" id="L145">        return new ConstantConfigurationBuilder(defConfig);</span>
    }

    /**
     * Convenience method for creating a definition configuration. This method
     * creates a configuration containing a tag referring to a configuration
     * source. The tag has attributes defined by the given map.
     *
     * @param tag the name of the tag to create
     * @param attrs the attributes of this tag
     * @return the definition configuration
     */
    protected static BaseHierarchicalConfiguration createDefinitionConfig(final String tag,
            final Map&lt;String, Object&gt; attrs)
    {
<span class="fc" id="L160">        final BaseHierarchicalConfiguration defConfig =</span>
                new BaseHierarchicalConfiguration();
<span class="fc" id="L162">        final String prefix = &quot;override.&quot; + tag;</span>
<span class="fc bfc" id="L163" title="All 2 branches covered.">        for (final Map.Entry&lt;String, Object&gt; e : attrs.entrySet())</span>
        {
<span class="fc" id="L165">            defConfig.addProperty(prefix + &quot;[@&quot; + e.getKey() + &quot;]&quot;,</span>
<span class="fc" id="L166">                    e.getValue());</span>
<span class="fc" id="L167">        }</span>
<span class="fc" id="L168">        return defConfig;</span>
    }

    /**
     * Creates an object with parameters for defining the file to be loaded.
     *
     * @return the parameters object
     */
    protected FileBasedBuilderParameters createParameters()
    {
<span class="fc" id="L178">        return parameters.fileBased();</span>
    }

    /**
     * Tries to build a configuration if no definition builder is provided.
     */
    @Test(expected = ConfigurationException.class)
    public void testNoDefinitionBuilder() throws ConfigurationException
    {
<span class="nc" id="L187">        builder.getConfiguration();</span>
<span class="nc" id="L188">    }</span>

    /**
     * Tests if the configuration was correctly created by the builder.
     *
     * @return the combined configuration obtained from the builder
     */
    private CombinedConfiguration checkConfiguration()
            throws ConfigurationException
    {
<span class="fc" id="L198">        final CombinedConfiguration compositeConfiguration =</span>
<span class="fc" id="L199">                builder.getConfiguration();</span>

<span class="fc" id="L201">        assertEquals(&quot;Number of configurations&quot;, 3,</span>
<span class="fc" id="L202">                compositeConfiguration.getNumberOfConfigurations());</span>
<span class="fc" id="L203">        assertEquals(PropertiesConfiguration.class, compositeConfiguration</span>
<span class="fc" id="L204">                .getConfiguration(0).getClass());</span>
<span class="fc" id="L205">        assertEquals(XMLPropertiesConfiguration.class, compositeConfiguration</span>
<span class="fc" id="L206">                .getConfiguration(1).getClass());</span>
<span class="fc" id="L207">        assertEquals(XMLConfiguration.class, compositeConfiguration</span>
<span class="fc" id="L208">                .getConfiguration(2).getClass());</span>

        // check the first configuration
<span class="fc" id="L211">        final PropertiesConfiguration pc =</span>
                (PropertiesConfiguration) compositeConfiguration
<span class="fc" id="L213">                        .getConfiguration(0);</span>
<span class="fc" id="L214">        assertNotNull(&quot;No properties configuration&quot;, pc);</span>

        // check some properties
<span class="fc" id="L217">        checkProperties(compositeConfiguration);</span>
<span class="fc" id="L218">        return compositeConfiguration;</span>
    }

    /**
     * Checks if the passed in configuration contains the expected properties.
     *
     * @param compositeConfiguration the configuration to check
     */
    private void checkProperties(final Configuration compositeConfiguration)
    {
<span class="fc" id="L228">        assertTrue(&quot;Make sure we have loaded our key&quot;,</span>
<span class="fc" id="L229">                compositeConfiguration.getBoolean(&quot;test.boolean&quot;));</span>
<span class="fc" id="L230">        assertEquals(&quot;I'm complex!&quot;,</span>
                compositeConfiguration
<span class="fc" id="L232">                        .getProperty(&quot;element2.subelement.subsubelement&quot;));</span>
<span class="fc" id="L233">        assertEquals(&quot;property in the XMLPropertiesConfiguration&quot;, &quot;value1&quot;,</span>
<span class="fc" id="L234">                compositeConfiguration.getProperty(&quot;key1&quot;));</span>
<span class="fc" id="L235">    }</span>

    /**
     * Tests that the return value of configure() is overloaded.
     */
    @Test
    public void testConfigureResult()
    {
<span class="fc" id="L243">        final CombinedConfigurationBuilder configuredBuilder =</span>
<span class="fc" id="L244">                builder.configure(createParameters().setFile(TEST_FILE));</span>
<span class="fc" id="L245">        assertSame(&quot;Wrong instance returned&quot;, builder, configuredBuilder);</span>
<span class="fc" id="L246">    }</span>

    /**
     * Tests loading a simple configuration definition file.
     */
    @Test
    public void testLoadConfiguration() throws ConfigurationException
    {
<span class="fc" id="L254">        builder.configure(createParameters()</span>
<span class="fc" id="L255">                .setFile(TEST_FILE));</span>
<span class="fc" id="L256">        checkConfiguration();</span>
<span class="fc" id="L257">    }</span>

    /**
     * Tests loading a configuration definition file with an additional section.
     */
    @Test
    public void testLoadAdditional() throws ConfigurationException
    {
<span class="fc" id="L265">        final File additonalFile =</span>
                ConfigurationAssert
<span class="fc" id="L267">                        .getTestFile(&quot;testDigesterConfiguration2.xml&quot;);</span>
<span class="fc" id="L268">        builder.configure(createParameters()</span>
<span class="fc" id="L269">                .setFile(additonalFile));</span>
<span class="fc" id="L270">        final CombinedConfiguration compositeConfiguration =</span>
<span class="fc" id="L271">                builder.getConfiguration();</span>
<span class="fc" id="L272">        assertEquals(&quot;Verify how many configs&quot;, 2,</span>
<span class="fc" id="L273">                compositeConfiguration.getNumberOfConfigurations());</span>

        // Test if union was constructed correctly
<span class="fc" id="L276">        Object prop = compositeConfiguration.getProperty(&quot;tables.table.name&quot;);</span>
<span class="fc" id="L277">        assertTrue(prop instanceof Collection);</span>
<span class="fc" id="L278">        assertEquals(3, ((Collection&lt;?&gt;) prop).size());</span>
<span class="fc" id="L279">        assertEquals(&quot;users&quot;,</span>
<span class="fc" id="L280">                compositeConfiguration.getProperty(&quot;tables.table(0).name&quot;));</span>
<span class="fc" id="L281">        assertEquals(&quot;documents&quot;,</span>
<span class="fc" id="L282">                compositeConfiguration.getProperty(&quot;tables.table(1).name&quot;));</span>
<span class="fc" id="L283">        assertEquals(&quot;tasks&quot;,</span>
<span class="fc" id="L284">                compositeConfiguration.getProperty(&quot;tables.table(2).name&quot;));</span>

<span class="fc" id="L286">        prop =</span>
                compositeConfiguration
<span class="fc" id="L288">                        .getProperty(&quot;tables.table.fields.field.name&quot;);</span>
<span class="fc" id="L289">        assertTrue(prop instanceof Collection);</span>
<span class="fc" id="L290">        assertEquals(17, ((Collection&lt;?&gt;) prop).size());</span>

<span class="fc" id="L292">        assertEquals(&quot;smtp.mydomain.org&quot;,</span>
<span class="fc" id="L293">                compositeConfiguration.getString(&quot;mail.host.smtp&quot;));</span>
<span class="fc" id="L294">        assertEquals(&quot;pop3.mydomain.org&quot;,</span>
<span class="fc" id="L295">                compositeConfiguration.getString(&quot;mail.host.pop&quot;));</span>

        // This was overriden
<span class="fc" id="L298">        assertEquals(&quot;masterOfPost&quot;,</span>
<span class="fc" id="L299">                compositeConfiguration.getString(&quot;mail.account.user&quot;));</span>
<span class="fc" id="L300">        assertEquals(&quot;topsecret&quot;,</span>
<span class="fc" id="L301">                compositeConfiguration.getString(&quot;mail.account.psswd&quot;));</span>

        // This was overridden, too, but not in additional section
<span class="fc" id="L304">        assertEquals(&quot;enhanced factory&quot;,</span>
<span class="fc" id="L305">                compositeConfiguration.getString(&quot;test.configuration&quot;));</span>
<span class="fc" id="L306">    }</span>

    /**
     * Tests loading a definition file that contains optional configurations.
     */
    @Test
    public void testLoadOptional() throws Exception
    {
<span class="fc" id="L314">        final File optionalFile =</span>
                ConfigurationAssert
<span class="fc" id="L316">                        .getTestFile(&quot;testDigesterOptionalConfiguration.xml&quot;);</span>
<span class="fc" id="L317">        builder.configure(createParameters()</span>
<span class="fc" id="L318">                .setFile(optionalFile));</span>
<span class="fc" id="L319">        final Configuration config = builder.getConfiguration();</span>
<span class="fc" id="L320">        assertTrue(config.getBoolean(&quot;test.boolean&quot;));</span>
<span class="fc" id="L321">        assertEquals(&quot;value&quot;, config.getProperty(&quot;element&quot;));</span>
<span class="fc" id="L322">    }</span>

    /**
     * Tests loading a definition file with optional and non optional
     * configuration sources. One non optional does not exist, so this should
     * cause an exception.
     */
    @Test(expected = ConfigurationException.class)
    public void testLoadOptionalWithException() throws ConfigurationException
    {
<span class="fc" id="L332">        final File optionalExFile =</span>
                ConfigurationAssert
<span class="fc" id="L334">                        .getTestFile(&quot;testDigesterOptionalConfigurationEx.xml&quot;);</span>
<span class="fc" id="L335">        builder.configure(createParameters()</span>
<span class="fc" id="L336">                .setFile(optionalExFile));</span>
<span class="nc" id="L337">        builder.getConfiguration();</span>
<span class="nc" id="L338">    }</span>

    /**
     * Tests whether the force-create attribute is taken into account.
     */
    @Test
    public void testLoadOptionalForceCreate() throws ConfigurationException
    {
<span class="fc" id="L346">        final String name = &quot;optionalConfig&quot;;</span>
<span class="fc" id="L347">        final Map&lt;String, Object&gt; attrs = new HashMap&lt;&gt;();</span>
<span class="fc" id="L348">        attrs.put(&quot;fileName&quot;, &quot;nonExisting.xml&quot;);</span>
<span class="fc" id="L349">        attrs.put(&quot;config-name&quot;, name);</span>
<span class="fc" id="L350">        attrs.put(&quot;config-optional&quot;, Boolean.TRUE);</span>
<span class="fc" id="L351">        attrs.put(&quot;config-forceCreate&quot;, Boolean.TRUE);</span>
<span class="fc" id="L352">        final BaseHierarchicalConfiguration defConfig =</span>
<span class="fc" id="L353">                createDefinitionConfig(&quot;xml&quot;, attrs);</span>
<span class="fc" id="L354">        final BasicConfigurationBuilder&lt;? extends BaseHierarchicalConfiguration&gt; defBuilder =</span>
<span class="fc" id="L355">                createDefinitionBuilder(defConfig);</span>
<span class="fc" id="L356">        builder.configure(new CombinedBuilderParametersImpl()</span>
<span class="fc" id="L357">                .setDefinitionBuilder(defBuilder));</span>
<span class="fc" id="L358">        final CombinedConfiguration cc = builder.getConfiguration();</span>
<span class="fc" id="L359">        assertEquals(&quot;Wrong number of configurations&quot;, 1,</span>
<span class="fc" id="L360">                cc.getNumberOfConfigurations());</span>
<span class="fc" id="L361">        assertTrue(&quot;Wrong configuration type&quot;,</span>
<span class="fc" id="L362">                cc.getConfiguration(name) instanceof XMLConfiguration);</span>
<span class="fc" id="L363">    }</span>

    /**
     * Tests the behavior of builderNames() before the result configuration has
     * been created.
     */
    @Test
    public void testBuilderNamesBeforeConfigurationAccess()
    {
<span class="fc" id="L372">        assertTrue(&quot;Got builders (1)&quot;, builder.builderNames().isEmpty());</span>
<span class="fc" id="L373">        builder.configure(createParameters()</span>
<span class="fc" id="L374">                .setFile(TEST_FILE));</span>
<span class="fc" id="L375">        assertTrue(&quot;Got builders (2)&quot;, builder.builderNames().isEmpty());</span>
<span class="fc" id="L376">    }</span>

    /**
     * Tests whether the names of sub builders can be queried.
     */
    @Test
    public void testBuilderNames() throws ConfigurationException
    {
<span class="fc" id="L384">        builder.configure(createParameters()</span>
<span class="fc" id="L385">                .setFile(TEST_FILE));</span>
<span class="fc" id="L386">        builder.getConfiguration();</span>
<span class="fc" id="L387">        final Set&lt;String&gt; names = builder.builderNames();</span>
<span class="fc" id="L388">        final List&lt;String&gt; expected = Arrays.asList(&quot;props&quot;, &quot;xml&quot;);</span>
<span class="fc" id="L389">        assertEquals(&quot;Wrong number of named builders&quot;, expected.size(),</span>
<span class="fc" id="L390">                names.size());</span>
<span class="fc" id="L391">        assertTrue(&quot;Wrong builder names: &quot; + names, names.containsAll(expected));</span>
<span class="fc" id="L392">    }</span>

    /**
     * Tests that the collection with builder names cannot be manipulated.
     */
    @Test(expected = UnsupportedOperationException.class)
    public void testBuilderNamesManipulate() throws ConfigurationException
    {
<span class="fc" id="L400">        builder.configure(createParameters()</span>
<span class="fc" id="L401">                .setFile(TEST_FILE));</span>
<span class="fc" id="L402">        builder.getConfiguration();</span>
<span class="fc" id="L403">        final Set&lt;String&gt; names = builder.builderNames();</span>
<span class="nc" id="L404">        names.add(BUILDER_NAME);</span>
<span class="nc" id="L405">    }</span>

    /**
     * Tests whether named builders can be accessed.
     */
    @Test
    public void testGetNamedBuilder() throws ConfigurationException
    {
<span class="fc" id="L413">        builder.configure(createParameters()</span>
<span class="fc" id="L414">                .setFile(TEST_FILE));</span>
<span class="fc" id="L415">        builder.getConfiguration();</span>
<span class="fc" id="L416">        final ConfigurationBuilder&lt;? extends Configuration&gt; propBuilder =</span>
<span class="fc" id="L417">                builder.getNamedBuilder(&quot;props&quot;);</span>
<span class="fc" id="L418">        assertTrue(&quot;Wrong builder class&quot;,</span>
                propBuilder instanceof FileBasedConfigurationBuilder);
<span class="fc" id="L420">        assertTrue(</span>
                &quot;Wrong sub configuration&quot;,
<span class="fc" id="L422">                propBuilder.getConfiguration() instanceof PropertiesConfiguration);</span>
<span class="fc" id="L423">    }</span>

    /**
     * Tries to query a non-existing builder by name.
     */
    @Test(expected = ConfigurationException.class)
    public void testGetNamedBuilderUnknown() throws ConfigurationException
    {
<span class="fc" id="L431">        builder.configure(createParameters()</span>
<span class="fc" id="L432">                .setFile(TEST_FILE));</span>
<span class="fc" id="L433">        builder.getConfiguration();</span>
<span class="nc" id="L434">        builder.getNamedBuilder(&quot;nonExistingBuilder&quot;);</span>
<span class="nc" id="L435">    }</span>

    /**
     * Tries to query a named builder before the result configuration has been
     * created.
     */
    @Test(expected = ConfigurationException.class)
    public void testGetNamedBuilderBeforeConfigurationAccess()
            throws ConfigurationException
    {
<span class="fc" id="L445">        builder.configure(createParameters()</span>
<span class="fc" id="L446">                .setFile(TEST_FILE));</span>
<span class="nc" id="L447">        builder.getNamedBuilder(&quot;nonExistingBuilder&quot;);</span>
<span class="nc" id="L448">    }</span>

    /**
     * Prepares a test with a combined configuration that uses a single sub
     * builder. This method adds some default attributes to the given map,
     * creates the corresponding definition builder and configures the combined
     * builder.
     *
     * @param attrs the map with attributes
     * @return the definition builder
     */
    private BasicConfigurationBuilder&lt;? extends HierarchicalConfiguration&lt;ImmutableNode&gt;&gt; prepareSubBuilderTest(
            final Map&lt;String, Object&gt; attrs)
    {
<span class="fc" id="L462">        attrs.put(&quot;fileName&quot;, TEST_SUB_XML);</span>
<span class="fc" id="L463">        attrs.put(&quot;config-name&quot;, BUILDER_NAME);</span>
<span class="fc" id="L464">        final BaseHierarchicalConfiguration defConfig =</span>
<span class="fc" id="L465">                createDefinitionConfig(&quot;xml&quot;, attrs);</span>
<span class="fc" id="L466">        final BasicConfigurationBuilder&lt;? extends HierarchicalConfiguration&lt;ImmutableNode&gt;&gt; defBuilder =</span>
<span class="fc" id="L467">                createDefinitionBuilder(defConfig);</span>
<span class="fc" id="L468">        builder.configure(new CombinedBuilderParametersImpl()</span>
<span class="fc" id="L469">                .setDefinitionBuilder(defBuilder));</span>
<span class="fc" id="L470">        return defBuilder;</span>
    }

    /**
     * Tests a reset of the builder. The configuration instance should be
     * created anew.
     */
    @Test
    public void testResetBuilder() throws ConfigurationException
    {
<span class="fc" id="L480">        final Map&lt;String, Object&gt; attrs = new HashMap&lt;&gt;();</span>
<span class="fc" id="L481">        final BasicConfigurationBuilder&lt;? extends HierarchicalConfiguration&lt;ImmutableNode&gt;&gt; defBuilder =</span>
<span class="fc" id="L482">                prepareSubBuilderTest(attrs);</span>
<span class="fc" id="L483">        final CombinedConfiguration cc = builder.getConfiguration();</span>
<span class="fc" id="L484">        final ConfigurationBuilder&lt;? extends Configuration&gt; subBuilder =</span>
<span class="fc" id="L485">                builder.getNamedBuilder(BUILDER_NAME);</span>
<span class="fc" id="L486">        defBuilder.reset();</span>
<span class="fc" id="L487">        final CombinedConfiguration cc2 = builder.getConfiguration();</span>
<span class="fc" id="L488">        assertNotSame(&quot;No new configuration instance&quot;, cc, cc2);</span>
<span class="fc" id="L489">        final ConfigurationBuilder&lt;? extends Configuration&gt; subBuilder2 =</span>
<span class="fc" id="L490">                builder.getNamedBuilder(BUILDER_NAME);</span>
<span class="fc" id="L491">        assertNotSame(&quot;No new sub builder instance&quot;, subBuilder, subBuilder2);</span>
<span class="fc" id="L492">    }</span>

    /**
     * Tests whether a reloading sub builder can be created.
     */
    @Test
    public void testReloadingBuilder() throws ConfigurationException
    {
<span class="fc" id="L500">        final Map&lt;String, Object&gt; attrs = new HashMap&lt;&gt;();</span>
<span class="fc" id="L501">        attrs.put(&quot;config-reload&quot;, Boolean.TRUE);</span>
<span class="fc" id="L502">        prepareSubBuilderTest(attrs);</span>
<span class="fc" id="L503">        builder.getConfiguration();</span>
<span class="fc" id="L504">        assertTrue(</span>
                &quot;Not a reloading builder&quot;,
<span class="fc" id="L506">                builder.getNamedBuilder(BUILDER_NAME) instanceof ReloadingFileBasedConfigurationBuilder);</span>
<span class="fc" id="L507">    }</span>

    /**
     * Tests whether a reset of one of the sub builders causes the combined
     * configuration to be re-created.
     */
    @Test
    public void testReactOnSubBuilderChange() throws ConfigurationException
    {
<span class="fc" id="L516">        final Map&lt;String, Object&gt; attrs = new HashMap&lt;&gt;();</span>
<span class="fc" id="L517">        prepareSubBuilderTest(attrs);</span>
<span class="fc" id="L518">        final CombinedConfiguration cc = builder.getConfiguration();</span>
<span class="fc" id="L519">        final BasicConfigurationBuilder&lt;?&gt; subBuilder =</span>
                (BasicConfigurationBuilder&lt;?&gt;) builder
<span class="fc" id="L521">                        .getNamedBuilder(BUILDER_NAME);</span>
<span class="fc" id="L522">        subBuilder.reset();</span>
<span class="fc" id="L523">        assertNotSame(&quot;Configuration not newly created&quot;, cc,</span>
<span class="fc" id="L524">                builder.getConfiguration());</span>
<span class="fc" id="L525">    }</span>

    /**
     * Tests that change listeners registered at sub builders are removed on a
     * reset.
     */
    @Test
    public void testRemoveSubBuilderListener() throws ConfigurationException
    {
<span class="fc" id="L534">        final Map&lt;String, Object&gt; attrs = new HashMap&lt;&gt;();</span>
<span class="fc" id="L535">        prepareSubBuilderTest(attrs);</span>
<span class="fc" id="L536">        builder.getConfiguration();</span>
<span class="fc" id="L537">        final BasicConfigurationBuilder&lt;?&gt; subBuilder =</span>
                (BasicConfigurationBuilder&lt;?&gt;) builder
<span class="fc" id="L539">                        .getNamedBuilder(BUILDER_NAME);</span>
<span class="fc" id="L540">        builder.reset();</span>
<span class="fc" id="L541">        prepareSubBuilderTest(attrs);</span>
<span class="fc" id="L542">        final CombinedConfiguration cc = builder.getConfiguration();</span>
<span class="fc" id="L543">        final BasicConfigurationBuilder&lt;?&gt; subBuilder2 =</span>
                (BasicConfigurationBuilder&lt;?&gt;) builder
<span class="fc" id="L545">                        .getNamedBuilder(BUILDER_NAME);</span>
<span class="fc" id="L546">        assertNotSame(&quot;Got the same sub builder&quot;, subBuilder, subBuilder2);</span>
<span class="fc" id="L547">        subBuilder.reset();</span>
<span class="fc" id="L548">        assertSame(&quot;Configuration was reset&quot;, cc, builder.getConfiguration());</span>
<span class="fc" id="L549">    }</span>

    /**
     * Helper method for testing the attributes of a combined configuration
     * created by the builder.
     *
     * @param cc the configuration to be checked
     */
    private static void checkCombinedConfigAttrs(final CombinedConfiguration cc)
    {
<span class="fc" id="L559">        final ListDelimiterHandler handler = cc.getListDelimiterHandler();</span>
<span class="fc" id="L560">        assertTrue(&quot;Wrong delimiter handler: &quot; + handler,</span>
                handler instanceof DefaultListDelimiterHandler);
<span class="fc" id="L562">        assertEquals(&quot;Wrong list delimiter character&quot;, ',',</span>
<span class="fc" id="L563">                ((DefaultListDelimiterHandler) handler).getDelimiter());</span>
<span class="fc" id="L564">    }</span>

    /**
     * Tests whether attributes are correctly set on the combined configurations
     * for the override and additional sections.
     */
    @Test
    public void testCombinedConfigurationAttributes()
            throws ConfigurationException
    {
<span class="fc" id="L574">        final File initFile =</span>
                ConfigurationAssert
<span class="fc" id="L576">                        .getTestFile(&quot;testCCResultInitialization.xml&quot;);</span>
<span class="fc" id="L577">        builder.configure(createParameters()</span>
<span class="fc" id="L578">                .setFile(initFile));</span>
<span class="fc" id="L579">        final CombinedConfiguration cc = builder.getConfiguration();</span>
<span class="fc" id="L580">        checkCombinedConfigAttrs(cc);</span>
<span class="fc" id="L581">        final CombinedConfiguration cc2 =</span>
                (CombinedConfiguration) cc
<span class="fc" id="L583">                        .getConfiguration(CombinedConfigurationBuilder.ADDITIONAL_NAME);</span>
<span class="fc" id="L584">        checkCombinedConfigAttrs(cc2);</span>
<span class="fc" id="L585">    }</span>

    /**
     * Tests the structure of the returned combined configuration if there is no
     * additional section.
     */
    @Test
    public void testCombinedConfigurationNoAdditional()
            throws ConfigurationException
    {
<span class="fc" id="L595">        builder.configure(createParameters()</span>
<span class="fc" id="L596">                .setFile(TEST_FILE));</span>
<span class="fc" id="L597">        final CombinedConfiguration cc = builder.getConfiguration();</span>
<span class="fc" id="L598">        assertNull(</span>
                &quot;Additional configuration was found&quot;,
<span class="fc" id="L600">                cc.getConfiguration(CombinedConfigurationBuilder.ADDITIONAL_NAME));</span>
<span class="fc" id="L601">    }</span>

    /**
     * Tests whether the list node definition was correctly processed.
     */
    @Test
    public void testCombinedConfigurationListNodes()
            throws ConfigurationException
    {
<span class="fc" id="L610">        final File initFile =</span>
                ConfigurationAssert
<span class="fc" id="L612">                        .getTestFile(&quot;testCCResultInitialization.xml&quot;);</span>
<span class="fc" id="L613">        builder.configure(createParameters()</span>
<span class="fc" id="L614">                .setFile(initFile));</span>
<span class="fc" id="L615">        final CombinedConfiguration cc = builder.getConfiguration();</span>
<span class="fc" id="L616">        Set&lt;String&gt; listNodes = cc.getNodeCombiner().getListNodes();</span>
<span class="fc" id="L617">        assertEquals(&quot;Wrong number of list nodes&quot;, 2, listNodes.size());</span>
<span class="fc" id="L618">        assertTrue(&quot;table node not a list node&quot;, listNodes.contains(&quot;table&quot;));</span>
<span class="fc" id="L619">        assertTrue(&quot;list node not a list node&quot;, listNodes.contains(&quot;list&quot;));</span>

<span class="fc" id="L621">        final CombinedConfiguration cca =</span>
                (CombinedConfiguration) cc
<span class="fc" id="L623">                        .getConfiguration(CombinedConfigurationBuilder.ADDITIONAL_NAME);</span>
<span class="fc" id="L624">        listNodes = cca.getNodeCombiner().getListNodes();</span>
<span class="fc" id="L625">        assertTrue(&quot;Found list nodes for additional combiner&quot;,</span>
<span class="fc" id="L626">                listNodes.isEmpty());</span>
<span class="fc" id="L627">    }</span>

    /**
     * Tests whether a custom provider can be registered.
     */
    @Test
    public void testCustomBuilderProvider() throws ConfigurationException
    {
<span class="fc" id="L635">        final String tagName = &quot;myTestTag&quot;;</span>
<span class="fc" id="L636">        final BaseHierarchicalConfiguration dataConf =</span>
                new BaseHierarchicalConfiguration();
<span class="fc" id="L638">        dataConf.addProperty(tagName, Boolean.TRUE);</span>
<span class="fc" id="L639">        final Map&lt;String, Object&gt; attrs = new HashMap&lt;&gt;();</span>
<span class="fc" id="L640">        attrs.put(&quot;config-name&quot;, BUILDER_NAME);</span>
<span class="fc" id="L641">        attrs.put(&quot;config-at&quot;, &quot;tests&quot;);</span>
<span class="fc" id="L642">        builder.configure(new CombinedBuilderParametersImpl()</span>
<span class="fc" id="L643">                .setDefinitionBuilder(</span>
<span class="fc" id="L644">                        createDefinitionBuilder(createDefinitionConfig(tagName,</span>
<span class="fc" id="L645">                                attrs))).registerProvider(tagName,</span>
                        new ConfigurationBuilderProvider()
<span class="fc" id="L647">                        {</span>
                            @Override
                            public ConfigurationBuilder&lt;? extends Configuration&gt; getConfigurationBuilder(
                                    final ConfigurationDeclaration decl)
                                    throws ConfigurationException
                            {
<span class="fc" id="L653">                                return new ConstantConfigurationBuilder(</span>
                                        dataConf);
                            }
                        }));
<span class="fc" id="L657">        final CombinedConfiguration cc = builder.getConfiguration();</span>
<span class="fc" id="L658">        assertEquals(&quot;Configuration not added&quot;, dataConf,</span>
<span class="fc" id="L659">                cc.getConfiguration(BUILDER_NAME));</span>
<span class="fc" id="L660">        assertEquals(&quot;Property not set&quot;, Boolean.TRUE,</span>
<span class="fc" id="L661">                cc.getProperty(&quot;tests.&quot; + tagName));</span>
<span class="fc" id="L662">    }</span>

    /**
     * Tests whether a custom provider can be defined in the definition file.
     */
    @Test
    public void testProviderInDefinitionConfig() throws ConfigurationException
    {
<span class="fc" id="L670">        builder.configure(createParameters()</span>
<span class="fc" id="L671">                .setFile(ConfigurationAssert</span>
<span class="fc" id="L672">                        .getTestFile(&quot;testCCCustomProvider.xml&quot;)));</span>
<span class="fc" id="L673">        final CombinedConfiguration cc = builder.getConfiguration();</span>
<span class="fc" id="L674">        assertTrue(&quot;Property not found&quot;, cc.getBoolean(&quot;testKey&quot;));</span>
<span class="fc" id="L675">    }</span>

    /**
     * Tests whether a file with system properties can be specified in the
     * configuration definition file and that system properties can be added to
     * the resulting configuration.
     */
    @Test
    public void testSystemProperties() throws ConfigurationException
    {
<span class="fc" id="L685">        final File systemFile =</span>
<span class="fc" id="L686">                ConfigurationAssert.getTestFile(&quot;testCCSystemProperties.xml&quot;);</span>
<span class="fc" id="L687">        builder.configure(createParameters()</span>
<span class="fc" id="L688">                .setFile(systemFile));</span>
<span class="fc" id="L689">        final CombinedConfiguration cc = builder.getConfiguration();</span>
<span class="fc" id="L690">        assertTrue(&quot;System property not found&quot;, cc.containsKey(&quot;user.name&quot;));</span>
<span class="fc" id="L691">        assertEquals(&quot;Properties not added&quot;, &quot;value1&quot;,</span>
<span class="fc" id="L692">                System.getProperty(&quot;key1&quot;));</span>
<span class="fc" id="L693">    }</span>

    /**
     * Tests whether environment properties can be added as a configuration
     * source.
     */
    @Test
    public void testEnvironmentProperties() throws ConfigurationException
    {
<span class="fc" id="L702">        final File envFile =</span>
<span class="fc" id="L703">                ConfigurationAssert.getTestFile(&quot;testCCEnvProperties.xml&quot;);</span>
<span class="fc" id="L704">        builder.configure(createParameters().setFile(envFile));</span>
<span class="fc" id="L705">        final CombinedConfiguration cc = builder.getConfiguration();</span>
<span class="fc" id="L706">        assertFalse(&quot;Configuration is empty&quot;, cc.isEmpty());</span>
<span class="fc bfc" id="L707" title="All 2 branches covered.">        for (final Map.Entry&lt;String, String&gt; e : System.getenv().entrySet())</span>
        {
<span class="fc" id="L709">            assertEquals(&quot;Wrong value for property: &quot; + e.getKey(),</span>
<span class="fc" id="L710">                    e.getValue(), cc.getString(e.getKey()));</span>
<span class="fc" id="L711">        }</span>
<span class="fc" id="L712">    }</span>

    /**
     * Tests whether a JNDI configuration can be integrated into the combined
     * configuration.
     */
    @Test
    public void testJndiConfiguration() throws ConfigurationException
    {
<span class="fc" id="L721">        final File multiFile =</span>
                ConfigurationAssert
<span class="fc" id="L723">                        .getTestFile(&quot;testDigesterConfiguration3.xml&quot;);</span>
<span class="fc" id="L724">        builder.configure(new CombinedBuilderParametersImpl()</span>
<span class="fc" id="L725">                .setDefinitionBuilderParameters(createParameters()</span>
<span class="fc" id="L726">                        .setFile(multiFile)));</span>
<span class="fc" id="L727">        final CombinedConfiguration cc = builder.getConfiguration();</span>
<span class="fc" id="L728">        assertTrue(&quot;JNDI property not found&quot;, cc.getBoolean(&quot;test.onlyinjndi&quot;));</span>
<span class="fc" id="L729">    }</span>

    /**
     * Tests whether an INI configuration source can be added to the combined
     * configuration.
     */
    @Test
    public void testINIConfiguration() throws ConfigurationException
    {
<span class="fc" id="L738">        final File multiFile =</span>
                ConfigurationAssert
<span class="fc" id="L740">                        .getTestFile(&quot;testDigesterConfiguration3.xml&quot;);</span>
<span class="fc" id="L741">        builder.configure(new CombinedBuilderParametersImpl()</span>
<span class="fc" id="L742">                .setDefinitionBuilderParameters(createParameters()</span>
<span class="fc" id="L743">                        .setFile(multiFile)));</span>
<span class="fc" id="L744">        final CombinedConfiguration cc = builder.getConfiguration();</span>
<span class="fc" id="L745">        assertEquals(&quot;Property from ini file not found&quot;, &quot;yes&quot;,</span>
<span class="fc" id="L746">                cc.getString(&quot;testini.loaded&quot;));</span>
<span class="fc" id="L747">    }</span>

    /**
     * Tests whether an entity resolver can be defined in the definition file.
     */
    @Test
    public void testCustomEntityResolver() throws ConfigurationException
    {
<span class="fc" id="L755">        final File resolverFile =</span>
<span class="fc" id="L756">                ConfigurationAssert.getTestFile(&quot;testCCEntityResolver.xml&quot;);</span>
<span class="fc" id="L757">        builder.configure(createParameters()</span>
<span class="fc" id="L758">                .setFile(resolverFile));</span>
<span class="fc" id="L759">        final CombinedConfiguration cc = builder.getConfiguration();</span>
<span class="fc" id="L760">        final XMLConfiguration xmlConf =</span>
<span class="fc" id="L761">                (XMLConfiguration) cc.getConfiguration(&quot;xml&quot;);</span>
<span class="fc" id="L762">        final EntityResolverWithPropertiesTestImpl resolver =</span>
                (EntityResolverWithPropertiesTestImpl) xmlConf
<span class="fc" id="L764">                        .getEntityResolver();</span>
<span class="fc" id="L765">        assertFalse(&quot;No lookups&quot;, resolver.getInterpolator().getLookups()</span>
<span class="fc" id="L766">                .isEmpty());</span>
<span class="fc" id="L767">    }</span>

    /**
     * Tests whether the entity resolver is initialized with other XML-related
     * properties.
     */
    @Test
    public void testConfigureEntityResolverWithProperties()
            throws ConfigurationException
    {
<span class="fc" id="L777">        final HierarchicalConfiguration&lt;ImmutableNode&gt; config = new BaseHierarchicalConfiguration();</span>
<span class="fc" id="L778">        config.addProperty(&quot;header.entity-resolver[@config-class]&quot;,</span>
<span class="fc" id="L779">                EntityResolverWithPropertiesTestImpl.class.getName());</span>
<span class="fc" id="L780">        final XMLBuilderParametersImpl xmlParams = new XMLBuilderParametersImpl();</span>
<span class="fc" id="L781">        final FileSystem fs = EasyMock.createMock(FileSystem.class);</span>
<span class="fc" id="L782">        final String baseDir = ConfigurationAssert.OUT_DIR_NAME;</span>
<span class="fc" id="L783">        xmlParams.setBasePath(baseDir);</span>
<span class="fc" id="L784">        xmlParams.setFileSystem(fs);</span>
<span class="fc" id="L785">        builder.configureEntityResolver(config, xmlParams);</span>
<span class="fc" id="L786">        final EntityResolverWithPropertiesTestImpl resolver =</span>
                (EntityResolverWithPropertiesTestImpl) xmlParams
<span class="fc" id="L788">                        .getEntityResolver();</span>
<span class="fc" id="L789">        assertSame(&quot;File system not set&quot;, fs, resolver.getFileSystem());</span>
<span class="fc" id="L790">        assertSame(&quot;Base directory not set&quot;, baseDir, resolver.getBaseDir());</span>
<span class="fc" id="L791">    }</span>

    /**
     * Helper method for testing whether the file system can be customized in
     * the configuration definition file.
     *
     * @param fsFile the file to be processed
     * @throws ConfigurationException if an error occurs
     */
    private void checkFileSystem(final File fsFile) throws ConfigurationException
    {
<span class="fc" id="L802">        builder.configure(createParameters().setFile(fsFile));</span>
<span class="fc" id="L803">        builder.getConfiguration();</span>
        @SuppressWarnings(&quot;unchecked&quot;) // this is the minimum bound for type arguments
        final
<span class="fc" id="L806">        FileBasedConfigurationBuilder&lt;? extends Configuration&gt; xmlBuilder =</span>
                (FileBasedConfigurationBuilder&lt;? extends Configuration&gt;) builder
<span class="fc" id="L808">                        .getNamedBuilder(&quot;xml&quot;);</span>
<span class="fc" id="L809">        assertTrue(&quot;Wrong file system: &quot;</span>
<span class="fc" id="L810">                + xmlBuilder.getFileHandler().getFileSystem(), xmlBuilder</span>
<span class="fc" id="L811">                .getFileHandler().getFileSystem() instanceof FileSystemTestImpl);</span>
<span class="fc" id="L812">    }</span>

    /**
     * Tests whether a default file system can be configured in the definition
     * file.
     */
    @Test
    public void testCustomFileSystem() throws ConfigurationException
    {
<span class="fc" id="L821">        checkFileSystem(ConfigurationAssert.getTestFile(&quot;testCCFileSystem.xml&quot;));</span>
<span class="fc" id="L822">    }</span>

    /**
     * Tests whether a specific file system can be applied to a sub
     * configuration.
     */
    @Test
    public void testCustomFileSystemForSubConfig()
            throws ConfigurationException
    {
<span class="fc" id="L832">        checkFileSystem(ConfigurationAssert</span>
<span class="fc" id="L833">                .getTestFile(&quot;testCCFileSystemSubConfig.xml&quot;));</span>
<span class="fc" id="L834">    }</span>

    /**
     * Tests whether a default base path for all file-based child configurations
     * can be set in the builder parameters.
     */
    @Test
    public void testDefaultBasePathInParameters() throws ConfigurationException
    {
<span class="fc" id="L843">        final File testFile =</span>
<span class="fc" id="L844">                ConfigurationAssert.getTestFile(&quot;testCCSystemProperties.xml&quot;);</span>
<span class="fc" id="L845">        final String basePath = ConfigurationAssert.OUT_DIR.getAbsolutePath();</span>
<span class="fc" id="L846">        builder.configure(new CombinedBuilderParametersImpl().setBasePath(</span>
<span class="fc" id="L847">                basePath).setDefinitionBuilderParameters(</span>
<span class="fc" id="L848">                createParameters().setFile(testFile)));</span>
<span class="fc" id="L849">        builder.getConfiguration();</span>
<span class="fc" id="L850">        final XMLBuilderParametersImpl xmlParams = new XMLBuilderParametersImpl();</span>
<span class="fc" id="L851">        builder.initChildBuilderParameters(xmlParams);</span>
<span class="fc" id="L852">        assertEquals(&quot;Base path not set&quot;, basePath, xmlParams.getFileHandler()</span>
<span class="fc" id="L853">                .getBasePath());</span>
<span class="fc" id="L854">    }</span>

    /**
     * Tests whether the default base path for file-based configurations is
     * derived from the configuration definition builder.
     */
    @Test
    public void testDefaultBasePathFromDefinitionBuilder()
            throws ConfigurationException, IOException
    {
<span class="fc" id="L864">        final String testFile = &quot;testCCSystemProperties.xml&quot;;</span>
<span class="fc" id="L865">        builder.configure(new CombinedBuilderParametersImpl()</span>
<span class="fc" id="L866">                .setDefinitionBuilderParameters(createParameters()</span>
<span class="fc" id="L867">                        .setBasePath(</span>
<span class="fc" id="L868">                                ConfigurationAssert.TEST_DIR.getAbsolutePath())</span>
<span class="fc" id="L869">                        .setFileName(testFile)));</span>
<span class="fc" id="L870">        builder.getConfiguration();</span>
<span class="fc" id="L871">        final XMLBuilderParametersImpl xmlParams = new XMLBuilderParametersImpl();</span>
<span class="fc" id="L872">        builder.initChildBuilderParameters(xmlParams);</span>
<span class="fc" id="L873">        final File basePathFile =</span>
<span class="fc" id="L874">                FileLocatorUtils.fileFromURL(new URL(xmlParams</span>
<span class="fc" id="L875">                        .getFileHandler().getBasePath()));</span>
<span class="fc" id="L876">        assertEquals(&quot;Wrong base path&quot;,</span>
<span class="fc" id="L877">                ConfigurationAssert.getTestFile(testFile).getAbsoluteFile(),</span>
                basePathFile);
<span class="fc" id="L879">    }</span>

    /**
     * Tests if the base path is correctly evaluated.
     */
    @Test
    public void testBasePathForChildConfigurations()
            throws ConfigurationException
    {
<span class="fc" id="L888">        final BaseHierarchicalConfiguration defConfig =</span>
                new BaseHierarchicalConfiguration();
<span class="fc" id="L890">        defConfig.addProperty(&quot;properties[@fileName]&quot;, &quot;test.properties&quot;);</span>
<span class="fc" id="L891">        final File deepDir = new File(ConfigurationAssert.TEST_DIR, &quot;config/deep&quot;);</span>
<span class="fc" id="L892">        builder.configure(new CombinedBuilderParametersImpl().setBasePath(</span>
<span class="fc" id="L893">                deepDir.getAbsolutePath()).setDefinitionBuilder(</span>
                new ConstantConfigurationBuilder(defConfig)));
<span class="fc" id="L895">        final CombinedConfiguration config = builder.getConfiguration();</span>
<span class="fc" id="L896">        assertEquals(&quot;Wrong property value&quot;, &quot;somevalue&quot;,</span>
<span class="fc" id="L897">                config.getString(&quot;somekey&quot;));</span>
<span class="fc" id="L898">    }</span>

    /**
     * Tests whether the resulting combined configuration can be customized.
     */
    @Test
    public void testCustomResultConfiguration() throws ConfigurationException
    {
<span class="fc" id="L906">        final File testFile =</span>
<span class="fc" id="L907">                ConfigurationAssert.getTestFile(&quot;testCCResultClass.xml&quot;);</span>
<span class="fc" id="L908">        final ListDelimiterHandler listHandler = new DefaultListDelimiterHandler('.');</span>
<span class="fc" id="L909">        builder.configure(new CombinedBuilderParametersImpl()</span>
<span class="fc" id="L910">                .setDefinitionBuilderParameters(</span>
<span class="fc" id="L911">                        new XMLBuilderParametersImpl().setFile(testFile))</span>
<span class="fc" id="L912">                .setListDelimiterHandler(listHandler)</span>
<span class="fc" id="L913">                .setThrowExceptionOnMissing(false));</span>
<span class="fc" id="L914">        final CombinedConfiguration cc = builder.getConfiguration();</span>
<span class="fc" id="L915">        assertTrue(&quot;Wrong configuration class: &quot; + cc.getClass(),</span>
                cc instanceof CombinedConfigurationTestImpl);
<span class="fc" id="L917">        assertTrue(&quot;Wrong exception flag&quot;, cc.isThrowExceptionOnMissing());</span>
<span class="fc" id="L918">        assertEquals(&quot;Wrong list delimiter handler&quot;, listHandler,</span>
<span class="fc" id="L919">                cc.getListDelimiterHandler());</span>
<span class="fc" id="L920">    }</span>

    /**
     * Tests whether a configuration builder can itself be declared in a
     * configuration definition file.
     */
    @Test
    public void testConfigurationBuilderProvider()
            throws ConfigurationException
    {
<span class="fc" id="L930">        final BaseHierarchicalConfiguration defConfig =</span>
                new BaseHierarchicalConfiguration();
<span class="fc" id="L932">        defConfig.addProperty(&quot;override.configuration[@fileName]&quot;,</span>
<span class="fc" id="L933">                TEST_FILE.getAbsolutePath());</span>
<span class="fc" id="L934">        builder.configure(new CombinedBuilderParametersImpl()</span>
<span class="fc" id="L935">                .setDefinitionBuilder(new ConstantConfigurationBuilder(</span>
                        defConfig)));
<span class="fc" id="L937">        final CombinedConfiguration cc = builder.getConfiguration();</span>
<span class="fc" id="L938">        assertEquals(&quot;Wrong number of configurations&quot;, 1,</span>
<span class="fc" id="L939">                cc.getNumberOfConfigurations());</span>
<span class="fc" id="L940">        checkProperties(cc);</span>
<span class="fc" id="L941">    }</span>

    /**
     * Tests whether basic properties defined for the combined configuration are
     * inherited by a child combined configuration builder.
     */
    @Test
    public void testConfigurationBuilderProviderInheritBasicProperties()
            throws ConfigurationException
    {
<span class="fc" id="L951">        final File testFile =</span>
                ConfigurationAssert
<span class="fc" id="L953">                        .getTestFile(&quot;testCCCombinedChildBuilder.xml&quot;);</span>
<span class="fc" id="L954">        final ListDelimiterHandler listHandler = new DefaultListDelimiterHandler('*');</span>
<span class="fc" id="L955">        final ConfigurationDecoder decoder = EasyMock.createMock(ConfigurationDecoder.class);</span>
<span class="fc" id="L956">        builder.configure(new CombinedBuilderParametersImpl()</span>
<span class="fc" id="L957">                .setDefinitionBuilderParameters(</span>
<span class="fc" id="L958">                        new XMLBuilderParametersImpl().setFile(testFile))</span>
<span class="fc" id="L959">                .setListDelimiterHandler(listHandler)</span>
<span class="fc" id="L960">                .setConfigurationDecoder(decoder));</span>
<span class="fc" id="L961">        final CombinedConfiguration cc = builder.getConfiguration();</span>
<span class="fc" id="L962">        final CombinedConfiguration cc2 =</span>
<span class="fc" id="L963">                (CombinedConfiguration) cc.getConfiguration(&quot;subcc&quot;);</span>
<span class="fc" id="L964">        assertFalse(&quot;Wrong exception flag&quot;, cc2.isThrowExceptionOnMissing());</span>
<span class="fc" id="L965">        assertEquals(&quot;Wrong list delimiter handler&quot;, listHandler,</span>
<span class="fc" id="L966">                cc2.getListDelimiterHandler());</span>
<span class="fc" id="L967">        assertEquals(&quot;Wrong decoder&quot;, decoder, cc2.getConfigurationDecoder());</span>
<span class="fc" id="L968">    }</span>

    /**
     * Tests whether a child configuration builder inherits the event listeners
     * from its parent.
     */
    @Test
    public void testConfigurationBuilderProviderInheritEventListeners()
            throws ConfigurationException
    {
        @SuppressWarnings(&quot;unchecked&quot;)
        final
<span class="fc" id="L980">        EventListener&lt;Event&gt; l1 = EasyMock.createNiceMock(EventListener.class);</span>
        @SuppressWarnings(&quot;unchecked&quot;)
        final
<span class="fc" id="L983">        EventListener&lt;ConfigurationEvent&gt; l2 =</span>
<span class="fc" id="L984">                EasyMock.createNiceMock(EventListener.class);</span>
<span class="fc" id="L985">        EasyMock.replay(l1, l2);</span>
<span class="fc" id="L986">        final File testFile =</span>
                ConfigurationAssert
<span class="fc" id="L988">                        .getTestFile(&quot;testCCCombinedChildBuilder.xml&quot;);</span>
<span class="fc" id="L989">        builder.configure(new XMLBuilderParametersImpl().setFile(testFile));</span>
<span class="fc" id="L990">        builder.addEventListener(Event.ANY, l1);</span>
<span class="fc" id="L991">        builder.addEventListener(ConfigurationEvent.ANY, l2);</span>
<span class="fc" id="L992">        final CombinedConfiguration cc = builder.getConfiguration();</span>
<span class="fc" id="L993">        final CombinedConfiguration cc2 =</span>
<span class="fc" id="L994">                (CombinedConfiguration) cc.getConfiguration(&quot;subcc&quot;);</span>
<span class="fc" id="L995">        final Collection&lt;EventListener&lt;? super ConfigurationEvent&gt;&gt; listeners =</span>
<span class="fc" id="L996">                cc2.getEventListeners(ConfigurationEvent.ANY);</span>
<span class="fc" id="L997">        assertTrue(&quot;Listener 1 not found&quot;, listeners.contains(l1));</span>
<span class="fc" id="L998">        assertTrue(&quot;Listener 2 not found&quot;, listeners.contains(l2));</span>
<span class="fc" id="L999">        final Collection&lt;EventListener&lt;? super Event&gt;&gt; eventListeners =</span>
<span class="fc" id="L1000">                cc2.getEventListeners(Event.ANY);</span>
<span class="fc" id="L1001">        assertEquals(&quot;Wrong number of event listeners&quot;, 1,</span>
<span class="fc" id="L1002">                eventListeners.size());</span>
<span class="fc" id="L1003">        assertTrue(&quot;Wrong listener&quot;, eventListeners.contains(l1));</span>
<span class="fc" id="L1004">    }</span>

    /**
     * Tests whether custom builder providers are inherited to child combined
     * configuration builder providers.
     */
    @Test
    public void testConfigurationBuilderProviderInheritCustomProviders()
            throws ConfigurationException
    {
<span class="fc" id="L1014">        builder.configure(createParameters()</span>
<span class="fc" id="L1015">                .setFile(ConfigurationAssert</span>
<span class="fc" id="L1016">                        .getTestFile(&quot;testCCCustomProvider.xml&quot;)));</span>
<span class="fc" id="L1017">        builder.getConfiguration();</span>
<span class="fc" id="L1018">        final CombinedBuilderParametersImpl ccparams =</span>
                new CombinedBuilderParametersImpl();
<span class="fc" id="L1020">        builder.initChildBuilderParameters(ccparams);</span>
<span class="fc" id="L1021">        assertNotNull(&quot;Custom provider not found&quot;,</span>
<span class="fc" id="L1022">                ccparams.providerForTag(&quot;test&quot;));</span>
<span class="fc" id="L1023">    }</span>

    /**
     * Tests whether the base path can be inherited to child combined
     * configuration builders.
     */
    @Test
    public void testConfigurationBuilderProviderInheritBasePath()
            throws ConfigurationException
    {
<span class="fc" id="L1033">        final File envFile =</span>
<span class="fc" id="L1034">                ConfigurationAssert.getTestFile(&quot;testCCEnvProperties.xml&quot;);</span>
<span class="fc" id="L1035">        final String basePath = ConfigurationAssert.OUT_DIR.getAbsolutePath();</span>
<span class="fc" id="L1036">        builder.configure(new CombinedBuilderParametersImpl().setBasePath(</span>
<span class="fc" id="L1037">                basePath).setDefinitionBuilderParameters(</span>
<span class="fc" id="L1038">                createParameters().setFile(envFile)));</span>
<span class="fc" id="L1039">        builder.getConfiguration();</span>
<span class="fc" id="L1040">        final CombinedBuilderParametersImpl params =</span>
                new CombinedBuilderParametersImpl();
<span class="fc" id="L1042">        builder.initChildBuilderParameters(params);</span>
<span class="fc" id="L1043">        assertEquals(&quot;Base path not set&quot;, basePath, params.getBasePath());</span>
<span class="fc" id="L1044">    }</span>

    /**
     * Tests whether default child properties in the combined builder's
     * configuration are inherited by child parameter objects.
     */
    @Test
    public void testInitChildBuilderParametersDefaultChildProperties()
            throws ConfigurationException
    {
<span class="fc" id="L1054">        final Long defRefresh = 60000L;</span>
<span class="fc" id="L1055">        final Long xmlRefresh = 30000L;</span>
<span class="fc" id="L1056">        builder.configure(parameters</span>
<span class="fc" id="L1057">                .combined()</span>
<span class="fc" id="L1058">                .setDefinitionBuilderParameters(</span>
<span class="fc" id="L1059">                        parameters.fileBased().setFile(TEST_FILE))</span>
<span class="fc" id="L1060">                .registerChildDefaultsHandler(</span>
                        FileBasedBuilderProperties.class,
                        new CopyObjectDefaultHandler(
                                new FileBasedBuilderParametersImpl()
<span class="fc" id="L1064">                                        .setReloadingRefreshDelay(defRefresh)</span>
<span class="fc" id="L1065">                                        .setThrowExceptionOnMissing(true)))</span>
<span class="fc" id="L1066">                .registerChildDefaultsHandler(</span>
                        XMLBuilderProperties.class,
                        new CopyObjectDefaultHandler(
                                new XMLBuilderParametersImpl()
<span class="fc" id="L1070">                                        .setValidating(false)</span>
<span class="fc" id="L1071">                                        .setExpressionEngine(</span>
                                                new XPathExpressionEngine())
<span class="fc" id="L1073">                                        .setReloadingRefreshDelay(xmlRefresh))));</span>
<span class="fc" id="L1074">        builder.getConfiguration();</span>
<span class="fc" id="L1075">        final XMLBuilderParametersImpl params = new XMLBuilderParametersImpl();</span>
<span class="fc" id="L1076">        builder.initChildBuilderParameters(params);</span>
<span class="fc" id="L1077">        assertTrue(</span>
                &quot;Wrong expression engine&quot;,
<span class="fc" id="L1079">                params.getParameters().get(&quot;expressionEngine&quot;) instanceof XPathExpressionEngine);</span>
<span class="fc" id="L1080">        assertEquals(&quot;Validating flag not set&quot;, Boolean.FALSE, params</span>
<span class="fc" id="L1081">                .getParameters().get(&quot;validating&quot;));</span>
<span class="fc" id="L1082">        assertEquals(&quot;Wrong XML refresh&quot;, xmlRefresh,</span>
<span class="fc" id="L1083">                params.getReloadingRefreshDelay());</span>
<span class="fc" id="L1084">        assertEquals(&quot;Basic flag not set&quot;, Boolean.TRUE, params.getParameters()</span>
<span class="fc" id="L1085">                .get(&quot;throwExceptionOnMissing&quot;));</span>

<span class="fc" id="L1087">        final PropertiesBuilderParametersImpl params2 =</span>
                new PropertiesBuilderParametersImpl();
<span class="fc" id="L1089">        builder.initChildBuilderParameters(params2);</span>
<span class="fc" id="L1090">        assertEquals(&quot;Wrong default refresh&quot;, defRefresh,</span>
<span class="fc" id="L1091">                params2.getReloadingRefreshDelay());</span>
<span class="fc" id="L1092">    }</span>

    /**
     * Tests whether a Lookup object can be declared in the definition
     * configuration.
     */
    @Test
    public void testCustomLookup() throws ConfigurationException
    {
<span class="fc" id="L1101">        final File testFile = ConfigurationAssert.getTestFile(&quot;testCCLookup.xml&quot;);</span>
<span class="fc" id="L1102">        builder.configure(createParameters()</span>
<span class="fc" id="L1103">                .setFile(testFile));</span>
<span class="fc" id="L1104">        final CombinedConfiguration cc = builder.getConfiguration();</span>
<span class="fc" id="L1105">        assertTrue(&quot;Lookup not registered in CC&quot;, cc.getInterpolator()</span>
<span class="fc" id="L1106">                .getLookups().containsKey(&quot;test&quot;));</span>
<span class="fc" id="L1107">        final Configuration xmlConf = cc.getConfiguration(&quot;xml&quot;);</span>
<span class="fc" id="L1108">        assertTrue(&quot;Lookup not registered in sub config&quot;, xmlConf</span>
<span class="fc" id="L1109">                .getInterpolator().getLookups().containsKey(&quot;test&quot;));</span>
<span class="fc" id="L1110">    }</span>

    /**
     * Tests whether variable substitution works across multiple child
     * configurations and also in the definition configuration.
     */
    @Test
    public void testInterpolationOverMultipleSources()
            throws ConfigurationException
    {
<span class="fc" id="L1120">        final File testFile =</span>
<span class="fc" id="L1121">                ConfigurationAssert.getTestFile(&quot;testInterpolationBuilder.xml&quot;);</span>
<span class="fc" id="L1122">        builder.configure(createParameters().setFile(testFile));</span>
<span class="fc" id="L1123">        final CombinedConfiguration combConfig = builder.getConfiguration();</span>
<span class="fc" id="L1124">        assertEquals(&quot;Wrong value&quot;, &quot;abc-product&quot;,</span>
<span class="fc" id="L1125">                combConfig.getString(&quot;products.product.desc&quot;));</span>
<span class="fc" id="L1126">        final XMLConfiguration xmlConfig =</span>
<span class="fc" id="L1127">                (XMLConfiguration) combConfig.getConfiguration(&quot;test&quot;);</span>
<span class="fc" id="L1128">        assertEquals(&quot;Wrong value from XML config&quot;, &quot;abc-product&quot;,</span>
<span class="fc" id="L1129">                xmlConfig.getString(&quot;products/product/desc&quot;));</span>
<span class="fc" id="L1130">        final HierarchicalConfiguration&lt;ImmutableNode&gt; subConfig =</span>
                xmlConfig
<span class="fc" id="L1132">                        .configurationAt(&quot;products/product[@name='abc']&quot;, true);</span>
<span class="fc" id="L1133">        assertEquals(&quot;Wrong value from sub config&quot;, &quot;abc-product&quot;,</span>
<span class="fc" id="L1134">                subConfig.getString(&quot;desc&quot;));</span>
<span class="fc" id="L1135">    }</span>

    /**
     * Tests whether all child builders can be obtained.
     */
    @Test
    public void testGetChildBuilders() throws ConfigurationException
    {
<span class="fc" id="L1143">        builder.configure(createParameters()</span>
<span class="fc" id="L1144">                .setFile(TEST_FILE));</span>
<span class="fc" id="L1145">        builder.getConfiguration();</span>
<span class="fc" id="L1146">        final Collection&lt;ConfigurationBuilder&lt;? extends Configuration&gt;&gt; childBuilders =</span>
<span class="fc" id="L1147">                builder.getChildBuilders();</span>
<span class="fc" id="L1148">        assertEquals(&quot;Wrong number of child builders&quot;, 3, childBuilders.size());</span>
<span class="fc" id="L1149">    }</span>

    /**
     * Tests that child configuration builders are not initialized multiple
     * times. This test is releated to CONFIGURATION-687.
     */
    @Test
    public void testChildBuildersAreInitializedOnlyOnce()
            throws ConfigurationException
    {
<span class="fc" id="L1159">        builder.configure(createParameters().setFile(TEST_FILE));</span>
<span class="fc" id="L1160">        builder.getConfiguration();</span>
<span class="fc" id="L1161">        builder.resetResult();</span>
<span class="fc" id="L1162">        builder.getConfiguration();</span>
<span class="fc" id="L1163">        final Collection&lt;ConfigurationBuilder&lt;? extends Configuration&gt;&gt; childBuilders =</span>
<span class="fc" id="L1164">                builder.getChildBuilders();</span>
<span class="fc" id="L1165">        assertEquals(&quot;Wrong number of child builders&quot;, 3, childBuilders.size());</span>
<span class="fc" id="L1166">    }</span>

    /**
     * Loads a test file which includes a MultiFileConfigurationBuilder
     * declaration and returns the resulting configuration.
     *
     * @param fileName the name of the file to be loaded
     * @return the resulting combined configuration
     * @throws ConfigurationException if an error occurs
     */
    private CombinedConfiguration createMultiFileConfig(final String fileName)
            throws ConfigurationException
    {
<span class="fc" id="L1179">        final File testFile = ConfigurationAssert.getTestFile(fileName);</span>
<span class="fc" id="L1180">        builder.configure(createParameters()</span>
<span class="fc" id="L1181">                .setFile(testFile));</span>
<span class="fc" id="L1182">        final CombinedConfiguration config = builder.getConfiguration();</span>
<span class="fc" id="L1183">        assertTrue(&quot;Incorrect result configuration&quot;,</span>
                config instanceof DynamicCombinedConfiguration);
<span class="fc" id="L1185">        return config;</span>
    }

    /**
     * Tests whether a MultiFileConfigurationBuilder can be integrated into a
     * combined configuration definition.
     */
    @Test
    public void testMultiTenentConfiguration() throws ConfigurationException
    {
<span class="fc" id="L1195">        final CombinedConfiguration config = createMultiFileConfig(&quot;testCCMultiTenent.xml&quot;);</span>
<span class="fc" id="L1196">        checkMultiFile(&quot;1001&quot;, config, 15);</span>
<span class="fc" id="L1197">        checkMultiFile(&quot;1002&quot;, config, 25);</span>
<span class="fc" id="L1198">        checkMultiFile(&quot;1003&quot;, config, 35);</span>
<span class="fc" id="L1199">        checkMultiFile(&quot;1004&quot;, config, 50);</span>
<span class="fc" id="L1200">    }</span>

    /**
     * Tests whether a configuration created by a MultiFileConfigurationBuilder
     * has been initialized correctly.
     */
    @Test
    public void testMultiTenentConfigurationProperties()
            throws ConfigurationException
    {
<span class="fc" id="L1210">        final CombinedConfiguration config = createMultiFileConfig(&quot;testCCMultiTenent.xml&quot;);</span>
<span class="fc" id="L1211">        switchToMultiFile(&quot;1001&quot;);</span>
<span class="fc" id="L1212">        final HierarchicalConfiguration&lt;?&gt; multiConf =</span>
                (HierarchicalConfiguration&lt;?&gt;) config
<span class="fc" id="L1214">                        .getConfiguration(&quot;clientConfig&quot;);</span>
<span class="fc" id="L1215">        assertTrue(</span>
                &quot;Expression engine not configured&quot;,
<span class="fc" id="L1217">                multiConf.getExpressionEngine() instanceof XPathExpressionEngine);</span>
<span class="fc" id="L1218">        assertEquals(&quot;Wrong bg color&quot;, &quot;#808080&quot;,</span>
<span class="fc" id="L1219">                config.getString(&quot;colors.background&quot;));</span>
<span class="fc" id="L1220">        assertEquals(&quot;Wrong text color&quot;, &quot;#000000&quot;,</span>
<span class="fc" id="L1221">                multiConf.getString(&quot;colors/text&quot;));</span>
<span class="fc" id="L1222">    }</span>

    /**
     * Helper method for testing whether properties of a MultiFileConfiguration
     * can be obtained.
     *
     * @param key the key of the file to be accessed
     * @param config the configuration to check
     * @param rows the expected value of the test property
     */
    private void checkMultiFile(final String key, final CombinedConfiguration config,
            final int rows)
    {
<span class="fc" id="L1235">        switchToMultiFile(key);</span>
<span class="fc" id="L1236">        assertEquals(&quot;Wrong property value&quot;, rows, config.getInt(&quot;rowsPerPage&quot;));</span>
<span class="fc" id="L1237">    }</span>

    /**
     * Sets the system property which selects a specific file managed by a
     * MultiFileConfigurationBuilder.
     *
     * @param key the key to select the desired file
     */
    private static void switchToMultiFile(final String key)
    {
<span class="fc" id="L1247">        System.setProperty(MULTI_FILE_PROPERTY, key);</span>
<span class="fc" id="L1248">    }</span>

    /**
     * Tests whether reloading support works for MultiFileConfigurationBuilder.
     */
    @Test
    public void testMultiTenentConfigurationReloading()
            throws ConfigurationException, InterruptedException
    {
<span class="fc" id="L1257">        final CombinedConfiguration config =</span>
<span class="fc" id="L1258">                createMultiFileConfig(&quot;testCCMultiTenentReloading.xml&quot;);</span>
<span class="fc" id="L1259">        final File outFile =</span>
<span class="fc" id="L1260">                ConfigurationAssert.getOutFile(&quot;MultiFileReloadingTest.xml&quot;);</span>
<span class="fc" id="L1261">        switchToMultiFile(outFile.getAbsolutePath());</span>
<span class="fc" id="L1262">        final XMLConfiguration reloadConfig = new XMLConfiguration();</span>
<span class="fc" id="L1263">        final FileHandler handler = new FileHandler(reloadConfig);</span>
<span class="fc" id="L1264">        handler.setFile(outFile);</span>
<span class="fc" id="L1265">        final String key = &quot;test.reload&quot;;</span>
<span class="fc" id="L1266">        reloadConfig.setProperty(key, &quot;no&quot;);</span>
<span class="fc" id="L1267">        handler.save();</span>
        try
        {
<span class="fc" id="L1270">            assertEquals(&quot;Wrong property&quot;, &quot;no&quot;, config.getString(key));</span>
<span class="fc" id="L1271">            final ConfigurationBuilder&lt;? extends Configuration&gt; childBuilder =</span>
<span class="fc" id="L1272">                    builder.getNamedBuilder(&quot;clientConfig&quot;);</span>
<span class="fc" id="L1273">            assertTrue(&quot;Not a reloading builder&quot;,</span>
                    childBuilder instanceof ReloadingControllerSupport);
<span class="fc" id="L1275">            final ReloadingController ctrl =</span>
                    ((ReloadingControllerSupport) childBuilder)
<span class="fc" id="L1277">                            .getReloadingController();</span>
<span class="fc" id="L1278">            ctrl.checkForReloading(null); // initialize reloading</span>
<span class="fc" id="L1279">            final BuilderEventListenerImpl l = new BuilderEventListenerImpl();</span>
<span class="fc" id="L1280">            childBuilder.addEventListener(ConfigurationBuilderEvent.RESET, l);</span>
<span class="fc" id="L1281">            reloadConfig.setProperty(key, &quot;yes&quot;);</span>
<span class="fc" id="L1282">            handler.save();</span>

<span class="fc" id="L1284">            int attempts = 10;</span>
            boolean changeDetected;
            do
            {
<span class="fc" id="L1288">                changeDetected = ctrl.checkForReloading(null);</span>
<span class="fc bfc" id="L1289" title="All 2 branches covered.">                if (!changeDetected)</span>
                {
<span class="fc" id="L1291">                    Thread.sleep(1000);</span>
<span class="fc" id="L1292">                    handler.save(outFile);</span>
                }
<span class="pc bpc" id="L1294" title="1 of 4 branches missed.">            } while (!changeDetected &amp;&amp; --attempts &gt; 0);</span>
<span class="fc" id="L1295">            assertTrue(&quot;No change detected&quot;, changeDetected);</span>
<span class="fc" id="L1296">            assertEquals(&quot;Wrong updated property&quot;, &quot;yes&quot;, builder</span>
<span class="fc" id="L1297">                    .getConfiguration().getString(key));</span>
<span class="fc" id="L1298">            final ConfigurationBuilderEvent event = l.nextEvent(ConfigurationBuilderEvent.RESET);</span>
<span class="fc" id="L1299">            l.assertNoMoreEvents();</span>
<span class="fc" id="L1300">            final BasicConfigurationBuilder&lt;? extends Configuration&gt; multiBuilder =</span>
<span class="fc" id="L1301">                    (BasicConfigurationBuilder&lt;? extends Configuration&gt;) event.getSource();</span>
<span class="fc" id="L1302">            childBuilder.removeEventListener(ConfigurationBuilderEvent.RESET, l);</span>
<span class="fc" id="L1303">            multiBuilder.resetResult();</span>
<span class="fc" id="L1304">            l.assertNoMoreEvents();</span>
        }
        finally
        {
<span class="fc" id="L1308">            assertTrue(&quot;Output file could not be deleted&quot;, outFile.delete());</span>
        }
<span class="fc" id="L1310">    }</span>

    /**
     * Tests that the combined configuration has been fully constructed
     * (including its root node) when it is returned from the builder.
     */
    @Test
    public void testRootNodeInitializedAfterCreation()
            throws ConfigurationException
    {
<span class="fc" id="L1320">        builder.configure(createParameters()</span>
<span class="fc" id="L1321">                .setFile(TEST_FILE));</span>
<span class="fc" id="L1322">        final CombinedConfiguration cc = builder.getConfiguration();</span>
<span class="fc" id="L1323">        assertNotNull(&quot;Root node not initialized&quot;, cc.getNodeModel()</span>
<span class="fc" id="L1324">                .getNodeHandler().getRootNode());</span>
<span class="fc" id="L1325">    }</span>

    /**
     * Tests whether a newly created instance can be read concurrently without a
     * special synchronizer.
     */
    @Test
    public void testConcurrentReadAccessWithoutSynchronizer()
            throws ConfigurationException
    {
<span class="fc" id="L1335">        builder.configure(createParameters()</span>
<span class="fc" id="L1336">                .setFile(TEST_FILE));</span>
<span class="fc" id="L1337">        final CombinedConfiguration config = builder.getConfiguration();</span>
<span class="fc" id="L1338">        final int threadCount = 32;</span>
<span class="fc" id="L1339">        final CountDownLatch startLatch = new CountDownLatch(1);</span>
<span class="fc" id="L1340">        final ReadThread[] threads = new ReadThread[threadCount];</span>
<span class="fc bfc" id="L1341" title="All 2 branches covered.">        for (int i = 0; i &lt; threadCount; i++)</span>
        {
<span class="fc" id="L1343">            threads[i] = new ReadThread(config, startLatch);</span>
<span class="fc" id="L1344">            threads[i].start();</span>
        }

<span class="fc" id="L1347">        startLatch.countDown();</span>
<span class="fc bfc" id="L1348" title="All 2 branches covered.">        for (final ReadThread t : threads)</span>
        {
<span class="fc" id="L1350">            t.verify();</span>
        }
<span class="fc" id="L1352">    }</span>

    /**
     * Prepares a parameters object for a test for properties inheritance.
     * @param params the {@code Parameters} object
     * @return the builder parameters
     */
    private static XMLBuilderParameters prepareParamsForInheritanceTest(final Parameters params) {
<span class="fc" id="L1360">        final DefaultExpressionEngineSymbols symbols = new DefaultExpressionEngineSymbols.Builder(</span>
                DefaultExpressionEngineSymbols.DEFAULT_SYMBOLS)
<span class="fc" id="L1362">                .setPropertyDelimiter(&quot;/&quot;).create();</span>
<span class="fc" id="L1363">        final DefaultExpressionEngine engine = new DefaultExpressionEngine(symbols);</span>
<span class="fc" id="L1364">        final DefaultListDelimiterHandler listDelimiterHandler = new DefaultListDelimiterHandler(',');</span>
<span class="fc" id="L1365">        return params.xml()</span>
<span class="fc" id="L1366">                .setExpressionEngine(engine)</span>
<span class="fc" id="L1367">                .setListDelimiterHandler(listDelimiterHandler).setFile(TEST_FILE);</span>
    }

    /**
     * Tests whether builder properties can be inherited by child builders.
     */
    @Test
    public void testInheritProperties() throws ConfigurationException
    {
<span class="fc" id="L1376">        final Parameters params = new Parameters();</span>
<span class="fc" id="L1377">        final XMLBuilderParameters xmlParams =</span>
<span class="fc" id="L1378">                prepareParamsForInheritanceTest(params);</span>
<span class="fc" id="L1379">        builder.configure(xmlParams);</span>
<span class="fc" id="L1380">        final CombinedConfiguration config = builder.getConfiguration();</span>

<span class="fc" id="L1382">        List&lt;String&gt; list = config.getList(String.class, &quot;test/mixed/array&quot;);</span>
<span class="pc bpc" id="L1383" title="1 of 2 branches missed.">        assertTrue(&quot;Wrong number of elements in list&quot;, list.size() &gt; 2);</span>
<span class="fc" id="L1384">        final String[] stringArray = config.getStringArray(&quot;test/mixed/array&quot;);</span>
<span class="pc bpc" id="L1385" title="1 of 2 branches missed.">        assertTrue(&quot;Wrong number of elements in array&quot;, stringArray.length &gt; 2);</span>
<span class="fc" id="L1386">        final XMLConfiguration xmlConfig =</span>
<span class="fc" id="L1387">                (XMLConfiguration) config.getConfiguration(&quot;xml&quot;);</span>
<span class="fc" id="L1388">        list = xmlConfig.getList(String.class, &quot;split/list1&quot;);</span>
<span class="fc" id="L1389">        assertEquals(&quot;Wrong number of elements in XML list&quot;, 3, list.size());</span>
<span class="fc" id="L1390">    }</span>

    /**
     * Tests whether the inheritance of builder properties can be disabled.
     */
    @Test
    public void testSuppressChildBuilderPropertyInheritance()
            throws ConfigurationException
    {
<span class="fc" id="L1399">        final Parameters params = new Parameters();</span>
<span class="fc" id="L1400">        final CombinedBuilderParameters combinedParams =</span>
<span class="fc" id="L1401">                params.combined().setInheritSettings(false);</span>
<span class="fc" id="L1402">        builder.configure(combinedParams,</span>
<span class="fc" id="L1403">                prepareParamsForInheritanceTest(params));</span>
<span class="fc" id="L1404">        final CombinedConfiguration config = builder.getConfiguration();</span>

<span class="fc" id="L1406">        final XMLConfiguration xmlConfig =</span>
<span class="fc" id="L1407">                (XMLConfiguration) config.getConfiguration(&quot;xml&quot;);</span>
<span class="fc" id="L1408">        final List&lt;String&gt; list = xmlConfig.getList(String.class, &quot;split.list1&quot;);</span>
<span class="fc" id="L1409">        assertEquals(&quot;Wrong number of elements in XML list&quot;, 1, list.size());</span>
<span class="fc" id="L1410">    }</span>

    /**
     * A test builder provider implementation for testing whether providers can
     * be defined in the definition file.
     */
<span class="fc" id="L1416">    public static class BuilderProviderTestImpl implements</span>
            ConfigurationBuilderProvider
    {
        /** The test property key of the configuration to be created. */
        private String propertyKey;

        public String getPropertyKey()
        {
<span class="fc" id="L1424">            return propertyKey;</span>
        }

        public void setPropertyKey(final String propertyKey)
        {
<span class="fc" id="L1429">            this.propertyKey = propertyKey;</span>
<span class="fc" id="L1430">        }</span>

        @Override
        public ConfigurationBuilder&lt;? extends Configuration&gt; getConfigurationBuilder(
                final ConfigurationDeclaration decl) throws ConfigurationException
        {
<span class="fc" id="L1436">            final BaseHierarchicalConfiguration config =</span>
                    new BaseHierarchicalConfiguration();
<span class="fc" id="L1438">            config.addProperty(getPropertyKey(), Boolean.TRUE);</span>
<span class="fc" id="L1439">            return new ConstantConfigurationBuilder(config);</span>
        }
    }

    /**
     * A test builder class which always returns the same configuration.
     */
    private static class ConstantConfigurationBuilder extends
            BasicConfigurationBuilder&lt;BaseHierarchicalConfiguration&gt;
    {
        private final BaseHierarchicalConfiguration configuration;

        public ConstantConfigurationBuilder(final BaseHierarchicalConfiguration conf)
        {
<span class="fc" id="L1453">            super(BaseHierarchicalConfiguration.class);</span>
<span class="fc" id="L1454">            configuration = conf;</span>
<span class="fc" id="L1455">        }</span>

        @Override
        public BaseHierarchicalConfiguration getConfiguration()
                throws ConfigurationException
        {
<span class="fc" id="L1461">            return configuration;</span>
        }
    }

    /**
     * A specialized entity resolver implementation for testing whether
     * properties of a catalog resolver are correctly set.
     */
<span class="fc" id="L1469">    public static class EntityResolverWithPropertiesTestImpl extends</span>
            CatalogResolver
    {
        /** The base directory. */
        private String baseDirectory;

        /** The file system. */
        private FileSystem fileSystem;

        /** The ConfigurationInterpolator. */
        private ConfigurationInterpolator interpolator;

        public FileSystem getFileSystem()
        {
<span class="fc" id="L1483">            return fileSystem;</span>
        }

        @Override
        public void setFileSystem(final FileSystem fileSystem)
        {
<span class="fc" id="L1489">            super.setFileSystem(fileSystem);</span>
<span class="fc" id="L1490">            this.fileSystem = fileSystem;</span>
<span class="fc" id="L1491">        }</span>

        public String getBaseDir()
        {
<span class="fc" id="L1495">            return baseDirectory;</span>
        }

        @Override
        public void setBaseDir(final String baseDir)
        {
<span class="fc" id="L1501">            super.setBaseDir(baseDir);</span>
<span class="fc" id="L1502">            baseDirectory = baseDir;</span>
<span class="fc" id="L1503">        }</span>

        public ConfigurationInterpolator getInterpolator()
        {
<span class="fc" id="L1507">            return interpolator;</span>
        }

        @Override
        public void setInterpolator(final ConfigurationInterpolator interpolator)
        {
<span class="fc" id="L1513">            super.setInterpolator(interpolator);</span>
<span class="fc" id="L1514">            this.interpolator = interpolator;</span>
<span class="fc" id="L1515">        }</span>
    }

    /**
     * A test file system implementation for testing whether a custom file
     * system class can be specified in the configuration definition file.
     */
<span class="fc" id="L1522">    public static class FileSystemTestImpl extends DefaultFileSystem</span>
    {
    }

    /**
     * A test combined configuration class for testing whether a specific result
     * configuration class can be declared in the definition configuration.
     */
<span class="fc" id="L1530">    public static class CombinedConfigurationTestImpl extends</span>
            CombinedConfiguration
    {
    }

    /**
     * A custom Lookup implementation for testing whether lookups can be defined
     * in the definition configuration. This lookup supports some variables
     * referencing test files.
     */
    public static class TestLookup implements Lookup
    {
<span class="fc" id="L1542">        private final Map&lt;String, String&gt; map = new HashMap&lt;&gt;();</span>

        public TestLookup()
<span class="fc" id="L1545">        {</span>
<span class="fc" id="L1546">            map.put(&quot;test_file_xml&quot;, &quot;test.xml&quot;);</span>
<span class="fc" id="L1547">            map.put(&quot;test_file_combine&quot;, &quot;testcombine1.xml&quot;);</span>
<span class="fc" id="L1548">            map.put(&quot;test_key&quot;, &quot;test.value&quot;);</span>
<span class="fc" id="L1549">        }</span>

        @Override
        public String lookup(final String key)
        {
<span class="fc" id="L1554">            return map.get(key);</span>
        }
    }

    /**
     * A thread class for testing concurrent read access to a newly created
     * configuration.
     */
    private static class ReadThread extends Thread
    {
        /** The configuration to access. */
        private final CombinedConfiguration config;

        /** The start latch. */
        private final CountDownLatch startLatch;

        /** The value read from the configuration. */
        private Boolean value;

        public ReadThread(final CombinedConfiguration cc, final CountDownLatch latch)
<span class="fc" id="L1574">        {</span>
<span class="fc" id="L1575">            config = cc;</span>
<span class="fc" id="L1576">            startLatch = latch;</span>
<span class="fc" id="L1577">        }</span>

        @Override
        public void run()
        {
            try
            {
<span class="fc" id="L1584">                startLatch.await();</span>
<span class="fc" id="L1585">                value = config.getBoolean(&quot;configuration.loaded&quot;);</span>
            }
<span class="nc" id="L1587">            catch (final InterruptedException iex)</span>
            {
                // ignore
<span class="fc" id="L1590">            }</span>
<span class="fc" id="L1591">        }</span>

        /**
         * Verifies that the correct value was read.
         */
        public void verify()
        {
            try
            {
<span class="fc" id="L1600">                join();</span>
            }
<span class="nc" id="L1602">            catch (final InterruptedException iex)</span>
            {
<span class="nc" id="L1604">                fail(&quot;Waiting was interrupted: &quot; + iex);</span>
<span class="fc" id="L1605">            }</span>
<span class="fc" id="L1606">            assertEquals(&quot;Wrong value read&quot;, Boolean.TRUE, value);</span>
<span class="fc" id="L1607">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>