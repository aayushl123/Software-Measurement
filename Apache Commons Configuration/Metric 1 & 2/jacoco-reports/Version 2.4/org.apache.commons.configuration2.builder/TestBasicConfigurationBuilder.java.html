<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TestBasicConfigurationBuilder.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">commons_configuration2$Unnamed.exec</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.configuration2.builder</a> &gt; <span class="el_source">TestBasicConfigurationBuilder.java</span></div><h1>TestBasicConfigurationBuilder.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.commons.configuration2.builder;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotSame;
import static org.junit.Assert.assertSame;
import static org.junit.Assert.assertTrue;

import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

import org.apache.commons.configuration2.BaseConfiguration;
import org.apache.commons.configuration2.BaseHierarchicalConfiguration;
import org.apache.commons.configuration2.Configuration;
import org.apache.commons.configuration2.Initializable;
import org.apache.commons.configuration2.PropertiesConfiguration;
import org.apache.commons.configuration2.XMLConfiguration;
import org.apache.commons.configuration2.beanutils.BeanCreationContext;
import org.apache.commons.configuration2.beanutils.BeanDeclaration;
import org.apache.commons.configuration2.beanutils.BeanFactory;
import org.apache.commons.configuration2.beanutils.BeanHelper;
import org.apache.commons.configuration2.beanutils.DefaultBeanFactory;
import org.apache.commons.configuration2.beanutils.XMLBeanDeclaration;
import org.apache.commons.configuration2.convert.DefaultListDelimiterHandler;
import org.apache.commons.configuration2.convert.ListDelimiterHandler;
import org.apache.commons.configuration2.event.ConfigurationErrorEvent;
import org.apache.commons.configuration2.event.ConfigurationEvent;
import org.apache.commons.configuration2.event.ErrorListenerTestImpl;
import org.apache.commons.configuration2.event.EventListener;
import org.apache.commons.configuration2.event.EventListenerRegistrationData;
import org.apache.commons.configuration2.event.EventListenerTestImpl;
import org.apache.commons.configuration2.ex.ConfigurationException;
import org.apache.commons.configuration2.ex.ConfigurationRuntimeException;
import org.apache.commons.configuration2.reloading.ReloadingController;
import org.apache.commons.configuration2.reloading.ReloadingDetector;
import org.easymock.EasyMock;
import org.junit.BeforeClass;
import org.junit.Test;

/**
 * Test class for {@code BasicConfigurationBuilder}.
 *
 * @version $Id$
 */
<span class="fc" id="L66">public class TestBasicConfigurationBuilder</span>
{
    /** A test list delimiter handler. */
    private static ListDelimiterHandler listHandler;

    @BeforeClass
    public static void setUpBeforeClass() throws Exception
    {
<span class="fc" id="L74">        listHandler = new DefaultListDelimiterHandler(';');</span>
<span class="fc" id="L75">    }</span>

    /**
     * Tries to create an instance without a result class.
     */
    @Test(expected = IllegalArgumentException.class)
    public void testInitNoClass()
    {
<span class="nc" id="L83">        new BasicConfigurationBuilder&lt;Configuration&gt;(null);</span>
<span class="nc" id="L84">    }</span>

    /**
     * Creates a map with test initialization parameters.
     *
     * @return the map with parameters
     */
    private static Map&lt;String, Object&gt; createTestParameters()
    {
<span class="fc" id="L93">        final Map&lt;String, Object&gt; params = new HashMap&lt;&gt;();</span>
<span class="fc" id="L94">        params.put(&quot;throwExceptionOnMissing&quot;, Boolean.TRUE);</span>
<span class="fc" id="L95">        params.put(&quot;listDelimiterHandler&quot;, listHandler);</span>
<span class="fc" id="L96">        return params;</span>
    }

    /**
     * Tests whether initialization parameters can be passed to the constructor.
     */
    @Test
    public void testInitWithParameters()
    {
<span class="fc" id="L105">        final Map&lt;String, Object&gt; params = createTestParameters();</span>
<span class="fc" id="L106">        final BasicConfigurationBuilder&lt;Configuration&gt; builder =</span>
                new BasicConfigurationBuilder&lt;&gt;(
                        PropertiesConfiguration.class, params);
<span class="fc" id="L109">        final Map&lt;String, Object&gt; params2 =</span>
<span class="fc" id="L110">                new HashMap&lt;&gt;(builder.getParameters());</span>
<span class="fc" id="L111">        assertEquals(&quot;Wrong parameters&quot;, createTestParameters(), params2);</span>
<span class="fc" id="L112">    }</span>

    /**
     * Tests whether a copy of the passed in parameters is created.
     */
    @Test
    public void testInitWithParametersDefensiveCopy()
    {
<span class="fc" id="L120">        final Map&lt;String, Object&gt; params = createTestParameters();</span>
<span class="fc" id="L121">        final BasicConfigurationBuilder&lt;PropertiesConfiguration&gt; builder =</span>
                new BasicConfigurationBuilder&lt;&gt;(
                        PropertiesConfiguration.class, params);
<span class="fc" id="L124">        params.put(&quot;anotherParameter&quot;, &quot;value&quot;);</span>
<span class="fc" id="L125">        final Map&lt;String, Object&gt; params2 =</span>
<span class="fc" id="L126">                new HashMap&lt;&gt;(builder.getParameters());</span>
<span class="fc" id="L127">        assertEquals(&quot;Wrong parameters&quot;, createTestParameters(), params2);</span>
<span class="fc" id="L128">    }</span>

    /**
     * Tests whether null parameters are handled correctly.
     */
    @Test
    public void testInitWithParametersNull()
    {
<span class="fc" id="L136">        final BasicConfigurationBuilder&lt;PropertiesConfiguration&gt; builder =</span>
                new BasicConfigurationBuilder&lt;&gt;(
                        PropertiesConfiguration.class, null);
<span class="fc" id="L139">        assertTrue(&quot;Got parameters&quot;, builder.getParameters().isEmpty());</span>
<span class="fc" id="L140">    }</span>

    /**
     * Tests that the map with parameters cannot be modified.
     */
    @Test(expected = UnsupportedOperationException.class)
    public void testGetParametersModify()
    {
<span class="fc" id="L148">        final BasicConfigurationBuilder&lt;PropertiesConfiguration&gt; builder =</span>
                new BasicConfigurationBuilder&lt;&gt;(
<span class="fc" id="L150">                        PropertiesConfiguration.class, createTestParameters());</span>
<span class="nc" id="L151">        builder.getParameters().clear();</span>
<span class="nc" id="L152">    }</span>

    /**
     * Tests whether parameters can be set using the configure() method.
     */
    @Test
    public void testConfigure()
    {
<span class="fc" id="L160">        final BasicConfigurationBuilder&lt;PropertiesConfiguration&gt; builder =</span>
                new BasicConfigurationBuilder&lt;&gt;(
                        PropertiesConfiguration.class)
<span class="fc" id="L163">                        .configure(new BasicBuilderParameters()</span>
<span class="fc" id="L164">                                .setListDelimiterHandler(listHandler)</span>
<span class="fc" id="L165">                                .setThrowExceptionOnMissing(true));</span>
<span class="fc" id="L166">        final Map&lt;String, Object&gt; params2 =</span>
<span class="fc" id="L167">                new HashMap&lt;&gt;(builder.getParameters());</span>
<span class="fc" id="L168">        assertEquals(&quot;Wrong parameters&quot;, createTestParameters(), params2);</span>
<span class="fc" id="L169">    }</span>

    /**
     * Tests whether new parameters can be set to replace existing ones.
     */
    @Test
    public void testSetParameters()
    {
<span class="fc" id="L177">        final Map&lt;String, Object&gt; params1 = new HashMap&lt;&gt;();</span>
<span class="fc" id="L178">        params1.put(&quot;someParameter&quot;, &quot;value&quot;);</span>
<span class="fc" id="L179">        final BasicConfigurationBuilder&lt;PropertiesConfiguration&gt; builder =</span>
                new BasicConfigurationBuilder&lt;&gt;(
                        PropertiesConfiguration.class, params1);
<span class="fc" id="L182">        assertSame(&quot;Wrong result&quot;, builder,</span>
<span class="fc" id="L183">                builder.setParameters(createTestParameters()));</span>
<span class="fc" id="L184">        final Map&lt;String, Object&gt; params2 =</span>
<span class="fc" id="L185">                new HashMap&lt;&gt;(builder.getParameters());</span>
<span class="fc" id="L186">        assertEquals(&quot;Wrong parameters&quot;, createTestParameters(), params2);</span>
<span class="fc" id="L187">    }</span>

    /**
     * Tests whether additional parameters can be added.
     */
    @Test
    public void testAddParameters()
    {
<span class="fc" id="L195">        final BasicConfigurationBuilder&lt;PropertiesConfiguration&gt; builder =</span>
                new BasicConfigurationBuilder&lt;&gt;(
<span class="fc" id="L197">                        PropertiesConfiguration.class, createTestParameters());</span>
<span class="fc" id="L198">        final Map&lt;String, Object&gt; params = createTestParameters();</span>
<span class="fc" id="L199">        params.put(&quot;anotherParameter&quot;, &quot;value&quot;);</span>
<span class="fc" id="L200">        assertSame(&quot;Wrong result&quot;, builder, builder.addParameters(params));</span>
<span class="fc" id="L201">        final Map&lt;String, Object&gt; params2 = builder.getParameters();</span>
<span class="fc" id="L202">        assertTrue(&quot;No original parameters&quot;,</span>
<span class="fc" id="L203">                params2.keySet().containsAll(createTestParameters().keySet()));</span>
<span class="fc" id="L204">        assertEquals(&quot;Additional parameter not found&quot;, &quot;value&quot;,</span>
<span class="fc" id="L205">                params2.get(&quot;anotherParameter&quot;));</span>
<span class="fc" id="L206">    }</span>

    /**
     * Tests whether null parameters are handled correctly by addParameters().
     */
    @Test
    public void testAddParametersNull()
    {
<span class="fc" id="L214">        final BasicConfigurationBuilder&lt;PropertiesConfiguration&gt; builder =</span>
                new BasicConfigurationBuilder&lt;&gt;(
<span class="fc" id="L216">                        PropertiesConfiguration.class, createTestParameters());</span>
<span class="fc" id="L217">        final Map&lt;String, Object&gt; params = builder.getParameters();</span>
<span class="fc" id="L218">        builder.addParameters(null);</span>
<span class="fc" id="L219">        assertEquals(&quot;Parameters changed&quot;, params, builder.getParameters());</span>
<span class="fc" id="L220">    }</span>

    /**
     * Tests whether all parameters can be reset.
     */
    @Test
    public void testResetParameters()
    {
<span class="fc" id="L228">        final BasicConfigurationBuilder&lt;PropertiesConfiguration&gt; builder =</span>
                new BasicConfigurationBuilder&lt;&gt;(
<span class="fc" id="L230">                        PropertiesConfiguration.class, createTestParameters());</span>
<span class="fc" id="L231">        builder.resetParameters();</span>
<span class="fc" id="L232">        assertTrue(&quot;Still got parameters&quot;, builder.getParameters().isEmpty());</span>
<span class="fc" id="L233">    }</span>

    /**
     * Tests whether the builder can create a correctly initialized
     * configuration object.
     */
    @Test
    public void testGetConfiguration() throws ConfigurationException
    {
<span class="fc" id="L242">        final PropertiesConfiguration config =</span>
                new BasicConfigurationBuilder&lt;&gt;(
<span class="fc" id="L244">                        PropertiesConfiguration.class).configure(</span>
<span class="fc" id="L245">                        new BasicBuilderParameters().setListDelimiterHandler(</span>
<span class="fc" id="L246">                                listHandler).setThrowExceptionOnMissing(true))</span>
<span class="fc" id="L247">                        .getConfiguration();</span>
<span class="fc" id="L248">        assertTrue(&quot;Wrong exception flag&quot;, config.isThrowExceptionOnMissing());</span>
<span class="fc" id="L249">        assertEquals(&quot;Wrong list delimiter handler&quot;, listHandler,</span>
<span class="fc" id="L250">                config.getListDelimiterHandler());</span>
<span class="fc" id="L251">    }</span>

    /**
     * Tests whether the builder can be accessed by multiple threads and that
     * only a single result object is produced.
     */
    @Test
    public void testGetConfigurationConcurrently() throws Exception
    {
<span class="fc" id="L260">        final int threadCount = 32;</span>
<span class="fc" id="L261">        final CountDownLatch startLatch = new CountDownLatch(1);</span>
<span class="fc" id="L262">        final CountDownLatch endLatch = new CountDownLatch(threadCount);</span>
<span class="fc" id="L263">        final ConfigurationBuilder&lt;?&gt; builder =</span>
                new BasicConfigurationBuilder&lt;&gt;(
                        PropertiesConfiguration.class);
<span class="fc" id="L266">        final AccessBuilderThread[] threads = new AccessBuilderThread[threadCount];</span>
<span class="fc bfc" id="L267" title="All 2 branches covered.">        for (int i = 0; i &lt; threadCount; i++)</span>
        {
<span class="fc" id="L269">            threads[i] = new AccessBuilderThread(startLatch, endLatch, builder);</span>
<span class="fc" id="L270">            threads[i].start();</span>
        }
<span class="fc" id="L272">        startLatch.countDown();</span>
<span class="fc" id="L273">        assertTrue(&quot;Timeout&quot;, endLatch.await(5, TimeUnit.SECONDS));</span>
<span class="fc" id="L274">        final Set&lt;Object&gt; results = new HashSet&lt;&gt;();</span>
<span class="fc bfc" id="L275" title="All 2 branches covered.">        for (final AccessBuilderThread t : threads)</span>
        {
<span class="fc" id="L277">            results.add(t.result);</span>
        }
<span class="fc" id="L279">        assertEquals(&quot;Wrong number of result objects&quot;, 1, results.size());</span>
<span class="fc" id="L280">    }</span>

    /**
     * Tests whether a reset of the result object can be performed.
     */
    @Test
    public void testResetResult() throws ConfigurationException
    {
<span class="fc" id="L288">        final BasicConfigurationBuilder&lt;PropertiesConfiguration&gt; builder =</span>
                new BasicConfigurationBuilder&lt;&gt;(
<span class="fc" id="L290">                        PropertiesConfiguration.class, createTestParameters());</span>
<span class="fc" id="L291">        final PropertiesConfiguration config = builder.getConfiguration();</span>
<span class="fc" id="L292">        builder.resetResult();</span>
<span class="fc" id="L293">        final PropertiesConfiguration config2 = builder.getConfiguration();</span>
<span class="fc" id="L294">        assertNotSame(&quot;No new result&quot;, config, config2);</span>
<span class="fc" id="L295">        assertTrue(&quot;Wrong property&quot;, config2.isThrowExceptionOnMissing());</span>
<span class="fc" id="L296">    }</span>

    /**
     * Tests a full reset of the builder.
     */
    @Test
    public void testReset() throws ConfigurationException
    {
<span class="fc" id="L304">        final BasicConfigurationBuilder&lt;PropertiesConfiguration&gt; builder =</span>
                new BasicConfigurationBuilder&lt;&gt;(
<span class="fc" id="L306">                        PropertiesConfiguration.class, createTestParameters());</span>
<span class="fc" id="L307">        final PropertiesConfiguration config = builder.getConfiguration();</span>
<span class="fc" id="L308">        builder.reset();</span>
<span class="fc" id="L309">        final PropertiesConfiguration config2 = builder.getConfiguration();</span>
<span class="fc" id="L310">        assertNotSame(&quot;No new result&quot;, config, config2);</span>
<span class="fc" id="L311">        assertFalse(&quot;Parameters not reset&quot;, config2.isThrowExceptionOnMissing());</span>
<span class="fc" id="L312">    }</span>

    /**
     * Tests whether a check for the correct bean class is made.
     */
    @Test(expected = ConfigurationRuntimeException.class)
    public void testGetResultDeclarationInvalidBeanClass()
            throws ConfigurationException
    {
<span class="fc" id="L321">        final BasicConfigurationBuilder&lt;PropertiesConfiguration&gt; builder =</span>
                new BasicConfigurationBuilder&lt;PropertiesConfiguration&gt;(
<span class="fc" id="L323">                        PropertiesConfiguration.class, createTestParameters())</span>
<span class="fc" id="L324">                {</span>
                    @Override
                    protected BeanDeclaration createResultDeclaration(
                            final Map&lt;String, Object&gt; params)
                    {
<span class="fc" id="L329">                        return new XMLBeanDeclaration(</span>
                                new BaseHierarchicalConfiguration(), &quot;bean&quot;,
<span class="fc" id="L331">                                true, Object.class.getName());</span>
                    }
                };
<span class="nc" id="L334">        builder.getConfiguration();</span>
<span class="nc" id="L335">    }</span>

    /**
     * Creates a mock for an event listener.
     *
     * @return the event listener mock
     */
    private static EventListener&lt;ConfigurationEvent&gt; createEventListener()
    {
        @SuppressWarnings(&quot;unchecked&quot;)
        final
<span class="fc" id="L346">        EventListener&lt;ConfigurationEvent&gt; listener =</span>
<span class="fc" id="L347">                EasyMock.createMock(EventListener.class);</span>
<span class="fc" id="L348">        return listener;</span>
    }

    /**
     * Tests whether configuration listeners can be added.
     */
    @Test
    public void testAddConfigurationListener() throws ConfigurationException
    {
<span class="fc" id="L357">        final EventListener&lt;ConfigurationEvent&gt; l1 = createEventListener();</span>
<span class="fc" id="L358">        final EventListener&lt;ConfigurationEvent&gt; l2 = createEventListener();</span>
<span class="fc" id="L359">        EasyMock.replay(l1, l2);</span>
<span class="fc" id="L360">        final BasicConfigurationBuilder&lt;PropertiesConfiguration&gt; builder =</span>
                new BasicConfigurationBuilder&lt;&gt;(
                        PropertiesConfiguration.class);
<span class="fc" id="L363">        builder.addEventListener(ConfigurationEvent.ANY, l1);</span>
<span class="fc" id="L364">        final PropertiesConfiguration config = builder.getConfiguration();</span>
<span class="fc" id="L365">        builder.addEventListener(ConfigurationEvent.ANY, l2);</span>
<span class="fc" id="L366">        final Collection&lt;EventListener&lt;? super ConfigurationEvent&gt;&gt; listeners =</span>
<span class="fc" id="L367">                config.getEventListeners(ConfigurationEvent.ANY);</span>
<span class="fc" id="L368">        assertTrue(&quot;Listener 1 not registered&quot;, listeners.contains(l1));</span>
<span class="fc" id="L369">        assertTrue(&quot;Listener 2 not registered&quot;, listeners.contains(l2));</span>
<span class="fc" id="L370">    }</span>

    /**
     * Tests whether configuration listeners can be removed.
     */
    @Test
    public void testRemoveConfigurationListener() throws ConfigurationException
    {
<span class="fc" id="L378">        final EventListener&lt;ConfigurationEvent&gt; l1 = createEventListener();</span>
<span class="fc" id="L379">        final EventListener&lt;ConfigurationEvent&gt; l2 = createEventListener();</span>
<span class="fc" id="L380">        EasyMock.replay(l1, l2);</span>
<span class="fc" id="L381">        final BasicConfigurationBuilder&lt;PropertiesConfiguration&gt; builder =</span>
                new BasicConfigurationBuilder&lt;&gt;(
                        PropertiesConfiguration.class);
<span class="fc" id="L384">        builder.addEventListener(ConfigurationEvent.ANY_HIERARCHICAL,</span>
                l1);
<span class="fc" id="L386">        builder.addEventListener(ConfigurationEvent.ANY, l2);</span>
<span class="fc" id="L387">        assertTrue(&quot;Wrong result&quot;,</span>
<span class="fc" id="L388">                builder.removeEventListener(ConfigurationEvent.ANY, l2));</span>
<span class="fc" id="L389">        final PropertiesConfiguration config = builder.getConfiguration();</span>
<span class="fc" id="L390">        assertFalse(&quot;Removed listener was registered&quot;, config</span>
<span class="fc" id="L391">                .getEventListeners(ConfigurationEvent.ANY).contains(l2));</span>
<span class="fc" id="L392">        assertTrue(&quot;Listener not registered&quot;,</span>
<span class="fc" id="L393">                config.getEventListeners(ConfigurationEvent.ANY_HIERARCHICAL)</span>
<span class="fc" id="L394">                        .contains(l1));</span>
<span class="fc" id="L395">        builder.removeEventListener(</span>
                ConfigurationEvent.ANY_HIERARCHICAL, l1);
<span class="fc" id="L397">        assertFalse(&quot;Listener still registered&quot;,</span>
<span class="fc" id="L398">                config.getEventListeners(ConfigurationEvent.ANY_HIERARCHICAL)</span>
<span class="fc" id="L399">                        .contains(l1));</span>
<span class="fc" id="L400">    }</span>

    /**
     * Tests whether event listeners can be copied to another builder.
     */
    @Test
    public void testCopyEventListeners() throws ConfigurationException
    {
<span class="fc" id="L408">        final EventListener&lt;ConfigurationEvent&gt; l1 = createEventListener();</span>
<span class="fc" id="L409">        final EventListener&lt;ConfigurationEvent&gt; l2 = createEventListener();</span>
<span class="fc" id="L410">        final EventListener&lt;ConfigurationErrorEvent&gt; l3 = new ErrorListenerTestImpl(null);</span>
<span class="fc" id="L411">        final BasicConfigurationBuilder&lt;PropertiesConfiguration&gt; builder =</span>
                new BasicConfigurationBuilder&lt;&gt;(
                        PropertiesConfiguration.class);
<span class="fc" id="L414">        builder.addEventListener(ConfigurationEvent.ANY, l1);</span>
<span class="fc" id="L415">        builder.addEventListener(ConfigurationEvent.ANY_HIERARCHICAL, l2);</span>
<span class="fc" id="L416">        builder.addEventListener(ConfigurationErrorEvent.ANY, l3);</span>
<span class="fc" id="L417">        final BasicConfigurationBuilder&lt;XMLConfiguration&gt; builder2 =</span>
                new BasicConfigurationBuilder&lt;&gt;(
                        XMLConfiguration.class);
<span class="fc" id="L420">        builder.copyEventListeners(builder2);</span>
<span class="fc" id="L421">        final XMLConfiguration config = builder2.getConfiguration();</span>
<span class="fc" id="L422">        Collection&lt;EventListener&lt;? super ConfigurationEvent&gt;&gt; listeners =</span>
<span class="fc" id="L423">                config.getEventListeners(ConfigurationEvent.ANY);</span>
<span class="fc" id="L424">        assertEquals(&quot;Wrong number of listeners&quot;, 1, listeners.size());</span>
<span class="fc" id="L425">        assertTrue(&quot;Wrong listener&quot;, listeners.contains(l1));</span>
<span class="fc" id="L426">        listeners =</span>
<span class="fc" id="L427">                config.getEventListeners(ConfigurationEvent.ANY_HIERARCHICAL);</span>
<span class="fc" id="L428">        assertEquals(&quot;Wrong number of listeners for hierarchical&quot;, 2,</span>
<span class="fc" id="L429">                listeners.size());</span>
<span class="fc" id="L430">        assertTrue(&quot;Listener 1 not found&quot;, listeners.contains(l1));</span>
<span class="fc" id="L431">        assertTrue(&quot;Listener 2 not found&quot;, listeners.contains(l2));</span>
<span class="fc" id="L432">        final Collection&lt;EventListener&lt;? super ConfigurationErrorEvent&gt;&gt; errListeners =</span>
<span class="fc" id="L433">                config.getEventListeners(ConfigurationErrorEvent.ANY);</span>
<span class="fc" id="L434">        assertEquals(&quot;Wrong number of error listeners&quot;, 1, errListeners.size());</span>
<span class="fc" id="L435">        assertTrue(&quot;Wrong error listener&quot;, errListeners.contains(l3));</span>
<span class="fc" id="L436">    }</span>

    /**
     * Tests whether configuration listeners can be defined via the configure()
     * method.
     */
    @Test
    public void testEventListenerConfiguration() throws ConfigurationException
    {
<span class="fc" id="L445">        final EventListenerTestImpl listener1 = new EventListenerTestImpl(null);</span>
<span class="fc" id="L446">        final EventListenerRegistrationData&lt;ConfigurationErrorEvent&gt; regData =</span>
                new EventListenerRegistrationData&lt;&gt;(
                        ConfigurationErrorEvent.WRITE,
                        new ErrorListenerTestImpl(null));
<span class="fc" id="L450">        final BasicConfigurationBuilder&lt;PropertiesConfiguration&gt; builder =</span>
                new BasicConfigurationBuilder&lt;&gt;(
                        PropertiesConfiguration.class)
<span class="fc" id="L453">                        .configure(new EventListenerParameters()</span>
<span class="fc" id="L454">                                .addEventListener(ConfigurationEvent.ANY,</span>
<span class="fc" id="L455">                                        listener1).addEventListener(regData));</span>
<span class="fc" id="L456">        final PropertiesConfiguration config = builder.getConfiguration();</span>
<span class="fc" id="L457">        assertTrue(&quot;Configuration listener not found&quot;, config</span>
<span class="fc" id="L458">                .getEventListeners(ConfigurationEvent.ANY).contains(listener1));</span>
<span class="fc" id="L459">        assertTrue(</span>
                &quot;Error listener not found&quot;,
<span class="fc" id="L461">                config.getEventListeners(regData.getEventType()).contains(</span>
<span class="fc" id="L462">                        regData.getListener()));</span>
<span class="fc" id="L463">    }</span>

    /**
     * Tests whether configuration listeners are removed from the managed
     * configuration when the builder's result object is reset.
     */
    @Test
    public void testRemoveConfigurationListenersOnReset()
            throws ConfigurationException
    {
<span class="fc" id="L473">        final EventListenerTestImpl listener = new EventListenerTestImpl(null);</span>
<span class="fc" id="L474">        final BasicConfigurationBuilder&lt;PropertiesConfiguration&gt; builder =</span>
                new BasicConfigurationBuilder&lt;&gt;(
                        PropertiesConfiguration.class)
<span class="fc" id="L477">                        .configure(new EventListenerParameters()</span>
<span class="fc" id="L478">                                .addEventListener(ConfigurationEvent.ANY,</span>
                                        listener));
<span class="fc" id="L480">        final PropertiesConfiguration config = builder.getConfiguration();</span>
<span class="fc" id="L481">        builder.resetResult();</span>
<span class="fc" id="L482">        config.addProperty(&quot;foo&quot;, &quot;bar&quot;);</span>
<span class="fc" id="L483">        listener.done();</span>
<span class="fc" id="L484">    }</span>

    /**
     * Tests whether parameters starting with a reserved prefix are filtered out
     * before result objects are initialized.
     */
    @Test
    public void testReservedParameter() throws ConfigurationException
    {
<span class="fc" id="L493">        final Map&lt;String, Object&gt; params = new HashMap&lt;&gt;();</span>
<span class="fc" id="L494">        params.put(&quot;throwExceptionOnMissing&quot;, Boolean.TRUE);</span>
<span class="fc" id="L495">        params.put(&quot;config-test&quot;, &quot;a test&quot;);</span>
<span class="fc" id="L496">        final BasicConfigurationBuilder&lt;PropertiesConfiguration&gt; builder =</span>
                new BasicConfigurationBuilder&lt;&gt;(
                        PropertiesConfiguration.class, params);
<span class="fc" id="L499">        final PropertiesConfiguration config = builder.getConfiguration();</span>
<span class="fc" id="L500">        assertTrue(&quot;Flag not set&quot;, config.isThrowExceptionOnMissing());</span>
<span class="fc" id="L501">    }</span>

    /**
     * Tests an exception during configuration initialization if the
     * allowFailOnInit flag is false.
     */
    @Test(expected = ConfigurationException.class)
    public void testInitializationErrorNotAllowed()
            throws ConfigurationException
    {
<span class="fc" id="L511">        final BasicConfigurationBuilderInitFailImpl builder =</span>
                new BasicConfigurationBuilderInitFailImpl(false);
<span class="nc" id="L513">        builder.getConfiguration();</span>
<span class="nc" id="L514">    }</span>

    /**
     * Tests an exception during configuration initialization if the
     * allowFailOnInit flag is true.
     */
    @Test
    public void testInitializationErrorAllowed() throws ConfigurationException
    {
<span class="fc" id="L523">        final BasicConfigurationBuilderInitFailImpl builder =</span>
                new BasicConfigurationBuilderInitFailImpl(true);
<span class="fc" id="L525">        final PropertiesConfiguration config = builder.getConfiguration();</span>
<span class="fc" id="L526">        assertTrue(&quot;Got data&quot;, config.isEmpty());</span>
<span class="fc" id="L527">    }</span>

    /**
     * Tests whether a configuration implementing {@code Initializable} is
     * correctly handled.
     */
    @Test
    public void testInitializableCalled() throws ConfigurationException
    {
<span class="fc" id="L536">        final BasicConfigurationBuilder&lt;InitializableConfiguration&gt; builder =</span>
                new BasicConfigurationBuilder&lt;&gt;(
                        InitializableConfiguration.class);
<span class="fc" id="L539">        builder.configure(new BasicBuilderParameters()</span>
<span class="fc" id="L540">                .setThrowExceptionOnMissing(true));</span>
<span class="fc" id="L541">        final InitializableConfiguration config = builder.getConfiguration();</span>
<span class="fc" id="L542">        assertEquals(&quot;Property not correctly initialized&quot;,</span>
<span class="fc" id="L543">                &quot;Initialized with flag true&quot;, config.getInitProperty());</span>
<span class="fc" id="L544">    }</span>

    /**
     * Tests whether a configured BeanHelper is used for result creation.
     */
    @Test
    public void testBeanHelperInConfiguration() throws ConfigurationException
    {
<span class="fc" id="L552">        final Set&lt;Class&lt;?&gt;&gt; classesPassedToFactory = new HashSet&lt;&gt;();</span>
<span class="fc" id="L553">        final BeanFactory factory = new DefaultBeanFactory()</span>
<span class="fc" id="L554">        {</span>
            @Override
            public Object createBean(final BeanCreationContext bcc) throws Exception
            {
<span class="fc" id="L558">                classesPassedToFactory.add(bcc.getBeanClass());</span>
<span class="fc" id="L559">                return super.createBean(bcc);</span>
            }
        };
<span class="fc" id="L562">        final BeanHelper helper = new BeanHelper(factory);</span>
<span class="fc" id="L563">        final BasicConfigurationBuilder&lt;PropertiesConfiguration&gt; builder =</span>
                new BasicConfigurationBuilder&lt;&gt;(
                        PropertiesConfiguration.class);
<span class="fc" id="L566">        builder.configure(new BasicBuilderParameters().setBeanHelper(helper));</span>
<span class="fc" id="L567">        final PropertiesConfiguration config = builder.getConfiguration();</span>
<span class="fc" id="L568">        assertTrue(&quot;BeanFactory was not used correctly&quot;,</span>
<span class="fc" id="L569">                classesPassedToFactory.contains(config.getClass()));</span>
<span class="fc" id="L570">    }</span>

    /**
     * Tests whether a builder can be connected to a reloading controller.
     */
    @Test
    public void testConnectToReloadingController()
            throws ConfigurationException
    {
<span class="fc" id="L579">        final ReloadingDetector detector =</span>
<span class="fc" id="L580">                EasyMock.createNiceMock(ReloadingDetector.class);</span>
<span class="fc" id="L581">        EasyMock.expect(detector.isReloadingRequired()).andReturn(Boolean.TRUE);</span>
<span class="fc" id="L582">        EasyMock.replay(detector);</span>
<span class="fc" id="L583">        final ReloadingController controller = new ReloadingController(detector);</span>
<span class="fc" id="L584">        final BasicConfigurationBuilder&lt;Configuration&gt; builder =</span>
                new BasicConfigurationBuilder&lt;&gt;(
                        PropertiesConfiguration.class);
<span class="fc" id="L587">        final Configuration configuration = builder.getConfiguration();</span>

<span class="fc" id="L589">        builder.connectToReloadingController(controller);</span>
<span class="fc" id="L590">        controller.checkForReloading(null);</span>
<span class="fc" id="L591">        assertTrue(&quot;Not in reloading state&quot;, controller.isInReloadingState());</span>
<span class="fc" id="L592">        assertNotSame(&quot;No new configuration created&quot;, configuration,</span>
<span class="fc" id="L593">                builder.getConfiguration());</span>
<span class="fc" id="L594">        assertFalse(&quot;Still in reloading state&quot;, controller.isInReloadingState());</span>
<span class="fc" id="L595">    }</span>

    /**
     * Tries to connect to a null reloading controller.
     */
    @Test(expected = IllegalArgumentException.class)
    public void testConnectToReloadingControllerNull()
    {
<span class="fc" id="L603">        final BasicConfigurationBuilder&lt;Configuration&gt; builder =</span>
                new BasicConfigurationBuilder&lt;&gt;(
                        PropertiesConfiguration.class);
<span class="nc" id="L606">        builder.connectToReloadingController(null);</span>
<span class="nc" id="L607">    }</span>

    /**
     * A test thread class for testing whether the builder's result object can
     * be requested concurrently.
     */
    private static class AccessBuilderThread extends Thread
    {
        /** A latch for controlling the start of the thread. */
        private final CountDownLatch startLatch;

        /** A latch for controlling the end of the thread. */
        private final CountDownLatch endLatch;

        /** The builder to be accessed. */
        private final ConfigurationBuilder&lt;?&gt; builder;

        /** The result object obtained from the builder. */
        private volatile Object result;

        /**
         * Creates a new instance of {@code AccessBuilderThread}.
         *
         * @param lstart the latch for controlling the thread start
         * @param lend the latch for controlling the thread end
         * @param bldr the builder to be tested
         */
        public AccessBuilderThread(final CountDownLatch lstart, final CountDownLatch lend,
                final ConfigurationBuilder&lt;?&gt; bldr)
<span class="fc" id="L636">        {</span>
<span class="fc" id="L637">            startLatch = lstart;</span>
<span class="fc" id="L638">            endLatch = lend;</span>
<span class="fc" id="L639">            builder = bldr;</span>
<span class="fc" id="L640">        }</span>

        @Override
        public void run()
        {
            try
            {
<span class="fc" id="L647">                startLatch.await();</span>
<span class="fc" id="L648">                result = builder.getConfiguration();</span>
            }
<span class="nc" id="L650">            catch (final Exception ex)</span>
            {
<span class="nc" id="L652">                result = ex;</span>
            }
            finally
            {
<span class="fc" id="L656">                endLatch.countDown();</span>
            }
<span class="fc" id="L658">        }</span>
    }

    /**
     * A builder test implementation which allows checking exception handling
     * when creating new configuration objects.
     */
    private static class BasicConfigurationBuilderInitFailImpl extends
            BasicConfigurationBuilder&lt;PropertiesConfiguration&gt;
    {
        public BasicConfigurationBuilderInitFailImpl(final boolean allowFailOnInit)
        {
<span class="fc" id="L670">            super(PropertiesConfiguration.class, null, allowFailOnInit);</span>
<span class="fc" id="L671">        }</span>

        /**
         * {@inheritDoc} This implementation only throws an exception.
         */
        @Override
        protected void initResultInstance(final PropertiesConfiguration obj)
                throws ConfigurationException
        {
<span class="fc" id="L680">            throw new ConfigurationException(&quot;Initialization test exception!&quot;);</span>
        }
    }

    /**
     * A test configuration implementation which also implements Initializable.
     */
<span class="fc" id="L687">    public static class InitializableConfiguration extends BaseConfiguration</span>
            implements Initializable
    {
        /** A property which is initialized if the builder works as expected. */
        private String initProperty;

        /**
         * Sets the value of the initProperty member based on other flag values.
         * This tests whether the method is called after other properties have
         * been set.
         */
        @Override
        public void initialize()
        {
<span class="fc" id="L701">            initProperty =</span>
<span class="fc" id="L702">                    &quot;Initialized with flag &quot; + isThrowExceptionOnMissing();</span>
<span class="fc" id="L703">        }</span>

        public String getInitProperty()
        {
<span class="fc" id="L707">            return initProperty;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>