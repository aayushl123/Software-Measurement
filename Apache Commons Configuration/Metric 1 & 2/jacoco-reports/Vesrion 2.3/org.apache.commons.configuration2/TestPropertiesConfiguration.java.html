<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TestPropertiesConfiguration.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">commons_configuration2$Unnamed.exec</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.configuration2</a> &gt; <span class="el_source">TestPropertiesConfiguration.java</span></div><h1>TestPropertiesConfiguration.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.commons.configuration2;

import java.io.*;
import java.net.HttpURLConnection;
import java.net.URL;
import java.net.URLConnection;
import java.net.URLStreamHandler;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;

import org.apache.commons.configuration2.SynchronizerTestImpl.Methods;
import org.apache.commons.configuration2.builder.FileBasedBuilderParametersImpl;
import org.apache.commons.configuration2.builder.FileBasedConfigurationBuilder;
import org.apache.commons.configuration2.builder.combined.CombinedConfigurationBuilder;
import org.apache.commons.configuration2.builder.fluent.Parameters;
import org.apache.commons.configuration2.convert.DefaultListDelimiterHandler;
import org.apache.commons.configuration2.convert.DisabledListDelimiterHandler;
import org.apache.commons.configuration2.convert.LegacyListDelimiterHandler;
import org.apache.commons.configuration2.convert.ListDelimiterHandler;
import org.apache.commons.configuration2.event.ConfigurationEvent;
import org.apache.commons.configuration2.ex.ConfigurationException;
import org.apache.commons.configuration2.io.DefaultFileSystem;
import org.apache.commons.configuration2.io.FileHandler;
import org.apache.commons.configuration2.io.FileSystem;
import org.apache.commons.lang3.mutable.MutableObject;
import org.junit.Before;
import org.junit.Test;
import org.junit.Rule;
import org.junit.rules.TemporaryFolder;

import static org.hamcrest.CoreMatchers.containsString;
import static org.junit.Assert.*;

/**
 * Test for loading and saving properties files.
 *
 * @version $Id$
 */
<span class="fc" id="L60">public class TestPropertiesConfiguration</span>
{
    /** Constant for a test property name.*/
    private static final String PROP_NAME = &quot;testProperty&quot;;

    /** Constant for a test property value.*/
    private static final String PROP_VALUE = &quot;value&quot;;

    /** Constant for the line break character. */
<span class="fc" id="L69">    private static final String CR = System.getProperty(&quot;line.separator&quot;);</span>

    /** The configuration to be tested.*/
    private PropertiesConfiguration conf;

    /** The File that we test with */
<span class="fc" id="L75">    private static String testProperties = ConfigurationAssert.getTestFile(&quot;test.properties&quot;).getAbsolutePath();</span>

<span class="fc" id="L77">    private static String testBasePath = ConfigurationAssert.TEST_DIR.getAbsolutePath();</span>
<span class="fc" id="L78">    private static String testBasePath2 = ConfigurationAssert.TEST_DIR.getParentFile().getAbsolutePath();</span>
<span class="fc" id="L79">    private static File testSavePropertiesFile = ConfigurationAssert.getOutFile(&quot;testsave.properties&quot;);</span>

    /** Helper object for creating temporary files. */
<span class="fc" id="L82">    @Rule</span>
    public TemporaryFolder folder = new TemporaryFolder();

    @Before
    public void setUp() throws Exception
    {
<span class="fc" id="L88">        conf = new PropertiesConfiguration();</span>
<span class="fc" id="L89">        conf.setListDelimiterHandler(new LegacyListDelimiterHandler(','));</span>
<span class="fc" id="L90">        load(conf, testProperties);</span>

        // remove the test save file if it exists
<span class="fc bfc" id="L93" title="All 2 branches covered.">        if (testSavePropertiesFile.exists())</span>
        {
<span class="fc" id="L95">            assertTrue(&quot;Test output file could not be deleted&quot;,</span>
<span class="fc" id="L96">                    testSavePropertiesFile.delete());</span>
        }
<span class="fc" id="L98">    }</span>

    /**
     * Helper method for loading a configuration from a given file.
     *
     * @param pc the configuration to be loaded
     * @param fileName the file name
     * @return the file handler associated with the configuration
     * @throws ConfigurationException if an error occurs
     */
    private static FileHandler load(PropertiesConfiguration pc, String fileName)
            throws ConfigurationException
    {
<span class="fc" id="L111">        FileHandler handler = new FileHandler(pc);</span>
<span class="fc" id="L112">        handler.setFileName(fileName);</span>
<span class="fc" id="L113">        handler.load();</span>
<span class="fc" id="L114">        return handler;</span>
    }

    @Test
    public void testLoad() throws Exception
    {
<span class="fc" id="L120">        String loaded = conf.getString(&quot;configuration.loaded&quot;);</span>
<span class="fc" id="L121">        assertEquals(&quot;true&quot;, loaded);</span>
<span class="fc" id="L122">    }</span>

    /**
     * Tests if properties can be appended by simply calling load() another
     * time.
     */
    @Test
    public void testAppend() throws Exception
    {
<span class="fc" id="L131">        File file2 = ConfigurationAssert.getTestFile(&quot;threesome.properties&quot;);</span>
<span class="fc" id="L132">        FileHandler handler = new FileHandler(conf);</span>
<span class="fc" id="L133">        handler.load(file2);</span>
<span class="fc" id="L134">        assertEquals(&quot;aaa&quot;, conf.getString(&quot;test.threesome.one&quot;));</span>
<span class="fc" id="L135">        assertEquals(&quot;true&quot;, conf.getString(&quot;configuration.loaded&quot;));</span>
<span class="fc" id="L136">    }</span>

    /**
     * Checks for a property without a value.
     *
     * @param key the key to be checked
     */
    private void checkEmpty(String key)
    {
<span class="fc" id="L145">        String empty = conf.getString(key);</span>
<span class="fc" id="L146">        assertNotNull(&quot;Property not found: &quot; + key, empty);</span>
<span class="fc" id="L147">        assertEquals(&quot;Wrong value for property &quot; + key, &quot;&quot;, empty);</span>
<span class="fc" id="L148">    }</span>

    /**
     * Tests that empty properties are treated as the empty string (rather than
     * as null).
     */
    @Test
    public void testEmpty()
    {
<span class="fc" id="L157">        checkEmpty(&quot;test.empty&quot;);</span>
<span class="fc" id="L158">    }</span>

    /**
     * Tests that properties are detected that do not have a separator and a
     * value.
     */
    @Test
    public void testEmptyNoSeparator()
    {
<span class="fc" id="L167">        checkEmpty(&quot;test.empty2&quot;);</span>
<span class="fc" id="L168">    }</span>

    /**
     * Tests that references to other properties work
     */
    @Test
    public void testReference() throws Exception
    {
<span class="fc" id="L176">        assertEquals(&quot;baseextra&quot;, conf.getString(&quot;base.reference&quot;));</span>
<span class="fc" id="L177">    }</span>

    /**
     * test if includes properties get loaded too
     */
    @Test
    public void testLoadInclude() throws Exception
    {
<span class="fc" id="L185">        String loaded = conf.getString(&quot;include.loaded&quot;);</span>
<span class="fc" id="L186">        assertEquals(&quot;true&quot;, loaded);</span>
<span class="fc" id="L187">    }</span>

    /**
     * test if includes properties from interpolated file
     * name get loaded
     */
    @Test
    public void testLoadIncludeInterpol() throws Exception
    {
<span class="fc" id="L196">        String loaded = conf.getString(&quot;include.interpol.loaded&quot;);</span>
<span class="fc" id="L197">        assertEquals(&quot;true&quot;, loaded);</span>
<span class="fc" id="L198">    }</span>

    /**
     * Tests whether include files can be resolved if a configuration file is
     * read from a reader.
     */
    @Test
    public void testLoadIncludeFromReader() throws ConfigurationException,
            IOException
    {
<span class="fc" id="L208">        StringReader in =</span>
<span class="fc" id="L209">                new StringReader(PropertiesConfiguration.getInclude() + &quot; = &quot;</span>
<span class="fc" id="L210">                        + ConfigurationAssert.getTestURL(&quot;include.properties&quot;));</span>
<span class="fc" id="L211">        conf = new PropertiesConfiguration();</span>
<span class="fc" id="L212">        FileHandler handler = new FileHandler(conf);</span>
<span class="fc" id="L213">        handler.load(in);</span>
<span class="fc" id="L214">        assertEquals(&quot;Include file not loaded&quot;, &quot;true&quot;,</span>
<span class="fc" id="L215">                conf.getString(&quot;include.loaded&quot;));</span>
<span class="fc" id="L216">    }</span>

    /**
     * Tests whether include files can be disabled.
     */
    @Test
    public void testDisableIncludes() throws ConfigurationException,
            IOException
    {
<span class="fc" id="L225">        String content =</span>
<span class="fc" id="L226">                PropertiesConfiguration.getInclude()</span>
                        + &quot; = nonExistingIncludeFile&quot; + CR + PROP_NAME + &quot; = &quot;
                        + PROP_VALUE + CR;
<span class="fc" id="L229">        StringReader in = new StringReader(content);</span>
<span class="fc" id="L230">        conf = new PropertiesConfiguration();</span>
<span class="fc" id="L231">        conf.setIncludesAllowed(false);</span>
<span class="fc" id="L232">        conf.read(in);</span>
<span class="fc" id="L233">        assertEquals(&quot;Data not loaded&quot;, PROP_VALUE, conf.getString(PROP_NAME));</span>
<span class="fc" id="L234">    }</span>

    /**
     * Tests whether multiple include files can be resolved.
     */
    @Test
    public void testMultipleIncludeFiles() throws ConfigurationException
    {
<span class="fc" id="L242">        conf = new PropertiesConfiguration();</span>
<span class="fc" id="L243">        FileHandler handler = new FileHandler(conf);</span>
<span class="fc" id="L244">        handler.load(ConfigurationAssert.getTestFile(&quot;config/testMultiInclude.properties&quot;));</span>
<span class="fc" id="L245">        assertEquals(&quot;Wrong top-level property&quot;, &quot;topValue&quot;,</span>
<span class="fc" id="L246">                conf.getString(&quot;top&quot;));</span>
<span class="fc" id="L247">        assertEquals(&quot;Wrong included property (1)&quot;, 100,</span>
<span class="fc" id="L248">                conf.getInt(&quot;property.c&quot;));</span>
<span class="fc" id="L249">        assertEquals(&quot;Wrong included property (2)&quot;, true,</span>
<span class="fc" id="L250">                conf.getBoolean(&quot;include.loaded&quot;));</span>
<span class="fc" id="L251">    }</span>

    @Test
    public void testSetInclude() throws Exception
    {
<span class="fc" id="L256">        conf.clear();</span>
        // change the include key
<span class="fc" id="L258">        PropertiesConfiguration.setInclude(&quot;import&quot;);</span>

        // load the configuration
<span class="fc" id="L261">        load(conf, testProperties);</span>

        // restore the previous value for the other tests
<span class="fc" id="L264">        PropertiesConfiguration.setInclude(&quot;include&quot;);</span>

<span class="fc" id="L266">        assertNull(conf.getString(&quot;include.loaded&quot;));</span>
<span class="fc" id="L267">    }</span>

    /**
     * Tests {@code List} parsing.
     */
    @Test
    public void testList() throws Exception
    {
<span class="fc" id="L275">        List&lt;Object&gt; packages = conf.getList(&quot;packages&quot;);</span>
        // we should get 3 packages here
<span class="fc" id="L277">        assertEquals(3, packages.size());</span>
<span class="fc" id="L278">    }</span>

    @Test
    public void testSave() throws Exception
    {
        // add an array of strings to the configuration
<span class="fc" id="L284">        conf.addProperty(&quot;string&quot;, &quot;value1&quot;);</span>
<span class="fc" id="L285">        List&lt;Object&gt; list = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L286" title="All 2 branches covered.">        for (int i = 1; i &lt; 5; i++)</span>
        {
<span class="fc" id="L288">            list.add(&quot;value&quot; + i);</span>
        }
<span class="fc" id="L290">        conf.addProperty(&quot;array&quot;, list);</span>

        // save the configuration
<span class="fc" id="L293">        saveTestConfig();</span>
<span class="fc" id="L294">        assertTrue(&quot;The saved file doesn't exist&quot;, testSavePropertiesFile.exists());</span>

        // read the configuration and compare the properties
<span class="fc" id="L297">        checkSavedConfig();</span>
<span class="fc" id="L298">    }</span>

    @Test
    public void testSaveToCustomURL() throws Exception
    {
        // save the configuration to a custom URL
<span class="fc" id="L304">        URL url = new URL(&quot;foo&quot;, &quot;&quot;, 0, folder.newFile(&quot;testsave-custom-url.properties&quot;).getAbsolutePath(), new FileURLStreamHandler());</span>
<span class="fc" id="L305">        FileHandler handlerSave = new FileHandler(conf);</span>
<span class="fc" id="L306">        handlerSave.save(url);</span>

        // reload the configuration
<span class="fc" id="L309">        PropertiesConfiguration config2 = new PropertiesConfiguration();</span>
<span class="fc" id="L310">        FileHandler handlerLoad = new FileHandler(config2);</span>
<span class="fc" id="L311">        handlerLoad.load(url);</span>
<span class="fc" id="L312">        assertEquals(&quot;true&quot;, config2.getString(&quot;configuration.loaded&quot;));</span>
<span class="fc" id="L313">    }</span>

    @Test
    public void testInMemoryCreatedSave() throws Exception
    {
<span class="fc" id="L318">        conf = new PropertiesConfiguration();</span>
        // add an array of strings to the configuration
<span class="fc" id="L320">        conf.addProperty(&quot;string&quot;, &quot;value1&quot;);</span>
<span class="fc" id="L321">        List&lt;Object&gt; list = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L322" title="All 2 branches covered.">        for (int i = 1; i &lt; 5; i++)</span>
        {
<span class="fc" id="L324">            list.add(&quot;value&quot; + i);</span>
        }
<span class="fc" id="L326">        conf.addProperty(&quot;array&quot;, list);</span>

        // save the configuration
<span class="fc" id="L329">        saveTestConfig();</span>
<span class="fc" id="L330">        assertTrue(&quot;The saved file doesn't exist&quot;, testSavePropertiesFile.exists());</span>

        // read the configuration and compare the properties
<span class="fc" id="L333">        checkSavedConfig();</span>
<span class="fc" id="L334">    }</span>

    /**
     * Tests saving a configuration if delimiter parsing is disabled.
     */
    @Test
    public void testSaveWithDelimiterParsingDisabled() throws ConfigurationException
    {
<span class="fc" id="L342">        conf.clear();</span>
<span class="fc" id="L343">        conf.setListDelimiterHandler(new DisabledListDelimiterHandler());</span>
<span class="fc" id="L344">        conf.addProperty(&quot;test.list&quot;, &quot;a,b,c&quot;);</span>
<span class="fc" id="L345">        conf.addProperty(&quot;test.dirs&quot;, &quot;C:\\Temp\\,D:\\Data\\&quot;);</span>
<span class="fc" id="L346">        saveTestConfig();</span>

<span class="fc" id="L348">        PropertiesConfiguration checkConfig = new PropertiesConfiguration();</span>
<span class="fc" id="L349">        checkConfig.setListDelimiterHandler(new DisabledListDelimiterHandler());</span>
<span class="fc" id="L350">        new FileHandler(checkConfig).load(testSavePropertiesFile);</span>
<span class="fc" id="L351">        ConfigurationAssert.assertConfigurationEquals(conf, checkConfig);</span>
<span class="fc" id="L352">    }</span>

    /**
     * Tests whether saving works correctly with the default list delimiter
     * handler implementation.
     */
    @Test
    public void testSaveWithDefaultListDelimiterHandler() throws ConfigurationException
    {
<span class="fc" id="L361">        conf.setListDelimiterHandler(new DefaultListDelimiterHandler(','));</span>
<span class="fc" id="L362">        saveTestConfig();</span>

<span class="fc" id="L364">        PropertiesConfiguration checkConfig = new PropertiesConfiguration();</span>
<span class="fc" id="L365">        checkConfig.setListDelimiterHandler(conf.getListDelimiterHandler());</span>
<span class="fc" id="L366">        new FileHandler(checkConfig).load(testSavePropertiesFile);</span>
<span class="fc" id="L367">        ConfigurationAssert.assertConfigurationEquals(conf, checkConfig);</span>
<span class="fc" id="L368">    }</span>

    @Test(expected = ConfigurationException.class)
    public void testSaveMissingFilename() throws ConfigurationException
    {
<span class="fc" id="L373">        FileHandler handler = new FileHandler(conf);</span>
<span class="nc" id="L374">        handler.save();</span>
<span class="nc" id="L375">    }</span>

    /**
     * Tests if the base path is taken into account by the save() method.
     */
    @Test
    public void testSaveWithBasePath() throws Exception
    {
<span class="fc" id="L383">        conf.setProperty(&quot;test&quot;, &quot;true&quot;);</span>
<span class="fc" id="L384">        FileHandler handler = new FileHandler(conf);</span>
<span class="fc" id="L385">        handler.setBasePath(testSavePropertiesFile.getParentFile().toURI().toURL()</span>
<span class="fc" id="L386">                .toString());</span>
<span class="fc" id="L387">        handler.setFileName(testSavePropertiesFile.getName());</span>
<span class="fc" id="L388">        handler.save();</span>
<span class="fc" id="L389">        assertTrue(testSavePropertiesFile.exists());</span>
<span class="fc" id="L390">    }</span>

    /**
     * Tests whether the escape character for list delimiters can be itself
     * escaped and survives a save operation.
     */
    @Test
    public void testSaveEscapedEscapingCharacter()
            throws ConfigurationException
    {
<span class="fc" id="L400">        conf.addProperty(&quot;test.dirs&quot;, &quot;C:\\Temp\\\\,D:\\Data\\\\,E:\\Test\\&quot;);</span>
<span class="fc" id="L401">        List&lt;Object&gt; dirs = conf.getList(&quot;test.dirs&quot;);</span>
<span class="fc" id="L402">        assertEquals(&quot;Wrong number of list elements&quot;, 3, dirs.size());</span>
<span class="fc" id="L403">        saveTestConfig();</span>
<span class="fc" id="L404">        checkSavedConfig();</span>
<span class="fc" id="L405">    }</span>

    @Test
    public void testLoadViaPropertyWithBasePath() throws Exception
    {
<span class="fc" id="L410">        PropertiesConfiguration pc = new PropertiesConfiguration();</span>
<span class="fc" id="L411">        FileHandler handler = new FileHandler(pc);</span>
<span class="fc" id="L412">        handler.setBasePath(testBasePath);</span>
<span class="fc" id="L413">        handler.setFileName(&quot;test.properties&quot;);</span>
<span class="fc" id="L414">        handler.load();</span>

<span class="fc" id="L416">        assertTrue(&quot;Make sure we have multiple keys&quot;, pc.getBoolean(&quot;test.boolean&quot;));</span>
<span class="fc" id="L417">    }</span>

    @Test
    public void testLoadViaPropertyWithBasePath2() throws Exception
    {
<span class="fc" id="L422">        PropertiesConfiguration pc = new PropertiesConfiguration();</span>
<span class="fc" id="L423">        FileHandler handler = new FileHandler(pc);</span>
<span class="fc" id="L424">        handler.setBasePath(testBasePath2);</span>
<span class="fc" id="L425">        handler.setFileName(&quot;test.properties&quot;);</span>
<span class="fc" id="L426">        handler.load();</span>

<span class="fc" id="L428">        assertTrue(&quot;Make sure we have multiple keys&quot;, pc.getBoolean(&quot;test.boolean&quot;));</span>
<span class="fc" id="L429">    }</span>

    @Test
    public void testLoadFromFile() throws Exception
    {
<span class="fc" id="L434">        File file = ConfigurationAssert.getTestFile(&quot;test.properties&quot;);</span>
<span class="fc" id="L435">        conf.clear();</span>
<span class="fc" id="L436">        FileHandler handler = new FileHandler(conf);</span>
<span class="fc" id="L437">        handler.setFile(file);</span>
<span class="fc" id="L438">        handler.load();</span>

<span class="fc" id="L440">        assertEquals(&quot;true&quot;, conf.getString(&quot;configuration.loaded&quot;));</span>
<span class="fc" id="L441">    }</span>

    @Test(expected = ConfigurationException.class)
    public void testLoadUnexistingFile() throws ConfigurationException
    {
<span class="nc" id="L446">        load(conf, &quot;unexisting file&quot;);</span>
<span class="nc" id="L447">    }</span>

    /**
     * Helper method for testing a saved configuration. Reads in the file using
     * a new instance and compares this instance with the original one.
     *
     * @return the newly created configuration instance
     * @throws ConfigurationException if an error occurs
     */
    private PropertiesConfiguration checkSavedConfig()
            throws ConfigurationException
    {
<span class="fc" id="L459">        PropertiesConfiguration checkConfig = new PropertiesConfiguration();</span>
<span class="fc" id="L460">        checkConfig.setListDelimiterHandler(new LegacyListDelimiterHandler(','));</span>
<span class="fc" id="L461">        load(checkConfig, testSavePropertiesFile.getAbsolutePath());</span>
<span class="fc" id="L462">        ConfigurationAssert.assertConfigurationEquals(conf, checkConfig);</span>
<span class="fc" id="L463">        return checkConfig;</span>
    }

    @Test
    public void testGetStringWithEscapedChars()
    {
<span class="fc" id="L469">        String property = conf.getString(&quot;test.unescape&quot;);</span>
<span class="fc" id="L470">        assertEquals(&quot;String with escaped characters&quot;, &quot;This \n string \t contains \&quot; escaped \\ characters&quot;, property);</span>
<span class="fc" id="L471">    }</span>

    @Test
    public void testGetStringWithEscapedComma()
    {
<span class="fc" id="L476">        String property = conf.getString(&quot;test.unescape.list-separator&quot;);</span>
<span class="fc" id="L477">        assertEquals(&quot;String with an escaped list separator&quot;, &quot;This string contains , an escaped list separator&quot;, property);</span>
<span class="fc" id="L478">    }</span>

    @Test
    public void testUnescapeJava()
    {
<span class="fc" id="L483">        assertEquals(&quot;test\\,test&quot;, PropertiesConfiguration.unescapeJava(&quot;test\\,test&quot;));</span>
<span class="fc" id="L484">    }</span>

    @Test
    public void testEscapedKey() throws Exception
    {
<span class="fc" id="L489">        conf.clear();</span>
<span class="fc" id="L490">        FileHandler handler = new FileHandler(conf);</span>
<span class="fc" id="L491">        handler.load(new StringReader(&quot;\\u0066\\u006f\\u006f=bar&quot;));</span>

<span class="fc" id="L493">        assertEquals(&quot;value of the 'foo' property&quot;, &quot;bar&quot;, conf.getString(&quot;foo&quot;));</span>
<span class="fc" id="L494">    }</span>

    @Test
    public void testMixedArray()
    {
<span class="fc" id="L499">        String[] array = conf.getStringArray(&quot;test.mixed.array&quot;);</span>

<span class="fc" id="L501">        assertEquals(&quot;array length&quot;, 4, array.length);</span>
<span class="fc" id="L502">        assertEquals(&quot;1st element&quot;, &quot;a&quot;, array[0]);</span>
<span class="fc" id="L503">        assertEquals(&quot;2nd element&quot;, &quot;b&quot;, array[1]);</span>
<span class="fc" id="L504">        assertEquals(&quot;3rd element&quot;, &quot;c&quot;, array[2]);</span>
<span class="fc" id="L505">        assertEquals(&quot;4th element&quot;, &quot;d&quot;, array[3]);</span>
<span class="fc" id="L506">    }</span>

    @Test
    public void testMultilines()
    {
<span class="fc" id="L511">        String property = &quot;This is a value spread out across several adjacent &quot;</span>
                + &quot;natural lines by escaping the line terminator with &quot;
                + &quot;a backslash character.&quot;;

<span class="fc" id="L515">        assertEquals(&quot;'test.multilines' property&quot;, property, conf.getString(&quot;test.multilines&quot;));</span>
<span class="fc" id="L516">    }</span>

    /**
     * Tests whether another list delimiter character can be set (by using an
     * alternative list delimiter handler).
     */
    @Test
    public void testChangingListDelimiter() throws Exception
    {
<span class="fc" id="L525">        assertEquals(&quot;Wrong initial string&quot;, &quot;a^b^c&quot;,</span>
<span class="fc" id="L526">                conf.getString(&quot;test.other.delimiter&quot;));</span>
<span class="fc" id="L527">        PropertiesConfiguration pc2 = new PropertiesConfiguration();</span>
<span class="fc" id="L528">        pc2.setListDelimiterHandler(new DefaultListDelimiterHandler('^'));</span>
<span class="fc" id="L529">        load(pc2, testProperties);</span>
<span class="fc" id="L530">        assertEquals(&quot;Should obtain the first value&quot;, &quot;a&quot;,</span>
<span class="fc" id="L531">                pc2.getString(&quot;test.other.delimiter&quot;));</span>
<span class="fc" id="L532">        assertEquals(&quot;Wrong list size&quot;, 3, pc2.getList(&quot;test.other.delimiter&quot;)</span>
<span class="fc" id="L533">                .size());</span>
<span class="fc" id="L534">    }</span>

    @Test
    public void testDisableListDelimiter() throws Exception
    {
<span class="fc" id="L539">        assertEquals(4, conf.getList(&quot;test.mixed.array&quot;).size());</span>

<span class="fc" id="L541">        PropertiesConfiguration pc2 = new PropertiesConfiguration();</span>
<span class="fc" id="L542">        load(pc2, testProperties);</span>
<span class="fc" id="L543">        assertEquals(2, pc2.getList(&quot;test.mixed.array&quot;).size());</span>
<span class="fc" id="L544">    }</span>

    /**
     * Tests escaping of an end of line with a backslash.
     */
    @Test
    public void testNewLineEscaping()
    {
<span class="fc" id="L552">        List&lt;Object&gt; list = conf.getList(&quot;test.path&quot;);</span>
<span class="fc" id="L553">        assertEquals(3, list.size());</span>
<span class="fc" id="L554">        assertEquals(&quot;C:\\path1\\&quot;, list.get(0));</span>
<span class="fc" id="L555">        assertEquals(&quot;C:\\path2\\&quot;, list.get(1));</span>
<span class="fc" id="L556">        assertEquals(&quot;C:\\path3\\complex\\test\\&quot;, list.get(2));</span>
<span class="fc" id="L557">    }</span>

    /**
     * Tests if included files are loaded when the source lies in the class path.
     */
    @Test
    public void testLoadIncludeFromClassPath() throws ConfigurationException
    {
<span class="fc" id="L565">        assertEquals(&quot;true&quot;, conf.getString(&quot;include.loaded&quot;));</span>
<span class="fc" id="L566">    }</span>

    /**
     * Test if the lines starting with # or ! are properly ignored.
     */
    @Test
    public void testComment() {
<span class="fc" id="L573">        assertFalse(&quot;comment line starting with '#' parsed as a property&quot;, conf.containsKey(&quot;#comment&quot;));</span>
<span class="fc" id="L574">        assertFalse(&quot;comment line starting with '!' parsed as a property&quot;, conf.containsKey(&quot;!comment&quot;));</span>
<span class="fc" id="L575">    }</span>

    /**
     * Check that key/value separators can be part of a key.
     */
    @Test
    public void testEscapedKeyValueSeparator()
    {
<span class="fc" id="L583">        assertEquals(&quot;Escaped separator '=' not supported in keys&quot;, &quot;foo&quot;, conf.getProperty(&quot;test.separator=in.key&quot;));</span>
<span class="fc" id="L584">        assertEquals(&quot;Escaped separator ':' not supported in keys&quot;, &quot;bar&quot;, conf.getProperty(&quot;test.separator:in.key&quot;));</span>
<span class="fc" id="L585">        assertEquals(&quot;Escaped separator '\\t' not supported in keys&quot;, &quot;foo&quot;, conf.getProperty(&quot;test.separator\tin.key&quot;));</span>
<span class="fc" id="L586">        assertEquals(&quot;Escaped separator '\\f' not supported in keys&quot;, &quot;bar&quot;, conf.getProperty(&quot;test.separator\fin.key&quot;));</span>
<span class="fc" id="L587">        assertEquals(&quot;Escaped separator ' ' not supported in keys&quot;  , &quot;foo&quot;, conf.getProperty(&quot;test.separator in.key&quot;));</span>
<span class="fc" id="L588">    }</span>

    /**
     * Test all acceptable key/value separators ('=', ':' or white spaces).
     */
    @Test
    public void testKeyValueSeparators() {
<span class="fc" id="L595">        assertEquals(&quot;equal separator not properly parsed&quot;,      &quot;foo&quot;, conf.getProperty(&quot;test.separator.equal&quot;));</span>
<span class="fc" id="L596">        assertEquals(&quot;colon separator not properly parsed&quot;,      &quot;foo&quot;, conf.getProperty(&quot;test.separator.colon&quot;));</span>
<span class="fc" id="L597">        assertEquals(&quot;tab separator not properly parsed&quot;,        &quot;foo&quot;, conf.getProperty(&quot;test.separator.tab&quot;));</span>
<span class="fc" id="L598">        assertEquals(&quot;formfeed separator not properly parsed&quot;,   &quot;foo&quot;, conf.getProperty(&quot;test.separator.formfeed&quot;));</span>
<span class="fc" id="L599">        assertEquals(&quot;whitespace separator not properly parsed&quot;, &quot;foo&quot;, conf.getProperty(&quot;test.separator.whitespace&quot;));</span>
<span class="fc" id="L600">    }</span>

    /**
     * Tests including properties when they are loaded from a nested directory
     * structure.
     */
    @Test
    public void testIncludeInSubDir() throws ConfigurationException
    {
<span class="fc" id="L609">        CombinedConfigurationBuilder builder = new CombinedConfigurationBuilder();</span>
<span class="fc" id="L610">        builder.configure(new FileBasedBuilderParametersImpl().setFileName(&quot;testFactoryPropertiesInclude.xml&quot;));</span>
<span class="fc" id="L611">        Configuration config = builder.getConfiguration();</span>
<span class="fc" id="L612">        assertTrue(config.getBoolean(&quot;deeptest&quot;));</span>
<span class="fc" id="L613">        assertTrue(config.getBoolean(&quot;deepinclude&quot;));</span>
<span class="fc" id="L614">        assertFalse(config.containsKey(&quot;deeptestinvalid&quot;));</span>
<span class="fc" id="L615">    }</span>

    /**
     * Tests whether the correct line separator is used.
     */
    @Test
    public void testLineSeparator() throws ConfigurationException
    {
<span class="fc" id="L623">        final String EOL = System.getProperty(&quot;line.separator&quot;);</span>
<span class="fc" id="L624">        conf = new PropertiesConfiguration();</span>
<span class="fc" id="L625">        conf.setHeader(&quot;My header&quot;);</span>
<span class="fc" id="L626">        conf.setProperty(&quot;prop&quot;, &quot;value&quot;);</span>

<span class="fc" id="L628">        StringWriter out = new StringWriter();</span>
<span class="fc" id="L629">        new FileHandler(conf).save(out);</span>
<span class="fc" id="L630">        String content = out.toString();</span>
<span class="pc bpc" id="L631" title="1 of 2 branches missed.">        assertTrue(&quot;Header could not be found&quot;, content.indexOf(&quot;# My header&quot;</span>
                + EOL + EOL) == 0);
<span class="pc bpc" id="L633" title="1 of 2 branches missed.">        assertTrue(&quot;Property could not be found&quot;, content.indexOf(&quot;prop = value&quot; + EOL) &gt; 0);</span>
<span class="fc" id="L634">    }</span>

    /**
     * Tests accessing the layout object.
     */
    @Test
    public void testGetLayout()
    {
<span class="fc" id="L642">        PropertiesConfigurationLayout layout = conf.getLayout();</span>
<span class="fc" id="L643">        assertNotNull(&quot;Layout is null&quot;, layout);</span>
<span class="fc" id="L644">        assertSame(&quot;Different object returned&quot;, layout, conf.getLayout());</span>
<span class="fc" id="L645">        conf.setLayout(null);</span>
<span class="fc" id="L646">        PropertiesConfigurationLayout layout2 = conf.getLayout();</span>
<span class="fc" id="L647">        assertNotNull(&quot;Layout 2 is null&quot;, layout2);</span>
<span class="fc" id="L648">        assertNotSame(&quot;Same object returned&quot;, layout, layout2);</span>
<span class="fc" id="L649">    }</span>

    /**
     * Tests the propertyLoaded() method for a simple property.
     */
    @Test
    public void testPropertyLoaded() throws ConfigurationException
    {
<span class="fc" id="L657">        DummyLayout layout = new DummyLayout();</span>
<span class="fc" id="L658">        conf.setLayout(layout);</span>
<span class="fc" id="L659">        conf.propertyLoaded(&quot;layoutLoadedProperty&quot;, &quot;yes&quot;);</span>
<span class="fc" id="L660">        assertEquals(&quot;Layout's load() was called&quot;, 0, layout.loadCalls);</span>
<span class="fc" id="L661">        assertEquals(&quot;Property not added&quot;, &quot;yes&quot;, conf.getString(&quot;layoutLoadedProperty&quot;));</span>
<span class="fc" id="L662">    }</span>

    /**
     * Tests the propertyLoaded() method for an include property.
     */
    @Test
    public void testPropertyLoadedInclude() throws ConfigurationException
    {
<span class="fc" id="L670">        DummyLayout layout = new DummyLayout();</span>
<span class="fc" id="L671">        conf.setLayout(layout);</span>
<span class="fc" id="L672">        conf.propertyLoaded(PropertiesConfiguration.getInclude(), &quot;testClasspath.properties,testEqual.properties&quot;);</span>
<span class="fc" id="L673">        assertEquals(&quot;Layout's load() was not correctly called&quot;, 2, layout.loadCalls);</span>
<span class="fc" id="L674">        assertFalse(&quot;Property was added&quot;, conf.containsKey(PropertiesConfiguration.getInclude()));</span>
<span class="fc" id="L675">    }</span>

    /**
     * Tests propertyLoaded() for an include property, when includes are
     * disabled.
     */
    @Test
    public void testPropertyLoadedIncludeNotAllowed() throws ConfigurationException
    {
<span class="fc" id="L684">        DummyLayout layout = new DummyLayout();</span>
<span class="fc" id="L685">        conf.setLayout(layout);</span>
<span class="fc" id="L686">        conf.setIncludesAllowed(false);</span>
<span class="fc" id="L687">        conf.propertyLoaded(PropertiesConfiguration.getInclude(), &quot;testClassPath.properties,testEqual.properties&quot;);</span>
<span class="fc" id="L688">        assertEquals(&quot;Layout's load() was called&quot;, 0, layout.loadCalls);</span>
<span class="fc" id="L689">        assertFalse(&quot;Property was added&quot;, conf.containsKey(PropertiesConfiguration.getInclude()));</span>
<span class="fc" id="L690">    }</span>

    /**
     * Tests whether comment lines are correctly detected.
     */
    @Test
    public void testIsCommentLine()
    {
<span class="fc" id="L698">        assertTrue(&quot;Comment not detected&quot;, PropertiesConfiguration.isCommentLine(&quot;# a comment&quot;));</span>
<span class="fc" id="L699">        assertTrue(&quot;Alternative comment not detected&quot;, PropertiesConfiguration.isCommentLine(&quot;! a comment&quot;));</span>
<span class="fc" id="L700">        assertTrue(&quot;Comment with no space not detected&quot;, PropertiesConfiguration.isCommentLine(&quot;#a comment&quot;));</span>
<span class="fc" id="L701">        assertTrue(&quot;Comment with leading space not detected&quot;, PropertiesConfiguration.isCommentLine(&quot;    ! a comment&quot;));</span>
<span class="fc" id="L702">        assertFalse(&quot;Wrong comment&quot;, PropertiesConfiguration.isCommentLine(&quot;   a#comment&quot;));</span>
<span class="fc" id="L703">    }</span>

    /**
     * Tests whether a properties configuration can be successfully cloned. It
     * is especially checked whether the layout object is taken into account.
     */
    @Test
    public void testClone() throws ConfigurationException
    {
<span class="fc" id="L712">        PropertiesConfiguration copy = (PropertiesConfiguration) conf.clone();</span>
<span class="fc" id="L713">        assertNotSame(&quot;Copy has same layout object&quot;, conf.getLayout(),</span>
<span class="fc" id="L714">                copy.getLayout());</span>
<span class="fc" id="L715">        assertEquals(&quot;Wrong number of event listeners for original&quot;, 1, conf</span>
<span class="fc" id="L716">                .getEventListeners(ConfigurationEvent.ANY).size());</span>
<span class="fc" id="L717">        assertEquals(&quot;Wrong number of event listeners for clone&quot;, 1, copy</span>
<span class="fc" id="L718">                .getEventListeners(ConfigurationEvent.ANY).size());</span>
<span class="fc" id="L719">        assertSame(&quot;Wrong event listener for original&quot;, conf.getLayout(), conf</span>
<span class="fc" id="L720">                .getEventListeners(ConfigurationEvent.ANY).iterator().next());</span>
<span class="fc" id="L721">        assertSame(&quot;Wrong event listener for clone&quot;, copy.getLayout(), copy</span>
<span class="fc" id="L722">                .getEventListeners(ConfigurationEvent.ANY).iterator().next());</span>
<span class="fc" id="L723">        StringWriter outConf = new StringWriter();</span>
<span class="fc" id="L724">        new FileHandler(conf).save(outConf);</span>
<span class="fc" id="L725">        StringWriter outCopy = new StringWriter();</span>
<span class="fc" id="L726">        new FileHandler(copy).save(outCopy);</span>
<span class="fc" id="L727">        assertEquals(&quot;Output from copy is different&quot;, outConf.toString(), outCopy.toString());</span>
<span class="fc" id="L728">    }</span>

    /**
     * Tests the clone() method when no layout object exists yet.
     */
    @Test
    public void testCloneNullLayout()
    {
<span class="fc" id="L736">        conf = new PropertiesConfiguration();</span>
<span class="fc" id="L737">        PropertiesConfiguration copy = (PropertiesConfiguration) conf.clone();</span>
<span class="fc" id="L738">        assertNotSame(&quot;Layout objects are the same&quot;, conf.getLayout(), copy.getLayout());</span>
<span class="fc" id="L739">    }</span>

    /**
     * Tests saving a file-based configuration to a HTTP server.
     */
    @Test
    public void testSaveToHTTPServerSuccess() throws Exception
    {
<span class="fc" id="L747">        MockHttpURLStreamHandler handler = new MockHttpURLStreamHandler(</span>
                HttpURLConnection.HTTP_OK, testSavePropertiesFile);
<span class="fc" id="L749">        URL url = new URL(null, &quot;http://jakarta.apache.org&quot;, handler);</span>
<span class="fc" id="L750">        new FileHandler(conf).save(url);</span>
<span class="fc" id="L751">        MockHttpURLConnection con = handler.getMockConnection();</span>
<span class="fc" id="L752">        assertTrue(&quot;Wrong output flag&quot;, con.getDoOutput());</span>
<span class="fc" id="L753">        assertEquals(&quot;Wrong method&quot;, &quot;PUT&quot;, con.getRequestMethod());</span>
<span class="fc" id="L754">        checkSavedConfig();</span>
<span class="fc" id="L755">    }</span>

    /**
     * Tests saving a file-based configuration to a HTTP server when the server
     * reports a failure. This should cause an exception.
     */
    @Test
    public void testSaveToHTTPServerFail() throws Exception
    {
<span class="fc" id="L764">        MockHttpURLStreamHandler handler = new MockHttpURLStreamHandler(</span>
                HttpURLConnection.HTTP_BAD_REQUEST, testSavePropertiesFile);
<span class="fc" id="L766">        URL url = new URL(null, &quot;http://jakarta.apache.org&quot;, handler);</span>
        try
        {
<span class="nc" id="L769">            new FileHandler(conf).save(url);</span>
<span class="nc" id="L770">            fail(&quot;Response code was not checked!&quot;);</span>
        }
<span class="fc" id="L772">        catch (ConfigurationException cex)</span>
        {
<span class="fc" id="L774">            assertTrue(&quot;Wrong root cause: &quot; + cex,</span>
<span class="fc" id="L775">                    cex.getCause() instanceof IOException);</span>
<span class="nc" id="L776">        }</span>
<span class="fc" id="L777">    }</span>

    /**
     * Test the creation of a file containing a '#' in its name.
     */
    @Test
    public void testFileWithSharpSymbol() throws Exception
    {
<span class="fc" id="L785">        File file = folder.newFile(&quot;sharp#1.properties&quot;);</span>

<span class="fc" id="L787">        PropertiesConfiguration conf = new PropertiesConfiguration();</span>
<span class="fc" id="L788">        FileHandler handler = new FileHandler(conf);</span>
<span class="fc" id="L789">        handler.setFile(file);</span>
<span class="fc" id="L790">        handler.load();</span>
<span class="fc" id="L791">        handler.save();</span>

<span class="fc" id="L793">        assertTrue(&quot;Missing file &quot; + file, file.exists());</span>
<span class="fc" id="L794">    }</span>

    /**
     * Tests initializing a properties configuration from a non existing file.
     * There was a bug, which caused properties getting lost when later save()
     * is called.
     */
    @Test
    public void testInitFromNonExistingFile() throws ConfigurationException
    {
<span class="fc" id="L804">        final String testProperty = &quot;test.successfull&quot;;</span>
<span class="fc" id="L805">        conf = new PropertiesConfiguration();</span>
<span class="fc" id="L806">        FileHandler handler = new FileHandler(conf);</span>
<span class="fc" id="L807">        handler.setFile(testSavePropertiesFile);</span>
<span class="fc" id="L808">        conf.addProperty(testProperty, &quot;true&quot;);</span>
<span class="fc" id="L809">        handler.save();</span>
<span class="fc" id="L810">        checkSavedConfig();</span>
<span class="fc" id="L811">    }</span>

    /**
     * Tests copying another configuration into the test configuration. This
     * test ensures that the layout object is informed about the newly added
     * properties.
     */
    @Test
    public void testCopyAndSave() throws ConfigurationException
    {
<span class="fc" id="L821">        Configuration copyConf = setUpCopyConfig();</span>
<span class="fc" id="L822">        conf.copy(copyConf);</span>
<span class="fc" id="L823">        checkCopiedConfig(copyConf);</span>
<span class="fc" id="L824">    }</span>

    /**
     * Tests appending a configuration to the test configuration. Again it has
     * to be ensured that the layout object is correctly updated.
     */
    @Test
    public void testAppendAndSave() throws ConfigurationException
    {
<span class="fc" id="L833">        Configuration copyConf = setUpCopyConfig();</span>
<span class="fc" id="L834">        conf.append(copyConf);</span>
<span class="fc" id="L835">        checkCopiedConfig(copyConf);</span>
<span class="fc" id="L836">    }</span>

    /**
     * Tests adding properties through a DataConfiguration. This is related to
     * CONFIGURATION-332.
     */
    @Test
    public void testSaveWithDataConfig() throws ConfigurationException
    {
<span class="fc" id="L845">        conf = new PropertiesConfiguration();</span>
<span class="fc" id="L846">        FileHandler handler = new FileHandler(conf);</span>
<span class="fc" id="L847">        handler.setFile(testSavePropertiesFile);</span>
<span class="fc" id="L848">        DataConfiguration dataConfig = new DataConfiguration(conf);</span>
<span class="fc" id="L849">        dataConfig.setProperty(&quot;foo&quot;, &quot;bar&quot;);</span>
<span class="fc" id="L850">        assertEquals(&quot;Property not set&quot;, &quot;bar&quot;, conf.getString(&quot;foo&quot;));</span>

<span class="fc" id="L852">        handler.save();</span>
<span class="fc" id="L853">        PropertiesConfiguration config2 = new PropertiesConfiguration();</span>
<span class="fc" id="L854">        load(config2, testSavePropertiesFile.getAbsolutePath());</span>
<span class="fc" id="L855">        assertEquals(&quot;Property not saved&quot;, &quot;bar&quot;, config2.getString(&quot;foo&quot;));</span>
<span class="fc" id="L856">    }</span>

    /**
     * Tests whether a default IOFactory is set.
     */
    @Test
    public void testGetIOFactoryDefault()
    {
<span class="fc" id="L864">        assertNotNull(&quot;No default IO factory&quot;, conf.getIOFactory());</span>
<span class="fc" id="L865">    }</span>

    /**
     * Tests setting the IOFactory to null. This should cause an exception.
     */
    @Test(expected = IllegalArgumentException.class)
    public void testSetIOFactoryNull()
    {
<span class="nc" id="L873">        conf.setIOFactory(null);</span>
<span class="nc" id="L874">    }</span>

    /**
     * Tests setting an IOFactory that uses a specialized reader.
     */
    @Test
    public void testSetIOFactoryReader() throws ConfigurationException
    {
<span class="fc" id="L882">        final int propertyCount = 10;</span>
<span class="fc" id="L883">        conf.clear();</span>
<span class="fc" id="L884">        conf.setIOFactory(new PropertiesConfiguration.IOFactory()</span>
<span class="fc" id="L885">        {</span>
            @Override
            public PropertiesConfiguration.PropertiesReader createPropertiesReader(
                    Reader in)
            {
<span class="fc" id="L890">                return new PropertiesReaderTestImpl(in, propertyCount);</span>
            }

            @Override
            public PropertiesConfiguration.PropertiesWriter createPropertiesWriter(
                    Writer out, ListDelimiterHandler handler)
            {
<span class="nc" id="L897">                throw new UnsupportedOperationException(&quot;Unexpected call!&quot;);</span>
            }
        });
<span class="fc" id="L900">        load(conf, testProperties);</span>
<span class="fc bfc" id="L901" title="All 2 branches covered.">        for (int i = 1; i &lt;= propertyCount; i++)</span>
        {
<span class="fc" id="L903">            assertEquals(&quot;Wrong property value at &quot; + i, PROP_VALUE + i, conf</span>
<span class="fc" id="L904">                    .getString(PROP_NAME + i));</span>
        }
<span class="fc" id="L906">    }</span>

    /**
     * Tests setting an IOFactory that uses a specialized writer.
     */
    @Test
    public void testSetIOFactoryWriter() throws ConfigurationException, IOException
    {
<span class="fc" id="L914">        final MutableObject&lt;Writer&gt; propertiesWriter = new MutableObject&lt;&gt;();</span>
<span class="fc" id="L915">        conf.setIOFactory(new PropertiesConfiguration.IOFactory()</span>
<span class="fc" id="L916">        {</span>
            @Override
            public PropertiesConfiguration.PropertiesReader createPropertiesReader(
                    Reader in)
            {
<span class="nc" id="L921">                throw new UnsupportedOperationException(&quot;Unexpected call!&quot;);</span>
            }

            @Override
            public PropertiesConfiguration.PropertiesWriter createPropertiesWriter(
                    Writer out, ListDelimiterHandler handler)
            {
                try
                {
<span class="fc" id="L930">                    PropertiesWriterTestImpl propWriter = new PropertiesWriterTestImpl(handler);</span>
<span class="fc" id="L931">                    propertiesWriter.setValue(propWriter);</span>
<span class="fc" id="L932">                    return propWriter;</span>
                }
<span class="nc" id="L934">                catch (IOException e)</span>
                {
<span class="nc" id="L936">                    return null;</span>
                }
            }
        });
<span class="fc" id="L940">        new FileHandler(conf).save(new StringWriter());</span>
<span class="fc" id="L941">        propertiesWriter.getValue().close();</span>
<span class="fc" id="L942">        checkSavedConfig();</span>
<span class="fc" id="L943">    }</span>

    /**
     * Tests that the property separators are retained when saving the
     * configuration.
     */
    @Test
    public void testKeepSeparators() throws ConfigurationException, IOException
    {
<span class="fc" id="L952">        saveTestConfig();</span>
<span class="fc" id="L953">        final String[] separatorTests = {</span>
                &quot;test.separator.equal = foo&quot;, &quot;test.separator.colon : foo&quot;,
                &quot;test.separator.tab\tfoo&quot;, &quot;test.separator.whitespace foo&quot;,
                &quot;test.separator.no.space=foo&quot;
        };
<span class="fc" id="L958">        Set&lt;String&gt; foundLines = new HashSet&lt;&gt;();</span>
<span class="fc" id="L959">        BufferedReader in = new BufferedReader(new FileReader(</span>
                testSavePropertiesFile));
        try
        {
            String s;
<span class="fc bfc" id="L964" title="All 2 branches covered.">            while ((s = in.readLine()) != null)</span>
            {
<span class="fc bfc" id="L966" title="All 2 branches covered.">                for (String separatorTest : separatorTests) {</span>
<span class="fc bfc" id="L967" title="All 2 branches covered.">                    if (separatorTest.equals(s))</span>
                    {
<span class="fc" id="L969">                        foundLines.add(s);</span>
                    }
                }
            }
        }
        finally
        {
<span class="fc" id="L976">            in.close();</span>
        }
<span class="fc" id="L978">        assertEquals(&quot;No all separators were found: &quot; + foundLines,</span>
<span class="fc" id="L979">                separatorTests.length, foundLines.size());</span>
<span class="fc" id="L980">    }</span>

    /**
     * Tests whether properties with slashes in their values can be saved. This
     * test is related to CONFIGURATION-408.
     */
    @Test
    public void testSlashEscaping() throws ConfigurationException
    {
<span class="fc" id="L989">        conf.setProperty(PROP_NAME, &quot;http://www.apache.org&quot;);</span>
<span class="fc" id="L990">        StringWriter writer = new StringWriter();</span>
<span class="fc" id="L991">        new FileHandler(conf).save(writer);</span>
<span class="fc" id="L992">        String s = writer.toString();</span>
<span class="fc" id="L993">        assertTrue(&quot;Value not found: &quot; + s, s.contains(PROP_NAME</span>
                + &quot; = http://www.apache.org&quot;));
<span class="fc" id="L995">    }</span>

    /**
     * Tests whether backslashes are correctly handled if lists are parsed. This
     * test is related to CONFIGURATION-418.
     */
    @Test
    public void testBackslashEscapingInLists() throws Exception
    {
<span class="fc" id="L1004">        checkBackslashList(&quot;share2&quot;);</span>
<span class="fc" id="L1005">        checkBackslashList(&quot;share1&quot;);</span>
<span class="fc" id="L1006">    }</span>

    /**
     * Tests whether a list property is handled correctly if delimiter parsing
     * is disabled. This test is related to CONFIGURATION-495.
     */
    @Test
    public void testSetPropertyListWithDelimiterParsingDisabled()
            throws ConfigurationException
    {
<span class="fc" id="L1016">        String prop = &quot;delimiterListProp&quot;;</span>
<span class="fc" id="L1017">        conf.setListDelimiterHandler(DisabledListDelimiterHandler.INSTANCE);</span>
<span class="fc" id="L1018">        List&lt;String&gt; list = Arrays.asList(&quot;val&quot;, &quot;val2&quot;, &quot;val3&quot;);</span>
<span class="fc" id="L1019">        conf.setProperty(prop, list);</span>
<span class="fc" id="L1020">        saveTestConfig();</span>
<span class="fc" id="L1021">        conf.clear();</span>
<span class="fc" id="L1022">        load(conf, testSavePropertiesFile.getAbsolutePath());</span>
<span class="fc" id="L1023">        assertEquals(&quot;Wrong list property&quot;, list, conf.getProperty(prop));</span>
<span class="fc" id="L1024">    }</span>

    /**
     * Tests whether a footer comment is correctly read.
     */
    @Test
    public void testReadFooterComment()
    {
<span class="fc" id="L1032">        assertEquals(&quot;Wrong footer comment&quot;, &quot;\n# This is a foot comment\n&quot;,</span>
<span class="fc" id="L1033">                conf.getFooter());</span>
<span class="fc" id="L1034">        assertEquals(&quot;Wrong footer comment from layout&quot;,</span>
<span class="fc" id="L1035">                &quot;\nThis is a foot comment\n&quot;, conf.getLayout()</span>
<span class="fc" id="L1036">                        .getCanonicalFooterCooment(false));</span>
<span class="fc" id="L1037">    }</span>

    /**
     * Tests whether a footer comment is correctly written out.
     */
    @Test
    public void testWriteFooterComment() throws ConfigurationException,
            IOException
    {
<span class="fc" id="L1046">        final String footer = &quot;my footer&quot;;</span>
<span class="fc" id="L1047">        conf.clear();</span>
<span class="fc" id="L1048">        conf.setProperty(PROP_NAME, PROP_VALUE);</span>
<span class="fc" id="L1049">        conf.setFooter(footer);</span>
<span class="fc" id="L1050">        StringWriter out = new StringWriter();</span>
<span class="fc" id="L1051">        conf.write(out);</span>
<span class="fc" id="L1052">        assertEquals(&quot;Wrong result&quot;, PROP_NAME + &quot; = &quot; + PROP_VALUE + CR + &quot;# &quot;</span>
<span class="fc" id="L1053">                + footer + CR, out.toString());</span>
<span class="fc" id="L1054">    }</span>

    /**
     * Tests whether a clear() operation clears the footer comment.
     */
    @Test
    public void testClearFooterComment()
    {
<span class="fc" id="L1062">        conf.clear();</span>
<span class="fc" id="L1063">        assertNull(&quot;Still got a footer comment&quot;, conf.getFooter());</span>
<span class="fc" id="L1064">        assertNull(&quot;Still got a header comment&quot;, conf.getHeader());</span>
<span class="fc" id="L1065">    }</span>

    /**
     * Tests whether read access to the footer comment is synchronized.
     */
    @Test
    public void testGetFooterSynchronized()
    {
<span class="fc" id="L1073">        SynchronizerTestImpl sync = new SynchronizerTestImpl();</span>
<span class="fc" id="L1074">        conf.setSynchronizer(sync);</span>
<span class="fc" id="L1075">        assertNotNull(&quot;No footer comment&quot;, conf.getFooter());</span>
<span class="fc" id="L1076">        sync.verify(Methods.BEGIN_READ, Methods.END_READ);</span>
<span class="fc" id="L1077">    }</span>

    /**
     * Tests whether write access to the footer comment is synchronized.
     */
    @Test
    public void testSetFooterSynchronized()
    {
<span class="fc" id="L1085">        SynchronizerTestImpl sync = new SynchronizerTestImpl();</span>
<span class="fc" id="L1086">        conf.setSynchronizer(sync);</span>
<span class="fc" id="L1087">        conf.setFooter(&quot;new comment&quot;);</span>
<span class="fc" id="L1088">        sync.verify(Methods.BEGIN_WRITE, Methods.END_WRITE);</span>
<span class="fc" id="L1089">    }</span>

    /**
     * Tests whether read access to the header comment is synchronized.
     */
    @Test
    public void testGetHeaderSynchronized()
    {
<span class="fc" id="L1097">        SynchronizerTestImpl sync = new SynchronizerTestImpl();</span>
<span class="fc" id="L1098">        conf.setSynchronizer(sync);</span>
<span class="fc" id="L1099">        assertNull(&quot;Got a header comment&quot;, conf.getHeader());</span>
<span class="fc" id="L1100">        sync.verify(Methods.BEGIN_READ, Methods.END_READ);</span>
<span class="fc" id="L1101">    }</span>

    /**
     * Tests whether write access to the header comment is synchronized.
     */
    @Test
    public void testSetHeaderSynchronized()
    {
<span class="fc" id="L1109">        SynchronizerTestImpl sync = new SynchronizerTestImpl();</span>
<span class="fc" id="L1110">        conf.setSynchronizer(sync);</span>
<span class="fc" id="L1111">        conf.setHeader(&quot;new comment&quot;);</span>
<span class="fc" id="L1112">        sync.verify(Methods.BEGIN_WRITE, Methods.END_WRITE);</span>
<span class="fc" id="L1113">    }</span>

    /**
     * Tests the escaping of quotation marks in a properties value. This test is
     * related to CONFIGURATION-516.
     */
    @Test
    public void testEscapeQuote() throws ConfigurationException
    {
<span class="fc" id="L1122">        conf.clear();</span>
<span class="fc" id="L1123">        String text = &quot;\&quot;Hello World!\&quot;&quot;;</span>
<span class="fc" id="L1124">        conf.setProperty(PROP_NAME, text);</span>
<span class="fc" id="L1125">        StringWriter out = new StringWriter();</span>
<span class="fc" id="L1126">        new FileHandler(conf).save(out);</span>
<span class="fc" id="L1127">        assertTrue(&quot;Value was escaped: &quot; + out,</span>
<span class="fc" id="L1128">                out.toString().contains(text));</span>
<span class="fc" id="L1129">        saveTestConfig();</span>
<span class="fc" id="L1130">        PropertiesConfiguration c2 = new PropertiesConfiguration();</span>
<span class="fc" id="L1131">        load(c2, testSavePropertiesFile.getAbsolutePath());</span>
<span class="fc" id="L1132">        assertEquals(&quot;Wrong value&quot;, text, c2.getString(PROP_NAME));</span>
<span class="fc" id="L1133">    }</span>

    /**
     * Tests whether the correct file system is used when loading an include
     * file. This test is related to CONFIGURATION-609.
     */
    @Test
    public void testLoadIncludeFileViaFileSystem() throws ConfigurationException
    {
<span class="fc" id="L1142">        conf.clear();</span>
<span class="fc" id="L1143">        conf.addProperty(&quot;include&quot;, &quot;include.properties&quot;);</span>
<span class="fc" id="L1144">        saveTestConfig();</span>

<span class="fc" id="L1146">        FileSystem fs = new DefaultFileSystem()</span>
<span class="fc" id="L1147">        {</span>
            @Override
            public InputStream getInputStream(URL url)
                    throws ConfigurationException
            {
<span class="fc bfc" id="L1152" title="All 2 branches covered.">                if (url.toString().endsWith(&quot;include.properties&quot;))</span>
                {
                    try
                    {
<span class="fc" id="L1156">                        return new ByteArrayInputStream(</span>
<span class="fc" id="L1157">                                &quot;test.outcome = success&quot;.getBytes(&quot;UTF-8&quot;));</span>
                    }
<span class="nc" id="L1159">                    catch (UnsupportedEncodingException e)</span>
                    {
<span class="nc" id="L1161">                        throw new ConfigurationException(&quot;Unsupported encoding&quot;,</span>
                                e);
                    }
                }
<span class="fc" id="L1165">                return super.getInputStream(url);</span>
            }
        };
<span class="fc" id="L1168">        Parameters params = new Parameters();</span>
<span class="fc" id="L1169">        FileBasedConfigurationBuilder&lt;PropertiesConfiguration&gt; builder =</span>
                new FileBasedConfigurationBuilder&lt;&gt;(
                        PropertiesConfiguration.class);
<span class="fc" id="L1172">        builder.configure(params.fileBased().setFile(testSavePropertiesFile)</span>
<span class="fc" id="L1173">                .setBasePath(ConfigurationAssert.OUT_DIR.toURI().toString())</span>
<span class="fc" id="L1174">                .setFileSystem(fs));</span>
<span class="fc" id="L1175">        PropertiesConfiguration configuration = builder.getConfiguration();</span>
<span class="fc" id="L1176">        assertEquals(&quot;success&quot;, configuration.getString(&quot;test.outcome&quot;));</span>
<span class="fc" id="L1177">    }</span>

    /**
     * Tests whether special characters in a property value are un-escaped. This
     * test is related to CONFIGURATION-640.
     */
    @Test
    public void testUnEscapeCharacters()
    {
<span class="fc" id="L1186">        assertEquals(&quot;Wrong value&quot;, &quot;#1 =: me!&quot;,</span>
<span class="fc" id="L1187">                conf.getString(&quot;test.unescape.characters&quot;));</span>
<span class="fc" id="L1188">    }</span>

    /**
     * Tests a direct invocation of the read() method. This is not allowed
     * because certain initializations have not been done. This test is
     * related to CONFIGURATION-641.
     */
    @Test
    public void testReadCalledDirectly() throws IOException
    {
<span class="fc" id="L1198">        conf = new PropertiesConfiguration();</span>
<span class="fc" id="L1199">        Reader in = new FileReader(ConfigurationAssert.getTestFile(&quot;test.properties&quot;));</span>
        try
        {
<span class="nc" id="L1202">            conf.read(in);</span>
<span class="nc" id="L1203">            fail(&quot;No exception thrown!&quot;);</span>
        }
<span class="fc" id="L1205">        catch (ConfigurationException e)</span>
        {
<span class="fc" id="L1207">            assertThat(e.getMessage(), containsString(&quot;FileHandler&quot;));</span>
        }
        finally
        {
<span class="fc" id="L1211">            in.close();</span>
        }
<span class="fc" id="L1213">    }</span>

    /**
     * Helper method for testing the content of a list with elements that
     * contain backslashes.
     *
     * @param key the key
     */
    private void checkBackslashList(String key)
    {
<span class="fc" id="L1223">        Object prop = conf.getProperty(&quot;test.&quot; + key);</span>
<span class="fc" id="L1224">        assertTrue(&quot;Not a list&quot;, prop instanceof List);</span>
<span class="fc" id="L1225">        List&lt;?&gt; list = (List&lt;?&gt;) prop;</span>
<span class="fc" id="L1226">        assertEquals(&quot;Wrong number of list elements&quot;, 2, list.size());</span>
<span class="fc" id="L1227">        final String prefix = &quot;\\\\&quot; + key;</span>
<span class="fc" id="L1228">        assertEquals(&quot;Wrong element 1&quot;, prefix + &quot;a&quot;, list.get(0));</span>
<span class="fc" id="L1229">        assertEquals(&quot;Wrong element 2&quot;, prefix + &quot;b&quot;, list.get(1));</span>
<span class="fc" id="L1230">    }</span>

    /**
     * Creates a configuration that can be used for testing copy operations.
     *
     * @return the configuration to be copied
     */
    private Configuration setUpCopyConfig()
    {
<span class="fc" id="L1239">        final int count = 25;</span>
<span class="fc" id="L1240">        Configuration result = new BaseConfiguration();</span>
<span class="fc bfc" id="L1241" title="All 2 branches covered.">        for (int i = 1; i &lt;= count; i++)</span>
        {
<span class="fc" id="L1243">            result.addProperty(&quot;copyKey&quot; + i, &quot;copyValue&quot; + i);</span>
        }
<span class="fc" id="L1245">        return result;</span>
    }

    /**
     * Tests whether the data of a configuration that was copied into the test
     * configuration is correctly saved.
     *
     * @param copyConf the copied configuration
     * @throws ConfigurationException if an error occurs
     */
    private void checkCopiedConfig(Configuration copyConf)
            throws ConfigurationException
    {
<span class="fc" id="L1258">        saveTestConfig();</span>
<span class="fc" id="L1259">        PropertiesConfiguration checkConf = new PropertiesConfiguration();</span>
<span class="fc" id="L1260">        load(checkConf, testSavePropertiesFile.getAbsolutePath());</span>
<span class="fc bfc" id="L1261" title="All 2 branches covered.">        for (Iterator&lt;String&gt; it = copyConf.getKeys(); it.hasNext();)</span>
        {
<span class="fc" id="L1263">            String key = it.next();</span>
<span class="fc" id="L1264">            assertEquals(&quot;Wrong value for property &quot; + key, checkConf</span>
<span class="fc" id="L1265">                    .getProperty(key), copyConf.getProperty(key));</span>
<span class="fc" id="L1266">        }</span>
<span class="fc" id="L1267">    }</span>

    /**
     * Saves the test configuration to a default output file.
     *
     * @throws ConfigurationException if an error occurs
     */
    private void saveTestConfig() throws ConfigurationException
    {
<span class="fc" id="L1276">        FileHandler handler = new FileHandler(conf);</span>
<span class="fc" id="L1277">        handler.save(testSavePropertiesFile);</span>
<span class="fc" id="L1278">    }</span>

    /**
     * A dummy layout implementation for checking whether certain methods are
     * correctly called by the configuration.
     */
<span class="fc" id="L1284">    static class DummyLayout extends PropertiesConfigurationLayout</span>
    {
        /** Stores the number how often load() was called. */
        public int loadCalls;

        @Override
        public void load(PropertiesConfiguration config, Reader in)
                throws ConfigurationException
        {
<span class="fc" id="L1293">            loadCalls++;</span>
<span class="fc" id="L1294">        }</span>
    }

    /**
     * A mock implementation of a HttpURLConnection used for testing saving to
     * a HTTP server.
     */
    static class MockHttpURLConnection extends HttpURLConnection
    {
        /** The response code to return.*/
        private final int returnCode;

        /** The output file. The output stream will point to this file.*/
        private final File outputFile;

        protected MockHttpURLConnection(URL u, int respCode, File outFile)
        {
<span class="fc" id="L1311">            super(u);</span>
<span class="fc" id="L1312">            returnCode = respCode;</span>
<span class="fc" id="L1313">            outputFile = outFile;</span>
<span class="fc" id="L1314">        }</span>

        @Override
        public void disconnect()
        {
<span class="nc" id="L1319">        }</span>

        @Override
        public boolean usingProxy()
        {
<span class="nc" id="L1324">            return false;</span>
        }

        @Override
        public void connect() throws IOException
        {
<span class="nc" id="L1330">        }</span>

        @Override
        public int getResponseCode() throws IOException
        {
<span class="fc" id="L1335">            return returnCode;</span>
        }

        @Override
        public OutputStream getOutputStream() throws IOException
        {
<span class="fc" id="L1341">            return new FileOutputStream(outputFile);</span>
        }
    }

    /**
     * A mock stream handler for working with the mock HttpURLConnection.
     */
    static class MockHttpURLStreamHandler extends URLStreamHandler
    {
        /** Stores the response code.*/
        private final int responseCode;

        /** Stores the output file.*/
        private final File outputFile;

        /** Stores the connection.*/
        private MockHttpURLConnection connection;

        public MockHttpURLStreamHandler(int respCode, File outFile)
<span class="fc" id="L1360">        {</span>
<span class="fc" id="L1361">            responseCode = respCode;</span>
<span class="fc" id="L1362">            outputFile = outFile;</span>
<span class="fc" id="L1363">        }</span>

        public MockHttpURLConnection getMockConnection()
        {
<span class="fc" id="L1367">            return connection;</span>
        }

        @Override
        protected URLConnection openConnection(URL u) throws IOException
        {
<span class="fc" id="L1373">            connection = new MockHttpURLConnection(u, responseCode, outputFile);</span>
<span class="fc" id="L1374">            return connection;</span>
        }
    }

    /**
     * A test PropertiesReader for testing whether a custom reader can be
     * injected. This implementation creates a configurable number of synthetic
     * test properties.
     */
    private static class PropertiesReaderTestImpl extends
            PropertiesConfiguration.PropertiesReader
    {
        /** The number of test properties to be created. */
        private final int maxProperties;

        /** The current number of properties. */
        private int propertyCount;

        public PropertiesReaderTestImpl(Reader reader, int maxProps)
        {
<span class="fc" id="L1394">            super(reader);</span>
<span class="fc" id="L1395">            maxProperties = maxProps;</span>
<span class="fc" id="L1396">        }</span>

        @Override
        public String getPropertyName()
        {
<span class="fc" id="L1401">            return PROP_NAME + propertyCount;</span>
        }

        @Override
        public String getPropertyValue()
        {
<span class="fc" id="L1407">            return PROP_VALUE + propertyCount;</span>
        }

        @Override
        public boolean nextProperty() throws IOException
        {
<span class="fc" id="L1413">            propertyCount++;</span>
<span class="fc bfc" id="L1414" title="All 2 branches covered.">            return propertyCount &lt;= maxProperties;</span>
        }
    }

    /**
     * A test PropertiesWriter for testing whether a custom writer can be
     * injected. This implementation simply redirects all output into a test
     * file.
     */
    private static class PropertiesWriterTestImpl extends
            PropertiesConfiguration.PropertiesWriter
    {
        public PropertiesWriterTestImpl(ListDelimiterHandler handler) throws IOException
        {
<span class="fc" id="L1428">            super(new FileWriter(testSavePropertiesFile), handler);</span>
<span class="fc" id="L1429">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>