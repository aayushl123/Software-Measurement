<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>XmlStreamReader.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">commons_io$Whole_project.exec</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.io.input.compatibility</a> &gt; <span class="el_source">XmlStreamReader.java</span></div><h1>XmlStreamReader.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.commons.io.input.compatibility;

import java.io.BufferedInputStream;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.io.StringReader;
import java.net.HttpURLConnection;
import java.net.URL;
import java.net.URLConnection;
import java.text.MessageFormat;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.apache.commons.io.output.XmlStreamWriter;

/**
 * Character stream that handles all the necessary Voodo to figure out the
 * charset encoding of the XML document within the stream.
 * &lt;p&gt;
 * IMPORTANT: This class is not related in any way to the org.xml.sax.XMLReader.
 * This one IS a character stream.
 * &lt;p&gt;
 * All this has to be done without consuming characters from the stream, if not
 * the XML parser will not recognized the document as a valid XML. This is not
 * 100% true, but it's close enough (UTF-8 BOM is not handled by all parsers
 * right now, XmlStreamReader handles it and things work in all parsers).
 * &lt;p&gt;
 * The XmlStreamReader class handles the charset encoding of XML documents in
 * Files, raw streams and HTTP streams by offering a wide set of constructors.
 * &lt;p&gt;
 * By default the charset encoding detection is lenient, the constructor with
 * the lenient flag can be used for an script (following HTTP MIME and XML
 * specifications). All this is nicely explained by Mark Pilgrim in his blog, &lt;a
 * href=&quot;http://diveintomark.org/archives/2004/02/13/xml-media-types&quot;&gt;
 * Determining the character encoding of a feed&lt;/a&gt;.
 * &lt;p&gt;
 * Originally developed for &lt;a href=&quot;http://rome.dev.java.net&quot;&gt;ROME&lt;/a&gt; under
 * Apache License 2.0.
 *
 * @version $Id$
 * @see XmlStreamWriter
 */
public class XmlStreamReader extends Reader {
    private static final int BUFFER_SIZE = 4096;

    private static final String UTF_8 = &quot;UTF-8&quot;;

    private static final String US_ASCII = &quot;US-ASCII&quot;;

    private static final String UTF_16BE = &quot;UTF-16BE&quot;;

    private static final String UTF_16LE = &quot;UTF-16LE&quot;;

    private static final String UTF_16 = &quot;UTF-16&quot;;

    private static final String UTF_32BE = &quot;UTF-32BE&quot;;

    private static final String UTF_32LE = &quot;UTF-32LE&quot;;

    private static final String UTF_32 = &quot;UTF-32&quot;;

    private static final String EBCDIC = &quot;CP1047&quot;;

<span class="fc" id="L85">    private static String staticDefaultEncoding = null;</span>

    private Reader reader;

    private String encoding;

    private final String defaultEncoding;

    /**
     * Sets the default encoding to use if none is set in HTTP content-type, XML
     * prolog and the rules based on content-type are not adequate.
     * &lt;p&gt;
     * If it is set to NULL the content-type based rules are used.
     * &lt;p&gt;
     * By default it is NULL.
     *
     * @param encoding charset encoding to default to.
     */
    public static void setDefaultEncoding(final String encoding) {
<span class="nc" id="L104">        staticDefaultEncoding = encoding;</span>
<span class="nc" id="L105">    }</span>

    /**
     * Returns the default encoding to use if none is set in HTTP content-type,
     * XML prolog and the rules based on content-type are not adequate.
     * &lt;p&gt;
     * If it is NULL the content-type based rules are used.
     *
     * @return the default encoding to use.
     */
    public static String getDefaultEncoding() {
<span class="nc" id="L116">        return staticDefaultEncoding;</span>
    }

    /**
     * Creates a Reader for a File.
     * &lt;p&gt;
     * It looks for the UTF-8 BOM first, if none sniffs the XML prolog charset,
     * if this is also missing defaults to UTF-8.
     * &lt;p&gt;
     * It does a lenient charset encoding detection, check the constructor with
     * the lenient parameter for details.
     *
     * @param file File to create a Reader from.
     * @throws IOException thrown if there is a problem reading the file.
     */
    public XmlStreamReader(final File file) throws IOException {
<span class="nc" id="L132">        this(new FileInputStream(file));</span>
<span class="nc" id="L133">    }</span>

    /**
     * Creates a Reader for a raw InputStream.
     * &lt;p&gt;
     * It follows the same logic used for files.
     * &lt;p&gt;
     * It does a lenient charset encoding detection, check the constructor with
     * the lenient parameter for details.
     *
     * @param is InputStream to create a Reader from.
     * @throws IOException thrown if there is a problem reading the stream.
     */
    public XmlStreamReader(final InputStream is) throws IOException {
<span class="nc" id="L147">        this(is, true);</span>
<span class="nc" id="L148">    }</span>

    /**
     * Creates a Reader for a raw InputStream.
     * &lt;p&gt;
     * It follows the same logic used for files.
     * &lt;p&gt;
     * If lenient detection is indicated and the detection above fails as per
     * specifications it then attempts the following:
     * &lt;p&gt;
     * If the content type was 'text/html' it replaces it with 'text/xml' and
     * tries the detection again.
     * &lt;p&gt;
     * Else if the XML prolog had a charset encoding that encoding is used.
     * &lt;p&gt;
     * Else if the content type had a charset encoding that encoding is used.
     * &lt;p&gt;
     * Else 'UTF-8' is used.
     * &lt;p&gt;
     * If lenient detection is indicated an XmlStreamReaderException is never
     * thrown.
     *
     * @param is InputStream to create a Reader from.
     * @param lenient indicates if the charset encoding detection should be
     *        relaxed.
     * @throws IOException thrown if there is a problem reading the stream.
     * @throws XmlStreamReaderException thrown if the charset encoding could not
     *         be determined according to the specs.
     */
    public XmlStreamReader(final InputStream is, final boolean lenient) throws IOException,
<span class="nc" id="L178">            XmlStreamReaderException {</span>
<span class="nc" id="L179">        defaultEncoding = staticDefaultEncoding;</span>
        try {
<span class="nc" id="L181">            doRawStream(is);</span>
<span class="nc" id="L182">        } catch (final XmlStreamReaderException ex) {</span>
<span class="nc bnc" id="L183" title="All 2 branches missed.">            if (!lenient) {</span>
<span class="nc" id="L184">                throw ex;</span>
            } else {
<span class="nc" id="L186">                doLenientDetection(null, ex);</span>
            }
<span class="nc" id="L188">        }</span>
<span class="nc" id="L189">    }</span>

    /**
     * Creates a Reader using the InputStream of a URL.
     * &lt;p&gt;
     * If the URL is not of type HTTP and there is not 'content-type' header in
     * the fetched data it uses the same logic used for Files.
     * &lt;p&gt;
     * If the URL is a HTTP Url or there is a 'content-type' header in the
     * fetched data it uses the same logic used for an InputStream with
     * content-type.
     * &lt;p&gt;
     * It does a lenient charset encoding detection, check the constructor with
     * the lenient parameter for details.
     *
     * @param url URL to create a Reader from.
     * @throws IOException thrown if there is a problem reading the stream of
     *         the URL.
     */
    public XmlStreamReader(final URL url) throws IOException {
<span class="nc" id="L209">        this(url.openConnection());</span>
<span class="nc" id="L210">    }</span>

    /**
     * Creates a Reader using the InputStream of a URLConnection.
     * &lt;p&gt;
     * If the URLConnection is not of type HttpURLConnection and there is not
     * 'content-type' header in the fetched data it uses the same logic used for
     * files.
     * &lt;p&gt;
     * If the URLConnection is a HTTP Url or there is a 'content-type' header in
     * the fetched data it uses the same logic used for an InputStream with
     * content-type.
     * &lt;p&gt;
     * It does a lenient charset encoding detection, check the constructor with
     * the lenient parameter for details.
     *
     * @param conn URLConnection to create a Reader from.
     * @throws IOException thrown if there is a problem reading the stream of
     *         the URLConnection.
     */
<span class="nc" id="L230">    public XmlStreamReader(final URLConnection conn) throws IOException {</span>
<span class="nc" id="L231">        defaultEncoding = staticDefaultEncoding;</span>
<span class="nc" id="L232">        final boolean lenient = true;</span>
<span class="nc bnc" id="L233" title="All 2 branches missed.">        if (conn instanceof HttpURLConnection) {</span>
            try {
<span class="nc" id="L235">                doHttpStream(conn.getInputStream(), conn.getContentType(),</span>
                        lenient);
<span class="nc" id="L237">            } catch (final XmlStreamReaderException ex) {</span>
<span class="nc" id="L238">                doLenientDetection(conn.getContentType(), ex);</span>
<span class="nc" id="L239">            }</span>
<span class="nc bnc" id="L240" title="All 2 branches missed.">        } else if (conn.getContentType() != null) {</span>
            try {
<span class="nc" id="L242">                doHttpStream(conn.getInputStream(), conn.getContentType(),</span>
                        lenient);
<span class="nc" id="L244">            } catch (final XmlStreamReaderException ex) {</span>
<span class="nc" id="L245">                doLenientDetection(conn.getContentType(), ex);</span>
<span class="nc" id="L246">            }</span>
        } else {
            try {
<span class="nc" id="L249">                doRawStream(conn.getInputStream());</span>
<span class="nc" id="L250">            } catch (final XmlStreamReaderException ex) {</span>
<span class="nc" id="L251">                doLenientDetection(null, ex);</span>
<span class="nc" id="L252">            }</span>
        }
<span class="nc" id="L254">    }</span>

    /**
     * Creates a Reader using an InputStream an the associated content-type
     * header.
     * &lt;p&gt;
     * First it checks if the stream has BOM. If there is not BOM checks the
     * content-type encoding. If there is not content-type encoding checks the
     * XML prolog encoding. If there is not XML prolog encoding uses the default
     * encoding mandated by the content-type MIME type.
     * &lt;p&gt;
     * It does a lenient charset encoding detection, check the constructor with
     * the lenient parameter for details.
     *
     * @param is InputStream to create the reader from.
     * @param httpContentType content-type header to use for the resolution of
     *        the charset encoding.
     * @throws IOException thrown if there is a problem reading the file.
     */
    public XmlStreamReader(final InputStream is, final String httpContentType)
            throws IOException {
<span class="nc" id="L275">        this(is, httpContentType, true);</span>
<span class="nc" id="L276">    }</span>

    /**
     * Creates a Reader using an InputStream an the associated content-type
     * header. This constructor is lenient regarding the encoding detection.
     * &lt;p&gt;
     * First it checks if the stream has BOM. If there is not BOM checks the
     * content-type encoding. If there is not content-type encoding checks the
     * XML prolog encoding. If there is not XML prolog encoding uses the default
     * encoding mandated by the content-type MIME type.
     * &lt;p&gt;
     * If lenient detection is indicated and the detection above fails as per
     * specifications it then attempts the following:
     * &lt;p&gt;
     * If the content type was 'text/html' it replaces it with 'text/xml' and
     * tries the detection again.
     * &lt;p&gt;
     * Else if the XML prolog had a charset encoding that encoding is used.
     * &lt;p&gt;
     * Else if the content type had a charset encoding that encoding is used.
     * &lt;p&gt;
     * Else 'UTF-8' is used.
     * &lt;p&gt;
     * If lenient detection is indicated an XmlStreamReaderException is never
     * thrown.
     *
     * @param is InputStream to create the reader from.
     * @param httpContentType content-type header to use for the resolution of
     *        the charset encoding.
     * @param lenient indicates if the charset encoding detection should be
     *        relaxed.
     * @param defaultEncoding the default encoding to use
     * @throws IOException thrown if there is a problem reading the file.
     * @throws XmlStreamReaderException thrown if the charset encoding could not
     *         be determined according to the specs.
     */
    public XmlStreamReader(final InputStream is, final String httpContentType,
            final boolean lenient, final String defaultEncoding) throws IOException,
<span class="fc" id="L314">            XmlStreamReaderException {</span>
<span class="fc bfc" id="L315" title="All 2 branches covered.">        this.defaultEncoding = defaultEncoding == null ? staticDefaultEncoding</span>
<span class="fc" id="L316">                : defaultEncoding;</span>
        try {
<span class="nc" id="L318">            doHttpStream(is, httpContentType, lenient);</span>
<span class="fc" id="L319">        } catch (final XmlStreamReaderException ex) {</span>
<span class="pc bpc" id="L320" title="1 of 2 branches missed.">            if (!lenient) {</span>
<span class="nc" id="L321">                throw ex;</span>
            } else {
<span class="fc" id="L323">                doLenientDetection(httpContentType, ex);</span>
            }
<span class="nc" id="L325">        }</span>
<span class="fc" id="L326">    }</span>

    /**
     * Creates a Reader using an InputStream an the associated content-type
     * header. This constructor is lenient regarding the encoding detection.
     * &lt;p&gt;
     * First it checks if the stream has BOM. If there is not BOM checks the
     * content-type encoding. If there is not content-type encoding checks the
     * XML prolog encoding. If there is not XML prolog encoding uses the default
     * encoding mandated by the content-type MIME type.
     * &lt;p&gt;
     * If lenient detection is indicated and the detection above fails as per
     * specifications it then attempts the following:
     * &lt;p&gt;
     * If the content type was 'text/html' it replaces it with 'text/xml' and
     * tries the detection again.
     * &lt;p&gt;
     * Else if the XML prolog had a charset encoding that encoding is used.
     * &lt;p&gt;
     * Else if the content type had a charset encoding that encoding is used.
     * &lt;p&gt;
     * Else 'UTF-8' is used.
     * &lt;p&gt;
     * If lenient detection is indicated an XmlStreamReaderException is never
     * thrown.
     *
     * @param is InputStream to create the reader from.
     * @param httpContentType content-type header to use for the resolution of
     *        the charset encoding.
     * @param lenient indicates if the charset encoding detection should be
     *        relaxed.
     * @throws IOException thrown if there is a problem reading the file.
     * @throws XmlStreamReaderException thrown if the charset encoding could not
     *         be determined according to the specs.
     */
    public XmlStreamReader(final InputStream is, final String httpContentType,
            final boolean lenient) throws IOException, XmlStreamReaderException {
<span class="nc" id="L363">        this(is, httpContentType, lenient, null);</span>
<span class="nc" id="L364">    }</span>

    private void doLenientDetection(String httpContentType,
            XmlStreamReaderException ex) throws IOException {
<span class="pc bpc" id="L368" title="1 of 2 branches missed.">        if (httpContentType != null) {</span>
<span class="nc bnc" id="L369" title="All 2 branches missed.">            if (httpContentType.startsWith(&quot;text/html&quot;)) {</span>
<span class="nc" id="L370">                httpContentType = httpContentType.substring(&quot;text/html&quot;</span>
<span class="nc" id="L371">                        .length());</span>
<span class="nc" id="L372">                httpContentType = &quot;text/xml&quot; + httpContentType;</span>
                try {
<span class="nc" id="L374">                    doHttpStream(ex.getInputStream(), httpContentType, true);</span>
<span class="nc" id="L375">                    ex = null;</span>
<span class="nc" id="L376">                } catch (final XmlStreamReaderException ex2) {</span>
<span class="nc" id="L377">                    ex = ex2;</span>
<span class="nc" id="L378">                }</span>
            }
        }
<span class="pc bpc" id="L381" title="1 of 2 branches missed.">        if (ex != null) {</span>
<span class="fc" id="L382">            String encoding = ex.getXmlEncoding();</span>
<span class="pc bpc" id="L383" title="1 of 2 branches missed.">            if (encoding == null) {</span>
<span class="fc" id="L384">                encoding = ex.getContentTypeEncoding();</span>
            }
<span class="pc bpc" id="L386" title="1 of 2 branches missed.">            if (encoding == null) {</span>
<span class="fc bfc" id="L387" title="All 2 branches covered.">                encoding = defaultEncoding == null ? UTF_8 : defaultEncoding;</span>
            }
<span class="fc" id="L389">            prepareReader(ex.getInputStream(), encoding);</span>
        }
<span class="fc" id="L391">    }</span>

    /**
     * Returns the charset encoding of the XmlStreamReader.
     *
     * @return charset encoding.
     */
    public String getEncoding() {
<span class="nc" id="L399">        return encoding;</span>
    }

    @Override
    public int read(final char[] buf, final int offset, final int len) throws IOException {
<span class="nc" id="L404">        return reader.read(buf, offset, len);</span>
    }

    /**
     * Closes the XmlStreamReader stream.
     *
     * @throws IOException thrown if there was a problem closing the stream.
     */
    @Override
    public void close() throws IOException {
<span class="fc" id="L414">        reader.close();</span>
<span class="fc" id="L415">    }</span>

    private void doRawStream(final InputStream is)
            throws IOException {
<span class="nc" id="L419">        final BufferedInputStream pis = new BufferedInputStream(is, BUFFER_SIZE);</span>
<span class="nc" id="L420">        final String bomEnc = getBOMEncoding(pis);</span>
<span class="nc" id="L421">        final String xmlGuessEnc = getXMLGuessEncoding(pis);</span>
<span class="nc" id="L422">        final String xmlEnc = getXmlProlog(pis, xmlGuessEnc);</span>
<span class="nc" id="L423">        final String encoding = calculateRawEncoding(bomEnc, xmlGuessEnc, xmlEnc, pis);</span>
<span class="nc" id="L424">        prepareReader(pis, encoding);</span>
<span class="nc" id="L425">    }</span>

    private void doHttpStream(final InputStream is, final String httpContentType,
            final boolean lenient) throws IOException {
<span class="fc" id="L429">        final BufferedInputStream pis = new BufferedInputStream(is, BUFFER_SIZE);</span>
<span class="fc" id="L430">        final String cTMime = getContentTypeMime(httpContentType);</span>
<span class="fc" id="L431">        final String cTEnc = getContentTypeEncoding(httpContentType);</span>
<span class="fc" id="L432">        final String bomEnc = getBOMEncoding(pis);</span>
<span class="fc" id="L433">        final String xmlGuessEnc = getXMLGuessEncoding(pis);</span>
<span class="fc" id="L434">        final String xmlEnc = getXmlProlog(pis, xmlGuessEnc);</span>
<span class="nc" id="L435">        final String encoding = calculateHttpEncoding(cTMime, cTEnc, bomEnc,</span>
                xmlGuessEnc, xmlEnc, pis, lenient);
<span class="nc" id="L437">        prepareReader(pis, encoding);</span>
<span class="nc" id="L438">    }</span>

    private void prepareReader(final InputStream is, final String encoding)
            throws IOException {
<span class="fc" id="L442">        reader = new InputStreamReader(is, encoding);</span>
<span class="fc" id="L443">        this.encoding = encoding;</span>
<span class="fc" id="L444">    }</span>

    // InputStream is passed for XmlStreamReaderException creation only
    String calculateRawEncoding(final String bomEnc, final String xmlGuessEnc,
            final String xmlEnc, final InputStream is) throws IOException {
        String encoding;
<span class="fc bfc" id="L450" title="All 2 branches covered.">        if (bomEnc == null) {</span>
<span class="fc bfc" id="L451" title="All 4 branches covered.">            if (xmlGuessEnc == null || xmlEnc == null) {</span>
<span class="fc bfc" id="L452" title="All 2 branches covered.">                encoding = defaultEncoding == null ? UTF_8 : defaultEncoding;</span>
<span class="fc bfc" id="L453" title="All 2 branches covered.">            } else if (xmlEnc.equals(UTF_16)</span>
<span class="fc bfc" id="L454" title="All 2 branches covered.">                    &amp;&amp; (xmlGuessEnc.equals(UTF_16BE) || xmlGuessEnc</span>
<span class="pc bpc" id="L455" title="1 of 2 branches missed.">                            .equals(UTF_16LE))) {</span>
<span class="fc" id="L456">                encoding = xmlGuessEnc;</span>
<span class="pc bpc" id="L457" title="1 of 2 branches missed.">            } else if (xmlEnc.equals(UTF_32)</span>
<span class="nc bnc" id="L458" title="All 2 branches missed.">                    &amp;&amp; (xmlGuessEnc.equals(UTF_32BE) || xmlGuessEnc</span>
<span class="nc bnc" id="L459" title="All 2 branches missed.">                            .equals(UTF_32LE))) {</span>
<span class="nc" id="L460">                encoding = xmlGuessEnc;</span>
            } else {
<span class="fc" id="L462">                encoding = xmlEnc;</span>
            }
<span class="fc bfc" id="L464" title="All 2 branches covered.">        } else if (bomEnc.equals(UTF_8)) {</span>
<span class="fc bfc" id="L465" title="All 4 branches covered.">            if (xmlGuessEnc != null &amp;&amp; !xmlGuessEnc.equals(UTF_8)) {</span>
<span class="fc" id="L466">                throw new XmlStreamReaderException(RAW_EX_1</span>
<span class="fc" id="L467">                        .format(new Object[] { bomEnc, xmlGuessEnc, xmlEnc }),</span>
                        bomEnc, xmlGuessEnc, xmlEnc, is);
            }
<span class="fc bfc" id="L470" title="All 4 branches covered.">            if (xmlEnc != null &amp;&amp; !xmlEnc.equals(UTF_8)) {</span>
<span class="fc" id="L471">                throw new XmlStreamReaderException(RAW_EX_1</span>
<span class="fc" id="L472">                        .format(new Object[] { bomEnc, xmlGuessEnc, xmlEnc }),</span>
                        bomEnc, xmlGuessEnc, xmlEnc, is);
            }
<span class="fc" id="L475">            encoding = UTF_8;</span>
<span class="fc bfc" id="L476" title="All 4 branches covered.">        } else if (bomEnc.equals(UTF_16BE) || bomEnc.equals(UTF_16LE)) {</span>
<span class="fc bfc" id="L477" title="All 4 branches covered.">            if (xmlGuessEnc != null &amp;&amp; !xmlGuessEnc.equals(bomEnc)) {</span>
<span class="fc" id="L478">                throw new XmlStreamReaderException(RAW_EX_1.format(new Object[] { bomEnc,</span>
                        xmlGuessEnc, xmlEnc }), bomEnc, xmlGuessEnc, xmlEnc, is);
            }
<span class="fc bfc" id="L481" title="All 4 branches covered.">            if (xmlEnc != null &amp;&amp; !xmlEnc.equals(UTF_16)</span>
<span class="fc bfc" id="L482" title="All 2 branches covered.">                    &amp;&amp; !xmlEnc.equals(bomEnc)) {</span>
<span class="fc" id="L483">                throw new XmlStreamReaderException(RAW_EX_1</span>
<span class="fc" id="L484">                        .format(new Object[] { bomEnc, xmlGuessEnc, xmlEnc }),</span>
                        bomEnc, xmlGuessEnc, xmlEnc, is);
            }
<span class="fc" id="L487">            encoding = bomEnc;</span>
<span class="fc bfc" id="L488" title="All 4 branches covered.">        } else if (bomEnc.equals(UTF_32BE) || bomEnc.equals(UTF_32LE)) {</span>
<span class="fc bfc" id="L489" title="All 4 branches covered.">            if (xmlGuessEnc != null &amp;&amp; !xmlGuessEnc.equals(bomEnc)) {</span>
<span class="fc" id="L490">                throw new XmlStreamReaderException(RAW_EX_1.format(new Object[] { bomEnc,</span>
                        xmlGuessEnc, xmlEnc }), bomEnc, xmlGuessEnc, xmlEnc, is);
            }
<span class="fc bfc" id="L493" title="All 4 branches covered.">            if (xmlEnc != null &amp;&amp; !xmlEnc.equals(UTF_32)</span>
<span class="fc bfc" id="L494" title="All 2 branches covered.">                    &amp;&amp; !xmlEnc.equals(bomEnc)) {</span>
<span class="fc" id="L495">                throw new XmlStreamReaderException(RAW_EX_1</span>
<span class="fc" id="L496">                        .format(new Object[] { bomEnc, xmlGuessEnc, xmlEnc }),</span>
                        bomEnc, xmlGuessEnc, xmlEnc, is);
            }
<span class="fc" id="L499">            encoding = bomEnc;</span>
        } else {
<span class="fc" id="L501">            throw new XmlStreamReaderException(RAW_EX_2.format(new Object[] {</span>
                    bomEnc, xmlGuessEnc, xmlEnc }), bomEnc, xmlGuessEnc,
                    xmlEnc, is);
        }
<span class="fc" id="L505">        return encoding;</span>
    }

    // InputStream is passed for XmlStreamReaderException creation only
    String calculateHttpEncoding(final String cTMime, final String cTEnc,
            final String bomEnc, final String xmlGuessEnc, final String xmlEnc, final InputStream is,
            final boolean lenient) throws IOException {
        String encoding;
<span class="fc bfc" id="L513" title="All 4 branches covered.">        if (lenient &amp; xmlEnc != null) {</span>
<span class="fc" id="L514">            encoding = xmlEnc;</span>
        } else {
<span class="fc" id="L516">            final boolean appXml = isAppXml(cTMime);</span>
<span class="fc" id="L517">            final boolean textXml = isTextXml(cTMime);</span>
<span class="fc bfc" id="L518" title="All 4 branches covered.">            if (appXml || textXml) {</span>
<span class="fc bfc" id="L519" title="All 2 branches covered.">                if (cTEnc == null) {</span>
<span class="fc bfc" id="L520" title="All 2 branches covered.">                    if (appXml) {</span>
<span class="fc" id="L521">                        encoding = calculateRawEncoding(bomEnc, xmlGuessEnc,</span>
                                xmlEnc, is);
                    } else {
<span class="fc bfc" id="L524" title="All 2 branches covered.">                        encoding = defaultEncoding == null ? US_ASCII</span>
<span class="fc" id="L525">                                : defaultEncoding;</span>
                    }
<span class="fc bfc" id="L527" title="All 2 branches covered.">                } else if (bomEnc != null</span>
<span class="fc bfc" id="L528" title="All 4 branches covered.">                        &amp;&amp; (cTEnc.equals(UTF_16BE) || cTEnc.equals(UTF_16LE))) {</span>
<span class="fc" id="L529">                    throw new XmlStreamReaderException(HTTP_EX_1</span>
<span class="fc" id="L530">                            .format(new Object[] { cTMime, cTEnc, bomEnc,</span>
                                    xmlGuessEnc, xmlEnc }), cTMime, cTEnc,
                            bomEnc, xmlGuessEnc, xmlEnc, is);
<span class="fc bfc" id="L533" title="All 2 branches covered.">                } else if (cTEnc.equals(UTF_16)) {</span>
<span class="fc bfc" id="L534" title="All 4 branches covered.">                    if (bomEnc != null &amp;&amp; bomEnc.startsWith(UTF_16)) {</span>
<span class="fc" id="L535">                        encoding = bomEnc;</span>
                    } else {
<span class="fc" id="L537">                        throw new XmlStreamReaderException(HTTP_EX_2</span>
<span class="fc" id="L538">                                .format(new Object[] { cTMime, cTEnc, bomEnc,</span>
                                        xmlGuessEnc, xmlEnc }), cTMime, cTEnc,
                                bomEnc, xmlGuessEnc, xmlEnc, is);
                    }
<span class="fc bfc" id="L542" title="All 2 branches covered.">                } else if (bomEnc != null</span>
<span class="fc bfc" id="L543" title="All 4 branches covered.">                        &amp;&amp; (cTEnc.equals(UTF_32BE) || cTEnc.equals(UTF_32LE))) {</span>
<span class="fc" id="L544">                    throw new XmlStreamReaderException(HTTP_EX_1</span>
<span class="fc" id="L545">                            .format(new Object[] { cTMime, cTEnc, bomEnc,</span>
                                    xmlGuessEnc, xmlEnc }), cTMime, cTEnc,
                            bomEnc, xmlGuessEnc, xmlEnc, is);
<span class="fc bfc" id="L548" title="All 2 branches covered.">                } else if (cTEnc.equals(UTF_32)) {</span>
<span class="fc bfc" id="L549" title="All 4 branches covered.">                    if (bomEnc != null &amp;&amp; bomEnc.startsWith(UTF_32)) {</span>
<span class="fc" id="L550">                        encoding = bomEnc;</span>
                    } else {
<span class="fc" id="L552">                        throw new XmlStreamReaderException(HTTP_EX_2</span>
<span class="fc" id="L553">                                .format(new Object[] { cTMime, cTEnc, bomEnc,</span>
                                        xmlGuessEnc, xmlEnc }), cTMime, cTEnc,
                                bomEnc, xmlGuessEnc, xmlEnc, is);
                    }
                } else {
<span class="fc" id="L558">                    encoding = cTEnc;</span>
                }
            } else {
<span class="fc" id="L561">                throw new XmlStreamReaderException(HTTP_EX_3</span>
<span class="fc" id="L562">                        .format(new Object[] { cTMime, cTEnc, bomEnc,</span>
                                xmlGuessEnc, xmlEnc }), cTMime, cTEnc, bomEnc,
                        xmlGuessEnc, xmlEnc, is);
            }
        }
<span class="fc" id="L567">        return encoding;</span>
    }

    // returns MIME type or NULL if httpContentType is NULL
    static String getContentTypeMime(final String httpContentType) {
<span class="fc" id="L572">        String mime = null;</span>
<span class="fc bfc" id="L573" title="All 2 branches covered.">        if (httpContentType != null) {</span>
<span class="fc" id="L574">            final int i = httpContentType.indexOf(&quot;;&quot;);</span>
<span class="fc bfc" id="L575" title="All 2 branches covered.">            mime = (i == -1 ? httpContentType : httpContentType.substring(0,</span>
<span class="fc" id="L576">                    i)).trim();</span>
        }
<span class="fc" id="L578">        return mime;</span>
    }

<span class="fc" id="L581">    private static final Pattern CHARSET_PATTERN = Pattern</span>
<span class="fc" id="L582">            .compile(&quot;charset=[\&quot;']?([.[^; \&quot;']]*)[\&quot;']?&quot;);</span>

    // returns charset parameter value, NULL if not present, NULL if
    // httpContentType is NULL
    static String getContentTypeEncoding(final String httpContentType) {
<span class="fc" id="L587">        String encoding = null;</span>
<span class="fc bfc" id="L588" title="All 2 branches covered.">        if (httpContentType != null) {</span>
<span class="fc" id="L589">            final int i = httpContentType.indexOf(&quot;;&quot;);</span>
<span class="fc bfc" id="L590" title="All 2 branches covered.">            if (i &gt; -1) {</span>
<span class="fc" id="L591">                final String postMime = httpContentType.substring(i + 1);</span>
<span class="fc" id="L592">                final Matcher m = CHARSET_PATTERN.matcher(postMime);</span>
<span class="pc bpc" id="L593" title="1 of 2 branches missed.">                encoding = m.find() ? m.group(1) : null;</span>
<span class="pc bpc" id="L594" title="1 of 2 branches missed.">                encoding = encoding != null ? encoding.toUpperCase() : null;</span>
            }
        }
<span class="fc" id="L597">        return encoding;</span>
    }

    // returns the BOM in the stream, NULL if not present,
    // if there was BOM the in the stream it is consumed
    static String getBOMEncoding(final BufferedInputStream is)
            throws IOException {
<span class="fc" id="L604">        String encoding = null;</span>
<span class="fc" id="L605">        final int[] bytes = new int[3];</span>
<span class="fc" id="L606">        is.mark(3);</span>
<span class="fc" id="L607">        bytes[0] = is.read();</span>
<span class="fc" id="L608">        bytes[1] = is.read();</span>
<span class="fc" id="L609">        bytes[2] = is.read();</span>

<span class="pc bpc" id="L611" title="3 of 4 branches missed.">        if (bytes[0] == 0xFE &amp;&amp; bytes[1] == 0xFF) {</span>
<span class="nc" id="L612">            encoding = UTF_16BE;</span>
<span class="nc" id="L613">            is.reset();</span>
<span class="nc" id="L614">            is.read();</span>
<span class="nc" id="L615">            is.read();</span>
<span class="pc bpc" id="L616" title="3 of 4 branches missed.">        } else if (bytes[0] == 0xFF &amp;&amp; bytes[1] == 0xFE) {</span>
<span class="nc" id="L617">            encoding = UTF_16LE;</span>
<span class="nc" id="L618">            is.reset();</span>
<span class="nc" id="L619">            is.read();</span>
<span class="nc" id="L620">            is.read();</span>
<span class="pc bpc" id="L621" title="5 of 6 branches missed.">        } else if (bytes[0] == 0xEF &amp;&amp; bytes[1] == 0xBB &amp;&amp; bytes[2] == 0xBF) {</span>
<span class="nc" id="L622">            encoding = UTF_8;</span>
        } else {
<span class="fc" id="L624">            is.reset();</span>
        }
<span class="fc" id="L626">        return encoding;</span>
    }

    // returns the best guess for the encoding by looking the first bytes of the
    // stream, '&lt;?'
    private static String getXMLGuessEncoding(final BufferedInputStream is)
            throws IOException {
<span class="fc" id="L633">        String encoding = null;</span>
<span class="fc" id="L634">        final int[] bytes = new int[4];</span>
<span class="fc" id="L635">        is.mark(4);</span>
<span class="fc" id="L636">        bytes[0] = is.read();</span>
<span class="fc" id="L637">        bytes[1] = is.read();</span>
<span class="fc" id="L638">        bytes[2] = is.read();</span>
<span class="fc" id="L639">        bytes[3] = is.read();</span>
<span class="fc" id="L640">        is.reset();</span>

<span class="pc bpc" id="L642" title="7 of 8 branches missed.">        if (bytes[0] == 0x00 &amp;&amp; bytes[1] == 0x3C &amp;&amp; bytes[2] == 0x00</span>
                &amp;&amp; bytes[3] == 0x3F) {
<span class="nc" id="L644">            encoding = UTF_16BE;</span>
<span class="pc bpc" id="L645" title="7 of 8 branches missed.">        } else if (bytes[0] == 0x3C &amp;&amp; bytes[1] == 0x00 &amp;&amp; bytes[2] == 0x3F</span>
                &amp;&amp; bytes[3] == 0x00) {
<span class="nc" id="L647">            encoding = UTF_16LE;</span>
<span class="pc bpc" id="L648" title="7 of 8 branches missed.">        } else if (bytes[0] == 0x3C &amp;&amp; bytes[1] == 0x3F &amp;&amp; bytes[2] == 0x78</span>
                &amp;&amp; bytes[3] == 0x6D) {
<span class="nc" id="L650">            encoding = UTF_8;</span>
<span class="pc bpc" id="L651" title="7 of 8 branches missed.">        } else if (bytes[0] == 0x4C &amp;&amp; bytes[1] == 0x6F &amp;&amp; bytes[2] == 0xA7</span>
                &amp;&amp; bytes[3] == 0x94) {
<span class="nc" id="L653">            encoding = EBCDIC;</span>
        }
<span class="fc" id="L655">        return encoding;</span>
    }

<span class="fc" id="L658">    public static final Pattern ENCODING_PATTERN = Pattern.compile(</span>
            &quot;&lt;\\?xml.*encoding[\\s]*=[\\s]*((?:\&quot;.[^\&quot;]*\&quot;)|(?:'.[^']*'))&quot;,
            Pattern.MULTILINE);

    // returns the encoding declared in the &lt;?xml encoding=...?&gt;, NULL if none
    private static String getXmlProlog(final BufferedInputStream is, final String guessedEnc)
            throws IOException {
<span class="fc" id="L665">        String encoding = null;</span>
<span class="pc bpc" id="L666" title="1 of 2 branches missed.">        if (guessedEnc != null) {</span>
<span class="nc" id="L667">            final byte[] bytes = new byte[BUFFER_SIZE];</span>
<span class="nc" id="L668">            is.mark(BUFFER_SIZE);</span>
<span class="nc" id="L669">            int offset = 0;</span>
<span class="nc" id="L670">            int max = BUFFER_SIZE;</span>
<span class="nc" id="L671">            int c = is.read(bytes, offset, max);</span>
<span class="nc" id="L672">            int firstGT = -1;</span>
<span class="nc" id="L673">            String xmlProlog = &quot;&quot;; // avoid possible NPE warning (cannot happen; this just silences the warning)</span>
<span class="nc bnc" id="L674" title="All 6 branches missed.">            while (c != -1 &amp;&amp; firstGT == -1 &amp;&amp; offset &lt; BUFFER_SIZE) {</span>
<span class="nc" id="L675">                offset += c;</span>
<span class="nc" id="L676">                max -= c;</span>
<span class="nc" id="L677">                c = is.read(bytes, offset, max);</span>
<span class="nc" id="L678">                xmlProlog = new String(bytes, 0, offset, guessedEnc);</span>
<span class="nc" id="L679">                firstGT = xmlProlog.indexOf('&gt;');</span>
            }
<span class="nc bnc" id="L681" title="All 2 branches missed.">            if (firstGT == -1) {</span>
<span class="nc bnc" id="L682" title="All 2 branches missed.">                if (c == -1) {</span>
<span class="nc" id="L683">                    throw new IOException(&quot;Unexpected end of XML stream&quot;);</span>
                } else {
<span class="nc" id="L685">                    throw new IOException(</span>
                            &quot;XML prolog or ROOT element not found on first &quot;
                                    + offset + &quot; bytes&quot;);
                }
            }
<span class="nc" id="L690">            final int bytesRead = offset;</span>
<span class="nc bnc" id="L691" title="All 2 branches missed.">            if (bytesRead &gt; 0) {</span>
<span class="nc" id="L692">                is.reset();</span>
<span class="nc" id="L693">                final BufferedReader bReader = new BufferedReader(new StringReader(</span>
<span class="nc" id="L694">                        xmlProlog.substring(0, firstGT + 1)));</span>
<span class="nc" id="L695">                final StringBuffer prolog = new StringBuffer();</span>
<span class="nc" id="L696">                String line = bReader.readLine();</span>
<span class="nc bnc" id="L697" title="All 2 branches missed.">                while (line != null) {</span>
<span class="nc" id="L698">                    prolog.append(line);</span>
<span class="nc" id="L699">                    line = bReader.readLine();</span>
                }
<span class="nc" id="L701">                final Matcher m = ENCODING_PATTERN.matcher(prolog);</span>
<span class="nc bnc" id="L702" title="All 2 branches missed.">                if (m.find()) {</span>
<span class="nc" id="L703">                    encoding = m.group(1).toUpperCase();</span>
<span class="nc" id="L704">                    encoding = encoding.substring(1, encoding.length() - 1);</span>
                }
            }
        }
<span class="fc" id="L708">        return encoding;</span>
    }

    // indicates if the MIME type belongs to the APPLICATION XML family
    static boolean isAppXml(final String mime) {
<span class="fc bfc" id="L713" title="All 2 branches covered.">        return mime != null</span>
<span class="fc bfc" id="L714" title="All 2 branches covered.">                &amp;&amp; (mime.equals(&quot;application/xml&quot;)</span>
<span class="pc bpc" id="L715" title="1 of 2 branches missed.">                        || mime.equals(&quot;application/xml-dtd&quot;)</span>
                        || mime
<span class="pc bpc" id="L717" title="1 of 2 branches missed.">                                .equals(&quot;application/xml-external-parsed-entity&quot;) || mime</span>
<span class="pc bpc" id="L718" title="3 of 4 branches missed.">                        .startsWith(&quot;application/&quot;) &amp;&amp; mime.endsWith(&quot;+xml&quot;));</span>
    }

    // indicates if the MIME type belongs to the TEXT XML family
    static boolean isTextXml(final String mime) {
<span class="fc bfc" id="L723" title="All 2 branches covered.">        return mime != null</span>
<span class="fc bfc" id="L724" title="All 2 branches covered.">                &amp;&amp; (mime.equals(&quot;text/xml&quot;)</span>
<span class="pc bpc" id="L725" title="1 of 2 branches missed.">                        || mime.equals(&quot;text/xml-external-parsed-entity&quot;) || mime</span>
<span class="pc bpc" id="L726" title="1 of 4 branches missed.">                        .startsWith(&quot;text/&quot;) &amp;&amp; mime.endsWith(&quot;+xml&quot;));</span>
    }

<span class="fc" id="L729">    private static final MessageFormat RAW_EX_1 = new MessageFormat(</span>
            &quot;Invalid encoding, BOM [{0}] XML guess [{1}] XML prolog [{2}] encoding mismatch&quot;);

<span class="fc" id="L732">    private static final MessageFormat RAW_EX_2 = new MessageFormat(</span>
            &quot;Invalid encoding, BOM [{0}] XML guess [{1}] XML prolog [{2}] unknown BOM&quot;);

<span class="fc" id="L735">    private static final MessageFormat HTTP_EX_1 = new MessageFormat(</span>
            &quot;Invalid encoding, CT-MIME [{0}] CT-Enc [{1}] BOM [{2}] XML guess [{3}] XML prolog [{4}], BOM must be NULL&quot;);

<span class="fc" id="L738">    private static final MessageFormat HTTP_EX_2 = new MessageFormat(</span>
            &quot;Invalid encoding, CT-MIME [{0}] CT-Enc [{1}] BOM [{2}] XML guess [{3}] XML prolog [{4}], encoding mismatch&quot;);

<span class="fc" id="L741">    private static final MessageFormat HTTP_EX_3 = new MessageFormat(</span>
            &quot;Invalid encoding, CT-MIME [{0}] CT-Enc [{1}] BOM [{2}] XML guess [{3}] XML prolog [{4}], Invalid MIME&quot;);

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>