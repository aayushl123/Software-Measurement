


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: PolyhedronsSet</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">org.apache.commons.math4.geometry.euclidean.threed</a> ]
</div>

<h1>Coverage Summary for Class: PolyhedronsSet (org.apache.commons.math4.geometry.euclidean.threed)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">PolyhedronsSet</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (16/ 16)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    98.6%
  </span>
  <span class="absValue">
    (146/ 148)
  </span>
</td>
</tr>
  <tr>
    <td class="name">PolyhedronsSet$FacetsContributionVisitor</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/ 7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (26/ 26)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">PolyhedronsSet$RotationTransform</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (25/ 25)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">PolyhedronsSet$TranslationTransform</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (15/ 15)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>total</strong></td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (31/ 31)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    99.1%
  </span>
  <span class="absValue">
    (212/ 214)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;/*
<i>2</i>&nbsp; * Licensed to the Apache Software Foundation (ASF) under one or more
<i>3</i>&nbsp; * contributor license agreements.  See the NOTICE file distributed with
<i>4</i>&nbsp; * this work for additional information regarding copyright ownership.
<i>5</i>&nbsp; * The ASF licenses this file to You under the Apache License, Version 2.0
<i>6</i>&nbsp; * (the &quot;License&quot;); you may not use this file except in compliance with
<i>7</i>&nbsp; * the License.  You may obtain a copy of the License at
<i>8</i>&nbsp; *
<i>9</i>&nbsp; *      http://www.apache.org/licenses/LICENSE-2.0
<i>10</i>&nbsp; *
<i>11</i>&nbsp; * Unless required by applicable law or agreed to in writing, software
<i>12</i>&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
<i>13</i>&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
<i>14</i>&nbsp; * See the License for the specific language governing permissions and
<i>15</i>&nbsp; * limitations under the License.
<i>16</i>&nbsp; */
<i>17</i>&nbsp;package org.apache.commons.math4.geometry.euclidean.threed;
<i>18</i>&nbsp;
<i>19</i>&nbsp;import java.util.ArrayList;
<i>20</i>&nbsp;import java.util.Arrays;
<i>21</i>&nbsp;import java.util.Collection;
<i>22</i>&nbsp;import java.util.List;
<i>23</i>&nbsp;
<i>24</i>&nbsp;import org.apache.commons.math4.exception.MathIllegalArgumentException;
<i>25</i>&nbsp;import org.apache.commons.math4.exception.NumberIsTooSmallException;
<i>26</i>&nbsp;import org.apache.commons.math4.exception.util.LocalizedFormats;
<i>27</i>&nbsp;import org.apache.commons.math4.geometry.Point;
<i>28</i>&nbsp;import org.apache.commons.math4.geometry.euclidean.oned.Euclidean1D;
<i>29</i>&nbsp;import org.apache.commons.math4.geometry.euclidean.twod.Euclidean2D;
<i>30</i>&nbsp;import org.apache.commons.math4.geometry.euclidean.twod.PolygonsSet;
<i>31</i>&nbsp;import org.apache.commons.math4.geometry.euclidean.twod.SubLine;
<i>32</i>&nbsp;import org.apache.commons.math4.geometry.euclidean.twod.Cartesian2D;
<i>33</i>&nbsp;import org.apache.commons.math4.geometry.partitioning.AbstractRegion;
<i>34</i>&nbsp;import org.apache.commons.math4.geometry.partitioning.BSPTree;
<i>35</i>&nbsp;import org.apache.commons.math4.geometry.partitioning.BSPTreeVisitor;
<i>36</i>&nbsp;import org.apache.commons.math4.geometry.partitioning.BoundaryAttribute;
<i>37</i>&nbsp;import org.apache.commons.math4.geometry.partitioning.Hyperplane;
<i>38</i>&nbsp;import org.apache.commons.math4.geometry.partitioning.Region;
<i>39</i>&nbsp;import org.apache.commons.math4.geometry.partitioning.RegionFactory;
<i>40</i>&nbsp;import org.apache.commons.math4.geometry.partitioning.SubHyperplane;
<i>41</i>&nbsp;import org.apache.commons.math4.geometry.partitioning.Transform;
<i>42</i>&nbsp;import org.apache.commons.math4.util.FastMath;
<i>43</i>&nbsp;
<i>44</i>&nbsp;/** This class represents a 3D region: a set of polyhedrons.
<i>45</i>&nbsp; * @since 3.0
<i>46</i>&nbsp; */
<i>47</i>&nbsp;public class PolyhedronsSet extends AbstractRegion&lt;Euclidean3D, Euclidean2D&gt; {
<i>48</i>&nbsp;
<i>49</i>&nbsp;    /** Build a polyhedrons set representing the whole real line.
<i>50</i>&nbsp;     * @param tolerance tolerance below which points are considered identical
<i>51</i>&nbsp;     * @since 3.3
<i>52</i>&nbsp;     */
<i>53</i>&nbsp;    public PolyhedronsSet(final double tolerance) {
<b class="fc"><i>54</i>&nbsp;        super(tolerance);</b>
<b class="fc"><i>55</i>&nbsp;    }</b>
<i>56</i>&nbsp;
<i>57</i>&nbsp;    /** Build a polyhedrons set from a BSP tree.
<i>58</i>&nbsp;     * &lt;p&gt;The leaf nodes of the BSP tree &lt;em&gt;must&lt;/em&gt; have a
<i>59</i>&nbsp;     * {@code Boolean} attribute representing the inside status of
<i>60</i>&nbsp;     * the corresponding cell (true for inside cells, false for outside
<i>61</i>&nbsp;     * cells). In order to avoid building too many small objects, it is
<i>62</i>&nbsp;     * recommended to use the predefined constants
<i>63</i>&nbsp;     * {@code Boolean.TRUE} and {@code Boolean.FALSE}&lt;/p&gt;
<i>64</i>&nbsp;     * &lt;p&gt;
<i>65</i>&nbsp;     * This constructor is aimed at expert use, as building the tree may
<i>66</i>&nbsp;     * be a difficult task. It is not intended for general use and for
<i>67</i>&nbsp;     * performances reasons does not check thoroughly its input, as this would
<i>68</i>&nbsp;     * require walking the full tree each time. Failing to provide a tree with
<i>69</i>&nbsp;     * the proper attributes, &lt;em&gt;will&lt;/em&gt; therefore generate problems like
<i>70</i>&nbsp;     * {@link NullPointerException} or {@link ClassCastException} only later on.
<i>71</i>&nbsp;     * This limitation is known and explains why this constructor is for expert
<i>72</i>&nbsp;     * use only. The caller does have the responsibility to provided correct arguments.
<i>73</i>&nbsp;     * &lt;/p&gt;
<i>74</i>&nbsp;     * @param tree inside/outside BSP tree representing the region
<i>75</i>&nbsp;     * @param tolerance tolerance below which points are considered identical
<i>76</i>&nbsp;     * @since 3.3
<i>77</i>&nbsp;     */
<i>78</i>&nbsp;    public PolyhedronsSet(final BSPTree&lt;Euclidean3D&gt; tree, final double tolerance) {
<b class="fc"><i>79</i>&nbsp;        super(tree, tolerance);</b>
<b class="fc"><i>80</i>&nbsp;    }</b>
<i>81</i>&nbsp;
<i>82</i>&nbsp;    /** Build a polyhedrons set from a Boundary REPresentation (B-rep) specified by sub-hyperplanes.
<i>83</i>&nbsp;     * &lt;p&gt;The boundary is provided as a collection of {@link
<i>84</i>&nbsp;     * SubHyperplane sub-hyperplanes}. Each sub-hyperplane has the
<i>85</i>&nbsp;     * interior part of the region on its minus side and the exterior on
<i>86</i>&nbsp;     * its plus side.&lt;/p&gt;
<i>87</i>&nbsp;     * &lt;p&gt;The boundary elements can be in any order, and can form
<i>88</i>&nbsp;     * several non-connected sets (like for example polyhedrons with holes
<i>89</i>&nbsp;     * or a set of disjoint polyhedrons considered as a whole). In
<i>90</i>&nbsp;     * fact, the elements do not even need to be connected together
<i>91</i>&nbsp;     * (their topological connections are not used here). However, if the
<i>92</i>&nbsp;     * boundary does not really separate an inside open from an outside
<i>93</i>&nbsp;     * open (open having here its topological meaning), then subsequent
<i>94</i>&nbsp;     * calls to the {@link Region#checkPoint(Point) checkPoint} method will
<i>95</i>&nbsp;     * not be meaningful anymore.&lt;/p&gt;
<i>96</i>&nbsp;     * &lt;p&gt;If the boundary is empty, the region will represent the whole
<i>97</i>&nbsp;     * space.&lt;/p&gt;
<i>98</i>&nbsp;     * @param boundary collection of boundary elements, as a
<i>99</i>&nbsp;     * collection of {@link SubHyperplane SubHyperplane} objects
<i>100</i>&nbsp;     * @param tolerance tolerance below which points are considered identical
<i>101</i>&nbsp;     * @since 3.3
<i>102</i>&nbsp;     */
<i>103</i>&nbsp;    public PolyhedronsSet(final Collection&lt;SubHyperplane&lt;Euclidean3D&gt;&gt; boundary,
<i>104</i>&nbsp;                          final double tolerance) {
<b class="fc"><i>105</i>&nbsp;        super(boundary, tolerance);</b>
<b class="fc"><i>106</i>&nbsp;    }</b>
<i>107</i>&nbsp;
<i>108</i>&nbsp;    /** Build a polyhedrons set from a Boundary REPresentation (B-rep) specified by connected vertices.
<i>109</i>&nbsp;     * &lt;p&gt;
<i>110</i>&nbsp;     * The boundary is provided as a list of vertices and a list of facets.
<i>111</i>&nbsp;     * Each facet is specified as an integer array containing the arrays vertices
<i>112</i>&nbsp;     * indices in the vertices list. Each facet normal is oriented by right hand
<i>113</i>&nbsp;     * rule to the facet vertices list.
<i>114</i>&nbsp;     * &lt;/p&gt;
<i>115</i>&nbsp;     * &lt;p&gt;
<i>116</i>&nbsp;     * Some basic sanity checks are performed but not everything is thoroughly
<i>117</i>&nbsp;     * assessed, so it remains under caller responsibility to ensure the vertices
<i>118</i>&nbsp;     * and facets are consistent and properly define a polyhedrons set.
<i>119</i>&nbsp;     * &lt;/p&gt;
<i>120</i>&nbsp;     * @param vertices list of polyhedrons set vertices
<i>121</i>&nbsp;     * @param facets list of facets, as vertices indices in the vertices list
<i>122</i>&nbsp;     * @param tolerance tolerance below which points are considered identical
<i>123</i>&nbsp;     * @exception MathIllegalArgumentException if some basic sanity checks fail
<i>124</i>&nbsp;     * @since 3.5
<i>125</i>&nbsp;     */
<i>126</i>&nbsp;    public PolyhedronsSet(final List&lt;Cartesian3D&gt; vertices, final List&lt;int[]&gt; facets,
<i>127</i>&nbsp;                          final double tolerance) {
<b class="fc"><i>128</i>&nbsp;        super(buildBoundary(vertices, facets, tolerance), tolerance);</b>
<b class="fc"><i>129</i>&nbsp;    }</b>
<i>130</i>&nbsp;
<i>131</i>&nbsp;    /** Build a parallellepipedic box.
<i>132</i>&nbsp;     * @param xMin low bound along the x direction
<i>133</i>&nbsp;     * @param xMax high bound along the x direction
<i>134</i>&nbsp;     * @param yMin low bound along the y direction
<i>135</i>&nbsp;     * @param yMax high bound along the y direction
<i>136</i>&nbsp;     * @param zMin low bound along the z direction
<i>137</i>&nbsp;     * @param zMax high bound along the z direction
<i>138</i>&nbsp;     * @param tolerance tolerance below which points are considered identical
<i>139</i>&nbsp;     * @since 3.3
<i>140</i>&nbsp;     */
<i>141</i>&nbsp;    public PolyhedronsSet(final double xMin, final double xMax,
<i>142</i>&nbsp;                          final double yMin, final double yMax,
<i>143</i>&nbsp;                          final double zMin, final double zMax,
<i>144</i>&nbsp;                          final double tolerance) {
<b class="fc"><i>145</i>&nbsp;        super(buildBoundary(xMin, xMax, yMin, yMax, zMin, zMax, tolerance), tolerance);</b>
<b class="fc"><i>146</i>&nbsp;    }</b>
<i>147</i>&nbsp;
<i>148</i>&nbsp;    /** Build a parallellepipedic box boundary.
<i>149</i>&nbsp;     * @param xMin low bound along the x direction
<i>150</i>&nbsp;     * @param xMax high bound along the x direction
<i>151</i>&nbsp;     * @param yMin low bound along the y direction
<i>152</i>&nbsp;     * @param yMax high bound along the y direction
<i>153</i>&nbsp;     * @param zMin low bound along the z direction
<i>154</i>&nbsp;     * @param zMax high bound along the z direction
<i>155</i>&nbsp;     * @param tolerance tolerance below which points are considered identical
<i>156</i>&nbsp;     * @return boundary tree
<i>157</i>&nbsp;     * @since 3.3
<i>158</i>&nbsp;     */
<i>159</i>&nbsp;    private static BSPTree&lt;Euclidean3D&gt; buildBoundary(final double xMin, final double xMax,
<i>160</i>&nbsp;                                                      final double yMin, final double yMax,
<i>161</i>&nbsp;                                                      final double zMin, final double zMax,
<i>162</i>&nbsp;                                                      final double tolerance) {
<b class="fc"><i>163</i>&nbsp;        if ((xMin &gt;= xMax - tolerance) || (yMin &gt;= yMax - tolerance) || (zMin &gt;= zMax - tolerance)) {</b>
<i>164</i>&nbsp;            // too thin box, build an empty polygons set
<b class="fc"><i>165</i>&nbsp;            return new BSPTree&lt;&gt;(Boolean.FALSE);</b>
<i>166</i>&nbsp;        }
<b class="fc"><i>167</i>&nbsp;        final Plane pxMin = new Plane(new Cartesian3D(xMin, 0,    0),   Cartesian3D.MINUS_I, tolerance);</b>
<b class="fc"><i>168</i>&nbsp;        final Plane pxMax = new Plane(new Cartesian3D(xMax, 0,    0),   Cartesian3D.PLUS_I,  tolerance);</b>
<b class="fc"><i>169</i>&nbsp;        final Plane pyMin = new Plane(new Cartesian3D(0,    yMin, 0),   Cartesian3D.MINUS_J, tolerance);</b>
<b class="fc"><i>170</i>&nbsp;        final Plane pyMax = new Plane(new Cartesian3D(0,    yMax, 0),   Cartesian3D.PLUS_J,  tolerance);</b>
<b class="fc"><i>171</i>&nbsp;        final Plane pzMin = new Plane(new Cartesian3D(0,    0,   zMin), Cartesian3D.MINUS_K, tolerance);</b>
<b class="fc"><i>172</i>&nbsp;        final Plane pzMax = new Plane(new Cartesian3D(0,    0,   zMax), Cartesian3D.PLUS_K,  tolerance);</b>
<b class="fc"><i>173</i>&nbsp;        final Region&lt;Euclidean3D&gt; boundary =</b>
<b class="fc"><i>174</i>&nbsp;        new RegionFactory&lt;Euclidean3D&gt;().buildConvex(pxMin, pxMax, pyMin, pyMax, pzMin, pzMax);</b>
<b class="fc"><i>175</i>&nbsp;        return boundary.getTree(false);</b>
<i>176</i>&nbsp;    }
<i>177</i>&nbsp;
<i>178</i>&nbsp;    /** Build boundary from vertices and facets.
<i>179</i>&nbsp;     * @param vertices list of polyhedrons set vertices
<i>180</i>&nbsp;     * @param facets list of facets, as vertices indices in the vertices list
<i>181</i>&nbsp;     * @param tolerance tolerance below which points are considered identical
<i>182</i>&nbsp;     * @return boundary as a list of sub-hyperplanes
<i>183</i>&nbsp;     * @exception MathIllegalArgumentException if some basic sanity checks fail
<i>184</i>&nbsp;     * @since 3.5
<i>185</i>&nbsp;     */
<i>186</i>&nbsp;    private static List&lt;SubHyperplane&lt;Euclidean3D&gt;&gt; buildBoundary(final List&lt;Cartesian3D&gt; vertices,
<i>187</i>&nbsp;                                                                  final List&lt;int[]&gt; facets,
<i>188</i>&nbsp;                                                                  final double tolerance) {
<i>189</i>&nbsp;
<i>190</i>&nbsp;        // check vertices distances
<b class="fc"><i>191</i>&nbsp;        for (int i = 0; i &lt; vertices.size() - 1; ++i) {</b>
<b class="fc"><i>192</i>&nbsp;            final Cartesian3D vi = vertices.get(i);</b>
<b class="fc"><i>193</i>&nbsp;            for (int j = i + 1; j &lt; vertices.size(); ++j) {</b>
<b class="fc"><i>194</i>&nbsp;                if (Cartesian3D.distance(vi, vertices.get(j)) &lt;= tolerance) {</b>
<b class="fc"><i>195</i>&nbsp;                    throw new MathIllegalArgumentException(LocalizedFormats.CLOSE_VERTICES,</b>
<b class="fc"><i>196</i>&nbsp;                                                           vi.getX(), vi.getY(), vi.getZ());</b>
<i>197</i>&nbsp;                }
<i>198</i>&nbsp;            }
<i>199</i>&nbsp;        }
<i>200</i>&nbsp;
<i>201</i>&nbsp;        // find how vertices are referenced by facets
<b class="fc"><i>202</i>&nbsp;        final int[][] references = findReferences(vertices, facets);</b>
<i>203</i>&nbsp;
<i>204</i>&nbsp;        // find how vertices are linked together by edges along the facets they belong to
<b class="fc"><i>205</i>&nbsp;        final int[][] successors = successors(vertices, facets, references);</b>
<i>206</i>&nbsp;
<i>207</i>&nbsp;        // check edges orientations
<b class="fc"><i>208</i>&nbsp;        for (int vA = 0; vA &lt; vertices.size(); ++vA) {</b>
<b class="fc"><i>209</i>&nbsp;            for (final int vB : successors[vA]) {</b>
<i>210</i>&nbsp;
<b class="fc"><i>211</i>&nbsp;                if (vB &gt;= 0) {</b>
<i>212</i>&nbsp;                    // when facets are properly oriented, if vB is the successor of vA on facet f1,
<i>213</i>&nbsp;                    // then there must be an adjacent facet f2 where vA is the successor of vB
<b class="fc"><i>214</i>&nbsp;                    boolean found = false;</b>
<b class="fc"><i>215</i>&nbsp;                    for (final int v : successors[vB]) {</b>
<b class="fc"><i>216</i>&nbsp;                        found = found || (v == vA);</b>
<i>217</i>&nbsp;                    }
<b class="fc"><i>218</i>&nbsp;                    if (!found) {</b>
<b class="fc"><i>219</i>&nbsp;                        final Cartesian3D start = vertices.get(vA);</b>
<b class="fc"><i>220</i>&nbsp;                        final Cartesian3D end   = vertices.get(vB);</b>
<b class="fc"><i>221</i>&nbsp;                        throw new MathIllegalArgumentException(LocalizedFormats.EDGE_CONNECTED_TO_ONE_FACET,</b>
<b class="fc"><i>222</i>&nbsp;                                                               start.getX(), start.getY(), start.getZ(),</b>
<b class="fc"><i>223</i>&nbsp;                                                               end.getX(),   end.getY(),   end.getZ());</b>
<i>224</i>&nbsp;                    }
<i>225</i>&nbsp;                }
<i>226</i>&nbsp;            }
<i>227</i>&nbsp;        }
<i>228</i>&nbsp;
<b class="fc"><i>229</i>&nbsp;        final List&lt;SubHyperplane&lt;Euclidean3D&gt;&gt; boundary = new ArrayList&lt;&gt;();</b>
<i>230</i>&nbsp;
<b class="fc"><i>231</i>&nbsp;        for (final int[] facet : facets) {</b>
<i>232</i>&nbsp;
<i>233</i>&nbsp;            // define facet plane from the first 3 points
<b class="fc"><i>234</i>&nbsp;            Plane plane = new Plane(vertices.get(facet[0]), vertices.get(facet[1]), vertices.get(facet[2]),</b>
<i>235</i>&nbsp;                                    tolerance);
<i>236</i>&nbsp;
<i>237</i>&nbsp;            // check all points are in the plane
<b class="fc"><i>238</i>&nbsp;            final Cartesian2D[] two2Points = new Cartesian2D[facet.length];</b>
<b class="fc"><i>239</i>&nbsp;            for (int i = 0 ; i &lt; facet.length; ++i) {</b>
<b class="fc"><i>240</i>&nbsp;                final Cartesian3D v = vertices.get(facet[i]);</b>
<b class="fc"><i>241</i>&nbsp;                if (!plane.contains(v)) {</b>
<b class="fc"><i>242</i>&nbsp;                    throw new MathIllegalArgumentException(LocalizedFormats.OUT_OF_PLANE,</b>
<b class="fc"><i>243</i>&nbsp;                                                           v.getX(), v.getY(), v.getZ());</b>
<i>244</i>&nbsp;                }
<b class="fc"><i>245</i>&nbsp;                two2Points[i] = plane.toSubSpace(v);</b>
<i>246</i>&nbsp;            }
<i>247</i>&nbsp;
<i>248</i>&nbsp;            // create the polygonal facet
<b class="fc"><i>249</i>&nbsp;            boundary.add(new SubPlane(plane, new PolygonsSet(tolerance, two2Points)));</b>
<i>250</i>&nbsp;
<b class="fc"><i>251</i>&nbsp;        }</b>
<i>252</i>&nbsp;
<b class="fc"><i>253</i>&nbsp;        return boundary;</b>
<i>254</i>&nbsp;
<i>255</i>&nbsp;    }
<i>256</i>&nbsp;
<i>257</i>&nbsp;    /** Find the facets that reference each edges.
<i>258</i>&nbsp;     * @param vertices list of polyhedrons set vertices
<i>259</i>&nbsp;     * @param facets list of facets, as vertices indices in the vertices list
<i>260</i>&nbsp;     * @return references array such that r[v][k] = f for some k if facet f contains vertex v
<i>261</i>&nbsp;     * @exception MathIllegalArgumentException if some facets have fewer than 3 vertices
<i>262</i>&nbsp;     * @since 3.5
<i>263</i>&nbsp;     */
<i>264</i>&nbsp;    private static int[][] findReferences(final List&lt;Cartesian3D&gt; vertices, final List&lt;int[]&gt; facets) {
<i>265</i>&nbsp;
<i>266</i>&nbsp;        // find the maximum number of facets a vertex belongs to
<b class="fc"><i>267</i>&nbsp;        final int[] nbFacets = new int[vertices.size()];</b>
<b class="fc"><i>268</i>&nbsp;        int maxFacets  = 0;</b>
<b class="fc"><i>269</i>&nbsp;        for (final int[] facet : facets) {</b>
<b class="fc"><i>270</i>&nbsp;            if (facet.length &lt; 3) {</b>
<b class="fc"><i>271</i>&nbsp;                throw new NumberIsTooSmallException(LocalizedFormats.WRONG_NUMBER_OF_POINTS,</b>
<b class="fc"><i>272</i>&nbsp;                                                    3, facet.length, true);</b>
<i>273</i>&nbsp;            }
<b class="fc"><i>274</i>&nbsp;            for (final int index : facet) {</b>
<b class="fc"><i>275</i>&nbsp;                maxFacets = FastMath.max(maxFacets, ++nbFacets[index]);</b>
<i>276</i>&nbsp;            }
<b class="fc"><i>277</i>&nbsp;        }</b>
<i>278</i>&nbsp;
<i>279</i>&nbsp;        // set up the references array
<b class="fc"><i>280</i>&nbsp;        final int[][] references = new int[vertices.size()][maxFacets];</b>
<b class="fc"><i>281</i>&nbsp;        for (int[] r : references) {</b>
<b class="fc"><i>282</i>&nbsp;            Arrays.fill(r, -1);</b>
<i>283</i>&nbsp;        }
<b class="fc"><i>284</i>&nbsp;        for (int f = 0; f &lt; facets.size(); ++f) {</b>
<b class="fc"><i>285</i>&nbsp;            for (final int v : facets.get(f)) {</b>
<i>286</i>&nbsp;                // vertex v is referenced by facet f
<b class="fc"><i>287</i>&nbsp;                int k = 0;</b>
<b class="fc"><i>288</i>&nbsp;                while (k &lt; maxFacets &amp;&amp; references[v][k] &gt;= 0) {</b>
<b class="fc"><i>289</i>&nbsp;                    ++k;</b>
<i>290</i>&nbsp;                }
<b class="fc"><i>291</i>&nbsp;                references[v][k] = f;</b>
<i>292</i>&nbsp;            }
<i>293</i>&nbsp;        }
<i>294</i>&nbsp;
<b class="fc"><i>295</i>&nbsp;        return references;</b>
<i>296</i>&nbsp;
<i>297</i>&nbsp;    }
<i>298</i>&nbsp;
<i>299</i>&nbsp;    /** Find the successors of all vertices among all facets they belong to.
<i>300</i>&nbsp;     * @param vertices list of polyhedrons set vertices
<i>301</i>&nbsp;     * @param facets list of facets, as vertices indices in the vertices list
<i>302</i>&nbsp;     * @param references facets references array
<i>303</i>&nbsp;     * @return indices of vertices that follow vertex v in some facet (the array
<i>304</i>&nbsp;     * may contain extra entries at the end, set to negative indices)
<i>305</i>&nbsp;     * @exception MathIllegalArgumentException if the same vertex appears more than
<i>306</i>&nbsp;     * once in the successors list (which means one facet orientation is wrong)
<i>307</i>&nbsp;     * @since 3.5
<i>308</i>&nbsp;     */
<i>309</i>&nbsp;    private static int[][] successors(final List&lt;Cartesian3D&gt; vertices, final List&lt;int[]&gt; facets,
<i>310</i>&nbsp;                                      final int[][] references) {
<i>311</i>&nbsp;
<i>312</i>&nbsp;        // create an array large enough
<b class="fc"><i>313</i>&nbsp;        final int[][] successors = new int[vertices.size()][references[0].length];</b>
<b class="fc"><i>314</i>&nbsp;        for (final int[] s : successors) {</b>
<b class="fc"><i>315</i>&nbsp;            Arrays.fill(s, -1);</b>
<i>316</i>&nbsp;        }
<i>317</i>&nbsp;
<b class="fc"><i>318</i>&nbsp;        for (int v = 0; v &lt; vertices.size(); ++v) {</b>
<b class="fc"><i>319</i>&nbsp;            for (int k = 0; k &lt; successors[v].length &amp;&amp; references[v][k] &gt;= 0; ++k) {</b>
<i>320</i>&nbsp;
<i>321</i>&nbsp;                // look for vertex v
<b class="fc"><i>322</i>&nbsp;                final int[] facet = facets.get(references[v][k]);</b>
<b class="fc"><i>323</i>&nbsp;                int i = 0;</b>
<b class="fc"><i>324</i>&nbsp;                while (i &lt; facet.length &amp;&amp; facet[i] != v) {</b>
<b class="fc"><i>325</i>&nbsp;                    ++i;</b>
<i>326</i>&nbsp;                }
<i>327</i>&nbsp;
<i>328</i>&nbsp;                // we have found vertex v, we deduce its successor on current facet
<b class="fc"><i>329</i>&nbsp;                successors[v][k] = facet[(i + 1) % facet.length];</b>
<b class="fc"><i>330</i>&nbsp;                for (int l = 0; l &lt; k; ++l) {</b>
<b class="fc"><i>331</i>&nbsp;                    if (successors[v][l] == successors[v][k]) {</b>
<b class="fc"><i>332</i>&nbsp;                        final Cartesian3D start = vertices.get(v);</b>
<b class="fc"><i>333</i>&nbsp;                        final Cartesian3D end   = vertices.get(successors[v][k]);</b>
<b class="fc"><i>334</i>&nbsp;                        throw new MathIllegalArgumentException(LocalizedFormats.FACET_ORIENTATION_MISMATCH,</b>
<b class="fc"><i>335</i>&nbsp;                                                               start.getX(), start.getY(), start.getZ(),</b>
<b class="fc"><i>336</i>&nbsp;                                                               end.getX(),   end.getY(),   end.getZ());</b>
<i>337</i>&nbsp;                    }
<i>338</i>&nbsp;                }
<i>339</i>&nbsp;
<i>340</i>&nbsp;            }
<i>341</i>&nbsp;        }
<i>342</i>&nbsp;
<b class="fc"><i>343</i>&nbsp;        return successors;</b>
<i>344</i>&nbsp;
<i>345</i>&nbsp;    }
<i>346</i>&nbsp;
<i>347</i>&nbsp;    /** {@inheritDoc} */
<i>348</i>&nbsp;    @Override
<i>349</i>&nbsp;    public PolyhedronsSet buildNew(final BSPTree&lt;Euclidean3D&gt; tree) {
<b class="fc"><i>350</i>&nbsp;        return new PolyhedronsSet(tree, getTolerance());</b>
<i>351</i>&nbsp;    }
<i>352</i>&nbsp;
<i>353</i>&nbsp;    /** {@inheritDoc} */
<i>354</i>&nbsp;    @Override
<i>355</i>&nbsp;    protected void computeGeometricalProperties() {
<i>356</i>&nbsp;        // check simple cases first
<b class="fc"><i>357</i>&nbsp;        if (isEmpty()) {</b>
<b class="fc"><i>358</i>&nbsp;            setSize(0.0);</b>
<b class="fc"><i>359</i>&nbsp;            setBarycenter((Point&lt;Euclidean3D&gt;) Cartesian3D.NaN);</b>
<i>360</i>&nbsp;        }
<b class="fc"><i>361</i>&nbsp;        else if (isFull()) {</b>
<b class="fc"><i>362</i>&nbsp;            setSize(Double.POSITIVE_INFINITY);</b>
<b class="fc"><i>363</i>&nbsp;            setBarycenter((Point&lt;Euclidean3D&gt;) Cartesian3D.NaN);</b>
<i>364</i>&nbsp;        }
<i>365</i>&nbsp;        else {
<i>366</i>&nbsp;            // not empty or full; compute the contribution of all boundary facets
<b class="fc"><i>367</i>&nbsp;            final FacetsContributionVisitor contributionVisitor = new FacetsContributionVisitor();</b>
<b class="fc"><i>368</i>&nbsp;            getTree(true).visit(contributionVisitor);</b>
<i>369</i>&nbsp;
<b class="fc"><i>370</i>&nbsp;            final double size = contributionVisitor.getSize();</b>
<b class="fc"><i>371</i>&nbsp;            final Cartesian3D barycenter = contributionVisitor.getBarycenter();</b>
<i>372</i>&nbsp;
<b class="fc"><i>373</i>&nbsp;            if (size &lt; 0) {</b>
<i>374</i>&nbsp;                // the polyhedrons set is a finite outside surrounded by an infinite inside
<b class="fc"><i>375</i>&nbsp;                setSize(Double.POSITIVE_INFINITY);</b>
<b class="fc"><i>376</i>&nbsp;                setBarycenter((Point&lt;Euclidean3D&gt;) Cartesian3D.NaN);</b>
<i>377</i>&nbsp;            } else {
<i>378</i>&nbsp;                // the polyhedrons set is finite
<b class="fc"><i>379</i>&nbsp;                setSize(size);</b>
<b class="fc"><i>380</i>&nbsp;                setBarycenter((Point&lt;Euclidean3D&gt;) barycenter);</b>
<i>381</i>&nbsp;            }
<i>382</i>&nbsp;        }
<b class="fc"><i>383</i>&nbsp;    }</b>
<i>384</i>&nbsp;
<i>385</i>&nbsp;    /** Visitor computing polyhedron geometrical properties.
<i>386</i>&nbsp;     *  The volume of the polyhedron is computed using the equation
<i>387</i>&nbsp;     *  &lt;code&gt;V = (1/3)*&amp;Sigma;&lt;sub&gt;F&lt;/sub&gt;[(C&lt;sub&gt;F&lt;/sub&gt;&amp;sdot;N&lt;sub&gt;F&lt;/sub&gt;)*area(F)]&lt;/code&gt;,
<i>388</i>&nbsp;     *  where &lt;code&gt;F&lt;/code&gt; represents each face in the polyhedron, &lt;code&gt;C&lt;sub&gt;F&lt;/sub&gt;&lt;/code&gt;
<i>389</i>&nbsp;     *  represents the barycenter of the face, and &lt;code&gt;N&lt;sub&gt;F&lt;/sub&gt;&lt;/code&gt; represents the
<i>390</i>&nbsp;     *  normal of the face. (More details can be found in the article
<i>391</i>&nbsp;     *  &lt;a href=&quot;https://en.wikipedia.org/wiki/Polyhedron#Volume&quot;&gt;here&lt;/a&gt;.)
<i>392</i>&nbsp;     *  This essentially splits up the polyhedron into pyramids with a polyhedron
<i>393</i>&nbsp;     *  face forming the base of each pyramid.
<i>394</i>&nbsp;     *  The barycenter is computed in a similar way. The barycenter of each pyramid
<i>395</i>&nbsp;     *  is calculated using the fact that it is located 3/4 of the way along the
<i>396</i>&nbsp;     *  line from the apex to the base. The polyhedron barycenter then becomes
<i>397</i>&nbsp;     *  the volume-weighted average of these pyramid centers.
<i>398</i>&nbsp;     */
<b class="fc"><i>399</i>&nbsp;    private static class FacetsContributionVisitor implements BSPTreeVisitor&lt;Euclidean3D&gt; {</b>
<i>400</i>&nbsp;
<i>401</i>&nbsp;        /** Accumulator for facet volume contributions. */
<i>402</i>&nbsp;        private double volumeSum;
<i>403</i>&nbsp;
<i>404</i>&nbsp;        /** Accumulator for barycenter contributions. */
<b class="fc"><i>405</i>&nbsp;        private Cartesian3D barycenterSum = Cartesian3D.ZERO;</b>
<i>406</i>&nbsp;
<i>407</i>&nbsp;        /** Returns the total computed size (ie, volume) of the polyhedron.
<i>408</i>&nbsp;         * This value will be negative if the polyhedron is &quot;inside-out&quot;, meaning
<i>409</i>&nbsp;         * that it has a finite outside surrounded by an infinite inside.
<i>410</i>&nbsp;         * @return the volume.
<i>411</i>&nbsp;         */
<i>412</i>&nbsp;        public double getSize() {
<i>413</i>&nbsp;            // apply the 1/3 pyramid volume scaling factor
<b class="fc"><i>414</i>&nbsp;            return volumeSum / 3.0;</b>
<i>415</i>&nbsp;        }
<i>416</i>&nbsp;
<i>417</i>&nbsp;        /** Returns the computed barycenter. This is the volume-weighted average
<i>418</i>&nbsp;         * of contributions from all facets. All coordinates will be NaN if the
<i>419</i>&nbsp;         * region is infinite.
<i>420</i>&nbsp;         * @return the barycenter.
<i>421</i>&nbsp;         */
<i>422</i>&nbsp;        public Cartesian3D getBarycenter() {
<i>423</i>&nbsp;            // Since the volume we used when adding together the facet contributions
<i>424</i>&nbsp;            // was 3x the actual pyramid size, we&#39;ll multiply by 1/4 here instead
<i>425</i>&nbsp;            // of 3/4 to adjust for the actual barycenter position in each pyramid.
<b class="fc"><i>426</i>&nbsp;            return new Cartesian3D(1.0 / (4 * getSize()), barycenterSum);</b>
<i>427</i>&nbsp;        }
<i>428</i>&nbsp;
<i>429</i>&nbsp;        /** {@inheritDoc} */
<i>430</i>&nbsp;        @Override
<i>431</i>&nbsp;        public Order visitOrder(final BSPTree&lt;Euclidean3D&gt; node) {
<b class="fc"><i>432</i>&nbsp;            return Order.MINUS_SUB_PLUS;</b>
<i>433</i>&nbsp;        }
<i>434</i>&nbsp;
<i>435</i>&nbsp;        /** {@inheritDoc} */
<i>436</i>&nbsp;        @Override
<i>437</i>&nbsp;        public void visitInternalNode(final BSPTree&lt;Euclidean3D&gt; node) {
<i>438</i>&nbsp;            @SuppressWarnings(&quot;unchecked&quot;)
<b class="fc"><i>439</i>&nbsp;            final BoundaryAttribute&lt;Euclidean3D&gt; attribute =</b>
<b class="fc"><i>440</i>&nbsp;                (BoundaryAttribute&lt;Euclidean3D&gt;) node.getAttribute();</b>
<b class="fc"><i>441</i>&nbsp;            if (attribute.getPlusOutside() != null) {</b>
<b class="fc"><i>442</i>&nbsp;                addContribution(attribute.getPlusOutside(), false);</b>
<i>443</i>&nbsp;            }
<b class="fc"><i>444</i>&nbsp;            if (attribute.getPlusInside() != null) {</b>
<b class="fc"><i>445</i>&nbsp;                addContribution(attribute.getPlusInside(), true);</b>
<i>446</i>&nbsp;            }
<b class="fc"><i>447</i>&nbsp;        }</b>
<i>448</i>&nbsp;
<i>449</i>&nbsp;        /** {@inheritDoc} */
<i>450</i>&nbsp;        @Override
<i>451</i>&nbsp;        public void visitLeafNode(final BSPTree&lt;Euclidean3D&gt; node) {
<b class="fc"><i>452</i>&nbsp;        }</b>
<i>453</i>&nbsp;
<i>454</i>&nbsp;        /** Add the contribution of a boundary facet.
<i>455</i>&nbsp;         * @param facet boundary facet
<i>456</i>&nbsp;         * @param reversed if true, the facet has the inside on its plus side
<i>457</i>&nbsp;         */
<i>458</i>&nbsp;        private void addContribution(final SubHyperplane&lt;Euclidean3D&gt; facet, final boolean reversed) {
<i>459</i>&nbsp;
<b class="fc"><i>460</i>&nbsp;            final Region&lt;Euclidean2D&gt; polygon = ((SubPlane) facet).getRemainingRegion();</b>
<b class="fc"><i>461</i>&nbsp;            final double area = polygon.getSize();</b>
<i>462</i>&nbsp;
<b class="fc"><i>463</i>&nbsp;            if (Double.isInfinite(area)) {</b>
<b class="fc"><i>464</i>&nbsp;                volumeSum = Double.POSITIVE_INFINITY;</b>
<b class="fc"><i>465</i>&nbsp;                barycenterSum = Cartesian3D.NaN;</b>
<i>466</i>&nbsp;            } else {
<b class="fc"><i>467</i>&nbsp;                final Plane plane = (Plane) facet.getHyperplane();</b>
<b class="fc"><i>468</i>&nbsp;                final Cartesian3D facetBarycenter = plane.toSpace(polygon.getBarycenter());</b>
<i>469</i>&nbsp;
<i>470</i>&nbsp;                // the volume here is actually 3x the actual pyramid volume; we&#39;ll apply
<i>471</i>&nbsp;                // the final scaling all at once at the end
<b class="fc"><i>472</i>&nbsp;                double scaledVolume = area * facetBarycenter.dotProduct(plane.getNormal());</b>
<b class="fc"><i>473</i>&nbsp;                if (reversed) {</b>
<b class="fc"><i>474</i>&nbsp;                    scaledVolume = -scaledVolume;</b>
<i>475</i>&nbsp;                }
<i>476</i>&nbsp;
<b class="fc"><i>477</i>&nbsp;                volumeSum += scaledVolume;</b>
<b class="fc"><i>478</i>&nbsp;                barycenterSum = new Cartesian3D(1.0, barycenterSum, scaledVolume, facetBarycenter);</b>
<i>479</i>&nbsp;            }
<b class="fc"><i>480</i>&nbsp;        }</b>
<i>481</i>&nbsp;    }
<i>482</i>&nbsp;
<i>483</i>&nbsp;    /** Get the first sub-hyperplane crossed by a semi-infinite line.
<i>484</i>&nbsp;     * @param point start point of the part of the line considered
<i>485</i>&nbsp;     * @param line line to consider (contains point)
<i>486</i>&nbsp;     * @return the first sub-hyperplane crossed by the line after the
<i>487</i>&nbsp;     * given point, or null if the line does not intersect any
<i>488</i>&nbsp;     * sub-hyperplane
<i>489</i>&nbsp;     */
<i>490</i>&nbsp;    public SubHyperplane&lt;Euclidean3D&gt; firstIntersection(final Cartesian3D point, final Line line) {
<b class="fc"><i>491</i>&nbsp;        return recurseFirstIntersection(getTree(true), point, line);</b>
<i>492</i>&nbsp;    }
<i>493</i>&nbsp;
<i>494</i>&nbsp;    /** Get the first sub-hyperplane crossed by a semi-infinite line.
<i>495</i>&nbsp;     * @param node current node
<i>496</i>&nbsp;     * @param point start point of the part of the line considered
<i>497</i>&nbsp;     * @param line line to consider (contains point)
<i>498</i>&nbsp;     * @return the first sub-hyperplane crossed by the line after the
<i>499</i>&nbsp;     * given point, or null if the line does not intersect any
<i>500</i>&nbsp;     * sub-hyperplane
<i>501</i>&nbsp;     */
<i>502</i>&nbsp;    private SubHyperplane&lt;Euclidean3D&gt; recurseFirstIntersection(final BSPTree&lt;Euclidean3D&gt; node,
<i>503</i>&nbsp;                                                                final Cartesian3D point,
<i>504</i>&nbsp;                                                                final Line line) {
<i>505</i>&nbsp;
<b class="fc"><i>506</i>&nbsp;        final SubHyperplane&lt;Euclidean3D&gt; cut = node.getCut();</b>
<b class="fc"><i>507</i>&nbsp;        if (cut == null) {</b>
<b class="fc"><i>508</i>&nbsp;            return null;</b>
<i>509</i>&nbsp;        }
<b class="fc"><i>510</i>&nbsp;        final BSPTree&lt;Euclidean3D&gt; minus = node.getMinus();</b>
<b class="fc"><i>511</i>&nbsp;        final BSPTree&lt;Euclidean3D&gt; plus  = node.getPlus();</b>
<b class="fc"><i>512</i>&nbsp;        final Plane                plane = (Plane) cut.getHyperplane();</b>
<i>513</i>&nbsp;
<i>514</i>&nbsp;        // establish search order
<b class="fc"><i>515</i>&nbsp;        final double offset = plane.getOffset(point);</b>
<b class="fc"><i>516</i>&nbsp;        final boolean in    = FastMath.abs(offset) &lt; getTolerance();</b>
<i>517</i>&nbsp;        final BSPTree&lt;Euclidean3D&gt; near;
<i>518</i>&nbsp;        final BSPTree&lt;Euclidean3D&gt; far;
<b class="fc"><i>519</i>&nbsp;        if (offset &lt; 0) {</b>
<b class="fc"><i>520</i>&nbsp;            near = minus;</b>
<b class="fc"><i>521</i>&nbsp;            far  = plus;</b>
<i>522</i>&nbsp;        } else {
<b class="fc"><i>523</i>&nbsp;            near = plus;</b>
<b class="fc"><i>524</i>&nbsp;            far  = minus;</b>
<i>525</i>&nbsp;        }
<i>526</i>&nbsp;
<b class="fc"><i>527</i>&nbsp;        if (in) {</b>
<i>528</i>&nbsp;            // search in the cut hyperplane
<b class="fc"><i>529</i>&nbsp;            final SubHyperplane&lt;Euclidean3D&gt; facet = boundaryFacet(point, node);</b>
<b class="fc"><i>530</i>&nbsp;            if (facet != null) {</b>
<b class="fc"><i>531</i>&nbsp;                return facet;</b>
<i>532</i>&nbsp;            }
<i>533</i>&nbsp;        }
<i>534</i>&nbsp;
<i>535</i>&nbsp;        // search in the near branch
<b class="fc"><i>536</i>&nbsp;        final SubHyperplane&lt;Euclidean3D&gt; crossed = recurseFirstIntersection(near, point, line);</b>
<b class="fc"><i>537</i>&nbsp;        if (crossed != null) {</b>
<b class="fc"><i>538</i>&nbsp;            return crossed;</b>
<i>539</i>&nbsp;        }
<i>540</i>&nbsp;
<b class="fc"><i>541</i>&nbsp;        if (!in) {</b>
<i>542</i>&nbsp;            // search in the cut hyperplane
<b class="fc"><i>543</i>&nbsp;            final Cartesian3D hit3D = plane.intersection(line);</b>
<b class="fc"><i>544</i>&nbsp;            if (hit3D != null &amp;&amp; line.getAbscissa(hit3D) &gt; line.getAbscissa(point)) {</b>
<b class="fc"><i>545</i>&nbsp;                final SubHyperplane&lt;Euclidean3D&gt; facet = boundaryFacet(hit3D, node);</b>
<b class="fc"><i>546</i>&nbsp;                if (facet != null) {</b>
<b class="fc"><i>547</i>&nbsp;                    return facet;</b>
<i>548</i>&nbsp;                }
<i>549</i>&nbsp;            }
<i>550</i>&nbsp;        }
<i>551</i>&nbsp;
<i>552</i>&nbsp;        // search in the far branch
<b class="fc"><i>553</i>&nbsp;        return recurseFirstIntersection(far, point, line);</b>
<i>554</i>&nbsp;
<i>555</i>&nbsp;    }
<i>556</i>&nbsp;
<i>557</i>&nbsp;    /** Check if a point belongs to the boundary part of a node.
<i>558</i>&nbsp;     * @param point point to check
<i>559</i>&nbsp;     * @param node node containing the boundary facet to check
<i>560</i>&nbsp;     * @return the boundary facet this points belongs to (or null if it
<i>561</i>&nbsp;     * does not belong to any boundary facet)
<i>562</i>&nbsp;     */
<i>563</i>&nbsp;    private SubHyperplane&lt;Euclidean3D&gt; boundaryFacet(final Cartesian3D point,
<i>564</i>&nbsp;                                                     final BSPTree&lt;Euclidean3D&gt; node) {
<b class="fc"><i>565</i>&nbsp;        final Cartesian2D point2D = ((Plane) node.getCut().getHyperplane()).toSubSpace(point);</b>
<i>566</i>&nbsp;        @SuppressWarnings(&quot;unchecked&quot;)
<b class="fc"><i>567</i>&nbsp;        final BoundaryAttribute&lt;Euclidean3D&gt; attribute =</b>
<b class="fc"><i>568</i>&nbsp;            (BoundaryAttribute&lt;Euclidean3D&gt;) node.getAttribute();</b>
<b class="fc"><i>569</i>&nbsp;        if ((attribute.getPlusOutside() != null) &amp;&amp;</b>
<b class="fc"><i>570</i>&nbsp;            (((SubPlane) attribute.getPlusOutside()).getRemainingRegion().checkPoint(point2D) == Location.INSIDE)) {</b>
<b class="fc"><i>571</i>&nbsp;            return attribute.getPlusOutside();</b>
<i>572</i>&nbsp;        }
<b class="fc"><i>573</i>&nbsp;        if ((attribute.getPlusInside() != null) &amp;&amp;</b>
<b class="nc"><i>574</i>&nbsp;            (((SubPlane) attribute.getPlusInside()).getRemainingRegion().checkPoint(point2D) == Location.INSIDE)) {</b>
<b class="nc"><i>575</i>&nbsp;            return attribute.getPlusInside();</b>
<i>576</i>&nbsp;        }
<b class="fc"><i>577</i>&nbsp;        return null;</b>
<i>578</i>&nbsp;    }
<i>579</i>&nbsp;
<i>580</i>&nbsp;    /** Rotate the region around the specified point.
<i>581</i>&nbsp;     * &lt;p&gt;The instance is not modified, a new instance is created.&lt;/p&gt;
<i>582</i>&nbsp;     * @param center rotation center
<i>583</i>&nbsp;     * @param rotation vectorial rotation operator
<i>584</i>&nbsp;     * @return a new instance representing the rotated region
<i>585</i>&nbsp;     */
<i>586</i>&nbsp;    public PolyhedronsSet rotate(final Cartesian3D center, final Rotation rotation) {
<b class="fc"><i>587</i>&nbsp;        return (PolyhedronsSet) applyTransform(new RotationTransform(center, rotation));</b>
<i>588</i>&nbsp;    }
<i>589</i>&nbsp;
<i>590</i>&nbsp;    /** 3D rotation as a Transform. */
<i>591</i>&nbsp;    private static class RotationTransform implements Transform&lt;Euclidean3D, Euclidean2D&gt; {
<i>592</i>&nbsp;
<i>593</i>&nbsp;        /** Center point of the rotation. */
<i>594</i>&nbsp;        private final Cartesian3D   center;
<i>595</i>&nbsp;
<i>596</i>&nbsp;        /** Vectorial rotation. */
<i>597</i>&nbsp;        private final Rotation   rotation;
<i>598</i>&nbsp;
<i>599</i>&nbsp;        /** Cached original hyperplane. */
<i>600</i>&nbsp;        private Plane cachedOriginal;
<i>601</i>&nbsp;
<i>602</i>&nbsp;        /** Cached 2D transform valid inside the cached original hyperplane. */
<i>603</i>&nbsp;        private Transform&lt;Euclidean2D, Euclidean1D&gt;  cachedTransform;
<i>604</i>&nbsp;
<i>605</i>&nbsp;        /** Build a rotation transform.
<i>606</i>&nbsp;         * @param center center point of the rotation
<i>607</i>&nbsp;         * @param rotation vectorial rotation
<i>608</i>&nbsp;         */
<b class="fc"><i>609</i>&nbsp;        RotationTransform(final Cartesian3D center, final Rotation rotation) {</b>
<b class="fc"><i>610</i>&nbsp;            this.center   = center;</b>
<b class="fc"><i>611</i>&nbsp;            this.rotation = rotation;</b>
<b class="fc"><i>612</i>&nbsp;        }</b>
<i>613</i>&nbsp;
<i>614</i>&nbsp;        /** {@inheritDoc} */
<i>615</i>&nbsp;        @Override
<i>616</i>&nbsp;        public Cartesian3D apply(final Point&lt;Euclidean3D&gt; point) {
<b class="fc"><i>617</i>&nbsp;            final Cartesian3D delta = ((Cartesian3D) point).subtract(center);</b>
<b class="fc"><i>618</i>&nbsp;            return new Cartesian3D(1.0, center, 1.0, rotation.applyTo(delta));</b>
<i>619</i>&nbsp;        }
<i>620</i>&nbsp;
<i>621</i>&nbsp;        /** {@inheritDoc} */
<i>622</i>&nbsp;        @Override
<i>623</i>&nbsp;        public Plane apply(final Hyperplane&lt;Euclidean3D&gt; hyperplane) {
<b class="fc"><i>624</i>&nbsp;            return ((Plane) hyperplane).rotate(center, rotation);</b>
<i>625</i>&nbsp;        }
<i>626</i>&nbsp;
<i>627</i>&nbsp;        /** {@inheritDoc} */
<i>628</i>&nbsp;        @Override
<i>629</i>&nbsp;        public SubHyperplane&lt;Euclidean2D&gt; apply(final SubHyperplane&lt;Euclidean2D&gt; sub,
<i>630</i>&nbsp;                                                final Hyperplane&lt;Euclidean3D&gt; original,
<i>631</i>&nbsp;                                                final Hyperplane&lt;Euclidean3D&gt; transformed) {
<b class="fc"><i>632</i>&nbsp;            if (original != cachedOriginal) {</b>
<i>633</i>&nbsp;                // we have changed hyperplane, reset the in-hyperplane transform
<i>634</i>&nbsp;
<b class="fc"><i>635</i>&nbsp;                final Plane    oPlane = (Plane) original;</b>
<b class="fc"><i>636</i>&nbsp;                final Plane    tPlane = (Plane) transformed;</b>
<b class="fc"><i>637</i>&nbsp;                final Cartesian3D p00    = oPlane.getOrigin();</b>
<b class="fc"><i>638</i>&nbsp;                final Cartesian3D p10    = oPlane.toSpace(new Cartesian2D(1.0, 0.0));</b>
<b class="fc"><i>639</i>&nbsp;                final Cartesian3D p01    = oPlane.toSpace(new Cartesian2D(0.0, 1.0));</b>
<b class="fc"><i>640</i>&nbsp;                final Cartesian2D tP00   = tPlane.toSubSpace(apply(p00));</b>
<b class="fc"><i>641</i>&nbsp;                final Cartesian2D tP10   = tPlane.toSubSpace(apply(p10));</b>
<b class="fc"><i>642</i>&nbsp;                final Cartesian2D tP01   = tPlane.toSubSpace(apply(p01));</b>
<i>643</i>&nbsp;
<b class="fc"><i>644</i>&nbsp;                cachedOriginal  = (Plane) original;</b>
<b class="fc"><i>645</i>&nbsp;                cachedTransform =</b>
<b class="fc"><i>646</i>&nbsp;                        org.apache.commons.math4.geometry.euclidean.twod.Line.getTransform(tP10.getX() - tP00.getX(),</b>
<b class="fc"><i>647</i>&nbsp;                                                                                           tP10.getY() - tP00.getY(),</b>
<b class="fc"><i>648</i>&nbsp;                                                                                           tP01.getX() - tP00.getX(),</b>
<b class="fc"><i>649</i>&nbsp;                                                                                           tP01.getY() - tP00.getY(),</b>
<b class="fc"><i>650</i>&nbsp;                                                                                           tP00.getX(),</b>
<b class="fc"><i>651</i>&nbsp;                                                                                           tP00.getY());</b>
<i>652</i>&nbsp;
<i>653</i>&nbsp;            }
<b class="fc"><i>654</i>&nbsp;            return ((SubLine) sub).applyTransform(cachedTransform);</b>
<i>655</i>&nbsp;        }
<i>656</i>&nbsp;
<i>657</i>&nbsp;    }
<i>658</i>&nbsp;
<i>659</i>&nbsp;    /** Translate the region by the specified amount.
<i>660</i>&nbsp;     * &lt;p&gt;The instance is not modified, a new instance is created.&lt;/p&gt;
<i>661</i>&nbsp;     * @param translation translation to apply
<i>662</i>&nbsp;     * @return a new instance representing the translated region
<i>663</i>&nbsp;     */
<i>664</i>&nbsp;    public PolyhedronsSet translate(final Cartesian3D translation) {
<b class="fc"><i>665</i>&nbsp;        return (PolyhedronsSet) applyTransform(new TranslationTransform(translation));</b>
<i>666</i>&nbsp;    }
<i>667</i>&nbsp;
<i>668</i>&nbsp;    /** 3D translation as a transform. */
<i>669</i>&nbsp;    private static class TranslationTransform implements Transform&lt;Euclidean3D, Euclidean2D&gt; {
<i>670</i>&nbsp;
<i>671</i>&nbsp;        /** Translation vector. */
<i>672</i>&nbsp;        private final Cartesian3D   translation;
<i>673</i>&nbsp;
<i>674</i>&nbsp;        /** Cached original hyperplane. */
<i>675</i>&nbsp;        private Plane cachedOriginal;
<i>676</i>&nbsp;
<i>677</i>&nbsp;        /** Cached 2D transform valid inside the cached original hyperplane. */
<i>678</i>&nbsp;        private Transform&lt;Euclidean2D, Euclidean1D&gt;  cachedTransform;
<i>679</i>&nbsp;
<i>680</i>&nbsp;        /** Build a translation transform.
<i>681</i>&nbsp;         * @param translation translation vector
<i>682</i>&nbsp;         */
<b class="fc"><i>683</i>&nbsp;        TranslationTransform(final Cartesian3D translation) {</b>
<b class="fc"><i>684</i>&nbsp;            this.translation = translation;</b>
<b class="fc"><i>685</i>&nbsp;        }</b>
<i>686</i>&nbsp;
<i>687</i>&nbsp;        /** {@inheritDoc} */
<i>688</i>&nbsp;        @Override
<i>689</i>&nbsp;        public Cartesian3D apply(final Point&lt;Euclidean3D&gt; point) {
<b class="fc"><i>690</i>&nbsp;            return new Cartesian3D(1.0, (Cartesian3D) point, 1.0, translation);</b>
<i>691</i>&nbsp;        }
<i>692</i>&nbsp;
<i>693</i>&nbsp;        /** {@inheritDoc} */
<i>694</i>&nbsp;        @Override
<i>695</i>&nbsp;        public Plane apply(final Hyperplane&lt;Euclidean3D&gt; hyperplane) {
<b class="fc"><i>696</i>&nbsp;            return ((Plane) hyperplane).translate(translation);</b>
<i>697</i>&nbsp;        }
<i>698</i>&nbsp;
<i>699</i>&nbsp;        /** {@inheritDoc} */
<i>700</i>&nbsp;        @Override
<i>701</i>&nbsp;        public SubHyperplane&lt;Euclidean2D&gt; apply(final SubHyperplane&lt;Euclidean2D&gt; sub,
<i>702</i>&nbsp;                                                final Hyperplane&lt;Euclidean3D&gt; original,
<i>703</i>&nbsp;                                                final Hyperplane&lt;Euclidean3D&gt; transformed) {
<b class="fc"><i>704</i>&nbsp;            if (original != cachedOriginal) {</b>
<i>705</i>&nbsp;                // we have changed hyperplane, reset the in-hyperplane transform
<i>706</i>&nbsp;
<b class="fc"><i>707</i>&nbsp;                final Plane   oPlane = (Plane) original;</b>
<b class="fc"><i>708</i>&nbsp;                final Plane   tPlane = (Plane) transformed;</b>
<b class="fc"><i>709</i>&nbsp;                final Cartesian2D shift  = tPlane.toSubSpace(apply(oPlane.getOrigin()));</b>
<i>710</i>&nbsp;
<b class="fc"><i>711</i>&nbsp;                cachedOriginal  = (Plane) original;</b>
<b class="fc"><i>712</i>&nbsp;                cachedTransform =</b>
<b class="fc"><i>713</i>&nbsp;                        org.apache.commons.math4.geometry.euclidean.twod.Line.getTransform(1, 0, 0, 1,</b>
<b class="fc"><i>714</i>&nbsp;                                                                                           shift.getX(),</b>
<b class="fc"><i>715</i>&nbsp;                                                                                           shift.getY());</b>
<i>716</i>&nbsp;
<i>717</i>&nbsp;            }
<i>718</i>&nbsp;
<b class="fc"><i>719</i>&nbsp;            return ((SubLine) sub).applyTransform(cachedTransform);</b>
<i>720</i>&nbsp;
<i>721</i>&nbsp;        }
<i>722</i>&nbsp;
<i>723</i>&nbsp;    }
<i>724</i>&nbsp;
<i>725</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2019-06-04 09:26</div>
</div>
</body>
</html>
