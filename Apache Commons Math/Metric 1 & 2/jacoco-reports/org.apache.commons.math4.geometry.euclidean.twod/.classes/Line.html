


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: Line</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">org.apache.commons.math4.geometry.euclidean.twod</a> ]
</div>

<h1>Coverage Summary for Class: Line (org.apache.commons.math4.geometry.euclidean.twod)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">Line</td>
<td class="coverageStat">
  <span class="percent">
    81.1%
  </span>
  <span class="absValue">
    (30/ 37)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    75.5%
  </span>
  <span class="absValue">
    (80/ 106)
  </span>
</td>
</tr>
  <tr>
    <td class="name">Line$LineTransform</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    96.8%
  </span>
  <span class="absValue">
    (30/ 31)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>total</strong></td>
<td class="coverageStat">
  <span class="percent">
    82.9%
  </span>
  <span class="absValue">
    (34/ 41)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    80.3%
  </span>
  <span class="absValue">
    (110/ 137)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;/*
<i>2</i>&nbsp; * Licensed to the Apache Software Foundation (ASF) under one or more
<i>3</i>&nbsp; * contributor license agreements.  See the NOTICE file distributed with
<i>4</i>&nbsp; * this work for additional information regarding copyright ownership.
<i>5</i>&nbsp; * The ASF licenses this file to You under the Apache License, Version 2.0
<i>6</i>&nbsp; * (the &quot;License&quot;); you may not use this file except in compliance with
<i>7</i>&nbsp; * the License.  You may obtain a copy of the License at
<i>8</i>&nbsp; *
<i>9</i>&nbsp; *      http://www.apache.org/licenses/LICENSE-2.0
<i>10</i>&nbsp; *
<i>11</i>&nbsp; * Unless required by applicable law or agreed to in writing, software
<i>12</i>&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
<i>13</i>&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
<i>14</i>&nbsp; * See the License for the specific language governing permissions and
<i>15</i>&nbsp; * limitations under the License.
<i>16</i>&nbsp; */
<i>17</i>&nbsp;package org.apache.commons.math4.geometry.euclidean.twod;
<i>18</i>&nbsp;
<i>19</i>&nbsp;import org.apache.commons.numbers.arrays.LinearCombination;
<i>20</i>&nbsp;import org.apache.commons.numbers.angle.PlaneAngleRadians;
<i>21</i>&nbsp;import org.apache.commons.math4.exception.MathIllegalArgumentException;
<i>22</i>&nbsp;import org.apache.commons.math4.exception.util.LocalizedFormats;
<i>23</i>&nbsp;import org.apache.commons.math4.geometry.Point;
<i>24</i>&nbsp;import org.apache.commons.math4.geometry.Vector;
<i>25</i>&nbsp;import org.apache.commons.math4.geometry.euclidean.oned.Euclidean1D;
<i>26</i>&nbsp;import org.apache.commons.math4.geometry.euclidean.oned.IntervalsSet;
<i>27</i>&nbsp;import org.apache.commons.math4.geometry.euclidean.oned.OrientedPoint;
<i>28</i>&nbsp;import org.apache.commons.math4.geometry.euclidean.oned.Cartesian1D;
<i>29</i>&nbsp;import org.apache.commons.math4.geometry.partitioning.Embedding;
<i>30</i>&nbsp;import org.apache.commons.math4.geometry.partitioning.Hyperplane;
<i>31</i>&nbsp;import org.apache.commons.math4.geometry.partitioning.SubHyperplane;
<i>32</i>&nbsp;import org.apache.commons.math4.geometry.partitioning.Transform;
<i>33</i>&nbsp;import org.apache.commons.math4.util.FastMath;
<i>34</i>&nbsp;
<i>35</i>&nbsp;/** This class represents an oriented line in the 2D plane.
<i>36</i>&nbsp;
<i>37</i>&nbsp; * &lt;p&gt;An oriented line can be defined either by prolongating a line
<i>38</i>&nbsp; * segment between two points past these points, or by one point and
<i>39</i>&nbsp; * an angular direction (in trigonometric orientation).&lt;/p&gt;
<i>40</i>&nbsp;
<i>41</i>&nbsp; * &lt;p&gt;Since it is oriented the two half planes at its two sides are
<i>42</i>&nbsp; * unambiguously identified as a left half plane and a right half
<i>43</i>&nbsp; * plane. This can be used to identify the interior and the exterior
<i>44</i>&nbsp; * in a simple way by local properties only when part of a line is
<i>45</i>&nbsp; * used to define part of a polygon boundary.&lt;/p&gt;
<i>46</i>&nbsp;
<i>47</i>&nbsp; * &lt;p&gt;A line can also be used to completely define a reference frame
<i>48</i>&nbsp; * in the plane. It is sufficient to select one specific point in the
<i>49</i>&nbsp; * line (the orthogonal projection of the original reference frame on
<i>50</i>&nbsp; * the line) and to use the unit vector in the line direction and the
<i>51</i>&nbsp; * orthogonal vector oriented from left half plane to right half
<i>52</i>&nbsp; * plane. We define two coordinates by the process, the
<i>53</i>&nbsp; * &lt;em&gt;abscissa&lt;/em&gt; along the line, and the &lt;em&gt;offset&lt;/em&gt; across
<i>54</i>&nbsp; * the line. All points of the plane are uniquely identified by these
<i>55</i>&nbsp; * two coordinates. The line is the set of points at zero offset, the
<i>56</i>&nbsp; * left half plane is the set of points with negative offsets and the
<i>57</i>&nbsp; * right half plane is the set of points with positive offsets.&lt;/p&gt;
<i>58</i>&nbsp;
<i>59</i>&nbsp; * @since 3.0
<i>60</i>&nbsp; */
<b class="fc"><i>61</i>&nbsp;public class Line implements Hyperplane&lt;Euclidean2D&gt;, Embedding&lt;Euclidean2D, Euclidean1D&gt; {</b>
<i>62</i>&nbsp;    /** Angle with respect to the abscissa axis. */
<i>63</i>&nbsp;    private double angle;
<i>64</i>&nbsp;
<i>65</i>&nbsp;    /** Cosine of the line angle. */
<i>66</i>&nbsp;    private double cos;
<i>67</i>&nbsp;
<i>68</i>&nbsp;    /** Sine of the line angle. */
<i>69</i>&nbsp;    private double sin;
<i>70</i>&nbsp;
<i>71</i>&nbsp;    /** Offset of the frame origin. */
<i>72</i>&nbsp;    private double originOffset;
<i>73</i>&nbsp;
<i>74</i>&nbsp;    /** Tolerance below which points are considered identical. */
<i>75</i>&nbsp;    private final double tolerance;
<i>76</i>&nbsp;
<i>77</i>&nbsp;    /** Reverse line. */
<i>78</i>&nbsp;    private Line reverse;
<i>79</i>&nbsp;
<i>80</i>&nbsp;    /** Build a line from two points.
<i>81</i>&nbsp;     * &lt;p&gt;The line is oriented from p1 to p2&lt;/p&gt;
<i>82</i>&nbsp;     * @param p1 first point
<i>83</i>&nbsp;     * @param p2 second point
<i>84</i>&nbsp;     * @param tolerance tolerance below which points are considered identical
<i>85</i>&nbsp;     * @since 3.3
<i>86</i>&nbsp;     */
<b class="fc"><i>87</i>&nbsp;    public Line(final Cartesian2D p1, final Cartesian2D p2, final double tolerance) {</b>
<b class="fc"><i>88</i>&nbsp;        reset(p1, p2);</b>
<b class="fc"><i>89</i>&nbsp;        this.tolerance = tolerance;</b>
<b class="fc"><i>90</i>&nbsp;    }</b>
<i>91</i>&nbsp;
<i>92</i>&nbsp;    /** Build a line from a point and an angle.
<i>93</i>&nbsp;     * @param p point belonging to the line
<i>94</i>&nbsp;     * @param angle angle of the line with respect to abscissa axis
<i>95</i>&nbsp;     * @param tolerance tolerance below which points are considered identical
<i>96</i>&nbsp;     * @since 3.3
<i>97</i>&nbsp;     */
<b class="fc"><i>98</i>&nbsp;    public Line(final Cartesian2D p, final double angle, final double tolerance) {</b>
<b class="fc"><i>99</i>&nbsp;        reset(p, angle);</b>
<b class="fc"><i>100</i>&nbsp;        this.tolerance = tolerance;</b>
<b class="fc"><i>101</i>&nbsp;    }</b>
<i>102</i>&nbsp;
<i>103</i>&nbsp;    /** Build a line from its internal characteristics.
<i>104</i>&nbsp;     * @param angle angle of the line with respect to abscissa axis
<i>105</i>&nbsp;     * @param cos cosine of the angle
<i>106</i>&nbsp;     * @param sin sine of the angle
<i>107</i>&nbsp;     * @param originOffset offset of the origin
<i>108</i>&nbsp;     * @param tolerance tolerance below which points are considered identical
<i>109</i>&nbsp;     * @since 3.3
<i>110</i>&nbsp;     */
<i>111</i>&nbsp;    private Line(final double angle, final double cos, final double sin,
<b class="fc"><i>112</i>&nbsp;                 final double originOffset, final double tolerance) {</b>
<b class="fc"><i>113</i>&nbsp;        this.angle        = angle;</b>
<b class="fc"><i>114</i>&nbsp;        this.cos          = cos;</b>
<b class="fc"><i>115</i>&nbsp;        this.sin          = sin;</b>
<b class="fc"><i>116</i>&nbsp;        this.originOffset = originOffset;</b>
<b class="fc"><i>117</i>&nbsp;        this.tolerance    = tolerance;</b>
<b class="fc"><i>118</i>&nbsp;        this.reverse      = null;</b>
<b class="fc"><i>119</i>&nbsp;    }</b>
<i>120</i>&nbsp;
<i>121</i>&nbsp;    /** Copy constructor.
<i>122</i>&nbsp;     * &lt;p&gt;The created instance is completely independent from the
<i>123</i>&nbsp;     * original instance, it is a deep copy.&lt;/p&gt;
<i>124</i>&nbsp;     * @param line line to copy
<i>125</i>&nbsp;     */
<b class="fc"><i>126</i>&nbsp;    public Line(final Line line) {</b>
<b class="fc"><i>127</i>&nbsp;        angle        = PlaneAngleRadians.normalizeBetweenZeroAndTwoPi(line.angle);</b>
<b class="fc"><i>128</i>&nbsp;        cos          = line.cos;</b>
<b class="fc"><i>129</i>&nbsp;        sin          = line.sin;</b>
<b class="fc"><i>130</i>&nbsp;        originOffset = line.originOffset;</b>
<b class="fc"><i>131</i>&nbsp;        tolerance    = line.tolerance;</b>
<b class="fc"><i>132</i>&nbsp;        reverse      = null;</b>
<b class="fc"><i>133</i>&nbsp;    }</b>
<i>134</i>&nbsp;
<i>135</i>&nbsp;    /** {@inheritDoc} */
<i>136</i>&nbsp;    @Override
<i>137</i>&nbsp;    public Line copySelf() {
<b class="fc"><i>138</i>&nbsp;        return new Line(this);</b>
<i>139</i>&nbsp;    }
<i>140</i>&nbsp;
<i>141</i>&nbsp;    /** Reset the instance as if built from two points.
<i>142</i>&nbsp;     * &lt;p&gt;The line is oriented from p1 to p2&lt;/p&gt;
<i>143</i>&nbsp;     * @param p1 first point
<i>144</i>&nbsp;     * @param p2 second point
<i>145</i>&nbsp;     */
<i>146</i>&nbsp;    public void reset(final Cartesian2D p1, final Cartesian2D p2) {
<b class="fc"><i>147</i>&nbsp;        unlinkReverse();</b>
<b class="fc"><i>148</i>&nbsp;        final double dx = p2.getX() - p1.getX();</b>
<b class="fc"><i>149</i>&nbsp;        final double dy = p2.getY() - p1.getY();</b>
<b class="fc"><i>150</i>&nbsp;        final double d = FastMath.hypot(dx, dy);</b>
<b class="fc"><i>151</i>&nbsp;        if (d == 0.0) {</b>
<b class="nc"><i>152</i>&nbsp;            angle        = 0.0;</b>
<b class="nc"><i>153</i>&nbsp;            cos          = 1.0;</b>
<b class="nc"><i>154</i>&nbsp;            sin          = 0.0;</b>
<b class="nc"><i>155</i>&nbsp;            originOffset = p1.getY();</b>
<i>156</i>&nbsp;        } else {
<b class="fc"><i>157</i>&nbsp;            angle        = FastMath.PI + FastMath.atan2(-dy, -dx);</b>
<b class="fc"><i>158</i>&nbsp;            cos          = dx / d;</b>
<b class="fc"><i>159</i>&nbsp;            sin          = dy / d;</b>
<b class="fc"><i>160</i>&nbsp;            originOffset = LinearCombination.value(p2.getX(), p1.getY(), -p1.getX(), p2.getY()) / d;</b>
<i>161</i>&nbsp;        }
<b class="fc"><i>162</i>&nbsp;    }</b>
<i>163</i>&nbsp;
<i>164</i>&nbsp;    /** Reset the instance as if built from a line and an angle.
<i>165</i>&nbsp;     * @param p point belonging to the line
<i>166</i>&nbsp;     * @param alpha angle of the line with respect to abscissa axis
<i>167</i>&nbsp;     */
<i>168</i>&nbsp;    public void reset(final Cartesian2D p, final double alpha) {
<b class="fc"><i>169</i>&nbsp;        unlinkReverse();</b>
<b class="fc"><i>170</i>&nbsp;        this.angle   = PlaneAngleRadians.normalizeBetweenZeroAndTwoPi(alpha);</b>
<b class="fc"><i>171</i>&nbsp;        cos          = FastMath.cos(this.angle);</b>
<b class="fc"><i>172</i>&nbsp;        sin          = FastMath.sin(this.angle);</b>
<b class="fc"><i>173</i>&nbsp;        originOffset = LinearCombination.value(cos, p.getY(), -sin, p.getX());</b>
<b class="fc"><i>174</i>&nbsp;    }</b>
<i>175</i>&nbsp;
<i>176</i>&nbsp;    /** Revert the instance.
<i>177</i>&nbsp;     */
<i>178</i>&nbsp;    public void revertSelf() {
<b class="nc"><i>179</i>&nbsp;        unlinkReverse();</b>
<b class="nc"><i>180</i>&nbsp;        if (angle &lt; FastMath.PI) {</b>
<b class="nc"><i>181</i>&nbsp;            angle += FastMath.PI;</b>
<i>182</i>&nbsp;        } else {
<b class="nc"><i>183</i>&nbsp;            angle -= FastMath.PI;</b>
<i>184</i>&nbsp;        }
<b class="nc"><i>185</i>&nbsp;        cos          = -cos;</b>
<b class="nc"><i>186</i>&nbsp;        sin          = -sin;</b>
<b class="nc"><i>187</i>&nbsp;        originOffset = -originOffset;</b>
<b class="nc"><i>188</i>&nbsp;    }</b>
<i>189</i>&nbsp;
<i>190</i>&nbsp;    /** Unset the link between an instance and its reverse.
<i>191</i>&nbsp;     */
<i>192</i>&nbsp;    private void unlinkReverse() {
<b class="fc"><i>193</i>&nbsp;        if (reverse != null) {</b>
<b class="nc"><i>194</i>&nbsp;            reverse.reverse = null;</b>
<i>195</i>&nbsp;        }
<b class="fc"><i>196</i>&nbsp;        reverse = null;</b>
<b class="fc"><i>197</i>&nbsp;    }</b>
<i>198</i>&nbsp;
<i>199</i>&nbsp;    /** Get the reverse of the instance.
<i>200</i>&nbsp;     * &lt;p&gt;Get a line with reversed orientation with respect to the
<i>201</i>&nbsp;     * instance.&lt;/p&gt;
<i>202</i>&nbsp;     * &lt;p&gt;
<i>203</i>&nbsp;     * As long as neither the instance nor its reverse are modified
<i>204</i>&nbsp;     * (i.e. as long as none of the {@link #reset(Cartesian2D, Cartesian2D)},
<i>205</i>&nbsp;     * {@link #reset(Cartesian2D, double)}, {@link #revertSelf()},
<i>206</i>&nbsp;     * {@link #setAngle(double)} or {@link #setOriginOffset(double)}
<i>207</i>&nbsp;     * methods are called), then the line and its reverse remain linked
<i>208</i>&nbsp;     * together so that {@code line.getReverse().getReverse() == line}.
<i>209</i>&nbsp;     * When one of the line is modified, the link is deleted as both
<i>210</i>&nbsp;     * instance becomes independent.
<i>211</i>&nbsp;     * &lt;/p&gt;
<i>212</i>&nbsp;     * @return a new line, with orientation opposite to the instance orientation
<i>213</i>&nbsp;     */
<i>214</i>&nbsp;    public Line getReverse() {
<b class="fc"><i>215</i>&nbsp;        if (reverse == null) {</b>
<b class="fc"><i>216</i>&nbsp;            reverse = new Line((angle &lt; FastMath.PI) ? (angle + FastMath.PI) : (angle - FastMath.PI),</b>
<i>217</i>&nbsp;                               -cos, -sin, -originOffset, tolerance);
<b class="fc"><i>218</i>&nbsp;            reverse.reverse = this;</b>
<i>219</i>&nbsp;        }
<b class="fc"><i>220</i>&nbsp;        return reverse;</b>
<i>221</i>&nbsp;    }
<i>222</i>&nbsp;
<i>223</i>&nbsp;    /** Transform a space point into a sub-space point.
<i>224</i>&nbsp;     * @param vector n-dimension point of the space
<i>225</i>&nbsp;     * @return (n-1)-dimension point of the sub-space corresponding to
<i>226</i>&nbsp;     * the specified space point
<i>227</i>&nbsp;     */
<i>228</i>&nbsp;    public Cartesian1D toSubSpace(Vector&lt;Euclidean2D&gt; vector) {
<b class="nc"><i>229</i>&nbsp;        return toSubSpace((Cartesian2D) vector);</b>
<i>230</i>&nbsp;    }
<i>231</i>&nbsp;
<i>232</i>&nbsp;    /** Transform a sub-space point into a space point.
<i>233</i>&nbsp;     * @param vector (n-1)-dimension point of the sub-space
<i>234</i>&nbsp;     * @return n-dimension point of the space corresponding to the
<i>235</i>&nbsp;     * specified sub-space point
<i>236</i>&nbsp;     */
<i>237</i>&nbsp;    public Cartesian2D toSpace(Vector&lt;Euclidean1D&gt; vector) {
<b class="nc"><i>238</i>&nbsp;        return toSpace((Cartesian1D) vector);</b>
<i>239</i>&nbsp;    }
<i>240</i>&nbsp;
<i>241</i>&nbsp;    /** {@inheritDoc} */
<i>242</i>&nbsp;    @Override
<i>243</i>&nbsp;    public Cartesian1D toSubSpace(final Point&lt;Euclidean2D&gt; point) {
<b class="fc"><i>244</i>&nbsp;        return toSubSpace((Cartesian2D) point);</b>
<i>245</i>&nbsp;    }
<i>246</i>&nbsp;
<i>247</i>&nbsp;    /** {@inheritDoc} */
<i>248</i>&nbsp;    @Override
<i>249</i>&nbsp;    public Cartesian2D toSpace(final Point&lt;Euclidean1D&gt; point) {
<b class="fc"><i>250</i>&nbsp;        return toSpace((Cartesian1D) point);</b>
<i>251</i>&nbsp;    }
<i>252</i>&nbsp;
<i>253</i>&nbsp;    /** Transform a space point into a sub-space point.
<i>254</i>&nbsp;     * @param cartesian n-dimension point of the space
<i>255</i>&nbsp;     * @return (n-1)-dimension point of the sub-space corresponding to
<i>256</i>&nbsp;     * the specified space point
<i>257</i>&nbsp;     */
<i>258</i>&nbsp;    public Cartesian1D toSubSpace(final Cartesian2D cartesian) {
<b class="fc"><i>259</i>&nbsp;        return new Cartesian1D(LinearCombination.value(cos, cartesian.getX(), sin, cartesian.getY()));</b>
<i>260</i>&nbsp;    }
<i>261</i>&nbsp;
<i>262</i>&nbsp;    /** Transform a sub-space point into a space point.
<i>263</i>&nbsp;     * @param cartesian (n-1)-dimension point of the sub-space
<i>264</i>&nbsp;     * @return n-dimension point of the space corresponding to the
<i>265</i>&nbsp;     * specified sub-space point
<i>266</i>&nbsp;     */
<i>267</i>&nbsp;    public Cartesian2D toSpace(Cartesian1D cartesian) {
<b class="fc"><i>268</i>&nbsp;        final double abscissa = cartesian.getX();</b>
<b class="fc"><i>269</i>&nbsp;        return new Cartesian2D(LinearCombination.value(abscissa, cos, -originOffset, sin),</b>
<b class="fc"><i>270</i>&nbsp;                            LinearCombination.value(abscissa, sin,  originOffset, cos));</b>
<i>271</i>&nbsp;    }
<i>272</i>&nbsp;
<i>273</i>&nbsp;    /** Get the intersection point of the instance and another line.
<i>274</i>&nbsp;     * @param other other line
<i>275</i>&nbsp;     * @return intersection point of the instance and the other line
<i>276</i>&nbsp;     * or null if there are no intersection points
<i>277</i>&nbsp;     */
<i>278</i>&nbsp;    public Cartesian2D intersection(final Line other) {
<b class="fc"><i>279</i>&nbsp;        final double d = LinearCombination.value(sin, other.cos, -other.sin, cos);</b>
<b class="fc"><i>280</i>&nbsp;        if (FastMath.abs(d) &lt; tolerance) {</b>
<b class="fc"><i>281</i>&nbsp;            return null;</b>
<i>282</i>&nbsp;        }
<b class="fc"><i>283</i>&nbsp;        return new Cartesian2D(LinearCombination.value(cos, other.originOffset, -other.cos, originOffset) / d,</b>
<b class="fc"><i>284</i>&nbsp;                            LinearCombination.value(sin, other.originOffset, -other.sin, originOffset) / d);</b>
<i>285</i>&nbsp;    }
<i>286</i>&nbsp;
<i>287</i>&nbsp;    /** {@inheritDoc}
<i>288</i>&nbsp;     * @since 3.3
<i>289</i>&nbsp;     */
<i>290</i>&nbsp;    @Override
<i>291</i>&nbsp;    public Point&lt;Euclidean2D&gt; project(Point&lt;Euclidean2D&gt; point) {
<b class="fc"><i>292</i>&nbsp;        return toSpace(toSubSpace(point));</b>
<i>293</i>&nbsp;    }
<i>294</i>&nbsp;
<i>295</i>&nbsp;    /** {@inheritDoc}
<i>296</i>&nbsp;     * @since 3.3
<i>297</i>&nbsp;     */
<i>298</i>&nbsp;    @Override
<i>299</i>&nbsp;    public double getTolerance() {
<b class="fc"><i>300</i>&nbsp;        return tolerance;</b>
<i>301</i>&nbsp;    }
<i>302</i>&nbsp;
<i>303</i>&nbsp;    /** {@inheritDoc} */
<i>304</i>&nbsp;    @Override
<i>305</i>&nbsp;    public SubLine wholeHyperplane() {
<b class="fc"><i>306</i>&nbsp;        return new SubLine(this, new IntervalsSet(tolerance));</b>
<i>307</i>&nbsp;    }
<i>308</i>&nbsp;
<i>309</i>&nbsp;    /** Build a region covering the whole space.
<i>310</i>&nbsp;     * @return a region containing the instance (really a {@link
<i>311</i>&nbsp;     * PolygonsSet PolygonsSet} instance)
<i>312</i>&nbsp;     */
<i>313</i>&nbsp;    @Override
<i>314</i>&nbsp;    public PolygonsSet wholeSpace() {
<b class="fc"><i>315</i>&nbsp;        return new PolygonsSet(tolerance);</b>
<i>316</i>&nbsp;    }
<i>317</i>&nbsp;
<i>318</i>&nbsp;    /** Get the offset (oriented distance) of a parallel line.
<i>319</i>&nbsp;     * &lt;p&gt;This method should be called only for parallel lines otherwise
<i>320</i>&nbsp;     * the result is not meaningful.&lt;/p&gt;
<i>321</i>&nbsp;     * &lt;p&gt;The offset is 0 if both lines are the same, it is
<i>322</i>&nbsp;     * positive if the line is on the right side of the instance and
<i>323</i>&nbsp;     * negative if it is on the left side, according to its natural
<i>324</i>&nbsp;     * orientation.&lt;/p&gt;
<i>325</i>&nbsp;     * @param line line to check
<i>326</i>&nbsp;     * @return offset of the line
<i>327</i>&nbsp;     */
<i>328</i>&nbsp;    public double getOffset(final Line line) {
<b class="fc"><i>329</i>&nbsp;        return originOffset +</b>
<b class="fc"><i>330</i>&nbsp;               (LinearCombination.value(cos, line.cos, sin, line.sin) &gt; 0 ? -line.originOffset : line.originOffset);</b>
<i>331</i>&nbsp;    }
<i>332</i>&nbsp;
<i>333</i>&nbsp;    /** Get the offset (oriented distance) of a vector.
<i>334</i>&nbsp;     * @param vector vector to check
<i>335</i>&nbsp;     * @return offset of the vector
<i>336</i>&nbsp;     */
<i>337</i>&nbsp;    public double getOffset(Vector&lt;Euclidean2D&gt; vector) {
<b class="nc"><i>338</i>&nbsp;        return getOffset((Cartesian2D) vector);</b>
<i>339</i>&nbsp;    }
<i>340</i>&nbsp;
<i>341</i>&nbsp;    /** {@inheritDoc} */
<i>342</i>&nbsp;    @Override
<i>343</i>&nbsp;    public double getOffset(final Point&lt;Euclidean2D&gt; point) {
<b class="fc"><i>344</i>&nbsp;        return getOffset((Cartesian2D) point);</b>
<i>345</i>&nbsp;    }
<i>346</i>&nbsp;
<i>347</i>&nbsp;    /** Get the offset (oriented distance) of a point.
<i>348</i>&nbsp;     * @param cartesian point to check
<i>349</i>&nbsp;     * @return offset of the point
<i>350</i>&nbsp;     */
<i>351</i>&nbsp;    public double getOffset(Cartesian2D cartesian) {
<b class="fc"><i>352</i>&nbsp;        return LinearCombination.value(sin, cartesian.getX(), -cos, cartesian.getY(), 1.0, originOffset);</b>
<i>353</i>&nbsp;    }
<i>354</i>&nbsp;
<i>355</i>&nbsp;    /** {@inheritDoc} */
<i>356</i>&nbsp;    @Override
<i>357</i>&nbsp;    public boolean sameOrientationAs(final Hyperplane&lt;Euclidean2D&gt; other) {
<b class="fc"><i>358</i>&nbsp;        final Line otherL = (Line) other;</b>
<b class="fc"><i>359</i>&nbsp;        return LinearCombination.value(sin, otherL.sin, cos, otherL.cos) &gt;= 0.0;</b>
<i>360</i>&nbsp;    }
<i>361</i>&nbsp;
<i>362</i>&nbsp;    /** Get one point from the plane.
<i>363</i>&nbsp;     * @param abscissa desired abscissa for the point
<i>364</i>&nbsp;     * @param offset desired offset for the point
<i>365</i>&nbsp;     * @return one point in the plane, with given abscissa and offset
<i>366</i>&nbsp;     * relative to the line
<i>367</i>&nbsp;     */
<i>368</i>&nbsp;    public Cartesian2D getPointAt(final Cartesian1D abscissa, final double offset) {
<b class="fc"><i>369</i>&nbsp;        final double x       = abscissa.getX();</b>
<b class="fc"><i>370</i>&nbsp;        final double dOffset = offset - originOffset;</b>
<b class="fc"><i>371</i>&nbsp;        return new Cartesian2D(LinearCombination.value(x, cos,  dOffset, sin),</b>
<b class="fc"><i>372</i>&nbsp;                            LinearCombination.value(x, sin, -dOffset, cos));</b>
<i>373</i>&nbsp;    }
<i>374</i>&nbsp;
<i>375</i>&nbsp;    /** Check if the line contains a point.
<i>376</i>&nbsp;     * @param p point to check
<i>377</i>&nbsp;     * @return true if p belongs to the line
<i>378</i>&nbsp;     */
<i>379</i>&nbsp;    public boolean contains(final Cartesian2D p) {
<b class="fc"><i>380</i>&nbsp;        return FastMath.abs(getOffset(p)) &lt; tolerance;</b>
<i>381</i>&nbsp;    }
<i>382</i>&nbsp;
<i>383</i>&nbsp;    /** Compute the distance between the instance and a point.
<i>384</i>&nbsp;     * &lt;p&gt;This is a shortcut for invoking FastMath.abs(getOffset(p)),
<i>385</i>&nbsp;     * and provides consistency with what is in the
<i>386</i>&nbsp;     * org.apache.commons.math4.geometry.euclidean.threed.Line class.&lt;/p&gt;
<i>387</i>&nbsp;     *
<i>388</i>&nbsp;     * @param p to check
<i>389</i>&nbsp;     * @return distance between the instance and the point
<i>390</i>&nbsp;     * @since 3.1
<i>391</i>&nbsp;     */
<i>392</i>&nbsp;    public double distance(final Cartesian2D p) {
<b class="fc"><i>393</i>&nbsp;        return FastMath.abs(getOffset(p));</b>
<i>394</i>&nbsp;    }
<i>395</i>&nbsp;
<i>396</i>&nbsp;    /** Check the instance is parallel to another line.
<i>397</i>&nbsp;     * @param line other line to check
<i>398</i>&nbsp;     * @return true if the instance is parallel to the other line
<i>399</i>&nbsp;     * (they can have either the same or opposite orientations)
<i>400</i>&nbsp;     */
<i>401</i>&nbsp;    public boolean isParallelTo(final Line line) {
<b class="fc"><i>402</i>&nbsp;        return FastMath.abs(LinearCombination.value(sin, line.cos, -cos, line.sin)) &lt; tolerance;</b>
<i>403</i>&nbsp;    }
<i>404</i>&nbsp;
<i>405</i>&nbsp;    /** Translate the line to force it passing by a point.
<i>406</i>&nbsp;     * @param p point by which the line should pass
<i>407</i>&nbsp;     */
<i>408</i>&nbsp;    public void translateToPoint(final Cartesian2D p) {
<b class="nc"><i>409</i>&nbsp;        originOffset = LinearCombination.value(cos, p.getY(), -sin, p.getX());</b>
<b class="nc"><i>410</i>&nbsp;    }</b>
<i>411</i>&nbsp;
<i>412</i>&nbsp;    /** Get the angle of the line.
<i>413</i>&nbsp;     * @return the angle of the line with respect to the abscissa axis
<i>414</i>&nbsp;     */
<i>415</i>&nbsp;    public double getAngle() {
<b class="fc"><i>416</i>&nbsp;        return PlaneAngleRadians.normalizeBetweenZeroAndTwoPi(angle);</b>
<i>417</i>&nbsp;    }
<i>418</i>&nbsp;
<i>419</i>&nbsp;    /** Set the angle of the line.
<i>420</i>&nbsp;     * @param angle new angle of the line with respect to the abscissa axis
<i>421</i>&nbsp;     */
<i>422</i>&nbsp;    public void setAngle(final double angle) {
<b class="nc"><i>423</i>&nbsp;        unlinkReverse();</b>
<b class="nc"><i>424</i>&nbsp;        this.angle = PlaneAngleRadians.normalizeBetweenZeroAndTwoPi(angle);</b>
<b class="nc"><i>425</i>&nbsp;        cos        = FastMath.cos(this.angle);</b>
<b class="nc"><i>426</i>&nbsp;        sin        = FastMath.sin(this.angle);</b>
<b class="nc"><i>427</i>&nbsp;    }</b>
<i>428</i>&nbsp;
<i>429</i>&nbsp;    /** Get the offset of the origin.
<i>430</i>&nbsp;     * @return the offset of the origin
<i>431</i>&nbsp;     */
<i>432</i>&nbsp;    public double getOriginOffset() {
<b class="fc"><i>433</i>&nbsp;        return originOffset;</b>
<i>434</i>&nbsp;    }
<i>435</i>&nbsp;
<i>436</i>&nbsp;    /** Set the offset of the origin.
<i>437</i>&nbsp;     * @param offset offset of the origin
<i>438</i>&nbsp;     */
<i>439</i>&nbsp;    public void setOriginOffset(final double offset) {
<b class="nc"><i>440</i>&nbsp;        unlinkReverse();</b>
<b class="nc"><i>441</i>&nbsp;        originOffset = offset;</b>
<b class="nc"><i>442</i>&nbsp;    }</b>
<i>443</i>&nbsp;
<i>444</i>&nbsp;    /** Get a {@link org.apache.commons.math4.geometry.partitioning.Transform
<i>445</i>&nbsp;     * Transform} embedding an affine transform.
<i>446</i>&nbsp;     * @param cXX transform factor between input abscissa and output abscissa
<i>447</i>&nbsp;     * @param cYX transform factor between input abscissa and output ordinate
<i>448</i>&nbsp;     * @param cXY transform factor between input ordinate and output abscissa
<i>449</i>&nbsp;     * @param cYY transform factor between input ordinate and output ordinate
<i>450</i>&nbsp;     * @param cX1 transform addendum for output abscissa
<i>451</i>&nbsp;     * @param cY1 transform addendum for output ordinate
<i>452</i>&nbsp;     * @return a new transform that can be applied to either {@link
<i>453</i>&nbsp;     * Cartesian2D}, {@link Line Line} or {@link
<i>454</i>&nbsp;     * org.apache.commons.math4.geometry.partitioning.SubHyperplane
<i>455</i>&nbsp;     * SubHyperplane} instances
<i>456</i>&nbsp;     * @exception MathIllegalArgumentException if the transform is non invertible
<i>457</i>&nbsp;     * @since 4.0
<i>458</i>&nbsp;     */
<i>459</i>&nbsp;    public static Transform&lt;Euclidean2D, Euclidean1D&gt; getTransform(final double cXX,
<i>460</i>&nbsp;                                                                   final double cYX,
<i>461</i>&nbsp;                                                                   final double cXY,
<i>462</i>&nbsp;                                                                   final double cYY,
<i>463</i>&nbsp;                                                                   final double cX1,
<i>464</i>&nbsp;                                                                   final double cY1)
<i>465</i>&nbsp;        throws MathIllegalArgumentException {
<b class="fc"><i>466</i>&nbsp;        return new LineTransform(cXX, cYX, cXY, cYY, cX1, cY1);</b>
<i>467</i>&nbsp;    }
<i>468</i>&nbsp;
<i>469</i>&nbsp;    /** Class embedding an affine transform.
<i>470</i>&nbsp;     * &lt;p&gt;This class is used in order to apply an affine transform to a
<i>471</i>&nbsp;     * line. Using a specific object allow to perform some computations
<i>472</i>&nbsp;     * on the transform only once even if the same transform is to be
<i>473</i>&nbsp;     * applied to a large number of lines (for example to a large
<i>474</i>&nbsp;     * polygon)./&lt;p&gt;
<i>475</i>&nbsp;     */
<i>476</i>&nbsp;    private static class LineTransform implements Transform&lt;Euclidean2D, Euclidean1D&gt; {
<i>477</i>&nbsp;
<i>478</i>&nbsp;        /** Transform factor between input abscissa and output abscissa. */
<i>479</i>&nbsp;        private final double cXX;
<i>480</i>&nbsp;
<i>481</i>&nbsp;        /** Transform factor between input abscissa and output ordinate. */
<i>482</i>&nbsp;        private final double cYX;
<i>483</i>&nbsp;
<i>484</i>&nbsp;        /** Transform factor between input ordinate and output abscissa. */
<i>485</i>&nbsp;        private final double cXY;
<i>486</i>&nbsp;
<i>487</i>&nbsp;        /** Transform factor between input ordinate and output ordinate. */
<i>488</i>&nbsp;        private final double cYY;
<i>489</i>&nbsp;
<i>490</i>&nbsp;        /** Transform addendum for output abscissa. */
<i>491</i>&nbsp;        private final double cX1;
<i>492</i>&nbsp;
<i>493</i>&nbsp;        /** Transform addendum for output ordinate. */
<i>494</i>&nbsp;        private final double cY1;
<i>495</i>&nbsp;
<i>496</i>&nbsp;        /** cXY * cY1 - cYY * cX1. */
<i>497</i>&nbsp;        private final double c1Y;
<i>498</i>&nbsp;
<i>499</i>&nbsp;        /** cXX * cY1 - cYX * cX1. */
<i>500</i>&nbsp;        private final double c1X;
<i>501</i>&nbsp;
<i>502</i>&nbsp;        /** cXX * cYY - cYX * cXY. */
<i>503</i>&nbsp;        private final double c11;
<i>504</i>&nbsp;
<i>505</i>&nbsp;        /** Build an affine line transform from a n {@code AffineTransform}.
<i>506</i>&nbsp;         * @param cXX transform factor between input abscissa and output abscissa
<i>507</i>&nbsp;         * @param cYX transform factor between input abscissa and output ordinate
<i>508</i>&nbsp;         * @param cXY transform factor between input ordinate and output abscissa
<i>509</i>&nbsp;         * @param cYY transform factor between input ordinate and output ordinate
<i>510</i>&nbsp;         * @param cX1 transform addendum for output abscissa
<i>511</i>&nbsp;         * @param cY1 transform addendum for output ordinate
<i>512</i>&nbsp;         * @exception MathIllegalArgumentException if the transform is non invertible
<i>513</i>&nbsp;         * @since 4.0
<i>514</i>&nbsp;         */
<i>515</i>&nbsp;        LineTransform(final double cXX, final double cYX, final double cXY,
<i>516</i>&nbsp;                      final double cYY, final double cX1, final double cY1)
<b class="fc"><i>517</i>&nbsp;            throws MathIllegalArgumentException {</b>
<i>518</i>&nbsp;
<b class="fc"><i>519</i>&nbsp;            this.cXX = cXX;</b>
<b class="fc"><i>520</i>&nbsp;            this.cYX = cYX;</b>
<b class="fc"><i>521</i>&nbsp;            this.cXY = cXY;</b>
<b class="fc"><i>522</i>&nbsp;            this.cYY = cYY;</b>
<b class="fc"><i>523</i>&nbsp;            this.cX1 = cX1;</b>
<b class="fc"><i>524</i>&nbsp;            this.cY1 = cY1;</b>
<i>525</i>&nbsp;
<b class="fc"><i>526</i>&nbsp;            c1Y = LinearCombination.value(cXY, cY1, -cYY, cX1);</b>
<b class="fc"><i>527</i>&nbsp;            c1X = LinearCombination.value(cXX, cY1, -cYX, cX1);</b>
<b class="fc"><i>528</i>&nbsp;            c11 = LinearCombination.value(cXX, cYY, -cYX, cXY);</b>
<i>529</i>&nbsp;
<b class="fc"><i>530</i>&nbsp;            if (FastMath.abs(c11) &lt; 1.0e-20) {</b>
<b class="nc"><i>531</i>&nbsp;                throw new MathIllegalArgumentException(LocalizedFormats.NON_INVERTIBLE_TRANSFORM);</b>
<i>532</i>&nbsp;            }
<i>533</i>&nbsp;
<b class="fc"><i>534</i>&nbsp;        }</b>
<i>535</i>&nbsp;
<i>536</i>&nbsp;        /** {@inheritDoc} */
<i>537</i>&nbsp;        @Override
<i>538</i>&nbsp;        public Cartesian2D apply(final Point&lt;Euclidean2D&gt; point) {
<b class="fc"><i>539</i>&nbsp;            final Cartesian2D p2D = (Cartesian2D) point;</b>
<b class="fc"><i>540</i>&nbsp;            final double  x   = p2D.getX();</b>
<b class="fc"><i>541</i>&nbsp;            final double  y   = p2D.getY();</b>
<b class="fc"><i>542</i>&nbsp;            return new Cartesian2D(LinearCombination.value(cXX, x, cXY, y, cX1, 1),</b>
<b class="fc"><i>543</i>&nbsp;                                LinearCombination.value(cYX, x, cYY, y, cY1, 1));</b>
<i>544</i>&nbsp;        }
<i>545</i>&nbsp;
<i>546</i>&nbsp;        /** {@inheritDoc} */
<i>547</i>&nbsp;        @Override
<i>548</i>&nbsp;        public Line apply(final Hyperplane&lt;Euclidean2D&gt; hyperplane) {
<b class="fc"><i>549</i>&nbsp;            final Line   line    = (Line) hyperplane;</b>
<b class="fc"><i>550</i>&nbsp;            final double rOffset = LinearCombination.value(c1X, line.cos, c1Y, line.sin, c11, line.originOffset);</b>
<b class="fc"><i>551</i>&nbsp;            final double rCos    = LinearCombination.value(cXX, line.cos, cXY, line.sin);</b>
<b class="fc"><i>552</i>&nbsp;            final double rSin    = LinearCombination.value(cYX, line.cos, cYY, line.sin);</b>
<b class="fc"><i>553</i>&nbsp;            final double inv     = 1.0 / FastMath.sqrt(rSin * rSin + rCos * rCos);</b>
<b class="fc"><i>554</i>&nbsp;            return new Line(FastMath.PI + FastMath.atan2(-rSin, -rCos),</b>
<i>555</i>&nbsp;                            inv * rCos, inv * rSin,
<b class="fc"><i>556</i>&nbsp;                            inv * rOffset, line.tolerance);</b>
<i>557</i>&nbsp;        }
<i>558</i>&nbsp;
<i>559</i>&nbsp;        /** {@inheritDoc} */
<i>560</i>&nbsp;        @Override
<i>561</i>&nbsp;        public SubHyperplane&lt;Euclidean1D&gt; apply(final SubHyperplane&lt;Euclidean1D&gt; sub,
<i>562</i>&nbsp;                                                final Hyperplane&lt;Euclidean2D&gt; original,
<i>563</i>&nbsp;                                                final Hyperplane&lt;Euclidean2D&gt; transformed) {
<b class="fc"><i>564</i>&nbsp;            final OrientedPoint op     = (OrientedPoint) sub.getHyperplane();</b>
<b class="fc"><i>565</i>&nbsp;            final Line originalLine    = (Line) original;</b>
<b class="fc"><i>566</i>&nbsp;            final Line transformedLine = (Line) transformed;</b>
<b class="fc"><i>567</i>&nbsp;            final Cartesian1D newLoc =</b>
<b class="fc"><i>568</i>&nbsp;                transformedLine.toSubSpace(apply(originalLine.toSpace(op.getLocation())));</b>
<b class="fc"><i>569</i>&nbsp;            return new OrientedPoint(newLoc, op.isDirect(), originalLine.tolerance).wholeHyperplane();</b>
<i>570</i>&nbsp;        }
<i>571</i>&nbsp;
<i>572</i>&nbsp;    }
<i>573</i>&nbsp;
<i>574</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2019-06-04 09:26</div>
</div>
</body>
</html>
