


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: FastMath</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">org.apache.commons.math4.util</a> ]
</div>

<h1>Coverage Summary for Class: FastMath (org.apache.commons.math4.util)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">FastMath</td>
<td class="coverageStat">
  <span class="percent">
    95.6%
  </span>
  <span class="absValue">
    (87/ 91)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    97.2%
  </span>
  <span class="absValue">
    (1452/ 1494)
  </span>
</td>
</tr>
  <tr>
    <td class="name">FastMath$CodyWaite</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (24/ 24)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FastMath$ExpFracTable</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/ 4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FastMath$ExpIntTable</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/ 4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FastMath$lnMant</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/ 3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FastMath$Split</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (8/ 8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    97.4%
  </span>
  <span class="absValue">
    (38/ 39)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>total</strong></td>
<td class="coverageStat">
  <span class="percent">
    96.3%
  </span>
  <span class="absValue">
    (105/ 109)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    97.3%
  </span>
  <span class="absValue">
    (1525/ 1568)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;/*
<i>2</i>&nbsp; * Licensed to the Apache Software Foundation (ASF) under one or more
<i>3</i>&nbsp; * contributor license agreements.  See the NOTICE file distributed with
<i>4</i>&nbsp; * this work for additional information regarding copyright ownership.
<i>5</i>&nbsp; * The ASF licenses this file to You under the Apache License, Version 2.0
<i>6</i>&nbsp; * (the &quot;License&quot;); you may not use this file except in compliance with
<i>7</i>&nbsp; * the License.  You may obtain a copy of the License at
<i>8</i>&nbsp; *
<i>9</i>&nbsp; *      http://www.apache.org/licenses/LICENSE-2.0
<i>10</i>&nbsp; *
<i>11</i>&nbsp; * Unless required by applicable law or agreed to in writing, software
<i>12</i>&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
<i>13</i>&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
<i>14</i>&nbsp; * See the License for the specific language governing permissions and
<i>15</i>&nbsp; * limitations under the License.
<i>16</i>&nbsp; */
<i>17</i>&nbsp;package org.apache.commons.math4.util;
<i>18</i>&nbsp;
<i>19</i>&nbsp;import java.io.PrintStream;
<i>20</i>&nbsp;
<i>21</i>&nbsp;import org.apache.commons.numbers.core.Precision;
<i>22</i>&nbsp;import org.apache.commons.math4.exception.MathArithmeticException;
<i>23</i>&nbsp;import org.apache.commons.math4.exception.util.LocalizedFormats;
<i>24</i>&nbsp;
<i>25</i>&nbsp;/**
<i>26</i>&nbsp; * Faster, more accurate, portable alternative to {@link Math} and
<i>27</i>&nbsp; * {@link StrictMath} for large scale computation.
<i>28</i>&nbsp; * &lt;p&gt;
<i>29</i>&nbsp; * FastMath is a drop-in replacement for both Math and StrictMath. This
<i>30</i>&nbsp; * means that for any method in Math (say {@code Math.sin(x)} or
<i>31</i>&nbsp; * {@code Math.cbrt(y)}), user can directly change the class and use the
<i>32</i>&nbsp; * methods as is (using {@code FastMath.sin(x)} or {@code FastMath.cbrt(y)}
<i>33</i>&nbsp; * in the previous example).
<i>34</i>&nbsp; * &lt;/p&gt;
<i>35</i>&nbsp; * &lt;p&gt;
<i>36</i>&nbsp; * FastMath speed is achieved by relying heavily on optimizing compilers
<i>37</i>&nbsp; * to native code present in many JVMs today and use of large tables.
<i>38</i>&nbsp; * The larger tables are lazily initialized on first use, so that the setup
<i>39</i>&nbsp; * time does not penalize methods that don&#39;t need them.
<i>40</i>&nbsp; * &lt;/p&gt;
<i>41</i>&nbsp; * &lt;p&gt;
<i>42</i>&nbsp; * Note that FastMath is
<i>43</i>&nbsp; * extensively used inside Apache Commons Math, so by calling some algorithms,
<i>44</i>&nbsp; * the overhead when the tables need to be initialized will occur
<i>45</i>&nbsp; * regardless of the end-user calling FastMath methods directly or not.
<i>46</i>&nbsp; * Performance figures for a specific JVM and hardware can be evaluated by
<i>47</i>&nbsp; * running the FastMathTestPerformance tests in the test directory of the source
<i>48</i>&nbsp; * distribution.
<i>49</i>&nbsp; * &lt;/p&gt;
<i>50</i>&nbsp; * &lt;p&gt;
<i>51</i>&nbsp; * FastMath accuracy should be mostly independent of the JVM as it relies only
<i>52</i>&nbsp; * on IEEE-754 basic operations and on embedded tables. Almost all operations
<i>53</i>&nbsp; * are accurate to about 0.5 ulp throughout the domain range. This statement,
<i>54</i>&nbsp; * of course is only a rough global observed behavior, it is &lt;em&gt;not&lt;/em&gt; a
<i>55</i>&nbsp; * guarantee for &lt;em&gt;every&lt;/em&gt; double numbers input (see William Kahan&#39;s &lt;a
<i>56</i>&nbsp; * href=&quot;http://en.wikipedia.org/wiki/Rounding#The_table-maker.27s_dilemma&quot;&gt;Table
<i>57</i>&nbsp; * Maker&#39;s Dilemma&lt;/a&gt;).
<i>58</i>&nbsp; * &lt;/p&gt;
<i>59</i>&nbsp; * &lt;p&gt;
<i>60</i>&nbsp; * FastMath additionally implements the following methods not found in Math/StrictMath:
<i>61</i>&nbsp; * &lt;ul&gt;
<i>62</i>&nbsp; * &lt;li&gt;{@link #asinh(double)}&lt;/li&gt;
<i>63</i>&nbsp; * &lt;li&gt;{@link #acosh(double)}&lt;/li&gt;
<i>64</i>&nbsp; * &lt;li&gt;{@link #atanh(double)}&lt;/li&gt;
<i>65</i>&nbsp; * &lt;/ul&gt;
<i>66</i>&nbsp; * The following methods are found in Math/StrictMath since 1.6 only, they are provided
<i>67</i>&nbsp; * by FastMath even in 1.5 Java virtual machines
<i>68</i>&nbsp; * &lt;ul&gt;
<i>69</i>&nbsp; * &lt;li&gt;{@link #copySign(double, double)}&lt;/li&gt;
<i>70</i>&nbsp; * &lt;li&gt;{@link #getExponent(double)}&lt;/li&gt;
<i>71</i>&nbsp; * &lt;li&gt;{@link #nextAfter(double,double)}&lt;/li&gt;
<i>72</i>&nbsp; * &lt;li&gt;{@link #nextUp(double)}&lt;/li&gt;
<i>73</i>&nbsp; * &lt;li&gt;{@link #scalb(double, int)}&lt;/li&gt;
<i>74</i>&nbsp; * &lt;li&gt;{@link #copySign(float, float)}&lt;/li&gt;
<i>75</i>&nbsp; * &lt;li&gt;{@link #getExponent(float)}&lt;/li&gt;
<i>76</i>&nbsp; * &lt;li&gt;{@link #nextAfter(float,double)}&lt;/li&gt;
<i>77</i>&nbsp; * &lt;li&gt;{@link #nextUp(float)}&lt;/li&gt;
<i>78</i>&nbsp; * &lt;li&gt;{@link #scalb(float, int)}&lt;/li&gt;
<i>79</i>&nbsp; * &lt;/ul&gt;
<i>80</i>&nbsp; * @since 2.2
<i>81</i>&nbsp; */
<i>82</i>&nbsp;public class FastMath {
<i>83</i>&nbsp;    /** Archimede&#39;s constant PI, ratio of circle circumference to diameter. */
<i>84</i>&nbsp;    public static final double PI = 105414357.0 / 33554432.0 + 1.984187159361080883e-9;
<i>85</i>&nbsp;
<i>86</i>&nbsp;    /** Napier&#39;s constant e, base of the natural logarithm. */
<i>87</i>&nbsp;    public static final double E = 2850325.0 / 1048576.0 + 8.254840070411028747e-8;
<i>88</i>&nbsp;
<i>89</i>&nbsp;    /** Index of exp(0) in the array of integer exponentials. */
<i>90</i>&nbsp;    static final int EXP_INT_TABLE_MAX_INDEX = 750;
<i>91</i>&nbsp;    /** Length of the array of integer exponentials. */
<i>92</i>&nbsp;    static final int EXP_INT_TABLE_LEN = EXP_INT_TABLE_MAX_INDEX * 2;
<i>93</i>&nbsp;    /** Logarithm table length. */
<i>94</i>&nbsp;    static final int LN_MANT_LEN = 1024;
<i>95</i>&nbsp;    /** Exponential fractions table length. */
<i>96</i>&nbsp;    static final int EXP_FRAC_TABLE_LEN = 1025; // 0, 1/1024, ... 1024/1024
<i>97</i>&nbsp;
<i>98</i>&nbsp;    /** StrictMath.log(Double.MAX_VALUE): {@value} */
<b class="fc"><i>99</i>&nbsp;    private static final double LOG_MAX_VALUE = StrictMath.log(Double.MAX_VALUE);</b>
<i>100</i>&nbsp;
<i>101</i>&nbsp;    /** Indicator for tables initialization.
<i>102</i>&nbsp;     * &lt;p&gt;
<i>103</i>&nbsp;     * This compile-time constant should be set to true only if one explicitly
<i>104</i>&nbsp;     * wants to compute the tables at class loading time instead of using the
<i>105</i>&nbsp;     * already computed ones provided as literal arrays below.
<i>106</i>&nbsp;     * &lt;/p&gt;
<i>107</i>&nbsp;     */
<i>108</i>&nbsp;    private static final boolean RECOMPUTE_TABLES_AT_RUNTIME = false;
<i>109</i>&nbsp;
<i>110</i>&nbsp;    /** log(2) (high bits). */
<i>111</i>&nbsp;    private static final double LN_2_A = 0.693147063255310059;
<i>112</i>&nbsp;
<i>113</i>&nbsp;    /** log(2) (low bits). */
<i>114</i>&nbsp;    private static final double LN_2_B = 1.17304635250823482e-7;
<i>115</i>&nbsp;
<i>116</i>&nbsp;    /** Coefficients for log, when input 0.99 &lt; x &lt; 1.01. */
<b class="fc"><i>117</i>&nbsp;    private static final double LN_QUICK_COEF[][] = {</b>
<i>118</i>&nbsp;        {1.0, 5.669184079525E-24},
<i>119</i>&nbsp;        {-0.25, -0.25},
<i>120</i>&nbsp;        {0.3333333134651184, 1.986821492305628E-8},
<i>121</i>&nbsp;        {-0.25, -6.663542893624021E-14},
<i>122</i>&nbsp;        {0.19999998807907104, 1.1921056801463227E-8},
<i>123</i>&nbsp;        {-0.1666666567325592, -7.800414592973399E-9},
<i>124</i>&nbsp;        {0.1428571343421936, 5.650007086920087E-9},
<i>125</i>&nbsp;        {-0.12502530217170715, -7.44321345601866E-11},
<i>126</i>&nbsp;        {0.11113807559013367, 9.219544613762692E-9},
<i>127</i>&nbsp;    };
<i>128</i>&nbsp;
<i>129</i>&nbsp;    /** Coefficients for log in the range of 1.0 &lt; x &lt; 1.0 + 2^-10. */
<b class="fc"><i>130</i>&nbsp;    private static final double LN_HI_PREC_COEF[][] = {</b>
<i>131</i>&nbsp;        {1.0, -6.032174644509064E-23},
<i>132</i>&nbsp;        {-0.25, -0.25},
<i>133</i>&nbsp;        {0.3333333134651184, 1.9868161777724352E-8},
<i>134</i>&nbsp;        {-0.2499999701976776, -2.957007209750105E-8},
<i>135</i>&nbsp;        {0.19999954104423523, 1.5830993332061267E-10},
<i>136</i>&nbsp;        {-0.16624879837036133, -2.6033824355191673E-8}
<i>137</i>&nbsp;    };
<i>138</i>&nbsp;
<i>139</i>&nbsp;    /** Sine, Cosine, Tangent tables are for 0, 1/8, 2/8, ... 13/8 = PI/2 approx. */
<i>140</i>&nbsp;    private static final int SINE_TABLE_LEN = 14;
<i>141</i>&nbsp;
<i>142</i>&nbsp;    /** Sine table (high bits). */
<b class="fc"><i>143</i>&nbsp;    private static final double SINE_TABLE_A[] =</b>
<i>144</i>&nbsp;        {
<i>145</i>&nbsp;        +0.0d,
<i>146</i>&nbsp;        +0.1246747374534607d,
<i>147</i>&nbsp;        +0.24740394949913025d,
<i>148</i>&nbsp;        +0.366272509098053d,
<i>149</i>&nbsp;        +0.4794255495071411d,
<i>150</i>&nbsp;        +0.5850973129272461d,
<i>151</i>&nbsp;        +0.6816387176513672d,
<i>152</i>&nbsp;        +0.7675435543060303d,
<i>153</i>&nbsp;        +0.8414709568023682d,
<i>154</i>&nbsp;        +0.902267575263977d,
<i>155</i>&nbsp;        +0.9489846229553223d,
<i>156</i>&nbsp;        +0.9808930158615112d,
<i>157</i>&nbsp;        +0.9974949359893799d,
<i>158</i>&nbsp;        +0.9985313415527344d,
<i>159</i>&nbsp;    };
<i>160</i>&nbsp;
<i>161</i>&nbsp;    /** Sine table (low bits). */
<b class="fc"><i>162</i>&nbsp;    private static final double SINE_TABLE_B[] =</b>
<i>163</i>&nbsp;        {
<i>164</i>&nbsp;        +0.0d,
<i>165</i>&nbsp;        -4.068233003401932E-9d,
<i>166</i>&nbsp;        +9.755392680573412E-9d,
<i>167</i>&nbsp;        +1.9987994582857286E-8d,
<i>168</i>&nbsp;        -1.0902938113007961E-8d,
<i>169</i>&nbsp;        -3.9986783938944604E-8d,
<i>170</i>&nbsp;        +4.23719669792332E-8d,
<i>171</i>&nbsp;        -5.207000323380292E-8d,
<i>172</i>&nbsp;        +2.800552834259E-8d,
<i>173</i>&nbsp;        +1.883511811213715E-8d,
<i>174</i>&nbsp;        -3.5997360512765566E-9d,
<i>175</i>&nbsp;        +4.116164446561962E-8d,
<i>176</i>&nbsp;        +5.0614674548127384E-8d,
<i>177</i>&nbsp;        -1.0129027912496858E-9d,
<i>178</i>&nbsp;    };
<i>179</i>&nbsp;
<i>180</i>&nbsp;    /** Cosine table (high bits). */
<b class="fc"><i>181</i>&nbsp;    private static final double COSINE_TABLE_A[] =</b>
<i>182</i>&nbsp;        {
<i>183</i>&nbsp;        +1.0d,
<i>184</i>&nbsp;        +0.9921976327896118d,
<i>185</i>&nbsp;        +0.9689123630523682d,
<i>186</i>&nbsp;        +0.9305076599121094d,
<i>187</i>&nbsp;        +0.8775825500488281d,
<i>188</i>&nbsp;        +0.8109631538391113d,
<i>189</i>&nbsp;        +0.7316888570785522d,
<i>190</i>&nbsp;        +0.6409968137741089d,
<i>191</i>&nbsp;        +0.5403022766113281d,
<i>192</i>&nbsp;        +0.4311765432357788d,
<i>193</i>&nbsp;        +0.3153223395347595d,
<i>194</i>&nbsp;        +0.19454771280288696d,
<i>195</i>&nbsp;        +0.07073719799518585d,
<i>196</i>&nbsp;        -0.05417713522911072d,
<i>197</i>&nbsp;    };
<i>198</i>&nbsp;
<i>199</i>&nbsp;    /** Cosine table (low bits). */
<b class="fc"><i>200</i>&nbsp;    private static final double COSINE_TABLE_B[] =</b>
<i>201</i>&nbsp;        {
<i>202</i>&nbsp;        +0.0d,
<i>203</i>&nbsp;        +3.4439717236742845E-8d,
<i>204</i>&nbsp;        +5.865827662008209E-8d,
<i>205</i>&nbsp;        -3.7999795083850525E-8d,
<i>206</i>&nbsp;        +1.184154459111628E-8d,
<i>207</i>&nbsp;        -3.43338934259355E-8d,
<i>208</i>&nbsp;        +1.1795268640216787E-8d,
<i>209</i>&nbsp;        +4.438921624363781E-8d,
<i>210</i>&nbsp;        +2.925681159240093E-8d,
<i>211</i>&nbsp;        -2.6437112632041807E-8d,
<i>212</i>&nbsp;        +2.2860509143963117E-8d,
<i>213</i>&nbsp;        -4.813899778443457E-9d,
<i>214</i>&nbsp;        +3.6725170580355583E-9d,
<i>215</i>&nbsp;        +2.0217439756338078E-10d,
<i>216</i>&nbsp;    };
<i>217</i>&nbsp;
<i>218</i>&nbsp;
<i>219</i>&nbsp;    /** Tangent table, used by atan() (high bits). */
<b class="fc"><i>220</i>&nbsp;    private static final double TANGENT_TABLE_A[] =</b>
<i>221</i>&nbsp;        {
<i>222</i>&nbsp;        +0.0d,
<i>223</i>&nbsp;        +0.1256551444530487d,
<i>224</i>&nbsp;        +0.25534194707870483d,
<i>225</i>&nbsp;        +0.3936265707015991d,
<i>226</i>&nbsp;        +0.5463024377822876d,
<i>227</i>&nbsp;        +0.7214844226837158d,
<i>228</i>&nbsp;        +0.9315965175628662d,
<i>229</i>&nbsp;        +1.1974215507507324d,
<i>230</i>&nbsp;        +1.5574076175689697d,
<i>231</i>&nbsp;        +2.092571258544922d,
<i>232</i>&nbsp;        +3.0095696449279785d,
<i>233</i>&nbsp;        +5.041914939880371d,
<i>234</i>&nbsp;        +14.101419448852539d,
<i>235</i>&nbsp;        -18.430862426757812d,
<i>236</i>&nbsp;    };
<i>237</i>&nbsp;
<i>238</i>&nbsp;    /** Tangent table, used by atan() (low bits). */
<b class="fc"><i>239</i>&nbsp;    private static final double TANGENT_TABLE_B[] =</b>
<i>240</i>&nbsp;        {
<i>241</i>&nbsp;        +0.0d,
<i>242</i>&nbsp;        -7.877917738262007E-9d,
<i>243</i>&nbsp;        -2.5857668567479893E-8d,
<i>244</i>&nbsp;        +5.2240336371356666E-9d,
<i>245</i>&nbsp;        +5.206150291559893E-8d,
<i>246</i>&nbsp;        +1.8307188599677033E-8d,
<i>247</i>&nbsp;        -5.7618793749770706E-8d,
<i>248</i>&nbsp;        +7.848361555046424E-8d,
<i>249</i>&nbsp;        +1.0708593250394448E-7d,
<i>250</i>&nbsp;        +1.7827257129423813E-8d,
<i>251</i>&nbsp;        +2.893485277253286E-8d,
<i>252</i>&nbsp;        +3.1660099222737955E-7d,
<i>253</i>&nbsp;        +4.983191803254889E-7d,
<i>254</i>&nbsp;        -3.356118100840571E-7d,
<i>255</i>&nbsp;    };
<i>256</i>&nbsp;
<i>257</i>&nbsp;    /** Bits of 1/(2*pi), need for reducePayneHanek(). */
<b class="fc"><i>258</i>&nbsp;    private static final long RECIP_2PI[] = new long[] {</b>
<i>259</i>&nbsp;        (0x28be60dbL &lt;&lt; 32) | 0x9391054aL,
<i>260</i>&nbsp;        (0x7f09d5f4L &lt;&lt; 32) | 0x7d4d3770L,
<i>261</i>&nbsp;        (0x36d8a566L &lt;&lt; 32) | 0x4f10e410L,
<i>262</i>&nbsp;        (0x7f9458eaL &lt;&lt; 32) | 0xf7aef158L,
<i>263</i>&nbsp;        (0x6dc91b8eL &lt;&lt; 32) | 0x909374b8L,
<i>264</i>&nbsp;        (0x01924bbaL &lt;&lt; 32) | 0x82746487L,
<i>265</i>&nbsp;        (0x3f877ac7L &lt;&lt; 32) | 0x2c4a69cfL,
<i>266</i>&nbsp;        (0xba208d7dL &lt;&lt; 32) | 0x4baed121L,
<i>267</i>&nbsp;        (0x3a671c09L &lt;&lt; 32) | 0xad17df90L,
<i>268</i>&nbsp;        (0x4e64758eL &lt;&lt; 32) | 0x60d4ce7dL,
<i>269</i>&nbsp;        (0x272117e2L &lt;&lt; 32) | 0xef7e4a0eL,
<i>270</i>&nbsp;        (0xc7fe25ffL &lt;&lt; 32) | 0xf7816603L,
<i>271</i>&nbsp;        (0xfbcbc462L &lt;&lt; 32) | 0xd6829b47L,
<i>272</i>&nbsp;        (0xdb4d9fb3L &lt;&lt; 32) | 0xc9f2c26dL,
<i>273</i>&nbsp;        (0xd3d18fd9L &lt;&lt; 32) | 0xa797fa8bL,
<i>274</i>&nbsp;        (0x5d49eeb1L &lt;&lt; 32) | 0xfaf97c5eL,
<i>275</i>&nbsp;        (0xcf41ce7dL &lt;&lt; 32) | 0xe294a4baL,
<i>276</i>&nbsp;         0x9afed7ecL &lt;&lt; 32  };
<i>277</i>&nbsp;
<i>278</i>&nbsp;    /** Bits of pi/4, need for reducePayneHanek(). */
<b class="fc"><i>279</i>&nbsp;    private static final long PI_O_4_BITS[] = new long[] {</b>
<i>280</i>&nbsp;        (0xc90fdaa2L &lt;&lt; 32) | 0x2168c234L,
<i>281</i>&nbsp;        (0xc4c6628bL &lt;&lt; 32) | 0x80dc1cd1L };
<i>282</i>&nbsp;
<i>283</i>&nbsp;    /** Eighths.
<i>284</i>&nbsp;     * This is used by sinQ, because its faster to do a table lookup than
<i>285</i>&nbsp;     * a multiply in this time-critical routine
<i>286</i>&nbsp;     */
<b class="fc"><i>287</i>&nbsp;    private static final double EIGHTHS[] = {0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875, 1.0, 1.125, 1.25, 1.375, 1.5, 1.625};</b>
<i>288</i>&nbsp;
<i>289</i>&nbsp;    /** Table of 2^((n+2)/3) */
<b class="fc"><i>290</i>&nbsp;    private static final double CBRTTWO[] = { 0.6299605249474366,</b>
<i>291</i>&nbsp;                                            0.7937005259840998,
<i>292</i>&nbsp;                                            1.0,
<i>293</i>&nbsp;                                            1.2599210498948732,
<i>294</i>&nbsp;                                            1.5874010519681994 };
<i>295</i>&nbsp;
<i>296</i>&nbsp;    /*
<i>297</i>&nbsp;     *  There are 52 bits in the mantissa of a double.
<i>298</i>&nbsp;     *  For additional precision, the code splits double numbers into two parts,
<i>299</i>&nbsp;     *  by clearing the low order 30 bits if possible, and then performs the arithmetic
<i>300</i>&nbsp;     *  on each half separately.
<i>301</i>&nbsp;     */
<i>302</i>&nbsp;
<i>303</i>&nbsp;    /**
<i>304</i>&nbsp;     * 0x40000000 - used to split a double into two parts, both with the low order bits cleared.
<i>305</i>&nbsp;     * Equivalent to 2^30.
<i>306</i>&nbsp;     */
<i>307</i>&nbsp;    private static final long HEX_40000000 = 0x40000000L; // 1073741824L
<i>308</i>&nbsp;
<i>309</i>&nbsp;    /** Mask used to clear low order 30 bits */
<i>310</i>&nbsp;    private static final long MASK_30BITS = -1L - (HEX_40000000 -1); // 0xFFFFFFFFC0000000L;
<i>311</i>&nbsp;
<i>312</i>&nbsp;    /** Mask used to clear the non-sign part of an int. */
<i>313</i>&nbsp;    private static final int MASK_NON_SIGN_INT = 0x7fffffff;
<i>314</i>&nbsp;
<i>315</i>&nbsp;    /** Mask used to clear the non-sign part of a long. */
<i>316</i>&nbsp;    private static final long MASK_NON_SIGN_LONG = 0x7fffffffffffffffl;
<i>317</i>&nbsp;
<i>318</i>&nbsp;    /** Mask used to extract exponent from double bits. */
<i>319</i>&nbsp;    private static final long MASK_DOUBLE_EXPONENT = 0x7ff0000000000000L;
<i>320</i>&nbsp;
<i>321</i>&nbsp;    /** Mask used to extract mantissa from double bits. */
<i>322</i>&nbsp;    private static final long MASK_DOUBLE_MANTISSA = 0x000fffffffffffffL;
<i>323</i>&nbsp;
<i>324</i>&nbsp;    /** Mask used to add implicit high order bit for normalized double. */
<i>325</i>&nbsp;    private static final long IMPLICIT_HIGH_BIT = 0x0010000000000000L;
<i>326</i>&nbsp;
<i>327</i>&nbsp;    /** 2^52 - double numbers this large must be integral (no fraction) or NaN or Infinite */
<i>328</i>&nbsp;    private static final double TWO_POWER_52 = 4503599627370496.0;
<i>329</i>&nbsp;
<i>330</i>&nbsp;    /** Constant: {@value}. */
<i>331</i>&nbsp;    private static final double F_1_3 = 1d / 3d;
<i>332</i>&nbsp;    /** Constant: {@value}. */
<i>333</i>&nbsp;    private static final double F_1_5 = 1d / 5d;
<i>334</i>&nbsp;    /** Constant: {@value}. */
<i>335</i>&nbsp;    private static final double F_1_7 = 1d / 7d;
<i>336</i>&nbsp;    /** Constant: {@value}. */
<i>337</i>&nbsp;    private static final double F_1_9 = 1d / 9d;
<i>338</i>&nbsp;    /** Constant: {@value}. */
<i>339</i>&nbsp;    private static final double F_1_11 = 1d / 11d;
<i>340</i>&nbsp;    /** Constant: {@value}. */
<i>341</i>&nbsp;    private static final double F_1_13 = 1d / 13d;
<i>342</i>&nbsp;    /** Constant: {@value}. */
<i>343</i>&nbsp;    private static final double F_1_15 = 1d / 15d;
<i>344</i>&nbsp;    /** Constant: {@value}. */
<i>345</i>&nbsp;    private static final double F_1_17 = 1d / 17d;
<i>346</i>&nbsp;    /** Constant: {@value}. */
<i>347</i>&nbsp;    private static final double F_3_4 = 3d / 4d;
<i>348</i>&nbsp;    /** Constant: {@value}. */
<i>349</i>&nbsp;    private static final double F_15_16 = 15d / 16d;
<i>350</i>&nbsp;    /** Constant: {@value}. */
<i>351</i>&nbsp;    private static final double F_13_14 = 13d / 14d;
<i>352</i>&nbsp;    /** Constant: {@value}. */
<i>353</i>&nbsp;    private static final double F_11_12 = 11d / 12d;
<i>354</i>&nbsp;    /** Constant: {@value}. */
<i>355</i>&nbsp;    private static final double F_9_10 = 9d / 10d;
<i>356</i>&nbsp;    /** Constant: {@value}. */
<i>357</i>&nbsp;    private static final double F_7_8 = 7d / 8d;
<i>358</i>&nbsp;    /** Constant: {@value}. */
<i>359</i>&nbsp;    private static final double F_5_6 = 5d / 6d;
<i>360</i>&nbsp;    /** Constant: {@value}. */
<i>361</i>&nbsp;    private static final double F_1_2 = 1d / 2d;
<i>362</i>&nbsp;    /** Constant: {@value}. */
<i>363</i>&nbsp;    private static final double F_1_4 = 1d / 4d;
<i>364</i>&nbsp;
<i>365</i>&nbsp;    /**
<i>366</i>&nbsp;     * Private Constructor
<i>367</i>&nbsp;     */
<b class="nc"><i>368</i>&nbsp;    private FastMath() {}</b>
<i>369</i>&nbsp;
<i>370</i>&nbsp;    // Generic helper methods
<i>371</i>&nbsp;
<i>372</i>&nbsp;    /**
<i>373</i>&nbsp;     * Get the high order bits from the mantissa.
<i>374</i>&nbsp;     * Equivalent to adding and subtracting HEX_40000 but also works for very large numbers
<i>375</i>&nbsp;     *
<i>376</i>&nbsp;     * @param d the value to split
<i>377</i>&nbsp;     * @return the high order part of the mantissa
<i>378</i>&nbsp;     */
<i>379</i>&nbsp;    private static double doubleHighPart(double d) {
<b class="fc"><i>380</i>&nbsp;        if (d &gt; -Precision.SAFE_MIN &amp;&amp; d &lt; Precision.SAFE_MIN){</b>
<b class="fc"><i>381</i>&nbsp;            return d; // These are un-normalised - don&#39;t try to convert</b>
<i>382</i>&nbsp;        }
<b class="fc"><i>383</i>&nbsp;        long xl = Double.doubleToRawLongBits(d); // can take raw bits because just gonna convert it back</b>
<b class="fc"><i>384</i>&nbsp;        xl &amp;= MASK_30BITS; // Drop low order bits</b>
<b class="fc"><i>385</i>&nbsp;        return Double.longBitsToDouble(xl);</b>
<i>386</i>&nbsp;    }
<i>387</i>&nbsp;
<i>388</i>&nbsp;    /** Compute the square root of a number.
<i>389</i>&nbsp;     * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; this implementation currently delegates to {@link Math#sqrt}
<i>390</i>&nbsp;     * @param a number on which evaluation is done
<i>391</i>&nbsp;     * @return square root of a
<i>392</i>&nbsp;     */
<i>393</i>&nbsp;    public static double sqrt(final double a) {
<b class="fc"><i>394</i>&nbsp;        return Math.sqrt(a);</b>
<i>395</i>&nbsp;    }
<i>396</i>&nbsp;
<i>397</i>&nbsp;    /** Compute the hyperbolic cosine of a number.
<i>398</i>&nbsp;     * @param x number on which evaluation is done
<i>399</i>&nbsp;     * @return hyperbolic cosine of x
<i>400</i>&nbsp;     */
<i>401</i>&nbsp;    public static double cosh(double x) {
<b class="fc"><i>402</i>&nbsp;      if (Double.isNaN(x)) {</b>
<b class="fc"><i>403</i>&nbsp;          return x;</b>
<i>404</i>&nbsp;      }
<i>405</i>&nbsp;
<i>406</i>&nbsp;      // cosh[z] = (exp(z) + exp(-z))/2
<i>407</i>&nbsp;
<i>408</i>&nbsp;      // for numbers with magnitude 20 or so,
<i>409</i>&nbsp;      // exp(-z) can be ignored in comparison with exp(z)
<i>410</i>&nbsp;
<b class="fc"><i>411</i>&nbsp;      if (x &gt; 20) {</b>
<b class="fc"><i>412</i>&nbsp;          if (x &gt;= LOG_MAX_VALUE) {</b>
<i>413</i>&nbsp;              // Avoid overflow (MATH-905).
<b class="fc"><i>414</i>&nbsp;              final double t = exp(0.5 * x);</b>
<b class="fc"><i>415</i>&nbsp;              return (0.5 * t) * t;</b>
<i>416</i>&nbsp;          } else {
<b class="fc"><i>417</i>&nbsp;              return 0.5 * exp(x);</b>
<i>418</i>&nbsp;          }
<b class="fc"><i>419</i>&nbsp;      } else if (x &lt; -20) {</b>
<b class="fc"><i>420</i>&nbsp;          if (x &lt;= -LOG_MAX_VALUE) {</b>
<i>421</i>&nbsp;              // Avoid overflow (MATH-905).
<b class="fc"><i>422</i>&nbsp;              final double t = exp(-0.5 * x);</b>
<b class="fc"><i>423</i>&nbsp;              return (0.5 * t) * t;</b>
<i>424</i>&nbsp;          } else {
<b class="fc"><i>425</i>&nbsp;              return 0.5 * exp(-x);</b>
<i>426</i>&nbsp;          }
<i>427</i>&nbsp;      }
<i>428</i>&nbsp;
<b class="fc"><i>429</i>&nbsp;      final double hiPrec[] = new double[2];</b>
<b class="fc"><i>430</i>&nbsp;      if (x &lt; 0.0) {</b>
<b class="fc"><i>431</i>&nbsp;          x = -x;</b>
<i>432</i>&nbsp;      }
<b class="fc"><i>433</i>&nbsp;      exp(x, 0.0, hiPrec);</b>
<i>434</i>&nbsp;
<b class="fc"><i>435</i>&nbsp;      double ya = hiPrec[0] + hiPrec[1];</b>
<b class="fc"><i>436</i>&nbsp;      double yb = -(ya - hiPrec[0] - hiPrec[1]);</b>
<i>437</i>&nbsp;
<b class="fc"><i>438</i>&nbsp;      double temp = ya * HEX_40000000;</b>
<b class="fc"><i>439</i>&nbsp;      double yaa = ya + temp - temp;</b>
<b class="fc"><i>440</i>&nbsp;      double yab = ya - yaa;</b>
<i>441</i>&nbsp;
<i>442</i>&nbsp;      // recip = 1/y
<b class="fc"><i>443</i>&nbsp;      double recip = 1.0/ya;</b>
<b class="fc"><i>444</i>&nbsp;      temp = recip * HEX_40000000;</b>
<b class="fc"><i>445</i>&nbsp;      double recipa = recip + temp - temp;</b>
<b class="fc"><i>446</i>&nbsp;      double recipb = recip - recipa;</b>
<i>447</i>&nbsp;
<i>448</i>&nbsp;      // Correct for rounding in division
<b class="fc"><i>449</i>&nbsp;      recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;</b>
<i>450</i>&nbsp;      // Account for yb
<b class="fc"><i>451</i>&nbsp;      recipb += -yb * recip * recip;</b>
<i>452</i>&nbsp;
<i>453</i>&nbsp;      // y = y + 1/y
<b class="fc"><i>454</i>&nbsp;      temp = ya + recipa;</b>
<b class="fc"><i>455</i>&nbsp;      yb += -(temp - ya - recipa);</b>
<b class="fc"><i>456</i>&nbsp;      ya = temp;</b>
<b class="fc"><i>457</i>&nbsp;      temp = ya + recipb;</b>
<b class="fc"><i>458</i>&nbsp;      yb += -(temp - ya - recipb);</b>
<b class="fc"><i>459</i>&nbsp;      ya = temp;</b>
<i>460</i>&nbsp;
<b class="fc"><i>461</i>&nbsp;      double result = ya + yb;</b>
<b class="fc"><i>462</i>&nbsp;      result *= 0.5;</b>
<b class="fc"><i>463</i>&nbsp;      return result;</b>
<i>464</i>&nbsp;    }
<i>465</i>&nbsp;
<i>466</i>&nbsp;    /** Compute the hyperbolic sine of a number.
<i>467</i>&nbsp;     * @param x number on which evaluation is done
<i>468</i>&nbsp;     * @return hyperbolic sine of x
<i>469</i>&nbsp;     */
<i>470</i>&nbsp;    public static double sinh(double x) {
<b class="fc"><i>471</i>&nbsp;      boolean negate = false;</b>
<b class="fc"><i>472</i>&nbsp;      if (Double.isNaN(x)) {</b>
<b class="fc"><i>473</i>&nbsp;          return x;</b>
<i>474</i>&nbsp;      }
<i>475</i>&nbsp;
<i>476</i>&nbsp;      // sinh[z] = (exp(z) - exp(-z) / 2
<i>477</i>&nbsp;
<i>478</i>&nbsp;      // for values of z larger than about 20,
<i>479</i>&nbsp;      // exp(-z) can be ignored in comparison with exp(z)
<i>480</i>&nbsp;
<b class="fc"><i>481</i>&nbsp;      if (x &gt; 20) {</b>
<b class="fc"><i>482</i>&nbsp;          if (x &gt;= LOG_MAX_VALUE) {</b>
<i>483</i>&nbsp;              // Avoid overflow (MATH-905).
<b class="fc"><i>484</i>&nbsp;              final double t = exp(0.5 * x);</b>
<b class="fc"><i>485</i>&nbsp;              return (0.5 * t) * t;</b>
<i>486</i>&nbsp;          } else {
<b class="fc"><i>487</i>&nbsp;              return 0.5 * exp(x);</b>
<i>488</i>&nbsp;          }
<b class="fc"><i>489</i>&nbsp;      } else if (x &lt; -20) {</b>
<b class="fc"><i>490</i>&nbsp;          if (x &lt;= -LOG_MAX_VALUE) {</b>
<i>491</i>&nbsp;              // Avoid overflow (MATH-905).
<b class="fc"><i>492</i>&nbsp;              final double t = exp(-0.5 * x);</b>
<b class="fc"><i>493</i>&nbsp;              return (-0.5 * t) * t;</b>
<i>494</i>&nbsp;          } else {
<b class="fc"><i>495</i>&nbsp;              return -0.5 * exp(-x);</b>
<i>496</i>&nbsp;          }
<i>497</i>&nbsp;      }
<i>498</i>&nbsp;
<b class="fc"><i>499</i>&nbsp;      if (x == 0) {</b>
<b class="fc"><i>500</i>&nbsp;          return x;</b>
<i>501</i>&nbsp;      }
<i>502</i>&nbsp;
<b class="fc"><i>503</i>&nbsp;      if (x &lt; 0.0) {</b>
<b class="fc"><i>504</i>&nbsp;          x = -x;</b>
<b class="fc"><i>505</i>&nbsp;          negate = true;</b>
<i>506</i>&nbsp;      }
<i>507</i>&nbsp;
<i>508</i>&nbsp;      double result;
<i>509</i>&nbsp;
<b class="fc"><i>510</i>&nbsp;      if (x &gt; 0.25) {</b>
<b class="fc"><i>511</i>&nbsp;          double hiPrec[] = new double[2];</b>
<b class="fc"><i>512</i>&nbsp;          exp(x, 0.0, hiPrec);</b>
<i>513</i>&nbsp;
<b class="fc"><i>514</i>&nbsp;          double ya = hiPrec[0] + hiPrec[1];</b>
<b class="fc"><i>515</i>&nbsp;          double yb = -(ya - hiPrec[0] - hiPrec[1]);</b>
<i>516</i>&nbsp;
<b class="fc"><i>517</i>&nbsp;          double temp = ya * HEX_40000000;</b>
<b class="fc"><i>518</i>&nbsp;          double yaa = ya + temp - temp;</b>
<b class="fc"><i>519</i>&nbsp;          double yab = ya - yaa;</b>
<i>520</i>&nbsp;
<i>521</i>&nbsp;          // recip = 1/y
<b class="fc"><i>522</i>&nbsp;          double recip = 1.0/ya;</b>
<b class="fc"><i>523</i>&nbsp;          temp = recip * HEX_40000000;</b>
<b class="fc"><i>524</i>&nbsp;          double recipa = recip + temp - temp;</b>
<b class="fc"><i>525</i>&nbsp;          double recipb = recip - recipa;</b>
<i>526</i>&nbsp;
<i>527</i>&nbsp;          // Correct for rounding in division
<b class="fc"><i>528</i>&nbsp;          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;</b>
<i>529</i>&nbsp;          // Account for yb
<b class="fc"><i>530</i>&nbsp;          recipb += -yb * recip * recip;</b>
<i>531</i>&nbsp;
<b class="fc"><i>532</i>&nbsp;          recipa = -recipa;</b>
<b class="fc"><i>533</i>&nbsp;          recipb = -recipb;</b>
<i>534</i>&nbsp;
<i>535</i>&nbsp;          // y = y + 1/y
<b class="fc"><i>536</i>&nbsp;          temp = ya + recipa;</b>
<b class="fc"><i>537</i>&nbsp;          yb += -(temp - ya - recipa);</b>
<b class="fc"><i>538</i>&nbsp;          ya = temp;</b>
<b class="fc"><i>539</i>&nbsp;          temp = ya + recipb;</b>
<b class="fc"><i>540</i>&nbsp;          yb += -(temp - ya - recipb);</b>
<b class="fc"><i>541</i>&nbsp;          ya = temp;</b>
<i>542</i>&nbsp;
<b class="fc"><i>543</i>&nbsp;          result = ya + yb;</b>
<b class="fc"><i>544</i>&nbsp;          result *= 0.5;</b>
<b class="fc"><i>545</i>&nbsp;      }</b>
<i>546</i>&nbsp;      else {
<b class="fc"><i>547</i>&nbsp;          double hiPrec[] = new double[2];</b>
<b class="fc"><i>548</i>&nbsp;          expm1(x, hiPrec);</b>
<i>549</i>&nbsp;
<b class="fc"><i>550</i>&nbsp;          double ya = hiPrec[0] + hiPrec[1];</b>
<b class="fc"><i>551</i>&nbsp;          double yb = -(ya - hiPrec[0] - hiPrec[1]);</b>
<i>552</i>&nbsp;
<i>553</i>&nbsp;          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */
<b class="fc"><i>554</i>&nbsp;          double denom = 1.0 + ya;</b>
<b class="fc"><i>555</i>&nbsp;          double denomr = 1.0 / denom;</b>
<b class="fc"><i>556</i>&nbsp;          double denomb = -(denom - 1.0 - ya) + yb;</b>
<b class="fc"><i>557</i>&nbsp;          double ratio = ya * denomr;</b>
<b class="fc"><i>558</i>&nbsp;          double temp = ratio * HEX_40000000;</b>
<b class="fc"><i>559</i>&nbsp;          double ra = ratio + temp - temp;</b>
<b class="fc"><i>560</i>&nbsp;          double rb = ratio - ra;</b>
<i>561</i>&nbsp;
<b class="fc"><i>562</i>&nbsp;          temp = denom * HEX_40000000;</b>
<b class="fc"><i>563</i>&nbsp;          double za = denom + temp - temp;</b>
<b class="fc"><i>564</i>&nbsp;          double zb = denom - za;</b>
<i>565</i>&nbsp;
<b class="fc"><i>566</i>&nbsp;          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;</b>
<i>567</i>&nbsp;
<i>568</i>&nbsp;          // Adjust for yb
<b class="fc"><i>569</i>&nbsp;          rb += yb*denomr;                        // numerator</b>
<b class="fc"><i>570</i>&nbsp;          rb += -ya * denomb * denomr * denomr;   // denominator</b>
<i>571</i>&nbsp;
<i>572</i>&nbsp;          // y = y - 1/y
<b class="fc"><i>573</i>&nbsp;          temp = ya + ra;</b>
<b class="fc"><i>574</i>&nbsp;          yb += -(temp - ya - ra);</b>
<b class="fc"><i>575</i>&nbsp;          ya = temp;</b>
<b class="fc"><i>576</i>&nbsp;          temp = ya + rb;</b>
<b class="fc"><i>577</i>&nbsp;          yb += -(temp - ya - rb);</b>
<b class="fc"><i>578</i>&nbsp;          ya = temp;</b>
<i>579</i>&nbsp;
<b class="fc"><i>580</i>&nbsp;          result = ya + yb;</b>
<b class="fc"><i>581</i>&nbsp;          result *= 0.5;</b>
<i>582</i>&nbsp;      }
<i>583</i>&nbsp;
<b class="fc"><i>584</i>&nbsp;      if (negate) {</b>
<b class="fc"><i>585</i>&nbsp;          result = -result;</b>
<i>586</i>&nbsp;      }
<i>587</i>&nbsp;
<b class="fc"><i>588</i>&nbsp;      return result;</b>
<i>589</i>&nbsp;    }
<i>590</i>&nbsp;
<i>591</i>&nbsp;    /** Compute the hyperbolic tangent of a number.
<i>592</i>&nbsp;     * @param x number on which evaluation is done
<i>593</i>&nbsp;     * @return hyperbolic tangent of x
<i>594</i>&nbsp;     */
<i>595</i>&nbsp;    public static double tanh(double x) {
<b class="fc"><i>596</i>&nbsp;      boolean negate = false;</b>
<i>597</i>&nbsp;
<b class="fc"><i>598</i>&nbsp;      if (Double.isNaN(x)) {</b>
<b class="fc"><i>599</i>&nbsp;          return x;</b>
<i>600</i>&nbsp;      }
<i>601</i>&nbsp;
<i>602</i>&nbsp;      // tanh[z] = sinh[z] / cosh[z]
<i>603</i>&nbsp;      // = (exp(z) - exp(-z)) / (exp(z) + exp(-z))
<i>604</i>&nbsp;      // = (exp(2x) - 1) / (exp(2x) + 1)
<i>605</i>&nbsp;
<i>606</i>&nbsp;      // for magnitude &gt; 20, sinh[z] == cosh[z] in double precision
<i>607</i>&nbsp;
<b class="fc"><i>608</i>&nbsp;      if (x &gt; 20.0) {</b>
<b class="fc"><i>609</i>&nbsp;          return 1.0;</b>
<i>610</i>&nbsp;      }
<i>611</i>&nbsp;
<b class="fc"><i>612</i>&nbsp;      if (x &lt; -20) {</b>
<b class="fc"><i>613</i>&nbsp;          return -1.0;</b>
<i>614</i>&nbsp;      }
<i>615</i>&nbsp;
<b class="fc"><i>616</i>&nbsp;      if (x == 0) {</b>
<b class="fc"><i>617</i>&nbsp;          return x;</b>
<i>618</i>&nbsp;      }
<i>619</i>&nbsp;
<b class="fc"><i>620</i>&nbsp;      if (x &lt; 0.0) {</b>
<b class="fc"><i>621</i>&nbsp;          x = -x;</b>
<b class="fc"><i>622</i>&nbsp;          negate = true;</b>
<i>623</i>&nbsp;      }
<i>624</i>&nbsp;
<i>625</i>&nbsp;      double result;
<b class="fc"><i>626</i>&nbsp;      if (x &gt;= 0.5) {</b>
<b class="fc"><i>627</i>&nbsp;          double hiPrec[] = new double[2];</b>
<i>628</i>&nbsp;          // tanh(x) = (exp(2x) - 1) / (exp(2x) + 1)
<b class="fc"><i>629</i>&nbsp;          exp(x*2.0, 0.0, hiPrec);</b>
<i>630</i>&nbsp;
<b class="fc"><i>631</i>&nbsp;          double ya = hiPrec[0] + hiPrec[1];</b>
<b class="fc"><i>632</i>&nbsp;          double yb = -(ya - hiPrec[0] - hiPrec[1]);</b>
<i>633</i>&nbsp;
<i>634</i>&nbsp;          /* Numerator */
<b class="fc"><i>635</i>&nbsp;          double na = -1.0 + ya;</b>
<b class="fc"><i>636</i>&nbsp;          double nb = -(na + 1.0 - ya);</b>
<b class="fc"><i>637</i>&nbsp;          double temp = na + yb;</b>
<b class="fc"><i>638</i>&nbsp;          nb += -(temp - na - yb);</b>
<b class="fc"><i>639</i>&nbsp;          na = temp;</b>
<i>640</i>&nbsp;
<i>641</i>&nbsp;          /* Denominator */
<b class="fc"><i>642</i>&nbsp;          double da = 1.0 + ya;</b>
<b class="fc"><i>643</i>&nbsp;          double db = -(da - 1.0 - ya);</b>
<b class="fc"><i>644</i>&nbsp;          temp = da + yb;</b>
<b class="fc"><i>645</i>&nbsp;          db += -(temp - da - yb);</b>
<b class="fc"><i>646</i>&nbsp;          da = temp;</b>
<i>647</i>&nbsp;
<b class="fc"><i>648</i>&nbsp;          temp = da * HEX_40000000;</b>
<b class="fc"><i>649</i>&nbsp;          double daa = da + temp - temp;</b>
<b class="fc"><i>650</i>&nbsp;          double dab = da - daa;</b>
<i>651</i>&nbsp;
<i>652</i>&nbsp;          // ratio = na/da
<b class="fc"><i>653</i>&nbsp;          double ratio = na/da;</b>
<b class="fc"><i>654</i>&nbsp;          temp = ratio * HEX_40000000;</b>
<b class="fc"><i>655</i>&nbsp;          double ratioa = ratio + temp - temp;</b>
<b class="fc"><i>656</i>&nbsp;          double ratiob = ratio - ratioa;</b>
<i>657</i>&nbsp;
<i>658</i>&nbsp;          // Correct for rounding in division
<b class="fc"><i>659</i>&nbsp;          ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;</b>
<i>660</i>&nbsp;
<i>661</i>&nbsp;          // Account for nb
<b class="fc"><i>662</i>&nbsp;          ratiob += nb / da;</b>
<i>663</i>&nbsp;          // Account for db
<b class="fc"><i>664</i>&nbsp;          ratiob += -db * na / da / da;</b>
<i>665</i>&nbsp;
<b class="fc"><i>666</i>&nbsp;          result = ratioa + ratiob;</b>
<b class="fc"><i>667</i>&nbsp;      }</b>
<i>668</i>&nbsp;      else {
<b class="fc"><i>669</i>&nbsp;          double hiPrec[] = new double[2];</b>
<i>670</i>&nbsp;          // tanh(x) = expm1(2x) / (expm1(2x) + 2)
<b class="fc"><i>671</i>&nbsp;          expm1(x*2.0, hiPrec);</b>
<i>672</i>&nbsp;
<b class="fc"><i>673</i>&nbsp;          double ya = hiPrec[0] + hiPrec[1];</b>
<b class="fc"><i>674</i>&nbsp;          double yb = -(ya - hiPrec[0] - hiPrec[1]);</b>
<i>675</i>&nbsp;
<i>676</i>&nbsp;          /* Numerator */
<b class="fc"><i>677</i>&nbsp;          double na = ya;</b>
<b class="fc"><i>678</i>&nbsp;          double nb = yb;</b>
<i>679</i>&nbsp;
<i>680</i>&nbsp;          /* Denominator */
<b class="fc"><i>681</i>&nbsp;          double da = 2.0 + ya;</b>
<b class="fc"><i>682</i>&nbsp;          double db = -(da - 2.0 - ya);</b>
<b class="fc"><i>683</i>&nbsp;          double temp = da + yb;</b>
<b class="fc"><i>684</i>&nbsp;          db += -(temp - da - yb);</b>
<b class="fc"><i>685</i>&nbsp;          da = temp;</b>
<i>686</i>&nbsp;
<b class="fc"><i>687</i>&nbsp;          temp = da * HEX_40000000;</b>
<b class="fc"><i>688</i>&nbsp;          double daa = da + temp - temp;</b>
<b class="fc"><i>689</i>&nbsp;          double dab = da - daa;</b>
<i>690</i>&nbsp;
<i>691</i>&nbsp;          // ratio = na/da
<b class="fc"><i>692</i>&nbsp;          double ratio = na/da;</b>
<b class="fc"><i>693</i>&nbsp;          temp = ratio * HEX_40000000;</b>
<b class="fc"><i>694</i>&nbsp;          double ratioa = ratio + temp - temp;</b>
<b class="fc"><i>695</i>&nbsp;          double ratiob = ratio - ratioa;</b>
<i>696</i>&nbsp;
<i>697</i>&nbsp;          // Correct for rounding in division
<b class="fc"><i>698</i>&nbsp;          ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;</b>
<i>699</i>&nbsp;
<i>700</i>&nbsp;          // Account for nb
<b class="fc"><i>701</i>&nbsp;          ratiob += nb / da;</b>
<i>702</i>&nbsp;          // Account for db
<b class="fc"><i>703</i>&nbsp;          ratiob += -db * na / da / da;</b>
<i>704</i>&nbsp;
<b class="fc"><i>705</i>&nbsp;          result = ratioa + ratiob;</b>
<i>706</i>&nbsp;      }
<i>707</i>&nbsp;
<b class="fc"><i>708</i>&nbsp;      if (negate) {</b>
<b class="fc"><i>709</i>&nbsp;          result = -result;</b>
<i>710</i>&nbsp;      }
<i>711</i>&nbsp;
<b class="fc"><i>712</i>&nbsp;      return result;</b>
<i>713</i>&nbsp;    }
<i>714</i>&nbsp;
<i>715</i>&nbsp;    /** Compute the inverse hyperbolic cosine of a number.
<i>716</i>&nbsp;     * @param a number on which evaluation is done
<i>717</i>&nbsp;     * @return inverse hyperbolic cosine of a
<i>718</i>&nbsp;     */
<i>719</i>&nbsp;    public static double acosh(final double a) {
<b class="fc"><i>720</i>&nbsp;        return FastMath.log(a + FastMath.sqrt(a * a - 1));</b>
<i>721</i>&nbsp;    }
<i>722</i>&nbsp;
<i>723</i>&nbsp;    /** Compute the inverse hyperbolic sine of a number.
<i>724</i>&nbsp;     * @param a number on which evaluation is done
<i>725</i>&nbsp;     * @return inverse hyperbolic sine of a
<i>726</i>&nbsp;     */
<i>727</i>&nbsp;    public static double asinh(double a) {
<b class="fc"><i>728</i>&nbsp;        boolean negative = false;</b>
<b class="fc"><i>729</i>&nbsp;        if (a &lt; 0) {</b>
<b class="fc"><i>730</i>&nbsp;            negative = true;</b>
<b class="fc"><i>731</i>&nbsp;            a = -a;</b>
<i>732</i>&nbsp;        }
<i>733</i>&nbsp;
<i>734</i>&nbsp;        double absAsinh;
<b class="fc"><i>735</i>&nbsp;        if (a &gt; 0.167) {</b>
<b class="fc"><i>736</i>&nbsp;            absAsinh = FastMath.log(FastMath.sqrt(a * a + 1) + a);</b>
<i>737</i>&nbsp;        } else {
<b class="fc"><i>738</i>&nbsp;            final double a2 = a * a;</b>
<b class="fc"><i>739</i>&nbsp;            if (a &gt; 0.097) {</b>
<b class="fc"><i>740</i>&nbsp;                absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * (F_1_13 - a2 * (F_1_15 - a2 * F_1_17 * F_15_16) * F_13_14) * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2);</b>
<b class="fc"><i>741</i>&nbsp;            } else if (a &gt; 0.036) {</b>
<b class="fc"><i>742</i>&nbsp;                absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * F_1_13 * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2);</b>
<b class="fc"><i>743</i>&nbsp;            } else if (a &gt; 0.0036) {</b>
<b class="fc"><i>744</i>&nbsp;                absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * F_1_9 * F_7_8) * F_5_6) * F_3_4) * F_1_2);</b>
<i>745</i>&nbsp;            } else {
<b class="fc"><i>746</i>&nbsp;                absAsinh = a * (1 - a2 * (F_1_3 - a2 * F_1_5 * F_3_4) * F_1_2);</b>
<i>747</i>&nbsp;            }
<i>748</i>&nbsp;        }
<i>749</i>&nbsp;
<b class="fc"><i>750</i>&nbsp;        return negative ? -absAsinh : absAsinh;</b>
<i>751</i>&nbsp;    }
<i>752</i>&nbsp;
<i>753</i>&nbsp;    /** Compute the inverse hyperbolic tangent of a number.
<i>754</i>&nbsp;     * @param a number on which evaluation is done
<i>755</i>&nbsp;     * @return inverse hyperbolic tangent of a
<i>756</i>&nbsp;     */
<i>757</i>&nbsp;    public static double atanh(double a) {
<b class="fc"><i>758</i>&nbsp;        boolean negative = false;</b>
<b class="fc"><i>759</i>&nbsp;        if (a &lt; 0) {</b>
<b class="fc"><i>760</i>&nbsp;            negative = true;</b>
<b class="fc"><i>761</i>&nbsp;            a = -a;</b>
<i>762</i>&nbsp;        }
<i>763</i>&nbsp;
<i>764</i>&nbsp;        double absAtanh;
<b class="fc"><i>765</i>&nbsp;        if (a &gt; 0.15) {</b>
<b class="fc"><i>766</i>&nbsp;            absAtanh = 0.5 * FastMath.log((1 + a) / (1 - a));</b>
<i>767</i>&nbsp;        } else {
<b class="fc"><i>768</i>&nbsp;            final double a2 = a * a;</b>
<b class="fc"><i>769</i>&nbsp;            if (a &gt; 0.087) {</b>
<b class="fc"><i>770</i>&nbsp;                absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * (F_1_9 + a2 * (F_1_11 + a2 * (F_1_13 + a2 * (F_1_15 + a2 * F_1_17))))))));</b>
<b class="fc"><i>771</i>&nbsp;            } else if (a &gt; 0.031) {</b>
<b class="fc"><i>772</i>&nbsp;                absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * (F_1_9 + a2 * (F_1_11 + a2 * F_1_13))))));</b>
<b class="fc"><i>773</i>&nbsp;            } else if (a &gt; 0.003) {</b>
<b class="fc"><i>774</i>&nbsp;                absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * F_1_9))));</b>
<i>775</i>&nbsp;            } else {
<b class="fc"><i>776</i>&nbsp;                absAtanh = a * (1 + a2 * (F_1_3 + a2 * F_1_5));</b>
<i>777</i>&nbsp;            }
<i>778</i>&nbsp;        }
<i>779</i>&nbsp;
<b class="fc"><i>780</i>&nbsp;        return negative ? -absAtanh : absAtanh;</b>
<i>781</i>&nbsp;    }
<i>782</i>&nbsp;
<i>783</i>&nbsp;    /** Compute the signum of a number.
<i>784</i>&nbsp;     * The signum is -1 for negative numbers, +1 for positive numbers and 0 otherwise
<i>785</i>&nbsp;     * @param a number on which evaluation is done
<i>786</i>&nbsp;     * @return -1.0, -0.0, +0.0, +1.0 or NaN depending on sign of a
<i>787</i>&nbsp;     */
<i>788</i>&nbsp;    public static double signum(final double a) {
<b class="fc"><i>789</i>&nbsp;        return (a &lt; 0.0) ? -1.0 : ((a &gt; 0.0) ? 1.0 : a); // return +0.0/-0.0/NaN depending on a</b>
<i>790</i>&nbsp;    }
<i>791</i>&nbsp;
<i>792</i>&nbsp;    /** Compute the signum of a number.
<i>793</i>&nbsp;     * The signum is -1 for negative numbers, +1 for positive numbers and 0 otherwise
<i>794</i>&nbsp;     * @param a number on which evaluation is done
<i>795</i>&nbsp;     * @return -1.0, -0.0, +0.0, +1.0 or NaN depending on sign of a
<i>796</i>&nbsp;     */
<i>797</i>&nbsp;    public static float signum(final float a) {
<b class="fc"><i>798</i>&nbsp;        return (a &lt; 0.0f) ? -1.0f : ((a &gt; 0.0f) ? 1.0f : a); // return +0.0/-0.0/NaN depending on a</b>
<i>799</i>&nbsp;    }
<i>800</i>&nbsp;
<i>801</i>&nbsp;    /** Compute next number towards positive infinity.
<i>802</i>&nbsp;     * @param a number to which neighbor should be computed
<i>803</i>&nbsp;     * @return neighbor of a towards positive infinity
<i>804</i>&nbsp;     */
<i>805</i>&nbsp;    public static double nextUp(final double a) {
<b class="fc"><i>806</i>&nbsp;        return nextAfter(a, Double.POSITIVE_INFINITY);</b>
<i>807</i>&nbsp;    }
<i>808</i>&nbsp;
<i>809</i>&nbsp;    /** Compute next number towards positive infinity.
<i>810</i>&nbsp;     * @param a number to which neighbor should be computed
<i>811</i>&nbsp;     * @return neighbor of a towards positive infinity
<i>812</i>&nbsp;     */
<i>813</i>&nbsp;    public static float nextUp(final float a) {
<b class="fc"><i>814</i>&nbsp;        return nextAfter(a, Float.POSITIVE_INFINITY);</b>
<i>815</i>&nbsp;    }
<i>816</i>&nbsp;
<i>817</i>&nbsp;    /** Compute next number towards negative infinity.
<i>818</i>&nbsp;     * @param a number to which neighbor should be computed
<i>819</i>&nbsp;     * @return neighbor of a towards negative infinity
<i>820</i>&nbsp;     * @since 3.4
<i>821</i>&nbsp;     */
<i>822</i>&nbsp;    public static double nextDown(final double a) {
<b class="fc"><i>823</i>&nbsp;        return nextAfter(a, Double.NEGATIVE_INFINITY);</b>
<i>824</i>&nbsp;    }
<i>825</i>&nbsp;
<i>826</i>&nbsp;    /** Compute next number towards negative infinity.
<i>827</i>&nbsp;     * @param a number to which neighbor should be computed
<i>828</i>&nbsp;     * @return neighbor of a towards negative infinity
<i>829</i>&nbsp;     * @since 3.4
<i>830</i>&nbsp;     */
<i>831</i>&nbsp;    public static float nextDown(final float a) {
<b class="fc"><i>832</i>&nbsp;        return nextAfter(a, Float.NEGATIVE_INFINITY);</b>
<i>833</i>&nbsp;    }
<i>834</i>&nbsp;
<i>835</i>&nbsp;    /** Returns a pseudo-random number between 0.0 and 1.0.
<i>836</i>&nbsp;     * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; this implementation currently delegates to {@link Math#random}
<i>837</i>&nbsp;     * @return a random number between 0.0 and 1.0
<i>838</i>&nbsp;     */
<i>839</i>&nbsp;    public static double random() {
<b class="fc"><i>840</i>&nbsp;        return Math.random();</b>
<i>841</i>&nbsp;    }
<i>842</i>&nbsp;
<i>843</i>&nbsp;    /**
<i>844</i>&nbsp;     * Exponential function.
<i>845</i>&nbsp;     *
<i>846</i>&nbsp;     * Computes exp(x), function result is nearly rounded.   It will be correctly
<i>847</i>&nbsp;     * rounded to the theoretical value for 99.9% of input values, otherwise it will
<i>848</i>&nbsp;     * have a 1 ULP error.
<i>849</i>&nbsp;     *
<i>850</i>&nbsp;     * Method:
<i>851</i>&nbsp;     *    Lookup intVal = exp(int(x))
<i>852</i>&nbsp;     *    Lookup fracVal = exp(int(x-int(x) / 1024.0) * 1024.0 );
<i>853</i>&nbsp;     *    Compute z as the exponential of the remaining bits by a polynomial minus one
<i>854</i>&nbsp;     *    exp(x) = intVal * fracVal * (1 + z)
<i>855</i>&nbsp;     *
<i>856</i>&nbsp;     * Accuracy:
<i>857</i>&nbsp;     *    Calculation is done with 63 bits of precision, so result should be correctly
<i>858</i>&nbsp;     *    rounded for 99.9% of input values, with less than 1 ULP error otherwise.
<i>859</i>&nbsp;     *
<i>860</i>&nbsp;     * @param x   a double
<i>861</i>&nbsp;     * @return double e&lt;sup&gt;x&lt;/sup&gt;
<i>862</i>&nbsp;     */
<i>863</i>&nbsp;    public static double exp(double x) {
<b class="fc"><i>864</i>&nbsp;        return exp(x, 0.0, null);</b>
<i>865</i>&nbsp;    }
<i>866</i>&nbsp;
<i>867</i>&nbsp;    /**
<i>868</i>&nbsp;     * Internal helper method for exponential function.
<i>869</i>&nbsp;     * @param x original argument of the exponential function
<i>870</i>&nbsp;     * @param extra extra bits of precision on input (To Be Confirmed)
<i>871</i>&nbsp;     * @param hiPrec extra bits of precision on output (To Be Confirmed)
<i>872</i>&nbsp;     * @return exp(x)
<i>873</i>&nbsp;     */
<i>874</i>&nbsp;    private static double exp(double x, double extra, double[] hiPrec) {
<i>875</i>&nbsp;        double intPartA;
<i>876</i>&nbsp;        double intPartB;
<b class="fc"><i>877</i>&nbsp;        int intVal = (int) x;</b>
<i>878</i>&nbsp;
<i>879</i>&nbsp;        /* Lookup exp(floor(x)).
<i>880</i>&nbsp;         * intPartA will have the upper 22 bits, intPartB will have the lower
<i>881</i>&nbsp;         * 52 bits.
<i>882</i>&nbsp;         */
<b class="fc"><i>883</i>&nbsp;        if (x &lt; 0.0) {</b>
<i>884</i>&nbsp;
<i>885</i>&nbsp;            // We don&#39;t check against intVal here as conversion of large negative double values
<i>886</i>&nbsp;            // may be affected by a JIT bug. Subsequent comparisons can safely use intVal
<b class="fc"><i>887</i>&nbsp;            if (x &lt; -746d) {</b>
<b class="fc"><i>888</i>&nbsp;                if (hiPrec != null) {</b>
<b class="fc"><i>889</i>&nbsp;                    hiPrec[0] = 0.0;</b>
<b class="fc"><i>890</i>&nbsp;                    hiPrec[1] = 0.0;</b>
<i>891</i>&nbsp;                }
<b class="fc"><i>892</i>&nbsp;                return 0.0;</b>
<i>893</i>&nbsp;            }
<i>894</i>&nbsp;
<b class="fc"><i>895</i>&nbsp;            if (intVal &lt; -709) {</b>
<i>896</i>&nbsp;                /* This will produce a subnormal output */
<b class="fc"><i>897</i>&nbsp;                final double result = exp(x+40.19140625, extra, hiPrec) / 285040095144011776.0;</b>
<b class="fc"><i>898</i>&nbsp;                if (hiPrec != null) {</b>
<b class="nc"><i>899</i>&nbsp;                    hiPrec[0] /= 285040095144011776.0;</b>
<b class="nc"><i>900</i>&nbsp;                    hiPrec[1] /= 285040095144011776.0;</b>
<i>901</i>&nbsp;                }
<b class="fc"><i>902</i>&nbsp;                return result;</b>
<i>903</i>&nbsp;            }
<i>904</i>&nbsp;
<b class="fc"><i>905</i>&nbsp;            if (intVal == -709) {</b>
<i>906</i>&nbsp;                /* exp(1.494140625) is nearly a machine number... */
<b class="fc"><i>907</i>&nbsp;                final double result = exp(x+1.494140625, extra, hiPrec) / 4.455505956692756620;</b>
<b class="fc"><i>908</i>&nbsp;                if (hiPrec != null) {</b>
<b class="nc"><i>909</i>&nbsp;                    hiPrec[0] /= 4.455505956692756620;</b>
<b class="nc"><i>910</i>&nbsp;                    hiPrec[1] /= 4.455505956692756620;</b>
<i>911</i>&nbsp;                }
<b class="fc"><i>912</i>&nbsp;                return result;</b>
<i>913</i>&nbsp;            }
<i>914</i>&nbsp;
<b class="fc"><i>915</i>&nbsp;            intVal--;</b>
<i>916</i>&nbsp;
<i>917</i>&nbsp;        } else {
<b class="fc"><i>918</i>&nbsp;            if (intVal &gt; 709) {</b>
<b class="fc"><i>919</i>&nbsp;                if (hiPrec != null) {</b>
<b class="fc"><i>920</i>&nbsp;                    hiPrec[0] = Double.POSITIVE_INFINITY;</b>
<b class="fc"><i>921</i>&nbsp;                    hiPrec[1] = 0.0;</b>
<i>922</i>&nbsp;                }
<b class="fc"><i>923</i>&nbsp;                return Double.POSITIVE_INFINITY;</b>
<i>924</i>&nbsp;            }
<i>925</i>&nbsp;
<i>926</i>&nbsp;        }
<i>927</i>&nbsp;
<b class="fc"><i>928</i>&nbsp;        intPartA = ExpIntTable.EXP_INT_TABLE_A[EXP_INT_TABLE_MAX_INDEX+intVal];</b>
<b class="fc"><i>929</i>&nbsp;        intPartB = ExpIntTable.EXP_INT_TABLE_B[EXP_INT_TABLE_MAX_INDEX+intVal];</b>
<i>930</i>&nbsp;
<i>931</i>&nbsp;        /* Get the fractional part of x, find the greatest multiple of 2^-10 less than
<i>932</i>&nbsp;         * x and look up the exp function of it.
<i>933</i>&nbsp;         * fracPartA will have the upper 22 bits, fracPartB the lower 52 bits.
<i>934</i>&nbsp;         */
<b class="fc"><i>935</i>&nbsp;        final int intFrac = (int) ((x - intVal) * 1024.0);</b>
<b class="fc"><i>936</i>&nbsp;        final double fracPartA = ExpFracTable.EXP_FRAC_TABLE_A[intFrac];</b>
<b class="fc"><i>937</i>&nbsp;        final double fracPartB = ExpFracTable.EXP_FRAC_TABLE_B[intFrac];</b>
<i>938</i>&nbsp;
<i>939</i>&nbsp;        /* epsilon is the difference in x from the nearest multiple of 2^-10.  It
<i>940</i>&nbsp;         * has a value in the range 0 &lt;= epsilon &lt; 2^-10.
<i>941</i>&nbsp;         * Do the subtraction from x as the last step to avoid possible loss of precision.
<i>942</i>&nbsp;         */
<b class="fc"><i>943</i>&nbsp;        final double epsilon = x - (intVal + intFrac / 1024.0);</b>
<i>944</i>&nbsp;
<i>945</i>&nbsp;        /* Compute z = exp(epsilon) - 1.0 via a minimax polynomial.  z has
<i>946</i>&nbsp;       full double precision (52 bits).  Since z &lt; 2^-10, we will have
<i>947</i>&nbsp;       62 bits of precision when combined with the constant 1.  This will be
<i>948</i>&nbsp;       used in the last addition below to get proper rounding. */
<i>949</i>&nbsp;
<i>950</i>&nbsp;        /* Remez generated polynomial.  Converges on the interval [0, 2^-10], error
<i>951</i>&nbsp;       is less than 0.5 ULP */
<b class="fc"><i>952</i>&nbsp;        double z = 0.04168701738764507;</b>
<b class="fc"><i>953</i>&nbsp;        z = z * epsilon + 0.1666666505023083;</b>
<b class="fc"><i>954</i>&nbsp;        z = z * epsilon + 0.5000000000042687;</b>
<b class="fc"><i>955</i>&nbsp;        z = z * epsilon + 1.0;</b>
<b class="fc"><i>956</i>&nbsp;        z = z * epsilon + -3.940510424527919E-20;</b>
<i>957</i>&nbsp;
<i>958</i>&nbsp;        /* Compute (intPartA+intPartB) * (fracPartA+fracPartB) by binomial
<i>959</i>&nbsp;       expansion.
<i>960</i>&nbsp;       tempA is exact since intPartA and intPartB only have 22 bits each.
<i>961</i>&nbsp;       tempB will have 52 bits of precision.
<i>962</i>&nbsp;         */
<b class="fc"><i>963</i>&nbsp;        double tempA = intPartA * fracPartA;</b>
<b class="fc"><i>964</i>&nbsp;        double tempB = intPartA * fracPartB + intPartB * fracPartA + intPartB * fracPartB;</b>
<i>965</i>&nbsp;
<i>966</i>&nbsp;        /* Compute the result.  (1+z)(tempA+tempB).  Order of operations is
<i>967</i>&nbsp;       important.  For accuracy add by increasing size.  tempA is exact and
<i>968</i>&nbsp;       much larger than the others.  If there are extra bits specified from the
<i>969</i>&nbsp;       pow() function, use them. */
<b class="fc"><i>970</i>&nbsp;        final double tempC = tempB + tempA;</b>
<i>971</i>&nbsp;
<i>972</i>&nbsp;        // If tempC is positive infinite, the evaluation below could result in NaN,
<i>973</i>&nbsp;        // because z could be negative at the same time.
<b class="fc"><i>974</i>&nbsp;        if (tempC == Double.POSITIVE_INFINITY) {</b>
<b class="fc"><i>975</i>&nbsp;            return Double.POSITIVE_INFINITY;</b>
<i>976</i>&nbsp;        }
<i>977</i>&nbsp;
<i>978</i>&nbsp;        final double result;
<b class="fc"><i>979</i>&nbsp;        if (extra != 0.0) {</b>
<b class="fc"><i>980</i>&nbsp;            result = tempC*extra*z + tempC*extra + tempC*z + tempB + tempA;</b>
<i>981</i>&nbsp;        } else {
<b class="fc"><i>982</i>&nbsp;            result = tempC*z + tempB + tempA;</b>
<i>983</i>&nbsp;        }
<i>984</i>&nbsp;
<b class="fc"><i>985</i>&nbsp;        if (hiPrec != null) {</b>
<i>986</i>&nbsp;            // If requesting high precision
<b class="fc"><i>987</i>&nbsp;            hiPrec[0] = tempA;</b>
<b class="fc"><i>988</i>&nbsp;            hiPrec[1] = tempC*extra*z + tempC*extra + tempC*z + tempB;</b>
<i>989</i>&nbsp;        }
<i>990</i>&nbsp;
<b class="fc"><i>991</i>&nbsp;        return result;</b>
<i>992</i>&nbsp;    }
<i>993</i>&nbsp;
<i>994</i>&nbsp;    /** Compute exp(x) - 1
<i>995</i>&nbsp;     * @param x number to compute shifted exponential
<i>996</i>&nbsp;     * @return exp(x) - 1
<i>997</i>&nbsp;     */
<i>998</i>&nbsp;    public static double expm1(double x) {
<b class="fc"><i>999</i>&nbsp;      return expm1(x, null);</b>
<i>1000</i>&nbsp;    }
<i>1001</i>&nbsp;
<i>1002</i>&nbsp;    /** Internal helper method for expm1
<i>1003</i>&nbsp;     * @param x number to compute shifted exponential
<i>1004</i>&nbsp;     * @param hiPrecOut receive high precision result for -1.0 &lt; x &lt; 1.0
<i>1005</i>&nbsp;     * @return exp(x) - 1
<i>1006</i>&nbsp;     */
<i>1007</i>&nbsp;    private static double expm1(double x, double hiPrecOut[]) {
<b class="fc"><i>1008</i>&nbsp;        if (Double.isNaN(x) || x == 0.0) { // NaN or zero</b>
<b class="fc"><i>1009</i>&nbsp;            return x;</b>
<i>1010</i>&nbsp;        }
<i>1011</i>&nbsp;
<b class="fc"><i>1012</i>&nbsp;        if (x &lt;= -1.0 || x &gt;= 1.0) {</b>
<i>1013</i>&nbsp;            // If not between +/- 1.0
<i>1014</i>&nbsp;            //return exp(x) - 1.0;
<b class="fc"><i>1015</i>&nbsp;            double hiPrec[] = new double[2];</b>
<b class="fc"><i>1016</i>&nbsp;            exp(x, 0.0, hiPrec);</b>
<b class="fc"><i>1017</i>&nbsp;            if (x &gt; 0.0) {</b>
<b class="fc"><i>1018</i>&nbsp;                return -1.0 + hiPrec[0] + hiPrec[1];</b>
<i>1019</i>&nbsp;            } else {
<b class="fc"><i>1020</i>&nbsp;                final double ra = -1.0 + hiPrec[0];</b>
<b class="fc"><i>1021</i>&nbsp;                double rb = -(ra + 1.0 - hiPrec[0]);</b>
<b class="fc"><i>1022</i>&nbsp;                rb += hiPrec[1];</b>
<b class="fc"><i>1023</i>&nbsp;                return ra + rb;</b>
<i>1024</i>&nbsp;            }
<i>1025</i>&nbsp;        }
<i>1026</i>&nbsp;
<i>1027</i>&nbsp;        double baseA;
<i>1028</i>&nbsp;        double baseB;
<i>1029</i>&nbsp;        double epsilon;
<b class="fc"><i>1030</i>&nbsp;        boolean negative = false;</b>
<i>1031</i>&nbsp;
<b class="fc"><i>1032</i>&nbsp;        if (x &lt; 0.0) {</b>
<b class="fc"><i>1033</i>&nbsp;            x = -x;</b>
<b class="fc"><i>1034</i>&nbsp;            negative = true;</b>
<i>1035</i>&nbsp;        }
<i>1036</i>&nbsp;
<i>1037</i>&nbsp;        {
<b class="fc"><i>1038</i>&nbsp;            int intFrac = (int) (x * 1024.0);</b>
<b class="fc"><i>1039</i>&nbsp;            double tempA = ExpFracTable.EXP_FRAC_TABLE_A[intFrac] - 1.0;</b>
<b class="fc"><i>1040</i>&nbsp;            double tempB = ExpFracTable.EXP_FRAC_TABLE_B[intFrac];</b>
<i>1041</i>&nbsp;
<b class="fc"><i>1042</i>&nbsp;            double temp = tempA + tempB;</b>
<b class="fc"><i>1043</i>&nbsp;            tempB = -(temp - tempA - tempB);</b>
<b class="fc"><i>1044</i>&nbsp;            tempA = temp;</b>
<i>1045</i>&nbsp;
<b class="fc"><i>1046</i>&nbsp;            temp = tempA * HEX_40000000;</b>
<b class="fc"><i>1047</i>&nbsp;            baseA = tempA + temp - temp;</b>
<b class="fc"><i>1048</i>&nbsp;            baseB = tempB + (tempA - baseA);</b>
<i>1049</i>&nbsp;
<b class="fc"><i>1050</i>&nbsp;            epsilon = x - intFrac/1024.0;</b>
<i>1051</i>&nbsp;        }
<i>1052</i>&nbsp;
<i>1053</i>&nbsp;
<i>1054</i>&nbsp;        /* Compute expm1(epsilon) */
<b class="fc"><i>1055</i>&nbsp;        double zb = 0.008336750013465571;</b>
<b class="fc"><i>1056</i>&nbsp;        zb = zb * epsilon + 0.041666663879186654;</b>
<b class="fc"><i>1057</i>&nbsp;        zb = zb * epsilon + 0.16666666666745392;</b>
<b class="fc"><i>1058</i>&nbsp;        zb = zb * epsilon + 0.49999999999999994;</b>
<b class="fc"><i>1059</i>&nbsp;        zb *= epsilon;</b>
<b class="fc"><i>1060</i>&nbsp;        zb *= epsilon;</b>
<i>1061</i>&nbsp;
<b class="fc"><i>1062</i>&nbsp;        double za = epsilon;</b>
<b class="fc"><i>1063</i>&nbsp;        double temp = za + zb;</b>
<b class="fc"><i>1064</i>&nbsp;        zb = -(temp - za - zb);</b>
<b class="fc"><i>1065</i>&nbsp;        za = temp;</b>
<i>1066</i>&nbsp;
<b class="fc"><i>1067</i>&nbsp;        temp = za * HEX_40000000;</b>
<b class="fc"><i>1068</i>&nbsp;        temp = za + temp - temp;</b>
<b class="fc"><i>1069</i>&nbsp;        zb += za - temp;</b>
<b class="fc"><i>1070</i>&nbsp;        za = temp;</b>
<i>1071</i>&nbsp;
<i>1072</i>&nbsp;        /* Combine the parts.   expm1(a+b) = expm1(a) + expm1(b) + expm1(a)*expm1(b) */
<b class="fc"><i>1073</i>&nbsp;        double ya = za * baseA;</b>
<i>1074</i>&nbsp;        //double yb = za*baseB + zb*baseA + zb*baseB;
<b class="fc"><i>1075</i>&nbsp;        temp = ya + za * baseB;</b>
<b class="fc"><i>1076</i>&nbsp;        double yb = -(temp - ya - za * baseB);</b>
<b class="fc"><i>1077</i>&nbsp;        ya = temp;</b>
<i>1078</i>&nbsp;
<b class="fc"><i>1079</i>&nbsp;        temp = ya + zb * baseA;</b>
<b class="fc"><i>1080</i>&nbsp;        yb += -(temp - ya - zb * baseA);</b>
<b class="fc"><i>1081</i>&nbsp;        ya = temp;</b>
<i>1082</i>&nbsp;
<b class="fc"><i>1083</i>&nbsp;        temp = ya + zb * baseB;</b>
<b class="fc"><i>1084</i>&nbsp;        yb += -(temp - ya - zb*baseB);</b>
<b class="fc"><i>1085</i>&nbsp;        ya = temp;</b>
<i>1086</i>&nbsp;
<i>1087</i>&nbsp;        //ya = ya + za + baseA;
<i>1088</i>&nbsp;        //yb = yb + zb + baseB;
<b class="fc"><i>1089</i>&nbsp;        temp = ya + baseA;</b>
<b class="fc"><i>1090</i>&nbsp;        yb += -(temp - baseA - ya);</b>
<b class="fc"><i>1091</i>&nbsp;        ya = temp;</b>
<i>1092</i>&nbsp;
<b class="fc"><i>1093</i>&nbsp;        temp = ya + za;</b>
<i>1094</i>&nbsp;        //yb += (ya &gt; za) ? -(temp - ya - za) : -(temp - za - ya);
<b class="fc"><i>1095</i>&nbsp;        yb += -(temp - ya - za);</b>
<b class="fc"><i>1096</i>&nbsp;        ya = temp;</b>
<i>1097</i>&nbsp;
<b class="fc"><i>1098</i>&nbsp;        temp = ya + baseB;</b>
<i>1099</i>&nbsp;        //yb += (ya &gt; baseB) ? -(temp - ya - baseB) : -(temp - baseB - ya);
<b class="fc"><i>1100</i>&nbsp;        yb += -(temp - ya - baseB);</b>
<b class="fc"><i>1101</i>&nbsp;        ya = temp;</b>
<i>1102</i>&nbsp;
<b class="fc"><i>1103</i>&nbsp;        temp = ya + zb;</b>
<i>1104</i>&nbsp;        //yb += (ya &gt; zb) ? -(temp - ya - zb) : -(temp - zb - ya);
<b class="fc"><i>1105</i>&nbsp;        yb += -(temp - ya - zb);</b>
<b class="fc"><i>1106</i>&nbsp;        ya = temp;</b>
<i>1107</i>&nbsp;
<b class="fc"><i>1108</i>&nbsp;        if (negative) {</b>
<i>1109</i>&nbsp;            /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */
<b class="fc"><i>1110</i>&nbsp;            double denom = 1.0 + ya;</b>
<b class="fc"><i>1111</i>&nbsp;            double denomr = 1.0 / denom;</b>
<b class="fc"><i>1112</i>&nbsp;            double denomb = -(denom - 1.0 - ya) + yb;</b>
<b class="fc"><i>1113</i>&nbsp;            double ratio = ya * denomr;</b>
<b class="fc"><i>1114</i>&nbsp;            temp = ratio * HEX_40000000;</b>
<b class="fc"><i>1115</i>&nbsp;            final double ra = ratio + temp - temp;</b>
<b class="fc"><i>1116</i>&nbsp;            double rb = ratio - ra;</b>
<i>1117</i>&nbsp;
<b class="fc"><i>1118</i>&nbsp;            temp = denom * HEX_40000000;</b>
<b class="fc"><i>1119</i>&nbsp;            za = denom + temp - temp;</b>
<b class="fc"><i>1120</i>&nbsp;            zb = denom - za;</b>
<i>1121</i>&nbsp;
<b class="fc"><i>1122</i>&nbsp;            rb += (ya - za * ra - za * rb - zb * ra - zb * rb) * denomr;</b>
<i>1123</i>&nbsp;
<i>1124</i>&nbsp;            // f(x) = x/1+x
<i>1125</i>&nbsp;            // Compute f&#39;(x)
<i>1126</i>&nbsp;            // Product rule:  d(uv) = du*v + u*dv
<i>1127</i>&nbsp;            // Chain rule:  d(f(g(x)) = f&#39;(g(x))*f(g&#39;(x))
<i>1128</i>&nbsp;            // d(1/x) = -1/(x*x)
<i>1129</i>&nbsp;            // d(1/1+x) = -1/( (1+x)^2) *  1 =  -1/((1+x)*(1+x))
<i>1130</i>&nbsp;            // d(x/1+x) = -x/((1+x)(1+x)) + 1/1+x = 1 / ((1+x)(1+x))
<i>1131</i>&nbsp;
<i>1132</i>&nbsp;            // Adjust for yb
<b class="fc"><i>1133</i>&nbsp;            rb += yb * denomr;                      // numerator</b>
<b class="fc"><i>1134</i>&nbsp;            rb += -ya * denomb * denomr * denomr;   // denominator</b>
<i>1135</i>&nbsp;
<i>1136</i>&nbsp;            // negate
<b class="fc"><i>1137</i>&nbsp;            ya = -ra;</b>
<b class="fc"><i>1138</i>&nbsp;            yb = -rb;</b>
<i>1139</i>&nbsp;        }
<i>1140</i>&nbsp;
<b class="fc"><i>1141</i>&nbsp;        if (hiPrecOut != null) {</b>
<b class="fc"><i>1142</i>&nbsp;            hiPrecOut[0] = ya;</b>
<b class="fc"><i>1143</i>&nbsp;            hiPrecOut[1] = yb;</b>
<i>1144</i>&nbsp;        }
<i>1145</i>&nbsp;
<b class="fc"><i>1146</i>&nbsp;        return ya + yb;</b>
<i>1147</i>&nbsp;    }
<i>1148</i>&nbsp;
<i>1149</i>&nbsp;    /**
<i>1150</i>&nbsp;     * Natural logarithm.
<i>1151</i>&nbsp;     *
<i>1152</i>&nbsp;     * @param x   a double
<i>1153</i>&nbsp;     * @return log(x)
<i>1154</i>&nbsp;     */
<i>1155</i>&nbsp;    public static double log(final double x) {
<b class="fc"><i>1156</i>&nbsp;        return log(x, null);</b>
<i>1157</i>&nbsp;    }
<i>1158</i>&nbsp;
<i>1159</i>&nbsp;    /**
<i>1160</i>&nbsp;     * Internal helper method for natural logarithm function.
<i>1161</i>&nbsp;     * @param x original argument of the natural logarithm function
<i>1162</i>&nbsp;     * @param hiPrec extra bits of precision on output (To Be Confirmed)
<i>1163</i>&nbsp;     * @return log(x)
<i>1164</i>&nbsp;     */
<i>1165</i>&nbsp;    private static double log(final double x, final double[] hiPrec) {
<b class="fc"><i>1166</i>&nbsp;        if (x==0) { // Handle special case of +0/-0</b>
<b class="fc"><i>1167</i>&nbsp;            return Double.NEGATIVE_INFINITY;</b>
<i>1168</i>&nbsp;        }
<b class="fc"><i>1169</i>&nbsp;        long bits = Double.doubleToRawLongBits(x);</b>
<i>1170</i>&nbsp;
<i>1171</i>&nbsp;        /* Handle special cases of negative input, and NaN */
<b class="fc"><i>1172</i>&nbsp;        if (((bits &amp; 0x8000000000000000L) != 0 || Double.isNaN(x)) &amp;&amp; x != 0.0) {</b>
<b class="fc"><i>1173</i>&nbsp;            if (hiPrec != null) {</b>
<b class="fc"><i>1174</i>&nbsp;                hiPrec[0] = Double.NaN;</b>
<i>1175</i>&nbsp;            }
<i>1176</i>&nbsp;
<b class="fc"><i>1177</i>&nbsp;            return Double.NaN;</b>
<i>1178</i>&nbsp;        }
<i>1179</i>&nbsp;
<i>1180</i>&nbsp;        /* Handle special cases of Positive infinity. */
<b class="fc"><i>1181</i>&nbsp;        if (x == Double.POSITIVE_INFINITY) {</b>
<b class="fc"><i>1182</i>&nbsp;            if (hiPrec != null) {</b>
<b class="fc"><i>1183</i>&nbsp;                hiPrec[0] = Double.POSITIVE_INFINITY;</b>
<i>1184</i>&nbsp;            }
<i>1185</i>&nbsp;
<b class="fc"><i>1186</i>&nbsp;            return Double.POSITIVE_INFINITY;</b>
<i>1187</i>&nbsp;        }
<i>1188</i>&nbsp;
<i>1189</i>&nbsp;        /* Extract the exponent */
<b class="fc"><i>1190</i>&nbsp;        int exp = (int)(bits &gt;&gt; 52)-1023;</b>
<i>1191</i>&nbsp;
<b class="fc"><i>1192</i>&nbsp;        if ((bits &amp; 0x7ff0000000000000L) == 0) {</b>
<i>1193</i>&nbsp;            // Subnormal!
<b class="fc"><i>1194</i>&nbsp;            if (x == 0) {</b>
<i>1195</i>&nbsp;                // Zero
<b class="nc"><i>1196</i>&nbsp;                if (hiPrec != null) {</b>
<b class="nc"><i>1197</i>&nbsp;                    hiPrec[0] = Double.NEGATIVE_INFINITY;</b>
<i>1198</i>&nbsp;                }
<i>1199</i>&nbsp;
<b class="nc"><i>1200</i>&nbsp;                return Double.NEGATIVE_INFINITY;</b>
<i>1201</i>&nbsp;            }
<i>1202</i>&nbsp;
<i>1203</i>&nbsp;            /* Normalize the subnormal number. */
<b class="fc"><i>1204</i>&nbsp;            bits &lt;&lt;= 1;</b>
<b class="fc"><i>1205</i>&nbsp;            while ( (bits &amp; 0x0010000000000000L) == 0) {</b>
<b class="fc"><i>1206</i>&nbsp;                --exp;</b>
<b class="fc"><i>1207</i>&nbsp;                bits &lt;&lt;= 1;</b>
<i>1208</i>&nbsp;            }
<i>1209</i>&nbsp;        }
<i>1210</i>&nbsp;
<i>1211</i>&nbsp;
<b class="fc"><i>1212</i>&nbsp;        if ((exp == -1 || exp == 0) &amp;&amp; x &lt; 1.01 &amp;&amp; x &gt; 0.99 &amp;&amp; hiPrec == null) {</b>
<i>1213</i>&nbsp;            /* The normal method doesn&#39;t work well in the range [0.99, 1.01], so call do a straight
<i>1214</i>&nbsp;           polynomial expansion in higer precision. */
<i>1215</i>&nbsp;
<i>1216</i>&nbsp;            /* Compute x - 1.0 and split it */
<b class="fc"><i>1217</i>&nbsp;            double xa = x - 1.0;</b>
<b class="fc"><i>1218</i>&nbsp;            double xb = xa - x + 1.0;</b>
<b class="fc"><i>1219</i>&nbsp;            double tmp = xa * HEX_40000000;</b>
<b class="fc"><i>1220</i>&nbsp;            double aa = xa + tmp - tmp;</b>
<b class="fc"><i>1221</i>&nbsp;            double ab = xa - aa;</b>
<b class="fc"><i>1222</i>&nbsp;            xa = aa;</b>
<b class="fc"><i>1223</i>&nbsp;            xb = ab;</b>
<i>1224</i>&nbsp;
<b class="fc"><i>1225</i>&nbsp;            final double[] lnCoef_last = LN_QUICK_COEF[LN_QUICK_COEF.length - 1];</b>
<b class="fc"><i>1226</i>&nbsp;            double ya = lnCoef_last[0];</b>
<b class="fc"><i>1227</i>&nbsp;            double yb = lnCoef_last[1];</b>
<i>1228</i>&nbsp;
<b class="fc"><i>1229</i>&nbsp;            for (int i = LN_QUICK_COEF.length - 2; i &gt;= 0; i--) {</b>
<i>1230</i>&nbsp;                /* Multiply a = y * x */
<b class="fc"><i>1231</i>&nbsp;                aa = ya * xa;</b>
<b class="fc"><i>1232</i>&nbsp;                ab = ya * xb + yb * xa + yb * xb;</b>
<i>1233</i>&nbsp;                /* split, so now y = a */
<b class="fc"><i>1234</i>&nbsp;                tmp = aa * HEX_40000000;</b>
<b class="fc"><i>1235</i>&nbsp;                ya = aa + tmp - tmp;</b>
<b class="fc"><i>1236</i>&nbsp;                yb = aa - ya + ab;</b>
<i>1237</i>&nbsp;
<i>1238</i>&nbsp;                /* Add  a = y + lnQuickCoef */
<b class="fc"><i>1239</i>&nbsp;                final double[] lnCoef_i = LN_QUICK_COEF[i];</b>
<b class="fc"><i>1240</i>&nbsp;                aa = ya + lnCoef_i[0];</b>
<b class="fc"><i>1241</i>&nbsp;                ab = yb + lnCoef_i[1];</b>
<i>1242</i>&nbsp;                /* Split y = a */
<b class="fc"><i>1243</i>&nbsp;                tmp = aa * HEX_40000000;</b>
<b class="fc"><i>1244</i>&nbsp;                ya = aa + tmp - tmp;</b>
<b class="fc"><i>1245</i>&nbsp;                yb = aa - ya + ab;</b>
<i>1246</i>&nbsp;            }
<i>1247</i>&nbsp;
<i>1248</i>&nbsp;            /* Multiply a = y * x */
<b class="fc"><i>1249</i>&nbsp;            aa = ya * xa;</b>
<b class="fc"><i>1250</i>&nbsp;            ab = ya * xb + yb * xa + yb * xb;</b>
<i>1251</i>&nbsp;            /* split, so now y = a */
<b class="fc"><i>1252</i>&nbsp;            tmp = aa * HEX_40000000;</b>
<b class="fc"><i>1253</i>&nbsp;            ya = aa + tmp - tmp;</b>
<b class="fc"><i>1254</i>&nbsp;            yb = aa - ya + ab;</b>
<i>1255</i>&nbsp;
<b class="fc"><i>1256</i>&nbsp;            return ya + yb;</b>
<i>1257</i>&nbsp;        }
<i>1258</i>&nbsp;
<i>1259</i>&nbsp;        // lnm is a log of a number in the range of 1.0 - 2.0, so 0 &lt;= lnm &lt; ln(2)
<b class="fc"><i>1260</i>&nbsp;        final double[] lnm = lnMant.LN_MANT[(int)((bits &amp; 0x000ffc0000000000L) &gt;&gt; 42)];</b>
<i>1261</i>&nbsp;
<i>1262</i>&nbsp;        /*
<i>1263</i>&nbsp;    double epsilon = x / Double.longBitsToDouble(bits &amp; 0xfffffc0000000000L);
<i>1264</i>&nbsp;
<i>1265</i>&nbsp;    epsilon -= 1.0;
<i>1266</i>&nbsp;         */
<i>1267</i>&nbsp;
<i>1268</i>&nbsp;        // y is the most significant 10 bits of the mantissa
<i>1269</i>&nbsp;        //double y = Double.longBitsToDouble(bits &amp; 0xfffffc0000000000L);
<i>1270</i>&nbsp;        //double epsilon = (x - y) / y;
<b class="fc"><i>1271</i>&nbsp;        final double epsilon = (bits &amp; 0x3ffffffffffL) / (TWO_POWER_52 + (bits &amp; 0x000ffc0000000000L));</b>
<i>1272</i>&nbsp;
<b class="fc"><i>1273</i>&nbsp;        double lnza = 0.0;</b>
<b class="fc"><i>1274</i>&nbsp;        double lnzb = 0.0;</b>
<i>1275</i>&nbsp;
<b class="fc"><i>1276</i>&nbsp;        if (hiPrec != null) {</b>
<i>1277</i>&nbsp;            /* split epsilon -&gt; x */
<b class="fc"><i>1278</i>&nbsp;            double tmp = epsilon * HEX_40000000;</b>
<b class="fc"><i>1279</i>&nbsp;            double aa = epsilon + tmp - tmp;</b>
<b class="fc"><i>1280</i>&nbsp;            double ab = epsilon - aa;</b>
<b class="fc"><i>1281</i>&nbsp;            double xa = aa;</b>
<b class="fc"><i>1282</i>&nbsp;            double xb = ab;</b>
<i>1283</i>&nbsp;
<i>1284</i>&nbsp;            /* Need a more accurate epsilon, so adjust the division. */
<b class="fc"><i>1285</i>&nbsp;            final double numer = bits &amp; 0x3ffffffffffL;</b>
<b class="fc"><i>1286</i>&nbsp;            final double denom = TWO_POWER_52 + (bits &amp; 0x000ffc0000000000L);</b>
<b class="fc"><i>1287</i>&nbsp;            aa = numer - xa*denom - xb * denom;</b>
<b class="fc"><i>1288</i>&nbsp;            xb += aa / denom;</b>
<i>1289</i>&nbsp;
<i>1290</i>&nbsp;            /* Remez polynomial evaluation */
<b class="fc"><i>1291</i>&nbsp;            final double[] lnCoef_last = LN_HI_PREC_COEF[LN_HI_PREC_COEF.length-1];</b>
<b class="fc"><i>1292</i>&nbsp;            double ya = lnCoef_last[0];</b>
<b class="fc"><i>1293</i>&nbsp;            double yb = lnCoef_last[1];</b>
<i>1294</i>&nbsp;
<b class="fc"><i>1295</i>&nbsp;            for (int i = LN_HI_PREC_COEF.length - 2; i &gt;= 0; i--) {</b>
<i>1296</i>&nbsp;                /* Multiply a = y * x */
<b class="fc"><i>1297</i>&nbsp;                aa = ya * xa;</b>
<b class="fc"><i>1298</i>&nbsp;                ab = ya * xb + yb * xa + yb * xb;</b>
<i>1299</i>&nbsp;                /* split, so now y = a */
<b class="fc"><i>1300</i>&nbsp;                tmp = aa * HEX_40000000;</b>
<b class="fc"><i>1301</i>&nbsp;                ya = aa + tmp - tmp;</b>
<b class="fc"><i>1302</i>&nbsp;                yb = aa - ya + ab;</b>
<i>1303</i>&nbsp;
<i>1304</i>&nbsp;                /* Add  a = y + lnHiPrecCoef */
<b class="fc"><i>1305</i>&nbsp;                final double[] lnCoef_i = LN_HI_PREC_COEF[i];</b>
<b class="fc"><i>1306</i>&nbsp;                aa = ya + lnCoef_i[0];</b>
<b class="fc"><i>1307</i>&nbsp;                ab = yb + lnCoef_i[1];</b>
<i>1308</i>&nbsp;                /* Split y = a */
<b class="fc"><i>1309</i>&nbsp;                tmp = aa * HEX_40000000;</b>
<b class="fc"><i>1310</i>&nbsp;                ya = aa + tmp - tmp;</b>
<b class="fc"><i>1311</i>&nbsp;                yb = aa - ya + ab;</b>
<i>1312</i>&nbsp;            }
<i>1313</i>&nbsp;
<i>1314</i>&nbsp;            /* Multiply a = y * x */
<b class="fc"><i>1315</i>&nbsp;            aa = ya * xa;</b>
<b class="fc"><i>1316</i>&nbsp;            ab = ya * xb + yb * xa + yb * xb;</b>
<i>1317</i>&nbsp;
<i>1318</i>&nbsp;            /* split, so now lnz = a */
<i>1319</i>&nbsp;            /*
<i>1320</i>&nbsp;      tmp = aa * 1073741824.0;
<i>1321</i>&nbsp;      lnza = aa + tmp - tmp;
<i>1322</i>&nbsp;      lnzb = aa - lnza + ab;
<i>1323</i>&nbsp;             */
<b class="fc"><i>1324</i>&nbsp;            lnza = aa + ab;</b>
<b class="fc"><i>1325</i>&nbsp;            lnzb = -(lnza - aa - ab);</b>
<b class="fc"><i>1326</i>&nbsp;        } else {</b>
<i>1327</i>&nbsp;            /* High precision not required.  Eval Remez polynomial
<i>1328</i>&nbsp;         using standard double precision */
<b class="fc"><i>1329</i>&nbsp;            lnza = -0.16624882440418567;</b>
<b class="fc"><i>1330</i>&nbsp;            lnza = lnza * epsilon + 0.19999954120254515;</b>
<b class="fc"><i>1331</i>&nbsp;            lnza = lnza * epsilon + -0.2499999997677497;</b>
<b class="fc"><i>1332</i>&nbsp;            lnza = lnza * epsilon + 0.3333333333332802;</b>
<b class="fc"><i>1333</i>&nbsp;            lnza = lnza * epsilon + -0.5;</b>
<b class="fc"><i>1334</i>&nbsp;            lnza = lnza * epsilon + 1.0;</b>
<b class="fc"><i>1335</i>&nbsp;            lnza *= epsilon;</b>
<i>1336</i>&nbsp;        }
<i>1337</i>&nbsp;
<i>1338</i>&nbsp;        /* Relative sizes:
<i>1339</i>&nbsp;         * lnzb     [0, 2.33E-10]
<i>1340</i>&nbsp;         * lnm[1]   [0, 1.17E-7]
<i>1341</i>&nbsp;         * ln2B*exp [0, 1.12E-4]
<i>1342</i>&nbsp;         * lnza      [0, 9.7E-4]
<i>1343</i>&nbsp;         * lnm[0]   [0, 0.692]
<i>1344</i>&nbsp;         * ln2A*exp [0, 709]
<i>1345</i>&nbsp;         */
<i>1346</i>&nbsp;
<i>1347</i>&nbsp;        /* Compute the following sum:
<i>1348</i>&nbsp;         * lnzb + lnm[1] + ln2B*exp + lnza + lnm[0] + ln2A*exp;
<i>1349</i>&nbsp;         */
<i>1350</i>&nbsp;
<i>1351</i>&nbsp;        //return lnzb + lnm[1] + ln2B*exp + lnza + lnm[0] + ln2A*exp;
<b class="fc"><i>1352</i>&nbsp;        double a = LN_2_A*exp;</b>
<b class="fc"><i>1353</i>&nbsp;        double b = 0.0;</b>
<b class="fc"><i>1354</i>&nbsp;        double c = a+lnm[0];</b>
<b class="fc"><i>1355</i>&nbsp;        double d = -(c-a-lnm[0]);</b>
<b class="fc"><i>1356</i>&nbsp;        a = c;</b>
<b class="fc"><i>1357</i>&nbsp;        b += d;</b>
<i>1358</i>&nbsp;
<b class="fc"><i>1359</i>&nbsp;        c = a + lnza;</b>
<b class="fc"><i>1360</i>&nbsp;        d = -(c - a - lnza);</b>
<b class="fc"><i>1361</i>&nbsp;        a = c;</b>
<b class="fc"><i>1362</i>&nbsp;        b += d;</b>
<i>1363</i>&nbsp;
<b class="fc"><i>1364</i>&nbsp;        c = a + LN_2_B*exp;</b>
<b class="fc"><i>1365</i>&nbsp;        d = -(c - a - LN_2_B*exp);</b>
<b class="fc"><i>1366</i>&nbsp;        a = c;</b>
<b class="fc"><i>1367</i>&nbsp;        b += d;</b>
<i>1368</i>&nbsp;
<b class="fc"><i>1369</i>&nbsp;        c = a + lnm[1];</b>
<b class="fc"><i>1370</i>&nbsp;        d = -(c - a - lnm[1]);</b>
<b class="fc"><i>1371</i>&nbsp;        a = c;</b>
<b class="fc"><i>1372</i>&nbsp;        b += d;</b>
<i>1373</i>&nbsp;
<b class="fc"><i>1374</i>&nbsp;        c = a + lnzb;</b>
<b class="fc"><i>1375</i>&nbsp;        d = -(c - a - lnzb);</b>
<b class="fc"><i>1376</i>&nbsp;        a = c;</b>
<b class="fc"><i>1377</i>&nbsp;        b += d;</b>
<i>1378</i>&nbsp;
<b class="fc"><i>1379</i>&nbsp;        if (hiPrec != null) {</b>
<b class="fc"><i>1380</i>&nbsp;            hiPrec[0] = a;</b>
<b class="fc"><i>1381</i>&nbsp;            hiPrec[1] = b;</b>
<i>1382</i>&nbsp;        }
<i>1383</i>&nbsp;
<b class="fc"><i>1384</i>&nbsp;        return a + b;</b>
<i>1385</i>&nbsp;    }
<i>1386</i>&nbsp;
<i>1387</i>&nbsp;    /**
<i>1388</i>&nbsp;     * Computes log(1 + x).
<i>1389</i>&nbsp;     *
<i>1390</i>&nbsp;     * @param x Number.
<i>1391</i>&nbsp;     * @return {@code log(1 + x)}.
<i>1392</i>&nbsp;     */
<i>1393</i>&nbsp;    public static double log1p(final double x) {
<b class="fc"><i>1394</i>&nbsp;        if (x == -1) {</b>
<b class="fc"><i>1395</i>&nbsp;            return Double.NEGATIVE_INFINITY;</b>
<i>1396</i>&nbsp;        }
<i>1397</i>&nbsp;
<b class="fc"><i>1398</i>&nbsp;        if (x == Double.POSITIVE_INFINITY) {</b>
<b class="fc"><i>1399</i>&nbsp;            return Double.POSITIVE_INFINITY;</b>
<i>1400</i>&nbsp;        }
<i>1401</i>&nbsp;
<b class="fc"><i>1402</i>&nbsp;        if (x &gt; 1e-6 ||</b>
<i>1403</i>&nbsp;            x &lt; -1e-6) {
<b class="fc"><i>1404</i>&nbsp;            final double xpa = 1 + x;</b>
<b class="fc"><i>1405</i>&nbsp;            final double xpb = -(xpa - 1 - x);</b>
<i>1406</i>&nbsp;
<b class="fc"><i>1407</i>&nbsp;            final double[] hiPrec = new double[2];</b>
<b class="fc"><i>1408</i>&nbsp;            final double lores = log(xpa, hiPrec);</b>
<b class="fc"><i>1409</i>&nbsp;            if (Double.isInfinite(lores)) { // Don&#39;t allow this to be converted to NaN</b>
<b class="nc"><i>1410</i>&nbsp;                return lores;</b>
<i>1411</i>&nbsp;            }
<i>1412</i>&nbsp;
<i>1413</i>&nbsp;            // Do a taylor series expansion around xpa:
<i>1414</i>&nbsp;            //   f(x+y) = f(x) + f&#39;(x) y + f&#39;&#39;(x)/2 y^2
<b class="fc"><i>1415</i>&nbsp;            final double fx1 = xpb / xpa;</b>
<b class="fc"><i>1416</i>&nbsp;            final double epsilon = 0.5 * fx1 + 1;</b>
<b class="fc"><i>1417</i>&nbsp;            return epsilon * fx1 + hiPrec[1] + hiPrec[0];</b>
<i>1418</i>&nbsp;        } else {
<i>1419</i>&nbsp;            // Value is small |x| &lt; 1e6, do a Taylor series centered on 1.
<b class="fc"><i>1420</i>&nbsp;            final double y = (x * F_1_3 - F_1_2) * x + 1;</b>
<b class="fc"><i>1421</i>&nbsp;            return y * x;</b>
<i>1422</i>&nbsp;        }
<i>1423</i>&nbsp;    }
<i>1424</i>&nbsp;
<i>1425</i>&nbsp;    /** Compute the base 10 logarithm.
<i>1426</i>&nbsp;     * @param x a number
<i>1427</i>&nbsp;     * @return log10(x)
<i>1428</i>&nbsp;     */
<i>1429</i>&nbsp;    public static double log10(final double x) {
<b class="fc"><i>1430</i>&nbsp;        final double hiPrec[] = new double[2];</b>
<i>1431</i>&nbsp;
<b class="fc"><i>1432</i>&nbsp;        final double lores = log(x, hiPrec);</b>
<b class="fc"><i>1433</i>&nbsp;        if (Double.isInfinite(lores)){ // don&#39;t allow this to be converted to NaN</b>
<b class="fc"><i>1434</i>&nbsp;            return lores;</b>
<i>1435</i>&nbsp;        }
<i>1436</i>&nbsp;
<b class="fc"><i>1437</i>&nbsp;        final double tmp = hiPrec[0] * HEX_40000000;</b>
<b class="fc"><i>1438</i>&nbsp;        final double lna = hiPrec[0] + tmp - tmp;</b>
<b class="fc"><i>1439</i>&nbsp;        final double lnb = hiPrec[0] - lna + hiPrec[1];</b>
<i>1440</i>&nbsp;
<b class="fc"><i>1441</i>&nbsp;        final double rln10a = 0.4342944622039795;</b>
<b class="fc"><i>1442</i>&nbsp;        final double rln10b = 1.9699272335463627E-8;</b>
<i>1443</i>&nbsp;
<b class="fc"><i>1444</i>&nbsp;        return rln10b * lnb + rln10b * lna + rln10a * lnb + rln10a * lna;</b>
<i>1445</i>&nbsp;    }
<i>1446</i>&nbsp;
<i>1447</i>&nbsp;    /**
<i>1448</i>&nbsp;     * Computes the &lt;a href=&quot;http://mathworld.wolfram.com/Logarithm.html&quot;&gt;
<i>1449</i>&nbsp;     * logarithm&lt;/a&gt; in a given base.
<i>1450</i>&nbsp;     *
<i>1451</i>&nbsp;     * Returns {@code NaN} if either argument is negative.
<i>1452</i>&nbsp;     * If {@code base} is 0 and {@code x} is positive, 0 is returned.
<i>1453</i>&nbsp;     * If {@code base} is positive and {@code x} is 0,
<i>1454</i>&nbsp;     * {@code Double.NEGATIVE_INFINITY} is returned.
<i>1455</i>&nbsp;     * If both arguments are 0, the result is {@code NaN}.
<i>1456</i>&nbsp;     *
<i>1457</i>&nbsp;     * @param base Base of the logarithm, must be greater than 0.
<i>1458</i>&nbsp;     * @param x Argument, must be greater than 0.
<i>1459</i>&nbsp;     * @return the value of the logarithm, i.e. the number {@code y} such that
<i>1460</i>&nbsp;     * &lt;code&gt;base&lt;sup&gt;y&lt;/sup&gt; = x&lt;/code&gt;.
<i>1461</i>&nbsp;     * @since 1.2 (previously in {@code MathUtils}, moved as of version 3.0)
<i>1462</i>&nbsp;     */
<i>1463</i>&nbsp;    public static double log(double base, double x) {
<b class="fc"><i>1464</i>&nbsp;        return log(x) / log(base);</b>
<i>1465</i>&nbsp;    }
<i>1466</i>&nbsp;
<i>1467</i>&nbsp;    /**
<i>1468</i>&nbsp;     * Power function.  Compute x^y.
<i>1469</i>&nbsp;     *
<i>1470</i>&nbsp;     * @param x   a double
<i>1471</i>&nbsp;     * @param y   a double
<i>1472</i>&nbsp;     * @return double
<i>1473</i>&nbsp;     */
<i>1474</i>&nbsp;    public static double pow(final double x, final double y) {
<i>1475</i>&nbsp;
<b class="fc"><i>1476</i>&nbsp;        if (y == 0) {</b>
<i>1477</i>&nbsp;            // y = -0 or y = +0
<b class="fc"><i>1478</i>&nbsp;            return 1.0;</b>
<i>1479</i>&nbsp;        } else {
<i>1480</i>&nbsp;
<b class="fc"><i>1481</i>&nbsp;            final long yBits        = Double.doubleToRawLongBits(y);</b>
<b class="fc"><i>1482</i>&nbsp;            final int  yRawExp      = (int) ((yBits &amp; MASK_DOUBLE_EXPONENT) &gt;&gt; 52);</b>
<b class="fc"><i>1483</i>&nbsp;            final long yRawMantissa = yBits &amp; MASK_DOUBLE_MANTISSA;</b>
<b class="fc"><i>1484</i>&nbsp;            final long xBits        = Double.doubleToRawLongBits(x);</b>
<b class="fc"><i>1485</i>&nbsp;            final int  xRawExp      = (int) ((xBits &amp; MASK_DOUBLE_EXPONENT) &gt;&gt; 52);</b>
<b class="fc"><i>1486</i>&nbsp;            final long xRawMantissa = xBits &amp; MASK_DOUBLE_MANTISSA;</b>
<i>1487</i>&nbsp;
<b class="fc"><i>1488</i>&nbsp;            if (yRawExp &gt; 1085) {</b>
<i>1489</i>&nbsp;                // y is either a very large integral value that does not fit in a long or it is a special number
<i>1490</i>&nbsp;
<b class="fc"><i>1491</i>&nbsp;                if ((yRawExp == 2047 &amp;&amp; yRawMantissa != 0) ||</b>
<i>1492</i>&nbsp;                    (xRawExp == 2047 &amp;&amp; xRawMantissa != 0)) {
<i>1493</i>&nbsp;                    // NaN
<b class="fc"><i>1494</i>&nbsp;                    return Double.NaN;</b>
<b class="fc"><i>1495</i>&nbsp;                } else if (xRawExp == 1023 &amp;&amp; xRawMantissa == 0) {</b>
<i>1496</i>&nbsp;                    // x = -1.0 or x = +1.0
<b class="fc"><i>1497</i>&nbsp;                    if (yRawExp == 2047) {</b>
<i>1498</i>&nbsp;                        // y is infinite
<b class="fc"><i>1499</i>&nbsp;                        return Double.NaN;</b>
<i>1500</i>&nbsp;                    } else {
<i>1501</i>&nbsp;                        // y is a large even integer
<b class="fc"><i>1502</i>&nbsp;                        return 1.0;</b>
<i>1503</i>&nbsp;                    }
<i>1504</i>&nbsp;                } else {
<i>1505</i>&nbsp;                    // the absolute value of x is either greater or smaller than 1.0
<i>1506</i>&nbsp;
<i>1507</i>&nbsp;                    // if yRawExp == 2047 and mantissa is 0, y = -infinity or y = +infinity
<i>1508</i>&nbsp;                    // if 1085 &lt; yRawExp &lt; 2047, y is simply a large number, however, due to limited
<i>1509</i>&nbsp;                    // accuracy, at this magnitude it behaves just like infinity with regards to x
<b class="fc"><i>1510</i>&nbsp;                    if ((y &gt; 0) ^ (xRawExp &lt; 1023)) {</b>
<i>1511</i>&nbsp;                        // either y = +infinity (or large engouh) and abs(x) &gt; 1.0
<i>1512</i>&nbsp;                        // or     y = -infinity (or large engouh) and abs(x) &lt; 1.0
<b class="fc"><i>1513</i>&nbsp;                        return Double.POSITIVE_INFINITY;</b>
<i>1514</i>&nbsp;                    } else {
<i>1515</i>&nbsp;                        // either y = +infinity (or large engouh) and abs(x) &lt; 1.0
<i>1516</i>&nbsp;                        // or     y = -infinity (or large engouh) and abs(x) &gt; 1.0
<b class="fc"><i>1517</i>&nbsp;                        return +0.0;</b>
<i>1518</i>&nbsp;                    }
<i>1519</i>&nbsp;                }
<i>1520</i>&nbsp;
<i>1521</i>&nbsp;            } else {
<i>1522</i>&nbsp;                // y is a regular non-zero number
<i>1523</i>&nbsp;
<b class="fc"><i>1524</i>&nbsp;                if (yRawExp &gt;= 1023) {</b>
<i>1525</i>&nbsp;                    // y may be an integral value, which should be handled specifically
<b class="fc"><i>1526</i>&nbsp;                    final long yFullMantissa = IMPLICIT_HIGH_BIT | yRawMantissa;</b>
<b class="fc"><i>1527</i>&nbsp;                    if (yRawExp &lt; 1075) {</b>
<i>1528</i>&nbsp;                        // normal number with negative shift that may have a fractional part
<b class="fc"><i>1529</i>&nbsp;                        final long integralMask = (-1L) &lt;&lt; (1075 - yRawExp);</b>
<b class="fc"><i>1530</i>&nbsp;                        if ((yFullMantissa &amp; integralMask) == yFullMantissa) {</b>
<i>1531</i>&nbsp;                            // all fractional bits are 0, the number is really integral
<b class="fc"><i>1532</i>&nbsp;                            final long l = yFullMantissa &gt;&gt; (1075 - yRawExp);</b>
<b class="fc"><i>1533</i>&nbsp;                            return FastMath.pow(x, (y &lt; 0) ? -l : l);</b>
<i>1534</i>&nbsp;                        }
<b class="fc"><i>1535</i>&nbsp;                    } else {</b>
<i>1536</i>&nbsp;                        // normal number with positive shift, always an integral value
<i>1537</i>&nbsp;                        // we know it fits in a primitive long because yRawExp &gt; 1085 has been handled above
<b class="fc"><i>1538</i>&nbsp;                        final long l =  yFullMantissa &lt;&lt; (yRawExp - 1075);</b>
<b class="fc"><i>1539</i>&nbsp;                        return FastMath.pow(x, (y &lt; 0) ? -l : l);</b>
<i>1540</i>&nbsp;                    }
<i>1541</i>&nbsp;                }
<i>1542</i>&nbsp;
<i>1543</i>&nbsp;                // y is a non-integral value
<i>1544</i>&nbsp;
<b class="fc"><i>1545</i>&nbsp;                if (x == 0) {</b>
<i>1546</i>&nbsp;                    // x = -0 or x = +0
<i>1547</i>&nbsp;                    // the integer powers have already been handled above
<b class="fc"><i>1548</i>&nbsp;                    return y &lt; 0 ? Double.POSITIVE_INFINITY : +0.0;</b>
<b class="fc"><i>1549</i>&nbsp;                } else if (xRawExp == 2047) {</b>
<b class="fc"><i>1550</i>&nbsp;                    if (xRawMantissa == 0) {</b>
<i>1551</i>&nbsp;                        // x = -infinity or x = +infinity
<b class="fc"><i>1552</i>&nbsp;                        return (y &lt; 0) ? +0.0 : Double.POSITIVE_INFINITY;</b>
<i>1553</i>&nbsp;                    } else {
<i>1554</i>&nbsp;                        // NaN
<b class="fc"><i>1555</i>&nbsp;                        return Double.NaN;</b>
<i>1556</i>&nbsp;                    }
<b class="fc"><i>1557</i>&nbsp;                } else if (x &lt; 0) {</b>
<i>1558</i>&nbsp;                    // the integer powers have already been handled above
<b class="fc"><i>1559</i>&nbsp;                    return Double.NaN;</b>
<i>1560</i>&nbsp;                } else {
<i>1561</i>&nbsp;
<i>1562</i>&nbsp;                    // this is the general case, for regular fractional numbers x and y
<i>1563</i>&nbsp;
<i>1564</i>&nbsp;                    // Split y into ya and yb such that y = ya+yb
<b class="fc"><i>1565</i>&nbsp;                    final double tmp = y * HEX_40000000;</b>
<b class="fc"><i>1566</i>&nbsp;                    final double ya = (y + tmp) - tmp;</b>
<b class="fc"><i>1567</i>&nbsp;                    final double yb = y - ya;</b>
<i>1568</i>&nbsp;
<i>1569</i>&nbsp;                    /* Compute ln(x) */
<b class="fc"><i>1570</i>&nbsp;                    final double lns[] = new double[2];</b>
<b class="fc"><i>1571</i>&nbsp;                    final double lores = log(x, lns);</b>
<b class="fc"><i>1572</i>&nbsp;                    if (Double.isInfinite(lores)) { // don&#39;t allow this to be converted to NaN</b>
<b class="nc"><i>1573</i>&nbsp;                        return lores;</b>
<i>1574</i>&nbsp;                    }
<i>1575</i>&nbsp;
<b class="fc"><i>1576</i>&nbsp;                    double lna = lns[0];</b>
<b class="fc"><i>1577</i>&nbsp;                    double lnb = lns[1];</b>
<i>1578</i>&nbsp;
<i>1579</i>&nbsp;                    /* resplit lns */
<b class="fc"><i>1580</i>&nbsp;                    final double tmp1 = lna * HEX_40000000;</b>
<b class="fc"><i>1581</i>&nbsp;                    final double tmp2 = (lna + tmp1) - tmp1;</b>
<b class="fc"><i>1582</i>&nbsp;                    lnb += lna - tmp2;</b>
<b class="fc"><i>1583</i>&nbsp;                    lna = tmp2;</b>
<i>1584</i>&nbsp;
<i>1585</i>&nbsp;                    // y*ln(x) = (aa+ab)
<b class="fc"><i>1586</i>&nbsp;                    final double aa = lna * ya;</b>
<b class="fc"><i>1587</i>&nbsp;                    final double ab = lna * yb + lnb * ya + lnb * yb;</b>
<i>1588</i>&nbsp;
<b class="fc"><i>1589</i>&nbsp;                    lna = aa+ab;</b>
<b class="fc"><i>1590</i>&nbsp;                    lnb = -(lna - aa - ab);</b>
<i>1591</i>&nbsp;
<b class="fc"><i>1592</i>&nbsp;                    double z = 1.0 / 120.0;</b>
<b class="fc"><i>1593</i>&nbsp;                    z = z * lnb + (1.0 / 24.0);</b>
<b class="fc"><i>1594</i>&nbsp;                    z = z * lnb + (1.0 / 6.0);</b>
<b class="fc"><i>1595</i>&nbsp;                    z = z * lnb + 0.5;</b>
<b class="fc"><i>1596</i>&nbsp;                    z = z * lnb + 1.0;</b>
<b class="fc"><i>1597</i>&nbsp;                    z *= lnb;</b>
<i>1598</i>&nbsp;
<b class="fc"><i>1599</i>&nbsp;                    final double result = exp(lna, z, null);</b>
<i>1600</i>&nbsp;                    //result = result + result * z;
<b class="fc"><i>1601</i>&nbsp;                    return result;</b>
<i>1602</i>&nbsp;
<i>1603</i>&nbsp;                }
<i>1604</i>&nbsp;            }
<i>1605</i>&nbsp;
<i>1606</i>&nbsp;        }
<i>1607</i>&nbsp;
<i>1608</i>&nbsp;    }
<i>1609</i>&nbsp;
<i>1610</i>&nbsp;    /**
<i>1611</i>&nbsp;     * Raise a double to an int power.
<i>1612</i>&nbsp;     *
<i>1613</i>&nbsp;     * @param d Number to raise.
<i>1614</i>&nbsp;     * @param e Exponent.
<i>1615</i>&nbsp;     * @return d&lt;sup&gt;e&lt;/sup&gt;
<i>1616</i>&nbsp;     * @since 3.1
<i>1617</i>&nbsp;     */
<i>1618</i>&nbsp;    public static double pow(double d, int e) {
<b class="fc"><i>1619</i>&nbsp;        return pow(d, (long) e);</b>
<i>1620</i>&nbsp;    }
<i>1621</i>&nbsp;
<i>1622</i>&nbsp;
<i>1623</i>&nbsp;    /**
<i>1624</i>&nbsp;     * Raise a double to a long power.
<i>1625</i>&nbsp;     *
<i>1626</i>&nbsp;     * @param d Number to raise.
<i>1627</i>&nbsp;     * @param e Exponent.
<i>1628</i>&nbsp;     * @return d&lt;sup&gt;e&lt;/sup&gt;
<i>1629</i>&nbsp;     * @since 3.6
<i>1630</i>&nbsp;     */
<i>1631</i>&nbsp;    public static double pow(double d, long e) {
<b class="fc"><i>1632</i>&nbsp;        if (e == 0) {</b>
<b class="fc"><i>1633</i>&nbsp;            return 1.0;</b>
<b class="fc"><i>1634</i>&nbsp;        } else if (e &gt; 0) {</b>
<b class="fc"><i>1635</i>&nbsp;            return new Split(d).pow(e).full;</b>
<i>1636</i>&nbsp;        } else {
<b class="fc"><i>1637</i>&nbsp;            return new Split(d).reciprocal().pow(-e).full;</b>
<i>1638</i>&nbsp;        }
<i>1639</i>&nbsp;    }
<i>1640</i>&nbsp;
<i>1641</i>&nbsp;    /** Class operator on double numbers split into one 26 bits number and one 27 bits number. */
<b class="fc"><i>1642</i>&nbsp;    private static class Split {</b>
<i>1643</i>&nbsp;
<i>1644</i>&nbsp;        /** Split version of NaN. */
<b class="fc"><i>1645</i>&nbsp;        public static final Split NAN = new Split(Double.NaN, 0);</b>
<i>1646</i>&nbsp;
<i>1647</i>&nbsp;        /** Split version of positive infinity. */
<b class="fc"><i>1648</i>&nbsp;        public static final Split POSITIVE_INFINITY = new Split(Double.POSITIVE_INFINITY, 0);</b>
<i>1649</i>&nbsp;
<i>1650</i>&nbsp;        /** Split version of negative infinity. */
<b class="fc"><i>1651</i>&nbsp;        public static final Split NEGATIVE_INFINITY = new Split(Double.NEGATIVE_INFINITY, 0);</b>
<i>1652</i>&nbsp;
<i>1653</i>&nbsp;        /** Full number. */
<i>1654</i>&nbsp;        private final double full;
<i>1655</i>&nbsp;
<i>1656</i>&nbsp;        /** High order bits. */
<i>1657</i>&nbsp;        private final double high;
<i>1658</i>&nbsp;
<i>1659</i>&nbsp;        /** Low order bits. */
<i>1660</i>&nbsp;        private final double low;
<i>1661</i>&nbsp;
<i>1662</i>&nbsp;        /** Simple constructor.
<i>1663</i>&nbsp;         * @param x number to split
<i>1664</i>&nbsp;         */
<b class="fc"><i>1665</i>&nbsp;        Split(final double x) {</b>
<b class="fc"><i>1666</i>&nbsp;            full = x;</b>
<b class="fc"><i>1667</i>&nbsp;            high = Double.longBitsToDouble(Double.doubleToRawLongBits(x) &amp; ((-1L) &lt;&lt; 27));</b>
<b class="fc"><i>1668</i>&nbsp;            low  = x - high;</b>
<b class="fc"><i>1669</i>&nbsp;        }</b>
<i>1670</i>&nbsp;
<i>1671</i>&nbsp;        /** Simple constructor.
<i>1672</i>&nbsp;         * @param high high order bits
<i>1673</i>&nbsp;         * @param low low order bits
<i>1674</i>&nbsp;         */
<i>1675</i>&nbsp;        Split(final double high, final double low) {
<b class="fc"><i>1676</i>&nbsp;            this(high == 0.0 ? (low == 0.0 &amp;&amp; Double.doubleToRawLongBits(high) == Long.MIN_VALUE /* negative zero */ ? -0.0 : low) : high + low, high, low);</b>
<b class="fc"><i>1677</i>&nbsp;        }</b>
<i>1678</i>&nbsp;
<i>1679</i>&nbsp;        /** Simple constructor.
<i>1680</i>&nbsp;         * @param full full number
<i>1681</i>&nbsp;         * @param high high order bits
<i>1682</i>&nbsp;         * @param low low order bits
<i>1683</i>&nbsp;         */
<b class="fc"><i>1684</i>&nbsp;        Split(final double full, final double high, final double low) {</b>
<b class="fc"><i>1685</i>&nbsp;            this.full = full;</b>
<b class="fc"><i>1686</i>&nbsp;            this.high = high;</b>
<b class="fc"><i>1687</i>&nbsp;            this.low  = low;</b>
<b class="fc"><i>1688</i>&nbsp;        }</b>
<i>1689</i>&nbsp;
<i>1690</i>&nbsp;        /** Multiply the instance by another one.
<i>1691</i>&nbsp;         * @param b other instance to multiply by
<i>1692</i>&nbsp;         * @return product
<i>1693</i>&nbsp;         */
<i>1694</i>&nbsp;        public Split multiply(final Split b) {
<i>1695</i>&nbsp;            // beware the following expressions must NOT be simplified, they rely on floating point arithmetic properties
<b class="fc"><i>1696</i>&nbsp;            final Split  mulBasic  = new Split(full * b.full);</b>
<b class="fc"><i>1697</i>&nbsp;            final double mulError  = low * b.low - (((mulBasic.full - high * b.high) - low * b.high) - high * b.low);</b>
<b class="fc"><i>1698</i>&nbsp;            return new Split(mulBasic.high, mulBasic.low + mulError);</b>
<i>1699</i>&nbsp;        }
<i>1700</i>&nbsp;
<i>1701</i>&nbsp;        /** Compute the reciprocal of the instance.
<i>1702</i>&nbsp;         * @return reciprocal of the instance
<i>1703</i>&nbsp;         */
<i>1704</i>&nbsp;        public Split reciprocal() {
<i>1705</i>&nbsp;
<b class="fc"><i>1706</i>&nbsp;            final double approximateInv = 1.0 / full;</b>
<b class="fc"><i>1707</i>&nbsp;            final Split  splitInv       = new Split(approximateInv);</b>
<i>1708</i>&nbsp;
<i>1709</i>&nbsp;            // if 1.0/d were computed perfectly, remultiplying it by d should give 1.0
<i>1710</i>&nbsp;            // we want to estimate the error so we can fix the low order bits of approximateInvLow
<i>1711</i>&nbsp;            // beware the following expressions must NOT be simplified, they rely on floating point arithmetic properties
<b class="fc"><i>1712</i>&nbsp;            final Split product = multiply(splitInv);</b>
<b class="fc"><i>1713</i>&nbsp;            final double error  = (product.high - 1) + product.low;</b>
<i>1714</i>&nbsp;
<i>1715</i>&nbsp;            // better accuracy estimate of reciprocal
<b class="fc"><i>1716</i>&nbsp;            return Double.isNaN(error) ? splitInv : new Split(splitInv.high, splitInv.low - error / full);</b>
<i>1717</i>&nbsp;
<i>1718</i>&nbsp;        }
<i>1719</i>&nbsp;
<i>1720</i>&nbsp;        /** Computes this^e.
<i>1721</i>&nbsp;         * @param e exponent (beware, here it MUST be &gt; 0; the only exclusion is Long.MIN_VALUE)
<i>1722</i>&nbsp;         * @return d^e, split in high and low bits
<i>1723</i>&nbsp;         * @since 3.6
<i>1724</i>&nbsp;         */
<i>1725</i>&nbsp;        private Split pow(final long e) {
<i>1726</i>&nbsp;
<i>1727</i>&nbsp;            // prepare result
<b class="fc"><i>1728</i>&nbsp;            Split result = new Split(1);</b>
<i>1729</i>&nbsp;
<i>1730</i>&nbsp;            // d^(2p)
<b class="fc"><i>1731</i>&nbsp;            Split d2p = new Split(full, high, low);</b>
<i>1732</i>&nbsp;
<b class="fc"><i>1733</i>&nbsp;            for (long p = e; p != 0; p &gt;&gt;&gt;= 1) {</b>
<i>1734</i>&nbsp;
<b class="fc"><i>1735</i>&nbsp;                if ((p &amp; 0x1) != 0) {</b>
<i>1736</i>&nbsp;                    // accurate multiplication result = result * d^(2p) using Veltkamp TwoProduct algorithm
<b class="fc"><i>1737</i>&nbsp;                    result = result.multiply(d2p);</b>
<i>1738</i>&nbsp;                }
<i>1739</i>&nbsp;
<i>1740</i>&nbsp;                // accurate squaring d^(2(p+1)) = d^(2p) * d^(2p) using Veltkamp TwoProduct algorithm
<b class="fc"><i>1741</i>&nbsp;                d2p = d2p.multiply(d2p);</b>
<i>1742</i>&nbsp;
<i>1743</i>&nbsp;            }
<i>1744</i>&nbsp;
<b class="fc"><i>1745</i>&nbsp;            if (Double.isNaN(result.full)) {</b>
<b class="fc"><i>1746</i>&nbsp;                if (Double.isNaN(full)) {</b>
<b class="fc"><i>1747</i>&nbsp;                    return Split.NAN;</b>
<i>1748</i>&nbsp;                } else {
<i>1749</i>&nbsp;                    // some intermediate numbers exceeded capacity,
<i>1750</i>&nbsp;                    // and the low order bits became NaN (because infinity - infinity = NaN)
<b class="fc"><i>1751</i>&nbsp;                    if (FastMath.abs(full) &lt; 1) {</b>
<b class="nc"><i>1752</i>&nbsp;                        return new Split(FastMath.copySign(0.0, full), 0.0);</b>
<b class="fc"><i>1753</i>&nbsp;                    } else if (full &lt; 0 &amp;&amp; (e &amp; 0x1) == 1) {</b>
<b class="fc"><i>1754</i>&nbsp;                        return Split.NEGATIVE_INFINITY;</b>
<i>1755</i>&nbsp;                    } else {
<b class="fc"><i>1756</i>&nbsp;                        return Split.POSITIVE_INFINITY;</b>
<i>1757</i>&nbsp;                    }
<i>1758</i>&nbsp;                }
<i>1759</i>&nbsp;            } else {
<b class="fc"><i>1760</i>&nbsp;                return result;</b>
<i>1761</i>&nbsp;            }
<i>1762</i>&nbsp;
<i>1763</i>&nbsp;        }
<i>1764</i>&nbsp;
<i>1765</i>&nbsp;    }
<i>1766</i>&nbsp;
<i>1767</i>&nbsp;    /**
<i>1768</i>&nbsp;     *  Computes sin(x) - x, where |x| &lt; 1/16.
<i>1769</i>&nbsp;     *  Use a Remez polynomial approximation.
<i>1770</i>&nbsp;     *  @param x a number smaller than 1/16
<i>1771</i>&nbsp;     *  @return sin(x) - x
<i>1772</i>&nbsp;     */
<i>1773</i>&nbsp;    private static double polySine(final double x)
<i>1774</i>&nbsp;    {
<b class="fc"><i>1775</i>&nbsp;        double x2 = x*x;</b>
<i>1776</i>&nbsp;
<b class="fc"><i>1777</i>&nbsp;        double p = 2.7553817452272217E-6;</b>
<b class="fc"><i>1778</i>&nbsp;        p = p * x2 + -1.9841269659586505E-4;</b>
<b class="fc"><i>1779</i>&nbsp;        p = p * x2 + 0.008333333333329196;</b>
<b class="fc"><i>1780</i>&nbsp;        p = p * x2 + -0.16666666666666666;</b>
<i>1781</i>&nbsp;        //p *= x2;
<i>1782</i>&nbsp;        //p *= x;
<b class="fc"><i>1783</i>&nbsp;        p = p * x2 * x;</b>
<i>1784</i>&nbsp;
<b class="fc"><i>1785</i>&nbsp;        return p;</b>
<i>1786</i>&nbsp;    }
<i>1787</i>&nbsp;
<i>1788</i>&nbsp;    /**
<i>1789</i>&nbsp;     *  Computes cos(x) - 1, where |x| &lt; 1/16.
<i>1790</i>&nbsp;     *  Use a Remez polynomial approximation.
<i>1791</i>&nbsp;     *  @param x a number smaller than 1/16
<i>1792</i>&nbsp;     *  @return cos(x) - 1
<i>1793</i>&nbsp;     */
<i>1794</i>&nbsp;    private static double polyCosine(double x) {
<b class="fc"><i>1795</i>&nbsp;        double x2 = x*x;</b>
<i>1796</i>&nbsp;
<b class="fc"><i>1797</i>&nbsp;        double p = 2.479773539153719E-5;</b>
<b class="fc"><i>1798</i>&nbsp;        p = p * x2 + -0.0013888888689039883;</b>
<b class="fc"><i>1799</i>&nbsp;        p = p * x2 + 0.041666666666621166;</b>
<b class="fc"><i>1800</i>&nbsp;        p = p * x2 + -0.49999999999999994;</b>
<b class="fc"><i>1801</i>&nbsp;        p *= x2;</b>
<i>1802</i>&nbsp;
<b class="fc"><i>1803</i>&nbsp;        return p;</b>
<i>1804</i>&nbsp;    }
<i>1805</i>&nbsp;
<i>1806</i>&nbsp;    /**
<i>1807</i>&nbsp;     *  Compute sine over the first quadrant (0 &lt; x &lt; pi/2).
<i>1808</i>&nbsp;     *  Use combination of table lookup and rational polynomial expansion.
<i>1809</i>&nbsp;     *  @param xa number from which sine is requested
<i>1810</i>&nbsp;     *  @param xb extra bits for x (may be 0.0)
<i>1811</i>&nbsp;     *  @return sin(xa + xb)
<i>1812</i>&nbsp;     */
<i>1813</i>&nbsp;    private static double sinQ(double xa, double xb) {
<b class="fc"><i>1814</i>&nbsp;        int idx = (int) ((xa * 8.0) + 0.5);</b>
<b class="fc"><i>1815</i>&nbsp;        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;</b>
<i>1816</i>&nbsp;
<i>1817</i>&nbsp;        // Table lookups
<b class="fc"><i>1818</i>&nbsp;        final double sintA = SINE_TABLE_A[idx];</b>
<b class="fc"><i>1819</i>&nbsp;        final double sintB = SINE_TABLE_B[idx];</b>
<b class="fc"><i>1820</i>&nbsp;        final double costA = COSINE_TABLE_A[idx];</b>
<b class="fc"><i>1821</i>&nbsp;        final double costB = COSINE_TABLE_B[idx];</b>
<i>1822</i>&nbsp;
<i>1823</i>&nbsp;        // Polynomial eval of sin(epsilon), cos(epsilon)
<b class="fc"><i>1824</i>&nbsp;        double sinEpsA = epsilon;</b>
<b class="fc"><i>1825</i>&nbsp;        double sinEpsB = polySine(epsilon);</b>
<b class="fc"><i>1826</i>&nbsp;        final double cosEpsA = 1.0;</b>
<b class="fc"><i>1827</i>&nbsp;        final double cosEpsB = polyCosine(epsilon);</b>
<i>1828</i>&nbsp;
<i>1829</i>&nbsp;        // Split epsilon   xa + xb = x
<b class="fc"><i>1830</i>&nbsp;        final double temp = sinEpsA * HEX_40000000;</b>
<b class="fc"><i>1831</i>&nbsp;        double temp2 = (sinEpsA + temp) - temp;</b>
<b class="fc"><i>1832</i>&nbsp;        sinEpsB +=  sinEpsA - temp2;</b>
<b class="fc"><i>1833</i>&nbsp;        sinEpsA = temp2;</b>
<i>1834</i>&nbsp;
<i>1835</i>&nbsp;        /* Compute sin(x) by angle addition formula */
<i>1836</i>&nbsp;        double result;
<i>1837</i>&nbsp;
<i>1838</i>&nbsp;        /* Compute the following sum:
<i>1839</i>&nbsp;         *
<i>1840</i>&nbsp;         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +
<i>1841</i>&nbsp;         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;
<i>1842</i>&nbsp;         *
<i>1843</i>&nbsp;         * Ranges of elements
<i>1844</i>&nbsp;         *
<i>1845</i>&nbsp;         * xxxtA   0            PI/2
<i>1846</i>&nbsp;         * xxxtB   -1.5e-9      1.5e-9
<i>1847</i>&nbsp;         * sinEpsA -0.0625      0.0625
<i>1848</i>&nbsp;         * sinEpsB -6e-11       6e-11
<i>1849</i>&nbsp;         * cosEpsA  1.0
<i>1850</i>&nbsp;         * cosEpsB  0           -0.0625
<i>1851</i>&nbsp;         *
<i>1852</i>&nbsp;         */
<i>1853</i>&nbsp;
<i>1854</i>&nbsp;        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +
<i>1855</i>&nbsp;        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;
<i>1856</i>&nbsp;
<i>1857</i>&nbsp;        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;
<i>1858</i>&nbsp;        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;
<b class="fc"><i>1859</i>&nbsp;        double a = 0;</b>
<b class="fc"><i>1860</i>&nbsp;        double b = 0;</b>
<i>1861</i>&nbsp;
<b class="fc"><i>1862</i>&nbsp;        double t = sintA;</b>
<b class="fc"><i>1863</i>&nbsp;        double c = a + t;</b>
<b class="fc"><i>1864</i>&nbsp;        double d = -(c - a - t);</b>
<b class="fc"><i>1865</i>&nbsp;        a = c;</b>
<b class="fc"><i>1866</i>&nbsp;        b += d;</b>
<i>1867</i>&nbsp;
<b class="fc"><i>1868</i>&nbsp;        t = costA * sinEpsA;</b>
<b class="fc"><i>1869</i>&nbsp;        c = a + t;</b>
<b class="fc"><i>1870</i>&nbsp;        d = -(c - a - t);</b>
<b class="fc"><i>1871</i>&nbsp;        a = c;</b>
<b class="fc"><i>1872</i>&nbsp;        b += d;</b>
<i>1873</i>&nbsp;
<b class="fc"><i>1874</i>&nbsp;        b = b + sintA * cosEpsB + costA * sinEpsB;</b>
<i>1875</i>&nbsp;        /*
<i>1876</i>&nbsp;    t = sintA*cosEpsB;
<i>1877</i>&nbsp;    c = a + t;
<i>1878</i>&nbsp;    d = -(c - a - t);
<i>1879</i>&nbsp;    a = c;
<i>1880</i>&nbsp;    b = b + d;
<i>1881</i>&nbsp;
<i>1882</i>&nbsp;    t = costA*sinEpsB;
<i>1883</i>&nbsp;    c = a + t;
<i>1884</i>&nbsp;    d = -(c - a - t);
<i>1885</i>&nbsp;    a = c;
<i>1886</i>&nbsp;    b = b + d;
<i>1887</i>&nbsp;         */
<i>1888</i>&nbsp;
<b class="fc"><i>1889</i>&nbsp;        b = b + sintB + costB * sinEpsA + sintB * cosEpsB + costB * sinEpsB;</b>
<i>1890</i>&nbsp;        /*
<i>1891</i>&nbsp;    t = sintB;
<i>1892</i>&nbsp;    c = a + t;
<i>1893</i>&nbsp;    d = -(c - a - t);
<i>1894</i>&nbsp;    a = c;
<i>1895</i>&nbsp;    b = b + d;
<i>1896</i>&nbsp;
<i>1897</i>&nbsp;    t = costB*sinEpsA;
<i>1898</i>&nbsp;    c = a + t;
<i>1899</i>&nbsp;    d = -(c - a - t);
<i>1900</i>&nbsp;    a = c;
<i>1901</i>&nbsp;    b = b + d;
<i>1902</i>&nbsp;
<i>1903</i>&nbsp;    t = sintB*cosEpsB;
<i>1904</i>&nbsp;    c = a + t;
<i>1905</i>&nbsp;    d = -(c - a - t);
<i>1906</i>&nbsp;    a = c;
<i>1907</i>&nbsp;    b = b + d;
<i>1908</i>&nbsp;
<i>1909</i>&nbsp;    t = costB*sinEpsB;
<i>1910</i>&nbsp;    c = a + t;
<i>1911</i>&nbsp;    d = -(c - a - t);
<i>1912</i>&nbsp;    a = c;
<i>1913</i>&nbsp;    b = b + d;
<i>1914</i>&nbsp;         */
<i>1915</i>&nbsp;
<b class="fc"><i>1916</i>&nbsp;        if (xb != 0.0) {</b>
<b class="fc"><i>1917</i>&nbsp;            t = ((costA + costB) * (cosEpsA + cosEpsB) -</b>
<i>1918</i>&nbsp;                 (sintA + sintB) * (sinEpsA + sinEpsB)) * xb;  // approximate cosine*xb
<b class="fc"><i>1919</i>&nbsp;            c = a + t;</b>
<b class="fc"><i>1920</i>&nbsp;            d = -(c - a - t);</b>
<b class="fc"><i>1921</i>&nbsp;            a = c;</b>
<b class="fc"><i>1922</i>&nbsp;            b += d;</b>
<i>1923</i>&nbsp;        }
<i>1924</i>&nbsp;
<b class="fc"><i>1925</i>&nbsp;        result = a + b;</b>
<i>1926</i>&nbsp;
<b class="fc"><i>1927</i>&nbsp;        return result;</b>
<i>1928</i>&nbsp;    }
<i>1929</i>&nbsp;
<i>1930</i>&nbsp;    /**
<i>1931</i>&nbsp;     * Compute cosine in the first quadrant by subtracting input from PI/2 and
<i>1932</i>&nbsp;     * then calling sinQ.  This is more accurate as the input approaches PI/2.
<i>1933</i>&nbsp;     *  @param xa number from which cosine is requested
<i>1934</i>&nbsp;     *  @param xb extra bits for x (may be 0.0)
<i>1935</i>&nbsp;     *  @return cos(xa + xb)
<i>1936</i>&nbsp;     */
<i>1937</i>&nbsp;    private static double cosQ(double xa, double xb) {
<b class="fc"><i>1938</i>&nbsp;        final double pi2a = 1.5707963267948966;</b>
<b class="fc"><i>1939</i>&nbsp;        final double pi2b = 6.123233995736766E-17;</b>
<i>1940</i>&nbsp;
<b class="fc"><i>1941</i>&nbsp;        final double a = pi2a - xa;</b>
<b class="fc"><i>1942</i>&nbsp;        double b = -(a - pi2a + xa);</b>
<b class="fc"><i>1943</i>&nbsp;        b += pi2b - xb;</b>
<i>1944</i>&nbsp;
<b class="fc"><i>1945</i>&nbsp;        return sinQ(a, b);</b>
<i>1946</i>&nbsp;    }
<i>1947</i>&nbsp;
<i>1948</i>&nbsp;    /**
<i>1949</i>&nbsp;     *  Compute tangent (or cotangent) over the first quadrant.   0 &lt; x &lt; pi/2
<i>1950</i>&nbsp;     *  Use combination of table lookup and rational polynomial expansion.
<i>1951</i>&nbsp;     *  @param xa number from which sine is requested
<i>1952</i>&nbsp;     *  @param xb extra bits for x (may be 0.0)
<i>1953</i>&nbsp;     *  @param cotanFlag if true, compute the cotangent instead of the tangent
<i>1954</i>&nbsp;     *  @return tan(xa+xb) (or cotangent, depending on cotanFlag)
<i>1955</i>&nbsp;     */
<i>1956</i>&nbsp;    private static double tanQ(double xa, double xb, boolean cotanFlag) {
<i>1957</i>&nbsp;
<b class="fc"><i>1958</i>&nbsp;        int idx = (int) ((xa * 8.0) + 0.5);</b>
<b class="fc"><i>1959</i>&nbsp;        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;</b>
<i>1960</i>&nbsp;
<i>1961</i>&nbsp;        // Table lookups
<b class="fc"><i>1962</i>&nbsp;        final double sintA = SINE_TABLE_A[idx];</b>
<b class="fc"><i>1963</i>&nbsp;        final double sintB = SINE_TABLE_B[idx];</b>
<b class="fc"><i>1964</i>&nbsp;        final double costA = COSINE_TABLE_A[idx];</b>
<b class="fc"><i>1965</i>&nbsp;        final double costB = COSINE_TABLE_B[idx];</b>
<i>1966</i>&nbsp;
<i>1967</i>&nbsp;        // Polynomial eval of sin(epsilon), cos(epsilon)
<b class="fc"><i>1968</i>&nbsp;        double sinEpsA = epsilon;</b>
<b class="fc"><i>1969</i>&nbsp;        double sinEpsB = polySine(epsilon);</b>
<b class="fc"><i>1970</i>&nbsp;        final double cosEpsA = 1.0;</b>
<b class="fc"><i>1971</i>&nbsp;        final double cosEpsB = polyCosine(epsilon);</b>
<i>1972</i>&nbsp;
<i>1973</i>&nbsp;        // Split epsilon   xa + xb = x
<b class="fc"><i>1974</i>&nbsp;        double temp = sinEpsA * HEX_40000000;</b>
<b class="fc"><i>1975</i>&nbsp;        double temp2 = (sinEpsA + temp) - temp;</b>
<b class="fc"><i>1976</i>&nbsp;        sinEpsB +=  sinEpsA - temp2;</b>
<b class="fc"><i>1977</i>&nbsp;        sinEpsA = temp2;</b>
<i>1978</i>&nbsp;
<i>1979</i>&nbsp;        /* Compute sin(x) by angle addition formula */
<i>1980</i>&nbsp;
<i>1981</i>&nbsp;        /* Compute the following sum:
<i>1982</i>&nbsp;         *
<i>1983</i>&nbsp;         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +
<i>1984</i>&nbsp;         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;
<i>1985</i>&nbsp;         *
<i>1986</i>&nbsp;         * Ranges of elements
<i>1987</i>&nbsp;         *
<i>1988</i>&nbsp;         * xxxtA   0            PI/2
<i>1989</i>&nbsp;         * xxxtB   -1.5e-9      1.5e-9
<i>1990</i>&nbsp;         * sinEpsA -0.0625      0.0625
<i>1991</i>&nbsp;         * sinEpsB -6e-11       6e-11
<i>1992</i>&nbsp;         * cosEpsA  1.0
<i>1993</i>&nbsp;         * cosEpsB  0           -0.0625
<i>1994</i>&nbsp;         *
<i>1995</i>&nbsp;         */
<i>1996</i>&nbsp;
<i>1997</i>&nbsp;        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +
<i>1998</i>&nbsp;        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;
<i>1999</i>&nbsp;
<i>2000</i>&nbsp;        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;
<i>2001</i>&nbsp;        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;
<b class="fc"><i>2002</i>&nbsp;        double a = 0;</b>
<b class="fc"><i>2003</i>&nbsp;        double b = 0;</b>
<i>2004</i>&nbsp;
<i>2005</i>&nbsp;        // Compute sine
<b class="fc"><i>2006</i>&nbsp;        double t = sintA;</b>
<b class="fc"><i>2007</i>&nbsp;        double c = a + t;</b>
<b class="fc"><i>2008</i>&nbsp;        double d = -(c - a - t);</b>
<b class="fc"><i>2009</i>&nbsp;        a = c;</b>
<b class="fc"><i>2010</i>&nbsp;        b += d;</b>
<i>2011</i>&nbsp;
<b class="fc"><i>2012</i>&nbsp;        t = costA*sinEpsA;</b>
<b class="fc"><i>2013</i>&nbsp;        c = a + t;</b>
<b class="fc"><i>2014</i>&nbsp;        d = -(c - a - t);</b>
<b class="fc"><i>2015</i>&nbsp;        a = c;</b>
<b class="fc"><i>2016</i>&nbsp;        b += d;</b>
<i>2017</i>&nbsp;
<b class="fc"><i>2018</i>&nbsp;        b += sintA*cosEpsB + costA*sinEpsB;</b>
<b class="fc"><i>2019</i>&nbsp;        b += sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;</b>
<i>2020</i>&nbsp;
<b class="fc"><i>2021</i>&nbsp;        double sina = a + b;</b>
<b class="fc"><i>2022</i>&nbsp;        double sinb = -(sina - a - b);</b>
<i>2023</i>&nbsp;
<i>2024</i>&nbsp;        // Compute cosine
<i>2025</i>&nbsp;
<b class="fc"><i>2026</i>&nbsp;        a = b = c = d = 0.0;</b>
<i>2027</i>&nbsp;
<b class="fc"><i>2028</i>&nbsp;        t = costA*cosEpsA;</b>
<b class="fc"><i>2029</i>&nbsp;        c = a + t;</b>
<b class="fc"><i>2030</i>&nbsp;        d = -(c - a - t);</b>
<b class="fc"><i>2031</i>&nbsp;        a = c;</b>
<b class="fc"><i>2032</i>&nbsp;        b += d;</b>
<i>2033</i>&nbsp;
<b class="fc"><i>2034</i>&nbsp;        t = -sintA*sinEpsA;</b>
<b class="fc"><i>2035</i>&nbsp;        c = a + t;</b>
<b class="fc"><i>2036</i>&nbsp;        d = -(c - a - t);</b>
<b class="fc"><i>2037</i>&nbsp;        a = c;</b>
<b class="fc"><i>2038</i>&nbsp;        b += d;</b>
<i>2039</i>&nbsp;
<b class="fc"><i>2040</i>&nbsp;        b += costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;</b>
<b class="fc"><i>2041</i>&nbsp;        b -= sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB;</b>
<i>2042</i>&nbsp;
<b class="fc"><i>2043</i>&nbsp;        double cosa = a + b;</b>
<b class="fc"><i>2044</i>&nbsp;        double cosb = -(cosa - a - b);</b>
<i>2045</i>&nbsp;
<b class="fc"><i>2046</i>&nbsp;        if (cotanFlag) {</b>
<i>2047</i>&nbsp;            double tmp;
<b class="fc"><i>2048</i>&nbsp;            tmp = cosa; cosa = sina; sina = tmp;</b>
<b class="fc"><i>2049</i>&nbsp;            tmp = cosb; cosb = sinb; sinb = tmp;</b>
<i>2050</i>&nbsp;        }
<i>2051</i>&nbsp;
<i>2052</i>&nbsp;
<i>2053</i>&nbsp;        /* estimate and correct, compute 1.0/(cosa+cosb) */
<i>2054</i>&nbsp;        /*
<i>2055</i>&nbsp;    double est = (sina+sinb)/(cosa+cosb);
<i>2056</i>&nbsp;    double err = (sina - cosa*est) + (sinb - cosb*est);
<i>2057</i>&nbsp;    est += err/(cosa+cosb);
<i>2058</i>&nbsp;    err = (sina - cosa*est) + (sinb - cosb*est);
<i>2059</i>&nbsp;         */
<i>2060</i>&nbsp;
<i>2061</i>&nbsp;        // f(x) = 1/x,   f&#39;(x) = -1/x^2
<i>2062</i>&nbsp;
<b class="fc"><i>2063</i>&nbsp;        double est = sina/cosa;</b>
<i>2064</i>&nbsp;
<i>2065</i>&nbsp;        /* Split the estimate to get more accurate read on division rounding */
<b class="fc"><i>2066</i>&nbsp;        temp = est * HEX_40000000;</b>
<b class="fc"><i>2067</i>&nbsp;        double esta = (est + temp) - temp;</b>
<b class="fc"><i>2068</i>&nbsp;        double estb =  est - esta;</b>
<i>2069</i>&nbsp;
<b class="fc"><i>2070</i>&nbsp;        temp = cosa * HEX_40000000;</b>
<b class="fc"><i>2071</i>&nbsp;        double cosaa = (cosa + temp) - temp;</b>
<b class="fc"><i>2072</i>&nbsp;        double cosab =  cosa - cosaa;</b>
<i>2073</i>&nbsp;
<i>2074</i>&nbsp;        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding
<b class="fc"><i>2075</i>&nbsp;        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding</b>
<b class="fc"><i>2076</i>&nbsp;        err += sinb/cosa;                     // Change in est due to sinb</b>
<b class="fc"><i>2077</i>&nbsp;        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb</b>
<i>2078</i>&nbsp;
<b class="fc"><i>2079</i>&nbsp;        if (xb != 0.0) {</b>
<i>2080</i>&nbsp;            // tan&#39; = 1 + tan^2      cot&#39; = -(1 + cot^2)
<i>2081</i>&nbsp;            // Approximate impact of xb
<b class="fc"><i>2082</i>&nbsp;            double xbadj = xb + est*est*xb;</b>
<b class="fc"><i>2083</i>&nbsp;            if (cotanFlag) {</b>
<b class="fc"><i>2084</i>&nbsp;                xbadj = -xbadj;</b>
<i>2085</i>&nbsp;            }
<i>2086</i>&nbsp;
<b class="fc"><i>2087</i>&nbsp;            err += xbadj;</b>
<i>2088</i>&nbsp;        }
<i>2089</i>&nbsp;
<b class="fc"><i>2090</i>&nbsp;        return est+err;</b>
<i>2091</i>&nbsp;    }
<i>2092</i>&nbsp;
<i>2093</i>&nbsp;    /** Reduce the input argument using the Payne and Hanek method.
<i>2094</i>&nbsp;     *  This is good for all inputs 0.0 &lt; x &lt; inf
<i>2095</i>&nbsp;     *  Output is remainder after dividing by PI/2
<i>2096</i>&nbsp;     *  The result array should contain 3 numbers.
<i>2097</i>&nbsp;     *  result[0] is the integer portion, so mod 4 this gives the quadrant.
<i>2098</i>&nbsp;     *  result[1] is the upper bits of the remainder
<i>2099</i>&nbsp;     *  result[2] is the lower bits of the remainder
<i>2100</i>&nbsp;     *
<i>2101</i>&nbsp;     * @param x number to reduce
<i>2102</i>&nbsp;     * @param result placeholder where to put the result
<i>2103</i>&nbsp;     */
<i>2104</i>&nbsp;    private static void reducePayneHanek(double x, double result[])
<i>2105</i>&nbsp;    {
<i>2106</i>&nbsp;        /* Convert input double to bits */
<b class="fc"><i>2107</i>&nbsp;        long inbits = Double.doubleToRawLongBits(x);</b>
<b class="fc"><i>2108</i>&nbsp;        int exponent = (int) ((inbits &gt;&gt; 52) &amp; 0x7ff) - 1023;</b>
<i>2109</i>&nbsp;
<i>2110</i>&nbsp;        /* Convert to fixed point representation */
<b class="fc"><i>2111</i>&nbsp;        inbits &amp;= 0x000fffffffffffffL;</b>
<b class="fc"><i>2112</i>&nbsp;        inbits |= 0x0010000000000000L;</b>
<i>2113</i>&nbsp;
<i>2114</i>&nbsp;        /* Normalize input to be between 0.5 and 1.0 */
<b class="fc"><i>2115</i>&nbsp;        exponent++;</b>
<b class="fc"><i>2116</i>&nbsp;        inbits &lt;&lt;= 11;</b>
<i>2117</i>&nbsp;
<i>2118</i>&nbsp;        /* Based on the exponent, get a shifted copy of recip2pi */
<i>2119</i>&nbsp;        long shpi0;
<i>2120</i>&nbsp;        long shpiA;
<i>2121</i>&nbsp;        long shpiB;
<b class="fc"><i>2122</i>&nbsp;        int idx = exponent &gt;&gt; 6;</b>
<b class="fc"><i>2123</i>&nbsp;        int shift = exponent - (idx &lt;&lt; 6);</b>
<i>2124</i>&nbsp;
<b class="fc"><i>2125</i>&nbsp;        if (shift != 0) {</b>
<b class="fc"><i>2126</i>&nbsp;            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] &lt;&lt; shift);</b>
<b class="fc"><i>2127</i>&nbsp;            shpi0 |= RECIP_2PI[idx] &gt;&gt;&gt; (64-shift);</b>
<b class="fc"><i>2128</i>&nbsp;            shpiA = (RECIP_2PI[idx] &lt;&lt; shift) | (RECIP_2PI[idx+1] &gt;&gt;&gt; (64-shift));</b>
<b class="fc"><i>2129</i>&nbsp;            shpiB = (RECIP_2PI[idx+1] &lt;&lt; shift) | (RECIP_2PI[idx+2] &gt;&gt;&gt; (64-shift));</b>
<i>2130</i>&nbsp;        } else {
<b class="fc"><i>2131</i>&nbsp;            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];</b>
<b class="fc"><i>2132</i>&nbsp;            shpiA = RECIP_2PI[idx];</b>
<b class="fc"><i>2133</i>&nbsp;            shpiB = RECIP_2PI[idx+1];</b>
<i>2134</i>&nbsp;        }
<i>2135</i>&nbsp;
<i>2136</i>&nbsp;        /* Multiply input by shpiA */
<b class="fc"><i>2137</i>&nbsp;        long a = inbits &gt;&gt;&gt; 32;</b>
<b class="fc"><i>2138</i>&nbsp;        long b = inbits &amp; 0xffffffffL;</b>
<i>2139</i>&nbsp;
<b class="fc"><i>2140</i>&nbsp;        long c = shpiA &gt;&gt;&gt; 32;</b>
<b class="fc"><i>2141</i>&nbsp;        long d = shpiA &amp; 0xffffffffL;</b>
<i>2142</i>&nbsp;
<b class="fc"><i>2143</i>&nbsp;        long ac = a * c;</b>
<b class="fc"><i>2144</i>&nbsp;        long bd = b * d;</b>
<b class="fc"><i>2145</i>&nbsp;        long bc = b * c;</b>
<b class="fc"><i>2146</i>&nbsp;        long ad = a * d;</b>
<i>2147</i>&nbsp;
<b class="fc"><i>2148</i>&nbsp;        long prodB = bd + (ad &lt;&lt; 32);</b>
<b class="fc"><i>2149</i>&nbsp;        long prodA = ac + (ad &gt;&gt;&gt; 32);</b>
<i>2150</i>&nbsp;
<b class="fc"><i>2151</i>&nbsp;        boolean bita = (bd &amp; 0x8000000000000000L) != 0;</b>
<b class="fc"><i>2152</i>&nbsp;        boolean bitb = (ad &amp; 0x80000000L ) != 0;</b>
<b class="fc"><i>2153</i>&nbsp;        boolean bitsum = (prodB &amp; 0x8000000000000000L) != 0;</b>
<i>2154</i>&nbsp;
<i>2155</i>&nbsp;        /* Carry */
<b class="fc"><i>2156</i>&nbsp;        if ( (bita &amp;&amp; bitb) ||</b>
<i>2157</i>&nbsp;                ((bita || bitb) &amp;&amp; !bitsum) ) {
<b class="nc"><i>2158</i>&nbsp;            prodA++;</b>
<i>2159</i>&nbsp;        }
<i>2160</i>&nbsp;
<b class="fc"><i>2161</i>&nbsp;        bita = (prodB &amp; 0x8000000000000000L) != 0;</b>
<b class="fc"><i>2162</i>&nbsp;        bitb = (bc &amp; 0x80000000L ) != 0;</b>
<i>2163</i>&nbsp;
<b class="fc"><i>2164</i>&nbsp;        prodB += bc &lt;&lt; 32;</b>
<b class="fc"><i>2165</i>&nbsp;        prodA += bc &gt;&gt;&gt; 32;</b>
<i>2166</i>&nbsp;
<b class="fc"><i>2167</i>&nbsp;        bitsum = (prodB &amp; 0x8000000000000000L) != 0;</b>
<i>2168</i>&nbsp;
<i>2169</i>&nbsp;        /* Carry */
<b class="fc"><i>2170</i>&nbsp;        if ( (bita &amp;&amp; bitb) ||</b>
<i>2171</i>&nbsp;                ((bita || bitb) &amp;&amp; !bitsum) ) {
<b class="fc"><i>2172</i>&nbsp;            prodA++;</b>
<i>2173</i>&nbsp;        }
<i>2174</i>&nbsp;
<i>2175</i>&nbsp;        /* Multiply input by shpiB */
<b class="fc"><i>2176</i>&nbsp;        c = shpiB &gt;&gt;&gt; 32;</b>
<b class="fc"><i>2177</i>&nbsp;        d = shpiB &amp; 0xffffffffL;</b>
<b class="fc"><i>2178</i>&nbsp;        ac = a * c;</b>
<b class="fc"><i>2179</i>&nbsp;        bc = b * c;</b>
<b class="fc"><i>2180</i>&nbsp;        ad = a * d;</b>
<i>2181</i>&nbsp;
<i>2182</i>&nbsp;        /* Collect terms */
<b class="fc"><i>2183</i>&nbsp;        ac += (bc + ad) &gt;&gt;&gt; 32;</b>
<i>2184</i>&nbsp;
<b class="fc"><i>2185</i>&nbsp;        bita = (prodB &amp; 0x8000000000000000L) != 0;</b>
<b class="fc"><i>2186</i>&nbsp;        bitb = (ac &amp; 0x8000000000000000L ) != 0;</b>
<b class="fc"><i>2187</i>&nbsp;        prodB += ac;</b>
<b class="fc"><i>2188</i>&nbsp;        bitsum = (prodB &amp; 0x8000000000000000L) != 0;</b>
<i>2189</i>&nbsp;        /* Carry */
<b class="fc"><i>2190</i>&nbsp;        if ( (bita &amp;&amp; bitb) ||</b>
<i>2191</i>&nbsp;                ((bita || bitb) &amp;&amp; !bitsum) ) {
<b class="fc"><i>2192</i>&nbsp;            prodA++;</b>
<i>2193</i>&nbsp;        }
<i>2194</i>&nbsp;
<i>2195</i>&nbsp;        /* Multiply by shpi0 */
<b class="fc"><i>2196</i>&nbsp;        c = shpi0 &gt;&gt;&gt; 32;</b>
<b class="fc"><i>2197</i>&nbsp;        d = shpi0 &amp; 0xffffffffL;</b>
<i>2198</i>&nbsp;
<b class="fc"><i>2199</i>&nbsp;        bd = b * d;</b>
<b class="fc"><i>2200</i>&nbsp;        bc = b * c;</b>
<b class="fc"><i>2201</i>&nbsp;        ad = a * d;</b>
<i>2202</i>&nbsp;
<b class="fc"><i>2203</i>&nbsp;        prodA += bd + ((bc + ad) &lt;&lt; 32);</b>
<i>2204</i>&nbsp;
<i>2205</i>&nbsp;        /*
<i>2206</i>&nbsp;         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of
<i>2207</i>&nbsp;         * PI/2, so use the following steps:
<i>2208</i>&nbsp;         * 1.) multiply by 4.
<i>2209</i>&nbsp;         * 2.) do a fixed point muliply by PI/4.
<i>2210</i>&nbsp;         * 3.) Convert to floating point.
<i>2211</i>&nbsp;         * 4.) Multiply by 2
<i>2212</i>&nbsp;         */
<i>2213</i>&nbsp;
<i>2214</i>&nbsp;        /* This identifies the quadrant */
<b class="fc"><i>2215</i>&nbsp;        int intPart = (int)(prodA &gt;&gt;&gt; 62);</b>
<i>2216</i>&nbsp;
<i>2217</i>&nbsp;        /* Multiply by 4 */
<b class="fc"><i>2218</i>&nbsp;        prodA &lt;&lt;= 2;</b>
<b class="fc"><i>2219</i>&nbsp;        prodA |= prodB &gt;&gt;&gt; 62;</b>
<b class="fc"><i>2220</i>&nbsp;        prodB &lt;&lt;= 2;</b>
<i>2221</i>&nbsp;
<i>2222</i>&nbsp;        /* Multiply by PI/4 */
<b class="fc"><i>2223</i>&nbsp;        a = prodA &gt;&gt;&gt; 32;</b>
<b class="fc"><i>2224</i>&nbsp;        b = prodA &amp; 0xffffffffL;</b>
<i>2225</i>&nbsp;
<b class="fc"><i>2226</i>&nbsp;        c = PI_O_4_BITS[0] &gt;&gt;&gt; 32;</b>
<b class="fc"><i>2227</i>&nbsp;        d = PI_O_4_BITS[0] &amp; 0xffffffffL;</b>
<i>2228</i>&nbsp;
<b class="fc"><i>2229</i>&nbsp;        ac = a * c;</b>
<b class="fc"><i>2230</i>&nbsp;        bd = b * d;</b>
<b class="fc"><i>2231</i>&nbsp;        bc = b * c;</b>
<b class="fc"><i>2232</i>&nbsp;        ad = a * d;</b>
<i>2233</i>&nbsp;
<b class="fc"><i>2234</i>&nbsp;        long prod2B = bd + (ad &lt;&lt; 32);</b>
<b class="fc"><i>2235</i>&nbsp;        long prod2A = ac + (ad &gt;&gt;&gt; 32);</b>
<i>2236</i>&nbsp;
<b class="fc"><i>2237</i>&nbsp;        bita = (bd &amp; 0x8000000000000000L) != 0;</b>
<b class="fc"><i>2238</i>&nbsp;        bitb = (ad &amp; 0x80000000L ) != 0;</b>
<b class="fc"><i>2239</i>&nbsp;        bitsum = (prod2B &amp; 0x8000000000000000L) != 0;</b>
<i>2240</i>&nbsp;
<i>2241</i>&nbsp;        /* Carry */
<b class="fc"><i>2242</i>&nbsp;        if ( (bita &amp;&amp; bitb) ||</b>
<i>2243</i>&nbsp;                ((bita || bitb) &amp;&amp; !bitsum) ) {
<b class="nc"><i>2244</i>&nbsp;            prod2A++;</b>
<i>2245</i>&nbsp;        }
<i>2246</i>&nbsp;
<b class="fc"><i>2247</i>&nbsp;        bita = (prod2B &amp; 0x8000000000000000L) != 0;</b>
<b class="fc"><i>2248</i>&nbsp;        bitb = (bc &amp; 0x80000000L ) != 0;</b>
<i>2249</i>&nbsp;
<b class="fc"><i>2250</i>&nbsp;        prod2B += bc &lt;&lt; 32;</b>
<b class="fc"><i>2251</i>&nbsp;        prod2A += bc &gt;&gt;&gt; 32;</b>
<i>2252</i>&nbsp;
<b class="fc"><i>2253</i>&nbsp;        bitsum = (prod2B &amp; 0x8000000000000000L) != 0;</b>
<i>2254</i>&nbsp;
<i>2255</i>&nbsp;        /* Carry */
<b class="fc"><i>2256</i>&nbsp;        if ( (bita &amp;&amp; bitb) ||</b>
<i>2257</i>&nbsp;                ((bita || bitb) &amp;&amp; !bitsum) ) {
<b class="fc"><i>2258</i>&nbsp;            prod2A++;</b>
<i>2259</i>&nbsp;        }
<i>2260</i>&nbsp;
<i>2261</i>&nbsp;        /* Multiply input by pio4bits[1] */
<b class="fc"><i>2262</i>&nbsp;        c = PI_O_4_BITS[1] &gt;&gt;&gt; 32;</b>
<b class="fc"><i>2263</i>&nbsp;        d = PI_O_4_BITS[1] &amp; 0xffffffffL;</b>
<b class="fc"><i>2264</i>&nbsp;        ac = a * c;</b>
<b class="fc"><i>2265</i>&nbsp;        bc = b * c;</b>
<b class="fc"><i>2266</i>&nbsp;        ad = a * d;</b>
<i>2267</i>&nbsp;
<i>2268</i>&nbsp;        /* Collect terms */
<b class="fc"><i>2269</i>&nbsp;        ac += (bc + ad) &gt;&gt;&gt; 32;</b>
<i>2270</i>&nbsp;
<b class="fc"><i>2271</i>&nbsp;        bita = (prod2B &amp; 0x8000000000000000L) != 0;</b>
<b class="fc"><i>2272</i>&nbsp;        bitb = (ac &amp; 0x8000000000000000L ) != 0;</b>
<b class="fc"><i>2273</i>&nbsp;        prod2B += ac;</b>
<b class="fc"><i>2274</i>&nbsp;        bitsum = (prod2B &amp; 0x8000000000000000L) != 0;</b>
<i>2275</i>&nbsp;        /* Carry */
<b class="fc"><i>2276</i>&nbsp;        if ( (bita &amp;&amp; bitb) ||</b>
<i>2277</i>&nbsp;                ((bita || bitb) &amp;&amp; !bitsum) ) {
<b class="fc"><i>2278</i>&nbsp;            prod2A++;</b>
<i>2279</i>&nbsp;        }
<i>2280</i>&nbsp;
<i>2281</i>&nbsp;        /* Multiply inputB by pio4bits[0] */
<b class="fc"><i>2282</i>&nbsp;        a = prodB &gt;&gt;&gt; 32;</b>
<b class="fc"><i>2283</i>&nbsp;        b = prodB &amp; 0xffffffffL;</b>
<b class="fc"><i>2284</i>&nbsp;        c = PI_O_4_BITS[0] &gt;&gt;&gt; 32;</b>
<b class="fc"><i>2285</i>&nbsp;        d = PI_O_4_BITS[0] &amp; 0xffffffffL;</b>
<b class="fc"><i>2286</i>&nbsp;        ac = a * c;</b>
<b class="fc"><i>2287</i>&nbsp;        bc = b * c;</b>
<b class="fc"><i>2288</i>&nbsp;        ad = a * d;</b>
<i>2289</i>&nbsp;
<i>2290</i>&nbsp;        /* Collect terms */
<b class="fc"><i>2291</i>&nbsp;        ac += (bc + ad) &gt;&gt;&gt; 32;</b>
<i>2292</i>&nbsp;
<b class="fc"><i>2293</i>&nbsp;        bita = (prod2B &amp; 0x8000000000000000L) != 0;</b>
<b class="fc"><i>2294</i>&nbsp;        bitb = (ac &amp; 0x8000000000000000L ) != 0;</b>
<b class="fc"><i>2295</i>&nbsp;        prod2B += ac;</b>
<b class="fc"><i>2296</i>&nbsp;        bitsum = (prod2B &amp; 0x8000000000000000L) != 0;</b>
<i>2297</i>&nbsp;        /* Carry */
<b class="fc"><i>2298</i>&nbsp;        if ( (bita &amp;&amp; bitb) ||</b>
<i>2299</i>&nbsp;                ((bita || bitb) &amp;&amp; !bitsum) ) {
<b class="fc"><i>2300</i>&nbsp;            prod2A++;</b>
<i>2301</i>&nbsp;        }
<i>2302</i>&nbsp;
<i>2303</i>&nbsp;        /* Convert to double */
<b class="fc"><i>2304</i>&nbsp;        double tmpA = (prod2A &gt;&gt;&gt; 12) / TWO_POWER_52;  // High order 52 bits</b>
<b class="fc"><i>2305</i>&nbsp;        double tmpB = (((prod2A &amp; 0xfffL) &lt;&lt; 40) + (prod2B &gt;&gt;&gt; 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits</b>
<i>2306</i>&nbsp;
<b class="fc"><i>2307</i>&nbsp;        double sumA = tmpA + tmpB;</b>
<b class="fc"><i>2308</i>&nbsp;        double sumB = -(sumA - tmpA - tmpB);</b>
<i>2309</i>&nbsp;
<i>2310</i>&nbsp;        /* Multiply by PI/2 and return */
<b class="fc"><i>2311</i>&nbsp;        result[0] = intPart;</b>
<b class="fc"><i>2312</i>&nbsp;        result[1] = sumA * 2.0;</b>
<b class="fc"><i>2313</i>&nbsp;        result[2] = sumB * 2.0;</b>
<b class="fc"><i>2314</i>&nbsp;    }</b>
<i>2315</i>&nbsp;
<i>2316</i>&nbsp;    /**
<i>2317</i>&nbsp;     * Sine function.
<i>2318</i>&nbsp;     *
<i>2319</i>&nbsp;     * @param x Argument.
<i>2320</i>&nbsp;     * @return sin(x)
<i>2321</i>&nbsp;     */
<i>2322</i>&nbsp;    public static double sin(double x) {
<b class="fc"><i>2323</i>&nbsp;        boolean negative = false;</b>
<b class="fc"><i>2324</i>&nbsp;        int quadrant = 0;</b>
<i>2325</i>&nbsp;        double xa;
<b class="fc"><i>2326</i>&nbsp;        double xb = 0.0;</b>
<i>2327</i>&nbsp;
<i>2328</i>&nbsp;        /* Take absolute value of the input */
<b class="fc"><i>2329</i>&nbsp;        xa = x;</b>
<b class="fc"><i>2330</i>&nbsp;        if (x &lt; 0) {</b>
<b class="fc"><i>2331</i>&nbsp;            negative = true;</b>
<b class="fc"><i>2332</i>&nbsp;            xa = -xa;</b>
<i>2333</i>&nbsp;        }
<i>2334</i>&nbsp;
<i>2335</i>&nbsp;        /* Check for zero and negative zero */
<b class="fc"><i>2336</i>&nbsp;        if (xa == 0.0) {</b>
<b class="fc"><i>2337</i>&nbsp;            long bits = Double.doubleToRawLongBits(x);</b>
<b class="fc"><i>2338</i>&nbsp;            if (bits &lt; 0) {</b>
<b class="fc"><i>2339</i>&nbsp;                return -0.0;</b>
<i>2340</i>&nbsp;            }
<b class="fc"><i>2341</i>&nbsp;            return 0.0;</b>
<i>2342</i>&nbsp;        }
<i>2343</i>&nbsp;
<b class="fc"><i>2344</i>&nbsp;        if (xa != xa || xa == Double.POSITIVE_INFINITY) {</b>
<b class="fc"><i>2345</i>&nbsp;            return Double.NaN;</b>
<i>2346</i>&nbsp;        }
<i>2347</i>&nbsp;
<i>2348</i>&nbsp;        /* Perform any argument reduction */
<b class="fc"><i>2349</i>&nbsp;        if (xa &gt; 3294198.0) {</b>
<i>2350</i>&nbsp;            // PI * (2**20)
<i>2351</i>&nbsp;            // Argument too big for CodyWaite reduction.  Must use
<i>2352</i>&nbsp;            // PayneHanek.
<b class="fc"><i>2353</i>&nbsp;            double reduceResults[] = new double[3];</b>
<b class="fc"><i>2354</i>&nbsp;            reducePayneHanek(xa, reduceResults);</b>
<b class="fc"><i>2355</i>&nbsp;            quadrant = ((int) reduceResults[0]) &amp; 3;</b>
<b class="fc"><i>2356</i>&nbsp;            xa = reduceResults[1];</b>
<b class="fc"><i>2357</i>&nbsp;            xb = reduceResults[2];</b>
<b class="fc"><i>2358</i>&nbsp;        } else if (xa &gt; 1.5707963267948966) {</b>
<b class="fc"><i>2359</i>&nbsp;            final CodyWaite cw = new CodyWaite(xa);</b>
<b class="fc"><i>2360</i>&nbsp;            quadrant = cw.getK() &amp; 3;</b>
<b class="fc"><i>2361</i>&nbsp;            xa = cw.getRemA();</b>
<b class="fc"><i>2362</i>&nbsp;            xb = cw.getRemB();</b>
<i>2363</i>&nbsp;        }
<i>2364</i>&nbsp;
<b class="fc"><i>2365</i>&nbsp;        if (negative) {</b>
<b class="fc"><i>2366</i>&nbsp;            quadrant ^= 2;  // Flip bit 1</b>
<i>2367</i>&nbsp;        }
<i>2368</i>&nbsp;
<b class="fc"><i>2369</i>&nbsp;        switch (quadrant) {</b>
<i>2370</i>&nbsp;            case 0:
<b class="fc"><i>2371</i>&nbsp;                return sinQ(xa, xb);</b>
<i>2372</i>&nbsp;            case 1:
<b class="fc"><i>2373</i>&nbsp;                return cosQ(xa, xb);</b>
<i>2374</i>&nbsp;            case 2:
<b class="fc"><i>2375</i>&nbsp;                return -sinQ(xa, xb);</b>
<i>2376</i>&nbsp;            case 3:
<b class="fc"><i>2377</i>&nbsp;                return -cosQ(xa, xb);</b>
<i>2378</i>&nbsp;            default:
<b class="nc"><i>2379</i>&nbsp;                return Double.NaN;</b>
<i>2380</i>&nbsp;        }
<i>2381</i>&nbsp;    }
<i>2382</i>&nbsp;
<i>2383</i>&nbsp;    /**
<i>2384</i>&nbsp;     * Cosine function.
<i>2385</i>&nbsp;     *
<i>2386</i>&nbsp;     * @param x Argument.
<i>2387</i>&nbsp;     * @return cos(x)
<i>2388</i>&nbsp;     */
<i>2389</i>&nbsp;    public static double cos(double x) {
<b class="fc"><i>2390</i>&nbsp;        int quadrant = 0;</b>
<i>2391</i>&nbsp;
<i>2392</i>&nbsp;        /* Take absolute value of the input */
<b class="fc"><i>2393</i>&nbsp;        double xa = x;</b>
<b class="fc"><i>2394</i>&nbsp;        if (x &lt; 0) {</b>
<b class="fc"><i>2395</i>&nbsp;            xa = -xa;</b>
<i>2396</i>&nbsp;        }
<i>2397</i>&nbsp;
<b class="fc"><i>2398</i>&nbsp;        if (xa != xa || xa == Double.POSITIVE_INFINITY) {</b>
<b class="fc"><i>2399</i>&nbsp;            return Double.NaN;</b>
<i>2400</i>&nbsp;        }
<i>2401</i>&nbsp;
<i>2402</i>&nbsp;        /* Perform any argument reduction */
<b class="fc"><i>2403</i>&nbsp;        double xb = 0;</b>
<b class="fc"><i>2404</i>&nbsp;        if (xa &gt; 3294198.0) {</b>
<i>2405</i>&nbsp;            // PI * (2**20)
<i>2406</i>&nbsp;            // Argument too big for CodyWaite reduction.  Must use
<i>2407</i>&nbsp;            // PayneHanek.
<b class="fc"><i>2408</i>&nbsp;            double reduceResults[] = new double[3];</b>
<b class="fc"><i>2409</i>&nbsp;            reducePayneHanek(xa, reduceResults);</b>
<b class="fc"><i>2410</i>&nbsp;            quadrant = ((int) reduceResults[0]) &amp; 3;</b>
<b class="fc"><i>2411</i>&nbsp;            xa = reduceResults[1];</b>
<b class="fc"><i>2412</i>&nbsp;            xb = reduceResults[2];</b>
<b class="fc"><i>2413</i>&nbsp;        } else if (xa &gt; 1.5707963267948966) {</b>
<b class="fc"><i>2414</i>&nbsp;            final CodyWaite cw = new CodyWaite(xa);</b>
<b class="fc"><i>2415</i>&nbsp;            quadrant = cw.getK() &amp; 3;</b>
<b class="fc"><i>2416</i>&nbsp;            xa = cw.getRemA();</b>
<b class="fc"><i>2417</i>&nbsp;            xb = cw.getRemB();</b>
<i>2418</i>&nbsp;        }
<i>2419</i>&nbsp;
<i>2420</i>&nbsp;        //if (negative)
<i>2421</i>&nbsp;        //  quadrant = (quadrant + 2) % 4;
<i>2422</i>&nbsp;
<b class="fc"><i>2423</i>&nbsp;        switch (quadrant) {</b>
<i>2424</i>&nbsp;            case 0:
<b class="fc"><i>2425</i>&nbsp;                return cosQ(xa, xb);</b>
<i>2426</i>&nbsp;            case 1:
<b class="fc"><i>2427</i>&nbsp;                return -sinQ(xa, xb);</b>
<i>2428</i>&nbsp;            case 2:
<b class="fc"><i>2429</i>&nbsp;                return -cosQ(xa, xb);</b>
<i>2430</i>&nbsp;            case 3:
<b class="fc"><i>2431</i>&nbsp;                return sinQ(xa, xb);</b>
<i>2432</i>&nbsp;            default:
<b class="nc"><i>2433</i>&nbsp;                return Double.NaN;</b>
<i>2434</i>&nbsp;        }
<i>2435</i>&nbsp;    }
<i>2436</i>&nbsp;
<i>2437</i>&nbsp;    /**
<i>2438</i>&nbsp;     * Tangent function.
<i>2439</i>&nbsp;     *
<i>2440</i>&nbsp;     * @param x Argument.
<i>2441</i>&nbsp;     * @return tan(x)
<i>2442</i>&nbsp;     */
<i>2443</i>&nbsp;    public static double tan(double x) {
<b class="fc"><i>2444</i>&nbsp;        boolean negative = false;</b>
<b class="fc"><i>2445</i>&nbsp;        int quadrant = 0;</b>
<i>2446</i>&nbsp;
<i>2447</i>&nbsp;        /* Take absolute value of the input */
<b class="fc"><i>2448</i>&nbsp;        double xa = x;</b>
<b class="fc"><i>2449</i>&nbsp;        if (x &lt; 0) {</b>
<b class="fc"><i>2450</i>&nbsp;            negative = true;</b>
<b class="fc"><i>2451</i>&nbsp;            xa = -xa;</b>
<i>2452</i>&nbsp;        }
<i>2453</i>&nbsp;
<i>2454</i>&nbsp;        /* Check for zero and negative zero */
<b class="fc"><i>2455</i>&nbsp;        if (xa == 0.0) {</b>
<b class="fc"><i>2456</i>&nbsp;            long bits = Double.doubleToRawLongBits(x);</b>
<b class="fc"><i>2457</i>&nbsp;            if (bits &lt; 0) {</b>
<b class="fc"><i>2458</i>&nbsp;                return -0.0;</b>
<i>2459</i>&nbsp;            }
<b class="fc"><i>2460</i>&nbsp;            return 0.0;</b>
<i>2461</i>&nbsp;        }
<i>2462</i>&nbsp;
<b class="fc"><i>2463</i>&nbsp;        if (xa != xa || xa == Double.POSITIVE_INFINITY) {</b>
<b class="fc"><i>2464</i>&nbsp;            return Double.NaN;</b>
<i>2465</i>&nbsp;        }
<i>2466</i>&nbsp;
<i>2467</i>&nbsp;        /* Perform any argument reduction */
<b class="fc"><i>2468</i>&nbsp;        double xb = 0;</b>
<b class="fc"><i>2469</i>&nbsp;        if (xa &gt; 3294198.0) {</b>
<i>2470</i>&nbsp;            // PI * (2**20)
<i>2471</i>&nbsp;            // Argument too big for CodyWaite reduction.  Must use
<i>2472</i>&nbsp;            // PayneHanek.
<b class="fc"><i>2473</i>&nbsp;            double reduceResults[] = new double[3];</b>
<b class="fc"><i>2474</i>&nbsp;            reducePayneHanek(xa, reduceResults);</b>
<b class="fc"><i>2475</i>&nbsp;            quadrant = ((int) reduceResults[0]) &amp; 3;</b>
<b class="fc"><i>2476</i>&nbsp;            xa = reduceResults[1];</b>
<b class="fc"><i>2477</i>&nbsp;            xb = reduceResults[2];</b>
<b class="fc"><i>2478</i>&nbsp;        } else if (xa &gt; 1.5707963267948966) {</b>
<b class="fc"><i>2479</i>&nbsp;            final CodyWaite cw = new CodyWaite(xa);</b>
<b class="fc"><i>2480</i>&nbsp;            quadrant = cw.getK() &amp; 3;</b>
<b class="fc"><i>2481</i>&nbsp;            xa = cw.getRemA();</b>
<b class="fc"><i>2482</i>&nbsp;            xb = cw.getRemB();</b>
<i>2483</i>&nbsp;        }
<i>2484</i>&nbsp;
<b class="fc"><i>2485</i>&nbsp;        if (xa &gt; 1.5) {</b>
<i>2486</i>&nbsp;            // Accuracy suffers between 1.5 and PI/2
<b class="fc"><i>2487</i>&nbsp;            final double pi2a = 1.5707963267948966;</b>
<b class="fc"><i>2488</i>&nbsp;            final double pi2b = 6.123233995736766E-17;</b>
<i>2489</i>&nbsp;
<b class="fc"><i>2490</i>&nbsp;            final double a = pi2a - xa;</b>
<b class="fc"><i>2491</i>&nbsp;            double b = -(a - pi2a + xa);</b>
<b class="fc"><i>2492</i>&nbsp;            b += pi2b - xb;</b>
<i>2493</i>&nbsp;
<b class="fc"><i>2494</i>&nbsp;            xa = a + b;</b>
<b class="fc"><i>2495</i>&nbsp;            xb = -(xa - a - b);</b>
<b class="fc"><i>2496</i>&nbsp;            quadrant ^= 1;</b>
<b class="fc"><i>2497</i>&nbsp;            negative ^= true;</b>
<i>2498</i>&nbsp;        }
<i>2499</i>&nbsp;
<i>2500</i>&nbsp;        double result;
<b class="fc"><i>2501</i>&nbsp;        if ((quadrant &amp; 1) == 0) {</b>
<b class="fc"><i>2502</i>&nbsp;            result = tanQ(xa, xb, false);</b>
<i>2503</i>&nbsp;        } else {
<b class="fc"><i>2504</i>&nbsp;            result = -tanQ(xa, xb, true);</b>
<i>2505</i>&nbsp;        }
<i>2506</i>&nbsp;
<b class="fc"><i>2507</i>&nbsp;        if (negative) {</b>
<b class="fc"><i>2508</i>&nbsp;            result = -result;</b>
<i>2509</i>&nbsp;        }
<i>2510</i>&nbsp;
<b class="fc"><i>2511</i>&nbsp;        return result;</b>
<i>2512</i>&nbsp;    }
<i>2513</i>&nbsp;
<i>2514</i>&nbsp;    /**
<i>2515</i>&nbsp;     * Arctangent function
<i>2516</i>&nbsp;     *  @param x a number
<i>2517</i>&nbsp;     *  @return atan(x)
<i>2518</i>&nbsp;     */
<i>2519</i>&nbsp;    public static double atan(double x) {
<b class="fc"><i>2520</i>&nbsp;        return atan(x, 0.0, false);</b>
<i>2521</i>&nbsp;    }
<i>2522</i>&nbsp;
<i>2523</i>&nbsp;    /** Internal helper function to compute arctangent.
<i>2524</i>&nbsp;     * @param xa number from which arctangent is requested
<i>2525</i>&nbsp;     * @param xb extra bits for x (may be 0.0)
<i>2526</i>&nbsp;     * @param leftPlane if true, result angle must be put in the left half plane
<i>2527</i>&nbsp;     * @return atan(xa + xb) (or angle shifted by {@code PI} if leftPlane is true)
<i>2528</i>&nbsp;     */
<i>2529</i>&nbsp;    private static double atan(double xa, double xb, boolean leftPlane) {
<b class="fc"><i>2530</i>&nbsp;        if (xa == 0.0) { // Matches +/- 0.0; return correct sign</b>
<b class="fc"><i>2531</i>&nbsp;            return leftPlane ? copySign(Math.PI, xa) : xa;</b>
<i>2532</i>&nbsp;        }
<i>2533</i>&nbsp;
<i>2534</i>&nbsp;        final boolean negate;
<b class="fc"><i>2535</i>&nbsp;        if (xa &lt; 0) {</b>
<i>2536</i>&nbsp;            // negative
<b class="fc"><i>2537</i>&nbsp;            xa = -xa;</b>
<b class="fc"><i>2538</i>&nbsp;            xb = -xb;</b>
<b class="fc"><i>2539</i>&nbsp;            negate = true;</b>
<i>2540</i>&nbsp;        } else {
<b class="fc"><i>2541</i>&nbsp;            negate = false;</b>
<i>2542</i>&nbsp;        }
<i>2543</i>&nbsp;
<b class="fc"><i>2544</i>&nbsp;        if (xa &gt; 1.633123935319537E16) { // Very large input</b>
<b class="fc"><i>2545</i>&nbsp;            return (negate ^ leftPlane) ? (-Math.PI * F_1_2) : (Math.PI * F_1_2);</b>
<i>2546</i>&nbsp;        }
<i>2547</i>&nbsp;
<i>2548</i>&nbsp;        /* Estimate the closest tabulated arctan value, compute eps = xa-tangentTable */
<i>2549</i>&nbsp;        final int idx;
<b class="fc"><i>2550</i>&nbsp;        if (xa &lt; 1) {</b>
<b class="fc"><i>2551</i>&nbsp;            idx = (int) (((-1.7168146928204136 * xa * xa + 8.0) * xa) + 0.5);</b>
<i>2552</i>&nbsp;        } else {
<b class="fc"><i>2553</i>&nbsp;            final double oneOverXa = 1 / xa;</b>
<b class="fc"><i>2554</i>&nbsp;            idx = (int) (-((-1.7168146928204136 * oneOverXa * oneOverXa + 8.0) * oneOverXa) + 13.07);</b>
<i>2555</i>&nbsp;        }
<i>2556</i>&nbsp;
<b class="fc"><i>2557</i>&nbsp;        final double ttA = TANGENT_TABLE_A[idx];</b>
<b class="fc"><i>2558</i>&nbsp;        final double ttB = TANGENT_TABLE_B[idx];</b>
<i>2559</i>&nbsp;
<b class="fc"><i>2560</i>&nbsp;        double epsA = xa - ttA;</b>
<b class="fc"><i>2561</i>&nbsp;        double epsB = -(epsA - xa + ttA);</b>
<b class="fc"><i>2562</i>&nbsp;        epsB += xb - ttB;</b>
<i>2563</i>&nbsp;
<b class="fc"><i>2564</i>&nbsp;        double temp = epsA + epsB;</b>
<b class="fc"><i>2565</i>&nbsp;        epsB = -(temp - epsA - epsB);</b>
<b class="fc"><i>2566</i>&nbsp;        epsA = temp;</b>
<i>2567</i>&nbsp;
<i>2568</i>&nbsp;        /* Compute eps = eps / (1.0 + xa*tangent) */
<b class="fc"><i>2569</i>&nbsp;        temp = xa * HEX_40000000;</b>
<b class="fc"><i>2570</i>&nbsp;        double ya = xa + temp - temp;</b>
<b class="fc"><i>2571</i>&nbsp;        double yb = xb + xa - ya;</b>
<b class="fc"><i>2572</i>&nbsp;        xa = ya;</b>
<b class="fc"><i>2573</i>&nbsp;        xb += yb;</b>
<i>2574</i>&nbsp;
<i>2575</i>&nbsp;        //if (idx &gt; 8 || idx == 0)
<b class="fc"><i>2576</i>&nbsp;        if (idx == 0) {</b>
<i>2577</i>&nbsp;            /* If the slope of the arctan is gentle enough (&lt; 0.45), this approximation will suffice */
<i>2578</i>&nbsp;            //double denom = 1.0 / (1.0 + xa*tangentTableA[idx] + xb*tangentTableA[idx] + xa*tangentTableB[idx] + xb*tangentTableB[idx]);
<b class="fc"><i>2579</i>&nbsp;            final double denom = 1d / (1d + (xa + xb) * (ttA + ttB));</b>
<i>2580</i>&nbsp;            //double denom = 1.0 / (1.0 + xa*tangentTableA[idx]);
<b class="fc"><i>2581</i>&nbsp;            ya = epsA * denom;</b>
<b class="fc"><i>2582</i>&nbsp;            yb = epsB * denom;</b>
<b class="fc"><i>2583</i>&nbsp;        } else {</b>
<b class="fc"><i>2584</i>&nbsp;            double temp2 = xa * ttA;</b>
<b class="fc"><i>2585</i>&nbsp;            double za = 1d + temp2;</b>
<b class="fc"><i>2586</i>&nbsp;            double zb = -(za - 1d - temp2);</b>
<b class="fc"><i>2587</i>&nbsp;            temp2 = xb * ttA + xa * ttB;</b>
<b class="fc"><i>2588</i>&nbsp;            temp = za + temp2;</b>
<b class="fc"><i>2589</i>&nbsp;            zb += -(temp - za - temp2);</b>
<b class="fc"><i>2590</i>&nbsp;            za = temp;</b>
<i>2591</i>&nbsp;
<b class="fc"><i>2592</i>&nbsp;            zb += xb * ttB;</b>
<b class="fc"><i>2593</i>&nbsp;            ya = epsA / za;</b>
<i>2594</i>&nbsp;
<b class="fc"><i>2595</i>&nbsp;            temp = ya * HEX_40000000;</b>
<b class="fc"><i>2596</i>&nbsp;            final double yaa = (ya + temp) - temp;</b>
<b class="fc"><i>2597</i>&nbsp;            final double yab = ya - yaa;</b>
<i>2598</i>&nbsp;
<b class="fc"><i>2599</i>&nbsp;            temp = za * HEX_40000000;</b>
<b class="fc"><i>2600</i>&nbsp;            final double zaa = (za + temp) - temp;</b>
<b class="fc"><i>2601</i>&nbsp;            final double zab = za - zaa;</b>
<i>2602</i>&nbsp;
<i>2603</i>&nbsp;            /* Correct for rounding in division */
<b class="fc"><i>2604</i>&nbsp;            yb = (epsA - yaa * zaa - yaa * zab - yab * zaa - yab * zab) / za;</b>
<i>2605</i>&nbsp;
<b class="fc"><i>2606</i>&nbsp;            yb += -epsA * zb / za / za;</b>
<b class="fc"><i>2607</i>&nbsp;            yb += epsB / za;</b>
<i>2608</i>&nbsp;        }
<i>2609</i>&nbsp;
<i>2610</i>&nbsp;
<b class="fc"><i>2611</i>&nbsp;        epsA = ya;</b>
<b class="fc"><i>2612</i>&nbsp;        epsB = yb;</b>
<i>2613</i>&nbsp;
<i>2614</i>&nbsp;        /* Evaluate polynomial */
<b class="fc"><i>2615</i>&nbsp;        final double epsA2 = epsA * epsA;</b>
<i>2616</i>&nbsp;
<i>2617</i>&nbsp;        /*
<i>2618</i>&nbsp;    yb = -0.09001346640161823;
<i>2619</i>&nbsp;    yb = yb * epsA2 + 0.11110718400605211;
<i>2620</i>&nbsp;    yb = yb * epsA2 + -0.1428571349122913;
<i>2621</i>&nbsp;    yb = yb * epsA2 + 0.19999999999273194;
<i>2622</i>&nbsp;    yb = yb * epsA2 + -0.33333333333333093;
<i>2623</i>&nbsp;    yb = yb * epsA2 * epsA;
<i>2624</i>&nbsp;         */
<i>2625</i>&nbsp;
<b class="fc"><i>2626</i>&nbsp;        yb = 0.07490822288864472;</b>
<b class="fc"><i>2627</i>&nbsp;        yb = yb * epsA2 - 0.09088450866185192;</b>
<b class="fc"><i>2628</i>&nbsp;        yb = yb * epsA2 + 0.11111095942313305;</b>
<b class="fc"><i>2629</i>&nbsp;        yb = yb * epsA2 - 0.1428571423679182;</b>
<b class="fc"><i>2630</i>&nbsp;        yb = yb * epsA2 + 0.19999999999923582;</b>
<b class="fc"><i>2631</i>&nbsp;        yb = yb * epsA2 - 0.33333333333333287;</b>
<b class="fc"><i>2632</i>&nbsp;        yb = yb * epsA2 * epsA;</b>
<i>2633</i>&nbsp;
<i>2634</i>&nbsp;
<b class="fc"><i>2635</i>&nbsp;        ya = epsA;</b>
<i>2636</i>&nbsp;
<b class="fc"><i>2637</i>&nbsp;        temp = ya + yb;</b>
<b class="fc"><i>2638</i>&nbsp;        yb = -(temp - ya - yb);</b>
<b class="fc"><i>2639</i>&nbsp;        ya = temp;</b>
<i>2640</i>&nbsp;
<i>2641</i>&nbsp;        /* Add in effect of epsB.   atan&#39;(x) = 1/(1+x^2) */
<b class="fc"><i>2642</i>&nbsp;        yb += epsB / (1d + epsA * epsA);</b>
<i>2643</i>&nbsp;
<b class="fc"><i>2644</i>&nbsp;        final double eighths = EIGHTHS[idx];</b>
<i>2645</i>&nbsp;
<i>2646</i>&nbsp;        //result = yb + eighths[idx] + ya;
<b class="fc"><i>2647</i>&nbsp;        double za = eighths + ya;</b>
<b class="fc"><i>2648</i>&nbsp;        double zb = -(za - eighths - ya);</b>
<b class="fc"><i>2649</i>&nbsp;        temp = za + yb;</b>
<b class="fc"><i>2650</i>&nbsp;        zb += -(temp - za - yb);</b>
<b class="fc"><i>2651</i>&nbsp;        za = temp;</b>
<i>2652</i>&nbsp;
<b class="fc"><i>2653</i>&nbsp;        double result = za + zb;</b>
<i>2654</i>&nbsp;
<b class="fc"><i>2655</i>&nbsp;        if (leftPlane) {</b>
<i>2656</i>&nbsp;            // Result is in the left plane
<b class="fc"><i>2657</i>&nbsp;            final double resultb = -(result - za - zb);</b>
<b class="fc"><i>2658</i>&nbsp;            final double pia = 1.5707963267948966 * 2;</b>
<b class="fc"><i>2659</i>&nbsp;            final double pib = 6.123233995736766E-17 * 2;</b>
<i>2660</i>&nbsp;
<b class="fc"><i>2661</i>&nbsp;            za = pia - result;</b>
<b class="fc"><i>2662</i>&nbsp;            zb = -(za - pia + result);</b>
<b class="fc"><i>2663</i>&nbsp;            zb += pib - resultb;</b>
<i>2664</i>&nbsp;
<b class="fc"><i>2665</i>&nbsp;            result = za + zb;</b>
<i>2666</i>&nbsp;        }
<i>2667</i>&nbsp;
<i>2668</i>&nbsp;
<b class="fc"><i>2669</i>&nbsp;        if (negate ^ leftPlane) {</b>
<b class="fc"><i>2670</i>&nbsp;            result = -result;</b>
<i>2671</i>&nbsp;        }
<i>2672</i>&nbsp;
<b class="fc"><i>2673</i>&nbsp;        return result;</b>
<i>2674</i>&nbsp;    }
<i>2675</i>&nbsp;
<i>2676</i>&nbsp;    /**
<i>2677</i>&nbsp;     * Two arguments arctangent function
<i>2678</i>&nbsp;     * @param y ordinate
<i>2679</i>&nbsp;     * @param x abscissa
<i>2680</i>&nbsp;     * @return phase angle of point (x,y) between {@code -PI} and {@code PI}
<i>2681</i>&nbsp;     */
<i>2682</i>&nbsp;    public static double atan2(double y, double x) {
<b class="fc"><i>2683</i>&nbsp;        if (Double.isNaN(x) || Double.isNaN(y)) {</b>
<b class="fc"><i>2684</i>&nbsp;            return Double.NaN;</b>
<i>2685</i>&nbsp;        }
<i>2686</i>&nbsp;
<b class="fc"><i>2687</i>&nbsp;        if (y == 0) {</b>
<b class="fc"><i>2688</i>&nbsp;            final double result = x * y;</b>
<b class="fc"><i>2689</i>&nbsp;            final double invx = 1d / x;</b>
<b class="fc"><i>2690</i>&nbsp;            final double invy = 1d / y;</b>
<i>2691</i>&nbsp;
<b class="fc"><i>2692</i>&nbsp;            if (invx == 0) { // X is infinite</b>
<b class="fc"><i>2693</i>&nbsp;                if (x &gt; 0) {</b>
<b class="fc"><i>2694</i>&nbsp;                    return y; // return +/- 0.0</b>
<i>2695</i>&nbsp;                } else {
<b class="fc"><i>2696</i>&nbsp;                    return copySign(Math.PI, y);</b>
<i>2697</i>&nbsp;                }
<i>2698</i>&nbsp;            }
<i>2699</i>&nbsp;
<b class="fc"><i>2700</i>&nbsp;            if (x &lt; 0 || invx &lt; 0) {</b>
<b class="fc"><i>2701</i>&nbsp;                if (y &lt; 0 || invy &lt; 0) {</b>
<b class="fc"><i>2702</i>&nbsp;                    return -Math.PI;</b>
<i>2703</i>&nbsp;                } else {
<b class="fc"><i>2704</i>&nbsp;                    return Math.PI;</b>
<i>2705</i>&nbsp;                }
<i>2706</i>&nbsp;            } else {
<b class="fc"><i>2707</i>&nbsp;                return result;</b>
<i>2708</i>&nbsp;            }
<i>2709</i>&nbsp;        }
<i>2710</i>&nbsp;
<i>2711</i>&nbsp;        // y cannot now be zero
<i>2712</i>&nbsp;
<b class="fc"><i>2713</i>&nbsp;        if (y == Double.POSITIVE_INFINITY) {</b>
<b class="fc"><i>2714</i>&nbsp;            if (x == Double.POSITIVE_INFINITY) {</b>
<b class="fc"><i>2715</i>&nbsp;                return Math.PI * F_1_4;</b>
<i>2716</i>&nbsp;            }
<i>2717</i>&nbsp;
<b class="fc"><i>2718</i>&nbsp;            if (x == Double.NEGATIVE_INFINITY) {</b>
<b class="fc"><i>2719</i>&nbsp;                return Math.PI * F_3_4;</b>
<i>2720</i>&nbsp;            }
<i>2721</i>&nbsp;
<b class="fc"><i>2722</i>&nbsp;            return Math.PI * F_1_2;</b>
<i>2723</i>&nbsp;        }
<i>2724</i>&nbsp;
<b class="fc"><i>2725</i>&nbsp;        if (y == Double.NEGATIVE_INFINITY) {</b>
<b class="fc"><i>2726</i>&nbsp;            if (x == Double.POSITIVE_INFINITY) {</b>
<b class="fc"><i>2727</i>&nbsp;                return -Math.PI * F_1_4;</b>
<i>2728</i>&nbsp;            }
<i>2729</i>&nbsp;
<b class="fc"><i>2730</i>&nbsp;            if (x == Double.NEGATIVE_INFINITY) {</b>
<b class="fc"><i>2731</i>&nbsp;                return -Math.PI * F_3_4;</b>
<i>2732</i>&nbsp;            }
<i>2733</i>&nbsp;
<b class="fc"><i>2734</i>&nbsp;            return -Math.PI * F_1_2;</b>
<i>2735</i>&nbsp;        }
<i>2736</i>&nbsp;
<b class="fc"><i>2737</i>&nbsp;        if (x == Double.POSITIVE_INFINITY) {</b>
<b class="fc"><i>2738</i>&nbsp;            if (y &gt; 0 || 1 / y &gt; 0) {</b>
<b class="fc"><i>2739</i>&nbsp;                return 0d;</b>
<i>2740</i>&nbsp;            }
<i>2741</i>&nbsp;
<b class="fc"><i>2742</i>&nbsp;            if (y &lt; 0 || 1 / y &lt; 0) {</b>
<b class="fc"><i>2743</i>&nbsp;                return -0d;</b>
<i>2744</i>&nbsp;            }
<i>2745</i>&nbsp;        }
<i>2746</i>&nbsp;
<b class="fc"><i>2747</i>&nbsp;        if (x == Double.NEGATIVE_INFINITY)</b>
<i>2748</i>&nbsp;        {
<b class="fc"><i>2749</i>&nbsp;            if (y &gt; 0.0 || 1 / y &gt; 0.0) {</b>
<b class="fc"><i>2750</i>&nbsp;                return Math.PI;</b>
<i>2751</i>&nbsp;            }
<i>2752</i>&nbsp;
<b class="fc"><i>2753</i>&nbsp;            if (y &lt; 0 || 1 / y &lt; 0) {</b>
<b class="fc"><i>2754</i>&nbsp;                return -Math.PI;</b>
<i>2755</i>&nbsp;            }
<i>2756</i>&nbsp;        }
<i>2757</i>&nbsp;
<i>2758</i>&nbsp;        // Neither y nor x can be infinite or NAN here
<i>2759</i>&nbsp;
<b class="fc"><i>2760</i>&nbsp;        if (x == 0) {</b>
<b class="fc"><i>2761</i>&nbsp;            if (y &gt; 0 || 1 / y &gt; 0) {</b>
<b class="fc"><i>2762</i>&nbsp;                return Math.PI * F_1_2;</b>
<i>2763</i>&nbsp;            }
<i>2764</i>&nbsp;
<b class="fc"><i>2765</i>&nbsp;            if (y &lt; 0 || 1 / y &lt; 0) {</b>
<b class="fc"><i>2766</i>&nbsp;                return -Math.PI * F_1_2;</b>
<i>2767</i>&nbsp;            }
<i>2768</i>&nbsp;        }
<i>2769</i>&nbsp;
<i>2770</i>&nbsp;        // Compute ratio r = y/x
<b class="fc"><i>2771</i>&nbsp;        final double r = y / x;</b>
<b class="fc"><i>2772</i>&nbsp;        if (Double.isInfinite(r)) { // bypass calculations that can create NaN</b>
<b class="fc"><i>2773</i>&nbsp;            return atan(r, 0, x &lt; 0);</b>
<i>2774</i>&nbsp;        }
<i>2775</i>&nbsp;
<b class="fc"><i>2776</i>&nbsp;        double ra = doubleHighPart(r);</b>
<b class="fc"><i>2777</i>&nbsp;        double rb = r - ra;</b>
<i>2778</i>&nbsp;
<i>2779</i>&nbsp;        // Split x
<b class="fc"><i>2780</i>&nbsp;        final double xa = doubleHighPart(x);</b>
<b class="fc"><i>2781</i>&nbsp;        final double xb = x - xa;</b>
<i>2782</i>&nbsp;
<b class="fc"><i>2783</i>&nbsp;        rb += (y - ra * xa - ra * xb - rb * xa - rb * xb) / x;</b>
<i>2784</i>&nbsp;
<b class="fc"><i>2785</i>&nbsp;        final double temp = ra + rb;</b>
<b class="fc"><i>2786</i>&nbsp;        rb = -(temp - ra - rb);</b>
<b class="fc"><i>2787</i>&nbsp;        ra = temp;</b>
<i>2788</i>&nbsp;
<b class="fc"><i>2789</i>&nbsp;        if (ra == 0) { // Fix up the sign so atan works correctly</b>
<b class="fc"><i>2790</i>&nbsp;            ra = copySign(0d, y);</b>
<i>2791</i>&nbsp;        }
<i>2792</i>&nbsp;
<i>2793</i>&nbsp;        // Call atan
<b class="fc"><i>2794</i>&nbsp;        final double result = atan(ra, rb, x &lt; 0);</b>
<i>2795</i>&nbsp;
<b class="fc"><i>2796</i>&nbsp;        return result;</b>
<i>2797</i>&nbsp;    }
<i>2798</i>&nbsp;
<i>2799</i>&nbsp;    /** Compute the arc sine of a number.
<i>2800</i>&nbsp;     * @param x number on which evaluation is done
<i>2801</i>&nbsp;     * @return arc sine of x
<i>2802</i>&nbsp;     */
<i>2803</i>&nbsp;    public static double asin(double x) {
<b class="fc"><i>2804</i>&nbsp;      if (Double.isNaN(x)) {</b>
<b class="fc"><i>2805</i>&nbsp;          return Double.NaN;</b>
<i>2806</i>&nbsp;      }
<i>2807</i>&nbsp;
<b class="fc"><i>2808</i>&nbsp;      if (x &gt; 1.0 || x &lt; -1.0) {</b>
<b class="fc"><i>2809</i>&nbsp;          return Double.NaN;</b>
<i>2810</i>&nbsp;      }
<i>2811</i>&nbsp;
<b class="fc"><i>2812</i>&nbsp;      if (x == 1.0) {</b>
<b class="fc"><i>2813</i>&nbsp;          return Math.PI/2.0;</b>
<i>2814</i>&nbsp;      }
<i>2815</i>&nbsp;
<b class="fc"><i>2816</i>&nbsp;      if (x == -1.0) {</b>
<b class="fc"><i>2817</i>&nbsp;          return -Math.PI/2.0;</b>
<i>2818</i>&nbsp;      }
<i>2819</i>&nbsp;
<b class="fc"><i>2820</i>&nbsp;      if (x == 0.0) { // Matches +/- 0.0; return correct sign</b>
<b class="fc"><i>2821</i>&nbsp;          return x;</b>
<i>2822</i>&nbsp;      }
<i>2823</i>&nbsp;
<i>2824</i>&nbsp;      /* Compute asin(x) = atan(x/sqrt(1-x*x)) */
<i>2825</i>&nbsp;
<i>2826</i>&nbsp;      /* Split x */
<b class="fc"><i>2827</i>&nbsp;      double temp = x * HEX_40000000;</b>
<b class="fc"><i>2828</i>&nbsp;      final double xa = x + temp - temp;</b>
<b class="fc"><i>2829</i>&nbsp;      final double xb = x - xa;</b>
<i>2830</i>&nbsp;
<i>2831</i>&nbsp;      /* Square it */
<b class="fc"><i>2832</i>&nbsp;      double ya = xa*xa;</b>
<b class="fc"><i>2833</i>&nbsp;      double yb = xa*xb*2.0 + xb*xb;</b>
<i>2834</i>&nbsp;
<i>2835</i>&nbsp;      /* Subtract from 1 */
<b class="fc"><i>2836</i>&nbsp;      ya = -ya;</b>
<b class="fc"><i>2837</i>&nbsp;      yb = -yb;</b>
<i>2838</i>&nbsp;
<b class="fc"><i>2839</i>&nbsp;      double za = 1.0 + ya;</b>
<b class="fc"><i>2840</i>&nbsp;      double zb = -(za - 1.0 - ya);</b>
<i>2841</i>&nbsp;
<b class="fc"><i>2842</i>&nbsp;      temp = za + yb;</b>
<b class="fc"><i>2843</i>&nbsp;      zb += -(temp - za - yb);</b>
<b class="fc"><i>2844</i>&nbsp;      za = temp;</b>
<i>2845</i>&nbsp;
<i>2846</i>&nbsp;      /* Square root */
<i>2847</i>&nbsp;      double y;
<b class="fc"><i>2848</i>&nbsp;      y = sqrt(za);</b>
<b class="fc"><i>2849</i>&nbsp;      temp = y * HEX_40000000;</b>
<b class="fc"><i>2850</i>&nbsp;      ya = y + temp - temp;</b>
<b class="fc"><i>2851</i>&nbsp;      yb = y - ya;</b>
<i>2852</i>&nbsp;
<i>2853</i>&nbsp;      /* Extend precision of sqrt */
<b class="fc"><i>2854</i>&nbsp;      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);</b>
<i>2855</i>&nbsp;
<i>2856</i>&nbsp;      /* Contribution of zb to sqrt */
<b class="fc"><i>2857</i>&nbsp;      double dx = zb / (2.0*y);</b>
<i>2858</i>&nbsp;
<i>2859</i>&nbsp;      // Compute ratio r = x/y
<b class="fc"><i>2860</i>&nbsp;      double r = x/y;</b>
<b class="fc"><i>2861</i>&nbsp;      temp = r * HEX_40000000;</b>
<b class="fc"><i>2862</i>&nbsp;      double ra = r + temp - temp;</b>
<b class="fc"><i>2863</i>&nbsp;      double rb = r - ra;</b>
<i>2864</i>&nbsp;
<b class="fc"><i>2865</i>&nbsp;      rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division</b>
<b class="fc"><i>2866</i>&nbsp;      rb += -x * dx / y / y;  // Add in effect additional bits of sqrt.</b>
<i>2867</i>&nbsp;
<b class="fc"><i>2868</i>&nbsp;      temp = ra + rb;</b>
<b class="fc"><i>2869</i>&nbsp;      rb = -(temp - ra - rb);</b>
<b class="fc"><i>2870</i>&nbsp;      ra = temp;</b>
<i>2871</i>&nbsp;
<b class="fc"><i>2872</i>&nbsp;      return atan(ra, rb, false);</b>
<i>2873</i>&nbsp;    }
<i>2874</i>&nbsp;
<i>2875</i>&nbsp;    /** Compute the arc cosine of a number.
<i>2876</i>&nbsp;     * @param x number on which evaluation is done
<i>2877</i>&nbsp;     * @return arc cosine of x
<i>2878</i>&nbsp;     */
<i>2879</i>&nbsp;    public static double acos(double x) {
<b class="fc"><i>2880</i>&nbsp;      if (Double.isNaN(x)) {</b>
<b class="fc"><i>2881</i>&nbsp;          return Double.NaN;</b>
<i>2882</i>&nbsp;      }
<i>2883</i>&nbsp;
<b class="fc"><i>2884</i>&nbsp;      if (x &gt; 1.0 || x &lt; -1.0) {</b>
<b class="fc"><i>2885</i>&nbsp;          return Double.NaN;</b>
<i>2886</i>&nbsp;      }
<i>2887</i>&nbsp;
<b class="fc"><i>2888</i>&nbsp;      if (x == -1.0) {</b>
<b class="fc"><i>2889</i>&nbsp;          return Math.PI;</b>
<i>2890</i>&nbsp;      }
<i>2891</i>&nbsp;
<b class="fc"><i>2892</i>&nbsp;      if (x == 1.0) {</b>
<b class="fc"><i>2893</i>&nbsp;          return 0.0;</b>
<i>2894</i>&nbsp;      }
<i>2895</i>&nbsp;
<b class="fc"><i>2896</i>&nbsp;      if (x == 0) {</b>
<b class="fc"><i>2897</i>&nbsp;          return Math.PI/2.0;</b>
<i>2898</i>&nbsp;      }
<i>2899</i>&nbsp;
<i>2900</i>&nbsp;      /* Compute acos(x) = atan(sqrt(1-x*x)/x) */
<i>2901</i>&nbsp;
<i>2902</i>&nbsp;      /* Split x */
<b class="fc"><i>2903</i>&nbsp;      double temp = x * HEX_40000000;</b>
<b class="fc"><i>2904</i>&nbsp;      final double xa = x + temp - temp;</b>
<b class="fc"><i>2905</i>&nbsp;      final double xb = x - xa;</b>
<i>2906</i>&nbsp;
<i>2907</i>&nbsp;      /* Square it */
<b class="fc"><i>2908</i>&nbsp;      double ya = xa*xa;</b>
<b class="fc"><i>2909</i>&nbsp;      double yb = xa*xb*2.0 + xb*xb;</b>
<i>2910</i>&nbsp;
<i>2911</i>&nbsp;      /* Subtract from 1 */
<b class="fc"><i>2912</i>&nbsp;      ya = -ya;</b>
<b class="fc"><i>2913</i>&nbsp;      yb = -yb;</b>
<i>2914</i>&nbsp;
<b class="fc"><i>2915</i>&nbsp;      double za = 1.0 + ya;</b>
<b class="fc"><i>2916</i>&nbsp;      double zb = -(za - 1.0 - ya);</b>
<i>2917</i>&nbsp;
<b class="fc"><i>2918</i>&nbsp;      temp = za + yb;</b>
<b class="fc"><i>2919</i>&nbsp;      zb += -(temp - za - yb);</b>
<b class="fc"><i>2920</i>&nbsp;      za = temp;</b>
<i>2921</i>&nbsp;
<i>2922</i>&nbsp;      /* Square root */
<b class="fc"><i>2923</i>&nbsp;      double y = sqrt(za);</b>
<b class="fc"><i>2924</i>&nbsp;      temp = y * HEX_40000000;</b>
<b class="fc"><i>2925</i>&nbsp;      ya = y + temp - temp;</b>
<b class="fc"><i>2926</i>&nbsp;      yb = y - ya;</b>
<i>2927</i>&nbsp;
<i>2928</i>&nbsp;      /* Extend precision of sqrt */
<b class="fc"><i>2929</i>&nbsp;      yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);</b>
<i>2930</i>&nbsp;
<i>2931</i>&nbsp;      /* Contribution of zb to sqrt */
<b class="fc"><i>2932</i>&nbsp;      yb += zb / (2.0*y);</b>
<b class="fc"><i>2933</i>&nbsp;      y = ya+yb;</b>
<b class="fc"><i>2934</i>&nbsp;      yb = -(y - ya - yb);</b>
<i>2935</i>&nbsp;
<i>2936</i>&nbsp;      // Compute ratio r = y/x
<b class="fc"><i>2937</i>&nbsp;      double r = y/x;</b>
<i>2938</i>&nbsp;
<i>2939</i>&nbsp;      // Did r overflow?
<b class="fc"><i>2940</i>&nbsp;      if (Double.isInfinite(r)) { // x is effectively zero</b>
<b class="fc"><i>2941</i>&nbsp;          return Math.PI/2; // so return the appropriate value</b>
<i>2942</i>&nbsp;      }
<i>2943</i>&nbsp;
<b class="fc"><i>2944</i>&nbsp;      double ra = doubleHighPart(r);</b>
<b class="fc"><i>2945</i>&nbsp;      double rb = r - ra;</b>
<i>2946</i>&nbsp;
<b class="fc"><i>2947</i>&nbsp;      rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division</b>
<b class="fc"><i>2948</i>&nbsp;      rb += yb / x;  // Add in effect additional bits of sqrt.</b>
<i>2949</i>&nbsp;
<b class="fc"><i>2950</i>&nbsp;      temp = ra + rb;</b>
<b class="fc"><i>2951</i>&nbsp;      rb = -(temp - ra - rb);</b>
<b class="fc"><i>2952</i>&nbsp;      ra = temp;</b>
<i>2953</i>&nbsp;
<b class="fc"><i>2954</i>&nbsp;      return atan(ra, rb, x&lt;0);</b>
<i>2955</i>&nbsp;    }
<i>2956</i>&nbsp;
<i>2957</i>&nbsp;    /** Compute the cubic root of a number.
<i>2958</i>&nbsp;     * @param x number on which evaluation is done
<i>2959</i>&nbsp;     * @return cubic root of x
<i>2960</i>&nbsp;     */
<i>2961</i>&nbsp;    public static double cbrt(double x) {
<i>2962</i>&nbsp;      /* Convert input double to bits */
<b class="fc"><i>2963</i>&nbsp;      long inbits = Double.doubleToRawLongBits(x);</b>
<b class="fc"><i>2964</i>&nbsp;      int exponent = (int) ((inbits &gt;&gt; 52) &amp; 0x7ff) - 1023;</b>
<b class="fc"><i>2965</i>&nbsp;      boolean subnormal = false;</b>
<i>2966</i>&nbsp;
<b class="fc"><i>2967</i>&nbsp;      if (exponent == -1023) {</b>
<b class="fc"><i>2968</i>&nbsp;          if (x == 0) {</b>
<b class="fc"><i>2969</i>&nbsp;              return x;</b>
<i>2970</i>&nbsp;          }
<i>2971</i>&nbsp;
<i>2972</i>&nbsp;          /* Subnormal, so normalize */
<b class="fc"><i>2973</i>&nbsp;          subnormal = true;</b>
<b class="fc"><i>2974</i>&nbsp;          x *= 1.8014398509481984E16;  // 2^54</b>
<b class="fc"><i>2975</i>&nbsp;          inbits = Double.doubleToRawLongBits(x);</b>
<b class="fc"><i>2976</i>&nbsp;          exponent = (int) ((inbits &gt;&gt; 52) &amp; 0x7ff) - 1023;</b>
<i>2977</i>&nbsp;      }
<i>2978</i>&nbsp;
<b class="fc"><i>2979</i>&nbsp;      if (exponent == 1024) {</b>
<i>2980</i>&nbsp;          // Nan or infinity.  Don&#39;t care which.
<b class="fc"><i>2981</i>&nbsp;          return x;</b>
<i>2982</i>&nbsp;      }
<i>2983</i>&nbsp;
<i>2984</i>&nbsp;      /* Divide the exponent by 3 */
<b class="fc"><i>2985</i>&nbsp;      int exp3 = exponent / 3;</b>
<i>2986</i>&nbsp;
<i>2987</i>&nbsp;      /* p2 will be the nearest power of 2 to x with its exponent divided by 3 */
<b class="fc"><i>2988</i>&nbsp;      double p2 = Double.longBitsToDouble((inbits &amp; 0x8000000000000000L) |</b>
<i>2989</i>&nbsp;                                          (long)(((exp3 + 1023) &amp; 0x7ff)) &lt;&lt; 52);
<i>2990</i>&nbsp;
<i>2991</i>&nbsp;      /* This will be a number between 1 and 2 */
<b class="fc"><i>2992</i>&nbsp;      final double mant = Double.longBitsToDouble((inbits &amp; 0x000fffffffffffffL) | 0x3ff0000000000000L);</b>
<i>2993</i>&nbsp;
<i>2994</i>&nbsp;      /* Estimate the cube root of mant by polynomial */
<b class="fc"><i>2995</i>&nbsp;      double est = -0.010714690733195933;</b>
<b class="fc"><i>2996</i>&nbsp;      est = est * mant + 0.0875862700108075;</b>
<b class="fc"><i>2997</i>&nbsp;      est = est * mant + -0.3058015757857271;</b>
<b class="fc"><i>2998</i>&nbsp;      est = est * mant + 0.7249995199969751;</b>
<b class="fc"><i>2999</i>&nbsp;      est = est * mant + 0.5039018405998233;</b>
<i>3000</i>&nbsp;
<b class="fc"><i>3001</i>&nbsp;      est *= CBRTTWO[exponent % 3 + 2];</b>
<i>3002</i>&nbsp;
<i>3003</i>&nbsp;      // est should now be good to about 15 bits of precision.   Do 2 rounds of
<i>3004</i>&nbsp;      // Newton&#39;s method to get closer,  this should get us full double precision
<i>3005</i>&nbsp;      // Scale down x for the purpose of doing newtons method.  This avoids over/under flows.
<b class="fc"><i>3006</i>&nbsp;      final double xs = x / (p2*p2*p2);</b>
<b class="fc"><i>3007</i>&nbsp;      est += (xs - est*est*est) / (3*est*est);</b>
<b class="fc"><i>3008</i>&nbsp;      est += (xs - est*est*est) / (3*est*est);</b>
<i>3009</i>&nbsp;
<i>3010</i>&nbsp;      // Do one round of Newton&#39;s method in extended precision to get the last bit right.
<b class="fc"><i>3011</i>&nbsp;      double temp = est * HEX_40000000;</b>
<b class="fc"><i>3012</i>&nbsp;      double ya = est + temp - temp;</b>
<b class="fc"><i>3013</i>&nbsp;      double yb = est - ya;</b>
<i>3014</i>&nbsp;
<b class="fc"><i>3015</i>&nbsp;      double za = ya * ya;</b>
<b class="fc"><i>3016</i>&nbsp;      double zb = ya * yb * 2.0 + yb * yb;</b>
<b class="fc"><i>3017</i>&nbsp;      temp = za * HEX_40000000;</b>
<b class="fc"><i>3018</i>&nbsp;      double temp2 = za + temp - temp;</b>
<b class="fc"><i>3019</i>&nbsp;      zb += za - temp2;</b>
<b class="fc"><i>3020</i>&nbsp;      za = temp2;</b>
<i>3021</i>&nbsp;
<b class="fc"><i>3022</i>&nbsp;      zb = za * yb + ya * zb + zb * yb;</b>
<b class="fc"><i>3023</i>&nbsp;      za *= ya;</b>
<i>3024</i>&nbsp;
<b class="fc"><i>3025</i>&nbsp;      double na = xs - za;</b>
<b class="fc"><i>3026</i>&nbsp;      double nb = -(na - xs + za);</b>
<b class="fc"><i>3027</i>&nbsp;      nb -= zb;</b>
<i>3028</i>&nbsp;
<b class="fc"><i>3029</i>&nbsp;      est += (na+nb)/(3*est*est);</b>
<i>3030</i>&nbsp;
<i>3031</i>&nbsp;      /* Scale by a power of two, so this is exact. */
<b class="fc"><i>3032</i>&nbsp;      est *= p2;</b>
<i>3033</i>&nbsp;
<b class="fc"><i>3034</i>&nbsp;      if (subnormal) {</b>
<b class="fc"><i>3035</i>&nbsp;          est *= 3.814697265625E-6;  // 2^-18</b>
<i>3036</i>&nbsp;      }
<i>3037</i>&nbsp;
<b class="fc"><i>3038</i>&nbsp;      return est;</b>
<i>3039</i>&nbsp;    }
<i>3040</i>&nbsp;
<i>3041</i>&nbsp;    /**
<i>3042</i>&nbsp;     *  Convert degrees to radians, with error of less than 0.5 ULP
<i>3043</i>&nbsp;     *  @param x angle in degrees
<i>3044</i>&nbsp;     *  @return x converted into radians
<i>3045</i>&nbsp;     */
<i>3046</i>&nbsp;    public static double toRadians(double x)
<i>3047</i>&nbsp;    {
<b class="fc"><i>3048</i>&nbsp;        if (Double.isInfinite(x) || x == 0.0) { // Matches +/- 0.0; return correct sign</b>
<b class="fc"><i>3049</i>&nbsp;            return x;</b>
<i>3050</i>&nbsp;        }
<i>3051</i>&nbsp;
<i>3052</i>&nbsp;        // These are PI/180 split into high and low order bits
<b class="fc"><i>3053</i>&nbsp;        final double facta = 0.01745329052209854;</b>
<b class="fc"><i>3054</i>&nbsp;        final double factb = 1.997844754509471E-9;</b>
<i>3055</i>&nbsp;
<b class="fc"><i>3056</i>&nbsp;        double xa = doubleHighPart(x);</b>
<b class="fc"><i>3057</i>&nbsp;        double xb = x - xa;</b>
<i>3058</i>&nbsp;
<b class="fc"><i>3059</i>&nbsp;        double result = xb * factb + xb * facta + xa * factb + xa * facta;</b>
<b class="fc"><i>3060</i>&nbsp;        if (result == 0) {</b>
<b class="fc"><i>3061</i>&nbsp;            result *= x; // ensure correct sign if calculation underflows</b>
<i>3062</i>&nbsp;        }
<b class="fc"><i>3063</i>&nbsp;        return result;</b>
<i>3064</i>&nbsp;    }
<i>3065</i>&nbsp;
<i>3066</i>&nbsp;    /**
<i>3067</i>&nbsp;     *  Convert radians to degrees, with error of less than 0.5 ULP
<i>3068</i>&nbsp;     *  @param x angle in radians
<i>3069</i>&nbsp;     *  @return x converted into degrees
<i>3070</i>&nbsp;     */
<i>3071</i>&nbsp;    public static double toDegrees(double x)
<i>3072</i>&nbsp;    {
<b class="fc"><i>3073</i>&nbsp;        if (Double.isInfinite(x) || x == 0.0) { // Matches +/- 0.0; return correct sign</b>
<b class="fc"><i>3074</i>&nbsp;            return x;</b>
<i>3075</i>&nbsp;        }
<i>3076</i>&nbsp;
<i>3077</i>&nbsp;        // These are 180/PI split into high and low order bits
<b class="fc"><i>3078</i>&nbsp;        final double facta = 57.2957763671875;</b>
<b class="fc"><i>3079</i>&nbsp;        final double factb = 3.145894820876798E-6;</b>
<i>3080</i>&nbsp;
<b class="fc"><i>3081</i>&nbsp;        double xa = doubleHighPart(x);</b>
<b class="fc"><i>3082</i>&nbsp;        double xb = x - xa;</b>
<i>3083</i>&nbsp;
<b class="fc"><i>3084</i>&nbsp;        return xb * factb + xb * facta + xa * factb + xa * facta;</b>
<i>3085</i>&nbsp;    }
<i>3086</i>&nbsp;
<i>3087</i>&nbsp;    /**
<i>3088</i>&nbsp;     * Absolute value.
<i>3089</i>&nbsp;     * @param x number from which absolute value is requested
<i>3090</i>&nbsp;     * @return abs(x)
<i>3091</i>&nbsp;     */
<i>3092</i>&nbsp;    public static int abs(final int x) {
<b class="fc"><i>3093</i>&nbsp;        final int i = x &gt;&gt;&gt; 31;</b>
<b class="fc"><i>3094</i>&nbsp;        return (x ^ (~i + 1)) + i;</b>
<i>3095</i>&nbsp;    }
<i>3096</i>&nbsp;
<i>3097</i>&nbsp;    /**
<i>3098</i>&nbsp;     * Absolute value.
<i>3099</i>&nbsp;     * @param x number from which absolute value is requested
<i>3100</i>&nbsp;     * @return abs(x)
<i>3101</i>&nbsp;     */
<i>3102</i>&nbsp;    public static long abs(final long x) {
<b class="fc"><i>3103</i>&nbsp;        final long l = x &gt;&gt;&gt; 63;</b>
<i>3104</i>&nbsp;        // l is one if x negative zero else
<i>3105</i>&nbsp;        // ~l+1 is zero if x is positive, -1 if x is negative
<i>3106</i>&nbsp;        // x^(~l+1) is x is x is positive, ~x if x is negative
<i>3107</i>&nbsp;        // add around
<b class="fc"><i>3108</i>&nbsp;        return (x ^ (~l + 1)) + l;</b>
<i>3109</i>&nbsp;    }
<i>3110</i>&nbsp;
<i>3111</i>&nbsp;    /**
<i>3112</i>&nbsp;     * Absolute value.
<i>3113</i>&nbsp;     * @param x number from which absolute value is requested
<i>3114</i>&nbsp;     * @return abs(x)
<i>3115</i>&nbsp;     */
<i>3116</i>&nbsp;    public static float abs(final float x) {
<b class="fc"><i>3117</i>&nbsp;        return Float.intBitsToFloat(MASK_NON_SIGN_INT &amp; Float.floatToRawIntBits(x));</b>
<i>3118</i>&nbsp;    }
<i>3119</i>&nbsp;
<i>3120</i>&nbsp;    /**
<i>3121</i>&nbsp;     * Absolute value.
<i>3122</i>&nbsp;     * @param x number from which absolute value is requested
<i>3123</i>&nbsp;     * @return abs(x)
<i>3124</i>&nbsp;     */
<i>3125</i>&nbsp;    public static double abs(double x) {
<b class="fc"><i>3126</i>&nbsp;        return Double.longBitsToDouble(MASK_NON_SIGN_LONG &amp; Double.doubleToRawLongBits(x));</b>
<i>3127</i>&nbsp;    }
<i>3128</i>&nbsp;
<i>3129</i>&nbsp;    /**
<i>3130</i>&nbsp;     * Compute least significant bit (Unit in Last Position) for a number.
<i>3131</i>&nbsp;     * @param x number from which ulp is requested
<i>3132</i>&nbsp;     * @return ulp(x)
<i>3133</i>&nbsp;     */
<i>3134</i>&nbsp;    public static double ulp(double x) {
<b class="fc"><i>3135</i>&nbsp;        if (Double.isInfinite(x)) {</b>
<b class="fc"><i>3136</i>&nbsp;            return Double.POSITIVE_INFINITY;</b>
<i>3137</i>&nbsp;        }
<b class="fc"><i>3138</i>&nbsp;        return abs(x - Double.longBitsToDouble(Double.doubleToRawLongBits(x) ^ 1));</b>
<i>3139</i>&nbsp;    }
<i>3140</i>&nbsp;
<i>3141</i>&nbsp;    /**
<i>3142</i>&nbsp;     * Compute least significant bit (Unit in Last Position) for a number.
<i>3143</i>&nbsp;     * @param x number from which ulp is requested
<i>3144</i>&nbsp;     * @return ulp(x)
<i>3145</i>&nbsp;     */
<i>3146</i>&nbsp;    public static float ulp(float x) {
<b class="fc"><i>3147</i>&nbsp;        if (Float.isInfinite(x)) {</b>
<b class="fc"><i>3148</i>&nbsp;            return Float.POSITIVE_INFINITY;</b>
<i>3149</i>&nbsp;        }
<b class="fc"><i>3150</i>&nbsp;        return abs(x - Float.intBitsToFloat(Float.floatToIntBits(x) ^ 1));</b>
<i>3151</i>&nbsp;    }
<i>3152</i>&nbsp;
<i>3153</i>&nbsp;    /**
<i>3154</i>&nbsp;     * Multiply a double number by a power of 2.
<i>3155</i>&nbsp;     * @param d number to multiply
<i>3156</i>&nbsp;     * @param n power of 2
<i>3157</i>&nbsp;     * @return d &amp;times; 2&lt;sup&gt;n&lt;/sup&gt;
<i>3158</i>&nbsp;     */
<i>3159</i>&nbsp;    public static double scalb(final double d, final int n) {
<i>3160</i>&nbsp;
<i>3161</i>&nbsp;        // first simple and fast handling when 2^n can be represented using normal numbers
<b class="fc"><i>3162</i>&nbsp;        if ((n &gt; -1023) &amp;&amp; (n &lt; 1024)) {</b>
<b class="fc"><i>3163</i>&nbsp;            return d * Double.longBitsToDouble(((long) (n + 1023)) &lt;&lt; 52);</b>
<i>3164</i>&nbsp;        }
<i>3165</i>&nbsp;
<i>3166</i>&nbsp;        // handle special cases
<b class="fc"><i>3167</i>&nbsp;        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {</b>
<b class="fc"><i>3168</i>&nbsp;            return d;</b>
<i>3169</i>&nbsp;        }
<b class="fc"><i>3170</i>&nbsp;        if (n &lt; -2098) {</b>
<b class="fc"><i>3171</i>&nbsp;            return (d &gt; 0) ? 0.0 : -0.0;</b>
<i>3172</i>&nbsp;        }
<b class="fc"><i>3173</i>&nbsp;        if (n &gt; 2097) {</b>
<b class="fc"><i>3174</i>&nbsp;            return (d &gt; 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;</b>
<i>3175</i>&nbsp;        }
<i>3176</i>&nbsp;
<i>3177</i>&nbsp;        // decompose d
<b class="fc"><i>3178</i>&nbsp;        final long bits = Double.doubleToRawLongBits(d);</b>
<b class="fc"><i>3179</i>&nbsp;        final long sign = bits &amp; 0x8000000000000000L;</b>
<b class="fc"><i>3180</i>&nbsp;        int  exponent   = ((int) (bits &gt;&gt;&gt; 52)) &amp; 0x7ff;</b>
<b class="fc"><i>3181</i>&nbsp;        long mantissa   = bits &amp; 0x000fffffffffffffL;</b>
<i>3182</i>&nbsp;
<i>3183</i>&nbsp;        // compute scaled exponent
<b class="fc"><i>3184</i>&nbsp;        int scaledExponent = exponent + n;</b>
<i>3185</i>&nbsp;
<b class="fc"><i>3186</i>&nbsp;        if (n &lt; 0) {</b>
<i>3187</i>&nbsp;            // we are really in the case n &lt;= -1023
<b class="fc"><i>3188</i>&nbsp;            if (scaledExponent &gt; 0) {</b>
<i>3189</i>&nbsp;                // both the input and the result are normal numbers, we only adjust the exponent
<b class="fc"><i>3190</i>&nbsp;                return Double.longBitsToDouble(sign | (((long) scaledExponent) &lt;&lt; 52) | mantissa);</b>
<b class="fc"><i>3191</i>&nbsp;            } else if (scaledExponent &gt; -53) {</b>
<i>3192</i>&nbsp;                // the input is a normal number and the result is a subnormal number
<i>3193</i>&nbsp;
<i>3194</i>&nbsp;                // recover the hidden mantissa bit
<b class="fc"><i>3195</i>&nbsp;                mantissa |= 1L &lt;&lt; 52;</b>
<i>3196</i>&nbsp;
<i>3197</i>&nbsp;                // scales down complete mantissa, hence losing least significant bits
<b class="fc"><i>3198</i>&nbsp;                final long mostSignificantLostBit = mantissa &amp; (1L &lt;&lt; (-scaledExponent));</b>
<b class="fc"><i>3199</i>&nbsp;                mantissa &gt;&gt;&gt;= 1 - scaledExponent;</b>
<b class="fc"><i>3200</i>&nbsp;                if (mostSignificantLostBit != 0) {</b>
<i>3201</i>&nbsp;                    // we need to add 1 bit to round up the result
<b class="fc"><i>3202</i>&nbsp;                    mantissa++;</b>
<i>3203</i>&nbsp;                }
<b class="fc"><i>3204</i>&nbsp;                return Double.longBitsToDouble(sign | mantissa);</b>
<i>3205</i>&nbsp;
<i>3206</i>&nbsp;            } else {
<i>3207</i>&nbsp;                // no need to compute the mantissa, the number scales down to 0
<b class="nc"><i>3208</i>&nbsp;                return (sign == 0L) ? 0.0 : -0.0;</b>
<i>3209</i>&nbsp;            }
<i>3210</i>&nbsp;        } else {
<i>3211</i>&nbsp;            // we are really in the case n &gt;= 1024
<b class="fc"><i>3212</i>&nbsp;            if (exponent == 0) {</b>
<i>3213</i>&nbsp;
<i>3214</i>&nbsp;                // the input number is subnormal, normalize it
<b class="fc"><i>3215</i>&nbsp;                while ((mantissa &gt;&gt;&gt; 52) != 1) {</b>
<b class="fc"><i>3216</i>&nbsp;                    mantissa &lt;&lt;= 1;</b>
<b class="fc"><i>3217</i>&nbsp;                    --scaledExponent;</b>
<i>3218</i>&nbsp;                }
<b class="fc"><i>3219</i>&nbsp;                ++scaledExponent;</b>
<b class="fc"><i>3220</i>&nbsp;                mantissa &amp;= 0x000fffffffffffffL;</b>
<i>3221</i>&nbsp;
<b class="fc"><i>3222</i>&nbsp;                if (scaledExponent &lt; 2047) {</b>
<b class="fc"><i>3223</i>&nbsp;                    return Double.longBitsToDouble(sign | (((long) scaledExponent) &lt;&lt; 52) | mantissa);</b>
<i>3224</i>&nbsp;                } else {
<b class="nc"><i>3225</i>&nbsp;                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;</b>
<i>3226</i>&nbsp;                }
<i>3227</i>&nbsp;
<b class="fc"><i>3228</i>&nbsp;            } else if (scaledExponent &lt; 2047) {</b>
<b class="fc"><i>3229</i>&nbsp;                return Double.longBitsToDouble(sign | (((long) scaledExponent) &lt;&lt; 52) | mantissa);</b>
<i>3230</i>&nbsp;            } else {
<b class="fc"><i>3231</i>&nbsp;                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;</b>
<i>3232</i>&nbsp;            }
<i>3233</i>&nbsp;        }
<i>3234</i>&nbsp;
<i>3235</i>&nbsp;    }
<i>3236</i>&nbsp;
<i>3237</i>&nbsp;    /**
<i>3238</i>&nbsp;     * Multiply a float number by a power of 2.
<i>3239</i>&nbsp;     * @param f number to multiply
<i>3240</i>&nbsp;     * @param n power of 2
<i>3241</i>&nbsp;     * @return f &amp;times; 2&lt;sup&gt;n&lt;/sup&gt;
<i>3242</i>&nbsp;     */
<i>3243</i>&nbsp;    public static float scalb(final float f, final int n) {
<i>3244</i>&nbsp;
<i>3245</i>&nbsp;        // first simple and fast handling when 2^n can be represented using normal numbers
<b class="fc"><i>3246</i>&nbsp;        if ((n &gt; -127) &amp;&amp; (n &lt; 128)) {</b>
<b class="fc"><i>3247</i>&nbsp;            return f * Float.intBitsToFloat((n + 127) &lt;&lt; 23);</b>
<i>3248</i>&nbsp;        }
<i>3249</i>&nbsp;
<i>3250</i>&nbsp;        // handle special cases
<b class="fc"><i>3251</i>&nbsp;        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {</b>
<b class="fc"><i>3252</i>&nbsp;            return f;</b>
<i>3253</i>&nbsp;        }
<b class="fc"><i>3254</i>&nbsp;        if (n &lt; -277) {</b>
<b class="fc"><i>3255</i>&nbsp;            return (f &gt; 0) ? 0.0f : -0.0f;</b>
<i>3256</i>&nbsp;        }
<b class="fc"><i>3257</i>&nbsp;        if (n &gt; 276) {</b>
<b class="fc"><i>3258</i>&nbsp;            return (f &gt; 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;</b>
<i>3259</i>&nbsp;        }
<i>3260</i>&nbsp;
<i>3261</i>&nbsp;        // decompose f
<b class="fc"><i>3262</i>&nbsp;        final int bits = Float.floatToIntBits(f);</b>
<b class="fc"><i>3263</i>&nbsp;        final int sign = bits &amp; 0x80000000;</b>
<b class="fc"><i>3264</i>&nbsp;        int  exponent  = (bits &gt;&gt;&gt; 23) &amp; 0xff;</b>
<b class="fc"><i>3265</i>&nbsp;        int mantissa   = bits &amp; 0x007fffff;</b>
<i>3266</i>&nbsp;
<i>3267</i>&nbsp;        // compute scaled exponent
<b class="fc"><i>3268</i>&nbsp;        int scaledExponent = exponent + n;</b>
<i>3269</i>&nbsp;
<b class="fc"><i>3270</i>&nbsp;        if (n &lt; 0) {</b>
<i>3271</i>&nbsp;            // we are really in the case n &lt;= -127
<b class="fc"><i>3272</i>&nbsp;            if (scaledExponent &gt; 0) {</b>
<i>3273</i>&nbsp;                // both the input and the result are normal numbers, we only adjust the exponent
<b class="nc"><i>3274</i>&nbsp;                return Float.intBitsToFloat(sign | (scaledExponent &lt;&lt; 23) | mantissa);</b>
<b class="fc"><i>3275</i>&nbsp;            } else if (scaledExponent &gt; -24) {</b>
<i>3276</i>&nbsp;                // the input is a normal number and the result is a subnormal number
<i>3277</i>&nbsp;
<i>3278</i>&nbsp;                // recover the hidden mantissa bit
<b class="fc"><i>3279</i>&nbsp;                mantissa |= 1 &lt;&lt; 23;</b>
<i>3280</i>&nbsp;
<i>3281</i>&nbsp;                // scales down complete mantissa, hence losing least significant bits
<b class="fc"><i>3282</i>&nbsp;                final int mostSignificantLostBit = mantissa &amp; (1 &lt;&lt; (-scaledExponent));</b>
<b class="fc"><i>3283</i>&nbsp;                mantissa &gt;&gt;&gt;= 1 - scaledExponent;</b>
<b class="fc"><i>3284</i>&nbsp;                if (mostSignificantLostBit != 0) {</b>
<i>3285</i>&nbsp;                    // we need to add 1 bit to round up the result
<b class="fc"><i>3286</i>&nbsp;                    mantissa++;</b>
<i>3287</i>&nbsp;                }
<b class="fc"><i>3288</i>&nbsp;                return Float.intBitsToFloat(sign | mantissa);</b>
<i>3289</i>&nbsp;
<i>3290</i>&nbsp;            } else {
<i>3291</i>&nbsp;                // no need to compute the mantissa, the number scales down to 0
<b class="nc"><i>3292</i>&nbsp;                return (sign == 0) ? 0.0f : -0.0f;</b>
<i>3293</i>&nbsp;            }
<i>3294</i>&nbsp;        } else {
<i>3295</i>&nbsp;            // we are really in the case n &gt;= 128
<b class="fc"><i>3296</i>&nbsp;            if (exponent == 0) {</b>
<i>3297</i>&nbsp;
<i>3298</i>&nbsp;                // the input number is subnormal, normalize it
<b class="fc"><i>3299</i>&nbsp;                while ((mantissa &gt;&gt;&gt; 23) != 1) {</b>
<b class="fc"><i>3300</i>&nbsp;                    mantissa &lt;&lt;= 1;</b>
<b class="fc"><i>3301</i>&nbsp;                    --scaledExponent;</b>
<i>3302</i>&nbsp;                }
<b class="fc"><i>3303</i>&nbsp;                ++scaledExponent;</b>
<b class="fc"><i>3304</i>&nbsp;                mantissa &amp;= 0x007fffff;</b>
<i>3305</i>&nbsp;
<b class="fc"><i>3306</i>&nbsp;                if (scaledExponent &lt; 255) {</b>
<b class="fc"><i>3307</i>&nbsp;                    return Float.intBitsToFloat(sign | (scaledExponent &lt;&lt; 23) | mantissa);</b>
<i>3308</i>&nbsp;                } else {
<b class="nc"><i>3309</i>&nbsp;                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;</b>
<i>3310</i>&nbsp;                }
<i>3311</i>&nbsp;
<b class="fc"><i>3312</i>&nbsp;            } else if (scaledExponent &lt; 255) {</b>
<b class="fc"><i>3313</i>&nbsp;                return Float.intBitsToFloat(sign | (scaledExponent &lt;&lt; 23) | mantissa);</b>
<i>3314</i>&nbsp;            } else {
<b class="fc"><i>3315</i>&nbsp;                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;</b>
<i>3316</i>&nbsp;            }
<i>3317</i>&nbsp;        }
<i>3318</i>&nbsp;
<i>3319</i>&nbsp;    }
<i>3320</i>&nbsp;
<i>3321</i>&nbsp;    /**
<i>3322</i>&nbsp;     * Get the next machine representable number after a number, moving
<i>3323</i>&nbsp;     * in the direction of another number.
<i>3324</i>&nbsp;     * &lt;p&gt;
<i>3325</i>&nbsp;     * The ordering is as follows (increasing):
<i>3326</i>&nbsp;     * &lt;ul&gt;
<i>3327</i>&nbsp;     * &lt;li&gt;-INFINITY&lt;/li&gt;
<i>3328</i>&nbsp;     * &lt;li&gt;-MAX_VALUE&lt;/li&gt;
<i>3329</i>&nbsp;     * &lt;li&gt;-MIN_VALUE&lt;/li&gt;
<i>3330</i>&nbsp;     * &lt;li&gt;-0.0&lt;/li&gt;
<i>3331</i>&nbsp;     * &lt;li&gt;+0.0&lt;/li&gt;
<i>3332</i>&nbsp;     * &lt;li&gt;+MIN_VALUE&lt;/li&gt;
<i>3333</i>&nbsp;     * &lt;li&gt;+MAX_VALUE&lt;/li&gt;
<i>3334</i>&nbsp;     * &lt;li&gt;+INFINITY&lt;/li&gt;
<i>3335</i>&nbsp;     * &lt;li&gt;&lt;/li&gt;
<i>3336</i>&nbsp;     * &lt;/ul&gt;
<i>3337</i>&nbsp;     * &lt;p&gt;
<i>3338</i>&nbsp;     * If arguments compare equal, then the second argument is returned.
<i>3339</i>&nbsp;     * &lt;p&gt;
<i>3340</i>&nbsp;     * If {@code direction} is greater than {@code d},
<i>3341</i>&nbsp;     * the smallest machine representable number strictly greater than
<i>3342</i>&nbsp;     * {@code d} is returned; if less, then the largest representable number
<i>3343</i>&nbsp;     * strictly less than {@code d} is returned.&lt;/p&gt;
<i>3344</i>&nbsp;     * &lt;p&gt;
<i>3345</i>&nbsp;     * If {@code d} is infinite and direction does not
<i>3346</i>&nbsp;     * bring it back to finite numbers, it is returned unchanged.&lt;/p&gt;
<i>3347</i>&nbsp;     *
<i>3348</i>&nbsp;     * @param d base number
<i>3349</i>&nbsp;     * @param direction (the only important thing is whether
<i>3350</i>&nbsp;     * {@code direction} is greater or smaller than {@code d})
<i>3351</i>&nbsp;     * @return the next machine representable number in the specified direction
<i>3352</i>&nbsp;     */
<i>3353</i>&nbsp;    public static double nextAfter(double d, double direction) {
<i>3354</i>&nbsp;
<i>3355</i>&nbsp;        // handling of some important special cases
<b class="fc"><i>3356</i>&nbsp;        if (Double.isNaN(d) || Double.isNaN(direction)) {</b>
<b class="fc"><i>3357</i>&nbsp;            return Double.NaN;</b>
<b class="fc"><i>3358</i>&nbsp;        } else if (d == direction) {</b>
<b class="fc"><i>3359</i>&nbsp;            return direction;</b>
<b class="fc"><i>3360</i>&nbsp;        } else if (Double.isInfinite(d)) {</b>
<b class="fc"><i>3361</i>&nbsp;            return (d &lt; 0) ? -Double.MAX_VALUE : Double.MAX_VALUE;</b>
<b class="fc"><i>3362</i>&nbsp;        } else if (d == 0) {</b>
<b class="fc"><i>3363</i>&nbsp;            return (direction &lt; 0) ? -Double.MIN_VALUE : Double.MIN_VALUE;</b>
<i>3364</i>&nbsp;        }
<i>3365</i>&nbsp;        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0
<i>3366</i>&nbsp;        // are handled just as normal numbers
<i>3367</i>&nbsp;        // can use raw bits since already dealt with infinity and NaN
<b class="fc"><i>3368</i>&nbsp;        final long bits = Double.doubleToRawLongBits(d);</b>
<b class="fc"><i>3369</i>&nbsp;        final long sign = bits &amp; 0x8000000000000000L;</b>
<b class="fc"><i>3370</i>&nbsp;        if ((direction &lt; d) ^ (sign == 0L)) {</b>
<b class="fc"><i>3371</i>&nbsp;            return Double.longBitsToDouble(sign | ((bits &amp; 0x7fffffffffffffffL) + 1));</b>
<i>3372</i>&nbsp;        } else {
<b class="fc"><i>3373</i>&nbsp;            return Double.longBitsToDouble(sign | ((bits &amp; 0x7fffffffffffffffL) - 1));</b>
<i>3374</i>&nbsp;        }
<i>3375</i>&nbsp;
<i>3376</i>&nbsp;    }
<i>3377</i>&nbsp;
<i>3378</i>&nbsp;    /**
<i>3379</i>&nbsp;     * Get the next machine representable number after a number, moving
<i>3380</i>&nbsp;     * in the direction of another number.
<i>3381</i>&nbsp;     * &lt;p&gt;
<i>3382</i>&nbsp;     * The ordering is as follows (increasing):
<i>3383</i>&nbsp;     * &lt;ul&gt;
<i>3384</i>&nbsp;     * &lt;li&gt;-INFINITY&lt;/li&gt;
<i>3385</i>&nbsp;     * &lt;li&gt;-MAX_VALUE&lt;/li&gt;
<i>3386</i>&nbsp;     * &lt;li&gt;-MIN_VALUE&lt;/li&gt;
<i>3387</i>&nbsp;     * &lt;li&gt;-0.0&lt;/li&gt;
<i>3388</i>&nbsp;     * &lt;li&gt;+0.0&lt;/li&gt;
<i>3389</i>&nbsp;     * &lt;li&gt;+MIN_VALUE&lt;/li&gt;
<i>3390</i>&nbsp;     * &lt;li&gt;+MAX_VALUE&lt;/li&gt;
<i>3391</i>&nbsp;     * &lt;li&gt;+INFINITY&lt;/li&gt;
<i>3392</i>&nbsp;     * &lt;li&gt;&lt;/li&gt;
<i>3393</i>&nbsp;     * &lt;/ul&gt;
<i>3394</i>&nbsp;     * &lt;p&gt;
<i>3395</i>&nbsp;     * If arguments compare equal, then the second argument is returned.
<i>3396</i>&nbsp;     * &lt;p&gt;
<i>3397</i>&nbsp;     * If {@code direction} is greater than {@code f},
<i>3398</i>&nbsp;     * the smallest machine representable number strictly greater than
<i>3399</i>&nbsp;     * {@code f} is returned; if less, then the largest representable number
<i>3400</i>&nbsp;     * strictly less than {@code f} is returned.&lt;/p&gt;
<i>3401</i>&nbsp;     * &lt;p&gt;
<i>3402</i>&nbsp;     * If {@code f} is infinite and direction does not
<i>3403</i>&nbsp;     * bring it back to finite numbers, it is returned unchanged.&lt;/p&gt;
<i>3404</i>&nbsp;     *
<i>3405</i>&nbsp;     * @param f base number
<i>3406</i>&nbsp;     * @param direction (the only important thing is whether
<i>3407</i>&nbsp;     * {@code direction} is greater or smaller than {@code f})
<i>3408</i>&nbsp;     * @return the next machine representable number in the specified direction
<i>3409</i>&nbsp;     */
<i>3410</i>&nbsp;    public static float nextAfter(final float f, final double direction) {
<i>3411</i>&nbsp;
<i>3412</i>&nbsp;        // handling of some important special cases
<b class="fc"><i>3413</i>&nbsp;        if (Double.isNaN(f) || Double.isNaN(direction)) {</b>
<b class="fc"><i>3414</i>&nbsp;            return Float.NaN;</b>
<b class="fc"><i>3415</i>&nbsp;        } else if (f == direction) {</b>
<b class="fc"><i>3416</i>&nbsp;            return (float) direction;</b>
<b class="fc"><i>3417</i>&nbsp;        } else if (Float.isInfinite(f)) {</b>
<b class="fc"><i>3418</i>&nbsp;            return (f &lt; 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;</b>
<b class="fc"><i>3419</i>&nbsp;        } else if (f == 0f) {</b>
<b class="fc"><i>3420</i>&nbsp;            return (direction &lt; 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;</b>
<i>3421</i>&nbsp;        }
<i>3422</i>&nbsp;        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0
<i>3423</i>&nbsp;        // are handled just as normal numbers
<i>3424</i>&nbsp;
<b class="fc"><i>3425</i>&nbsp;        final int bits = Float.floatToIntBits(f);</b>
<b class="fc"><i>3426</i>&nbsp;        final int sign = bits &amp; 0x80000000;</b>
<b class="fc"><i>3427</i>&nbsp;        if ((direction &lt; f) ^ (sign == 0)) {</b>
<b class="fc"><i>3428</i>&nbsp;            return Float.intBitsToFloat(sign | ((bits &amp; 0x7fffffff) + 1));</b>
<i>3429</i>&nbsp;        } else {
<b class="fc"><i>3430</i>&nbsp;            return Float.intBitsToFloat(sign | ((bits &amp; 0x7fffffff) - 1));</b>
<i>3431</i>&nbsp;        }
<i>3432</i>&nbsp;
<i>3433</i>&nbsp;    }
<i>3434</i>&nbsp;
<i>3435</i>&nbsp;    /** Get the largest whole number smaller than x.
<i>3436</i>&nbsp;     * @param x number from which floor is requested
<i>3437</i>&nbsp;     * @return a double number f such that f is an integer f &amp;lt;= x &amp;lt; f + 1.0
<i>3438</i>&nbsp;     */
<i>3439</i>&nbsp;    public static double floor(double x) {
<i>3440</i>&nbsp;        long y;
<i>3441</i>&nbsp;
<b class="fc"><i>3442</i>&nbsp;        if (Double.isNaN(x)) {</b>
<b class="fc"><i>3443</i>&nbsp;            return x;</b>
<i>3444</i>&nbsp;        }
<i>3445</i>&nbsp;
<b class="fc"><i>3446</i>&nbsp;        if (x &gt;= TWO_POWER_52 || x &lt;= -TWO_POWER_52) {</b>
<b class="fc"><i>3447</i>&nbsp;            return x;</b>
<i>3448</i>&nbsp;        }
<i>3449</i>&nbsp;
<b class="fc"><i>3450</i>&nbsp;        y = (long) x;</b>
<b class="fc"><i>3451</i>&nbsp;        if (x &lt; 0 &amp;&amp; y != x) {</b>
<b class="fc"><i>3452</i>&nbsp;            y--;</b>
<i>3453</i>&nbsp;        }
<i>3454</i>&nbsp;
<b class="fc"><i>3455</i>&nbsp;        if (y == 0) {</b>
<b class="fc"><i>3456</i>&nbsp;            return x*y;</b>
<i>3457</i>&nbsp;        }
<i>3458</i>&nbsp;
<b class="fc"><i>3459</i>&nbsp;        return y;</b>
<i>3460</i>&nbsp;    }
<i>3461</i>&nbsp;
<i>3462</i>&nbsp;    /** Get the smallest whole number larger than x.
<i>3463</i>&nbsp;     * @param x number from which ceil is requested
<i>3464</i>&nbsp;     * @return a double number c such that c is an integer c - 1.0 &amp;lt; x &amp;lt;= c
<i>3465</i>&nbsp;     */
<i>3466</i>&nbsp;    public static double ceil(double x) {
<i>3467</i>&nbsp;        double y;
<i>3468</i>&nbsp;
<b class="fc"><i>3469</i>&nbsp;        if (Double.isNaN(x)) {</b>
<b class="fc"><i>3470</i>&nbsp;            return x;</b>
<i>3471</i>&nbsp;        }
<i>3472</i>&nbsp;
<b class="fc"><i>3473</i>&nbsp;        y = floor(x);</b>
<b class="fc"><i>3474</i>&nbsp;        if (y == x) {</b>
<b class="fc"><i>3475</i>&nbsp;            return y;</b>
<i>3476</i>&nbsp;        }
<i>3477</i>&nbsp;
<b class="fc"><i>3478</i>&nbsp;        y += 1.0;</b>
<i>3479</i>&nbsp;
<b class="fc"><i>3480</i>&nbsp;        if (y == 0) {</b>
<b class="fc"><i>3481</i>&nbsp;            return x*y;</b>
<i>3482</i>&nbsp;        }
<i>3483</i>&nbsp;
<b class="fc"><i>3484</i>&nbsp;        return y;</b>
<i>3485</i>&nbsp;    }
<i>3486</i>&nbsp;
<i>3487</i>&nbsp;    /** Get the whole number that is the nearest to x, or the even one if x is exactly half way between two integers.
<i>3488</i>&nbsp;     * @param x number from which nearest whole number is requested
<i>3489</i>&nbsp;     * @return a double number r such that r is an integer r - 0.5 &amp;lt;= x &amp;lt;= r + 0.5
<i>3490</i>&nbsp;     */
<i>3491</i>&nbsp;    public static double rint(double x) {
<b class="fc"><i>3492</i>&nbsp;        double y = floor(x);</b>
<b class="fc"><i>3493</i>&nbsp;        double d = x - y;</b>
<i>3494</i>&nbsp;
<b class="fc"><i>3495</i>&nbsp;        if (d &gt; 0.5) {</b>
<b class="fc"><i>3496</i>&nbsp;            if (y == -1.0) {</b>
<b class="fc"><i>3497</i>&nbsp;                return -0.0; // Preserve sign of operand</b>
<i>3498</i>&nbsp;            }
<b class="fc"><i>3499</i>&nbsp;            return y+1.0;</b>
<i>3500</i>&nbsp;        }
<b class="fc"><i>3501</i>&nbsp;        if (d &lt; 0.5) {</b>
<b class="fc"><i>3502</i>&nbsp;            return y;</b>
<i>3503</i>&nbsp;        }
<i>3504</i>&nbsp;
<i>3505</i>&nbsp;        /* half way, round to even */
<b class="fc"><i>3506</i>&nbsp;        long z = (long) y;</b>
<b class="fc"><i>3507</i>&nbsp;        return (z &amp; 1) == 0 ? y : y + 1.0;</b>
<i>3508</i>&nbsp;    }
<i>3509</i>&nbsp;
<i>3510</i>&nbsp;    /** Get the closest long to x.
<i>3511</i>&nbsp;     * @param x number from which closest long is requested
<i>3512</i>&nbsp;     * @return closest long to x
<i>3513</i>&nbsp;     */
<i>3514</i>&nbsp;    public static long round(double x) {
<b class="fc"><i>3515</i>&nbsp;        final long bits = Double.doubleToRawLongBits(x);</b>
<b class="fc"><i>3516</i>&nbsp;        final int biasedExp = ((int)(bits&gt;&gt;52)) &amp; 0x7ff;</b>
<i>3517</i>&nbsp;        // Shift to get rid of bits past comma except first one: will need to
<i>3518</i>&nbsp;        // 1-shift to the right to end up with correct magnitude.
<b class="fc"><i>3519</i>&nbsp;        final int shift = (52 - 1 + Double.MAX_EXPONENT) - biasedExp;</b>
<b class="fc"><i>3520</i>&nbsp;        if ((shift &amp; -64) == 0) {</b>
<i>3521</i>&nbsp;            // shift in [0,63], so unbiased exp in [-12,51].
<b class="fc"><i>3522</i>&nbsp;            long extendedMantissa = 0x0010000000000000L | (bits &amp; 0x000fffffffffffffL);</b>
<b class="fc"><i>3523</i>&nbsp;            if (bits &lt; 0) {</b>
<b class="fc"><i>3524</i>&nbsp;                extendedMantissa = -extendedMantissa;</b>
<i>3525</i>&nbsp;            }
<i>3526</i>&nbsp;            // If value is positive and first bit past comma is 0, rounding
<i>3527</i>&nbsp;            // to lower integer, else to upper one, which is what &quot;+1&quot; and
<i>3528</i>&nbsp;            // then &quot;&gt;&gt;1&quot; do.
<b class="fc"><i>3529</i>&nbsp;            return ((extendedMantissa &gt;&gt; shift) + 1L) &gt;&gt; 1;</b>
<i>3530</i>&nbsp;        } else {
<i>3531</i>&nbsp;            // +-Infinity, NaN, or a mathematical integer.
<b class="fc"><i>3532</i>&nbsp;            return (long) x;</b>
<i>3533</i>&nbsp;        }
<i>3534</i>&nbsp;    }
<i>3535</i>&nbsp;
<i>3536</i>&nbsp;    /** Get the closest int to x.
<i>3537</i>&nbsp;     * @param x number from which closest int is requested
<i>3538</i>&nbsp;     * @return closest int to x
<i>3539</i>&nbsp;     */
<i>3540</i>&nbsp;    public static int round(final float x) {
<b class="fc"><i>3541</i>&nbsp;        final int bits = Float.floatToRawIntBits(x);</b>
<b class="fc"><i>3542</i>&nbsp;        final int biasedExp = (bits&gt;&gt;23) &amp; 0xff;</b>
<i>3543</i>&nbsp;        // Shift to get rid of bits past comma except first one: will need to
<i>3544</i>&nbsp;        // 1-shift to the right to end up with correct magnitude.
<b class="fc"><i>3545</i>&nbsp;        final int shift = (23 - 1 + Float.MAX_EXPONENT) - biasedExp;</b>
<b class="fc"><i>3546</i>&nbsp;        if ((shift &amp; -32) == 0) {</b>
<i>3547</i>&nbsp;            // shift in [0,31], so unbiased exp in [-9,22].
<b class="nc"><i>3548</i>&nbsp;            int extendedMantissa = 0x00800000 | (bits &amp; 0x007fffff);</b>
<b class="nc"><i>3549</i>&nbsp;            if (bits &lt; 0) {</b>
<b class="nc"><i>3550</i>&nbsp;                extendedMantissa = -extendedMantissa;</b>
<i>3551</i>&nbsp;            }
<i>3552</i>&nbsp;            // If value is positive and first bit past comma is 0, rounding
<i>3553</i>&nbsp;            // to lower integer, else to upper one, which is what &quot;+1&quot; and
<i>3554</i>&nbsp;            // then &quot;&gt;&gt;1&quot; do.
<b class="nc"><i>3555</i>&nbsp;            return ((extendedMantissa &gt;&gt; shift) + 1) &gt;&gt; 1;</b>
<i>3556</i>&nbsp;        } else {
<i>3557</i>&nbsp;            // +-Infinity, NaN, or a mathematical integer.
<b class="fc"><i>3558</i>&nbsp;            return (int) x;</b>
<i>3559</i>&nbsp;        }
<i>3560</i>&nbsp;    }
<i>3561</i>&nbsp;
<i>3562</i>&nbsp;    /** Compute the minimum of two values
<i>3563</i>&nbsp;     * @param a first value
<i>3564</i>&nbsp;     * @param b second value
<i>3565</i>&nbsp;     * @return a if a is lesser or equal to b, b otherwise
<i>3566</i>&nbsp;     */
<i>3567</i>&nbsp;    public static int min(final int a, final int b) {
<b class="fc"><i>3568</i>&nbsp;        return (a &lt;= b) ? a : b;</b>
<i>3569</i>&nbsp;    }
<i>3570</i>&nbsp;
<i>3571</i>&nbsp;    /** Compute the minimum of two values
<i>3572</i>&nbsp;     * @param a first value
<i>3573</i>&nbsp;     * @param b second value
<i>3574</i>&nbsp;     * @return a if a is lesser or equal to b, b otherwise
<i>3575</i>&nbsp;     */
<i>3576</i>&nbsp;    public static long min(final long a, final long b) {
<b class="fc"><i>3577</i>&nbsp;        return (a &lt;= b) ? a : b;</b>
<i>3578</i>&nbsp;    }
<i>3579</i>&nbsp;
<i>3580</i>&nbsp;    /** Compute the minimum of two values
<i>3581</i>&nbsp;     * @param a first value
<i>3582</i>&nbsp;     * @param b second value
<i>3583</i>&nbsp;     * @return a if a is lesser or equal to b, b otherwise
<i>3584</i>&nbsp;     */
<i>3585</i>&nbsp;    public static float min(final float a, final float b) {
<b class="fc"><i>3586</i>&nbsp;        if (a &gt; b) {</b>
<b class="fc"><i>3587</i>&nbsp;            return b;</b>
<i>3588</i>&nbsp;        }
<b class="fc"><i>3589</i>&nbsp;        if (a &lt; b) {</b>
<b class="fc"><i>3590</i>&nbsp;            return a;</b>
<i>3591</i>&nbsp;        }
<i>3592</i>&nbsp;        /* if either arg is NaN, return NaN */
<b class="fc"><i>3593</i>&nbsp;        if (a != b) {</b>
<b class="fc"><i>3594</i>&nbsp;            return Float.NaN;</b>
<i>3595</i>&nbsp;        }
<i>3596</i>&nbsp;        /* min(+0.0,-0.0) == -0.0 */
<i>3597</i>&nbsp;        /* 0x80000000 == Float.floatToRawIntBits(-0.0d) */
<b class="fc"><i>3598</i>&nbsp;        int bits = Float.floatToRawIntBits(a);</b>
<b class="fc"><i>3599</i>&nbsp;        if (bits == 0x80000000) {</b>
<b class="fc"><i>3600</i>&nbsp;            return a;</b>
<i>3601</i>&nbsp;        }
<b class="fc"><i>3602</i>&nbsp;        return b;</b>
<i>3603</i>&nbsp;    }
<i>3604</i>&nbsp;
<i>3605</i>&nbsp;    /** Compute the minimum of two values
<i>3606</i>&nbsp;     * @param a first value
<i>3607</i>&nbsp;     * @param b second value
<i>3608</i>&nbsp;     * @return a if a is lesser or equal to b, b otherwise
<i>3609</i>&nbsp;     */
<i>3610</i>&nbsp;    public static double min(final double a, final double b) {
<b class="fc"><i>3611</i>&nbsp;        if (a &gt; b) {</b>
<b class="fc"><i>3612</i>&nbsp;            return b;</b>
<i>3613</i>&nbsp;        }
<b class="fc"><i>3614</i>&nbsp;        if (a &lt; b) {</b>
<b class="fc"><i>3615</i>&nbsp;            return a;</b>
<i>3616</i>&nbsp;        }
<i>3617</i>&nbsp;        /* if either arg is NaN, return NaN */
<b class="fc"><i>3618</i>&nbsp;        if (a != b) {</b>
<b class="fc"><i>3619</i>&nbsp;            return Double.NaN;</b>
<i>3620</i>&nbsp;        }
<i>3621</i>&nbsp;        /* min(+0.0,-0.0) == -0.0 */
<i>3622</i>&nbsp;        /* 0x8000000000000000L == Double.doubleToRawLongBits(-0.0d) */
<b class="fc"><i>3623</i>&nbsp;        long bits = Double.doubleToRawLongBits(a);</b>
<b class="fc"><i>3624</i>&nbsp;        if (bits == 0x8000000000000000L) {</b>
<b class="fc"><i>3625</i>&nbsp;            return a;</b>
<i>3626</i>&nbsp;        }
<b class="fc"><i>3627</i>&nbsp;        return b;</b>
<i>3628</i>&nbsp;    }
<i>3629</i>&nbsp;
<i>3630</i>&nbsp;    /** Compute the maximum of two values
<i>3631</i>&nbsp;     * @param a first value
<i>3632</i>&nbsp;     * @param b second value
<i>3633</i>&nbsp;     * @return b if a is lesser or equal to b, a otherwise
<i>3634</i>&nbsp;     */
<i>3635</i>&nbsp;    public static int max(final int a, final int b) {
<b class="fc"><i>3636</i>&nbsp;        return (a &lt;= b) ? b : a;</b>
<i>3637</i>&nbsp;    }
<i>3638</i>&nbsp;
<i>3639</i>&nbsp;    /** Compute the maximum of two values
<i>3640</i>&nbsp;     * @param a first value
<i>3641</i>&nbsp;     * @param b second value
<i>3642</i>&nbsp;     * @return b if a is lesser or equal to b, a otherwise
<i>3643</i>&nbsp;     */
<i>3644</i>&nbsp;    public static long max(final long a, final long b) {
<b class="fc"><i>3645</i>&nbsp;        return (a &lt;= b) ? b : a;</b>
<i>3646</i>&nbsp;    }
<i>3647</i>&nbsp;
<i>3648</i>&nbsp;    /** Compute the maximum of two values
<i>3649</i>&nbsp;     * @param a first value
<i>3650</i>&nbsp;     * @param b second value
<i>3651</i>&nbsp;     * @return b if a is lesser or equal to b, a otherwise
<i>3652</i>&nbsp;     */
<i>3653</i>&nbsp;    public static float max(final float a, final float b) {
<b class="fc"><i>3654</i>&nbsp;        if (a &gt; b) {</b>
<b class="fc"><i>3655</i>&nbsp;            return a;</b>
<i>3656</i>&nbsp;        }
<b class="fc"><i>3657</i>&nbsp;        if (a &lt; b) {</b>
<b class="fc"><i>3658</i>&nbsp;            return b;</b>
<i>3659</i>&nbsp;        }
<i>3660</i>&nbsp;        /* if either arg is NaN, return NaN */
<b class="fc"><i>3661</i>&nbsp;        if (a != b) {</b>
<b class="fc"><i>3662</i>&nbsp;            return Float.NaN;</b>
<i>3663</i>&nbsp;        }
<i>3664</i>&nbsp;        /* min(+0.0,-0.0) == -0.0 */
<i>3665</i>&nbsp;        /* 0x80000000 == Float.floatToRawIntBits(-0.0d) */
<b class="fc"><i>3666</i>&nbsp;        int bits = Float.floatToRawIntBits(a);</b>
<b class="fc"><i>3667</i>&nbsp;        if (bits == 0x80000000) {</b>
<b class="fc"><i>3668</i>&nbsp;            return b;</b>
<i>3669</i>&nbsp;        }
<b class="fc"><i>3670</i>&nbsp;        return a;</b>
<i>3671</i>&nbsp;    }
<i>3672</i>&nbsp;
<i>3673</i>&nbsp;    /** Compute the maximum of two values
<i>3674</i>&nbsp;     * @param a first value
<i>3675</i>&nbsp;     * @param b second value
<i>3676</i>&nbsp;     * @return b if a is lesser or equal to b, a otherwise
<i>3677</i>&nbsp;     */
<i>3678</i>&nbsp;    public static double max(final double a, final double b) {
<b class="fc"><i>3679</i>&nbsp;        if (a &gt; b) {</b>
<b class="fc"><i>3680</i>&nbsp;            return a;</b>
<i>3681</i>&nbsp;        }
<b class="fc"><i>3682</i>&nbsp;        if (a &lt; b) {</b>
<b class="fc"><i>3683</i>&nbsp;            return b;</b>
<i>3684</i>&nbsp;        }
<i>3685</i>&nbsp;        /* if either arg is NaN, return NaN */
<b class="fc"><i>3686</i>&nbsp;        if (a != b) {</b>
<b class="fc"><i>3687</i>&nbsp;            return Double.NaN;</b>
<i>3688</i>&nbsp;        }
<i>3689</i>&nbsp;        /* min(+0.0,-0.0) == -0.0 */
<i>3690</i>&nbsp;        /* 0x8000000000000000L == Double.doubleToRawLongBits(-0.0d) */
<b class="fc"><i>3691</i>&nbsp;        long bits = Double.doubleToRawLongBits(a);</b>
<b class="fc"><i>3692</i>&nbsp;        if (bits == 0x8000000000000000L) {</b>
<b class="fc"><i>3693</i>&nbsp;            return b;</b>
<i>3694</i>&nbsp;        }
<b class="fc"><i>3695</i>&nbsp;        return a;</b>
<i>3696</i>&nbsp;    }
<i>3697</i>&nbsp;
<i>3698</i>&nbsp;    /**
<i>3699</i>&nbsp;     * Returns the hypotenuse of a triangle with sides {@code x} and {@code y}
<i>3700</i>&nbsp;     * - sqrt(&lt;i&gt;x&lt;/i&gt;&lt;sup&gt;2&lt;/sup&gt;&amp;nbsp;+&lt;i&gt;y&lt;/i&gt;&lt;sup&gt;2&lt;/sup&gt;)&lt;br&gt;
<i>3701</i>&nbsp;     * avoiding intermediate overflow or underflow.
<i>3702</i>&nbsp;     *
<i>3703</i>&nbsp;     * &lt;ul&gt;
<i>3704</i>&nbsp;     * &lt;li&gt; If either argument is infinite, then the result is positive infinity.&lt;/li&gt;
<i>3705</i>&nbsp;     * &lt;li&gt; else, if either argument is NaN then the result is NaN.&lt;/li&gt;
<i>3706</i>&nbsp;     * &lt;/ul&gt;
<i>3707</i>&nbsp;     *
<i>3708</i>&nbsp;     * @param x a value
<i>3709</i>&nbsp;     * @param y a value
<i>3710</i>&nbsp;     * @return sqrt(&lt;i&gt;x&lt;/i&gt;&lt;sup&gt;2&lt;/sup&gt;&amp;nbsp;+&lt;i&gt;y&lt;/i&gt;&lt;sup&gt;2&lt;/sup&gt;)
<i>3711</i>&nbsp;     */
<i>3712</i>&nbsp;    public static double hypot(final double x, final double y) {
<b class="fc"><i>3713</i>&nbsp;        if (Double.isInfinite(x) || Double.isInfinite(y)) {</b>
<b class="fc"><i>3714</i>&nbsp;            return Double.POSITIVE_INFINITY;</b>
<b class="fc"><i>3715</i>&nbsp;        } else if (Double.isNaN(x) || Double.isNaN(y)) {</b>
<b class="fc"><i>3716</i>&nbsp;            return Double.NaN;</b>
<i>3717</i>&nbsp;        } else {
<i>3718</i>&nbsp;
<b class="fc"><i>3719</i>&nbsp;            final int expX = getExponent(x);</b>
<b class="fc"><i>3720</i>&nbsp;            final int expY = getExponent(y);</b>
<b class="fc"><i>3721</i>&nbsp;            if (expX &gt; expY + 27) {</b>
<i>3722</i>&nbsp;                // y is neglectible with respect to x
<b class="fc"><i>3723</i>&nbsp;                return abs(x);</b>
<b class="fc"><i>3724</i>&nbsp;            } else if (expY &gt; expX + 27) {</b>
<i>3725</i>&nbsp;                // x is neglectible with respect to y
<b class="fc"><i>3726</i>&nbsp;                return abs(y);</b>
<i>3727</i>&nbsp;            } else {
<i>3728</i>&nbsp;
<i>3729</i>&nbsp;                // find an intermediate scale to avoid both overflow and underflow
<b class="fc"><i>3730</i>&nbsp;                final int middleExp = (expX + expY) / 2;</b>
<i>3731</i>&nbsp;
<i>3732</i>&nbsp;                // scale parameters without losing precision
<b class="fc"><i>3733</i>&nbsp;                final double scaledX = scalb(x, -middleExp);</b>
<b class="fc"><i>3734</i>&nbsp;                final double scaledY = scalb(y, -middleExp);</b>
<i>3735</i>&nbsp;
<i>3736</i>&nbsp;                // compute scaled hypotenuse
<b class="fc"><i>3737</i>&nbsp;                final double scaledH = sqrt(scaledX * scaledX + scaledY * scaledY);</b>
<i>3738</i>&nbsp;
<i>3739</i>&nbsp;                // remove scaling
<b class="fc"><i>3740</i>&nbsp;                return scalb(scaledH, middleExp);</b>
<i>3741</i>&nbsp;
<i>3742</i>&nbsp;            }
<i>3743</i>&nbsp;
<i>3744</i>&nbsp;        }
<i>3745</i>&nbsp;    }
<i>3746</i>&nbsp;
<i>3747</i>&nbsp;    /**
<i>3748</i>&nbsp;     * Computes the remainder as prescribed by the IEEE 754 standard.
<i>3749</i>&nbsp;     * The remainder value is mathematically equal to {@code x - y*n}
<i>3750</i>&nbsp;     * where {@code n} is the mathematical integer closest to the exact mathematical value
<i>3751</i>&nbsp;     * of the quotient {@code x/y}.
<i>3752</i>&nbsp;     * If two mathematical integers are equally close to {@code x/y} then
<i>3753</i>&nbsp;     * {@code n} is the integer that is even.
<i>3754</i>&nbsp;     * &lt;ul&gt;
<i>3755</i>&nbsp;     * &lt;li&gt;If either operand is NaN, the result is NaN.&lt;/li&gt;
<i>3756</i>&nbsp;     * &lt;li&gt;If the result is not NaN, the sign of the result equals the sign of the dividend.&lt;/li&gt;
<i>3757</i>&nbsp;     * &lt;li&gt;If the dividend is an infinity, or the divisor is a zero, or both, the result is NaN.&lt;/li&gt;
<i>3758</i>&nbsp;     * &lt;li&gt;If the dividend is finite and the divisor is an infinity, the result equals the dividend.&lt;/li&gt;
<i>3759</i>&nbsp;     * &lt;li&gt;If the dividend is a zero and the divisor is finite, the result equals the dividend.&lt;/li&gt;
<i>3760</i>&nbsp;     * &lt;/ul&gt;
<i>3761</i>&nbsp;     * @param dividend the number to be divided
<i>3762</i>&nbsp;     * @param divisor the number by which to divide
<i>3763</i>&nbsp;     * @return the remainder, rounded
<i>3764</i>&nbsp;     */
<i>3765</i>&nbsp;    public static double IEEEremainder(final double dividend, final double divisor) {
<b class="fc"><i>3766</i>&nbsp;        if (getExponent(dividend) == 1024 || getExponent(divisor) == 1024 || divisor == 0.0) {</b>
<i>3767</i>&nbsp;            // we are in one of the special cases
<b class="fc"><i>3768</i>&nbsp;            if (Double.isInfinite(divisor) &amp;&amp; !Double.isInfinite(dividend)) {</b>
<b class="fc"><i>3769</i>&nbsp;                return dividend;</b>
<i>3770</i>&nbsp;            } else {
<b class="fc"><i>3771</i>&nbsp;                return Double.NaN;</b>
<i>3772</i>&nbsp;            }
<i>3773</i>&nbsp;        } else {
<i>3774</i>&nbsp;            // we are in the general case
<b class="fc"><i>3775</i>&nbsp;            final double n         = FastMath.rint(dividend / divisor);</b>
<b class="fc"><i>3776</i>&nbsp;            final double remainder = Double.isInfinite(n) ? 0.0 : dividend - divisor * n;</b>
<b class="fc"><i>3777</i>&nbsp;            return (remainder == 0) ? FastMath.copySign(remainder, dividend) : remainder;</b>
<i>3778</i>&nbsp;        }
<i>3779</i>&nbsp;    }
<i>3780</i>&nbsp;
<i>3781</i>&nbsp;    /** Convert a long to integer, detecting overflows
<i>3782</i>&nbsp;     * @param n number to convert to int
<i>3783</i>&nbsp;     * @return integer with same value as n if no overflows occur
<i>3784</i>&nbsp;     * @exception MathArithmeticException if n cannot fit into an int
<i>3785</i>&nbsp;     * @since 3.4
<i>3786</i>&nbsp;     */
<i>3787</i>&nbsp;    public static int toIntExact(final long n) throws MathArithmeticException {
<b class="fc"><i>3788</i>&nbsp;        if (n &lt; Integer.MIN_VALUE || n &gt; Integer.MAX_VALUE) {</b>
<b class="fc"><i>3789</i>&nbsp;            throw new MathArithmeticException(LocalizedFormats.OVERFLOW);</b>
<i>3790</i>&nbsp;        }
<b class="fc"><i>3791</i>&nbsp;        return (int) n;</b>
<i>3792</i>&nbsp;    }
<i>3793</i>&nbsp;
<i>3794</i>&nbsp;    /** Increment a number, detecting overflows.
<i>3795</i>&nbsp;     * @param n number to increment
<i>3796</i>&nbsp;     * @return n+1 if no overflows occur
<i>3797</i>&nbsp;     * @exception MathArithmeticException if an overflow occurs
<i>3798</i>&nbsp;     * @since 3.4
<i>3799</i>&nbsp;     */
<i>3800</i>&nbsp;    public static int incrementExact(final int n) throws MathArithmeticException {
<i>3801</i>&nbsp;
<b class="fc"><i>3802</i>&nbsp;        if (n == Integer.MAX_VALUE) {</b>
<b class="fc"><i>3803</i>&nbsp;            throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_ADDITION, n, 1);</b>
<i>3804</i>&nbsp;        }
<i>3805</i>&nbsp;
<b class="fc"><i>3806</i>&nbsp;        return n + 1;</b>
<i>3807</i>&nbsp;
<i>3808</i>&nbsp;    }
<i>3809</i>&nbsp;
<i>3810</i>&nbsp;    /** Increment a number, detecting overflows.
<i>3811</i>&nbsp;     * @param n number to increment
<i>3812</i>&nbsp;     * @return n+1 if no overflows occur
<i>3813</i>&nbsp;     * @exception MathArithmeticException if an overflow occurs
<i>3814</i>&nbsp;     * @since 3.4
<i>3815</i>&nbsp;     */
<i>3816</i>&nbsp;    public static long incrementExact(final long n) throws MathArithmeticException {
<i>3817</i>&nbsp;
<b class="nc"><i>3818</i>&nbsp;        if (n == Long.MAX_VALUE) {</b>
<b class="nc"><i>3819</i>&nbsp;            throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_ADDITION, n, 1);</b>
<i>3820</i>&nbsp;        }
<i>3821</i>&nbsp;
<b class="nc"><i>3822</i>&nbsp;        return n + 1;</b>
<i>3823</i>&nbsp;
<i>3824</i>&nbsp;    }
<i>3825</i>&nbsp;
<i>3826</i>&nbsp;    /** Decrement a number, detecting overflows.
<i>3827</i>&nbsp;     * @param n number to decrement
<i>3828</i>&nbsp;     * @return n-1 if no overflows occur
<i>3829</i>&nbsp;     * @exception MathArithmeticException if an overflow occurs
<i>3830</i>&nbsp;     * @since 3.4
<i>3831</i>&nbsp;     */
<i>3832</i>&nbsp;    public static int decrementExact(final int n) throws MathArithmeticException {
<i>3833</i>&nbsp;
<b class="fc"><i>3834</i>&nbsp;        if (n == Integer.MIN_VALUE) {</b>
<b class="fc"><i>3835</i>&nbsp;            throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_SUBTRACTION, n, 1);</b>
<i>3836</i>&nbsp;        }
<i>3837</i>&nbsp;
<b class="fc"><i>3838</i>&nbsp;        return n - 1;</b>
<i>3839</i>&nbsp;
<i>3840</i>&nbsp;    }
<i>3841</i>&nbsp;
<i>3842</i>&nbsp;    /** Decrement a number, detecting overflows.
<i>3843</i>&nbsp;     * @param n number to decrement
<i>3844</i>&nbsp;     * @return n-1 if no overflows occur
<i>3845</i>&nbsp;     * @exception MathArithmeticException if an overflow occurs
<i>3846</i>&nbsp;     * @since 3.4
<i>3847</i>&nbsp;     */
<i>3848</i>&nbsp;    public static long decrementExact(final long n) throws MathArithmeticException {
<i>3849</i>&nbsp;
<b class="nc"><i>3850</i>&nbsp;        if (n == Long.MIN_VALUE) {</b>
<b class="nc"><i>3851</i>&nbsp;            throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_SUBTRACTION, n, 1);</b>
<i>3852</i>&nbsp;        }
<i>3853</i>&nbsp;
<b class="nc"><i>3854</i>&nbsp;        return n - 1;</b>
<i>3855</i>&nbsp;
<i>3856</i>&nbsp;    }
<i>3857</i>&nbsp;
<i>3858</i>&nbsp;    /** Add two numbers, detecting overflows.
<i>3859</i>&nbsp;     * @param a first number to add
<i>3860</i>&nbsp;     * @param b second number to add
<i>3861</i>&nbsp;     * @return a+b if no overflows occur
<i>3862</i>&nbsp;     * @exception MathArithmeticException if an overflow occurs
<i>3863</i>&nbsp;     * @since 3.4
<i>3864</i>&nbsp;     */
<i>3865</i>&nbsp;    public static int addExact(final int a, final int b) throws MathArithmeticException {
<i>3866</i>&nbsp;
<i>3867</i>&nbsp;        // compute sum
<b class="fc"><i>3868</i>&nbsp;        final int sum = a + b;</b>
<i>3869</i>&nbsp;
<i>3870</i>&nbsp;        // check for overflow
<b class="fc"><i>3871</i>&nbsp;        if ((a ^ b) &gt;= 0 &amp;&amp; (sum ^ b) &lt; 0) {</b>
<b class="fc"><i>3872</i>&nbsp;            throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_ADDITION, a, b);</b>
<i>3873</i>&nbsp;        }
<i>3874</i>&nbsp;
<b class="fc"><i>3875</i>&nbsp;        return sum;</b>
<i>3876</i>&nbsp;
<i>3877</i>&nbsp;    }
<i>3878</i>&nbsp;
<i>3879</i>&nbsp;    /** Add two numbers, detecting overflows.
<i>3880</i>&nbsp;     * @param a first number to add
<i>3881</i>&nbsp;     * @param b second number to add
<i>3882</i>&nbsp;     * @return a+b if no overflows occur
<i>3883</i>&nbsp;     * @exception MathArithmeticException if an overflow occurs
<i>3884</i>&nbsp;     * @since 3.4
<i>3885</i>&nbsp;     */
<i>3886</i>&nbsp;    public static long addExact(final long a, final long b) throws MathArithmeticException {
<i>3887</i>&nbsp;
<i>3888</i>&nbsp;        // compute sum
<b class="fc"><i>3889</i>&nbsp;        final long sum = a + b;</b>
<i>3890</i>&nbsp;
<i>3891</i>&nbsp;        // check for overflow
<b class="fc"><i>3892</i>&nbsp;        if ((a ^ b) &gt;= 0 &amp;&amp; (sum ^ b) &lt; 0) {</b>
<b class="fc"><i>3893</i>&nbsp;            throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_ADDITION, a, b);</b>
<i>3894</i>&nbsp;        }
<i>3895</i>&nbsp;
<b class="fc"><i>3896</i>&nbsp;        return sum;</b>
<i>3897</i>&nbsp;
<i>3898</i>&nbsp;    }
<i>3899</i>&nbsp;
<i>3900</i>&nbsp;    /** Subtract two numbers, detecting overflows.
<i>3901</i>&nbsp;     * @param a first number
<i>3902</i>&nbsp;     * @param b second number to subtract from a
<i>3903</i>&nbsp;     * @return a-b if no overflows occur
<i>3904</i>&nbsp;     * @exception MathArithmeticException if an overflow occurs
<i>3905</i>&nbsp;     * @since 3.4
<i>3906</i>&nbsp;     */
<i>3907</i>&nbsp;    public static int subtractExact(final int a, final int b) {
<i>3908</i>&nbsp;
<i>3909</i>&nbsp;        // compute subtraction
<b class="fc"><i>3910</i>&nbsp;        final int sub = a - b;</b>
<i>3911</i>&nbsp;
<i>3912</i>&nbsp;        // check for overflow
<b class="fc"><i>3913</i>&nbsp;        if ((a ^ b) &lt; 0 &amp;&amp; (sub ^ b) &gt;= 0) {</b>
<b class="fc"><i>3914</i>&nbsp;            throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_SUBTRACTION, a, b);</b>
<i>3915</i>&nbsp;        }
<i>3916</i>&nbsp;
<b class="fc"><i>3917</i>&nbsp;        return sub;</b>
<i>3918</i>&nbsp;
<i>3919</i>&nbsp;    }
<i>3920</i>&nbsp;
<i>3921</i>&nbsp;    /** Subtract two numbers, detecting overflows.
<i>3922</i>&nbsp;     * @param a first number
<i>3923</i>&nbsp;     * @param b second number to subtract from a
<i>3924</i>&nbsp;     * @return a-b if no overflows occur
<i>3925</i>&nbsp;     * @exception MathArithmeticException if an overflow occurs
<i>3926</i>&nbsp;     * @since 3.4
<i>3927</i>&nbsp;     */
<i>3928</i>&nbsp;    public static long subtractExact(final long a, final long b) {
<i>3929</i>&nbsp;
<i>3930</i>&nbsp;        // compute subtraction
<b class="fc"><i>3931</i>&nbsp;        final long sub = a - b;</b>
<i>3932</i>&nbsp;
<i>3933</i>&nbsp;        // check for overflow
<b class="fc"><i>3934</i>&nbsp;        if ((a ^ b) &lt; 0 &amp;&amp; (sub ^ b) &gt;= 0) {</b>
<b class="fc"><i>3935</i>&nbsp;            throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_SUBTRACTION, a, b);</b>
<i>3936</i>&nbsp;        }
<i>3937</i>&nbsp;
<b class="fc"><i>3938</i>&nbsp;        return sub;</b>
<i>3939</i>&nbsp;
<i>3940</i>&nbsp;    }
<i>3941</i>&nbsp;
<i>3942</i>&nbsp;    /** Multiply two numbers, detecting overflows.
<i>3943</i>&nbsp;     * @param a first number to multiply
<i>3944</i>&nbsp;     * @param b second number to multiply
<i>3945</i>&nbsp;     * @return a*b if no overflows occur
<i>3946</i>&nbsp;     * @exception MathArithmeticException if an overflow occurs
<i>3947</i>&nbsp;     * @since 3.4
<i>3948</i>&nbsp;     */
<i>3949</i>&nbsp;    public static int multiplyExact(final int a, final int b) {
<b class="fc"><i>3950</i>&nbsp;        if (((b  &gt;  0)  &amp;&amp; (a &gt; Integer.MAX_VALUE / b || a &lt; Integer.MIN_VALUE / b)) ||</b>
<i>3951</i>&nbsp;            ((b  &lt; -1)  &amp;&amp; (a &gt; Integer.MIN_VALUE / b || a &lt; Integer.MAX_VALUE / b)) ||
<i>3952</i>&nbsp;            ((b == -1)  &amp;&amp; (a == Integer.MIN_VALUE))) {
<b class="fc"><i>3953</i>&nbsp;            throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_MULTIPLICATION, a, b);</b>
<i>3954</i>&nbsp;        }
<b class="fc"><i>3955</i>&nbsp;        return a * b;</b>
<i>3956</i>&nbsp;    }
<i>3957</i>&nbsp;
<i>3958</i>&nbsp;    /** Multiply two numbers, detecting overflows.
<i>3959</i>&nbsp;     * @param a first number to multiply
<i>3960</i>&nbsp;     * @param b second number to multiply
<i>3961</i>&nbsp;     * @return a*b if no overflows occur
<i>3962</i>&nbsp;     * @exception MathArithmeticException if an overflow occurs
<i>3963</i>&nbsp;     * @since 3.4
<i>3964</i>&nbsp;     */
<i>3965</i>&nbsp;    public static long multiplyExact(final long a, final long b) {
<b class="fc"><i>3966</i>&nbsp;        if (((b  &gt;  0l)  &amp;&amp; (a &gt; Long.MAX_VALUE / b || a &lt; Long.MIN_VALUE / b)) ||</b>
<i>3967</i>&nbsp;            ((b  &lt; -1l)  &amp;&amp; (a &gt; Long.MIN_VALUE / b || a &lt; Long.MAX_VALUE / b)) ||
<i>3968</i>&nbsp;            ((b == -1l)  &amp;&amp; (a == Long.MIN_VALUE))) {
<b class="fc"><i>3969</i>&nbsp;                throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_MULTIPLICATION, a, b);</b>
<i>3970</i>&nbsp;            }
<b class="fc"><i>3971</i>&nbsp;            return a * b;</b>
<i>3972</i>&nbsp;    }
<i>3973</i>&nbsp;
<i>3974</i>&nbsp;    /** Finds q such that a = q b + r with 0 &amp;lt;= r &amp;lt; b if b &amp;gt; 0 and b &amp;lt; r &amp;lt;= 0 if b &amp;lt; 0.
<i>3975</i>&nbsp;     * &lt;p&gt;
<i>3976</i>&nbsp;     * This methods returns the same value as integer division when
<i>3977</i>&nbsp;     * a and b are same signs, but returns a different value when
<i>3978</i>&nbsp;     * they are opposite (i.e. q is negative).
<i>3979</i>&nbsp;     * &lt;/p&gt;
<i>3980</i>&nbsp;     * @param a dividend
<i>3981</i>&nbsp;     * @param b divisor
<i>3982</i>&nbsp;     * @return q such that a = q b + r with 0 &amp;lt;= r &amp;lt; b if b &amp;gt; 0 and b &amp;lt; r &amp;lt;= 0 if b &amp;lt; 0
<i>3983</i>&nbsp;     * @exception MathArithmeticException if b == 0
<i>3984</i>&nbsp;     * @see #floorMod(int, int)
<i>3985</i>&nbsp;     * @since 3.4
<i>3986</i>&nbsp;     */
<i>3987</i>&nbsp;    public static int floorDiv(final int a, final int b) throws MathArithmeticException {
<i>3988</i>&nbsp;
<b class="fc"><i>3989</i>&nbsp;        if (b == 0) {</b>
<b class="fc"><i>3990</i>&nbsp;            throw new MathArithmeticException(LocalizedFormats.ZERO_DENOMINATOR);</b>
<i>3991</i>&nbsp;        }
<i>3992</i>&nbsp;
<b class="fc"><i>3993</i>&nbsp;        final int m = a % b;</b>
<b class="fc"><i>3994</i>&nbsp;        if ((a ^ b) &gt;= 0 || m == 0) {</b>
<i>3995</i>&nbsp;            // a an b have same sign, or division is exact
<b class="fc"><i>3996</i>&nbsp;            return a / b;</b>
<i>3997</i>&nbsp;        } else {
<i>3998</i>&nbsp;            // a and b have opposite signs and division is not exact
<b class="fc"><i>3999</i>&nbsp;            return (a / b) - 1;</b>
<i>4000</i>&nbsp;        }
<i>4001</i>&nbsp;
<i>4002</i>&nbsp;    }
<i>4003</i>&nbsp;
<i>4004</i>&nbsp;    /** Finds q such that a = q b + r with 0 &amp;lt;= r &amp;lt; b if b &amp;gt; 0 and b &amp;lt; r &amp;lt;= 0 if b &amp;lt; 0.
<i>4005</i>&nbsp;     * &lt;p&gt;
<i>4006</i>&nbsp;     * This methods returns the same value as integer division when
<i>4007</i>&nbsp;     * a and b are same signs, but returns a different value when
<i>4008</i>&nbsp;     * they are opposite (i.e. q is negative).
<i>4009</i>&nbsp;     * &lt;/p&gt;
<i>4010</i>&nbsp;     * @param a dividend
<i>4011</i>&nbsp;     * @param b divisor
<i>4012</i>&nbsp;     * @return q such that a = q b + r with 0 &amp;lt;= r &amp;lt; b if b &amp;gt; 0 and b &amp;lt; r &amp;lt;= 0 if b &amp;lt; 0
<i>4013</i>&nbsp;     * @exception MathArithmeticException if b == 0
<i>4014</i>&nbsp;     * @see #floorMod(long, long)
<i>4015</i>&nbsp;     * @since 3.4
<i>4016</i>&nbsp;     */
<i>4017</i>&nbsp;    public static long floorDiv(final long a, final long b) throws MathArithmeticException {
<i>4018</i>&nbsp;
<b class="fc"><i>4019</i>&nbsp;        if (b == 0l) {</b>
<b class="fc"><i>4020</i>&nbsp;            throw new MathArithmeticException(LocalizedFormats.ZERO_DENOMINATOR);</b>
<i>4021</i>&nbsp;        }
<i>4022</i>&nbsp;
<b class="fc"><i>4023</i>&nbsp;        final long m = a % b;</b>
<b class="fc"><i>4024</i>&nbsp;        if ((a ^ b) &gt;= 0l || m == 0l) {</b>
<i>4025</i>&nbsp;            // a an b have same sign, or division is exact
<b class="fc"><i>4026</i>&nbsp;            return a / b;</b>
<i>4027</i>&nbsp;        } else {
<i>4028</i>&nbsp;            // a and b have opposite signs and division is not exact
<b class="fc"><i>4029</i>&nbsp;            return (a / b) - 1l;</b>
<i>4030</i>&nbsp;        }
<i>4031</i>&nbsp;
<i>4032</i>&nbsp;    }
<i>4033</i>&nbsp;
<i>4034</i>&nbsp;    /** Finds r such that a = q b + r with 0 &amp;lt;= r &amp;lt; b if b &amp;gt; 0 and b &amp;lt; r &amp;lt;= 0 if b &amp;lt; 0.
<i>4035</i>&nbsp;     * &lt;p&gt;
<i>4036</i>&nbsp;     * This methods returns the same value as integer modulo when
<i>4037</i>&nbsp;     * a and b are same signs, but returns a different value when
<i>4038</i>&nbsp;     * they are opposite (i.e. q is negative).
<i>4039</i>&nbsp;     * &lt;/p&gt;
<i>4040</i>&nbsp;     * @param a dividend
<i>4041</i>&nbsp;     * @param b divisor
<i>4042</i>&nbsp;     * @return r such that a = q b + r with 0 &amp;lt;= r &amp;lt; b if b &amp;gt; 0 and b &amp;lt; r &amp;lt;= 0 if b &amp;lt; 0
<i>4043</i>&nbsp;     * @exception MathArithmeticException if b == 0
<i>4044</i>&nbsp;     * @see #floorDiv(int, int)
<i>4045</i>&nbsp;     * @since 3.4
<i>4046</i>&nbsp;     */
<i>4047</i>&nbsp;    public static int floorMod(final int a, final int b) throws MathArithmeticException {
<i>4048</i>&nbsp;
<b class="fc"><i>4049</i>&nbsp;        if (b == 0) {</b>
<b class="fc"><i>4050</i>&nbsp;            throw new MathArithmeticException(LocalizedFormats.ZERO_DENOMINATOR);</b>
<i>4051</i>&nbsp;        }
<i>4052</i>&nbsp;
<b class="fc"><i>4053</i>&nbsp;        final int m = a % b;</b>
<b class="fc"><i>4054</i>&nbsp;        if ((a ^ b) &gt;= 0 || m == 0) {</b>
<i>4055</i>&nbsp;            // a an b have same sign, or division is exact
<b class="fc"><i>4056</i>&nbsp;            return m;</b>
<i>4057</i>&nbsp;        } else {
<i>4058</i>&nbsp;            // a and b have opposite signs and division is not exact
<b class="fc"><i>4059</i>&nbsp;            return b + m;</b>
<i>4060</i>&nbsp;        }
<i>4061</i>&nbsp;
<i>4062</i>&nbsp;    }
<i>4063</i>&nbsp;
<i>4064</i>&nbsp;    /** Finds r such that a = q b + r with 0 &amp;lt;= r &amp;lt; b if b &amp;gt; 0 and b &amp;lt; r &amp;lt;= 0 if b &amp;lt; 0.
<i>4065</i>&nbsp;     * &lt;p&gt;
<i>4066</i>&nbsp;     * This methods returns the same value as integer modulo when
<i>4067</i>&nbsp;     * a and b are same signs, but returns a different value when
<i>4068</i>&nbsp;     * they are opposite (i.e. q is negative).
<i>4069</i>&nbsp;     * &lt;/p&gt;
<i>4070</i>&nbsp;     * @param a dividend
<i>4071</i>&nbsp;     * @param b divisor
<i>4072</i>&nbsp;     * @return r such that a = q b + r with 0 &amp;lt;= r &amp;lt; b if b &amp;gt; 0 and b &amp;lt; r &amp;lt;= 0 if b &amp;lt; 0
<i>4073</i>&nbsp;     * @exception MathArithmeticException if b == 0
<i>4074</i>&nbsp;     * @see #floorDiv(long, long)
<i>4075</i>&nbsp;     * @since 3.4
<i>4076</i>&nbsp;     */
<i>4077</i>&nbsp;    public static long floorMod(final long a, final long b) {
<i>4078</i>&nbsp;
<b class="fc"><i>4079</i>&nbsp;        if (b == 0l) {</b>
<b class="fc"><i>4080</i>&nbsp;            throw new MathArithmeticException(LocalizedFormats.ZERO_DENOMINATOR);</b>
<i>4081</i>&nbsp;        }
<i>4082</i>&nbsp;
<b class="fc"><i>4083</i>&nbsp;        final long m = a % b;</b>
<b class="fc"><i>4084</i>&nbsp;        if ((a ^ b) &gt;= 0l || m == 0l) {</b>
<i>4085</i>&nbsp;            // a an b have same sign, or division is exact
<b class="fc"><i>4086</i>&nbsp;            return m;</b>
<i>4087</i>&nbsp;        } else {
<i>4088</i>&nbsp;            // a and b have opposite signs and division is not exact
<b class="fc"><i>4089</i>&nbsp;            return b + m;</b>
<i>4090</i>&nbsp;        }
<i>4091</i>&nbsp;
<i>4092</i>&nbsp;    }
<i>4093</i>&nbsp;
<i>4094</i>&nbsp;    /**
<i>4095</i>&nbsp;     * Returns the first argument with the sign of the second argument.
<i>4096</i>&nbsp;     * A NaN {@code sign} argument is treated as positive.
<i>4097</i>&nbsp;     *
<i>4098</i>&nbsp;     * @param magnitude the value to return
<i>4099</i>&nbsp;     * @param sign the sign for the returned value
<i>4100</i>&nbsp;     * @return the magnitude with the same sign as the {@code sign} argument
<i>4101</i>&nbsp;     */
<i>4102</i>&nbsp;    public static double copySign(double magnitude, double sign){
<i>4103</i>&nbsp;        // The highest order bit is going to be zero if the
<i>4104</i>&nbsp;        // highest order bit of m and s is the same and one otherwise.
<i>4105</i>&nbsp;        // So (m^s) will be positive if both m and s have the same sign
<i>4106</i>&nbsp;        // and negative otherwise.
<b class="fc"><i>4107</i>&nbsp;        final long m = Double.doubleToRawLongBits(magnitude); // don&#39;t care about NaN</b>
<b class="fc"><i>4108</i>&nbsp;        final long s = Double.doubleToRawLongBits(sign);</b>
<b class="fc"><i>4109</i>&nbsp;        if ((m^s) &gt;= 0) {</b>
<b class="fc"><i>4110</i>&nbsp;            return magnitude;</b>
<i>4111</i>&nbsp;        }
<b class="fc"><i>4112</i>&nbsp;        return -magnitude; // flip sign</b>
<i>4113</i>&nbsp;    }
<i>4114</i>&nbsp;
<i>4115</i>&nbsp;    /**
<i>4116</i>&nbsp;     * Returns the first argument with the sign of the second argument.
<i>4117</i>&nbsp;     * A NaN {@code sign} argument is treated as positive.
<i>4118</i>&nbsp;     *
<i>4119</i>&nbsp;     * @param magnitude the value to return
<i>4120</i>&nbsp;     * @param sign the sign for the returned value
<i>4121</i>&nbsp;     * @return the magnitude with the same sign as the {@code sign} argument
<i>4122</i>&nbsp;     */
<i>4123</i>&nbsp;    public static float copySign(float magnitude, float sign){
<i>4124</i>&nbsp;        // The highest order bit is going to be zero if the
<i>4125</i>&nbsp;        // highest order bit of m and s is the same and one otherwise.
<i>4126</i>&nbsp;        // So (m^s) will be positive if both m and s have the same sign
<i>4127</i>&nbsp;        // and negative otherwise.
<b class="fc"><i>4128</i>&nbsp;        final int m = Float.floatToRawIntBits(magnitude);</b>
<b class="fc"><i>4129</i>&nbsp;        final int s = Float.floatToRawIntBits(sign);</b>
<b class="fc"><i>4130</i>&nbsp;        if ((m^s) &gt;= 0) {</b>
<b class="fc"><i>4131</i>&nbsp;            return magnitude;</b>
<i>4132</i>&nbsp;        }
<b class="fc"><i>4133</i>&nbsp;        return -magnitude; // flip sign</b>
<i>4134</i>&nbsp;    }
<i>4135</i>&nbsp;
<i>4136</i>&nbsp;    /**
<i>4137</i>&nbsp;     * Return the exponent of a double number, removing the bias.
<i>4138</i>&nbsp;     * &lt;p&gt;
<i>4139</i>&nbsp;     * For double numbers of the form 2&lt;sup&gt;x&lt;/sup&gt;, the unbiased
<i>4140</i>&nbsp;     * exponent is exactly x.
<i>4141</i>&nbsp;     * &lt;/p&gt;
<i>4142</i>&nbsp;     * @param d number from which exponent is requested
<i>4143</i>&nbsp;     * @return exponent for d in IEEE754 representation, without bias
<i>4144</i>&nbsp;     */
<i>4145</i>&nbsp;    public static int getExponent(final double d) {
<i>4146</i>&nbsp;        // NaN and Infinite will return 1024 anywho so can use raw bits
<b class="fc"><i>4147</i>&nbsp;        return (int) ((Double.doubleToRawLongBits(d) &gt;&gt;&gt; 52) &amp; 0x7ff) - 1023;</b>
<i>4148</i>&nbsp;    }
<i>4149</i>&nbsp;
<i>4150</i>&nbsp;    /**
<i>4151</i>&nbsp;     * Return the exponent of a float number, removing the bias.
<i>4152</i>&nbsp;     * &lt;p&gt;
<i>4153</i>&nbsp;     * For float numbers of the form 2&lt;sup&gt;x&lt;/sup&gt;, the unbiased
<i>4154</i>&nbsp;     * exponent is exactly x.
<i>4155</i>&nbsp;     * &lt;/p&gt;
<i>4156</i>&nbsp;     * @param f number from which exponent is requested
<i>4157</i>&nbsp;     * @return exponent for d in IEEE754 representation, without bias
<i>4158</i>&nbsp;     */
<i>4159</i>&nbsp;    public static int getExponent(final float f) {
<i>4160</i>&nbsp;        // NaN and Infinite will return the same exponent anywho so can use raw bits
<b class="fc"><i>4161</i>&nbsp;        return ((Float.floatToRawIntBits(f) &gt;&gt;&gt; 23) &amp; 0xff) - 127;</b>
<i>4162</i>&nbsp;    }
<i>4163</i>&nbsp;
<i>4164</i>&nbsp;    /**
<i>4165</i>&nbsp;     * Print out contents of arrays, and check the length.
<i>4166</i>&nbsp;     * &lt;p&gt;used to generate the preset arrays originally.&lt;/p&gt;
<i>4167</i>&nbsp;     * @param a unused
<i>4168</i>&nbsp;     */
<i>4169</i>&nbsp;    public static void main(String[] a) {
<b class="nc"><i>4170</i>&nbsp;        PrintStream out = System.out;</b>
<b class="nc"><i>4171</i>&nbsp;        FastMathCalc.printarray(out, &quot;EXP_INT_TABLE_A&quot;, EXP_INT_TABLE_LEN, ExpIntTable.EXP_INT_TABLE_A);</b>
<b class="nc"><i>4172</i>&nbsp;        FastMathCalc.printarray(out, &quot;EXP_INT_TABLE_B&quot;, EXP_INT_TABLE_LEN, ExpIntTable.EXP_INT_TABLE_B);</b>
<b class="nc"><i>4173</i>&nbsp;        FastMathCalc.printarray(out, &quot;EXP_FRAC_TABLE_A&quot;, EXP_FRAC_TABLE_LEN, ExpFracTable.EXP_FRAC_TABLE_A);</b>
<b class="nc"><i>4174</i>&nbsp;        FastMathCalc.printarray(out, &quot;EXP_FRAC_TABLE_B&quot;, EXP_FRAC_TABLE_LEN, ExpFracTable.EXP_FRAC_TABLE_B);</b>
<b class="nc"><i>4175</i>&nbsp;        FastMathCalc.printarray(out, &quot;LN_MANT&quot;,LN_MANT_LEN, lnMant.LN_MANT);</b>
<b class="nc"><i>4176</i>&nbsp;        FastMathCalc.printarray(out, &quot;SINE_TABLE_A&quot;, SINE_TABLE_LEN, SINE_TABLE_A);</b>
<b class="nc"><i>4177</i>&nbsp;        FastMathCalc.printarray(out, &quot;SINE_TABLE_B&quot;, SINE_TABLE_LEN, SINE_TABLE_B);</b>
<b class="nc"><i>4178</i>&nbsp;        FastMathCalc.printarray(out, &quot;COSINE_TABLE_A&quot;, SINE_TABLE_LEN, COSINE_TABLE_A);</b>
<b class="nc"><i>4179</i>&nbsp;        FastMathCalc.printarray(out, &quot;COSINE_TABLE_B&quot;, SINE_TABLE_LEN, COSINE_TABLE_B);</b>
<b class="nc"><i>4180</i>&nbsp;        FastMathCalc.printarray(out, &quot;TANGENT_TABLE_A&quot;, SINE_TABLE_LEN, TANGENT_TABLE_A);</b>
<b class="nc"><i>4181</i>&nbsp;        FastMathCalc.printarray(out, &quot;TANGENT_TABLE_B&quot;, SINE_TABLE_LEN, TANGENT_TABLE_B);</b>
<b class="nc"><i>4182</i>&nbsp;    }</b>
<i>4183</i>&nbsp;
<i>4184</i>&nbsp;    /** Enclose large data table in nested static class so it&#39;s only loaded on first access. */
<b class="fc"><i>4185</i>&nbsp;    private static class ExpIntTable {</b>
<i>4186</i>&nbsp;        /** Exponential evaluated at integer values,
<i>4187</i>&nbsp;         * exp(x) =  expIntTableA[x + EXP_INT_TABLE_MAX_INDEX] + expIntTableB[x+EXP_INT_TABLE_MAX_INDEX].
<i>4188</i>&nbsp;         */
<i>4189</i>&nbsp;        private static final double[] EXP_INT_TABLE_A;
<i>4190</i>&nbsp;        /** Exponential evaluated at integer values,
<i>4191</i>&nbsp;         * exp(x) =  expIntTableA[x + EXP_INT_TABLE_MAX_INDEX] + expIntTableB[x+EXP_INT_TABLE_MAX_INDEX]
<i>4192</i>&nbsp;         */
<i>4193</i>&nbsp;        private static final double[] EXP_INT_TABLE_B;
<i>4194</i>&nbsp;
<i>4195</i>&nbsp;        static {
<i>4196</i>&nbsp;            if (RECOMPUTE_TABLES_AT_RUNTIME) {
<i>4197</i>&nbsp;                EXP_INT_TABLE_A = new double[FastMath.EXP_INT_TABLE_LEN];
<i>4198</i>&nbsp;                EXP_INT_TABLE_B = new double[FastMath.EXP_INT_TABLE_LEN];
<i>4199</i>&nbsp;
<i>4200</i>&nbsp;                final double tmp[] = new double[2];
<i>4201</i>&nbsp;                final double recip[] = new double[2];
<i>4202</i>&nbsp;
<i>4203</i>&nbsp;                // Populate expIntTable
<i>4204</i>&nbsp;                for (int i = 0; i &lt; FastMath.EXP_INT_TABLE_MAX_INDEX; i++) {
<i>4205</i>&nbsp;                    FastMathCalc.expint(i, tmp);
<i>4206</i>&nbsp;                    EXP_INT_TABLE_A[i + FastMath.EXP_INT_TABLE_MAX_INDEX] = tmp[0];
<i>4207</i>&nbsp;                    EXP_INT_TABLE_B[i + FastMath.EXP_INT_TABLE_MAX_INDEX] = tmp[1];
<i>4208</i>&nbsp;
<i>4209</i>&nbsp;                    if (i != 0) {
<i>4210</i>&nbsp;                        // Negative integer powers
<i>4211</i>&nbsp;                        FastMathCalc.splitReciprocal(tmp, recip);
<i>4212</i>&nbsp;                        EXP_INT_TABLE_A[FastMath.EXP_INT_TABLE_MAX_INDEX - i] = recip[0];
<i>4213</i>&nbsp;                        EXP_INT_TABLE_B[FastMath.EXP_INT_TABLE_MAX_INDEX - i] = recip[1];
<i>4214</i>&nbsp;                    }
<i>4215</i>&nbsp;                }
<i>4216</i>&nbsp;            } else {
<b class="fc"><i>4217</i>&nbsp;                EXP_INT_TABLE_A = FastMathLiteralArrays.loadExpIntA();</b>
<b class="fc"><i>4218</i>&nbsp;                EXP_INT_TABLE_B = FastMathLiteralArrays.loadExpIntB();</b>
<i>4219</i>&nbsp;            }
<b class="fc"><i>4220</i>&nbsp;        }</b>
<i>4221</i>&nbsp;    }
<i>4222</i>&nbsp;
<i>4223</i>&nbsp;    /** Enclose large data table in nested static class so it&#39;s only loaded on first access. */
<b class="fc"><i>4224</i>&nbsp;    private static class ExpFracTable {</b>
<i>4225</i>&nbsp;        /** Exponential over the range of 0 - 1 in increments of 2^-10
<i>4226</i>&nbsp;         * exp(x/1024) =  expFracTableA[x] + expFracTableB[x].
<i>4227</i>&nbsp;         * 1024 = 2^10
<i>4228</i>&nbsp;         */
<i>4229</i>&nbsp;        private static final double[] EXP_FRAC_TABLE_A;
<i>4230</i>&nbsp;        /** Exponential over the range of 0 - 1 in increments of 2^-10
<i>4231</i>&nbsp;         * exp(x/1024) =  expFracTableA[x] + expFracTableB[x].
<i>4232</i>&nbsp;         */
<i>4233</i>&nbsp;        private static final double[] EXP_FRAC_TABLE_B;
<i>4234</i>&nbsp;
<i>4235</i>&nbsp;        static {
<i>4236</i>&nbsp;            if (RECOMPUTE_TABLES_AT_RUNTIME) {
<i>4237</i>&nbsp;                EXP_FRAC_TABLE_A = new double[FastMath.EXP_FRAC_TABLE_LEN];
<i>4238</i>&nbsp;                EXP_FRAC_TABLE_B = new double[FastMath.EXP_FRAC_TABLE_LEN];
<i>4239</i>&nbsp;
<i>4240</i>&nbsp;                final double tmp[] = new double[2];
<i>4241</i>&nbsp;
<i>4242</i>&nbsp;                // Populate expFracTable
<i>4243</i>&nbsp;                final double factor = 1d / (EXP_FRAC_TABLE_LEN - 1);
<i>4244</i>&nbsp;                for (int i = 0; i &lt; EXP_FRAC_TABLE_A.length; i++) {
<i>4245</i>&nbsp;                    FastMathCalc.slowexp(i * factor, tmp);
<i>4246</i>&nbsp;                    EXP_FRAC_TABLE_A[i] = tmp[0];
<i>4247</i>&nbsp;                    EXP_FRAC_TABLE_B[i] = tmp[1];
<i>4248</i>&nbsp;                }
<i>4249</i>&nbsp;            } else {
<b class="fc"><i>4250</i>&nbsp;                EXP_FRAC_TABLE_A = FastMathLiteralArrays.loadExpFracA();</b>
<b class="fc"><i>4251</i>&nbsp;                EXP_FRAC_TABLE_B = FastMathLiteralArrays.loadExpFracB();</b>
<i>4252</i>&nbsp;            }
<b class="fc"><i>4253</i>&nbsp;        }</b>
<i>4254</i>&nbsp;    }
<i>4255</i>&nbsp;
<i>4256</i>&nbsp;    /** Enclose large data table in nested static class so it&#39;s only loaded on first access. */
<b class="fc"><i>4257</i>&nbsp;    private static class lnMant {</b>
<i>4258</i>&nbsp;        /** Extended precision logarithm table over the range 1 - 2 in increments of 2^-10. */
<i>4259</i>&nbsp;        private static final double[][] LN_MANT;
<i>4260</i>&nbsp;
<i>4261</i>&nbsp;        static {
<i>4262</i>&nbsp;            if (RECOMPUTE_TABLES_AT_RUNTIME) {
<i>4263</i>&nbsp;                LN_MANT = new double[FastMath.LN_MANT_LEN][];
<i>4264</i>&nbsp;
<i>4265</i>&nbsp;                // Populate lnMant table
<i>4266</i>&nbsp;                for (int i = 0; i &lt; LN_MANT.length; i++) {
<i>4267</i>&nbsp;                    final double d = Double.longBitsToDouble( (((long) i) &lt;&lt; 42) | 0x3ff0000000000000L );
<i>4268</i>&nbsp;                    LN_MANT[i] = FastMathCalc.slowLog(d);
<i>4269</i>&nbsp;                }
<i>4270</i>&nbsp;            } else {
<b class="fc"><i>4271</i>&nbsp;                LN_MANT = FastMathLiteralArrays.loadLnMant();</b>
<i>4272</i>&nbsp;            }
<b class="fc"><i>4273</i>&nbsp;        }</b>
<i>4274</i>&nbsp;    }
<i>4275</i>&nbsp;
<i>4276</i>&nbsp;    /** Enclose the Cody/Waite reduction (used in &quot;sin&quot;, &quot;cos&quot; and &quot;tan&quot;). */
<i>4277</i>&nbsp;    private static class CodyWaite {
<i>4278</i>&nbsp;        /** k */
<i>4279</i>&nbsp;        private final int finalK;
<i>4280</i>&nbsp;        /** remA */
<i>4281</i>&nbsp;        private final double finalRemA;
<i>4282</i>&nbsp;        /** remB */
<i>4283</i>&nbsp;        private final double finalRemB;
<i>4284</i>&nbsp;
<i>4285</i>&nbsp;        /**
<i>4286</i>&nbsp;         * @param xa Argument.
<i>4287</i>&nbsp;         */
<b class="fc"><i>4288</i>&nbsp;        CodyWaite(double xa) {</b>
<i>4289</i>&nbsp;            // Estimate k.
<i>4290</i>&nbsp;            //k = (int)(xa / 1.5707963267948966);
<b class="fc"><i>4291</i>&nbsp;            int k = (int)(xa * 0.6366197723675814);</b>
<i>4292</i>&nbsp;
<i>4293</i>&nbsp;            // Compute remainder.
<i>4294</i>&nbsp;            double remA;
<i>4295</i>&nbsp;            double remB;
<i>4296</i>&nbsp;            while (true) {
<b class="fc"><i>4297</i>&nbsp;                double a = -k * 1.570796251296997;</b>
<b class="fc"><i>4298</i>&nbsp;                remA = xa + a;</b>
<b class="fc"><i>4299</i>&nbsp;                remB = -(remA - xa - a);</b>
<i>4300</i>&nbsp;
<b class="fc"><i>4301</i>&nbsp;                a = -k * 7.549789948768648E-8;</b>
<b class="fc"><i>4302</i>&nbsp;                double b = remA;</b>
<b class="fc"><i>4303</i>&nbsp;                remA = a + b;</b>
<b class="fc"><i>4304</i>&nbsp;                remB += -(remA - b - a);</b>
<i>4305</i>&nbsp;
<b class="fc"><i>4306</i>&nbsp;                a = -k * 6.123233995736766E-17;</b>
<b class="fc"><i>4307</i>&nbsp;                b = remA;</b>
<b class="fc"><i>4308</i>&nbsp;                remA = a + b;</b>
<b class="fc"><i>4309</i>&nbsp;                remB += -(remA - b - a);</b>
<i>4310</i>&nbsp;
<b class="fc"><i>4311</i>&nbsp;                if (remA &gt; 0) {</b>
<b class="fc"><i>4312</i>&nbsp;                    break;</b>
<i>4313</i>&nbsp;                }
<i>4314</i>&nbsp;
<i>4315</i>&nbsp;                // Remainder is negative, so decrement k and try again.
<i>4316</i>&nbsp;                // This should only happen if the input is very close
<i>4317</i>&nbsp;                // to an even multiple of pi/2.
<b class="fc"><i>4318</i>&nbsp;                --k;</b>
<b class="fc"><i>4319</i>&nbsp;            }</b>
<i>4320</i>&nbsp;
<b class="fc"><i>4321</i>&nbsp;            this.finalK = k;</b>
<b class="fc"><i>4322</i>&nbsp;            this.finalRemA = remA;</b>
<b class="fc"><i>4323</i>&nbsp;            this.finalRemB = remB;</b>
<b class="fc"><i>4324</i>&nbsp;        }</b>
<i>4325</i>&nbsp;
<i>4326</i>&nbsp;        /**
<i>4327</i>&nbsp;         * @return k
<i>4328</i>&nbsp;         */
<i>4329</i>&nbsp;        int getK() {
<b class="fc"><i>4330</i>&nbsp;            return finalK;</b>
<i>4331</i>&nbsp;        }
<i>4332</i>&nbsp;        /**
<i>4333</i>&nbsp;         * @return remA
<i>4334</i>&nbsp;         */
<i>4335</i>&nbsp;        double getRemA() {
<b class="fc"><i>4336</i>&nbsp;            return finalRemA;</b>
<i>4337</i>&nbsp;        }
<i>4338</i>&nbsp;        /**
<i>4339</i>&nbsp;         * @return remB
<i>4340</i>&nbsp;         */
<i>4341</i>&nbsp;        double getRemB() {
<b class="fc"><i>4342</i>&nbsp;            return finalRemB;</b>
<i>4343</i>&nbsp;        }
<i>4344</i>&nbsp;    }
<i>4345</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2019-06-04 09:26</div>
</div>
</body>
</html>
