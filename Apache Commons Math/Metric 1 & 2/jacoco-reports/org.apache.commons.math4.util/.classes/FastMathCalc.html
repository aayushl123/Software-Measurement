


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: FastMathCalc</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">org.apache.commons.math4.util</a> ]
</div>

<h1>Coverage Summary for Class: FastMathCalc (org.apache.commons.math4.util)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">FastMathCalc</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 18)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 266)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;/*
<i>2</i>&nbsp; * Licensed to the Apache Software Foundation (ASF) under one or more
<i>3</i>&nbsp; * contributor license agreements.  See the NOTICE file distributed with
<i>4</i>&nbsp; * this work for additional information regarding copyright ownership.
<i>5</i>&nbsp; * The ASF licenses this file to You under the Apache License, Version 2.0
<i>6</i>&nbsp; * (the &quot;License&quot;); you may not use this file except in compliance with
<i>7</i>&nbsp; * the License.  You may obtain a copy of the License at
<i>8</i>&nbsp; *
<i>9</i>&nbsp; *      http://www.apache.org/licenses/LICENSE-2.0
<i>10</i>&nbsp; *
<i>11</i>&nbsp; * Unless required by applicable law or agreed to in writing, software
<i>12</i>&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
<i>13</i>&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
<i>14</i>&nbsp; * See the License for the specific language governing permissions and
<i>15</i>&nbsp; * limitations under the License.
<i>16</i>&nbsp; */
<i>17</i>&nbsp;package org.apache.commons.math4.util;
<i>18</i>&nbsp;
<i>19</i>&nbsp;import java.io.PrintStream;
<i>20</i>&nbsp;
<i>21</i>&nbsp;import org.apache.commons.math4.exception.DimensionMismatchException;
<i>22</i>&nbsp;
<i>23</i>&nbsp;/** Class used to compute the classical functions tables.
<i>24</i>&nbsp; * @since 3.0
<i>25</i>&nbsp; */
<i>26</i>&nbsp;class FastMathCalc {
<i>27</i>&nbsp;
<i>28</i>&nbsp;    /**
<i>29</i>&nbsp;     * 0x40000000 - used to split a double into two parts, both with the low order bits cleared.
<i>30</i>&nbsp;     * Equivalent to 2^30.
<i>31</i>&nbsp;     */
<i>32</i>&nbsp;    private static final long HEX_40000000 = 0x40000000L; // 1073741824L
<i>33</i>&nbsp;
<i>34</i>&nbsp;    /** Factorial table, for Taylor series expansions. 0!, 1!, 2!, ... 19! */
<b class="nc"><i>35</i>&nbsp;    private static final double FACT[] = new double[]</b>
<i>36</i>&nbsp;        {
<i>37</i>&nbsp;        +1.0d,                        // 0
<i>38</i>&nbsp;        +1.0d,                        // 1
<i>39</i>&nbsp;        +2.0d,                        // 2
<i>40</i>&nbsp;        +6.0d,                        // 3
<i>41</i>&nbsp;        +24.0d,                       // 4
<i>42</i>&nbsp;        +120.0d,                      // 5
<i>43</i>&nbsp;        +720.0d,                      // 6
<i>44</i>&nbsp;        +5040.0d,                     // 7
<i>45</i>&nbsp;        +40320.0d,                    // 8
<i>46</i>&nbsp;        +362880.0d,                   // 9
<i>47</i>&nbsp;        +3628800.0d,                  // 10
<i>48</i>&nbsp;        +39916800.0d,                 // 11
<i>49</i>&nbsp;        +479001600.0d,                // 12
<i>50</i>&nbsp;        +6227020800.0d,               // 13
<i>51</i>&nbsp;        +87178291200.0d,              // 14
<i>52</i>&nbsp;        +1307674368000.0d,            // 15
<i>53</i>&nbsp;        +20922789888000.0d,           // 16
<i>54</i>&nbsp;        +355687428096000.0d,          // 17
<i>55</i>&nbsp;        +6402373705728000.0d,         // 18
<i>56</i>&nbsp;        +121645100408832000.0d,       // 19
<i>57</i>&nbsp;        };
<i>58</i>&nbsp;
<i>59</i>&nbsp;    /** Coefficients for slowLog. */
<b class="nc"><i>60</i>&nbsp;    private static final double LN_SPLIT_COEF[][] = {</b>
<i>61</i>&nbsp;        {2.0, 0.0},
<i>62</i>&nbsp;        {0.6666666269302368, 3.9736429850260626E-8},
<i>63</i>&nbsp;        {0.3999999761581421, 2.3841857910019882E-8},
<i>64</i>&nbsp;        {0.2857142686843872, 1.7029898543501842E-8},
<i>65</i>&nbsp;        {0.2222222089767456, 1.3245471311735498E-8},
<i>66</i>&nbsp;        {0.1818181574344635, 2.4384203044354907E-8},
<i>67</i>&nbsp;        {0.1538461446762085, 9.140260083262505E-9},
<i>68</i>&nbsp;        {0.13333332538604736, 9.220590270857665E-9},
<i>69</i>&nbsp;        {0.11764700710773468, 1.2393345855018391E-8},
<i>70</i>&nbsp;        {0.10526403784751892, 8.251545029714408E-9},
<i>71</i>&nbsp;        {0.0952233225107193, 1.2675934823758863E-8},
<i>72</i>&nbsp;        {0.08713622391223907, 1.1430250008909141E-8},
<i>73</i>&nbsp;        {0.07842259109020233, 2.404307984052299E-9},
<i>74</i>&nbsp;        {0.08371849358081818, 1.176342548272881E-8},
<i>75</i>&nbsp;        {0.030589580535888672, 1.2958646899018938E-9},
<i>76</i>&nbsp;        {0.14982303977012634, 1.225743062930824E-8},
<i>77</i>&nbsp;    };
<i>78</i>&nbsp;
<i>79</i>&nbsp;    /** Table start declaration. */
<i>80</i>&nbsp;    private static final String TABLE_START_DECL = &quot;    {&quot;;
<i>81</i>&nbsp;
<i>82</i>&nbsp;    /** Table end declaration. */
<i>83</i>&nbsp;    private static final String TABLE_END_DECL   = &quot;    };&quot;;
<i>84</i>&nbsp;
<i>85</i>&nbsp;    /**
<i>86</i>&nbsp;     * Private Constructor.
<i>87</i>&nbsp;     */
<b class="nc"><i>88</i>&nbsp;    private FastMathCalc() {</b>
<i>89</i>&nbsp;    }
<i>90</i>&nbsp;
<i>91</i>&nbsp;    /** Build the sine and cosine tables.
<i>92</i>&nbsp;     * @param SINE_TABLE_A table of the most significant part of the sines
<i>93</i>&nbsp;     * @param SINE_TABLE_B table of the least significant part of the sines
<i>94</i>&nbsp;     * @param COSINE_TABLE_A table of the most significant part of the cosines
<i>95</i>&nbsp;     * @param COSINE_TABLE_B table of the most significant part of the cosines
<i>96</i>&nbsp;     * @param SINE_TABLE_LEN length of the tables
<i>97</i>&nbsp;     * @param TANGENT_TABLE_A table of the most significant part of the tangents
<i>98</i>&nbsp;     * @param TANGENT_TABLE_B table of the most significant part of the tangents
<i>99</i>&nbsp;     */
<i>100</i>&nbsp;    @SuppressWarnings(&quot;unused&quot;)
<i>101</i>&nbsp;    private static void buildSinCosTables(double[] SINE_TABLE_A, double[] SINE_TABLE_B,
<i>102</i>&nbsp;                                          double[] COSINE_TABLE_A, double[] COSINE_TABLE_B,
<i>103</i>&nbsp;                                          int SINE_TABLE_LEN, double[] TANGENT_TABLE_A, double[] TANGENT_TABLE_B) {
<b class="nc"><i>104</i>&nbsp;        final double result[] = new double[2];</b>
<i>105</i>&nbsp;
<i>106</i>&nbsp;        /* Use taylor series for 0 &lt;= x &lt;= 6/8 */
<b class="nc"><i>107</i>&nbsp;        for (int i = 0; i &lt; 7; i++) {</b>
<b class="nc"><i>108</i>&nbsp;            double x = i / 8.0;</b>
<i>109</i>&nbsp;
<b class="nc"><i>110</i>&nbsp;            slowSin(x, result);</b>
<b class="nc"><i>111</i>&nbsp;            SINE_TABLE_A[i] = result[0];</b>
<b class="nc"><i>112</i>&nbsp;            SINE_TABLE_B[i] = result[1];</b>
<i>113</i>&nbsp;
<b class="nc"><i>114</i>&nbsp;            slowCos(x, result);</b>
<b class="nc"><i>115</i>&nbsp;            COSINE_TABLE_A[i] = result[0];</b>
<b class="nc"><i>116</i>&nbsp;            COSINE_TABLE_B[i] = result[1];</b>
<i>117</i>&nbsp;        }
<i>118</i>&nbsp;
<i>119</i>&nbsp;        /* Use angle addition formula to complete table to 13/8, just beyond pi/2 */
<b class="nc"><i>120</i>&nbsp;        for (int i = 7; i &lt; SINE_TABLE_LEN; i++) {</b>
<b class="nc"><i>121</i>&nbsp;            double xs[] = new double[2];</b>
<b class="nc"><i>122</i>&nbsp;            double ys[] = new double[2];</b>
<b class="nc"><i>123</i>&nbsp;            double as[] = new double[2];</b>
<b class="nc"><i>124</i>&nbsp;            double bs[] = new double[2];</b>
<b class="nc"><i>125</i>&nbsp;            double temps[] = new double[2];</b>
<i>126</i>&nbsp;
<b class="nc"><i>127</i>&nbsp;            if ( (i &amp; 1) == 0) {</b>
<i>128</i>&nbsp;                // Even, use double angle
<b class="nc"><i>129</i>&nbsp;                xs[0] = SINE_TABLE_A[i/2];</b>
<b class="nc"><i>130</i>&nbsp;                xs[1] = SINE_TABLE_B[i/2];</b>
<b class="nc"><i>131</i>&nbsp;                ys[0] = COSINE_TABLE_A[i/2];</b>
<b class="nc"><i>132</i>&nbsp;                ys[1] = COSINE_TABLE_B[i/2];</b>
<i>133</i>&nbsp;
<i>134</i>&nbsp;                /* compute sine */
<b class="nc"><i>135</i>&nbsp;                splitMult(xs, ys, result);</b>
<b class="nc"><i>136</i>&nbsp;                SINE_TABLE_A[i] = result[0] * 2.0;</b>
<b class="nc"><i>137</i>&nbsp;                SINE_TABLE_B[i] = result[1] * 2.0;</b>
<i>138</i>&nbsp;
<i>139</i>&nbsp;                /* Compute cosine */
<b class="nc"><i>140</i>&nbsp;                splitMult(ys, ys, as);</b>
<b class="nc"><i>141</i>&nbsp;                splitMult(xs, xs, temps);</b>
<b class="nc"><i>142</i>&nbsp;                temps[0] = -temps[0];</b>
<b class="nc"><i>143</i>&nbsp;                temps[1] = -temps[1];</b>
<b class="nc"><i>144</i>&nbsp;                splitAdd(as, temps, result);</b>
<b class="nc"><i>145</i>&nbsp;                COSINE_TABLE_A[i] = result[0];</b>
<b class="nc"><i>146</i>&nbsp;                COSINE_TABLE_B[i] = result[1];</b>
<i>147</i>&nbsp;            } else {
<b class="nc"><i>148</i>&nbsp;                xs[0] = SINE_TABLE_A[i/2];</b>
<b class="nc"><i>149</i>&nbsp;                xs[1] = SINE_TABLE_B[i/2];</b>
<b class="nc"><i>150</i>&nbsp;                ys[0] = COSINE_TABLE_A[i/2];</b>
<b class="nc"><i>151</i>&nbsp;                ys[1] = COSINE_TABLE_B[i/2];</b>
<b class="nc"><i>152</i>&nbsp;                as[0] = SINE_TABLE_A[i/2+1];</b>
<b class="nc"><i>153</i>&nbsp;                as[1] = SINE_TABLE_B[i/2+1];</b>
<b class="nc"><i>154</i>&nbsp;                bs[0] = COSINE_TABLE_A[i/2+1];</b>
<b class="nc"><i>155</i>&nbsp;                bs[1] = COSINE_TABLE_B[i/2+1];</b>
<i>156</i>&nbsp;
<i>157</i>&nbsp;                /* compute sine */
<b class="nc"><i>158</i>&nbsp;                splitMult(xs, bs, temps);</b>
<b class="nc"><i>159</i>&nbsp;                splitMult(ys, as, result);</b>
<b class="nc"><i>160</i>&nbsp;                splitAdd(result, temps, result);</b>
<b class="nc"><i>161</i>&nbsp;                SINE_TABLE_A[i] = result[0];</b>
<b class="nc"><i>162</i>&nbsp;                SINE_TABLE_B[i] = result[1];</b>
<i>163</i>&nbsp;
<i>164</i>&nbsp;                /* Compute cosine */
<b class="nc"><i>165</i>&nbsp;                splitMult(ys, bs, result);</b>
<b class="nc"><i>166</i>&nbsp;                splitMult(xs, as, temps);</b>
<b class="nc"><i>167</i>&nbsp;                temps[0] = -temps[0];</b>
<b class="nc"><i>168</i>&nbsp;                temps[1] = -temps[1];</b>
<b class="nc"><i>169</i>&nbsp;                splitAdd(result, temps, result);</b>
<b class="nc"><i>170</i>&nbsp;                COSINE_TABLE_A[i] = result[0];</b>
<b class="nc"><i>171</i>&nbsp;                COSINE_TABLE_B[i] = result[1];</b>
<i>172</i>&nbsp;            }
<i>173</i>&nbsp;        }
<i>174</i>&nbsp;
<i>175</i>&nbsp;        /* Compute tangent = sine/cosine */
<b class="nc"><i>176</i>&nbsp;        for (int i = 0; i &lt; SINE_TABLE_LEN; i++) {</b>
<b class="nc"><i>177</i>&nbsp;            double xs[] = new double[2];</b>
<b class="nc"><i>178</i>&nbsp;            double ys[] = new double[2];</b>
<b class="nc"><i>179</i>&nbsp;            double as[] = new double[2];</b>
<i>180</i>&nbsp;
<b class="nc"><i>181</i>&nbsp;            as[0] = COSINE_TABLE_A[i];</b>
<b class="nc"><i>182</i>&nbsp;            as[1] = COSINE_TABLE_B[i];</b>
<i>183</i>&nbsp;
<b class="nc"><i>184</i>&nbsp;            splitReciprocal(as, ys);</b>
<i>185</i>&nbsp;
<b class="nc"><i>186</i>&nbsp;            xs[0] = SINE_TABLE_A[i];</b>
<b class="nc"><i>187</i>&nbsp;            xs[1] = SINE_TABLE_B[i];</b>
<i>188</i>&nbsp;
<b class="nc"><i>189</i>&nbsp;            splitMult(xs, ys, as);</b>
<i>190</i>&nbsp;
<b class="nc"><i>191</i>&nbsp;            TANGENT_TABLE_A[i] = as[0];</b>
<b class="nc"><i>192</i>&nbsp;            TANGENT_TABLE_B[i] = as[1];</b>
<i>193</i>&nbsp;        }
<i>194</i>&nbsp;
<i>195</i>&nbsp;    }
<i>196</i>&nbsp;
<i>197</i>&nbsp;    /**
<i>198</i>&nbsp;     *  For x between 0 and pi/4 compute cosine using Talor series
<i>199</i>&nbsp;     *  cos(x) = 1 - x^2/2! + x^4/4! ...
<i>200</i>&nbsp;     * @param x number from which cosine is requested
<i>201</i>&nbsp;     * @param result placeholder where to put the result in extended precision
<i>202</i>&nbsp;     * (may be null)
<i>203</i>&nbsp;     * @return cos(x)
<i>204</i>&nbsp;     */
<i>205</i>&nbsp;    static double slowCos(final double x, final double result[]) {
<i>206</i>&nbsp;
<b class="nc"><i>207</i>&nbsp;        final double xs[] = new double[2];</b>
<b class="nc"><i>208</i>&nbsp;        final double ys[] = new double[2];</b>
<b class="nc"><i>209</i>&nbsp;        final double facts[] = new double[2];</b>
<b class="nc"><i>210</i>&nbsp;        final double as[] = new double[2];</b>
<b class="nc"><i>211</i>&nbsp;        split(x, xs);</b>
<b class="nc"><i>212</i>&nbsp;        ys[0] = ys[1] = 0.0;</b>
<i>213</i>&nbsp;
<b class="nc"><i>214</i>&nbsp;        for (int i = FACT.length-1; i &gt;= 0; i--) {</b>
<b class="nc"><i>215</i>&nbsp;            splitMult(xs, ys, as);</b>
<b class="nc"><i>216</i>&nbsp;            ys[0] = as[0]; ys[1] = as[1];</b>
<i>217</i>&nbsp;
<b class="nc"><i>218</i>&nbsp;            if ( (i &amp; 1) != 0) { // skip odd entries</b>
<b class="nc"><i>219</i>&nbsp;                continue;</b>
<i>220</i>&nbsp;            }
<i>221</i>&nbsp;
<b class="nc"><i>222</i>&nbsp;            split(FACT[i], as);</b>
<b class="nc"><i>223</i>&nbsp;            splitReciprocal(as, facts);</b>
<i>224</i>&nbsp;
<b class="nc"><i>225</i>&nbsp;            if ( (i &amp; 2) != 0 ) { // alternate terms are negative</b>
<b class="nc"><i>226</i>&nbsp;                facts[0] = -facts[0];</b>
<b class="nc"><i>227</i>&nbsp;                facts[1] = -facts[1];</b>
<i>228</i>&nbsp;            }
<i>229</i>&nbsp;
<b class="nc"><i>230</i>&nbsp;            splitAdd(ys, facts, as);</b>
<b class="nc"><i>231</i>&nbsp;            ys[0] = as[0]; ys[1] = as[1];</b>
<i>232</i>&nbsp;        }
<i>233</i>&nbsp;
<b class="nc"><i>234</i>&nbsp;        if (result != null) {</b>
<b class="nc"><i>235</i>&nbsp;            result[0] = ys[0];</b>
<b class="nc"><i>236</i>&nbsp;            result[1] = ys[1];</b>
<i>237</i>&nbsp;        }
<i>238</i>&nbsp;
<b class="nc"><i>239</i>&nbsp;        return ys[0] + ys[1];</b>
<i>240</i>&nbsp;    }
<i>241</i>&nbsp;
<i>242</i>&nbsp;    /**
<i>243</i>&nbsp;     * For x between 0 and pi/4 compute sine using Taylor expansion:
<i>244</i>&nbsp;     * sin(x) = x - x^3/3! + x^5/5! - x^7/7! ...
<i>245</i>&nbsp;     * @param x number from which sine is requested
<i>246</i>&nbsp;     * @param result placeholder where to put the result in extended precision
<i>247</i>&nbsp;     * (may be null)
<i>248</i>&nbsp;     * @return sin(x)
<i>249</i>&nbsp;     */
<i>250</i>&nbsp;    static double slowSin(final double x, final double result[]) {
<b class="nc"><i>251</i>&nbsp;        final double xs[] = new double[2];</b>
<b class="nc"><i>252</i>&nbsp;        final double ys[] = new double[2];</b>
<b class="nc"><i>253</i>&nbsp;        final double facts[] = new double[2];</b>
<b class="nc"><i>254</i>&nbsp;        final double as[] = new double[2];</b>
<b class="nc"><i>255</i>&nbsp;        split(x, xs);</b>
<b class="nc"><i>256</i>&nbsp;        ys[0] = ys[1] = 0.0;</b>
<i>257</i>&nbsp;
<b class="nc"><i>258</i>&nbsp;        for (int i = FACT.length-1; i &gt;= 0; i--) {</b>
<b class="nc"><i>259</i>&nbsp;            splitMult(xs, ys, as);</b>
<b class="nc"><i>260</i>&nbsp;            ys[0] = as[0]; ys[1] = as[1];</b>
<i>261</i>&nbsp;
<b class="nc"><i>262</i>&nbsp;            if ( (i &amp; 1) == 0) { // Ignore even numbers</b>
<b class="nc"><i>263</i>&nbsp;                continue;</b>
<i>264</i>&nbsp;            }
<i>265</i>&nbsp;
<b class="nc"><i>266</i>&nbsp;            split(FACT[i], as);</b>
<b class="nc"><i>267</i>&nbsp;            splitReciprocal(as, facts);</b>
<i>268</i>&nbsp;
<b class="nc"><i>269</i>&nbsp;            if ( (i &amp; 2) != 0 ) { // alternate terms are negative</b>
<b class="nc"><i>270</i>&nbsp;                facts[0] = -facts[0];</b>
<b class="nc"><i>271</i>&nbsp;                facts[1] = -facts[1];</b>
<i>272</i>&nbsp;            }
<i>273</i>&nbsp;
<b class="nc"><i>274</i>&nbsp;            splitAdd(ys, facts, as);</b>
<b class="nc"><i>275</i>&nbsp;            ys[0] = as[0]; ys[1] = as[1];</b>
<i>276</i>&nbsp;        }
<i>277</i>&nbsp;
<b class="nc"><i>278</i>&nbsp;        if (result != null) {</b>
<b class="nc"><i>279</i>&nbsp;            result[0] = ys[0];</b>
<b class="nc"><i>280</i>&nbsp;            result[1] = ys[1];</b>
<i>281</i>&nbsp;        }
<i>282</i>&nbsp;
<b class="nc"><i>283</i>&nbsp;        return ys[0] + ys[1];</b>
<i>284</i>&nbsp;    }
<i>285</i>&nbsp;
<i>286</i>&nbsp;
<i>287</i>&nbsp;    /**
<i>288</i>&nbsp;     *  For x between 0 and 1, returns exp(x), uses extended precision
<i>289</i>&nbsp;     *  @param x argument of exponential
<i>290</i>&nbsp;     *  @param result placeholder where to place exp(x) split in two terms
<i>291</i>&nbsp;     *  for extra precision (i.e. exp(x) = result[0] + result[1]
<i>292</i>&nbsp;     *  @return exp(x)
<i>293</i>&nbsp;     */
<i>294</i>&nbsp;    static double slowexp(final double x, final double result[]) {
<b class="nc"><i>295</i>&nbsp;        final double xs[] = new double[2];</b>
<b class="nc"><i>296</i>&nbsp;        final double ys[] = new double[2];</b>
<b class="nc"><i>297</i>&nbsp;        final double facts[] = new double[2];</b>
<b class="nc"><i>298</i>&nbsp;        final double as[] = new double[2];</b>
<b class="nc"><i>299</i>&nbsp;        split(x, xs);</b>
<b class="nc"><i>300</i>&nbsp;        ys[0] = ys[1] = 0.0;</b>
<i>301</i>&nbsp;
<b class="nc"><i>302</i>&nbsp;        for (int i = FACT.length-1; i &gt;= 0; i--) {</b>
<b class="nc"><i>303</i>&nbsp;            splitMult(xs, ys, as);</b>
<b class="nc"><i>304</i>&nbsp;            ys[0] = as[0];</b>
<b class="nc"><i>305</i>&nbsp;            ys[1] = as[1];</b>
<i>306</i>&nbsp;
<b class="nc"><i>307</i>&nbsp;            split(FACT[i], as);</b>
<b class="nc"><i>308</i>&nbsp;            splitReciprocal(as, facts);</b>
<i>309</i>&nbsp;
<b class="nc"><i>310</i>&nbsp;            splitAdd(ys, facts, as);</b>
<b class="nc"><i>311</i>&nbsp;            ys[0] = as[0];</b>
<b class="nc"><i>312</i>&nbsp;            ys[1] = as[1];</b>
<i>313</i>&nbsp;        }
<i>314</i>&nbsp;
<b class="nc"><i>315</i>&nbsp;        if (result != null) {</b>
<b class="nc"><i>316</i>&nbsp;            result[0] = ys[0];</b>
<b class="nc"><i>317</i>&nbsp;            result[1] = ys[1];</b>
<i>318</i>&nbsp;        }
<i>319</i>&nbsp;
<b class="nc"><i>320</i>&nbsp;        return ys[0] + ys[1];</b>
<i>321</i>&nbsp;    }
<i>322</i>&nbsp;
<i>323</i>&nbsp;    /** Compute split[0], split[1] such that their sum is equal to d,
<i>324</i>&nbsp;     * and split[0] has its 30 least significant bits as zero.
<i>325</i>&nbsp;     * @param d number to split
<i>326</i>&nbsp;     * @param split placeholder where to place the result
<i>327</i>&nbsp;     */
<i>328</i>&nbsp;    private static void split(final double d, final double split[]) {
<b class="nc"><i>329</i>&nbsp;        if (d &lt; 8e298 &amp;&amp; d &gt; -8e298) {</b>
<b class="nc"><i>330</i>&nbsp;            final double a = d * HEX_40000000;</b>
<b class="nc"><i>331</i>&nbsp;            split[0] = (d + a) - a;</b>
<b class="nc"><i>332</i>&nbsp;            split[1] = d - split[0];</b>
<b class="nc"><i>333</i>&nbsp;        } else {</b>
<b class="nc"><i>334</i>&nbsp;            final double a = d * 9.31322574615478515625E-10;</b>
<b class="nc"><i>335</i>&nbsp;            split[0] = (d + a - d) * HEX_40000000;</b>
<b class="nc"><i>336</i>&nbsp;            split[1] = d - split[0];</b>
<i>337</i>&nbsp;        }
<i>338</i>&nbsp;    }
<i>339</i>&nbsp;
<i>340</i>&nbsp;    /** Recompute a split.
<i>341</i>&nbsp;     * @param a input/out array containing the split, changed
<i>342</i>&nbsp;     * on output
<i>343</i>&nbsp;     */
<i>344</i>&nbsp;    private static void resplit(final double a[]) {
<b class="nc"><i>345</i>&nbsp;        final double c = a[0] + a[1];</b>
<b class="nc"><i>346</i>&nbsp;        final double d = -(c - a[0] - a[1]);</b>
<i>347</i>&nbsp;
<b class="nc"><i>348</i>&nbsp;        if (c &lt; 8e298 &amp;&amp; c &gt; -8e298) { // MAGIC NUMBER</b>
<b class="nc"><i>349</i>&nbsp;            double z = c * HEX_40000000;</b>
<b class="nc"><i>350</i>&nbsp;            a[0] = (c + z) - z;</b>
<b class="nc"><i>351</i>&nbsp;            a[1] = c - a[0] + d;</b>
<b class="nc"><i>352</i>&nbsp;        } else {</b>
<b class="nc"><i>353</i>&nbsp;            double z = c * 9.31322574615478515625E-10;</b>
<b class="nc"><i>354</i>&nbsp;            a[0] = (c + z - c) * HEX_40000000;</b>
<b class="nc"><i>355</i>&nbsp;            a[1] = c - a[0] + d;</b>
<i>356</i>&nbsp;        }
<i>357</i>&nbsp;    }
<i>358</i>&nbsp;
<i>359</i>&nbsp;    /** Multiply two numbers in split form.
<i>360</i>&nbsp;     * @param a first term of multiplication
<i>361</i>&nbsp;     * @param b second term of multiplication
<i>362</i>&nbsp;     * @param ans placeholder where to put the result
<i>363</i>&nbsp;     */
<i>364</i>&nbsp;    private static void splitMult(double a[], double b[], double ans[]) {
<b class="nc"><i>365</i>&nbsp;        ans[0] = a[0] * b[0];</b>
<b class="nc"><i>366</i>&nbsp;        ans[1] = a[0] * b[1] + a[1] * b[0] + a[1] * b[1];</b>
<i>367</i>&nbsp;
<i>368</i>&nbsp;        /* Resplit */
<b class="nc"><i>369</i>&nbsp;        resplit(ans);</b>
<i>370</i>&nbsp;    }
<i>371</i>&nbsp;
<i>372</i>&nbsp;    /** Add two numbers in split form.
<i>373</i>&nbsp;     * @param a first term of addition
<i>374</i>&nbsp;     * @param b second term of addition
<i>375</i>&nbsp;     * @param ans placeholder where to put the result
<i>376</i>&nbsp;     */
<i>377</i>&nbsp;    private static void splitAdd(final double a[], final double b[], final double ans[]) {
<b class="nc"><i>378</i>&nbsp;        ans[0] = a[0] + b[0];</b>
<b class="nc"><i>379</i>&nbsp;        ans[1] = a[1] + b[1];</b>
<i>380</i>&nbsp;
<b class="nc"><i>381</i>&nbsp;        resplit(ans);</b>
<i>382</i>&nbsp;    }
<i>383</i>&nbsp;
<i>384</i>&nbsp;    /** Compute the reciprocal of in.  Use the following algorithm.
<i>385</i>&nbsp;     *  in = c + d.
<i>386</i>&nbsp;     *  want to find x + y such that x+y = 1/(c+d) and x is much
<i>387</i>&nbsp;     *  larger than y and x has several zero bits on the right.
<i>388</i>&nbsp;     *
<i>389</i>&nbsp;     *  Set b = 1/(2^22),  a = 1 - b.  Thus (a+b) = 1.
<i>390</i>&nbsp;     *  Use following identity to compute (a+b)/(c+d)
<i>391</i>&nbsp;     *
<i>392</i>&nbsp;     *  (a+b)/(c+d)  =   a/c   +    (bc - ad) / (c^2 + cd)
<i>393</i>&nbsp;     *  set x = a/c  and y = (bc - ad) / (c^2 + cd)
<i>394</i>&nbsp;     *  This will be close to the right answer, but there will be
<i>395</i>&nbsp;     *  some rounding in the calculation of X.  So by carefully
<i>396</i>&nbsp;     *  computing 1 - (c+d)(x+y) we can compute an error and
<i>397</i>&nbsp;     *  add that back in.   This is done carefully so that terms
<i>398</i>&nbsp;     *  of similar size are subtracted first.
<i>399</i>&nbsp;     *  @param in initial number, in split form
<i>400</i>&nbsp;     *  @param result placeholder where to put the result
<i>401</i>&nbsp;     */
<i>402</i>&nbsp;    static void splitReciprocal(final double in[], final double result[]) {
<b class="nc"><i>403</i>&nbsp;        final double b = 1.0/4194304.0;</b>
<b class="nc"><i>404</i>&nbsp;        final double a = 1.0 - b;</b>
<i>405</i>&nbsp;
<b class="nc"><i>406</i>&nbsp;        if (in[0] == 0.0) {</b>
<b class="nc"><i>407</i>&nbsp;            in[0] = in[1];</b>
<b class="nc"><i>408</i>&nbsp;            in[1] = 0.0;</b>
<i>409</i>&nbsp;        }
<i>410</i>&nbsp;
<b class="nc"><i>411</i>&nbsp;        result[0] = a / in[0];</b>
<b class="nc"><i>412</i>&nbsp;        result[1] = (b*in[0]-a*in[1]) / (in[0]*in[0] + in[0]*in[1]);</b>
<i>413</i>&nbsp;
<b class="nc"><i>414</i>&nbsp;        if (result[1] != result[1]) { // can happen if result[1] is NAN</b>
<b class="nc"><i>415</i>&nbsp;            result[1] = 0.0;</b>
<i>416</i>&nbsp;        }
<i>417</i>&nbsp;
<i>418</i>&nbsp;        /* Resplit */
<b class="nc"><i>419</i>&nbsp;        resplit(result);</b>
<i>420</i>&nbsp;
<b class="nc"><i>421</i>&nbsp;        for (int i = 0; i &lt; 2; i++) {</b>
<i>422</i>&nbsp;            /* this may be overkill, probably once is enough */
<b class="nc"><i>423</i>&nbsp;            double err = 1.0 - result[0] * in[0] - result[0] * in[1] -</b>
<i>424</i>&nbsp;            result[1] * in[0] - result[1] * in[1];
<i>425</i>&nbsp;            /*err = 1.0 - err; */
<b class="nc"><i>426</i>&nbsp;            err *= result[0] + result[1];</b>
<i>427</i>&nbsp;            /*printf(&quot;err = %16e\n&quot;, err); */
<b class="nc"><i>428</i>&nbsp;            result[1] += err;</b>
<i>429</i>&nbsp;        }
<i>430</i>&nbsp;    }
<i>431</i>&nbsp;
<i>432</i>&nbsp;    /** Compute (a[0] + a[1]) * (b[0] + b[1]) in extended precision.
<i>433</i>&nbsp;     * @param a first term of the multiplication
<i>434</i>&nbsp;     * @param b second term of the multiplication
<i>435</i>&nbsp;     * @param result placeholder where to put the result
<i>436</i>&nbsp;     */
<i>437</i>&nbsp;    private static void quadMult(final double a[], final double b[], final double result[]) {
<b class="nc"><i>438</i>&nbsp;        final double xs[] = new double[2];</b>
<b class="nc"><i>439</i>&nbsp;        final double ys[] = new double[2];</b>
<b class="nc"><i>440</i>&nbsp;        final double zs[] = new double[2];</b>
<i>441</i>&nbsp;
<i>442</i>&nbsp;        /* a[0] * b[0] */
<b class="nc"><i>443</i>&nbsp;        split(a[0], xs);</b>
<b class="nc"><i>444</i>&nbsp;        split(b[0], ys);</b>
<b class="nc"><i>445</i>&nbsp;        splitMult(xs, ys, zs);</b>
<i>446</i>&nbsp;
<b class="nc"><i>447</i>&nbsp;        result[0] = zs[0];</b>
<b class="nc"><i>448</i>&nbsp;        result[1] = zs[1];</b>
<i>449</i>&nbsp;
<i>450</i>&nbsp;        /* a[0] * b[1] */
<b class="nc"><i>451</i>&nbsp;        split(b[1], ys);</b>
<b class="nc"><i>452</i>&nbsp;        splitMult(xs, ys, zs);</b>
<i>453</i>&nbsp;
<b class="nc"><i>454</i>&nbsp;        double tmp = result[0] + zs[0];</b>
<b class="nc"><i>455</i>&nbsp;        result[1] -= tmp - result[0] - zs[0];</b>
<b class="nc"><i>456</i>&nbsp;        result[0] = tmp;</b>
<b class="nc"><i>457</i>&nbsp;        tmp = result[0] + zs[1];</b>
<b class="nc"><i>458</i>&nbsp;        result[1] -= tmp - result[0] - zs[1];</b>
<b class="nc"><i>459</i>&nbsp;        result[0] = tmp;</b>
<i>460</i>&nbsp;
<i>461</i>&nbsp;        /* a[1] * b[0] */
<b class="nc"><i>462</i>&nbsp;        split(a[1], xs);</b>
<b class="nc"><i>463</i>&nbsp;        split(b[0], ys);</b>
<b class="nc"><i>464</i>&nbsp;        splitMult(xs, ys, zs);</b>
<i>465</i>&nbsp;
<b class="nc"><i>466</i>&nbsp;        tmp = result[0] + zs[0];</b>
<b class="nc"><i>467</i>&nbsp;        result[1] -= tmp - result[0] - zs[0];</b>
<b class="nc"><i>468</i>&nbsp;        result[0] = tmp;</b>
<b class="nc"><i>469</i>&nbsp;        tmp = result[0] + zs[1];</b>
<b class="nc"><i>470</i>&nbsp;        result[1] -= tmp - result[0] - zs[1];</b>
<b class="nc"><i>471</i>&nbsp;        result[0] = tmp;</b>
<i>472</i>&nbsp;
<i>473</i>&nbsp;        /* a[1] * b[0] */
<b class="nc"><i>474</i>&nbsp;        split(a[1], xs);</b>
<b class="nc"><i>475</i>&nbsp;        split(b[1], ys);</b>
<b class="nc"><i>476</i>&nbsp;        splitMult(xs, ys, zs);</b>
<i>477</i>&nbsp;
<b class="nc"><i>478</i>&nbsp;        tmp = result[0] + zs[0];</b>
<b class="nc"><i>479</i>&nbsp;        result[1] -= tmp - result[0] - zs[0];</b>
<b class="nc"><i>480</i>&nbsp;        result[0] = tmp;</b>
<b class="nc"><i>481</i>&nbsp;        tmp = result[0] + zs[1];</b>
<b class="nc"><i>482</i>&nbsp;        result[1] -= tmp - result[0] - zs[1];</b>
<b class="nc"><i>483</i>&nbsp;        result[0] = tmp;</b>
<i>484</i>&nbsp;    }
<i>485</i>&nbsp;
<i>486</i>&nbsp;    /** Compute exp(p) for a integer p in extended precision.
<i>487</i>&nbsp;     * @param p integer whose exponential is requested
<i>488</i>&nbsp;     * @param result placeholder where to put the result in extended precision
<i>489</i>&nbsp;     * @return exp(p) in standard precision (equal to result[0] + result[1])
<i>490</i>&nbsp;     */
<i>491</i>&nbsp;    static double expint(int p, final double result[]) {
<i>492</i>&nbsp;        //double x = M_E;
<b class="nc"><i>493</i>&nbsp;        final double xs[] = new double[2];</b>
<b class="nc"><i>494</i>&nbsp;        final double as[] = new double[2];</b>
<b class="nc"><i>495</i>&nbsp;        final double ys[] = new double[2];</b>
<i>496</i>&nbsp;        //split(x, xs);
<i>497</i>&nbsp;        //xs[1] = (double)(2.7182818284590452353602874713526625L - xs[0]);
<i>498</i>&nbsp;        //xs[0] = 2.71827697753906250000;
<i>499</i>&nbsp;        //xs[1] = 4.85091998273542816811e-06;
<i>500</i>&nbsp;        //xs[0] = Double.longBitsToDouble(0x4005bf0800000000L);
<i>501</i>&nbsp;        //xs[1] = Double.longBitsToDouble(0x3ed458a2bb4a9b00L);
<i>502</i>&nbsp;
<i>503</i>&nbsp;        /* E */
<b class="nc"><i>504</i>&nbsp;        xs[0] = 2.718281828459045;</b>
<b class="nc"><i>505</i>&nbsp;        xs[1] = 1.4456468917292502E-16;</b>
<i>506</i>&nbsp;
<b class="nc"><i>507</i>&nbsp;        split(1.0, ys);</b>
<i>508</i>&nbsp;
<b class="nc"><i>509</i>&nbsp;        while (p &gt; 0) {</b>
<b class="nc"><i>510</i>&nbsp;            if ((p &amp; 1) != 0) {</b>
<b class="nc"><i>511</i>&nbsp;                quadMult(ys, xs, as);</b>
<b class="nc"><i>512</i>&nbsp;                ys[0] = as[0]; ys[1] = as[1];</b>
<i>513</i>&nbsp;            }
<i>514</i>&nbsp;
<b class="nc"><i>515</i>&nbsp;            quadMult(xs, xs, as);</b>
<b class="nc"><i>516</i>&nbsp;            xs[0] = as[0]; xs[1] = as[1];</b>
<i>517</i>&nbsp;
<b class="nc"><i>518</i>&nbsp;            p &gt;&gt;= 1;</b>
<i>519</i>&nbsp;        }
<i>520</i>&nbsp;
<b class="nc"><i>521</i>&nbsp;        if (result != null) {</b>
<b class="nc"><i>522</i>&nbsp;            result[0] = ys[0];</b>
<b class="nc"><i>523</i>&nbsp;            result[1] = ys[1];</b>
<i>524</i>&nbsp;
<b class="nc"><i>525</i>&nbsp;            resplit(result);</b>
<i>526</i>&nbsp;        }
<i>527</i>&nbsp;
<b class="nc"><i>528</i>&nbsp;        return ys[0] + ys[1];</b>
<i>529</i>&nbsp;    }
<i>530</i>&nbsp;    /** xi in the range of [1, 2].
<i>531</i>&nbsp;     *                                3        5        7
<i>532</i>&nbsp;     *      x+1           /          x        x        x          \
<i>533</i>&nbsp;     *  ln ----- =   2 *  |  x  +   ----  +  ----  +  ---- + ...  |
<i>534</i>&nbsp;     *      1-x           \          3        5        7          /
<i>535</i>&nbsp;     *
<i>536</i>&nbsp;     * So, compute a Remez approximation of the following function
<i>537</i>&nbsp;     *
<i>538</i>&nbsp;     *  ln ((sqrt(x)+1)/(1-sqrt(x)))  /  x
<i>539</i>&nbsp;     *
<i>540</i>&nbsp;     * This will be an even function with only positive coefficents.
<i>541</i>&nbsp;     * x is in the range [0 - 1/3].
<i>542</i>&nbsp;     *
<i>543</i>&nbsp;     * Transform xi for input to the above function by setting
<i>544</i>&nbsp;     * x = (xi-1)/(xi+1).   Input to the polynomial is x^2, then
<i>545</i>&nbsp;     * the result is multiplied by x.
<i>546</i>&nbsp;     * @param xi number from which log is requested
<i>547</i>&nbsp;     * @return log(xi)
<i>548</i>&nbsp;     */
<i>549</i>&nbsp;    static double[] slowLog(double xi) {
<b class="nc"><i>550</i>&nbsp;        double x[] = new double[2];</b>
<b class="nc"><i>551</i>&nbsp;        double x2[] = new double[2];</b>
<b class="nc"><i>552</i>&nbsp;        double y[] = new double[2];</b>
<b class="nc"><i>553</i>&nbsp;        double a[] = new double[2];</b>
<i>554</i>&nbsp;
<b class="nc"><i>555</i>&nbsp;        split(xi, x);</b>
<i>556</i>&nbsp;
<i>557</i>&nbsp;        /* Set X = (x-1)/(x+1) */
<b class="nc"><i>558</i>&nbsp;        x[0] += 1.0;</b>
<b class="nc"><i>559</i>&nbsp;        resplit(x);</b>
<b class="nc"><i>560</i>&nbsp;        splitReciprocal(x, a);</b>
<b class="nc"><i>561</i>&nbsp;        x[0] -= 2.0;</b>
<b class="nc"><i>562</i>&nbsp;        resplit(x);</b>
<b class="nc"><i>563</i>&nbsp;        splitMult(x, a, y);</b>
<b class="nc"><i>564</i>&nbsp;        x[0] = y[0];</b>
<b class="nc"><i>565</i>&nbsp;        x[1] = y[1];</b>
<i>566</i>&nbsp;
<i>567</i>&nbsp;        /* Square X -&gt; X2*/
<b class="nc"><i>568</i>&nbsp;        splitMult(x, x, x2);</b>
<i>569</i>&nbsp;
<i>570</i>&nbsp;
<i>571</i>&nbsp;        //x[0] -= 1.0;
<i>572</i>&nbsp;        //resplit(x);
<i>573</i>&nbsp;
<b class="nc"><i>574</i>&nbsp;        y[0] = LN_SPLIT_COEF[LN_SPLIT_COEF.length-1][0];</b>
<b class="nc"><i>575</i>&nbsp;        y[1] = LN_SPLIT_COEF[LN_SPLIT_COEF.length-1][1];</b>
<i>576</i>&nbsp;
<b class="nc"><i>577</i>&nbsp;        for (int i = LN_SPLIT_COEF.length-2; i &gt;= 0; i--) {</b>
<b class="nc"><i>578</i>&nbsp;            splitMult(y, x2, a);</b>
<b class="nc"><i>579</i>&nbsp;            y[0] = a[0];</b>
<b class="nc"><i>580</i>&nbsp;            y[1] = a[1];</b>
<b class="nc"><i>581</i>&nbsp;            splitAdd(y, LN_SPLIT_COEF[i], a);</b>
<b class="nc"><i>582</i>&nbsp;            y[0] = a[0];</b>
<b class="nc"><i>583</i>&nbsp;            y[1] = a[1];</b>
<i>584</i>&nbsp;        }
<i>585</i>&nbsp;
<b class="nc"><i>586</i>&nbsp;        splitMult(y, x, a);</b>
<b class="nc"><i>587</i>&nbsp;        y[0] = a[0];</b>
<b class="nc"><i>588</i>&nbsp;        y[1] = a[1];</b>
<i>589</i>&nbsp;
<b class="nc"><i>590</i>&nbsp;        return y;</b>
<i>591</i>&nbsp;    }
<i>592</i>&nbsp;
<i>593</i>&nbsp;
<i>594</i>&nbsp;    /**
<i>595</i>&nbsp;     * Print an array.
<i>596</i>&nbsp;     * @param out text output stream where output should be printed
<i>597</i>&nbsp;     * @param name array name
<i>598</i>&nbsp;     * @param expectedLen expected length of the array
<i>599</i>&nbsp;     * @param array2d array data
<i>600</i>&nbsp;     */
<i>601</i>&nbsp;    static void printarray(PrintStream out, String name, int expectedLen, double[][] array2d) {
<b class="nc"><i>602</i>&nbsp;        out.println(name);</b>
<b class="nc"><i>603</i>&nbsp;        checkLen(expectedLen, array2d.length);</b>
<b class="nc"><i>604</i>&nbsp;        out.println(TABLE_START_DECL + &quot; &quot;);</b>
<b class="nc"><i>605</i>&nbsp;        int i = 0;</b>
<b class="nc"><i>606</i>&nbsp;        for(double[] array : array2d) { // &quot;double array[]&quot; causes PMD parsing error</b>
<b class="nc"><i>607</i>&nbsp;            out.print(&quot;        {&quot;);</b>
<b class="nc"><i>608</i>&nbsp;            for(double d : array) { // assume inner array has very few entries</b>
<b class="nc"><i>609</i>&nbsp;                out.printf(&quot;%-25.25s&quot;, format(d)); // multiple entries per line</b>
<i>610</i>&nbsp;            }
<b class="nc"><i>611</i>&nbsp;            out.println(&quot;}, // &quot; + i++);</b>
<i>612</i>&nbsp;        }
<b class="nc"><i>613</i>&nbsp;        out.println(TABLE_END_DECL);</b>
<i>614</i>&nbsp;    }
<i>615</i>&nbsp;
<i>616</i>&nbsp;    /**
<i>617</i>&nbsp;     * Print an array.
<i>618</i>&nbsp;     * @param out text output stream where output should be printed
<i>619</i>&nbsp;     * @param name array name
<i>620</i>&nbsp;     * @param expectedLen expected length of the array
<i>621</i>&nbsp;     * @param array array data
<i>622</i>&nbsp;     */
<i>623</i>&nbsp;    static void printarray(PrintStream out, String name, int expectedLen, double[] array) {
<b class="nc"><i>624</i>&nbsp;        out.println(name + &quot;=&quot;);</b>
<b class="nc"><i>625</i>&nbsp;        checkLen(expectedLen, array.length);</b>
<b class="nc"><i>626</i>&nbsp;        out.println(TABLE_START_DECL);</b>
<b class="nc"><i>627</i>&nbsp;        for(double d : array){</b>
<b class="nc"><i>628</i>&nbsp;            out.printf(&quot;        %s%n&quot;, format(d)); // one entry per line</b>
<i>629</i>&nbsp;        }
<b class="nc"><i>630</i>&nbsp;        out.println(TABLE_END_DECL);</b>
<i>631</i>&nbsp;    }
<i>632</i>&nbsp;
<i>633</i>&nbsp;    /** Format a double.
<i>634</i>&nbsp;     * @param d double number to format
<i>635</i>&nbsp;     * @return formatted number
<i>636</i>&nbsp;     */
<i>637</i>&nbsp;    static String format(double d) {
<b class="nc"><i>638</i>&nbsp;        if (d != d) {</b>
<b class="nc"><i>639</i>&nbsp;            return &quot;Double.NaN,&quot;;</b>
<i>640</i>&nbsp;        } else {
<b class="nc"><i>641</i>&nbsp;            return ((d &gt;= 0) ? &quot;+&quot; : &quot;&quot;) + Double.toString(d) + &quot;d,&quot;;</b>
<i>642</i>&nbsp;        }
<i>643</i>&nbsp;    }
<i>644</i>&nbsp;
<i>645</i>&nbsp;    /**
<i>646</i>&nbsp;     * Check two lengths are equal.
<i>647</i>&nbsp;     * @param expectedLen expected length
<i>648</i>&nbsp;     * @param actual actual length
<i>649</i>&nbsp;     * @exception DimensionMismatchException if the two lengths are not equal
<i>650</i>&nbsp;     */
<i>651</i>&nbsp;    private static void checkLen(int expectedLen, int actual)
<i>652</i>&nbsp;        throws DimensionMismatchException {
<b class="nc"><i>653</i>&nbsp;        if (expectedLen != actual) {</b>
<b class="nc"><i>654</i>&nbsp;            throw new DimensionMismatchException(actual, expectedLen);</b>
<i>655</i>&nbsp;        }
<i>656</i>&nbsp;    }
<i>657</i>&nbsp;
<i>658</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2019-06-04 09:26</div>
</div>
</body>
</html>
