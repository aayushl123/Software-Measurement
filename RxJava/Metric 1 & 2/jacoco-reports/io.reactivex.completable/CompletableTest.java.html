<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CompletableTest.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">RxJava_2_x$Unnamed.exec</a> &gt; <a href="index.source.html" class="el_package">io.reactivex.completable</a> &gt; <span class="el_source">CompletableTest.java</span></div><h1>CompletableTest.java</h1><pre class="source lang-java linenums">/**
 * Copyright (c) 2016-present, RxJava Contributors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is
 * distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
 * the License for the specific language governing permissions and limitations under the License.
 */

package io.reactivex.completable;

import static org.junit.Assert.*;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;

import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.*;

import org.junit.*;
import org.reactivestreams.*;

import io.reactivex.*;
import io.reactivex.Observable;
import io.reactivex.Observer;
import io.reactivex.disposables.*;
import io.reactivex.exceptions.*;
import io.reactivex.functions.*;
import io.reactivex.internal.disposables.*;
import io.reactivex.internal.functions.Functions;
import io.reactivex.internal.subscriptions.BooleanSubscription;
import io.reactivex.internal.util.ExceptionHelper;
import io.reactivex.observers.TestObserver;
import io.reactivex.plugins.RxJavaPlugins;
import io.reactivex.processors.PublishProcessor;
import io.reactivex.schedulers.*;
import io.reactivex.subjects.PublishSubject;
import io.reactivex.subscribers.TestSubscriber;

/**
 * Test Completable methods and operators.
 */
<span class="fc" id="L47">public class CompletableTest {</span>
    /**
     * Iterable that returns an Iterator that throws in its hasNext method.
     */
<span class="fc" id="L51">    static final class IterableIteratorNextThrows implements Iterable&lt;Completable&gt; {</span>
        @Override
        public Iterator&lt;Completable&gt; iterator() {
<span class="fc" id="L54">            return new Iterator&lt;Completable&gt;() {</span>
                @Override
                public boolean hasNext() {
<span class="fc" id="L57">                    return true;</span>
                }

                @Override
                public Completable next() {
<span class="fc" id="L62">                    throw new TestException();</span>
                }

                @Override
                public void remove() {
                    // TODO Auto-generated method stub

<span class="nc" id="L69">                }</span>
            };
        }
    }

    /**
     * Iterable that returns an Iterator that throws in its next method.
     */
<span class="fc" id="L77">    static final class IterableIteratorHasNextThrows implements Iterable&lt;Completable&gt; {</span>
        @Override
        public Iterator&lt;Completable&gt; iterator() {
<span class="fc" id="L80">            return new Iterator&lt;Completable&gt;() {</span>
                @Override
                public boolean hasNext() {
<span class="fc" id="L83">                    throw new TestException();</span>
                }

                @Override
                public Completable next() {
<span class="nc" id="L88">                    return null;</span>
                }

                @Override
                public void remove() {
                    // TODO Auto-generated method stub

<span class="nc" id="L95">                }</span>
            };
        }
    }

    /**
     * A class containing a completable instance and counts the number of subscribers.
     */
<span class="fc" id="L103">    static final class NormalCompletable extends AtomicInteger {</span>

        private static final long serialVersionUID = 7192337844700923752L;

<span class="fc" id="L107">        public final Completable completable = Completable.unsafeCreate(new CompletableSource() {</span>
            @Override
            public void subscribe(CompletableObserver observer) {
<span class="fc" id="L110">                getAndIncrement();</span>
<span class="fc" id="L111">                EmptyDisposable.complete(observer);</span>
<span class="fc" id="L112">            }</span>
        });

        /**
         * Asserts the given number of subscriptions happened.
         * @param n the expected number of subscriptions
         */
        public void assertSubscriptions(int n) {
<span class="fc" id="L120">            Assert.assertEquals(n, get());</span>
<span class="fc" id="L121">        }</span>
    }

    /**
     * A class containing a completable instance that emits a TestException and counts
     * the number of subscribers.
     */
<span class="fc" id="L128">    static final class ErrorCompletable extends AtomicInteger {</span>

        private static final long serialVersionUID = 7192337844700923752L;

<span class="fc" id="L132">        public final Completable completable = Completable.unsafeCreate(new CompletableSource() {</span>
            @Override
            public void subscribe(CompletableObserver observer) {
<span class="fc" id="L135">                getAndIncrement();</span>
<span class="fc" id="L136">                EmptyDisposable.error(new TestException(), observer);</span>
<span class="fc" id="L137">            }</span>
        });

        /**
         * Asserts the given number of subscriptions happened.
         * @param n the expected number of subscriptions
         */
        public void assertSubscriptions(int n) {
<span class="fc" id="L145">            Assert.assertEquals(n, get());</span>
<span class="fc" id="L146">        }</span>
    }

    /** A normal Completable object. */
<span class="fc" id="L150">    final NormalCompletable normal = new NormalCompletable();</span>

    /** An error Completable object. */
<span class="fc" id="L153">    final ErrorCompletable error = new ErrorCompletable();</span>

    @Test(timeout = 5000)
    public void complete() {
<span class="fc" id="L157">        Completable c = Completable.complete();</span>

<span class="fc" id="L159">        c.blockingAwait();</span>
<span class="fc" id="L160">    }</span>

    @Test(expected = NullPointerException.class)
    public void concatNull() {
<span class="nc" id="L164">        Completable.concatArray((Completable[])null);</span>
<span class="nc" id="L165">    }</span>

    @Test(timeout = 5000)
    public void concatEmpty() {
<span class="fc" id="L169">        Completable c = Completable.concatArray();</span>

<span class="fc" id="L171">        c.blockingAwait();</span>
<span class="fc" id="L172">    }</span>

    @Test(timeout = 5000)
    public void concatSingleSource() {
<span class="fc" id="L176">        Completable c = Completable.concatArray(normal.completable);</span>

<span class="fc" id="L178">        c.blockingAwait();</span>

<span class="fc" id="L180">        normal.assertSubscriptions(1);</span>
<span class="fc" id="L181">    }</span>

    @Test(timeout = 5000, expected = TestException.class)
    public void concatSingleSourceThrows() {
<span class="fc" id="L185">        Completable c = Completable.concatArray(error.completable);</span>

<span class="nc" id="L187">        c.blockingAwait();</span>
<span class="nc" id="L188">    }</span>

    @Test(timeout = 5000)
    public void concatMultipleSources() {
<span class="fc" id="L192">        Completable c = Completable.concatArray(normal.completable, normal.completable, normal.completable);</span>

<span class="fc" id="L194">        c.blockingAwait();</span>

<span class="fc" id="L196">        normal.assertSubscriptions(3);</span>
<span class="fc" id="L197">    }</span>

    @Test(timeout = 5000, expected = TestException.class)
    public void concatMultipleOneThrows() {
<span class="fc" id="L201">        Completable c = Completable.concatArray(normal.completable, error.completable, normal.completable);</span>

<span class="nc" id="L203">        c.blockingAwait();</span>
<span class="nc" id="L204">    }</span>

    @Test(timeout = 5000, expected = NullPointerException.class)
    public void concatMultipleOneIsNull() {
<span class="fc" id="L208">        Completable c = Completable.concatArray(normal.completable, null);</span>

<span class="nc" id="L210">        c.blockingAwait();</span>
<span class="nc" id="L211">    }</span>

    @Test(timeout = 5000)
    public void concatIterableEmpty() {
<span class="fc" id="L215">        Completable c = Completable.concat(Collections.&lt;Completable&gt;emptyList());</span>

<span class="fc" id="L217">        c.blockingAwait();</span>
<span class="fc" id="L218">    }</span>

    @Test(expected = NullPointerException.class)
    public void concatIterableNull() {
<span class="nc" id="L222">        Completable.concat((Iterable&lt;Completable&gt;)null);</span>
<span class="nc" id="L223">    }</span>

    @Test(timeout = 5000, expected = NullPointerException.class)
    public void concatIterableIteratorNull() {
<span class="fc" id="L227">        Completable c = Completable.concat(new Iterable&lt;Completable&gt;() {</span>
            @Override
            public Iterator&lt;Completable&gt; iterator() {
<span class="fc" id="L230">                return null;</span>
            }
        });

<span class="nc" id="L234">        c.blockingAwait();</span>
<span class="nc" id="L235">    }</span>

    @Test(timeout = 5000, expected = NullPointerException.class)
    public void concatIterableWithNull() {
<span class="fc" id="L239">        Completable c = Completable.concat(Arrays.asList(normal.completable, (Completable)null));</span>

<span class="nc" id="L241">        c.blockingAwait();</span>
<span class="nc" id="L242">    }</span>

    @Test(timeout = 5000)
    public void concatIterableSingle() {
<span class="fc" id="L246">        Completable c = Completable.concat(Collections.singleton(normal.completable));</span>

<span class="fc" id="L248">        c.blockingAwait();</span>

<span class="fc" id="L250">        normal.assertSubscriptions(1);</span>
<span class="fc" id="L251">    }</span>

    @Test(timeout = 5000)
    public void concatIterableMany() {
<span class="fc" id="L255">        Completable c = Completable.concat(Arrays.asList(normal.completable, normal.completable, normal.completable));</span>

<span class="fc" id="L257">        c.blockingAwait();</span>

<span class="fc" id="L259">        normal.assertSubscriptions(3);</span>
<span class="fc" id="L260">    }</span>

    @Test(timeout = 5000, expected = TestException.class)
    public void concatIterableOneThrows() {
<span class="fc" id="L264">        Completable c = Completable.concat(Collections.singleton(error.completable));</span>

<span class="nc" id="L266">        c.blockingAwait();</span>
<span class="nc" id="L267">    }</span>

    @Test(timeout = 5000, expected = TestException.class)
    public void concatIterableManyOneThrows() {
<span class="fc" id="L271">        Completable c = Completable.concat(Arrays.asList(normal.completable, error.completable));</span>

<span class="nc" id="L273">        c.blockingAwait();</span>
<span class="nc" id="L274">    }</span>

    @Test(expected = TestException.class)
    public void concatIterableIterableThrows() {
<span class="fc" id="L278">        Completable c = Completable.concat(new Iterable&lt;Completable&gt;() {</span>
            @Override
            public Iterator&lt;Completable&gt; iterator() {
<span class="fc" id="L281">                throw new TestException();</span>
            }
        });

<span class="nc" id="L285">        c.blockingAwait();</span>
<span class="nc" id="L286">    }</span>

    @Test(expected = TestException.class)
    public void concatIterableIteratorHasNextThrows() {
<span class="fc" id="L290">        Completable c = Completable.concat(new IterableIteratorHasNextThrows());</span>

<span class="nc" id="L292">        c.blockingAwait();</span>
<span class="nc" id="L293">    }</span>

    @Test(expected = TestException.class)
    public void concatIterableIteratorNextThrows() {
<span class="fc" id="L297">        Completable c = Completable.concat(new IterableIteratorNextThrows());</span>

<span class="nc" id="L299">        c.blockingAwait();</span>
<span class="nc" id="L300">    }</span>

    @Test(timeout = 5000)
    public void concatObservableEmpty() {
<span class="fc" id="L304">        Completable c = Completable.concat(Flowable.&lt;Completable&gt;empty());</span>

<span class="fc" id="L306">        c.blockingAwait();</span>
<span class="fc" id="L307">    }</span>

    @Test(timeout = 5000, expected = TestException.class)
    public void concatObservableError() {
<span class="fc" id="L311">        Completable c = Completable.concat(Flowable.&lt;Completable&gt;error(new Callable&lt;Throwable&gt;() {</span>
            @Override
            public Throwable call() {
<span class="fc" id="L314">                return new TestException();</span>
            }
        }));

<span class="nc" id="L318">        c.blockingAwait();</span>
<span class="nc" id="L319">    }</span>

    @Test(timeout = 5000)
    public void concatObservableSingle() {
<span class="fc" id="L323">        Completable c = Completable.concat(Flowable.just(normal.completable));</span>

<span class="fc" id="L325">        c.blockingAwait();</span>

<span class="fc" id="L327">        normal.assertSubscriptions(1);</span>
<span class="fc" id="L328">    }</span>

    @Test(timeout = 5000, expected = TestException.class)
    public void concatObservableSingleThrows() {
<span class="fc" id="L332">        Completable c = Completable.concat(Flowable.just(error.completable));</span>

<span class="nc" id="L334">        c.blockingAwait();</span>
<span class="nc" id="L335">    }</span>

    @Test(timeout = 5000)
    public void concatObservableMany() {
<span class="fc" id="L339">        Completable c = Completable.concat(Flowable.just(normal.completable).repeat(3));</span>

<span class="fc" id="L341">        c.blockingAwait();</span>

<span class="fc" id="L343">        normal.assertSubscriptions(3);</span>
<span class="fc" id="L344">    }</span>

    @Test(timeout = 5000, expected = TestException.class)
    public void concatObservableManyOneThrows() {
<span class="fc" id="L348">        Completable c = Completable.concat(Flowable.just(normal.completable, error.completable));</span>

<span class="nc" id="L350">        c.blockingAwait();</span>
<span class="nc" id="L351">    }</span>

    @Test(timeout = 5000)
    public void concatObservablePrefetch() {
<span class="fc" id="L355">        final List&lt;Long&gt; requested = new ArrayList&lt;Long&gt;();</span>
<span class="fc" id="L356">        Flowable&lt;Completable&gt; cs = Flowable</span>
<span class="fc" id="L357">                .just(normal.completable)</span>
<span class="fc" id="L358">                .repeat(10)</span>
<span class="fc" id="L359">                .doOnRequest(new LongConsumer() {</span>
                    @Override
                    public void accept(long v) {
<span class="fc" id="L362">                        requested.add(v);</span>
<span class="fc" id="L363">                    }</span>
                });

<span class="fc" id="L366">        Completable c = Completable.concat(cs, 5);</span>

<span class="fc" id="L368">        c.blockingAwait();</span>

<span class="fc" id="L370">        Assert.assertEquals(Arrays.asList(5L, 4L, 4L), requested);</span>
<span class="fc" id="L371">    }</span>

    @Test(expected = NullPointerException.class)
    public void createNull() {
<span class="nc" id="L375">        Completable.unsafeCreate(null);</span>
<span class="nc" id="L376">    }</span>

    @Test(timeout = 5000, expected = NullPointerException.class)
    public void createOnSubscribeThrowsNPE() {
<span class="fc" id="L380">        Completable c = Completable.unsafeCreate(new CompletableSource() {</span>
            @Override
<span class="fc" id="L382">            public void subscribe(CompletableObserver observer) { throw new NullPointerException(); }</span>
        });

<span class="nc" id="L385">        c.blockingAwait();</span>
<span class="nc" id="L386">    }</span>

    @Test(timeout = 5000)
    public void createOnSubscribeThrowsRuntimeException() {
<span class="fc" id="L390">        List&lt;Throwable&gt; errors = TestHelper.trackPluginErrors();</span>
        try {
<span class="fc" id="L392">            Completable c = Completable.unsafeCreate(new CompletableSource() {</span>
                @Override
                public void subscribe(CompletableObserver observer) {
<span class="fc" id="L395">                    throw new TestException();</span>
                }
            });

<span class="nc" id="L399">            c.blockingAwait();</span>

<span class="nc" id="L401">            Assert.fail(&quot;Did not throw exception&quot;);</span>
<span class="fc" id="L402">        } catch (NullPointerException ex) {</span>
<span class="pc bpc" id="L403" title="1 of 2 branches missed.">            if (!(ex.getCause() instanceof TestException)) {</span>
<span class="nc" id="L404">                ex.printStackTrace();</span>
<span class="nc" id="L405">                Assert.fail(&quot;Did not wrap the TestException but it returned: &quot; + ex);</span>
            }

<span class="fc" id="L408">            TestHelper.assertUndeliverable(errors, 0, TestException.class);</span>
        } finally {
<span class="fc" id="L410">            RxJavaPlugins.reset();</span>
        }
<span class="fc" id="L412">    }</span>

    @Test(timeout = 5000)
    public void defer() {
<span class="fc" id="L416">        Completable c = Completable.defer(new Callable&lt;Completable&gt;() {</span>
            @Override
            public Completable call() {
<span class="fc" id="L419">                return normal.completable;</span>
            }
        });

<span class="fc" id="L423">        normal.assertSubscriptions(0);</span>

<span class="fc" id="L425">        c.blockingAwait();</span>

<span class="fc" id="L427">        normal.assertSubscriptions(1);</span>
<span class="fc" id="L428">    }</span>

    @Test(expected = NullPointerException.class)
    public void deferNull() {
<span class="nc" id="L432">        Completable.defer(null);</span>
<span class="nc" id="L433">    }</span>

    @Test(timeout = 5000, expected = NullPointerException.class)
    public void deferReturnsNull() {
<span class="fc" id="L437">        Completable c = Completable.defer(new Callable&lt;Completable&gt;() {</span>
            @Override
            public Completable call() {
<span class="fc" id="L440">                return null;</span>
            }
        });

<span class="nc" id="L444">        c.blockingAwait();</span>
<span class="nc" id="L445">    }</span>

    @Test(timeout = 5000, expected = TestException.class)
    public void deferFunctionThrows() {
<span class="fc" id="L449">        Completable c = Completable.defer(new Callable&lt;Completable&gt;() {</span>
            @Override
<span class="fc" id="L451">            public Completable call() { throw new TestException(); }</span>
        });

<span class="nc" id="L454">        c.blockingAwait();</span>
<span class="nc" id="L455">    }</span>

    @Test(timeout = 5000, expected = TestException.class)
    public void deferErrorSource() {
<span class="fc" id="L459">        Completable c = Completable.defer(new Callable&lt;Completable&gt;() {</span>
            @Override
            public Completable call() {
<span class="fc" id="L462">                return error.completable;</span>
            }
        });

<span class="nc" id="L466">        c.blockingAwait();</span>
<span class="nc" id="L467">    }</span>

    @Test(expected = NullPointerException.class)
    public void errorSupplierNull() {
<span class="nc" id="L471">        Completable.error((Callable&lt;Throwable&gt;)null);</span>
<span class="nc" id="L472">    }</span>

    @Test(timeout = 5000, expected = TestException.class)
    public void errorSupplierNormal() {
<span class="fc" id="L476">        Completable c = Completable.error(new Callable&lt;Throwable&gt;() {</span>
            @Override
            public Throwable call() {
<span class="fc" id="L479">                return new TestException();</span>
            }
        });

<span class="nc" id="L483">        c.blockingAwait();</span>
<span class="nc" id="L484">    }</span>

    @Test(timeout = 5000, expected = NullPointerException.class)
    public void errorSupplierReturnsNull() {
<span class="fc" id="L488">        Completable c = Completable.error(new Callable&lt;Throwable&gt;() {</span>
            @Override
            public Throwable call() {
<span class="fc" id="L491">                return null;</span>
            }
        });

<span class="nc" id="L495">        c.blockingAwait();</span>
<span class="nc" id="L496">    }</span>

    @Test(timeout = 5000, expected = TestException.class)
    public void errorSupplierThrows() {
<span class="fc" id="L500">        Completable c = Completable.error(new Callable&lt;Throwable&gt;() {</span>
            @Override
<span class="fc" id="L502">            public Throwable call() { throw new TestException(); }</span>
        });

<span class="nc" id="L505">        c.blockingAwait();</span>
<span class="nc" id="L506">    }</span>

    @Test(expected = NullPointerException.class)
    public void errorNull() {
<span class="nc" id="L510">        Completable.error((Throwable)null);</span>
<span class="nc" id="L511">    }</span>

    @Test(timeout = 5000, expected = TestException.class)
    public void errorNormal() {
<span class="fc" id="L515">        Completable c = Completable.error(new TestException());</span>

<span class="nc" id="L517">        c.blockingAwait();</span>
<span class="nc" id="L518">    }</span>

    @Test(expected = NullPointerException.class)
    public void fromCallableNull() {
<span class="nc" id="L522">        Completable.fromCallable(null);</span>
<span class="nc" id="L523">    }</span>

    @Test(timeout = 5000)
    public void fromCallableNormal() {
<span class="fc" id="L527">        final AtomicInteger calls = new AtomicInteger();</span>

<span class="fc" id="L529">        Completable c = Completable.fromCallable(new Callable&lt;Object&gt;() {</span>
            @Override
            public Object call() throws Exception {
<span class="fc" id="L532">                return calls.getAndIncrement();</span>
            }
        });

<span class="fc" id="L536">        c.blockingAwait();</span>

<span class="fc" id="L538">        Assert.assertEquals(1, calls.get());</span>
<span class="fc" id="L539">    }</span>

    @Test(timeout = 5000, expected = TestException.class)
    public void fromCallableThrows() {
<span class="fc" id="L543">        Completable c = Completable.fromCallable(new Callable&lt;Object&gt;() {</span>
            @Override
<span class="fc" id="L545">            public Object call() throws Exception { throw new TestException(); }</span>
        });

<span class="nc" id="L548">        c.blockingAwait();</span>
<span class="nc" id="L549">    }</span>

    @Test(expected = NullPointerException.class)
    public void fromFlowableNull() {
<span class="nc" id="L553">        Completable.fromPublisher(null);</span>
<span class="nc" id="L554">    }</span>

    @Test(timeout = 5000)
    public void fromFlowableEmpty() {
<span class="fc" id="L558">        Completable c = Completable.fromPublisher(Flowable.empty());</span>

<span class="fc" id="L560">        c.blockingAwait();</span>
<span class="fc" id="L561">    }</span>

    @Test(timeout = 5000)
    public void fromFlowableSome() {
<span class="fc bfc" id="L565" title="All 2 branches covered.">        for (int n = 1; n &lt; 10000; n *= 10) {</span>
<span class="fc" id="L566">            Completable c = Completable.fromPublisher(Flowable.range(1, n));</span>

<span class="fc" id="L568">            c.blockingAwait();</span>
        }
<span class="fc" id="L570">    }</span>

    @Test(timeout = 5000, expected = TestException.class)
    public void fromFlowableError() {
<span class="fc" id="L574">        Completable c = Completable.fromPublisher(Flowable.error(new Callable&lt;Throwable&gt;() {</span>
            @Override
            public Throwable call() {
<span class="fc" id="L577">                return new TestException();</span>
            }
        }));

<span class="nc" id="L581">        c.blockingAwait();</span>
<span class="nc" id="L582">    }</span>

    @Test(expected = NullPointerException.class)
    public void fromObservableNull() {
<span class="nc" id="L586">        Completable.fromObservable(null);</span>
<span class="nc" id="L587">    }</span>

    @Test(timeout = 5000)
    public void fromObservableEmpty() {
<span class="fc" id="L591">        Completable c = Completable.fromObservable(Observable.empty());</span>

<span class="fc" id="L593">        c.blockingAwait();</span>
<span class="fc" id="L594">    }</span>

    @Test(timeout = 5000)
    public void fromObservableSome() {
<span class="fc bfc" id="L598" title="All 2 branches covered.">        for (int n = 1; n &lt; 10000; n *= 10) {</span>
<span class="fc" id="L599">            Completable c = Completable.fromObservable(Observable.range(1, n));</span>

<span class="fc" id="L601">            c.blockingAwait();</span>
        }
<span class="fc" id="L603">    }</span>

    @Test(timeout = 5000, expected = TestException.class)
    public void fromObservableError() {
<span class="fc" id="L607">        Completable c = Completable.fromObservable(Observable.error(new Callable&lt;Throwable&gt;() {</span>
            @Override
            public Throwable call() {
<span class="fc" id="L610">                return new TestException();</span>
            }
        }));

<span class="nc" id="L614">        c.blockingAwait();</span>
<span class="nc" id="L615">    }</span>

    @Test(expected = NullPointerException.class)
    public void fromActionNull() {
<span class="nc" id="L619">        Completable.fromAction(null);</span>
<span class="nc" id="L620">    }</span>

    @Test(timeout = 5000)
    public void fromActionNormal() {
<span class="fc" id="L624">        final AtomicInteger calls = new AtomicInteger();</span>

<span class="fc" id="L626">        Completable c = Completable.fromAction(new Action() {</span>
            @Override
            public void run() {
<span class="fc" id="L629">                calls.getAndIncrement();</span>
<span class="fc" id="L630">            }</span>
        });

<span class="fc" id="L633">        c.blockingAwait();</span>

<span class="fc" id="L635">        Assert.assertEquals(1, calls.get());</span>
<span class="fc" id="L636">    }</span>

    @Test(timeout = 5000, expected = TestException.class)
    public void fromActionThrows() {
<span class="fc" id="L640">        Completable c = Completable.fromAction(new Action() {</span>
            @Override
<span class="fc" id="L642">            public void run() { throw new TestException(); }</span>
        });

<span class="nc" id="L645">        c.blockingAwait();</span>
<span class="nc" id="L646">    }</span>

    @Test(expected = NullPointerException.class)
    public void fromSingleNull() {
<span class="nc" id="L650">        Completable.fromSingle(null);</span>
<span class="nc" id="L651">    }</span>

    @Test(timeout = 5000)
    public void fromSingleNormal() {
<span class="fc" id="L655">        Completable c = Completable.fromSingle(Single.just(1));</span>

<span class="fc" id="L657">        c.blockingAwait();</span>
<span class="fc" id="L658">    }</span>

    @Test(timeout = 5000, expected = TestException.class)
    public void fromSingleThrows() {
<span class="fc" id="L662">        Completable c = Completable.fromSingle(Single.error(new Callable&lt;Throwable&gt;() {</span>
            @Override
            public Throwable call() {
<span class="fc" id="L665">                return new TestException();</span>
            }
        }));

<span class="nc" id="L669">        c.blockingAwait();</span>
<span class="nc" id="L670">    }</span>

    @Test(expected = NullPointerException.class)
    public void mergeNull() {
<span class="nc" id="L674">        Completable.mergeArray((Completable[])null);</span>
<span class="nc" id="L675">    }</span>

    @Test(timeout = 5000)
    public void mergeEmpty() {
<span class="fc" id="L679">        Completable c = Completable.mergeArray();</span>

<span class="fc" id="L681">        c.blockingAwait();</span>
<span class="fc" id="L682">    }</span>

    @Test(timeout = 5000)
    public void mergeSingleSource() {
<span class="fc" id="L686">        Completable c = Completable.mergeArray(normal.completable);</span>

<span class="fc" id="L688">        c.blockingAwait();</span>

<span class="fc" id="L690">        normal.assertSubscriptions(1);</span>
<span class="fc" id="L691">    }</span>

    @Test(timeout = 5000, expected = TestException.class)
    public void mergeSingleSourceThrows() {
<span class="fc" id="L695">        Completable c = Completable.mergeArray(error.completable);</span>

<span class="nc" id="L697">        c.blockingAwait();</span>
<span class="nc" id="L698">    }</span>

    @Test(timeout = 5000)
    public void mergeMultipleSources() {
<span class="fc" id="L702">        Completable c = Completable.mergeArray(normal.completable, normal.completable, normal.completable);</span>

<span class="fc" id="L704">        c.blockingAwait();</span>

<span class="fc" id="L706">        normal.assertSubscriptions(3);</span>
<span class="fc" id="L707">    }</span>

    @Test(timeout = 5000, expected = TestException.class)
    public void mergeMultipleOneThrows() {
<span class="fc" id="L711">        Completable c = Completable.mergeArray(normal.completable, error.completable, normal.completable);</span>

<span class="nc" id="L713">        c.blockingAwait();</span>
<span class="nc" id="L714">    }</span>

    @Test(timeout = 5000, expected = NullPointerException.class)
    public void mergeMultipleOneIsNull() {
<span class="fc" id="L718">        Completable c = Completable.mergeArray(normal.completable, null);</span>

<span class="nc" id="L720">        c.blockingAwait();</span>
<span class="nc" id="L721">    }</span>

    @Test(timeout = 5000)
    public void mergeIterableEmpty() {
<span class="fc" id="L725">        Completable c = Completable.merge(Collections.&lt;Completable&gt;emptyList());</span>

<span class="fc" id="L727">        c.blockingAwait();</span>
<span class="fc" id="L728">    }</span>

    @Test(expected = NullPointerException.class)
    public void mergeIterableNull() {
<span class="nc" id="L732">        Completable.merge((Iterable&lt;Completable&gt;)null);</span>
<span class="nc" id="L733">    }</span>

    @Test(timeout = 5000, expected = NullPointerException.class)
    public void mergeIterableIteratorNull() {
<span class="fc" id="L737">        Completable c = Completable.merge(new Iterable&lt;Completable&gt;() {</span>
            @Override
            public Iterator&lt;Completable&gt; iterator() {
<span class="fc" id="L740">                return null;</span>
            }
        });

<span class="nc" id="L744">        c.blockingAwait();</span>
<span class="nc" id="L745">    }</span>

    @Test(timeout = 5000, expected = NullPointerException.class)
    public void mergeIterableWithNull() {
<span class="fc" id="L749">        Completable c = Completable.merge(Arrays.asList(normal.completable, (Completable)null));</span>

<span class="nc" id="L751">        c.blockingAwait();</span>
<span class="nc" id="L752">    }</span>

    @Test(timeout = 5000)
    public void mergeIterableSingle() {
<span class="fc" id="L756">        Completable c = Completable.merge(Collections.singleton(normal.completable));</span>

<span class="fc" id="L758">        c.blockingAwait();</span>

<span class="fc" id="L760">        normal.assertSubscriptions(1);</span>
<span class="fc" id="L761">    }</span>

    @Test(timeout = 5000)
    public void mergeIterableMany() {
<span class="fc" id="L765">        Completable c = Completable.merge(Arrays.asList(normal.completable, normal.completable, normal.completable));</span>

<span class="fc" id="L767">        c.blockingAwait();</span>

<span class="fc" id="L769">        normal.assertSubscriptions(3);</span>
<span class="fc" id="L770">    }</span>

    @Test(timeout = 5000, expected = TestException.class)
    public void mergeIterableOneThrows() {
<span class="fc" id="L774">        Completable c = Completable.merge(Collections.singleton(error.completable));</span>

<span class="nc" id="L776">        c.blockingAwait();</span>
<span class="nc" id="L777">    }</span>

    @Test(timeout = 5000, expected = TestException.class)
    public void mergeIterableManyOneThrows() {
<span class="fc" id="L781">        Completable c = Completable.merge(Arrays.asList(normal.completable, error.completable));</span>

<span class="nc" id="L783">        c.blockingAwait();</span>
<span class="nc" id="L784">    }</span>

    @Test(expected = TestException.class)
    public void mergeIterableIterableThrows() {
<span class="fc" id="L788">        Completable c = Completable.merge(new Iterable&lt;Completable&gt;() {</span>
            @Override
            public Iterator&lt;Completable&gt; iterator() {
<span class="fc" id="L791">                throw new TestException();</span>
            }
        });

<span class="nc" id="L795">        c.blockingAwait();</span>
<span class="nc" id="L796">    }</span>

    @Test(expected = TestException.class)
    public void mergeIterableIteratorHasNextThrows() {
<span class="fc" id="L800">        Completable c = Completable.merge(new IterableIteratorHasNextThrows());</span>

<span class="nc" id="L802">        c.blockingAwait();</span>
<span class="nc" id="L803">    }</span>

    @Test(expected = TestException.class)
    public void mergeIterableIteratorNextThrows() {
<span class="fc" id="L807">        Completable c = Completable.merge(new IterableIteratorNextThrows());</span>

<span class="nc" id="L809">        c.blockingAwait();</span>
<span class="nc" id="L810">    }</span>

    @Test(timeout = 5000)
    public void mergeObservableEmpty() {
<span class="fc" id="L814">        Completable c = Completable.merge(Flowable.&lt;Completable&gt;empty());</span>

<span class="fc" id="L816">        c.blockingAwait();</span>
<span class="fc" id="L817">    }</span>

    @Test(timeout = 5000, expected = TestException.class)
    public void mergeObservableError() {
<span class="fc" id="L821">        Completable c = Completable.merge(Flowable.&lt;Completable&gt;error(new Callable&lt;Throwable&gt;() {</span>
            @Override
            public Throwable call() {
<span class="fc" id="L824">                return new TestException();</span>
            }
        }));

<span class="nc" id="L828">        c.blockingAwait();</span>
<span class="nc" id="L829">    }</span>

    @Test(timeout = 5000)
    public void mergeObservableSingle() {
<span class="fc" id="L833">        Completable c = Completable.merge(Flowable.just(normal.completable));</span>

<span class="fc" id="L835">        c.blockingAwait();</span>

<span class="fc" id="L837">        normal.assertSubscriptions(1);</span>
<span class="fc" id="L838">    }</span>

    @Test(timeout = 5000, expected = TestException.class)
    public void mergeObservableSingleThrows() {
<span class="fc" id="L842">        Completable c = Completable.merge(Flowable.just(error.completable));</span>

<span class="nc" id="L844">        c.blockingAwait();</span>
<span class="nc" id="L845">    }</span>

    @Test(timeout = 5000)
    public void mergeObservableMany() {
<span class="fc" id="L849">        Completable c = Completable.merge(Flowable.just(normal.completable).repeat(3));</span>

<span class="fc" id="L851">        c.blockingAwait();</span>

<span class="fc" id="L853">        normal.assertSubscriptions(3);</span>
<span class="fc" id="L854">    }</span>

    @Test(timeout = 5000, expected = TestException.class)
    public void mergeObservableManyOneThrows() {
<span class="fc" id="L858">        Completable c = Completable.merge(Flowable.just(normal.completable, error.completable));</span>

<span class="nc" id="L860">        c.blockingAwait();</span>
<span class="nc" id="L861">    }</span>

    @Test(timeout = 5000)
    public void mergeObservableMaxConcurrent() {
<span class="fc" id="L865">        final List&lt;Long&gt; requested = new ArrayList&lt;Long&gt;();</span>
<span class="fc" id="L866">        Flowable&lt;Completable&gt; cs = Flowable</span>
<span class="fc" id="L867">                .just(normal.completable)</span>
<span class="fc" id="L868">                .repeat(10)</span>
<span class="fc" id="L869">                .doOnRequest(new LongConsumer() {</span>
                    @Override
                    public void accept(long v) {
<span class="fc" id="L872">                        requested.add(v);</span>
<span class="fc" id="L873">                    }</span>
                });

<span class="fc" id="L876">        Completable c = Completable.merge(cs, 5);</span>

<span class="fc" id="L878">        c.blockingAwait();</span>

        // FIXME this request pattern looks odd because all 10 completions trigger 1 requests
<span class="fc" id="L881">        Assert.assertEquals(Arrays.asList(5L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L), requested);</span>
<span class="fc" id="L882">    }</span>

    @Test(expected = NullPointerException.class)
    public void mergeDelayErrorNull() {
<span class="nc" id="L886">        Completable.mergeArrayDelayError((Completable[])null);</span>
<span class="nc" id="L887">    }</span>

    @Test(timeout = 5000)
    public void mergeDelayErrorEmpty() {
<span class="fc" id="L891">        Completable c = Completable.mergeArrayDelayError();</span>

<span class="fc" id="L893">        c.blockingAwait();</span>
<span class="fc" id="L894">    }</span>

    @Test(timeout = 5000)
    public void mergeDelayErrorSingleSource() {
<span class="fc" id="L898">        Completable c = Completable.mergeArrayDelayError(normal.completable);</span>

<span class="fc" id="L900">        c.blockingAwait();</span>

<span class="fc" id="L902">        normal.assertSubscriptions(1);</span>
<span class="fc" id="L903">    }</span>

    @Test(timeout = 5000, expected = TestException.class)
    public void mergeDelayErrorSingleSourceThrows() {
<span class="fc" id="L907">        Completable c = Completable.mergeArrayDelayError(error.completable);</span>

<span class="nc" id="L909">        c.blockingAwait();</span>
<span class="nc" id="L910">    }</span>

    @Test(timeout = 5000)
    public void mergeDelayErrorMultipleSources() {
<span class="fc" id="L914">        Completable c = Completable.mergeArrayDelayError(normal.completable, normal.completable, normal.completable);</span>

<span class="fc" id="L916">        c.blockingAwait();</span>

<span class="fc" id="L918">        normal.assertSubscriptions(3);</span>
<span class="fc" id="L919">    }</span>

    @Test(timeout = 5000)
    public void mergeDelayErrorMultipleOneThrows() {
<span class="fc" id="L923">        Completable c = Completable.mergeArrayDelayError(normal.completable, error.completable, normal.completable);</span>

        try {
<span class="nc" id="L926">            c.blockingAwait();</span>
<span class="fc" id="L927">        } catch (TestException ex) {</span>
<span class="fc" id="L928">            normal.assertSubscriptions(2);</span>
<span class="nc" id="L929">        }</span>
<span class="fc" id="L930">    }</span>

    @Test(timeout = 5000, expected = NullPointerException.class)
    public void mergeDelayErrorMultipleOneIsNull() {
<span class="fc" id="L934">        Completable c = Completable.mergeArrayDelayError(normal.completable, null);</span>

<span class="nc" id="L936">        c.blockingAwait();</span>
<span class="nc" id="L937">    }</span>

    @Test(timeout = 5000)
    public void mergeDelayErrorIterableEmpty() {
<span class="fc" id="L941">        Completable c = Completable.mergeDelayError(Collections.&lt;Completable&gt;emptyList());</span>

<span class="fc" id="L943">        c.blockingAwait();</span>
<span class="fc" id="L944">    }</span>

    @Test(expected = NullPointerException.class)
    public void mergeDelayErrorIterableNull() {
<span class="nc" id="L948">        Completable.mergeDelayError((Iterable&lt;Completable&gt;)null);</span>
<span class="nc" id="L949">    }</span>

    @Test(timeout = 5000, expected = NullPointerException.class)
    public void mergeDelayErrorIterableIteratorNull() {
<span class="fc" id="L953">        Completable c = Completable.mergeDelayError(new Iterable&lt;Completable&gt;() {</span>
            @Override
            public Iterator&lt;Completable&gt; iterator() {
<span class="fc" id="L956">                return null;</span>
            }
        });

<span class="nc" id="L960">        c.blockingAwait();</span>
<span class="nc" id="L961">    }</span>

    @Test(timeout = 5000, expected = NullPointerException.class)
    public void mergeDelayErrorIterableWithNull() {
<span class="fc" id="L965">        Completable c = Completable.mergeDelayError(Arrays.asList(normal.completable, (Completable)null));</span>

<span class="nc" id="L967">        c.blockingAwait();</span>
<span class="nc" id="L968">    }</span>

    @Test(timeout = 5000)
    public void mergeDelayErrorIterableSingle() {
<span class="fc" id="L972">        Completable c = Completable.mergeDelayError(Collections.singleton(normal.completable));</span>

<span class="fc" id="L974">        c.blockingAwait();</span>

<span class="fc" id="L976">        normal.assertSubscriptions(1);</span>
<span class="fc" id="L977">    }</span>

    @Test(timeout = 5000)
    public void mergeDelayErrorIterableMany() {
<span class="fc" id="L981">        Completable c = Completable.mergeDelayError(Arrays.asList(normal.completable, normal.completable, normal.completable));</span>

<span class="fc" id="L983">        c.blockingAwait();</span>

<span class="fc" id="L985">        normal.assertSubscriptions(3);</span>
<span class="fc" id="L986">    }</span>

    @Test(timeout = 5000, expected = TestException.class)
    public void mergeDelayErrorIterableOneThrows() {
<span class="fc" id="L990">        Completable c = Completable.mergeDelayError(Collections.singleton(error.completable));</span>

<span class="nc" id="L992">        c.blockingAwait();</span>
<span class="nc" id="L993">    }</span>

    @Test(timeout = 5000)
    public void mergeDelayErrorIterableManyOneThrows() {
<span class="fc" id="L997">        Completable c = Completable.mergeDelayError(Arrays.asList(normal.completable, error.completable, normal.completable));</span>

        try {
<span class="nc" id="L1000">            c.blockingAwait();</span>
<span class="fc" id="L1001">        } catch (TestException ex) {</span>
<span class="fc" id="L1002">            normal.assertSubscriptions(2);</span>
<span class="nc" id="L1003">        }</span>
<span class="fc" id="L1004">    }</span>

    @Test(expected = TestException.class)
    public void mergeDelayErrorIterableIterableThrows() {
<span class="fc" id="L1008">        Completable c = Completable.mergeDelayError(new Iterable&lt;Completable&gt;() {</span>
            @Override
            public Iterator&lt;Completable&gt; iterator() {
<span class="fc" id="L1011">                throw new TestException();</span>
            }
        });

<span class="nc" id="L1015">        c.blockingAwait();</span>
<span class="nc" id="L1016">    }</span>

    @Test(expected = TestException.class)
    public void mergeDelayErrorIterableIteratorHasNextThrows() {
<span class="fc" id="L1020">        Completable c = Completable.mergeDelayError(new IterableIteratorHasNextThrows());</span>

<span class="nc" id="L1022">        c.blockingAwait();</span>
<span class="nc" id="L1023">    }</span>

    @Test(expected = TestException.class)
    public void mergeDelayErrorIterableIteratorNextThrows() {
<span class="fc" id="L1027">        Completable c = Completable.mergeDelayError(new IterableIteratorNextThrows());</span>

<span class="nc" id="L1029">        c.blockingAwait();</span>
<span class="nc" id="L1030">    }</span>

    @Test(timeout = 5000)
    public void mergeDelayErrorObservableEmpty() {
<span class="fc" id="L1034">        Completable c = Completable.mergeDelayError(Flowable.&lt;Completable&gt;empty());</span>

<span class="fc" id="L1036">        c.blockingAwait();</span>
<span class="fc" id="L1037">    }</span>

    @Test(timeout = 5000, expected = TestException.class)
    public void mergeDelayErrorObservableError() {
<span class="fc" id="L1041">        Completable c = Completable.mergeDelayError(Flowable.&lt;Completable&gt;error(new Callable&lt;Throwable&gt;() {</span>
            @Override
            public Throwable call() {
<span class="fc" id="L1044">                return new TestException();</span>
            }
        }));

<span class="nc" id="L1048">        c.blockingAwait();</span>
<span class="nc" id="L1049">    }</span>

    @Test(timeout = 5000)
    public void mergeDelayErrorObservableSingle() {
<span class="fc" id="L1053">        Completable c = Completable.mergeDelayError(Flowable.just(normal.completable));</span>

<span class="fc" id="L1055">        c.blockingAwait();</span>

<span class="fc" id="L1057">        normal.assertSubscriptions(1);</span>
<span class="fc" id="L1058">    }</span>

    @Test(timeout = 5000, expected = TestException.class)
    public void mergeDelayErrorObservableSingleThrows() {
<span class="fc" id="L1062">        Completable c = Completable.mergeDelayError(Flowable.just(error.completable));</span>

<span class="nc" id="L1064">        c.blockingAwait();</span>
<span class="nc" id="L1065">    }</span>

    @Test(timeout = 5000)
    public void mergeDelayErrorObservableMany() {
<span class="fc" id="L1069">        Completable c = Completable.mergeDelayError(Flowable.just(normal.completable).repeat(3));</span>

<span class="fc" id="L1071">        c.blockingAwait();</span>

<span class="fc" id="L1073">        normal.assertSubscriptions(3);</span>
<span class="fc" id="L1074">    }</span>

    @Test(timeout = 5000, expected = TestException.class)
    public void mergeDelayErrorObservableManyOneThrows() {
<span class="fc" id="L1078">        Completable c = Completable.mergeDelayError(Flowable.just(normal.completable, error.completable));</span>

<span class="nc" id="L1080">        c.blockingAwait();</span>
<span class="nc" id="L1081">    }</span>

    @Test(timeout = 5000)
    public void mergeDelayErrorObservableMaxConcurrent() {
<span class="fc" id="L1085">        final List&lt;Long&gt; requested = new ArrayList&lt;Long&gt;();</span>
<span class="fc" id="L1086">        Flowable&lt;Completable&gt; cs = Flowable</span>
<span class="fc" id="L1087">                .just(normal.completable)</span>
<span class="fc" id="L1088">                .repeat(10)</span>
<span class="fc" id="L1089">                .doOnRequest(new LongConsumer() {</span>
                    @Override
                    public void accept(long v) {
<span class="fc" id="L1092">                        requested.add(v);</span>
<span class="fc" id="L1093">                    }</span>
                });

<span class="fc" id="L1096">        Completable c = Completable.mergeDelayError(cs, 5);</span>

<span class="fc" id="L1098">        c.blockingAwait();</span>

        // FIXME this request pattern looks odd because all 10 completions trigger 1 requests
<span class="fc" id="L1101">        Assert.assertEquals(Arrays.asList(5L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L), requested);</span>
<span class="fc" id="L1102">    }</span>

    @Test(timeout = 5000)
    public void never() {
<span class="fc" id="L1106">        final AtomicBoolean onSubscribeCalled = new AtomicBoolean();</span>
<span class="fc" id="L1107">        final AtomicInteger calls = new AtomicInteger();</span>
<span class="fc" id="L1108">        Completable.never().subscribe(new CompletableObserver() {</span>
            @Override
            public void onSubscribe(Disposable d) {
<span class="fc" id="L1111">                onSubscribeCalled.set(true);</span>
<span class="fc" id="L1112">            }</span>

            @Override
            public void onError(Throwable e) {
<span class="nc" id="L1116">                calls.getAndIncrement();</span>
<span class="nc" id="L1117">            }</span>

            @Override
            public void onComplete() {
<span class="nc" id="L1121">                calls.getAndIncrement();</span>
<span class="nc" id="L1122">            }</span>
        });

<span class="fc" id="L1125">        Assert.assertTrue(&quot;onSubscribe not called&quot;, onSubscribeCalled.get());</span>
<span class="fc" id="L1126">        Assert.assertEquals(&quot;There were calls to onXXX methods&quot;, 0, calls.get());</span>
<span class="fc" id="L1127">    }</span>

    @Test(timeout = 1500)
    public void timer() {
<span class="fc" id="L1131">        Completable c = Completable.timer(500, TimeUnit.MILLISECONDS);</span>

<span class="fc" id="L1133">        c.blockingAwait();</span>
<span class="fc" id="L1134">    }</span>

    @Test(timeout = 1500)
    public void timerNewThread() {
<span class="fc" id="L1138">        Completable c = Completable.timer(500, TimeUnit.MILLISECONDS, Schedulers.newThread());</span>

<span class="fc" id="L1140">        c.blockingAwait();</span>
<span class="fc" id="L1141">    }</span>

    @Test(timeout = 5000)
    public void timerTestScheduler() {
<span class="fc" id="L1145">        TestScheduler scheduler = new TestScheduler();</span>

<span class="fc" id="L1147">        Completable c = Completable.timer(250, TimeUnit.MILLISECONDS, scheduler);</span>

<span class="fc" id="L1149">        final AtomicInteger calls = new AtomicInteger();</span>

<span class="fc" id="L1151">        c.subscribe(new CompletableObserver() {</span>
            @Override
            public void onSubscribe(Disposable d) {

<span class="fc" id="L1155">            }</span>

            @Override
            public void onComplete() {
<span class="fc" id="L1159">                calls.getAndIncrement();</span>
<span class="fc" id="L1160">            }</span>

            @Override
            public void onError(Throwable e) {
<span class="nc" id="L1164">                RxJavaPlugins.onError(e);</span>
<span class="nc" id="L1165">            }</span>
        });

<span class="fc" id="L1168">        scheduler.advanceTimeBy(100, TimeUnit.MILLISECONDS);</span>

<span class="fc" id="L1170">        Assert.assertEquals(0, calls.get());</span>

<span class="fc" id="L1172">        scheduler.advanceTimeBy(200, TimeUnit.MILLISECONDS);</span>

<span class="fc" id="L1174">        Assert.assertEquals(1, calls.get());</span>
<span class="fc" id="L1175">    }</span>

    @Test(timeout = 2000)
    public void timerCancel() throws InterruptedException {
<span class="fc" id="L1179">        Completable c = Completable.timer(250, TimeUnit.MILLISECONDS);</span>

<span class="fc" id="L1181">        final SequentialDisposable sd = new SequentialDisposable();</span>
<span class="fc" id="L1182">        final AtomicInteger calls = new AtomicInteger();</span>

<span class="fc" id="L1184">        c.subscribe(new CompletableObserver() {</span>
            @Override
            public void onSubscribe(Disposable d) {
<span class="fc" id="L1187">                sd.replace(d);</span>
<span class="fc" id="L1188">            }</span>

            @Override
            public void onError(Throwable e) {
<span class="nc" id="L1192">                calls.getAndIncrement();</span>
<span class="nc" id="L1193">            }</span>

            @Override
            public void onComplete() {
<span class="nc" id="L1197">                calls.getAndIncrement();</span>
<span class="nc" id="L1198">            }</span>
        });

<span class="fc" id="L1201">        Thread.sleep(100);</span>

<span class="fc" id="L1203">        sd.dispose();</span>

<span class="fc" id="L1205">        Thread.sleep(200);</span>

<span class="fc" id="L1207">        Assert.assertEquals(0, calls.get());</span>
<span class="fc" id="L1208">    }</span>

    @Test(expected = NullPointerException.class)
    public void timerUnitNull() {
<span class="nc" id="L1212">        Completable.timer(1, null);</span>
<span class="nc" id="L1213">    }</span>

    @Test(expected = NullPointerException.class)
    public void timerSchedulerNull() {
<span class="nc" id="L1217">        Completable.timer(1, TimeUnit.SECONDS, null);</span>
<span class="nc" id="L1218">    }</span>

    @Test(timeout = 5000)
    public void usingNormalEager() {
<span class="fc" id="L1222">        final AtomicInteger dispose = new AtomicInteger();</span>

<span class="fc" id="L1224">        Completable c = Completable.using(new Callable&lt;Integer&gt;() {</span>
            @Override
            public Integer call() {
<span class="fc" id="L1227">                return 1;</span>
            }
<span class="fc" id="L1229">        }, new Function&lt;Object, Completable&gt;() {</span>
            @Override
            public Completable apply(Object v) {
<span class="fc" id="L1232">                return normal.completable;</span>
            }
<span class="fc" id="L1234">        }, new Consumer&lt;Integer&gt;() {</span>
            @Override
            public void accept(Integer d) {
<span class="fc" id="L1237">                dispose.set(d);</span>
<span class="fc" id="L1238">            }</span>
        });

<span class="fc" id="L1241">        final AtomicBoolean disposedFirst = new AtomicBoolean();</span>
<span class="fc" id="L1242">        final AtomicReference&lt;Throwable&gt; error = new AtomicReference&lt;Throwable&gt;();</span>

<span class="fc" id="L1244">        c.subscribe(new CompletableObserver() {</span>
            @Override
            public void onSubscribe(Disposable d) {

<span class="fc" id="L1248">            }</span>

            @Override
            public void onError(Throwable e) {
<span class="nc" id="L1252">                error.lazySet(e);</span>
<span class="nc" id="L1253">            }</span>

            @Override
            public void onComplete() {
<span class="pc bpc" id="L1257" title="1 of 2 branches missed.">                disposedFirst.set(dispose.get() != 0);</span>
<span class="fc" id="L1258">            }</span>
        });

<span class="fc" id="L1261">        Assert.assertEquals(1, dispose.get());</span>
<span class="fc" id="L1262">        Assert.assertTrue(&quot;Not disposed first&quot;, disposedFirst.get());</span>
<span class="fc" id="L1263">        Assert.assertNull(error.get());</span>
<span class="fc" id="L1264">    }</span>

    @Test(timeout = 5000)
    public void usingNormalLazy() {
<span class="fc" id="L1268">        final AtomicInteger dispose = new AtomicInteger();</span>

<span class="fc" id="L1270">        Completable c = Completable.using(new Callable&lt;Integer&gt;() {</span>
            @Override
            public Integer call() {
<span class="fc" id="L1273">                return 1;</span>
            }
<span class="fc" id="L1275">        }, new Function&lt;Integer, Completable&gt;() {</span>
            @Override
            public Completable apply(Integer v) {
<span class="fc" id="L1278">                return normal.completable;</span>
            }
<span class="fc" id="L1280">        }, new Consumer&lt;Integer&gt;() {</span>
            @Override
            public void accept(Integer d) {
<span class="fc" id="L1283">                dispose.set(d);</span>
<span class="fc" id="L1284">            }</span>
        }, false);

<span class="fc" id="L1287">        final AtomicBoolean disposedFirst = new AtomicBoolean();</span>
<span class="fc" id="L1288">        final AtomicReference&lt;Throwable&gt; error = new AtomicReference&lt;Throwable&gt;();</span>

<span class="fc" id="L1290">        c.subscribe(new CompletableObserver() {</span>
            @Override
            public void onSubscribe(Disposable d) {

<span class="fc" id="L1294">            }</span>

            @Override
            public void onError(Throwable e) {
<span class="nc" id="L1298">                error.lazySet(e);</span>
<span class="nc" id="L1299">            }</span>

            @Override
            public void onComplete() {
<span class="pc bpc" id="L1303" title="1 of 2 branches missed.">                disposedFirst.set(dispose.get() != 0);</span>
<span class="fc" id="L1304">            }</span>
        });

<span class="fc" id="L1307">        Assert.assertEquals(1, dispose.get());</span>
<span class="fc" id="L1308">        Assert.assertFalse(&quot;Disposed first&quot;, disposedFirst.get());</span>
<span class="fc" id="L1309">        Assert.assertNull(error.get());</span>
<span class="fc" id="L1310">    }</span>

    @Test(timeout = 5000)
    public void usingErrorEager() {
<span class="fc" id="L1314">        final AtomicInteger dispose = new AtomicInteger();</span>

<span class="fc" id="L1316">        Completable c = Completable.using(new Callable&lt;Integer&gt;() {</span>
            @Override
            public Integer call() {
<span class="fc" id="L1319">                return 1;</span>
            }
<span class="fc" id="L1321">        }, new Function&lt;Integer, Completable&gt;() {</span>
            @Override
            public Completable apply(Integer v) {
<span class="fc" id="L1324">                return error.completable;</span>
            }
<span class="fc" id="L1326">        }, new Consumer&lt;Integer&gt;() {</span>
            @Override
            public void accept(Integer d) {
<span class="fc" id="L1329">                dispose.set(d);</span>
<span class="fc" id="L1330">            }</span>
        });

<span class="fc" id="L1333">        final AtomicBoolean disposedFirst = new AtomicBoolean();</span>
<span class="fc" id="L1334">        final AtomicBoolean complete = new AtomicBoolean();</span>

<span class="fc" id="L1336">        c.subscribe(new CompletableObserver() {</span>
            @Override
            public void onSubscribe(Disposable d) {

<span class="fc" id="L1340">            }</span>

            @Override
            public void onError(Throwable e) {
<span class="pc bpc" id="L1344" title="1 of 2 branches missed.">                disposedFirst.set(dispose.get() != 0);</span>
<span class="fc" id="L1345">            }</span>

            @Override
            public void onComplete() {
<span class="nc" id="L1349">                complete.set(true);</span>
<span class="nc" id="L1350">            }</span>
        });

<span class="fc" id="L1353">        Assert.assertEquals(1, dispose.get());</span>
<span class="fc" id="L1354">        Assert.assertTrue(&quot;Not disposed first&quot;, disposedFirst.get());</span>
<span class="fc" id="L1355">        Assert.assertFalse(complete.get());</span>
<span class="fc" id="L1356">    }</span>

    @Test(timeout = 5000)
    public void usingErrorLazy() {
<span class="fc" id="L1360">        final AtomicInteger dispose = new AtomicInteger();</span>

<span class="fc" id="L1362">        Completable c = Completable.using(new Callable&lt;Integer&gt;() {</span>
            @Override
            public Integer call() {
<span class="fc" id="L1365">                return 1;</span>
            }
<span class="fc" id="L1367">        }, new Function&lt;Integer, Completable&gt;() {</span>
            @Override
            public Completable apply(Integer v) {
<span class="fc" id="L1370">                return error.completable;</span>
            }
<span class="fc" id="L1372">        }, new Consumer&lt;Integer&gt;() {</span>
            @Override
            public void accept(Integer d) {
<span class="fc" id="L1375">                dispose.set(d);</span>
<span class="fc" id="L1376">            }</span>
        }, false);

<span class="fc" id="L1379">        final AtomicBoolean disposedFirst = new AtomicBoolean();</span>
<span class="fc" id="L1380">        final AtomicBoolean complete = new AtomicBoolean();</span>

<span class="fc" id="L1382">        c.subscribe(new CompletableObserver() {</span>
            @Override
            public void onSubscribe(Disposable d) {

<span class="fc" id="L1386">            }</span>

            @Override
            public void onError(Throwable e) {
<span class="pc bpc" id="L1390" title="1 of 2 branches missed.">                disposedFirst.set(dispose.get() != 0);</span>
<span class="fc" id="L1391">            }</span>

            @Override
            public void onComplete() {
<span class="nc" id="L1395">                complete.set(true);</span>
<span class="nc" id="L1396">            }</span>
        });

<span class="fc" id="L1399">        Assert.assertEquals(1, dispose.get());</span>
<span class="fc" id="L1400">        Assert.assertFalse(&quot;Disposed first&quot;, disposedFirst.get());</span>
<span class="fc" id="L1401">        Assert.assertFalse(complete.get());</span>
<span class="fc" id="L1402">    }</span>

    @Test(expected = NullPointerException.class)
    public void usingResourceSupplierNull() {
<span class="pc" id="L1406">        Completable.using(null, new Function&lt;Object, Completable&gt;() {</span>
            @Override
            public Completable apply(Object v) {
<span class="nc" id="L1409">                return normal.completable;</span>
            }
<span class="fc" id="L1411">        }, new Consumer&lt;Object&gt;() {</span>
            @Override
<span class="nc" id="L1413">            public void accept(Object v) { }</span>
        });
<span class="nc" id="L1415">    }</span>

    @Test(expected = NullPointerException.class)
    public void usingMapperNull() {
<span class="pc" id="L1419">        Completable.using(new Callable&lt;Object&gt;() {</span>
            @Override
            public Object call() {
<span class="nc" id="L1422">                return 1;</span>
            }
<span class="fc" id="L1424">        }, null, new Consumer&lt;Object&gt;() {</span>
            @Override
<span class="nc" id="L1426">            public void accept(Object v) { }</span>
        });
<span class="nc" id="L1428">    }</span>

    @Test(expected = NullPointerException.class)
    public void usingMapperReturnsNull() {
<span class="fc" id="L1432">        Completable c = Completable.using(new Callable&lt;Object&gt;() {</span>
            @Override
            public Object call() {
<span class="fc" id="L1435">                return 1;</span>
            }
<span class="fc" id="L1437">        }, new Function&lt;Object, Completable&gt;() {</span>
            @Override
            public Completable apply(Object v) {
<span class="fc" id="L1440">                return null;</span>
            }
<span class="fc" id="L1442">        }, new Consumer&lt;Object&gt;() {</span>
            @Override
<span class="fc" id="L1444">            public void accept(Object v) { }</span>
        });

<span class="nc" id="L1447">        c.blockingAwait();</span>
<span class="nc" id="L1448">    }</span>

    @Test(expected = NullPointerException.class)
    public void usingDisposeNull() {
<span class="pc" id="L1452">        Completable.using(new Callable&lt;Object&gt;() {</span>
            @Override
            public Object call() {
<span class="nc" id="L1455">                return 1;</span>
            }
<span class="fc" id="L1457">        }, new Function&lt;Object, Completable&gt;() {</span>
            @Override
            public Completable apply(Object v) {
<span class="nc" id="L1460">                return normal.completable;</span>
            }
        }, null);
<span class="nc" id="L1463">    }</span>

    @Test(expected = TestException.class)
    public void usingResourceThrows() {
<span class="fc" id="L1467">        Completable c = Completable.using(new Callable&lt;Object&gt;() {</span>
            @Override
<span class="fc" id="L1469">            public Object call() { throw new TestException(); }</span>
        },
<span class="fc" id="L1471">                new Function&lt;Object, Completable&gt;() {</span>
                    @Override
                    public Completable apply(Object v) {
<span class="nc" id="L1474">                        return normal.completable;</span>
                    }
<span class="fc" id="L1476">                }, new Consumer&lt;Object&gt;() {</span>
                    @Override
<span class="nc" id="L1478">                    public void accept(Object v) { }</span>
                });

<span class="nc" id="L1481">        c.blockingAwait();</span>
<span class="nc" id="L1482">    }</span>

    @Test(expected = TestException.class)
    public void usingMapperThrows() {
<span class="fc" id="L1486">        Completable c = Completable.using(new Callable&lt;Object&gt;() {</span>
            @Override
            public Object call() {
<span class="fc" id="L1489">                return 1;</span>
            }
        },
<span class="fc" id="L1492">                new Function&lt;Object, Completable&gt;() {</span>
                    @Override
<span class="fc" id="L1494">                    public Completable apply(Object v) { throw new TestException(); }</span>
<span class="fc" id="L1495">                }, new Consumer&lt;Object&gt;() {</span>
                    @Override
<span class="fc" id="L1497">                    public void accept(Object v) { }</span>
                });

<span class="nc" id="L1500">        c.blockingAwait();</span>
<span class="nc" id="L1501">    }</span>

    @Test(expected = TestException.class)
    public void usingDisposerThrows() {
<span class="fc" id="L1505">        Completable c = Completable.using(new Callable&lt;Object&gt;() {</span>
            @Override
            public Object call() {
<span class="fc" id="L1508">                return 1;</span>
            }
        },
<span class="fc" id="L1511">                new Function&lt;Object, Completable&gt;() {</span>
                    @Override
                    public Completable apply(Object v) {
<span class="fc" id="L1514">                        return normal.completable;</span>
                    }
<span class="fc" id="L1516">                }, new Consumer&lt;Object&gt;() {</span>
                    @Override
<span class="fc" id="L1518">                    public void accept(Object v) { throw new TestException(); }</span>
                });

<span class="nc" id="L1521">        c.blockingAwait();</span>
<span class="nc" id="L1522">    }</span>

    @Test(timeout = 5000)
    public void composeNormal() {
<span class="fc" id="L1526">        Completable c = error.completable.compose(new CompletableTransformer() {</span>
            @Override
            public Completable apply(Completable n) {
<span class="fc" id="L1529">                return n.onErrorComplete();</span>
            }
        });

<span class="fc" id="L1533">        c.blockingAwait();</span>
<span class="fc" id="L1534">    }</span>

    @Test(expected = NullPointerException.class)
    public void composeNull() {
<span class="nc" id="L1538">        error.completable.compose(null);</span>
<span class="nc" id="L1539">    }</span>

    @Test(timeout = 5000)
    public void concatWithNormal() {
<span class="fc" id="L1543">        Completable c = normal.completable.concatWith(normal.completable);</span>

<span class="fc" id="L1545">        c.blockingAwait();</span>

<span class="fc" id="L1547">        normal.assertSubscriptions(2);</span>
<span class="fc" id="L1548">    }</span>

    @Test(timeout = 5000, expected = TestException.class)
    public void concatWithError() {
<span class="fc" id="L1552">        Completable c = normal.completable.concatWith(error.completable);</span>

<span class="nc" id="L1554">        c.blockingAwait();</span>
<span class="nc" id="L1555">    }</span>

    @Test(expected = NullPointerException.class)
    public void concatWithNull() {
<span class="nc" id="L1559">        normal.completable.concatWith(null);</span>
<span class="nc" id="L1560">    }</span>

    @Test(expected = NullPointerException.class)
    public void delayUnitNull() {
<span class="nc" id="L1564">        normal.completable.delay(1, null);</span>
<span class="nc" id="L1565">    }</span>

    @Test(expected = NullPointerException.class)
    public void delaySchedulerNull() {
<span class="nc" id="L1569">        normal.completable.delay(1, TimeUnit.SECONDS, null);</span>
<span class="nc" id="L1570">    }</span>

    @Test(timeout = 5000)
    public void delayNormal() throws InterruptedException {
<span class="fc" id="L1574">        Completable c = normal.completable.delay(250, TimeUnit.MILLISECONDS);</span>

<span class="fc" id="L1576">        final AtomicBoolean done = new AtomicBoolean();</span>
<span class="fc" id="L1577">        final AtomicReference&lt;Throwable&gt; error = new AtomicReference&lt;Throwable&gt;();</span>

<span class="fc" id="L1579">        c.subscribe(new CompletableObserver() {</span>
            @Override
            public void onSubscribe(Disposable d) {

<span class="fc" id="L1583">            }</span>

            @Override
            public void onError(Throwable e) {
<span class="nc" id="L1587">                error.set(e);</span>
<span class="nc" id="L1588">            }</span>

            @Override
            public void onComplete() {
<span class="fc" id="L1592">                done.set(true);</span>
<span class="fc" id="L1593">            }</span>
        });

<span class="fc" id="L1596">        Thread.sleep(100);</span>

<span class="fc" id="L1598">        Assert.assertFalse(&quot;Already done&quot;, done.get());</span>

<span class="fc" id="L1600">        int timeout = 10;</span>

<span class="pc bpc" id="L1602" title="1 of 4 branches missed.">        while (timeout-- &gt; 0 &amp;&amp; !done.get()) {</span>
<span class="fc" id="L1603">            Thread.sleep(100);</span>
        }

<span class="fc" id="L1606">        Assert.assertTrue(&quot;Not done&quot;, done.get());</span>

<span class="fc" id="L1608">        Assert.assertNull(error.get());</span>
<span class="fc" id="L1609">    }</span>

    @Test(timeout = 5000)
    public void delayErrorImmediately() throws InterruptedException {
<span class="fc" id="L1613">        final TestScheduler scheduler = new TestScheduler();</span>
<span class="fc" id="L1614">        final Completable c = error.completable.delay(250, TimeUnit.MILLISECONDS, scheduler);</span>

<span class="fc" id="L1616">        final AtomicBoolean done = new AtomicBoolean();</span>
<span class="fc" id="L1617">        final AtomicReference&lt;Throwable&gt; error = new AtomicReference&lt;Throwable&gt;();</span>

<span class="fc" id="L1619">        c.subscribe(new CompletableObserver() {</span>
            @Override
            public void onSubscribe(Disposable d) {

<span class="fc" id="L1623">            }</span>

            @Override
            public void onError(Throwable e) {
<span class="fc" id="L1627">                error.set(e);</span>
<span class="fc" id="L1628">            }</span>

            @Override
            public void onComplete() {
<span class="nc" id="L1632">                done.set(true);</span>
<span class="nc" id="L1633">            }</span>
        });

<span class="fc" id="L1636">        scheduler.advanceTimeBy(100, TimeUnit.MILLISECONDS);</span>

<span class="fc" id="L1638">        Assert.assertTrue(error.get().toString(), error.get() instanceof TestException);</span>
<span class="fc" id="L1639">        Assert.assertFalse(&quot;Already done&quot;, done.get());</span>

<span class="fc" id="L1641">        scheduler.advanceTimeBy(100, TimeUnit.MILLISECONDS);</span>

<span class="fc" id="L1643">        Assert.assertFalse(&quot;Already done&quot;, done.get());</span>
<span class="fc" id="L1644">    }</span>

    @Test(timeout = 5000)
    public void delayErrorToo() throws InterruptedException {
<span class="fc" id="L1648">        Completable c = error.completable.delay(250, TimeUnit.MILLISECONDS, Schedulers.computation(), true);</span>

<span class="fc" id="L1650">        final AtomicBoolean done = new AtomicBoolean();</span>
<span class="fc" id="L1651">        final AtomicReference&lt;Throwable&gt; error = new AtomicReference&lt;Throwable&gt;();</span>

<span class="fc" id="L1653">        c.subscribe(new CompletableObserver() {</span>
            @Override
            public void onSubscribe(Disposable d) {

<span class="fc" id="L1657">            }</span>

            @Override
            public void onError(Throwable e) {
<span class="fc" id="L1661">                error.set(e);</span>
<span class="fc" id="L1662">            }</span>

            @Override
            public void onComplete() {
<span class="nc" id="L1666">                done.set(true);</span>
<span class="nc" id="L1667">            }</span>
        });

<span class="fc" id="L1670">        Thread.sleep(100);</span>

<span class="fc" id="L1672">        Assert.assertFalse(&quot;Already done&quot;, done.get());</span>
<span class="fc" id="L1673">        Assert.assertNull(error.get());</span>

<span class="fc" id="L1675">        Thread.sleep(200);</span>

<span class="fc" id="L1677">        Assert.assertFalse(&quot;Already done&quot;, done.get());</span>
<span class="fc" id="L1678">        Assert.assertTrue(error.get() instanceof TestException);</span>
<span class="fc" id="L1679">    }</span>

    @Test(timeout = 5000)
    public void doOnCompleteNormal() {
<span class="fc" id="L1683">        final AtomicInteger calls = new AtomicInteger();</span>

<span class="fc" id="L1685">        Completable c = normal.completable.doOnComplete(new Action() {</span>
            @Override
            public void run() {
<span class="fc" id="L1688">                calls.getAndIncrement();</span>
<span class="fc" id="L1689">            }</span>
        });

<span class="fc" id="L1692">        c.blockingAwait();</span>

<span class="fc" id="L1694">        Assert.assertEquals(1, calls.get());</span>
<span class="fc" id="L1695">    }</span>

    @Test(timeout = 5000)
    public void doOnCompleteError() {
<span class="fc" id="L1699">        final AtomicInteger calls = new AtomicInteger();</span>

<span class="fc" id="L1701">        Completable c = error.completable.doOnComplete(new Action() {</span>
            @Override
            public void run() {
<span class="nc" id="L1704">                calls.getAndIncrement();</span>
<span class="nc" id="L1705">            }</span>
        });

        try {
<span class="nc" id="L1709">            c.blockingAwait();</span>
<span class="nc" id="L1710">            Assert.fail(&quot;Failed to throw TestException&quot;);</span>
<span class="fc" id="L1711">        } catch (TestException ex) {</span>
            // expected
<span class="nc" id="L1713">        }</span>

<span class="fc" id="L1715">        Assert.assertEquals(0, calls.get());</span>
<span class="fc" id="L1716">    }</span>

    @Test(expected = NullPointerException.class)
    public void doOnCompleteNull() {
<span class="nc" id="L1720">        normal.completable.doOnComplete(null);</span>
<span class="nc" id="L1721">    }</span>

    @Test(timeout = 5000, expected = TestException.class)
    public void doOnCompleteThrows() {
<span class="fc" id="L1725">        Completable c = normal.completable.doOnComplete(new Action() {</span>
            @Override
<span class="fc" id="L1727">            public void run() { throw new TestException(); }</span>
        });

<span class="nc" id="L1730">        c.blockingAwait();</span>
<span class="nc" id="L1731">    }</span>

    @Test(timeout = 5000)
    public void doOnDisposeNormalDoesntCall() {
<span class="fc" id="L1735">        final AtomicInteger calls = new AtomicInteger();</span>

<span class="fc" id="L1737">        Completable c = normal.completable.doOnDispose(new Action() {</span>
            @Override
            public void run() {
<span class="nc" id="L1740">                calls.getAndIncrement();</span>
<span class="nc" id="L1741">            }</span>
        });

<span class="fc" id="L1744">        c.blockingAwait();</span>

<span class="fc" id="L1746">        Assert.assertEquals(0, calls.get());</span>
<span class="fc" id="L1747">    }</span>

    @Test(timeout = 5000)
    public void doOnDisposeErrorDoesntCall() {
<span class="fc" id="L1751">        final AtomicInteger calls = new AtomicInteger();</span>

<span class="fc" id="L1753">        Completable c = error.completable.doOnDispose(new Action() {</span>
            @Override
            public void run() {
<span class="nc" id="L1756">                calls.getAndIncrement();</span>
<span class="nc" id="L1757">            }</span>
        });

        try {
<span class="nc" id="L1761">            c.blockingAwait();</span>
<span class="nc" id="L1762">            Assert.fail(&quot;No exception thrown&quot;);</span>
<span class="fc" id="L1763">        } catch (TestException ex) {</span>
            // expected
<span class="nc" id="L1765">        }</span>
<span class="fc" id="L1766">        Assert.assertEquals(0, calls.get());</span>
<span class="fc" id="L1767">    }</span>

    @Test(timeout = 5000)
    public void doOnDisposeChildCancels() {
<span class="fc" id="L1771">        final AtomicInteger calls = new AtomicInteger();</span>

<span class="fc" id="L1773">        Completable c = normal.completable.doOnDispose(new Action() {</span>
            @Override
            public void run() {
<span class="fc" id="L1776">                calls.getAndIncrement();</span>
<span class="fc" id="L1777">            }</span>
        });

<span class="fc" id="L1780">        c.subscribe(new CompletableObserver() {</span>
            @Override
            public void onSubscribe(Disposable d) {
<span class="fc" id="L1783">                d.dispose();</span>
<span class="fc" id="L1784">            }</span>

            @Override
            public void onError(Throwable e) {
                // ignored
<span class="nc" id="L1789">            }</span>

            @Override
            public void onComplete() {
                // ignored
<span class="fc" id="L1794">            }</span>
        });

<span class="fc" id="L1797">        Assert.assertEquals(1, calls.get());</span>
<span class="fc" id="L1798">    }</span>

    @Test(expected = NullPointerException.class)
    public void doOnDisposeNull() {
<span class="nc" id="L1802">        normal.completable.doOnDispose(null);</span>
<span class="nc" id="L1803">    }</span>

    @Test(timeout = 5000)
    public void doOnDisposeThrows() {
<span class="fc" id="L1807">        List&lt;Throwable&gt; errors = TestHelper.trackPluginErrors();</span>
        try {
<span class="fc" id="L1809">            Completable c = normal.completable.doOnDispose(new Action() {</span>
                @Override
<span class="fc" id="L1811">                public void run() { throw new TestException(); }</span>
            });

<span class="fc" id="L1814">            c.subscribe(new CompletableObserver() {</span>
                @Override
                public void onSubscribe(Disposable d) {
<span class="fc" id="L1817">                    d.dispose();</span>
<span class="fc" id="L1818">                }</span>

                @Override
                public void onError(Throwable e) {
                    // ignored
<span class="nc" id="L1823">                }</span>

                @Override
                public void onComplete() {
                    // ignored
<span class="fc" id="L1828">                }</span>
            });

<span class="fc" id="L1831">            TestHelper.assertUndeliverable(errors, 0, TestException.class);</span>
        } finally {
<span class="fc" id="L1833">            RxJavaPlugins.reset();</span>
        }
<span class="fc" id="L1835">    }</span>

    @Test(timeout = 5000)
    public void doOnErrorNoError() {
<span class="fc" id="L1839">        final AtomicReference&lt;Throwable&gt; error = new AtomicReference&lt;Throwable&gt;();</span>

<span class="fc" id="L1841">        Completable c = normal.completable.doOnError(new Consumer&lt;Throwable&gt;() {</span>
            @Override
            public void accept(Throwable e) {
<span class="nc" id="L1844">                error.set(e);</span>
<span class="nc" id="L1845">            }</span>
        });

<span class="fc" id="L1848">        c.blockingAwait();</span>

<span class="fc" id="L1850">        Assert.assertNull(error.get());</span>
<span class="fc" id="L1851">    }</span>

    @Test(timeout = 5000)
    public void doOnErrorHasError() {
<span class="fc" id="L1855">        final AtomicReference&lt;Throwable&gt; err = new AtomicReference&lt;Throwable&gt;();</span>

<span class="fc" id="L1857">        Completable c = error.completable.doOnError(new Consumer&lt;Throwable&gt;() {</span>
            @Override
            public void accept(Throwable e) {
<span class="fc" id="L1860">                err.set(e);</span>
<span class="fc" id="L1861">            }</span>
        });

        try {
<span class="nc" id="L1865">            c.blockingAwait();</span>
<span class="nc" id="L1866">            Assert.fail(&quot;Did not throw exception&quot;);</span>
<span class="fc" id="L1867">        } catch (Throwable e) {</span>
            // expected
<span class="nc" id="L1869">        }</span>

<span class="fc" id="L1871">        Assert.assertTrue(err.get() instanceof TestException);</span>
<span class="fc" id="L1872">    }</span>

    @Test(expected = NullPointerException.class)
    public void doOnErrorNull() {
<span class="nc" id="L1876">        normal.completable.doOnError(null);</span>
<span class="nc" id="L1877">    }</span>

    @Test(timeout = 5000)
    public void doOnErrorThrows() {
<span class="fc" id="L1881">        Completable c = error.completable.doOnError(new Consumer&lt;Throwable&gt;() {</span>
            @Override
<span class="fc" id="L1883">            public void accept(Throwable e) { throw new IllegalStateException(); }</span>
        });

        try {
<span class="nc" id="L1887">            c.blockingAwait();</span>
<span class="fc" id="L1888">        } catch (CompositeException ex) {</span>
<span class="fc" id="L1889">            List&lt;Throwable&gt; a = ex.getExceptions();</span>
<span class="fc" id="L1890">            Assert.assertEquals(2, a.size());</span>
<span class="fc" id="L1891">            Assert.assertTrue(a.get(0) instanceof TestException);</span>
<span class="fc" id="L1892">            Assert.assertTrue(a.get(1) instanceof IllegalStateException);</span>
<span class="nc" id="L1893">        }</span>
<span class="fc" id="L1894">    }</span>

    @Test(timeout = 5000)
    public void doOnSubscribeNormal() {
<span class="fc" id="L1898">        final AtomicInteger calls = new AtomicInteger();</span>

<span class="fc" id="L1900">        Completable c = normal.completable.doOnSubscribe(new Consumer&lt;Disposable&gt;() {</span>
            @Override
            public void accept(Disposable d) {
<span class="fc" id="L1903">                calls.getAndIncrement();</span>
<span class="fc" id="L1904">            }</span>
        });

<span class="fc bfc" id="L1907" title="All 2 branches covered.">        for (int i = 0; i &lt; 10; i++) {</span>
<span class="fc" id="L1908">            c.blockingAwait();</span>
        }

<span class="fc" id="L1911">        Assert.assertEquals(10, calls.get());</span>
<span class="fc" id="L1912">    }</span>

    @Test(expected = NullPointerException.class)
    public void doOnSubscribeNull() {
<span class="nc" id="L1916">        normal.completable.doOnSubscribe(null);</span>
<span class="nc" id="L1917">    }</span>

    @Test(expected = TestException.class)
    public void doOnSubscribeThrows() {
<span class="fc" id="L1921">        Completable c = normal.completable.doOnSubscribe(new Consumer&lt;Disposable&gt;() {</span>
            @Override
<span class="fc" id="L1923">            public void accept(Disposable d) { throw new TestException(); }</span>
        });

<span class="nc" id="L1926">        c.blockingAwait();</span>
<span class="nc" id="L1927">    }</span>

    @Test(timeout = 5000)
    public void doOnTerminateNormal() {
<span class="fc" id="L1931">        final AtomicInteger calls = new AtomicInteger();</span>

<span class="fc" id="L1933">        Completable c = normal.completable.doOnTerminate(new Action() {</span>
            @Override
            public void run() {
<span class="fc" id="L1936">                calls.getAndIncrement();</span>
<span class="fc" id="L1937">            }</span>
        });

<span class="fc" id="L1940">        c.blockingAwait();</span>

<span class="fc" id="L1942">        Assert.assertEquals(1, calls.get());</span>
<span class="fc" id="L1943">    }</span>

    @Test(timeout = 5000)
    public void doOnTerminateError() {
<span class="fc" id="L1947">        final AtomicInteger calls = new AtomicInteger();</span>

<span class="fc" id="L1949">        Completable c = error.completable.doOnTerminate(new Action() {</span>
            @Override
            public void run() {
<span class="fc" id="L1952">                calls.getAndIncrement();</span>
<span class="fc" id="L1953">            }</span>
        });

        try {
<span class="nc" id="L1957">            c.blockingAwait();</span>
<span class="nc" id="L1958">            Assert.fail(&quot;Did dot throw exception&quot;);</span>
<span class="fc" id="L1959">        } catch (TestException ex) {</span>
            // expected
<span class="nc" id="L1961">        }</span>

<span class="fc" id="L1963">        Assert.assertEquals(1, calls.get());</span>
<span class="fc" id="L1964">    }</span>

    @Test(timeout = 5000)
    public void getNormal() {
<span class="fc" id="L1968">        Assert.assertNull(normal.completable.blockingGet());</span>
<span class="fc" id="L1969">    }</span>

    @Test(timeout = 5000)
    public void getError() {
<span class="fc" id="L1973">        Assert.assertTrue(error.completable.blockingGet() instanceof TestException);</span>
<span class="fc" id="L1974">    }</span>

    @Test(timeout = 5000)
    public void getTimeout() {
        try {
<span class="nc" id="L1979">            Completable.never().blockingGet(100, TimeUnit.MILLISECONDS);</span>
<span class="fc" id="L1980">        } catch (RuntimeException ex) {</span>
<span class="pc bpc" id="L1981" title="1 of 2 branches missed.">            if (!(ex.getCause() instanceof TimeoutException)) {</span>
<span class="nc" id="L1982">                Assert.fail(&quot;Wrong exception cause: &quot; + ex.getCause());</span>
            }
<span class="nc" id="L1984">        }</span>
<span class="fc" id="L1985">    }</span>

    @Test(expected = NullPointerException.class)
    public void getNullUnit() {
<span class="nc" id="L1989">        normal.completable.blockingGet(1, null);</span>
<span class="nc" id="L1990">    }</span>

    @Test(expected = NullPointerException.class)
    public void liftNull() {
<span class="nc" id="L1994">        normal.completable.lift(null);</span>
<span class="nc" id="L1995">    }</span>

    @Test(timeout = 5000, expected = NullPointerException.class)
    public void liftReturnsNull() {
<span class="fc" id="L1999">        Completable c = normal.completable.lift(new CompletableOperator() {</span>
            @Override
            public CompletableObserver apply(CompletableObserver v) {
<span class="fc" id="L2002">                return null;</span>
            }
        });

<span class="nc" id="L2006">        c.blockingAwait();</span>
<span class="nc" id="L2007">    }</span>

<span class="fc" id="L2009">    static final class CompletableOperatorSwap implements CompletableOperator {</span>
        @Override
        public CompletableObserver apply(final CompletableObserver v) {
<span class="fc" id="L2012">            return new CompletableObserver() {</span>

                @Override
                public void onComplete() {
<span class="fc" id="L2016">                    v.onError(new TestException());</span>
<span class="fc" id="L2017">                }</span>

                @Override
                public void onError(Throwable e) {
<span class="fc" id="L2021">                    v.onComplete();</span>
<span class="fc" id="L2022">                }</span>

                @Override
                public void onSubscribe(Disposable d) {
<span class="fc" id="L2026">                    v.onSubscribe(d);</span>
<span class="fc" id="L2027">                }</span>

            };
        }
    }

    @Test(timeout = 5000, expected = TestException.class)
    public void liftOnCompleteError() {
<span class="fc" id="L2035">        Completable c = normal.completable.lift(new CompletableOperatorSwap());</span>

<span class="nc" id="L2037">        c.blockingAwait();</span>
<span class="nc" id="L2038">    }</span>

    @Test(timeout = 5000)
    public void liftOnErrorComplete() {
<span class="fc" id="L2042">        Completable c = error.completable.lift(new CompletableOperatorSwap());</span>

<span class="fc" id="L2044">        c.blockingAwait();</span>
<span class="fc" id="L2045">    }</span>

    @Test(expected = NullPointerException.class)
    public void mergeWithNull() {
<span class="nc" id="L2049">        normal.completable.mergeWith(null);</span>
<span class="nc" id="L2050">    }</span>

    @Test(timeout = 5000)
    public void mergeWithNormal() {
<span class="fc" id="L2054">        Completable c = normal.completable.mergeWith(normal.completable);</span>

<span class="fc" id="L2056">        c.blockingAwait();</span>

<span class="fc" id="L2058">        normal.assertSubscriptions(2);</span>
<span class="fc" id="L2059">    }</span>

    @Test(expected = NullPointerException.class)
    public void observeOnNull() {
<span class="nc" id="L2063">        normal.completable.observeOn(null);</span>
<span class="nc" id="L2064">    }</span>

    @Test(timeout = 5000)
    public void observeOnNormal() throws InterruptedException {
<span class="fc" id="L2068">        final AtomicReference&lt;String&gt; name = new AtomicReference&lt;String&gt;();</span>
<span class="fc" id="L2069">        final AtomicReference&lt;Throwable&gt; err = new AtomicReference&lt;Throwable&gt;();</span>
<span class="fc" id="L2070">        final CountDownLatch cdl = new CountDownLatch(1);</span>

<span class="fc" id="L2072">        Completable c = normal.completable.observeOn(Schedulers.computation());</span>

<span class="fc" id="L2074">        c.subscribe(new CompletableObserver() {</span>
            @Override
            public void onSubscribe(Disposable d) {

<span class="fc" id="L2078">            }</span>

            @Override
            public void onComplete() {
<span class="fc" id="L2082">                name.set(Thread.currentThread().getName());</span>
<span class="fc" id="L2083">                cdl.countDown();</span>
<span class="fc" id="L2084">            }</span>

            @Override
            public void onError(Throwable e) {
<span class="nc" id="L2088">                err.set(e);</span>
<span class="nc" id="L2089">                cdl.countDown();</span>
<span class="nc" id="L2090">            }</span>
        });

<span class="fc" id="L2093">        cdl.await();</span>

<span class="fc" id="L2095">        Assert.assertNull(err.get());</span>
<span class="fc" id="L2096">        Assert.assertTrue(name.get().startsWith(&quot;RxComputation&quot;));</span>
<span class="fc" id="L2097">    }</span>

    @Test(timeout = 5000)
    public void observeOnError() throws InterruptedException {
<span class="fc" id="L2101">        final AtomicReference&lt;String&gt; name = new AtomicReference&lt;String&gt;();</span>
<span class="fc" id="L2102">        final AtomicReference&lt;Throwable&gt; err = new AtomicReference&lt;Throwable&gt;();</span>
<span class="fc" id="L2103">        final CountDownLatch cdl = new CountDownLatch(1);</span>

<span class="fc" id="L2105">        Completable c = error.completable.observeOn(Schedulers.computation());</span>

<span class="fc" id="L2107">        c.subscribe(new CompletableObserver() {</span>
            @Override
            public void onSubscribe(Disposable d) {

<span class="fc" id="L2111">            }</span>

            @Override
            public void onComplete() {
<span class="nc" id="L2115">                name.set(Thread.currentThread().getName());</span>
<span class="nc" id="L2116">                cdl.countDown();</span>
<span class="nc" id="L2117">            }</span>

            @Override
            public void onError(Throwable e) {
<span class="fc" id="L2121">                name.set(Thread.currentThread().getName());</span>
<span class="fc" id="L2122">                err.set(e);</span>
<span class="fc" id="L2123">                cdl.countDown();</span>
<span class="fc" id="L2124">            }</span>
        });

<span class="fc" id="L2127">        cdl.await();</span>

<span class="fc" id="L2129">        Assert.assertTrue(err.get() instanceof TestException);</span>
<span class="fc" id="L2130">        Assert.assertTrue(name.get().startsWith(&quot;RxComputation&quot;));</span>
<span class="fc" id="L2131">    }</span>

    @Test(timeout = 5000)
    public void onErrorComplete() {
<span class="fc" id="L2135">        Completable c = error.completable.onErrorComplete();</span>

<span class="fc" id="L2137">        c.blockingAwait();</span>
<span class="fc" id="L2138">    }</span>

    @Test(timeout = 5000, expected = TestException.class)
    public void onErrorCompleteFalse() {
<span class="fc" id="L2142">        Completable c = error.completable.onErrorComplete(new Predicate&lt;Throwable&gt;() {</span>
            @Override
            public boolean test(Throwable e) {
<span class="fc" id="L2145">                return e instanceof IllegalStateException;</span>
            }
        });

<span class="nc" id="L2149">        c.blockingAwait();</span>
<span class="nc" id="L2150">    }</span>

    @Test(expected = NullPointerException.class)
    public void onErrorCompleteNull() {
<span class="nc" id="L2154">        error.completable.onErrorComplete(null);</span>
<span class="nc" id="L2155">    }</span>

    @Test(expected = NullPointerException.class)
    public void onErrorResumeNextNull() {
<span class="nc" id="L2159">        error.completable.onErrorResumeNext(null);</span>
<span class="nc" id="L2160">    }</span>

    @Test(timeout = 5000)
    public void onErrorResumeNextFunctionReturnsNull() {
<span class="fc" id="L2164">        Completable c = error.completable.onErrorResumeNext(new Function&lt;Throwable, Completable&gt;() {</span>
            @Override
            public Completable apply(Throwable e) {
<span class="fc" id="L2167">                return null;</span>
            }
        });

        try {
<span class="nc" id="L2172">            c.blockingAwait();</span>
<span class="nc" id="L2173">            Assert.fail(&quot;Did not throw an exception&quot;);</span>
<span class="fc" id="L2174">        } catch (CompositeException ex) {</span>
<span class="fc" id="L2175">            List&lt;Throwable&gt; errors = ex.getExceptions();</span>
<span class="fc" id="L2176">            TestHelper.assertError(errors, 0, TestException.class);</span>
<span class="fc" id="L2177">            TestHelper.assertError(errors, 1, NullPointerException.class);</span>
<span class="fc" id="L2178">            assertEquals(2, errors.size());</span>
<span class="nc" id="L2179">        }</span>
<span class="fc" id="L2180">    }</span>

    @Test(timeout = 5000)
    public void onErrorResumeNextFunctionThrows() {
<span class="fc" id="L2184">        Completable c = error.completable.onErrorResumeNext(new Function&lt;Throwable, Completable&gt;() {</span>
            @Override
<span class="fc" id="L2186">            public Completable apply(Throwable e) { throw new TestException(); }</span>
        });

        try {
<span class="nc" id="L2190">            c.blockingAwait();</span>
<span class="nc" id="L2191">            Assert.fail(&quot;Did not throw an exception&quot;);</span>
<span class="fc" id="L2192">        } catch (CompositeException ex) {</span>
<span class="fc" id="L2193">            List&lt;Throwable&gt; a = ex.getExceptions();</span>

<span class="fc" id="L2195">            Assert.assertEquals(2, a.size());</span>
<span class="fc" id="L2196">            Assert.assertTrue(a.get(0) instanceof TestException);</span>
<span class="fc" id="L2197">            Assert.assertTrue(a.get(1) instanceof TestException);</span>
<span class="nc" id="L2198">        }</span>
<span class="fc" id="L2199">    }</span>

    @Test(timeout = 5000)
    public void onErrorResumeNextNormal() {
<span class="fc" id="L2203">        Completable c = error.completable.onErrorResumeNext(new Function&lt;Throwable, Completable&gt;() {</span>
            @Override
            public Completable apply(Throwable v) {
<span class="fc" id="L2206">                return normal.completable;</span>
            }
        });

<span class="fc" id="L2210">        c.blockingAwait();</span>
<span class="fc" id="L2211">    }</span>

    @Test(timeout = 5000, expected = TestException.class)
    public void onErrorResumeNextError() {
<span class="fc" id="L2215">        Completable c = error.completable.onErrorResumeNext(new Function&lt;Throwable, Completable&gt;() {</span>
            @Override
            public Completable apply(Throwable v) {
<span class="fc" id="L2218">                return error.completable;</span>
            }
        });

<span class="nc" id="L2222">        c.blockingAwait();</span>
<span class="nc" id="L2223">    }</span>

    @Test(timeout = 2000)
    public void repeatNormal() {
<span class="fc" id="L2227">        final AtomicReference&lt;Throwable&gt; err = new AtomicReference&lt;Throwable&gt;();</span>
<span class="fc" id="L2228">        final AtomicInteger calls = new AtomicInteger();</span>

<span class="fc" id="L2230">        Completable c = Completable.fromCallable(new Callable&lt;Object&gt;() {</span>
            @Override
            public Object call() throws Exception {
<span class="fc" id="L2233">                calls.getAndIncrement();</span>
<span class="fc" id="L2234">                Thread.sleep(100);</span>
<span class="fc" id="L2235">                return null;</span>
            }
<span class="fc" id="L2237">        }).repeat();</span>

<span class="fc" id="L2239">        c.subscribe(new CompletableObserver() {</span>
            @Override
            public void onSubscribe(final Disposable d) {
<span class="fc" id="L2242">                Schedulers.single().scheduleDirect(new Runnable() {</span>
                    @Override
                    public void run() {
<span class="fc" id="L2245">                        d.dispose();</span>
<span class="fc" id="L2246">                    }</span>
                }, 550, TimeUnit.MILLISECONDS);
<span class="fc" id="L2248">            }</span>

            @Override
            public void onError(Throwable e) {
<span class="nc" id="L2252">                err.set(e);</span>
<span class="nc" id="L2253">            }</span>

            @Override
            public void onComplete() {

<span class="nc" id="L2258">            }</span>
        });

<span class="fc" id="L2261">        Assert.assertEquals(6, calls.get());</span>
<span class="fc" id="L2262">        Assert.assertNull(err.get());</span>
<span class="fc" id="L2263">    }</span>

    @Test(timeout = 5000, expected = TestException.class)
    public void repeatError() {
<span class="fc" id="L2267">        Completable c = error.completable.repeat();</span>

<span class="nc" id="L2269">        c.blockingAwait();</span>
<span class="nc" id="L2270">    }</span>

    @Test(timeout = 5000)
    public void repeat5Times() {
<span class="fc" id="L2274">        final AtomicInteger calls = new AtomicInteger();</span>

<span class="fc" id="L2276">        Completable c = Completable.fromCallable(new Callable&lt;Object&gt;() {</span>
            @Override
            public Object call() throws Exception {
<span class="fc" id="L2279">                calls.getAndIncrement();</span>
<span class="fc" id="L2280">                return null;</span>
            }
<span class="fc" id="L2282">        }).repeat(5);</span>

<span class="fc" id="L2284">        c.blockingAwait();</span>

<span class="fc" id="L2286">        Assert.assertEquals(5, calls.get());</span>
<span class="fc" id="L2287">    }</span>

    @Test(timeout = 5000)
    public void repeat1Time() {
<span class="fc" id="L2291">        final AtomicInteger calls = new AtomicInteger();</span>

<span class="fc" id="L2293">        Completable c = Completable.fromCallable(new Callable&lt;Object&gt;() {</span>
            @Override
            public Object call() throws Exception {
<span class="fc" id="L2296">                calls.getAndIncrement();</span>
<span class="fc" id="L2297">                return null;</span>
            }
<span class="fc" id="L2299">        }).repeat(1);</span>

<span class="fc" id="L2301">        c.blockingAwait();</span>

<span class="fc" id="L2303">        Assert.assertEquals(1, calls.get());</span>
<span class="fc" id="L2304">    }</span>

    @Test(timeout = 5000)
    public void repeat0Time() {
<span class="fc" id="L2308">        final AtomicInteger calls = new AtomicInteger();</span>

<span class="fc" id="L2310">        Completable c = Completable.fromCallable(new Callable&lt;Object&gt;() {</span>
            @Override
            public Object call() throws Exception {
<span class="nc" id="L2313">                calls.getAndIncrement();</span>
<span class="nc" id="L2314">                return null;</span>
            }
<span class="fc" id="L2316">        }).repeat(0);</span>

<span class="fc" id="L2318">        c.blockingAwait();</span>

<span class="fc" id="L2320">        Assert.assertEquals(0, calls.get());</span>
<span class="fc" id="L2321">    }</span>

    @Test(timeout = 5000)
    public void repeatUntilNormal() {
<span class="fc" id="L2325">        final AtomicInteger calls = new AtomicInteger();</span>
<span class="fc" id="L2326">        final AtomicInteger times = new AtomicInteger(5);</span>

<span class="fc" id="L2328">        Completable c = Completable.fromCallable(new Callable&lt;Object&gt;() {</span>
            @Override
            public Object call() throws Exception {
<span class="fc" id="L2331">                calls.getAndIncrement();</span>
<span class="fc" id="L2332">                return null;</span>
            }
<span class="fc" id="L2334">        }).repeatUntil(new BooleanSupplier() {</span>
            @Override
            public boolean getAsBoolean() {
<span class="fc bfc" id="L2337" title="All 2 branches covered.">                return times.decrementAndGet() == 0;</span>
            }
        });

<span class="fc" id="L2341">        c.blockingAwait();</span>

<span class="fc" id="L2343">        Assert.assertEquals(5, calls.get());</span>
<span class="fc" id="L2344">    }</span>

    @Test(expected = NullPointerException.class)
    public void repeatUntilNull() {
<span class="nc" id="L2348">        normal.completable.repeatUntil(null);</span>
<span class="nc" id="L2349">    }</span>

    @Test(expected = NullPointerException.class)
    public void repeatWhenNull() {
<span class="nc" id="L2353">        normal.completable.repeatWhen(null);</span>
<span class="nc" id="L2354">    }</span>

    @Test(timeout = 5000)
    public void retryNormal() {
<span class="fc" id="L2358">        Completable c = normal.completable.retry();</span>

<span class="fc" id="L2360">        c.blockingAwait();</span>

<span class="fc" id="L2362">        normal.assertSubscriptions(1);</span>
<span class="fc" id="L2363">    }</span>

    @Test(timeout = 5000)
    public void retry5Times() {
<span class="fc" id="L2367">        final AtomicInteger calls = new AtomicInteger(5);</span>
<span class="fc" id="L2368">        Completable c = Completable.fromAction(new Action() {</span>
            @Override
            public void run() {
<span class="fc bfc" id="L2371" title="All 2 branches covered.">                if (calls.decrementAndGet() != 0) {</span>
<span class="fc" id="L2372">                    throw new TestException();</span>
                }
<span class="fc" id="L2374">            }</span>
<span class="fc" id="L2375">        }).retry();</span>

<span class="fc" id="L2377">        c.blockingAwait();</span>
<span class="fc" id="L2378">    }</span>

    @Test(timeout = 5000, expected = TestException.class)
    public void retryBiPredicate5Times() {
<span class="fc" id="L2382">        Completable c = error.completable.retry(new BiPredicate&lt;Integer, Throwable&gt;() {</span>
            @Override
            public boolean test(Integer n, Throwable e) {
<span class="fc bfc" id="L2385" title="All 2 branches covered.">                return n &lt; 5;</span>
            }
        });

<span class="nc" id="L2389">        c.blockingAwait();</span>
<span class="nc" id="L2390">    }</span>

    @Test(timeout = 5000, expected = TestException.class)
    public void retryTimes5Error() {
<span class="fc" id="L2394">        Completable c = error.completable.retry(5);</span>

<span class="nc" id="L2396">        c.blockingAwait();</span>
<span class="nc" id="L2397">    }</span>

    @Test(timeout = 5000)
    public void retryTimes5Normal() {
<span class="fc" id="L2401">        final AtomicInteger calls = new AtomicInteger();</span>

<span class="fc" id="L2403">        Completable c = Completable.fromAction(new Action() {</span>
            @Override
            public void run() {
<span class="fc bfc" id="L2406" title="All 2 branches covered.">                if (calls.incrementAndGet() != 6) {</span>
<span class="fc" id="L2407">                    throw new TestException();</span>
                }
<span class="fc" id="L2409">            }</span>
<span class="fc" id="L2410">        }).retry(5);</span>

<span class="fc" id="L2412">        c.blockingAwait();</span>

<span class="fc" id="L2414">        assertEquals(6, calls.get());</span>
<span class="fc" id="L2415">    }</span>

    @Test(expected = IllegalArgumentException.class)
    public void retryNegativeTimes() {
<span class="nc" id="L2419">        normal.completable.retry(-1);</span>
<span class="nc" id="L2420">    }</span>

    @Test(timeout = 5000, expected = TestException.class)
    public void retryPredicateError() {
<span class="fc" id="L2424">        Completable c = error.completable.retry(new Predicate&lt;Throwable&gt;() {</span>
            @Override
            public boolean test(Throwable e) {
<span class="fc" id="L2427">                return false;</span>
            }
        });

<span class="nc" id="L2431">        c.blockingAwait();</span>
<span class="nc" id="L2432">    }</span>

    @Test(expected = NullPointerException.class)
    public void retryPredicateNull() {
<span class="nc" id="L2436">        error.completable.retry((Predicate&lt;Throwable&gt;)null);</span>
<span class="nc" id="L2437">    }</span>

    @Test(timeout = 5000)
    public void retryPredicate5Times() {
<span class="fc" id="L2441">        final AtomicInteger calls = new AtomicInteger(5);</span>

<span class="fc" id="L2443">        Completable c = Completable.fromAction(new Action() {</span>
            @Override
            public void run() {
<span class="fc bfc" id="L2446" title="All 2 branches covered.">                if (calls.decrementAndGet() != 0) {</span>
<span class="fc" id="L2447">                    throw new TestException();</span>
                }
<span class="fc" id="L2449">            }</span>
<span class="fc" id="L2450">        }).retry(new Predicate&lt;Throwable&gt;() {</span>
            @Override
            public boolean test(Throwable e) {
<span class="fc" id="L2453">                return true;</span>
            }
        });

<span class="fc" id="L2457">        c.blockingAwait();</span>
<span class="fc" id="L2458">    }</span>

    @Test(timeout = 5000)
    public void retryWhen5Times() {
<span class="fc" id="L2462">        final AtomicInteger calls = new AtomicInteger(5);</span>

<span class="fc" id="L2464">        Completable c = Completable.fromAction(new Action() {</span>
            @Override
            public void run() {
<span class="fc bfc" id="L2467" title="All 2 branches covered.">                if (calls.decrementAndGet() != 0) {</span>
<span class="fc" id="L2468">                    throw new TestException();</span>
                }
<span class="fc" id="L2470">            }</span>
<span class="fc" id="L2471">        }).retryWhen(new Function&lt;Flowable&lt;? extends Throwable&gt;, Publisher&lt;Object&gt;&gt;() {</span>
            @SuppressWarnings({ &quot;rawtypes&quot;, &quot;unchecked&quot; })
            @Override
            public Publisher&lt;Object&gt; apply(Flowable&lt;? extends Throwable&gt; f) {
<span class="fc" id="L2475">                return (Publisher)f;</span>
            }
        });

<span class="fc" id="L2479">        c.blockingAwait();</span>
<span class="fc" id="L2480">    }</span>

    @Test(timeout = 5000)
    public void subscribe() throws InterruptedException {
<span class="fc" id="L2484">        final AtomicBoolean complete = new AtomicBoolean();</span>

<span class="fc" id="L2486">        Completable c = normal.completable</span>
<span class="fc" id="L2487">                .delay(100, TimeUnit.MILLISECONDS)</span>
<span class="fc" id="L2488">                .doOnComplete(new Action() {</span>
                    @Override
                    public void run() {
<span class="fc" id="L2491">                        complete.set(true);</span>
<span class="fc" id="L2492">                    }</span>
                });

<span class="fc" id="L2495">        Disposable d = c.subscribe();</span>

<span class="fc" id="L2497">        assertFalse(d.isDisposed());</span>

<span class="fc" id="L2499">        Thread.sleep(150);</span>

<span class="fc" id="L2501">        Assert.assertTrue(&quot;Not completed&quot;, complete.get());</span>

<span class="fc" id="L2503">        assertTrue(d.isDisposed());</span>
<span class="fc" id="L2504">    }</span>

    @Test(timeout = 5000)
    public void subscribeDispose() throws InterruptedException {
<span class="fc" id="L2508">        final AtomicBoolean complete = new AtomicBoolean();</span>

<span class="fc" id="L2510">        Completable c = normal.completable</span>
<span class="fc" id="L2511">                .delay(200, TimeUnit.MILLISECONDS)</span>
<span class="fc" id="L2512">                .doOnComplete(new Action() {</span>
                    @Override
                    public void run() {
<span class="nc" id="L2515">                        complete.set(true);</span>
<span class="nc" id="L2516">                    }</span>
                });

<span class="fc" id="L2519">        Disposable d = c.subscribe();</span>

<span class="fc" id="L2521">        Thread.sleep(100);</span>

<span class="fc" id="L2523">        d.dispose();</span>

<span class="fc" id="L2525">        Thread.sleep(150);</span>

<span class="fc" id="L2527">        Assert.assertFalse(&quot;Completed&quot;, complete.get());</span>
<span class="fc" id="L2528">    }</span>

    @Test(timeout = 5000)
    public void subscribeTwoCallbacksNormal() {
<span class="fc" id="L2532">        final AtomicReference&lt;Throwable&gt; err = new AtomicReference&lt;Throwable&gt;();</span>
<span class="fc" id="L2533">        final AtomicBoolean complete = new AtomicBoolean();</span>
<span class="fc" id="L2534">        normal.completable.subscribe(new Action() {</span>
            @Override
            public void run() {
<span class="fc" id="L2537">                complete.set(true);</span>
<span class="fc" id="L2538">            }</span>
<span class="fc" id="L2539">        }, new Consumer&lt;Throwable&gt;() {</span>
            @Override
            public void accept(Throwable e) {
<span class="nc" id="L2542">                err.set(e);</span>
<span class="nc" id="L2543">            }</span>
        });

<span class="fc" id="L2546">        Assert.assertNull(err.get());</span>
<span class="fc" id="L2547">        Assert.assertTrue(&quot;Not completed&quot;, complete.get());</span>
<span class="fc" id="L2548">    }</span>

    @Test(timeout = 5000)
    public void subscribeTwoCallbacksError() {
<span class="fc" id="L2552">        final AtomicReference&lt;Throwable&gt; err = new AtomicReference&lt;Throwable&gt;();</span>
<span class="fc" id="L2553">        final AtomicBoolean complete = new AtomicBoolean();</span>
<span class="fc" id="L2554">        error.completable.subscribe(new Action() {</span>
            @Override
            public void run() {
<span class="nc" id="L2557">                complete.set(true);</span>
<span class="nc" id="L2558">            }</span>
<span class="fc" id="L2559">        }, new Consumer&lt;Throwable&gt;() {</span>
            @Override
            public void accept(Throwable e) {
<span class="fc" id="L2562">                err.set(e);</span>
<span class="fc" id="L2563">            }</span>
        });

<span class="fc" id="L2566">        Assert.assertTrue(err.get() instanceof TestException);</span>
<span class="fc" id="L2567">        Assert.assertFalse(&quot;Not completed&quot;, complete.get());</span>
<span class="fc" id="L2568">    }</span>

    @Test(expected = NullPointerException.class)
    public void subscribeTwoCallbacksFirstNull() {
<span class="pc" id="L2572">        normal.completable.subscribe(new Action() {</span>
            @Override
<span class="nc" id="L2574">            public void run() { }</span>
        }, null);
<span class="nc" id="L2576">    }</span>

    @Test(expected = NullPointerException.class)
    public void subscribeTwoCallbacksSecondNull() {
<span class="pc" id="L2580">        normal.completable.subscribe(new Action() {</span>
            @Override
<span class="nc" id="L2582">            public void run() { }</span>
        }, null);
<span class="nc" id="L2584">    }</span>

    @Test(timeout = 5000)
    public void subscribeTwoCallbacksCompleteThrows() {
<span class="fc" id="L2588">        List&lt;Throwable&gt; errors = TestHelper.trackPluginErrors();</span>
        try {
<span class="fc" id="L2590">            final AtomicReference&lt;Throwable&gt; err = new AtomicReference&lt;Throwable&gt;();</span>
<span class="fc" id="L2591">            normal.completable.subscribe(new Action() {</span>
                @Override
<span class="fc" id="L2593">                public void run() { throw new TestException(); }</span>
<span class="fc" id="L2594">            }, new Consumer&lt;Throwable&gt;() {</span>
                @Override
                public void accept(Throwable e) {
<span class="nc" id="L2597">                    err.set(e);</span>
<span class="nc" id="L2598">                }</span>
            });

<span class="fc" id="L2601">            Assert.assertNull(err.get());</span>
<span class="fc" id="L2602">            TestHelper.assertUndeliverable(errors, 0, TestException.class);</span>
        } finally {
<span class="fc" id="L2604">            RxJavaPlugins.reset();</span>
        }
<span class="fc" id="L2606">    }</span>

    @Test(timeout = 5000)
    public void subscribeTwoCallbacksOnErrorThrows() {
<span class="fc" id="L2610">        List&lt;Throwable&gt; errors = TestHelper.trackPluginErrors();</span>
        try {
<span class="fc" id="L2612">            error.completable.subscribe(new Action() {</span>
                @Override
<span class="nc" id="L2614">                public void run() { }</span>
<span class="fc" id="L2615">            }, new Consumer&lt;Throwable&gt;() {</span>
                @Override
<span class="fc" id="L2617">                public void accept(Throwable e) { throw new TestException(); }</span>
            });

<span class="fc" id="L2620">            TestHelper.assertUndeliverable(errors, 0, TestException.class);</span>
        } finally {
<span class="fc" id="L2622">            RxJavaPlugins.reset();</span>
        }
<span class="fc" id="L2624">    }</span>

    @Test(timeout = 5000)
    public void subscribeObserverNormal() {
<span class="fc" id="L2628">        TestObserver&lt;Object&gt; to = new TestObserver&lt;Object&gt;();</span>

<span class="fc" id="L2630">        normal.completable.toObservable().subscribe(to);</span>

<span class="fc" id="L2632">        to.assertComplete();</span>
<span class="fc" id="L2633">        to.assertNoValues();</span>
<span class="fc" id="L2634">        to.assertNoErrors();</span>
<span class="fc" id="L2635">    }</span>

    @Test(timeout = 5000)
    public void subscribeObserverError() {
<span class="fc" id="L2639">        TestObserver&lt;Object&gt; to = new TestObserver&lt;Object&gt;();</span>

<span class="fc" id="L2641">        error.completable.toObservable().subscribe(to);</span>

<span class="fc" id="L2643">        to.assertNotComplete();</span>
<span class="fc" id="L2644">        to.assertNoValues();</span>
<span class="fc" id="L2645">        to.assertError(TestException.class);</span>
<span class="fc" id="L2646">    }</span>

    @Test(timeout = 5000)
    public void subscribeActionNormal() {
<span class="fc" id="L2650">        final AtomicBoolean run = new AtomicBoolean();</span>

<span class="fc" id="L2652">        normal.completable.subscribe(new Action() {</span>
            @Override
            public void run() {
<span class="fc" id="L2655">                run.set(true);</span>
<span class="fc" id="L2656">            }</span>
        });

<span class="fc" id="L2659">        Assert.assertTrue(&quot;Not completed&quot;, run.get());</span>
<span class="fc" id="L2660">    }</span>

    @Test(timeout = 5000)
    public void subscribeActionError() {
<span class="fc" id="L2664">        List&lt;Throwable&gt; errors = TestHelper.trackPluginErrors();</span>
        try {
<span class="fc" id="L2666">            final AtomicBoolean run = new AtomicBoolean();</span>

<span class="fc" id="L2668">            error.completable.subscribe(new Action() {</span>
                @Override
                public void run() {
<span class="nc" id="L2671">                    run.set(true);</span>
<span class="nc" id="L2672">                }</span>
            });

<span class="fc" id="L2675">            Assert.assertFalse(&quot;Completed&quot;, run.get());</span>

<span class="fc" id="L2677">            TestHelper.assertError(errors, 0, OnErrorNotImplementedException.class);</span>
        } finally {
<span class="fc" id="L2679">            RxJavaPlugins.reset();</span>
        }
<span class="fc" id="L2681">    }</span>

    @Test(expected = NullPointerException.class)
    public void subscribeActionNull() {
<span class="nc" id="L2685">        normal.completable.subscribe((Action)null);</span>
<span class="nc" id="L2686">    }</span>

    @Test(expected = NullPointerException.class)
    public void subscribeSubscriberNull() {
<span class="nc" id="L2690">        normal.completable.toFlowable().subscribe((Subscriber&lt;Object&gt;)null);</span>
<span class="nc" id="L2691">    }</span>

    @Test(expected = NullPointerException.class)
    public void subscribeObserverNull() {
<span class="nc" id="L2695">        normal.completable.toObservable().subscribe((Observer&lt;Object&gt;)null);</span>
<span class="nc" id="L2696">    }</span>

    @Test(expected = NullPointerException.class)
    public void subscribeCompletableSubscriberNull() {
<span class="nc" id="L2700">        normal.completable.subscribe((CompletableObserver)null);</span>
<span class="nc" id="L2701">    }</span>

    @Test(timeout = 5000)
    public void subscribeSubscriberNormal() {
<span class="fc" id="L2705">        TestSubscriber&lt;Object&gt; ts = new TestSubscriber&lt;Object&gt;();</span>

<span class="fc" id="L2707">        normal.completable.toFlowable().subscribe(ts);</span>

<span class="fc" id="L2709">        ts.assertComplete();</span>
<span class="fc" id="L2710">        ts.assertNoValues();</span>
<span class="fc" id="L2711">        ts.assertNoErrors();</span>
<span class="fc" id="L2712">    }</span>

    @Test(timeout = 5000)
    public void subscribeSubscriberError() {
<span class="fc" id="L2716">        TestSubscriber&lt;Object&gt; ts = new TestSubscriber&lt;Object&gt;();</span>

<span class="fc" id="L2718">        error.completable.toFlowable().subscribe(ts);</span>

<span class="fc" id="L2720">        ts.assertNotComplete();</span>
<span class="fc" id="L2721">        ts.assertNoValues();</span>
<span class="fc" id="L2722">        ts.assertError(TestException.class);</span>
<span class="fc" id="L2723">    }</span>

    @Test(expected = NullPointerException.class)
    public void subscribeOnNull() {
<span class="nc" id="L2727">        normal.completable.subscribeOn(null);</span>
<span class="nc" id="L2728">    }</span>

    @Test(timeout = 5000)
    public void subscribeOnNormal() {
<span class="fc" id="L2732">        final AtomicReference&lt;String&gt; name = new  AtomicReference&lt;String&gt;();</span>

<span class="fc" id="L2734">        Completable c = Completable.unsafeCreate(new CompletableSource() {</span>
            @Override
            public void subscribe(CompletableObserver observer) {
<span class="fc" id="L2737">                name.set(Thread.currentThread().getName());</span>
<span class="fc" id="L2738">                EmptyDisposable.complete(observer);</span>
<span class="fc" id="L2739">            }</span>
<span class="fc" id="L2740">        }).subscribeOn(Schedulers.computation());</span>

<span class="fc" id="L2742">        c.blockingAwait();</span>

<span class="fc" id="L2744">        Assert.assertTrue(name.get().startsWith(&quot;RxComputation&quot;));</span>
<span class="fc" id="L2745">    }</span>

    @Test(timeout = 5000)
    public void subscribeOnError() {
<span class="fc" id="L2749">        final AtomicReference&lt;String&gt; name = new  AtomicReference&lt;String&gt;();</span>

<span class="fc" id="L2751">        Completable c = Completable.unsafeCreate(new CompletableSource() {</span>
            @Override
            public void subscribe(CompletableObserver observer) {
<span class="fc" id="L2754">                name.set(Thread.currentThread().getName());</span>
<span class="fc" id="L2755">                EmptyDisposable.error(new TestException(), observer);</span>
<span class="fc" id="L2756">            }</span>
<span class="fc" id="L2757">        }).subscribeOn(Schedulers.computation());</span>

        try {
<span class="nc" id="L2760">            c.blockingAwait();</span>
<span class="nc" id="L2761">            Assert.fail(&quot;No exception thrown&quot;);</span>
<span class="fc" id="L2762">        } catch (TestException ex) {</span>
            // expected
<span class="nc" id="L2764">        }</span>

<span class="fc" id="L2766">        Assert.assertTrue(name.get().startsWith(&quot;RxComputation&quot;));</span>
<span class="fc" id="L2767">    }</span>

    @Test(timeout = 5000)
    public void timeoutEmitError() {
<span class="fc" id="L2771">        Throwable e = Completable.never().timeout(100, TimeUnit.MILLISECONDS).blockingGet();</span>

<span class="fc" id="L2773">        Assert.assertTrue(e instanceof TimeoutException);</span>
<span class="fc" id="L2774">    }</span>

    @Test(timeout = 5000)
    public void timeoutSwitchNormal() {
<span class="fc" id="L2778">        Completable c = Completable.never().timeout(100, TimeUnit.MILLISECONDS, normal.completable);</span>

<span class="fc" id="L2780">        c.blockingAwait();</span>

<span class="fc" id="L2782">        normal.assertSubscriptions(1);</span>
<span class="fc" id="L2783">    }</span>

    @Test(timeout = 5000)
    public void timeoutTimerCancelled() throws InterruptedException {
<span class="fc" id="L2787">        Completable c = Completable.fromCallable(new Callable&lt;Object&gt;() {</span>
            @Override
            public Object call() throws Exception {
<span class="fc" id="L2790">                Thread.sleep(50);</span>
<span class="fc" id="L2791">                return null;</span>
            }
<span class="fc" id="L2793">        }).timeout(100, TimeUnit.MILLISECONDS, normal.completable);</span>

<span class="fc" id="L2795">        c.blockingAwait();</span>

<span class="fc" id="L2797">        Thread.sleep(100);</span>

<span class="fc" id="L2799">        normal.assertSubscriptions(0);</span>
<span class="fc" id="L2800">    }</span>

    @Test(expected = NullPointerException.class)
    public void timeoutUnitNull() {
<span class="nc" id="L2804">        normal.completable.timeout(1, null);</span>
<span class="nc" id="L2805">    }</span>

    @Test(expected = NullPointerException.class)
    public void timeoutSchedulerNull() {
<span class="nc" id="L2809">        normal.completable.timeout(1, TimeUnit.SECONDS, (Scheduler)null);</span>
<span class="nc" id="L2810">    }</span>

    @Test(expected = NullPointerException.class)
    public void timeoutOtherNull() {
<span class="nc" id="L2814">        normal.completable.timeout(1, TimeUnit.SECONDS, (Completable)null);</span>
<span class="nc" id="L2815">    }</span>

    @Test(timeout = 5000)
    public void toNormal() {
<span class="fc" id="L2819">        normal.completable</span>
<span class="fc" id="L2820">                .to(new Function&lt;Completable, Flowable&lt;Object&gt;&gt;() {</span>
                    @Override
                    public Flowable&lt;Object&gt; apply(Completable c) {
<span class="fc" id="L2823">                        return c.toFlowable();</span>
                    }
                })
<span class="fc" id="L2826">                .test()</span>
<span class="fc" id="L2827">                .assertComplete()</span>
<span class="fc" id="L2828">                .assertNoValues();</span>
<span class="fc" id="L2829">    }</span>

    @Test(timeout = 5000)
    public void asNormal() {
<span class="fc" id="L2833">        normal.completable</span>
<span class="fc" id="L2834">                .as(new CompletableConverter&lt;Flowable&lt;Object&gt;&gt;() {</span>
                    @Override
                    public Flowable&lt;Object&gt; apply(Completable c) {
<span class="fc" id="L2837">                        return c.toFlowable();</span>
                    }
                })
<span class="fc" id="L2840">                .test()</span>
<span class="fc" id="L2841">                .assertComplete()</span>
<span class="fc" id="L2842">                .assertNoValues();</span>
<span class="fc" id="L2843">    }</span>

    @Test
    public void as() {
<span class="fc" id="L2847">        Completable.complete().as(new CompletableConverter&lt;Flowable&lt;Integer&gt;&gt;() {</span>
            @Override
            public Flowable&lt;Integer&gt; apply(Completable v) {
<span class="fc" id="L2850">                return v.toFlowable();</span>
            }
        })
<span class="fc" id="L2853">        .test()</span>
<span class="fc" id="L2854">        .assertComplete();</span>
<span class="fc" id="L2855">    }</span>

    @Test(expected = NullPointerException.class)
    public void toNull() {
<span class="nc" id="L2859">        normal.completable.to(null);</span>
<span class="nc" id="L2860">    }</span>

    @Test(expected = NullPointerException.class)
    public void asNull() {
<span class="nc" id="L2864">        normal.completable.as(null);</span>
<span class="nc" id="L2865">    }</span>

    @Test(timeout = 5000)
    public void toFlowableNormal() {
<span class="fc" id="L2869">        normal.completable.toFlowable().blockingForEach(Functions.emptyConsumer());</span>
<span class="fc" id="L2870">    }</span>

    @Test(timeout = 5000, expected = TestException.class)
    public void toFlowableError() {
<span class="nc" id="L2874">        error.completable.toFlowable().blockingForEach(Functions.emptyConsumer());</span>
<span class="nc" id="L2875">    }</span>

    @Test(timeout = 5000)
    public void toObservableNormal() {
<span class="fc" id="L2879">        normal.completable.toObservable().blockingForEach(Functions.emptyConsumer());</span>
<span class="fc" id="L2880">    }</span>

    @Test(timeout = 5000, expected = TestException.class)
    public void toObservableError() {
<span class="nc" id="L2884">        error.completable.toObservable().blockingForEach(Functions.emptyConsumer());</span>
<span class="nc" id="L2885">    }</span>

    @Test(timeout = 5000)
    public void toSingleSupplierNormal() {
<span class="fc" id="L2889">        Assert.assertEquals(1, normal.completable.toSingle(new Callable&lt;Object&gt;() {</span>
            @Override
            public Object call() {
<span class="fc" id="L2892">                return 1;</span>
            }
<span class="fc" id="L2894">        }).blockingGet());</span>
<span class="fc" id="L2895">    }</span>

    @Test(timeout = 5000, expected = TestException.class)
    public void toSingleSupplierError() {
<span class="fc" id="L2899">        error.completable.toSingle(new Callable&lt;Object&gt;() {</span>
            @Override
            public Object call() {
<span class="nc" id="L2902">                return 1;</span>
            }
<span class="nc" id="L2904">        }).blockingGet();</span>
<span class="nc" id="L2905">    }</span>

    @Test(expected = NullPointerException.class)
    public void toSingleSupplierNull() {
<span class="nc" id="L2909">        normal.completable.toSingle(null);</span>
<span class="nc" id="L2910">    }</span>

    @Test(expected = NullPointerException.class)
    public void toSingleSupplierReturnsNull() {
<span class="fc" id="L2914">        normal.completable.toSingle(new Callable&lt;Object&gt;() {</span>
            @Override
            public Object call() {
<span class="fc" id="L2917">                return null;</span>
            }
<span class="nc" id="L2919">        }).blockingGet();</span>
<span class="nc" id="L2920">    }</span>

    @Test(expected = TestException.class)
    public void toSingleSupplierThrows() {
<span class="fc" id="L2924">        normal.completable.toSingle(new Callable&lt;Object&gt;() {</span>
            @Override
<span class="fc" id="L2926">            public Object call() { throw new TestException(); }</span>
<span class="nc" id="L2927">        }).blockingGet();</span>
<span class="nc" id="L2928">    }</span>

    @Test(timeout = 5000, expected = TestException.class)
    public void toSingleDefaultError() {
<span class="nc" id="L2932">        error.completable.toSingleDefault(1).blockingGet();</span>
<span class="nc" id="L2933">    }</span>

    @Test(timeout = 5000)
    public void toSingleDefaultNormal() {
<span class="fc" id="L2937">        Assert.assertEquals((Integer)1, normal.completable.toSingleDefault(1).blockingGet());</span>
<span class="fc" id="L2938">    }</span>

    @Test(expected = NullPointerException.class)
    public void toSingleDefaultNull() {
<span class="nc" id="L2942">        normal.completable.toSingleDefault(null);</span>
<span class="nc" id="L2943">    }</span>

    @Test(timeout = 5000)
    public void unsubscribeOnNormal() throws InterruptedException {
<span class="fc" id="L2947">        final AtomicReference&lt;String&gt; name = new AtomicReference&lt;String&gt;();</span>
<span class="fc" id="L2948">        final CountDownLatch cdl = new CountDownLatch(1);</span>

<span class="fc" id="L2950">        normal.completable.delay(1, TimeUnit.SECONDS)</span>
<span class="fc" id="L2951">        .doOnDispose(new Action() {</span>
            @Override
            public void run() {
<span class="fc" id="L2954">                name.set(Thread.currentThread().getName());</span>
<span class="fc" id="L2955">                cdl.countDown();</span>
<span class="fc" id="L2956">            }</span>
        })
<span class="fc" id="L2958">        .unsubscribeOn(Schedulers.computation())</span>
<span class="fc" id="L2959">        .subscribe(new CompletableObserver() {</span>
            @Override
            public void onSubscribe(final Disposable d) {
<span class="fc" id="L2962">                Schedulers.single().scheduleDirect(new Runnable() {</span>
                    @Override
                    public void run() {
<span class="fc" id="L2965">                        d.dispose();</span>
<span class="fc" id="L2966">                    }</span>
                }, 100, TimeUnit.MILLISECONDS);
<span class="fc" id="L2968">            }</span>

            @Override
            public void onError(Throwable e) {

<span class="nc" id="L2973">            }</span>

            @Override
            public void onComplete() {

<span class="nc" id="L2978">            }</span>
        });

<span class="fc" id="L2981">        cdl.await();</span>

<span class="fc" id="L2983">        Assert.assertTrue(name.get().startsWith(&quot;RxComputation&quot;));</span>
<span class="fc" id="L2984">    }</span>

    @Test(expected = NullPointerException.class)
    public void ambArrayNull() {
<span class="nc" id="L2988">        Completable.ambArray((Completable[])null);</span>
<span class="nc" id="L2989">    }</span>

    @Test(timeout = 5000)
    public void ambArrayEmpty() {
<span class="fc" id="L2993">        Completable c = Completable.ambArray();</span>

<span class="fc" id="L2995">        c.blockingAwait();</span>
<span class="fc" id="L2996">    }</span>

    @Test(timeout = 5000)
    public void ambArraySingleNormal() {
<span class="fc" id="L3000">        Completable c = Completable.ambArray(normal.completable);</span>

<span class="fc" id="L3002">        c.blockingAwait();</span>
<span class="fc" id="L3003">    }</span>

    @Test(timeout = 5000)
    public void ambArraySingleError() {
<span class="fc" id="L3007">        Completable.ambArray(error.completable)</span>
<span class="fc" id="L3008">                .test()</span>
<span class="fc" id="L3009">                .assertError(TestException.class);</span>
<span class="fc" id="L3010">    }</span>

    @Test(timeout = 5000)
    public void ambArrayOneFires() {
<span class="fc" id="L3014">        PublishProcessor&lt;Object&gt; pp1 = PublishProcessor.create();</span>
<span class="fc" id="L3015">        PublishProcessor&lt;Object&gt; pp2 = PublishProcessor.create();</span>

<span class="fc" id="L3017">        Completable c1 = Completable.fromPublisher(pp1);</span>

<span class="fc" id="L3019">        Completable c2 = Completable.fromPublisher(pp2);</span>

<span class="fc" id="L3021">        Completable c = Completable.ambArray(c1, c2);</span>

<span class="fc" id="L3023">        final AtomicBoolean complete = new AtomicBoolean();</span>

<span class="fc" id="L3025">        c.subscribe(new Action() {</span>
            @Override
            public void run() {
<span class="fc" id="L3028">                complete.set(true);</span>
<span class="fc" id="L3029">            }</span>
        });

<span class="fc" id="L3032">        Assert.assertTrue(&quot;First subject no subscribers&quot;, pp1.hasSubscribers());</span>
<span class="fc" id="L3033">        Assert.assertTrue(&quot;Second subject no subscribers&quot;, pp2.hasSubscribers());</span>

<span class="fc" id="L3035">        pp1.onComplete();</span>

<span class="fc" id="L3037">        Assert.assertFalse(&quot;First subject has subscribers&quot;, pp1.hasSubscribers());</span>
<span class="fc" id="L3038">        Assert.assertFalse(&quot;Second subject has subscribers&quot;, pp2.hasSubscribers());</span>

<span class="fc" id="L3040">        Assert.assertTrue(&quot;Not completed&quot;, complete.get());</span>
<span class="fc" id="L3041">    }</span>

    @Test(timeout = 5000)
    public void ambArrayOneFiresError() {
<span class="fc" id="L3045">        PublishProcessor&lt;Object&gt; pp1 = PublishProcessor.create();</span>
<span class="fc" id="L3046">        PublishProcessor&lt;Object&gt; pp2 = PublishProcessor.create();</span>

<span class="fc" id="L3048">        Completable c1 = Completable.fromPublisher(pp1);</span>

<span class="fc" id="L3050">        Completable c2 = Completable.fromPublisher(pp2);</span>

<span class="fc" id="L3052">        Completable c = Completable.ambArray(c1, c2);</span>

<span class="fc" id="L3054">        final AtomicReference&lt;Throwable&gt; complete = new AtomicReference&lt;Throwable&gt;();</span>

<span class="fc" id="L3056">        c.subscribe(Functions.EMPTY_ACTION, new Consumer&lt;Throwable&gt;() {</span>
            @Override
            public void accept(Throwable v) {
<span class="fc" id="L3059">                complete.set(v);</span>
<span class="fc" id="L3060">            }</span>
        });

<span class="fc" id="L3063">        Assert.assertTrue(&quot;First subject no subscribers&quot;, pp1.hasSubscribers());</span>
<span class="fc" id="L3064">        Assert.assertTrue(&quot;Second subject no subscribers&quot;, pp2.hasSubscribers());</span>

<span class="fc" id="L3066">        pp1.onError(new TestException());</span>

<span class="fc" id="L3068">        Assert.assertFalse(&quot;First subject has subscribers&quot;, pp1.hasSubscribers());</span>
<span class="fc" id="L3069">        Assert.assertFalse(&quot;Second subject has subscribers&quot;, pp2.hasSubscribers());</span>

<span class="fc" id="L3071">        Assert.assertTrue(&quot;Not completed&quot;, complete.get() instanceof TestException);</span>
<span class="fc" id="L3072">    }</span>

    @Test(timeout = 5000)
    public void ambArraySecondFires() {
<span class="fc" id="L3076">        PublishProcessor&lt;Object&gt; pp1 = PublishProcessor.create();</span>
<span class="fc" id="L3077">        PublishProcessor&lt;Object&gt; pp2 = PublishProcessor.create();</span>

<span class="fc" id="L3079">        Completable c1 = Completable.fromPublisher(pp1);</span>

<span class="fc" id="L3081">        Completable c2 = Completable.fromPublisher(pp2);</span>

<span class="fc" id="L3083">        Completable c = Completable.ambArray(c1, c2);</span>

<span class="fc" id="L3085">        final AtomicBoolean complete = new AtomicBoolean();</span>

<span class="fc" id="L3087">        c.subscribe(new Action() {</span>
            @Override
            public void run() {
<span class="fc" id="L3090">                complete.set(true);</span>
<span class="fc" id="L3091">            }</span>
        });

<span class="fc" id="L3094">        Assert.assertTrue(&quot;First subject no subscribers&quot;, pp1.hasSubscribers());</span>
<span class="fc" id="L3095">        Assert.assertTrue(&quot;Second subject no subscribers&quot;, pp2.hasSubscribers());</span>

<span class="fc" id="L3097">        pp2.onComplete();</span>

<span class="fc" id="L3099">        Assert.assertFalse(&quot;First subject has subscribers&quot;, pp1.hasSubscribers());</span>
<span class="fc" id="L3100">        Assert.assertFalse(&quot;Second subject has subscribers&quot;, pp2.hasSubscribers());</span>

<span class="fc" id="L3102">        Assert.assertTrue(&quot;Not completed&quot;, complete.get());</span>
<span class="fc" id="L3103">    }</span>

    @Test(timeout = 5000)
    public void ambArraySecondFiresError() {
<span class="fc" id="L3107">        PublishProcessor&lt;Object&gt; pp1 = PublishProcessor.create();</span>
<span class="fc" id="L3108">        PublishProcessor&lt;Object&gt; pp2 = PublishProcessor.create();</span>

<span class="fc" id="L3110">        Completable c1 = Completable.fromPublisher(pp1);</span>

<span class="fc" id="L3112">        Completable c2 = Completable.fromPublisher(pp2);</span>

<span class="fc" id="L3114">        Completable c = Completable.ambArray(c1, c2);</span>

<span class="fc" id="L3116">        final AtomicReference&lt;Throwable&gt; complete = new AtomicReference&lt;Throwable&gt;();</span>

<span class="fc" id="L3118">        c.subscribe(Functions.EMPTY_ACTION, new Consumer&lt;Throwable&gt;() {</span>
            @Override
            public void accept(Throwable v) {
<span class="fc" id="L3121">                complete.set(v);</span>
<span class="fc" id="L3122">            }</span>
        });

<span class="fc" id="L3125">        Assert.assertTrue(&quot;First subject no subscribers&quot;, pp1.hasSubscribers());</span>
<span class="fc" id="L3126">        Assert.assertTrue(&quot;Second subject no subscribers&quot;, pp2.hasSubscribers());</span>

<span class="fc" id="L3128">        pp2.onError(new TestException());</span>

<span class="fc" id="L3130">        Assert.assertFalse(&quot;First subject has subscribers&quot;, pp1.hasSubscribers());</span>
<span class="fc" id="L3131">        Assert.assertFalse(&quot;Second subject has subscribers&quot;, pp2.hasSubscribers());</span>

<span class="fc" id="L3133">        Assert.assertTrue(&quot;Not completed&quot;, complete.get() instanceof TestException);</span>
<span class="fc" id="L3134">    }</span>

    @Test(timeout = 5000)
    public void ambMultipleOneIsNull() {
<span class="fc" id="L3138">        Completable.ambArray(null, normal.completable)</span>
<span class="fc" id="L3139">                .test()</span>
<span class="fc" id="L3140">                .assertError(NullPointerException.class);</span>
<span class="fc" id="L3141">    }</span>

    @Test(timeout = 5000)
    public void ambIterableEmpty() {
<span class="fc" id="L3145">        Completable c = Completable.amb(Collections.&lt;Completable&gt;emptyList());</span>

<span class="fc" id="L3147">        c.blockingAwait();</span>
<span class="fc" id="L3148">    }</span>

    @Test(expected = NullPointerException.class)
    public void ambIterableNull() {
<span class="nc" id="L3152">        Completable.amb((Iterable&lt;Completable&gt;)null);</span>
<span class="nc" id="L3153">    }</span>

    @Test(timeout = 5000)
    public void ambIterableIteratorNull() {
<span class="fc" id="L3157">        Completable.amb(new Iterable&lt;Completable&gt;() {</span>
            @Override
            public Iterator&lt;Completable&gt; iterator() {
<span class="fc" id="L3160">                return null;</span>
            }
<span class="fc" id="L3162">        }).test().assertError(NullPointerException.class);</span>
<span class="fc" id="L3163">    }</span>

    @Test(timeout = 5000)
    public void ambIterableWithNull() {
<span class="fc" id="L3167">        Completable.amb(Arrays.asList(null, normal.completable))</span>
<span class="fc" id="L3168">            .test()</span>
<span class="fc" id="L3169">            .assertError(NullPointerException.class);</span>
<span class="fc" id="L3170">    }</span>

    @Test(timeout = 5000)
    public void ambIterableSingle() {
<span class="fc" id="L3174">        Completable c = Completable.amb(Collections.singleton(normal.completable));</span>

<span class="fc" id="L3176">        c.blockingAwait();</span>

<span class="fc" id="L3178">        normal.assertSubscriptions(1);</span>
<span class="fc" id="L3179">    }</span>

    @Test(timeout = 5000)
    public void ambIterableMany() {
<span class="fc" id="L3183">        Completable c = Completable.amb(Arrays.asList(normal.completable, normal.completable, normal.completable));</span>

<span class="fc" id="L3185">        c.blockingAwait();</span>

<span class="fc" id="L3187">        normal.assertSubscriptions(1);</span>
<span class="fc" id="L3188">    }</span>

    @Test(timeout = 5000)
    public void ambIterableOneThrows() {
<span class="fc" id="L3192">        Completable.amb(Collections.singleton(error.completable))</span>
<span class="fc" id="L3193">                .test()</span>
<span class="fc" id="L3194">                .assertError(TestException.class);</span>
<span class="fc" id="L3195">    }</span>

    @Test(timeout = 5000)
    public void ambIterableManyOneThrows() {
<span class="fc" id="L3199">        Completable.amb(Arrays.asList(error.completable, normal.completable))</span>
<span class="fc" id="L3200">                .test()</span>
<span class="fc" id="L3201">                .assertError(TestException.class);</span>
<span class="fc" id="L3202">    }</span>

    @Test
    public void ambIterableIterableThrows() {
<span class="fc" id="L3206">        Completable.amb(new Iterable&lt;Completable&gt;() {</span>
            @Override
            public Iterator&lt;Completable&gt; iterator() {
<span class="fc" id="L3209">                throw new TestException();</span>
            }
<span class="fc" id="L3211">        }).test().assertError(TestException.class);</span>
<span class="fc" id="L3212">    }</span>

    @Test
    public void ambIterableIteratorHasNextThrows() {
<span class="fc" id="L3216">        Completable.amb(new IterableIteratorHasNextThrows())</span>
<span class="fc" id="L3217">                .test()</span>
<span class="fc" id="L3218">                .assertError(TestException.class);</span>
<span class="fc" id="L3219">    }</span>

    @Test
    public void ambIterableIteratorNextThrows() {
<span class="fc" id="L3223">        Completable.amb(new IterableIteratorNextThrows())</span>
<span class="fc" id="L3224">                .test()</span>
<span class="fc" id="L3225">                .assertError(TestException.class);</span>
<span class="fc" id="L3226">    }</span>

    @Test(expected = NullPointerException.class)
    public void ambWithNull() {
<span class="nc" id="L3230">        normal.completable.ambWith(null);</span>
<span class="nc" id="L3231">    }</span>

    @Test(timeout = 5000)
    public void ambWithArrayOneFires() {
<span class="fc" id="L3235">        PublishProcessor&lt;Object&gt; pp1 = PublishProcessor.create();</span>
<span class="fc" id="L3236">        PublishProcessor&lt;Object&gt; pp2 = PublishProcessor.create();</span>

<span class="fc" id="L3238">        Completable c1 = Completable.fromPublisher(pp1);</span>

<span class="fc" id="L3240">        Completable c2 = Completable.fromPublisher(pp2);</span>

<span class="fc" id="L3242">        Completable c = c1.ambWith(c2);</span>

<span class="fc" id="L3244">        final AtomicBoolean complete = new AtomicBoolean();</span>

<span class="fc" id="L3246">        c.subscribe(new Action() {</span>
            @Override
            public void run() {
<span class="fc" id="L3249">                complete.set(true);</span>
<span class="fc" id="L3250">            }</span>
        });

<span class="fc" id="L3253">        Assert.assertTrue(&quot;First subject no subscribers&quot;, pp1.hasSubscribers());</span>
<span class="fc" id="L3254">        Assert.assertTrue(&quot;Second subject no subscribers&quot;, pp2.hasSubscribers());</span>

<span class="fc" id="L3256">        pp1.onComplete();</span>

<span class="fc" id="L3258">        Assert.assertFalse(&quot;First subject has subscribers&quot;, pp1.hasSubscribers());</span>
<span class="fc" id="L3259">        Assert.assertFalse(&quot;Second subject has subscribers&quot;, pp2.hasSubscribers());</span>

<span class="fc" id="L3261">        Assert.assertTrue(&quot;Not completed&quot;, complete.get());</span>
<span class="fc" id="L3262">    }</span>

    @Test(timeout = 5000)
    public void ambWithArrayOneFiresError() {
<span class="fc" id="L3266">        PublishProcessor&lt;Object&gt; pp1 = PublishProcessor.create();</span>
<span class="fc" id="L3267">        PublishProcessor&lt;Object&gt; pp2 = PublishProcessor.create();</span>

<span class="fc" id="L3269">        Completable c1 = Completable.fromPublisher(pp1);</span>

<span class="fc" id="L3271">        Completable c2 = Completable.fromPublisher(pp2);</span>

<span class="fc" id="L3273">        Completable c = c1.ambWith(c2);</span>

<span class="fc" id="L3275">        final AtomicReference&lt;Throwable&gt; complete = new AtomicReference&lt;Throwable&gt;();</span>

<span class="fc" id="L3277">        c.subscribe(Functions.EMPTY_ACTION, new Consumer&lt;Throwable&gt;() {</span>
            @Override
            public void accept(Throwable v) {
<span class="fc" id="L3280">                complete.set(v);</span>
<span class="fc" id="L3281">            }</span>
        });

<span class="fc" id="L3284">        Assert.assertTrue(&quot;First subject no subscribers&quot;, pp1.hasSubscribers());</span>
<span class="fc" id="L3285">        Assert.assertTrue(&quot;Second subject no subscribers&quot;, pp2.hasSubscribers());</span>

<span class="fc" id="L3287">        pp1.onError(new TestException());</span>

<span class="fc" id="L3289">        Assert.assertFalse(&quot;First subject has subscribers&quot;, pp1.hasSubscribers());</span>
<span class="fc" id="L3290">        Assert.assertFalse(&quot;Second subject has subscribers&quot;, pp2.hasSubscribers());</span>

<span class="fc" id="L3292">        Assert.assertTrue(&quot;Not completed&quot;, complete.get() instanceof TestException);</span>
<span class="fc" id="L3293">    }</span>

    @Test(timeout = 5000)
    public void ambWithArraySecondFires() {
<span class="fc" id="L3297">        PublishProcessor&lt;Object&gt; pp1 = PublishProcessor.create();</span>
<span class="fc" id="L3298">        PublishProcessor&lt;Object&gt; pp2 = PublishProcessor.create();</span>

<span class="fc" id="L3300">        Completable c1 = Completable.fromPublisher(pp1);</span>

<span class="fc" id="L3302">        Completable c2 = Completable.fromPublisher(pp2);</span>

<span class="fc" id="L3304">        Completable c = c1.ambWith(c2);</span>

<span class="fc" id="L3306">        final AtomicBoolean complete = new AtomicBoolean();</span>

<span class="fc" id="L3308">        c.subscribe(new Action() {</span>
            @Override
            public void run() {
<span class="fc" id="L3311">                complete.set(true);</span>
<span class="fc" id="L3312">            }</span>
        });

<span class="fc" id="L3315">        Assert.assertTrue(&quot;First subject no subscribers&quot;, pp1.hasSubscribers());</span>
<span class="fc" id="L3316">        Assert.assertTrue(&quot;Second subject no subscribers&quot;, pp2.hasSubscribers());</span>

<span class="fc" id="L3318">        pp2.onComplete();</span>

<span class="fc" id="L3320">        Assert.assertFalse(&quot;First subject has subscribers&quot;, pp1.hasSubscribers());</span>
<span class="fc" id="L3321">        Assert.assertFalse(&quot;Second subject has subscribers&quot;, pp2.hasSubscribers());</span>

<span class="fc" id="L3323">        Assert.assertTrue(&quot;Not completed&quot;, complete.get());</span>
<span class="fc" id="L3324">    }</span>

    @Test(timeout = 5000)
    public void ambWithArraySecondFiresError() {
<span class="fc" id="L3328">        PublishProcessor&lt;Object&gt; pp1 = PublishProcessor.create();</span>
<span class="fc" id="L3329">        PublishProcessor&lt;Object&gt; pp2 = PublishProcessor.create();</span>

<span class="fc" id="L3331">        Completable c1 = Completable.fromPublisher(pp1);</span>

<span class="fc" id="L3333">        Completable c2 = Completable.fromPublisher(pp2);</span>

<span class="fc" id="L3335">        Completable c = c1.ambWith(c2);</span>

<span class="fc" id="L3337">        final AtomicReference&lt;Throwable&gt; complete = new AtomicReference&lt;Throwable&gt;();</span>

<span class="fc" id="L3339">        c.subscribe(Functions.EMPTY_ACTION, new Consumer&lt;Throwable&gt;() {</span>
            @Override
            public void accept(Throwable v) {
<span class="fc" id="L3342">                complete.set(v);</span>
<span class="fc" id="L3343">            }</span>
        });

<span class="fc" id="L3346">        Assert.assertTrue(&quot;First subject no subscribers&quot;, pp1.hasSubscribers());</span>
<span class="fc" id="L3347">        Assert.assertTrue(&quot;Second subject no subscribers&quot;, pp2.hasSubscribers());</span>

<span class="fc" id="L3349">        pp2.onError(new TestException());</span>

<span class="fc" id="L3351">        Assert.assertFalse(&quot;First subject has subscribers&quot;, pp1.hasSubscribers());</span>
<span class="fc" id="L3352">        Assert.assertFalse(&quot;Second subject has subscribers&quot;, pp2.hasSubscribers());</span>

<span class="fc" id="L3354">        Assert.assertTrue(&quot;Not completed&quot;, complete.get() instanceof TestException);</span>
<span class="fc" id="L3355">    }</span>

    @Test(timeout = 5000)
    public void startWithCompletableNormal() {
<span class="fc" id="L3359">        final AtomicBoolean run = new AtomicBoolean();</span>
<span class="fc" id="L3360">        Completable c = normal.completable</span>
<span class="fc" id="L3361">                .startWith(Completable.fromCallable(new Callable&lt;Object&gt;() {</span>
                    @Override
                    public Object call() throws Exception {
<span class="pc bpc" id="L3364" title="1 of 2 branches missed.">                        run.set(normal.get() == 0);</span>
<span class="fc" id="L3365">                        return null;</span>
                    }
                }));

<span class="fc" id="L3369">        c.blockingAwait();</span>

<span class="fc" id="L3371">        Assert.assertTrue(&quot;Did not start with other&quot;, run.get());</span>
<span class="fc" id="L3372">        normal.assertSubscriptions(1);</span>
<span class="fc" id="L3373">    }</span>

    @Test(timeout = 5000)
    public void startWithCompletableError() {
<span class="fc" id="L3377">        Completable c = normal.completable.startWith(error.completable);</span>

        try {
<span class="nc" id="L3380">            c.blockingAwait();</span>
<span class="nc" id="L3381">            Assert.fail(&quot;Did not throw TestException&quot;);</span>
<span class="fc" id="L3382">        } catch (TestException ex) {</span>
<span class="fc" id="L3383">            normal.assertSubscriptions(0);</span>
<span class="fc" id="L3384">            error.assertSubscriptions(1);</span>
<span class="nc" id="L3385">        }</span>
<span class="fc" id="L3386">    }</span>

    @Test(timeout = 5000)
    public void startWithFlowableNormal() {
<span class="fc" id="L3390">        final AtomicBoolean run = new AtomicBoolean();</span>
<span class="fc" id="L3391">        Flowable&lt;Object&gt; c = normal.completable</span>
<span class="fc" id="L3392">                .startWith(Flowable.fromCallable(new Callable&lt;Object&gt;() {</span>
                    @Override
                    public Object call() throws Exception {
<span class="pc bpc" id="L3395" title="1 of 2 branches missed.">                        run.set(normal.get() == 0);</span>
<span class="fc" id="L3396">                        return 1;</span>
                    }
                }));

<span class="fc" id="L3400">        TestSubscriber&lt;Object&gt; ts = new TestSubscriber&lt;Object&gt;();</span>

<span class="fc" id="L3402">        c.subscribe(ts);</span>

<span class="fc" id="L3404">        Assert.assertTrue(&quot;Did not start with other&quot;, run.get());</span>
<span class="fc" id="L3405">        normal.assertSubscriptions(1);</span>

<span class="fc" id="L3407">        ts.assertValue(1);</span>
<span class="fc" id="L3408">        ts.assertComplete();</span>
<span class="fc" id="L3409">        ts.assertNoErrors();</span>
<span class="fc" id="L3410">    }</span>

    @Test(timeout = 5000)
    public void startWithFlowableError() {
<span class="fc" id="L3414">        Flowable&lt;Object&gt; c = normal.completable</span>
<span class="fc" id="L3415">                .startWith(Flowable.error(new TestException()));</span>

<span class="fc" id="L3417">        TestSubscriber&lt;Object&gt; ts = new TestSubscriber&lt;Object&gt;();</span>

<span class="fc" id="L3419">        c.subscribe(ts);</span>

<span class="fc" id="L3421">        normal.assertSubscriptions(0);</span>

<span class="fc" id="L3423">        ts.assertNoValues();</span>
<span class="fc" id="L3424">        ts.assertError(TestException.class);</span>
<span class="fc" id="L3425">        ts.assertNotComplete();</span>
<span class="fc" id="L3426">    }</span>

    @Test(timeout = 5000)
    public void startWithObservableNormal() {
<span class="fc" id="L3430">        final AtomicBoolean run = new AtomicBoolean();</span>
<span class="fc" id="L3431">        Observable&lt;Object&gt; o = normal.completable</span>
<span class="fc" id="L3432">                .startWith(Observable.fromCallable(new Callable&lt;Object&gt;() {</span>
                    @Override
                    public Object call() throws Exception {
<span class="pc bpc" id="L3435" title="1 of 2 branches missed.">                        run.set(normal.get() == 0);</span>
<span class="fc" id="L3436">                        return 1;</span>
                    }
                }));

<span class="fc" id="L3440">        TestObserver&lt;Object&gt; to = new TestObserver&lt;Object&gt;();</span>

<span class="fc" id="L3442">        o.subscribe(to);</span>

<span class="fc" id="L3444">        Assert.assertTrue(&quot;Did not start with other&quot;, run.get());</span>
<span class="fc" id="L3445">        normal.assertSubscriptions(1);</span>

<span class="fc" id="L3447">        to.assertValue(1);</span>
<span class="fc" id="L3448">        to.assertComplete();</span>
<span class="fc" id="L3449">        to.assertNoErrors();</span>
<span class="fc" id="L3450">    }</span>

    @Test(timeout = 5000)
    public void startWithObservableError() {
<span class="fc" id="L3454">        Observable&lt;Object&gt; o = normal.completable</span>
<span class="fc" id="L3455">                .startWith(Observable.error(new TestException()));</span>

<span class="fc" id="L3457">        TestObserver&lt;Object&gt; to = new TestObserver&lt;Object&gt;();</span>

<span class="fc" id="L3459">        o.subscribe(to);</span>

<span class="fc" id="L3461">        normal.assertSubscriptions(0);</span>

<span class="fc" id="L3463">        to.assertNoValues();</span>
<span class="fc" id="L3464">        to.assertError(TestException.class);</span>
<span class="fc" id="L3465">        to.assertNotComplete();</span>
<span class="fc" id="L3466">    }</span>

    @Test(expected = NullPointerException.class)
    public void startWithCompletableNull() {
<span class="nc" id="L3470">        normal.completable.startWith((Completable)null);</span>
<span class="nc" id="L3471">    }</span>

    @Test(expected = NullPointerException.class)
    public void startWithFlowableNull() {
<span class="nc" id="L3475">        normal.completable.startWith((Flowable&lt;Object&gt;)null);</span>
<span class="nc" id="L3476">    }</span>

    @Test(expected = NullPointerException.class)
    public void startWithObservableNull() {
<span class="nc" id="L3480">        normal.completable.startWith((Observable&lt;Object&gt;)null);</span>
<span class="nc" id="L3481">    }</span>

    @Test
    public void andThen() {
<span class="fc" id="L3485">        TestSubscriber&lt;String&gt; ts = new TestSubscriber&lt;String&gt;(0);</span>
<span class="fc" id="L3486">        Completable.complete().andThen(Flowable.just(&quot;foo&quot;)).subscribe(ts);</span>
<span class="fc" id="L3487">        ts.request(1);</span>
<span class="fc" id="L3488">        ts.assertValue(&quot;foo&quot;);</span>
<span class="fc" id="L3489">        ts.assertComplete();</span>
<span class="fc" id="L3490">        ts.assertNoErrors();</span>

<span class="fc" id="L3492">        TestObserver&lt;String&gt; to = new TestObserver&lt;String&gt;();</span>
<span class="fc" id="L3493">        Completable.complete().andThen(Observable.just(&quot;foo&quot;)).subscribe(to);</span>
<span class="fc" id="L3494">        to.assertValue(&quot;foo&quot;);</span>
<span class="fc" id="L3495">        to.assertComplete();</span>
<span class="fc" id="L3496">        to.assertNoErrors();</span>
<span class="fc" id="L3497">    }</span>

    private static void expectUncaughtTestException(Action action) {
<span class="fc" id="L3500">        Thread.UncaughtExceptionHandler originalHandler = Thread.getDefaultUncaughtExceptionHandler();</span>
<span class="fc" id="L3501">        CapturingUncaughtExceptionHandler handler = new CapturingUncaughtExceptionHandler();</span>
<span class="fc" id="L3502">        Thread.setDefaultUncaughtExceptionHandler(handler);</span>
<span class="fc" id="L3503">        RxJavaPlugins.setErrorHandler(new Consumer&lt;Throwable&gt;() {</span>
            @Override
            public void accept(Throwable error) throws Exception {
<span class="fc" id="L3506">                Thread.currentThread().getUncaughtExceptionHandler().uncaughtException(Thread.currentThread(), error);</span>
<span class="fc" id="L3507">            }</span>
        });
        try {
<span class="fc" id="L3510">            action.run();</span>
<span class="fc" id="L3511">            assertEquals(&quot;Should have received exactly 1 exception&quot;, 1, handler.count);</span>
<span class="fc" id="L3512">            Throwable caught = handler.caught;</span>
<span class="pc bpc" id="L3513" title="1 of 2 branches missed.">            while (caught != null) {</span>
<span class="fc bfc" id="L3514" title="All 2 branches covered.">                if (caught instanceof TestException) { break; }</span>
<span class="pc bpc" id="L3515" title="1 of 2 branches missed.">                if (caught == caught.getCause()) { break; }</span>
<span class="fc" id="L3516">                caught = caught.getCause();</span>
            }
<span class="fc" id="L3518">            assertTrue(&quot;A TestException should have been delivered to the handler&quot;,</span>
                    caught instanceof TestException);
<span class="nc" id="L3520">        } catch (Throwable ex) {</span>
<span class="nc" id="L3521">            throw ExceptionHelper.wrapOrThrow(ex);</span>
        } finally {
<span class="fc" id="L3523">            Thread.setDefaultUncaughtExceptionHandler(originalHandler);</span>
<span class="fc" id="L3524">            RxJavaPlugins.setErrorHandler(null);</span>
        }
<span class="fc" id="L3526">    }</span>

    @Test
    public void subscribeOneActionThrowFromOnCompleted() {
<span class="fc" id="L3530">        expectUncaughtTestException(new Action() {</span>
            @Override
            public void run() {
<span class="fc" id="L3533">                normal.completable.subscribe(new Action() {</span>
                    @Override
                    public void run() {
<span class="fc" id="L3536">                        throw new TestException();</span>
                    }
                });
<span class="fc" id="L3539">            }</span>
        });
<span class="fc" id="L3541">    }</span>

    @Test
    public void subscribeTwoActionsThrowFromOnError() {
<span class="fc" id="L3545">        expectUncaughtTestException(new Action() {</span>
            @Override
            public void run() {
<span class="fc" id="L3548">                error.completable.subscribe(</span>
<span class="fc" id="L3549">                new Action() {</span>
                    @Override
                    public void run() {
<span class="nc" id="L3552">                    }</span>
                },
<span class="fc" id="L3554">                new Consumer&lt;Throwable&gt;() {</span>
                    @Override
                    public void accept(Throwable throwable) {
<span class="fc" id="L3557">                        throw new TestException();</span>
                    }
                });
<span class="fc" id="L3560">            }</span>
        });
<span class="fc" id="L3562">    }</span>

    @Test
    public void propagateExceptionSubscribeOneAction() {
<span class="fc" id="L3566">        expectUncaughtTestException(new Action() {</span>
            @Override
            public void run() {
<span class="fc" id="L3569">                error.completable.toSingleDefault(1).subscribe(new Consumer&lt;Integer&gt;() {</span>
                    @Override
                    public void accept(Integer integer) {
<span class="nc" id="L3572">                    }</span>
                });
<span class="fc" id="L3574">            }</span>
        });
<span class="fc" id="L3576">    }</span>

    @Test
    public void usingFactoryReturnsNullAndDisposerThrows() {
<span class="fc" id="L3580">        Consumer&lt;Integer&gt; onDispose = new Consumer&lt;Integer&gt;() {</span>
            @Override
            public void accept(Integer t) {
<span class="fc" id="L3583">                throw new TestException();</span>
            }
        };

<span class="fc" id="L3587">        TestSubscriber&lt;Integer&gt; ts = new TestSubscriber&lt;Integer&gt;();</span>

<span class="fc" id="L3589">        Completable.using(new Callable&lt;Integer&gt;() {</span>
            @Override
            public Integer call() {
<span class="fc" id="L3592">                return 1;</span>
            }
        },
<span class="fc" id="L3595">        new Function&lt;Integer, Completable&gt;() {</span>
            @Override
            public Completable apply(Integer t) {
<span class="fc" id="L3598">                return null;</span>
            }
<span class="fc" id="L3600">        }, onDispose).&lt;Integer&gt;toFlowable().subscribe(ts);</span>

<span class="fc" id="L3602">        ts.assertNoValues();</span>
<span class="fc" id="L3603">        ts.assertNotComplete();</span>
<span class="fc" id="L3604">        ts.assertError(CompositeException.class);</span>

<span class="fc" id="L3606">        CompositeException ex = (CompositeException)ts.errors().get(0);</span>

<span class="fc" id="L3608">        List&lt;Throwable&gt; listEx = ex.getExceptions();</span>

<span class="fc" id="L3610">        assertEquals(2, listEx.size());</span>

<span class="fc" id="L3612">        assertTrue(listEx.get(0).toString(), listEx.get(0) instanceof NullPointerException);</span>
<span class="fc" id="L3613">        assertTrue(listEx.get(1).toString(), listEx.get(1) instanceof TestException);</span>
<span class="fc" id="L3614">    }</span>

    @Test
    public void subscribeReportsUnsubscribedOnError() {
<span class="fc" id="L3618">        List&lt;Throwable&gt; errors = TestHelper.trackPluginErrors();</span>
        try {
<span class="fc" id="L3620">            PublishSubject&lt;String&gt; stringSubject = PublishSubject.create();</span>
<span class="fc" id="L3621">            Completable completable = stringSubject.ignoreElements();</span>

<span class="fc" id="L3623">            Disposable completableSubscription = completable.subscribe();</span>

<span class="fc" id="L3625">            stringSubject.onError(new TestException());</span>

<span class="fc" id="L3627">            assertTrue(&quot;Not unsubscribed?&quot;, completableSubscription.isDisposed());</span>

<span class="fc" id="L3629">            TestHelper.assertError(errors, 0, OnErrorNotImplementedException.class);</span>
        } finally {
<span class="fc" id="L3631">            RxJavaPlugins.reset();</span>
        }
<span class="fc" id="L3633">    }</span>

    @Test
    public void subscribeActionReportsUnsubscribed() {
<span class="fc" id="L3637">        PublishSubject&lt;String&gt; stringSubject = PublishSubject.create();</span>
<span class="fc" id="L3638">        Completable completable = stringSubject.ignoreElements();</span>

<span class="fc" id="L3640">        Disposable completableSubscription = completable.subscribe(new Action() {</span>
            @Override
            public void run() {

<span class="fc" id="L3644">            }</span>
        });

<span class="fc" id="L3647">        stringSubject.onComplete();</span>

<span class="fc" id="L3649">        assertTrue(&quot;Not unsubscribed?&quot;, completableSubscription.isDisposed());</span>
<span class="fc" id="L3650">    }</span>

    @Test
    public void subscribeActionReportsUnsubscribedAfter() {
<span class="fc" id="L3654">        PublishSubject&lt;String&gt; stringSubject = PublishSubject.create();</span>
<span class="fc" id="L3655">        Completable completable = stringSubject.ignoreElements();</span>

<span class="fc" id="L3657">        final AtomicReference&lt;Disposable&gt; disposableRef = new AtomicReference&lt;Disposable&gt;();</span>
<span class="fc" id="L3658">        Disposable completableSubscription = completable.subscribe(new Action() {</span>
            @Override
            public void run() {
<span class="pc bpc" id="L3661" title="1 of 2 branches missed.">                if (disposableRef.get().isDisposed()) {</span>
<span class="nc" id="L3662">                    disposableRef.set(null);</span>
                }
<span class="fc" id="L3664">            }</span>
        });
<span class="fc" id="L3666">        disposableRef.set(completableSubscription);</span>

<span class="fc" id="L3668">        stringSubject.onComplete();</span>

<span class="fc" id="L3670">        assertTrue(&quot;Not unsubscribed?&quot;, completableSubscription.isDisposed());</span>
<span class="fc" id="L3671">        assertNotNull(&quot;Unsubscribed before the call to onComplete&quot;, disposableRef.get());</span>
<span class="fc" id="L3672">    }</span>

    @Test
    public void subscribeActionReportsUnsubscribedOnError() {
<span class="fc" id="L3676">        List&lt;Throwable&gt; errors = TestHelper.trackPluginErrors();</span>
        try {
<span class="fc" id="L3678">            PublishSubject&lt;String&gt; stringSubject = PublishSubject.create();</span>
<span class="fc" id="L3679">            Completable completable = stringSubject.ignoreElements();</span>

<span class="fc" id="L3681">            Disposable completableSubscription = completable.subscribe(new Action() {</span>
                @Override
                public void run() {
<span class="nc" id="L3684">                }</span>
            });

<span class="fc" id="L3687">            stringSubject.onError(new TestException());</span>

<span class="fc" id="L3689">            assertTrue(&quot;Not unsubscribed?&quot;, completableSubscription.isDisposed());</span>

<span class="fc" id="L3691">            TestHelper.assertError(errors, 0, OnErrorNotImplementedException.class);</span>
        } finally {
<span class="fc" id="L3693">            RxJavaPlugins.reset();</span>
        }
<span class="fc" id="L3695">    }</span>

    @Test
    public void subscribeAction2ReportsUnsubscribed() {
<span class="fc" id="L3699">        PublishSubject&lt;String&gt; stringSubject = PublishSubject.create();</span>
<span class="fc" id="L3700">        Completable completable = stringSubject.ignoreElements();</span>

<span class="fc" id="L3702">        Disposable completableSubscription = completable.subscribe(new Action() {</span>
            @Override
            public void run() {

<span class="fc" id="L3706">            }</span>
<span class="fc" id="L3707">        }, new Consumer&lt;Throwable&gt;() {</span>
            @Override
            public void accept(Throwable t) {

<span class="nc" id="L3711">            }</span>
        });

<span class="fc" id="L3714">        stringSubject.onComplete();</span>

<span class="fc" id="L3716">        assertTrue(&quot;Not unsubscribed?&quot;, completableSubscription.isDisposed());</span>
<span class="fc" id="L3717">    }</span>

    @Test
    public void subscribeAction2ReportsUnsubscribedOnError() {
<span class="fc" id="L3721">        PublishSubject&lt;String&gt; stringSubject = PublishSubject.create();</span>
<span class="fc" id="L3722">        Completable completable = stringSubject.ignoreElements();</span>

<span class="fc" id="L3724">        Disposable completableSubscription = completable.subscribe(new Action() {</span>
            @Override
<span class="nc" id="L3726">            public void run() { }</span>
<span class="fc" id="L3727">        }, new Consumer&lt;Throwable&gt;() {</span>
            @Override
<span class="fc" id="L3729">            public void accept(Throwable e) { }</span>
        });

<span class="fc" id="L3732">        stringSubject.onError(new TestException());</span>

<span class="fc" id="L3734">        assertTrue(&quot;Not unsubscribed?&quot;, completableSubscription.isDisposed());</span>
<span class="fc" id="L3735">    }</span>

    @Test
    public void andThenSubscribeOn() {
<span class="fc" id="L3739">        TestSubscriber&lt;String&gt; ts = new TestSubscriber&lt;String&gt;(0);</span>
<span class="fc" id="L3740">        TestScheduler scheduler = new TestScheduler();</span>
<span class="fc" id="L3741">        Completable.complete().andThen(Flowable.just(&quot;foo&quot;).delay(1, TimeUnit.SECONDS, scheduler)).subscribe(ts);</span>

<span class="fc" id="L3743">        ts.request(1);</span>
<span class="fc" id="L3744">        ts.assertNoValues();</span>
<span class="fc" id="L3745">        ts.assertNotTerminated();</span>

<span class="fc" id="L3747">        scheduler.advanceTimeBy(1, TimeUnit.SECONDS);</span>

<span class="fc" id="L3749">        ts.assertValue(&quot;foo&quot;);</span>
<span class="fc" id="L3750">        ts.assertComplete();</span>
<span class="fc" id="L3751">        ts.assertNoErrors();</span>
<span class="fc" id="L3752">    }</span>

    @Test
    public void andThenSingleNever() {
<span class="fc" id="L3756">        TestSubscriber&lt;String&gt; ts = new TestSubscriber&lt;String&gt;(0);</span>
<span class="fc" id="L3757">        Completable.never().andThen(Single.just(&quot;foo&quot;)).toFlowable().subscribe(ts);</span>
<span class="fc" id="L3758">        ts.request(1);</span>
<span class="fc" id="L3759">        ts.assertNoValues();</span>
<span class="fc" id="L3760">        ts.assertNotTerminated();</span>
<span class="fc" id="L3761">    }</span>

    @Test
    public void andThenSingleError() {
<span class="fc" id="L3765">        TestSubscriber&lt;String&gt; ts = new TestSubscriber&lt;String&gt;(0);</span>
<span class="fc" id="L3766">        final AtomicBoolean hasRun = new AtomicBoolean(false);</span>
<span class="fc" id="L3767">        final Exception e = new Exception();</span>
<span class="fc" id="L3768">        Completable.error(e)</span>
<span class="fc" id="L3769">            .andThen(new Single&lt;String&gt;() {</span>
                @Override
                public void subscribeActual(SingleObserver&lt;? super String&gt; observer) {
<span class="nc" id="L3772">                    hasRun.set(true);</span>
<span class="nc" id="L3773">                    observer.onSuccess(&quot;foo&quot;);</span>
<span class="nc" id="L3774">                }</span>
            })
<span class="fc" id="L3776">            .toFlowable().subscribe(ts);</span>
<span class="fc" id="L3777">        ts.assertNoValues();</span>
<span class="fc" id="L3778">        ts.assertError(e);</span>
<span class="fc" id="L3779">        Assert.assertFalse(&quot;Should not have subscribed to single when completable errors&quot;, hasRun.get());</span>
<span class="fc" id="L3780">    }</span>

    @Test
    public void andThenSingleSubscribeOn() {
<span class="fc" id="L3784">        TestSubscriber&lt;String&gt; ts = new TestSubscriber&lt;String&gt;(0);</span>
<span class="fc" id="L3785">        TestScheduler scheduler = new TestScheduler();</span>
<span class="fc" id="L3786">        Completable.complete().andThen(Single.just(&quot;foo&quot;).delay(1, TimeUnit.SECONDS, scheduler)).toFlowable().subscribe(ts);</span>

<span class="fc" id="L3788">        ts.request(1);</span>
<span class="fc" id="L3789">        ts.assertNoValues();</span>
<span class="fc" id="L3790">        ts.assertNotTerminated();</span>

<span class="fc" id="L3792">        scheduler.advanceTimeBy(1, TimeUnit.SECONDS);</span>

<span class="fc" id="L3794">        ts.assertValue(&quot;foo&quot;);</span>
<span class="fc" id="L3795">        ts.assertComplete();</span>
<span class="fc" id="L3796">        ts.assertNoErrors();</span>
<span class="fc" id="L3797">    }</span>

    private Function&lt;Completable, Completable&gt; onCreate;

    private BiFunction&lt;Completable, CompletableObserver, CompletableObserver&gt; onStart;

    @Before
    public void setUp() throws Exception {
<span class="fc" id="L3805">        onCreate = spy(new Function&lt;Completable, Completable&gt;() {</span>
            @Override
            public Completable apply(Completable t) {
<span class="fc" id="L3808">                return t;</span>
            }
        });

<span class="fc" id="L3812">        RxJavaPlugins.setOnCompletableAssembly(onCreate);</span>

<span class="fc" id="L3814">        onStart = spy(new BiFunction&lt;Completable, CompletableObserver, CompletableObserver&gt;() {</span>
            @Override
            public CompletableObserver apply(Completable t1, CompletableObserver t2) {
<span class="fc" id="L3817">                return t2;</span>
            }
        });

<span class="fc" id="L3821">        RxJavaPlugins.setOnCompletableSubscribe(onStart);</span>
<span class="fc" id="L3822">    }</span>

    @After
    public void after() {
<span class="fc" id="L3826">        RxJavaPlugins.reset();</span>
<span class="fc" id="L3827">    }</span>

    @Test
    public void testHookCreate() throws Exception {
<span class="fc" id="L3831">        CompletableSource subscriber = mock(CompletableSource.class);</span>
<span class="fc" id="L3832">        Completable create = Completable.unsafeCreate(subscriber);</span>

<span class="fc" id="L3834">        verify(onCreate, times(1)).apply(create);</span>
<span class="fc" id="L3835">    }</span>

    @Test(timeout = 5000)
    public void doOnCompletedNormal() {
<span class="fc" id="L3839">        final AtomicInteger calls = new AtomicInteger();</span>

<span class="fc" id="L3841">        Completable c = normal.completable.doOnComplete(new Action() {</span>
            @Override
            public void run() {
<span class="fc" id="L3844">                calls.getAndIncrement();</span>
<span class="fc" id="L3845">            }</span>
        });

<span class="fc" id="L3848">        c.blockingAwait();</span>

<span class="fc" id="L3850">        Assert.assertEquals(1, calls.get());</span>
<span class="fc" id="L3851">    }</span>

    @Test(timeout = 5000)
    public void doOnCompletedError() {
<span class="fc" id="L3855">        final AtomicInteger calls = new AtomicInteger();</span>

<span class="fc" id="L3857">        Completable c = error.completable.doOnComplete(new Action() {</span>
            @Override
            public void run() {
<span class="nc" id="L3860">                calls.getAndIncrement();</span>
<span class="nc" id="L3861">            }</span>
        });

        try {
<span class="nc" id="L3865">            c.blockingAwait();</span>
<span class="nc" id="L3866">            Assert.fail(&quot;Failed to throw TestException&quot;);</span>
<span class="fc" id="L3867">        } catch (TestException ex) {</span>
            // expected
<span class="nc" id="L3869">        }</span>

<span class="fc" id="L3871">        Assert.assertEquals(0, calls.get());</span>
<span class="fc" id="L3872">    }</span>

    @Test(expected = NullPointerException.class)
    public void doOnCompletedNull() {
<span class="nc" id="L3876">        normal.completable.doOnComplete(null);</span>
<span class="nc" id="L3877">    }</span>

    @Test(timeout = 5000, expected = TestException.class)
    public void doOnCompletedThrows() {
<span class="fc" id="L3881">        Completable c = normal.completable.doOnComplete(new Action() {</span>
            @Override
<span class="fc" id="L3883">            public void run() { throw new TestException(); }</span>
        });

<span class="nc" id="L3886">        c.blockingAwait();</span>
<span class="nc" id="L3887">    }</span>

    @Test(timeout = 5000)
    public void doAfterTerminateNormal() {
<span class="fc" id="L3891">        final AtomicBoolean doneAfter = new AtomicBoolean();</span>
<span class="fc" id="L3892">        final AtomicBoolean complete = new AtomicBoolean();</span>

<span class="fc" id="L3894">        Completable c = normal.completable.doAfterTerminate(new Action() {</span>
            @Override
            public void run() {
<span class="fc" id="L3897">                doneAfter.set(complete.get());</span>
<span class="fc" id="L3898">            }</span>
        });

<span class="fc" id="L3901">        c.subscribe(new CompletableObserver() {</span>
            @Override
            public void onSubscribe(Disposable d) {

<span class="fc" id="L3905">            }</span>

            @Override
            public void onError(Throwable e) {

<span class="nc" id="L3910">            }</span>

            @Override
            public void onComplete() {
<span class="fc" id="L3914">                complete.set(true);</span>
<span class="fc" id="L3915">            }</span>
        });

<span class="fc" id="L3918">        c.blockingAwait();</span>

<span class="fc" id="L3920">        Assert.assertTrue(&quot;Not completed&quot;, complete.get());</span>
<span class="fc" id="L3921">        Assert.assertTrue(&quot;Closure called before onComplete&quot;, doneAfter.get());</span>
<span class="fc" id="L3922">    }</span>

    @Test
    public void doAfterTerminateWithError() {
<span class="fc" id="L3926">        final AtomicBoolean doneAfter = new AtomicBoolean();</span>

<span class="fc" id="L3928">        Completable c = error.completable.doAfterTerminate(new Action() {</span>
            @Override
            public void run() {
<span class="fc" id="L3931">                doneAfter.set(true);</span>
<span class="fc" id="L3932">            }</span>
        });

        try {
<span class="nc" id="L3936">            c.blockingAwait(5, TimeUnit.SECONDS);</span>
<span class="nc" id="L3937">            Assert.fail(&quot;Did not throw TestException&quot;);</span>
<span class="fc" id="L3938">        } catch (TestException ex) {</span>
            // expected
<span class="nc" id="L3940">        }</span>

<span class="fc" id="L3942">        Assert.assertTrue(&quot;Closure not called&quot;, doneAfter.get());</span>
<span class="fc" id="L3943">    }</span>

    @Test(expected = NullPointerException.class)
    public void doAfterTerminateNull() {
<span class="nc" id="L3947">        normal.completable.doAfterTerminate(null);</span>
<span class="nc" id="L3948">    }</span>

    @Test
    public void subscribeEmptyOnError() {
<span class="fc" id="L3952">        expectUncaughtTestException(new Action() {</span>
            @Override public void run() {
<span class="fc" id="L3954">                error.completable.subscribe();</span>
<span class="fc" id="L3955">            }</span>
        });
<span class="fc" id="L3957">    }</span>

    @Test
    public void subscribeOneActionOnError() {
<span class="fc" id="L3961">        expectUncaughtTestException(new Action() {</span>
            @Override
            public void run() {
<span class="fc" id="L3964">                error.completable.subscribe(new Action() {</span>
                    @Override
                    public void run() {
<span class="nc" id="L3967">                    }</span>
                });
<span class="fc" id="L3969">            }</span>
        });
<span class="fc" id="L3971">    }</span>

    @Test
    public void propagateExceptionSubscribeEmpty() {
<span class="fc" id="L3975">        expectUncaughtTestException(new Action() {</span>
            @Override
            public void run() {
<span class="fc" id="L3978">                error.completable.toSingleDefault(0).subscribe();</span>
<span class="fc" id="L3979">            }</span>
        });
<span class="fc" id="L3981">    }</span>

    @Test(expected = NullPointerException.class)
    public void andThenCompletableNull() {
<span class="nc" id="L3985">        normal.completable.andThen((Completable)null);</span>
<span class="nc" id="L3986">    }</span>

    @Test(expected = NullPointerException.class)
    public void andThenFlowableNull() {
<span class="nc" id="L3990">        normal.completable.andThen((Observable&lt;Object&gt;)null);</span>
<span class="nc" id="L3991">    }</span>

    @Test(timeout = 5000)
    public void andThenCompletableNormal() {
<span class="fc" id="L3995">        final AtomicBoolean run = new AtomicBoolean();</span>
<span class="fc" id="L3996">        Completable c = normal.completable</span>
<span class="fc" id="L3997">                .andThen(Completable.fromCallable(new Callable&lt;Object&gt;() {</span>
                    @Override
                    public Object call() throws Exception {
<span class="pc bpc" id="L4000" title="1 of 2 branches missed.">                        run.set(normal.get() == 0);</span>
<span class="fc" id="L4001">                        return null;</span>
                    }
                }));

<span class="fc" id="L4005">        c.blockingAwait();</span>

<span class="fc" id="L4007">        Assert.assertFalse(&quot;Start with other&quot;, run.get());</span>
<span class="fc" id="L4008">        normal.assertSubscriptions(1);</span>
<span class="fc" id="L4009">    }</span>

    @Test(timeout = 5000)
    public void andThenCompletableError() {
<span class="fc" id="L4013">        Completable c = normal.completable.andThen(error.completable);</span>

        try {
<span class="nc" id="L4016">            c.blockingAwait();</span>
<span class="nc" id="L4017">            Assert.fail(&quot;Did not throw TestException&quot;);</span>
<span class="fc" id="L4018">        } catch (TestException ex) {</span>
<span class="fc" id="L4019">            normal.assertSubscriptions(1);</span>
<span class="fc" id="L4020">            error.assertSubscriptions(1);</span>
<span class="nc" id="L4021">        }</span>
<span class="fc" id="L4022">    }</span>

    @Test(timeout = 5000)
    public void andThenFlowableNormal() {
<span class="fc" id="L4026">        final AtomicBoolean run = new AtomicBoolean();</span>
<span class="fc" id="L4027">        Flowable&lt;Object&gt; c = normal.completable</span>
<span class="fc" id="L4028">                .andThen(Flowable.fromCallable(new Callable&lt;Object&gt;() {</span>
                    @Override
                    public Object call() throws Exception {
<span class="pc bpc" id="L4031" title="1 of 2 branches missed.">                        run.set(normal.get() == 0);</span>
<span class="fc" id="L4032">                        return 1;</span>
                    }
                }));

<span class="fc" id="L4036">        TestSubscriber&lt;Object&gt; ts = new TestSubscriber&lt;Object&gt;();</span>

<span class="fc" id="L4038">        c.subscribe(ts);</span>

<span class="fc" id="L4040">        Assert.assertFalse(&quot;Start with other&quot;, run.get());</span>
<span class="fc" id="L4041">        normal.assertSubscriptions(1);</span>

<span class="fc" id="L4043">        ts.assertValue(1);</span>
<span class="fc" id="L4044">        ts.assertComplete();</span>
<span class="fc" id="L4045">        ts.assertNoErrors();</span>
<span class="fc" id="L4046">    }</span>

    @Test(timeout = 5000)
    public void andThenFlowableError() {
<span class="fc" id="L4050">        Flowable&lt;Object&gt; c = normal.completable</span>
<span class="fc" id="L4051">                .andThen(Flowable.error(new TestException()));</span>

<span class="fc" id="L4053">        TestSubscriber&lt;Object&gt; ts = new TestSubscriber&lt;Object&gt;();</span>

<span class="fc" id="L4055">        c.subscribe(ts);</span>

<span class="fc" id="L4057">        normal.assertSubscriptions(1);</span>

<span class="fc" id="L4059">        ts.assertNoValues();</span>
<span class="fc" id="L4060">        ts.assertError(TestException.class);</span>
<span class="fc" id="L4061">        ts.assertNotComplete();</span>
<span class="fc" id="L4062">    }</span>

    @Test
    public void usingFactoryThrows() throws Exception {
        @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L4067">        Consumer&lt;Integer&gt; onDispose = mock(Consumer.class);</span>

<span class="fc" id="L4069">        TestSubscriber&lt;Integer&gt; ts = new TestSubscriber&lt;Integer&gt;();</span>

<span class="fc" id="L4071">        Completable.using(new Callable&lt;Integer&gt;() {</span>
            @Override
            public Integer call() {
<span class="fc" id="L4074">                return 1;</span>
            }
        },
<span class="fc" id="L4077">        new Function&lt;Integer, Completable&gt;() {</span>
            @Override
            public Completable apply(Integer t) {
<span class="fc" id="L4080">                throw new TestException();</span>
            }
<span class="fc" id="L4082">        }, onDispose).&lt;Integer&gt;toFlowable().subscribe(ts);</span>

<span class="fc" id="L4084">        verify(onDispose).accept(1);</span>

<span class="fc" id="L4086">        ts.assertNoValues();</span>
<span class="fc" id="L4087">        ts.assertNotComplete();</span>
<span class="fc" id="L4088">        ts.assertError(TestException.class);</span>
<span class="fc" id="L4089">    }</span>

    @Test
    public void usingFactoryAndDisposerThrow() {
<span class="fc" id="L4093">        Consumer&lt;Integer&gt; onDispose = new Consumer&lt;Integer&gt;() {</span>
            @Override
            public void accept(Integer t) {
<span class="fc" id="L4096">                throw new TestException();</span>
            }
        };

<span class="fc" id="L4100">        TestSubscriber&lt;Integer&gt; ts = new TestSubscriber&lt;Integer&gt;();</span>

<span class="fc" id="L4102">        Completable.using(new Callable&lt;Integer&gt;() {</span>
            @Override
            public Integer call() {
<span class="fc" id="L4105">                return 1;</span>
            }
        },
<span class="fc" id="L4108">        new Function&lt;Integer, Completable&gt;() {</span>
            @Override
            public Completable apply(Integer t) {
<span class="fc" id="L4111">                throw new TestException();</span>
            }
<span class="fc" id="L4113">        }, onDispose).&lt;Integer&gt;toFlowable().subscribe(ts);</span>

<span class="fc" id="L4115">        ts.assertNoValues();</span>
<span class="fc" id="L4116">        ts.assertNotComplete();</span>
<span class="fc" id="L4117">        ts.assertError(CompositeException.class);</span>

<span class="fc" id="L4119">        CompositeException ex = (CompositeException)ts.errors().get(0);</span>

<span class="fc" id="L4121">        List&lt;Throwable&gt; listEx = ex.getExceptions();</span>

<span class="fc" id="L4123">        assertEquals(2, listEx.size());</span>

<span class="fc" id="L4125">        assertTrue(listEx.get(0).toString(), listEx.get(0) instanceof TestException);</span>
<span class="fc" id="L4126">        assertTrue(listEx.get(1).toString(), listEx.get(1) instanceof TestException);</span>
<span class="fc" id="L4127">    }</span>

    @Test
    public void usingFactoryReturnsNull() throws Exception {
        @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L4132">        Consumer&lt;Integer&gt; onDispose = mock(Consumer.class);</span>

<span class="fc" id="L4134">        TestSubscriber&lt;Integer&gt; ts = TestSubscriber.create();</span>

<span class="fc" id="L4136">        Completable.using(new Callable&lt;Integer&gt;() {</span>
            @Override
            public Integer call() {
<span class="fc" id="L4139">                return 1;</span>
            }
        },
<span class="fc" id="L4142">        new Function&lt;Integer, Completable&gt;() {</span>
            @Override
            public Completable apply(Integer t) {
<span class="fc" id="L4145">                return null;</span>
            }
<span class="fc" id="L4147">        }, onDispose).&lt;Integer&gt;toFlowable().subscribe(ts);</span>

<span class="fc" id="L4149">        verify(onDispose).accept(1);</span>

<span class="fc" id="L4151">        ts.assertNoValues();</span>
<span class="fc" id="L4152">        ts.assertNotComplete();</span>
<span class="fc" id="L4153">        ts.assertError(NullPointerException.class);</span>
<span class="fc" id="L4154">    }</span>

    @Test
    public void subscribeReportsUnsubscribed() {
<span class="fc" id="L4158">        PublishSubject&lt;String&gt; stringSubject = PublishSubject.create();</span>
<span class="fc" id="L4159">        Completable completable = stringSubject.ignoreElements();</span>

<span class="fc" id="L4161">        Disposable completableSubscription = completable.subscribe();</span>

<span class="fc" id="L4163">        stringSubject.onComplete();</span>

<span class="fc" id="L4165">        assertTrue(&quot;Not unsubscribed?&quot;, completableSubscription.isDisposed());</span>
<span class="fc" id="L4166">    }</span>

    @Ignore(&quot;onXXX methods are not allowed to throw&quot;)
    @Test
    public void safeOnCompleteThrows() {
        /*
        try {
            normal.completable.subscribe(new CompletableSubscriber() {

                @Override
                public void onComplete() {
                    throw new TestException(&quot;Forced failure&quot;);
                }

                @Override
                public void onError(Throwable e) {

                }

                @Override
                public void onSubscribe(Subscription s) {

                }

            });
            Assert.fail(&quot;Did not propagate exception!&quot;);
        } catch (OnCompletedFailedException ex) {
            Throwable c = ex.getCause();
            Assert.assertNotNull(c);

            Assert.assertEquals(&quot;Forced failure&quot;, c.getMessage());
        }
        */
<span class="nc" id="L4199">    }</span>

    @Ignore(&quot;onXXX methods are not allowed to throw&quot;)
    @Test
    public void safeOnErrorThrows() {
        /*
        try {
            error.completable.subscribe(new CompletableSubscriber() {

                @Override
                public void onComplete() {
                }

                @Override
                public void onError(Throwable e) {
                    throw new TestException(&quot;Forced failure&quot;);
                }

                @Override
                public void onSubscribe(Subscription s) {

                }

            });
            Assert.fail(&quot;Did not propagate exception!&quot;);
        } catch (OnErrorFailedException ex) {
            Throwable c = ex.getCause();
            Assert.assertTrue(&quot;&quot; + c, c instanceof CompositeException);

            CompositeException ce = (CompositeException)c;

            List&lt;Throwable&gt; list = ce.getExceptions();

            Assert.assertEquals(2, list.size());

            Assert.assertTrue(&quot;&quot; + list.get(0), list.get(0) instanceof TestException);
            Assert.assertNull(list.get(0).getMessage());

            Assert.assertTrue(&quot;&quot; + list.get(1), list.get(1) instanceof TestException);
            Assert.assertEquals(&quot;Forced failure&quot;, list.get(1).getMessage());
        }
        */
<span class="nc" id="L4241">    }</span>

    @Test
    public void testHookSubscribeStart() throws Exception {
<span class="fc" id="L4245">        TestSubscriber&lt;String&gt; ts = new TestSubscriber&lt;String&gt;();</span>

<span class="fc" id="L4247">        Completable completable = Completable.unsafeCreate(new CompletableSource() {</span>
            @Override public void subscribe(CompletableObserver observer) {
<span class="fc" id="L4249">                observer.onComplete();</span>
<span class="fc" id="L4250">            }</span>
        });
<span class="fc" id="L4252">        completable.&lt;String&gt;toFlowable().subscribe(ts);</span>

<span class="fc" id="L4254">        verify(onStart, times(1)).apply(eq(completable), any(CompletableObserver.class));</span>
<span class="fc" id="L4255">    }</span>

    @Ignore(&quot;No unsafeSubscribe&quot;)
    @Test
    public void testHookUnsafeSubscribeStart() {
        /*
        TestSubscriber&lt;String&gt; ts = new TestSubscriber&lt;String&gt;();
        Completable completable = Completable.create(new CompletableOnSubscribe() {
            @Override public void call(CompletableSubscriber s) {
                s.onComplete();
            }
        });
        completable.unsafeSubscribe(ts);

        verify(onStart, times(1)).call(eq(completable), any(Completable.CompletableOnSubscribe.class));
        */
<span class="nc" id="L4271">    }</span>

    @Test
    public void onStartCalledSafe() {
<span class="fc" id="L4275">        TestSubscriber&lt;Object&gt; ts = new TestSubscriber&lt;Object&gt;() {</span>
            @Override
            public void onStart() {
<span class="fc" id="L4278">                onNext(1);</span>
<span class="fc" id="L4279">            }</span>
        };

<span class="fc" id="L4282">        normal.completable.&lt;Object&gt;toFlowable().subscribe(ts);</span>

<span class="fc" id="L4284">        ts.assertValue(1);</span>
<span class="fc" id="L4285">        ts.assertNoErrors();</span>
<span class="fc" id="L4286">        ts.assertComplete();</span>
<span class="fc" id="L4287">    }</span>

    @Ignore(&quot;No unsafeSubscribe&quot;)
    @Test
    public void onStartCalledUnsafeSafe() {
        /*
        TestSubscriber&lt;Object&gt; ts = new TestSubscriber&lt;Object&gt;() {
            @Override
            public void onStart() {
                onNext(1);
            }
        };

        normal.completable.unsafeSubscribe(ts);

        ts.assertValue(1);
        ts.assertNoErrors();
        ts.assertCompleted();
        */
<span class="nc" id="L4306">    }</span>

    @Test
    public void onErrorCompleteFunctionThrows() {
<span class="fc" id="L4310">        TestSubscriber&lt;String&gt; ts = new TestSubscriber&lt;String&gt;();</span>

<span class="fc" id="L4312">        error.completable.onErrorComplete(new Predicate&lt;Throwable&gt;() {</span>
            @Override
            public boolean test(Throwable t) {
<span class="fc" id="L4315">                throw new TestException(&quot;Forced inner failure&quot;);</span>
            }
<span class="fc" id="L4317">        }).&lt;String&gt;toFlowable().subscribe(ts);</span>

<span class="fc" id="L4319">        ts.assertNoValues();</span>
<span class="fc" id="L4320">        ts.assertNotComplete();</span>
<span class="fc" id="L4321">        ts.assertError(CompositeException.class);</span>

<span class="fc" id="L4323">        CompositeException composite = (CompositeException)ts.errors().get(0);</span>

<span class="fc" id="L4325">        List&lt;Throwable&gt; errors = composite.getExceptions();</span>
<span class="fc" id="L4326">        Assert.assertEquals(2, errors.size());</span>

<span class="fc" id="L4328">        Assert.assertTrue(errors.get(0).toString(), errors.get(0) instanceof TestException);</span>
<span class="fc" id="L4329">        Assert.assertEquals(errors.get(0).toString(), null, errors.get(0).getMessage());</span>
<span class="fc" id="L4330">        Assert.assertTrue(errors.get(1).toString(), errors.get(1) instanceof TestException);</span>
<span class="fc" id="L4331">        Assert.assertEquals(errors.get(1).toString(), &quot;Forced inner failure&quot;, errors.get(1).getMessage());</span>
<span class="fc" id="L4332">    }</span>

    @Test
    public void subscribeAction2ReportsUnsubscribedAfter() {
<span class="fc" id="L4336">        PublishSubject&lt;String&gt; stringSubject = PublishSubject.create();</span>
<span class="fc" id="L4337">        Completable completable = stringSubject.ignoreElements();</span>

<span class="fc" id="L4339">        final AtomicReference&lt;Disposable&gt; disposableRef = new AtomicReference&lt;Disposable&gt;();</span>
<span class="fc" id="L4340">        Disposable completableSubscription = completable.subscribe(new Action() {</span>
            @Override
            public void run() {
<span class="pc bpc" id="L4343" title="1 of 2 branches missed.">                if (disposableRef.get().isDisposed()) {</span>
<span class="nc" id="L4344">                    disposableRef.set(null);</span>
                }
<span class="fc" id="L4346">            }</span>
<span class="fc" id="L4347">        }, Functions.emptyConsumer());</span>
<span class="fc" id="L4348">        disposableRef.set(completableSubscription);</span>

<span class="fc" id="L4350">        stringSubject.onComplete();</span>

<span class="fc" id="L4352">        assertTrue(&quot;Not unsubscribed?&quot;, completableSubscription.isDisposed());</span>
<span class="fc" id="L4353">        assertNotNull(&quot;Unsubscribed before the call to onComplete&quot;, disposableRef.get());</span>
<span class="fc" id="L4354">    }</span>

    @Test
    public void subscribeAction2ReportsUnsubscribedOnErrorAfter() {
<span class="fc" id="L4358">        PublishSubject&lt;String&gt; stringSubject = PublishSubject.create();</span>
<span class="fc" id="L4359">        Completable completable = stringSubject.ignoreElements();</span>

<span class="fc" id="L4361">        final AtomicReference&lt;Disposable&gt; disposableRef = new AtomicReference&lt;Disposable&gt;();</span>
<span class="fc" id="L4362">        Disposable completableSubscription = completable.subscribe(Functions.EMPTY_ACTION,</span>
<span class="fc" id="L4363">        new Consumer&lt;Throwable&gt;() {</span>
            @Override
            public void accept(Throwable e) {
<span class="pc bpc" id="L4366" title="1 of 2 branches missed.">                if (disposableRef.get().isDisposed()) {</span>
<span class="nc" id="L4367">                    disposableRef.set(null);</span>
                }
<span class="fc" id="L4369">            }</span>
        });
<span class="fc" id="L4371">        disposableRef.set(completableSubscription);</span>

<span class="fc" id="L4373">        stringSubject.onError(new TestException());</span>

<span class="fc" id="L4375">        assertTrue(&quot;Not unsubscribed?&quot;, completableSubscription.isDisposed());</span>
<span class="fc" id="L4376">        assertNotNull(&quot;Unsubscribed before the call to onError&quot;, disposableRef.get());</span>
<span class="fc" id="L4377">    }</span>

    @Ignore(&quot;onXXX methods are not allowed to throw&quot;)
    @Test
    public void safeOnCompleteThrowsRegularSubscriber() {
        /*
        try {
            normal.completable.subscribe(new FlowableSubscriber&lt;Object&gt;() {

                @Override
                public void onComplete() {
                    throw new TestException(&quot;Forced failure&quot;);
                }

                @Override
                public void onError(Throwable e) {

                }

                @Override
                public void onNext(Object t) {

                }
            });
            Assert.fail(&quot;Did not propagate exception!&quot;);
        } catch (OnCompletedFailedException ex) {
            Throwable c = ex.getCause();
            Assert.assertNotNull(c);

            Assert.assertEquals(&quot;Forced failure&quot;, c.getMessage());
        }
        */
<span class="nc" id="L4409">    }</span>

    @Ignore(&quot;onXXX methods are not allowed to throw&quot;)
    @Test
    public void safeOnErrorThrowsRegularSubscriber() {
        /*
        try {
            error.completable.subscribe(new FlowableSubscriber&lt;Object&gt;() {

                @Override
                public void onComplete() {

                }

                @Override
                public void onError(Throwable e) {
                    throw new TestException(&quot;Forced failure&quot;);
                }

                @Override
                public void onNext(Object t) {

                }
            });
            Assert.fail(&quot;Did not propagate exception!&quot;);
        } catch (OnErrorFailedException ex) {
            Throwable c = ex.getCause();
            Assert.assertTrue(&quot;&quot; + c, c instanceof CompositeException);

            CompositeException ce = (CompositeException)c;

            List&lt;Throwable&gt; list = ce.getExceptions();

            Assert.assertEquals(2, list.size());

            Assert.assertTrue(&quot;&quot; + list.get(0), list.get(0) instanceof TestException);
            Assert.assertNull(list.get(0).getMessage());

            Assert.assertTrue(&quot;&quot; + list.get(1), list.get(1) instanceof TestException);
            Assert.assertEquals(&quot;Forced failure&quot;, list.get(1).getMessage());
        }
        */
<span class="nc" id="L4451">    }</span>

    @Test
    public void propagateExceptionSubscribeOneActionThrowFromOnSuccess() {
<span class="fc" id="L4455">        expectUncaughtTestException(new Action() {</span>
            @Override
            public void run() {
<span class="fc" id="L4458">                normal.completable.toSingleDefault(1).subscribe(new Consumer&lt;Integer&gt;() {</span>
                    @Override
                    public void accept(Integer integer) {
<span class="fc" id="L4461">                        throw new TestException();</span>
                    }
                });
<span class="fc" id="L4464">            }</span>
        });
<span class="fc" id="L4466">    }</span>

    @Test
    public void andThenNever() {
<span class="fc" id="L4470">        TestSubscriber&lt;String&gt; ts = new TestSubscriber&lt;String&gt;(0);</span>
<span class="fc" id="L4471">        Completable.never().andThen(Flowable.just(&quot;foo&quot;)).subscribe(ts);</span>
<span class="fc" id="L4472">        ts.request(1);</span>
<span class="fc" id="L4473">        ts.assertNoValues();</span>
<span class="fc" id="L4474">        ts.assertNotTerminated();</span>
<span class="fc" id="L4475">    }</span>

    @Test
    public void andThenError() {
<span class="fc" id="L4479">        TestSubscriber&lt;String&gt; ts = new TestSubscriber&lt;String&gt;(0);</span>
<span class="fc" id="L4480">        final AtomicBoolean hasRun = new AtomicBoolean(false);</span>
<span class="fc" id="L4481">        final Exception e = new Exception();</span>
<span class="fc" id="L4482">        Completable.unsafeCreate(new CompletableSource() {</span>
                @Override
                public void subscribe(CompletableObserver co) {
<span class="fc" id="L4485">                    co.onSubscribe(Disposables.empty());</span>
<span class="fc" id="L4486">                    co.onError(e);</span>
<span class="fc" id="L4487">                }</span>
            })
<span class="fc" id="L4489">            .andThen(Flowable.&lt;String&gt;unsafeCreate(new Publisher&lt;String&gt;() {</span>
                @Override
                public void subscribe(Subscriber&lt;? super String&gt; s) {
<span class="nc" id="L4492">                    hasRun.set(true);</span>
<span class="nc" id="L4493">                    s.onSubscribe(new BooleanSubscription());</span>
<span class="nc" id="L4494">                    s.onNext(&quot;foo&quot;);</span>
<span class="nc" id="L4495">                    s.onComplete();</span>
<span class="nc" id="L4496">                }</span>
            }))
<span class="fc" id="L4498">            .subscribe(ts);</span>
<span class="fc" id="L4499">        ts.assertNoValues();</span>
<span class="fc" id="L4500">        ts.assertError(e);</span>
<span class="fc" id="L4501">        Assert.assertFalse(&quot;Should not have subscribed to observable when completable errors&quot;, hasRun.get());</span>
<span class="fc" id="L4502">    }</span>

    @Test
    public void andThenSingle() {
<span class="fc" id="L4506">        TestSubscriber&lt;String&gt; ts = new TestSubscriber&lt;String&gt;(0);</span>
<span class="fc" id="L4507">        Completable.complete().andThen(Single.just(&quot;foo&quot;)).toFlowable().subscribe(ts);</span>
<span class="fc" id="L4508">        ts.request(1);</span>
<span class="fc" id="L4509">        ts.assertValue(&quot;foo&quot;);</span>
<span class="fc" id="L4510">        ts.assertComplete();</span>
<span class="fc" id="L4511">        ts.assertNoErrors();</span>
<span class="fc" id="L4512">    }</span>

    @Test(expected = NullPointerException.class)
    public void fromFutureNull() {
<span class="nc" id="L4516">        Completable.fromFuture(null);</span>
<span class="nc" id="L4517">    }</span>

    @Test(timeout = 5000)
    public void fromFutureNormal() {
<span class="fc" id="L4521">        ExecutorService exec = Executors.newSingleThreadExecutor();</span>

        try {
<span class="fc" id="L4524">            Completable c = Completable.fromFuture(exec.submit(new Runnable() {</span>
                @Override
                public void run() {
                    // no action
<span class="fc" id="L4528">                }</span>
            }));

<span class="fc" id="L4531">            c.blockingAwait();</span>
        } finally {
<span class="fc" id="L4533">            exec.shutdown();</span>
        }
<span class="fc" id="L4535">    }</span>

    @Test(timeout = 5000)
    public void fromFutureThrows() {
<span class="fc" id="L4539">        ExecutorService exec = Executors.newSingleThreadExecutor();</span>

<span class="fc" id="L4541">        Completable c = Completable.fromFuture(exec.submit(new Runnable() {</span>
            @Override
            public void run() {
<span class="fc" id="L4544">                throw new TestException();</span>
            }
        }));

        try {
<span class="nc" id="L4549">            c.blockingAwait();</span>
<span class="nc" id="L4550">            Assert.fail(&quot;Failed to throw Exception&quot;);</span>
<span class="fc" id="L4551">        } catch (RuntimeException ex) {</span>
<span class="pc bpc" id="L4552" title="2 of 4 branches missed.">            if (!((ex.getCause() instanceof ExecutionException) &amp;&amp; (ex.getCause().getCause() instanceof TestException))) {</span>
<span class="nc" id="L4553">                ex.printStackTrace();</span>
<span class="nc" id="L4554">                Assert.fail(&quot;Wrong exception received&quot;);</span>
            }
        } finally {
<span class="fc" id="L4557">            exec.shutdown();</span>
        }
<span class="fc" id="L4559">    }</span>

    @Test(expected = NullPointerException.class)
    public void fromRunnableNull() {
<span class="nc" id="L4563">        Completable.fromRunnable(null);</span>
<span class="nc" id="L4564">    }</span>

    @Test(timeout = 5000)
    public void fromRunnableNormal() {
<span class="fc" id="L4568">        final AtomicInteger calls = new AtomicInteger();</span>

<span class="fc" id="L4570">        Completable c = Completable.fromRunnable(new Runnable() {</span>
            @Override
            public void run() {
<span class="fc" id="L4573">                calls.getAndIncrement();</span>
<span class="fc" id="L4574">            }</span>
        });

<span class="fc" id="L4577">        c.blockingAwait();</span>

<span class="fc" id="L4579">        Assert.assertEquals(1, calls.get());</span>
<span class="fc" id="L4580">    }</span>

    @Test(timeout = 5000, expected = TestException.class)
    public void fromRunnableThrows() {
<span class="fc" id="L4584">        Completable c = Completable.fromRunnable(new Runnable() {</span>
            @Override
<span class="fc" id="L4586">            public void run() { throw new TestException(); }</span>
        });

<span class="nc" id="L4589">        c.blockingAwait();</span>
<span class="nc" id="L4590">    }</span>

    @Test(expected = NullPointerException.class)
    public void doOnErrorNullValue() {
<span class="nc" id="L4594">        Completable.complete().doOnError(null);</span>
<span class="nc" id="L4595">    }</span>

    @Test(expected = NullPointerException.class)
    public void doOnSubscribeNullValue() {
<span class="nc" id="L4599">        Completable.complete().doOnSubscribe(null);</span>
<span class="nc" id="L4600">    }</span>

    @Test(expected = NullPointerException.class)
    public void doAfterTerminateNullValue() {
<span class="nc" id="L4604">        Completable.complete().doAfterTerminate(null);</span>
<span class="nc" id="L4605">    }</span>

    @Test(expected = NullPointerException.class)
    public void doOnTerminateNullValue() {
<span class="nc" id="L4609">        Completable.complete().doOnTerminate(null);</span>
<span class="nc" id="L4610">    }</span>

    @Test(expected = NullPointerException.class)
    public void doOnCompleteNullValue() {
<span class="nc" id="L4614">        Completable.complete().doOnComplete(null);</span>
<span class="nc" id="L4615">    }</span>

    @Test(expected = NullPointerException.class)
    public void doOnDisposeNullValue() {
<span class="nc" id="L4619">        Completable.complete().doOnDispose(null);</span>
<span class="nc" id="L4620">    }</span>

    @Test(expected = NullPointerException.class)
    public void doOnEventNullValue() {
<span class="nc" id="L4624">        Completable.complete().doOnEvent(null);</span>
<span class="nc" id="L4625">    }</span>

    @Test
    public void doOnEventComplete() {
<span class="fc" id="L4629">        final AtomicInteger atomicInteger = new AtomicInteger(0);</span>

<span class="fc" id="L4631">        Completable.complete().doOnEvent(new Consumer&lt;Throwable&gt;() {</span>
            @Override
            public void accept(final Throwable throwable) throws Exception {
<span class="pc bpc" id="L4634" title="1 of 2 branches missed.">                if (throwable == null) {</span>
<span class="fc" id="L4635">                    atomicInteger.incrementAndGet();</span>
                }
<span class="fc" id="L4637">            }</span>
<span class="fc" id="L4638">        }).subscribe();</span>

<span class="fc" id="L4640">        assertEquals(1, atomicInteger.get());</span>
<span class="fc" id="L4641">    }</span>

    @Test
    public void doOnEventError() {
<span class="fc" id="L4645">        List&lt;Throwable&gt; errors = TestHelper.trackPluginErrors();</span>
        try {
<span class="fc" id="L4647">            final AtomicInteger atomicInteger = new AtomicInteger(0);</span>

<span class="fc" id="L4649">            Completable.error(new RuntimeException()).doOnEvent(new Consumer&lt;Throwable&gt;() {</span>
                @Override
                public void accept(final Throwable throwable) throws Exception {
<span class="pc bpc" id="L4652" title="1 of 2 branches missed.">                    if (throwable != null) {</span>
<span class="fc" id="L4653">                        atomicInteger.incrementAndGet();</span>
                    }
<span class="fc" id="L4655">                }</span>
<span class="fc" id="L4656">            }).subscribe();</span>

<span class="fc" id="L4658">            assertEquals(1, atomicInteger.get());</span>

<span class="fc" id="L4660">            TestHelper.assertError(errors, 0, OnErrorNotImplementedException.class);</span>
        } finally {
<span class="fc" id="L4662">            RxJavaPlugins.reset();</span>
        }
<span class="fc" id="L4664">    }</span>

    @Test(timeout = 5000)
    public void subscribeTwoCallbacksDispose() {
<span class="fc" id="L4668">        PublishProcessor&lt;Integer&gt; pp = PublishProcessor.create();</span>
<span class="fc" id="L4669">        Disposable d = pp.ignoreElements().subscribe(Functions.EMPTY_ACTION, Functions.emptyConsumer());</span>

<span class="fc" id="L4671">        assertFalse(d.isDisposed());</span>
<span class="fc" id="L4672">        assertTrue(pp.hasSubscribers());</span>

<span class="fc" id="L4674">        d.dispose();</span>

<span class="fc" id="L4676">        assertTrue(d.isDisposed());</span>
<span class="fc" id="L4677">        assertFalse(pp.hasSubscribers());</span>
<span class="fc" id="L4678">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>