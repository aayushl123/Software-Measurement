<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CompositeException.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">RxJava_2_x$Unnamed.exec</a> &gt; <a href="index.source.html" class="el_package">io.reactivex.exceptions</a> &gt; <span class="el_source">CompositeException.java</span></div><h1>CompositeException.java</h1><pre class="source lang-java linenums">/**
 * Copyright (c) 2016-present, RxJava Contributors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.reactivex.exceptions;

import java.io.*;
import java.util.*;

import io.reactivex.annotations.NonNull;

/**
 * Represents an exception that is a composite of one or more other exceptions. A {@code CompositeException}
 * does not modify the structure of any exception it wraps, but at print-time it iterates through the list of
 * Throwables contained in the composite in order to print them all.
 *
 * Its invariant is to contain an immutable, ordered (by insertion order), unique list of non-composite
 * exceptions. You can retrieve individual exceptions in this list with {@link #getExceptions()}.
 *
 * The {@link #printStackTrace()} implementation handles the StackTrace in a customized way instead of using
 * {@code getCause()} so that it can avoid circular references.
 *
 * If you invoke {@link #getCause()}, it will lazily create the causal chain but will stop if it finds any
 * Throwable in the chain that it has already seen.
 */
public final class CompositeException extends RuntimeException {

    private static final long serialVersionUID = 3026362227162912146L;

    private final List&lt;Throwable&gt; exceptions;
    private final String message;
    private Throwable cause;

    /**
     * Constructs a CompositeException with the given array of Throwables as the
     * list of suppressed exceptions.
     * @param exceptions the Throwables to have as initially suppressed exceptions
     *
     * @throws IllegalArgumentException if &lt;code&gt;exceptions&lt;/code&gt; is empty.
     */
    public CompositeException(@NonNull Throwable... exceptions) {
<span class="pc bpc" id="L53" title="1 of 2 branches missed.">        this(exceptions == null ?</span>
<span class="pc" id="L54">                Collections.singletonList(new NullPointerException(&quot;exceptions was null&quot;)) : Arrays.asList(exceptions));</span>
<span class="fc" id="L55">    }</span>

    /**
     * Constructs a CompositeException with the given array of Throwables as the
     * list of suppressed exceptions.
     * @param errors the Throwables to have as initially suppressed exceptions
     *
     * @throws IllegalArgumentException if &lt;code&gt;errors&lt;/code&gt; is empty.
     */
<span class="fc" id="L64">    public CompositeException(@NonNull Iterable&lt;? extends Throwable&gt; errors) {</span>
<span class="fc" id="L65">        Set&lt;Throwable&gt; deDupedExceptions = new LinkedHashSet&lt;Throwable&gt;();</span>
<span class="fc" id="L66">        List&lt;Throwable&gt; localExceptions = new ArrayList&lt;Throwable&gt;();</span>
<span class="pc bpc" id="L67" title="1 of 2 branches missed.">        if (errors != null) {</span>
<span class="fc bfc" id="L68" title="All 2 branches covered.">            for (Throwable ex : errors) {</span>
<span class="fc bfc" id="L69" title="All 2 branches covered.">                if (ex instanceof CompositeException) {</span>
<span class="fc" id="L70">                    deDupedExceptions.addAll(((CompositeException) ex).getExceptions());</span>
                } else
<span class="fc bfc" id="L72" title="All 2 branches covered.">                if (ex != null) {</span>
<span class="fc" id="L73">                    deDupedExceptions.add(ex);</span>
                } else {
<span class="fc" id="L75">                    deDupedExceptions.add(new NullPointerException(&quot;Throwable was null!&quot;));</span>
                }
<span class="fc" id="L77">            }</span>
        } else {
<span class="nc" id="L79">            deDupedExceptions.add(new NullPointerException(&quot;errors was null&quot;));</span>
        }
<span class="pc bpc" id="L81" title="1 of 2 branches missed.">        if (deDupedExceptions.isEmpty()) {</span>
<span class="nc" id="L82">            throw new IllegalArgumentException(&quot;errors is empty&quot;);</span>
        }
<span class="fc" id="L84">        localExceptions.addAll(deDupedExceptions);</span>
<span class="fc" id="L85">        this.exceptions = Collections.unmodifiableList(localExceptions);</span>
<span class="fc" id="L86">        this.message = exceptions.size() + &quot; exceptions occurred. &quot;;</span>
<span class="fc" id="L87">    }</span>

    /**
     * Retrieves the list of exceptions that make up the {@code CompositeException}.
     *
     * @return the exceptions that make up the {@code CompositeException}, as a {@link List} of {@link Throwable}s
     */
    @NonNull
    public List&lt;Throwable&gt; getExceptions() {
<span class="fc" id="L96">        return exceptions;</span>
    }

    @Override
    @NonNull
    public String getMessage() {
<span class="fc" id="L102">        return message;</span>
    }

    @Override
    @NonNull
    public synchronized Throwable getCause() { // NOPMD
<span class="nc bnc" id="L108" title="All 2 branches missed.">        if (cause == null) {</span>
            // we lazily generate this causal chain if this is called
<span class="nc" id="L110">            CompositeExceptionCausalChain localCause = new CompositeExceptionCausalChain();</span>
<span class="nc" id="L111">            Set&lt;Throwable&gt; seenCauses = new HashSet&lt;Throwable&gt;();</span>

<span class="nc" id="L113">            Throwable chain = localCause;</span>
<span class="nc bnc" id="L114" title="All 2 branches missed.">            for (Throwable e : exceptions) {</span>
<span class="nc bnc" id="L115" title="All 2 branches missed.">                if (seenCauses.contains(e)) {</span>
                    // already seen this outer Throwable so skip
<span class="nc" id="L117">                    continue;</span>
                }
<span class="nc" id="L119">                seenCauses.add(e);</span>

<span class="nc" id="L121">                List&lt;Throwable&gt; listOfCauses = getListOfCauses(e);</span>
                // check if any of them have been seen before
<span class="nc bnc" id="L123" title="All 2 branches missed.">                for (Throwable child : listOfCauses) {</span>
<span class="nc bnc" id="L124" title="All 2 branches missed.">                    if (seenCauses.contains(child)) {</span>
                        // already seen this outer Throwable so skip
<span class="nc" id="L126">                        e = new RuntimeException(&quot;Duplicate found in causal chain so cropping to prevent loop ...&quot;);</span>
<span class="nc" id="L127">                        continue;</span>
                    }
<span class="nc" id="L129">                    seenCauses.add(child);</span>
<span class="nc" id="L130">                }</span>

                // we now have 'e' as the last in the chain
                try {
<span class="nc" id="L134">                    chain.initCause(e);</span>
<span class="nc" id="L135">                } catch (Throwable t) { // NOPMD</span>
                    // ignore
                    // the JavaDocs say that some Throwables (depending on how they're made) will never
                    // let me call initCause without blowing up even if it returns null
<span class="nc" id="L139">                }</span>
<span class="nc" id="L140">                chain = getRootCause(chain);</span>
<span class="nc" id="L141">            }</span>
<span class="nc" id="L142">            cause = localCause;</span>
        }
<span class="nc" id="L144">        return cause;</span>
    }

    /**
     * All of the following {@code printStackTrace} functionality is derived from JDK {@link Throwable}
     * {@code printStackTrace}. In particular, the {@code PrintStreamOrWriter} abstraction is copied wholesale.
     *
     * Changes from the official JDK implementation:&lt;ul&gt;
     * &lt;li&gt;no infinite loop detection&lt;/li&gt;
     * &lt;li&gt;smaller critical section holding {@link PrintStream} lock&lt;/li&gt;
     * &lt;li&gt;explicit knowledge about the exceptions {@link List} that this loops through&lt;/li&gt;
     * &lt;/ul&gt;
     */
    @Override
    public void printStackTrace() {
<span class="nc" id="L159">        printStackTrace(System.err);</span>
<span class="nc" id="L160">    }</span>

    @Override
    public void printStackTrace(PrintStream s) {
<span class="nc" id="L164">        printStackTrace(new WrappedPrintStream(s));</span>
<span class="nc" id="L165">    }</span>

    @Override
    public void printStackTrace(PrintWriter s) {
<span class="nc" id="L169">        printStackTrace(new WrappedPrintWriter(s));</span>
<span class="nc" id="L170">    }</span>

    /**
     * Special handling for printing out a {@code CompositeException}.
     * Loops through all inner exceptions and prints them out.
     *
     * @param s
     *            stream to print to
     */
    private void printStackTrace(PrintStreamOrWriter s) {
<span class="nc" id="L180">        StringBuilder b = new StringBuilder(128);</span>
<span class="nc" id="L181">        b.append(this).append('\n');</span>
<span class="nc bnc" id="L182" title="All 2 branches missed.">        for (StackTraceElement myStackElement : getStackTrace()) {</span>
<span class="nc" id="L183">            b.append(&quot;\tat &quot;).append(myStackElement).append('\n');</span>
        }
<span class="nc" id="L185">        int i = 1;</span>
<span class="nc bnc" id="L186" title="All 2 branches missed.">        for (Throwable ex : exceptions) {</span>
<span class="nc" id="L187">            b.append(&quot;  ComposedException &quot;).append(i).append(&quot; :\n&quot;);</span>
<span class="nc" id="L188">            appendStackTrace(b, ex, &quot;\t&quot;);</span>
<span class="nc" id="L189">            i++;</span>
<span class="nc" id="L190">        }</span>
<span class="nc" id="L191">        s.println(b.toString());</span>
<span class="nc" id="L192">    }</span>

    private void appendStackTrace(StringBuilder b, Throwable ex, String prefix) {
<span class="nc" id="L195">        b.append(prefix).append(ex).append('\n');</span>
<span class="nc bnc" id="L196" title="All 2 branches missed.">        for (StackTraceElement stackElement : ex.getStackTrace()) {</span>
<span class="nc" id="L197">            b.append(&quot;\t\tat &quot;).append(stackElement).append('\n');</span>
        }
<span class="nc bnc" id="L199" title="All 2 branches missed.">        if (ex.getCause() != null) {</span>
<span class="nc" id="L200">            b.append(&quot;\tCaused by: &quot;);</span>
<span class="nc" id="L201">            appendStackTrace(b, ex.getCause(), &quot;&quot;);</span>
        }
<span class="nc" id="L203">    }</span>

<span class="nc" id="L205">    abstract static class PrintStreamOrWriter {</span>
        /** Prints the specified string as a line on this StreamOrWriter. */
        abstract void println(Object o);
    }

    /**
     * Same abstraction and implementation as in JDK to allow PrintStream and PrintWriter to share implementation.
     */
    static final class WrappedPrintStream extends PrintStreamOrWriter {
        private final PrintStream printStream;

<span class="nc" id="L216">        WrappedPrintStream(PrintStream printStream) {</span>
<span class="nc" id="L217">            this.printStream = printStream;</span>
<span class="nc" id="L218">        }</span>

        @Override
        void println(Object o) {
<span class="nc" id="L222">            printStream.println(o);</span>
<span class="nc" id="L223">        }</span>
    }

    static final class WrappedPrintWriter extends PrintStreamOrWriter {
        private final PrintWriter printWriter;

<span class="nc" id="L229">        WrappedPrintWriter(PrintWriter printWriter) {</span>
<span class="nc" id="L230">            this.printWriter = printWriter;</span>
<span class="nc" id="L231">        }</span>

        @Override
        void println(Object o) {
<span class="nc" id="L235">            printWriter.println(o);</span>
<span class="nc" id="L236">        }</span>
    }

<span class="nc" id="L239">    static final class CompositeExceptionCausalChain extends RuntimeException {</span>
        private static final long serialVersionUID = 3875212506787802066L;
        /* package-private */static final String MESSAGE = &quot;Chain of Causes for CompositeException In Order Received =&gt;&quot;;

        @Override
        public String getMessage() {
<span class="nc" id="L245">            return MESSAGE;</span>
        }
    }

    private List&lt;Throwable&gt; getListOfCauses(Throwable ex) {
<span class="nc" id="L250">        List&lt;Throwable&gt; list = new ArrayList&lt;Throwable&gt;();</span>
<span class="nc" id="L251">        Throwable root = ex.getCause();</span>
<span class="nc bnc" id="L252" title="All 4 branches missed.">        if (root == null || root == ex) {</span>
<span class="nc" id="L253">            return list;</span>
        } else {
            while (true) {
<span class="nc" id="L256">                list.add(root);</span>
<span class="nc" id="L257">                Throwable cause = root.getCause();</span>
<span class="nc bnc" id="L258" title="All 4 branches missed.">                if (cause == null || cause == root) {</span>
<span class="nc" id="L259">                    return list;</span>
                } else {
<span class="nc" id="L261">                    root = cause;</span>
                }
<span class="nc" id="L263">            }</span>
        }
    }

    /**
     * Returns the number of suppressed exceptions.
     * @return the number of suppressed exceptions
     */
    public int size() {
<span class="fc" id="L272">        return exceptions.size();</span>
    }

    /**
     * Returns the root cause of {@code e}. If {@code e.getCause()} returns {@code null} or {@code e}, just return {@code e} itself.
     *
     * @param e the {@link Throwable} {@code e}.
     * @return The root cause of {@code e}. If {@code e.getCause()} returns {@code null} or {@code e}, just return {@code e} itself.
     */
    /*private */Throwable getRootCause(Throwable e) {
<span class="nc" id="L282">        Throwable root = e.getCause();</span>
<span class="nc bnc" id="L283" title="All 4 branches missed.">        if (root == null || e == root) {</span>
<span class="nc" id="L284">            return e;</span>
        }
        while (true) {
<span class="nc" id="L287">            Throwable cause = root.getCause();</span>
<span class="nc bnc" id="L288" title="All 4 branches missed.">            if (cause == null || cause == root) {</span>
<span class="nc" id="L289">                return root;</span>
            }
<span class="nc" id="L291">            root = cause;</span>
<span class="nc" id="L292">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>