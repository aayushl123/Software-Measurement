<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FlowableTests.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">RxJava_2_x$Unnamed.exec</a> &gt; <a href="index.source.html" class="el_package">io.reactivex.flowable</a> &gt; <span class="el_source">FlowableTests.java</span></div><h1>FlowableTests.java</h1><pre class="source lang-java linenums">/**
 * Copyright (c) 2016-present, RxJava Contributors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is
 * distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
 * the License for the specific language governing permissions and limitations under the License.
 */

package io.reactivex.flowable;

import static org.junit.Assert.*;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;

import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.*;

import org.junit.*;
import org.mockito.InOrder;
import org.reactivestreams.*;

import io.reactivex.*;
import io.reactivex.Observable;
import io.reactivex.disposables.Disposable;
import io.reactivex.exceptions.*;
import io.reactivex.flowables.ConnectableFlowable;
import io.reactivex.functions.*;
import io.reactivex.internal.functions.Functions;
import io.reactivex.internal.subscriptions.BooleanSubscription;
import io.reactivex.plugins.RxJavaPlugins;
import io.reactivex.processors.*;
import io.reactivex.schedulers.*;
import io.reactivex.subscribers.*;

<span class="fc" id="L41">public class FlowableTests {</span>

    Subscriber&lt;Number&gt; w;

    SingleObserver&lt;Number&gt; wo;

    MaybeObserver&lt;Number&gt; wm;

<span class="fc" id="L49">    private static final Predicate&lt;Integer&gt; IS_EVEN = new Predicate&lt;Integer&gt;() {</span>
        @Override
        public boolean test(Integer v) {
<span class="fc bfc" id="L52" title="All 2 branches covered.">            return v % 2 == 0;</span>
        }
    };

    @Before
    public void before() {
<span class="fc" id="L58">        w = TestHelper.mockSubscriber();</span>
<span class="fc" id="L59">        wo = TestHelper.mockSingleObserver();</span>
<span class="fc" id="L60">        wm = TestHelper.mockMaybeObserver();</span>
<span class="fc" id="L61">    }</span>

    @Test
    public void fromArray() {
<span class="fc" id="L65">        String[] items = new String[] { &quot;one&quot;, &quot;two&quot;, &quot;three&quot; };</span>
<span class="fc" id="L66">        assertEquals((Long)3L, Flowable.fromArray(items).count().blockingGet());</span>
<span class="fc" id="L67">        assertEquals(&quot;two&quot;, Flowable.fromArray(items).skip(1).take(1).blockingSingle());</span>
<span class="fc" id="L68">        assertEquals(&quot;three&quot;, Flowable.fromArray(items).takeLast(1).blockingSingle());</span>
<span class="fc" id="L69">    }</span>

    @Test
    public void fromIterable() {
<span class="fc" id="L73">        ArrayList&lt;String&gt; items = new ArrayList&lt;String&gt;();</span>
<span class="fc" id="L74">        items.add(&quot;one&quot;);</span>
<span class="fc" id="L75">        items.add(&quot;two&quot;);</span>
<span class="fc" id="L76">        items.add(&quot;three&quot;);</span>

<span class="fc" id="L78">        assertEquals((Long)3L, Flowable.fromIterable(items).count().blockingGet());</span>
<span class="fc" id="L79">        assertEquals(&quot;two&quot;, Flowable.fromIterable(items).skip(1).take(1).blockingSingle());</span>
<span class="fc" id="L80">        assertEquals(&quot;three&quot;, Flowable.fromIterable(items).takeLast(1).blockingSingle());</span>
<span class="fc" id="L81">    }</span>

    @Test
    public void fromArityArgs3() {
<span class="fc" id="L85">        Flowable&lt;String&gt; items = Flowable.just(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;);</span>

<span class="fc" id="L87">        assertEquals((Long)3L, items.count().blockingGet());</span>
<span class="fc" id="L88">        assertEquals(&quot;two&quot;, items.skip(1).take(1).blockingSingle());</span>
<span class="fc" id="L89">        assertEquals(&quot;three&quot;, items.takeLast(1).blockingSingle());</span>
<span class="fc" id="L90">    }</span>

    @Test
    public void fromArityArgs1() {
<span class="fc" id="L94">        Flowable&lt;String&gt; items = Flowable.just(&quot;one&quot;);</span>

<span class="fc" id="L96">        assertEquals((Long)1L, items.count().blockingGet());</span>
<span class="fc" id="L97">        assertEquals(&quot;one&quot;, items.takeLast(1).blockingSingle());</span>
<span class="fc" id="L98">    }</span>

    @Test
    public void testCreate() {

<span class="fc" id="L103">        Flowable&lt;String&gt; flowable = Flowable.just(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;);</span>

<span class="fc" id="L105">        Subscriber&lt;String&gt; subscriber = TestHelper.mockSubscriber();</span>

<span class="fc" id="L107">        flowable.subscribe(subscriber);</span>

<span class="fc" id="L109">        verify(subscriber, times(1)).onNext(&quot;one&quot;);</span>
<span class="fc" id="L110">        verify(subscriber, times(1)).onNext(&quot;two&quot;);</span>
<span class="fc" id="L111">        verify(subscriber, times(1)).onNext(&quot;three&quot;);</span>
<span class="fc" id="L112">        verify(subscriber, never()).onError(any(Throwable.class));</span>
<span class="fc" id="L113">        verify(subscriber, times(1)).onComplete();</span>
<span class="fc" id="L114">    }</span>

    @Test
    public void testCountAFewItemsFlowable() {
<span class="fc" id="L118">        Flowable&lt;String&gt; flowable = Flowable.just(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;);</span>

<span class="fc" id="L120">        flowable.count().toFlowable().subscribe(w);</span>

        // we should be called only once
<span class="fc" id="L123">        verify(w).onNext(4L);</span>
<span class="fc" id="L124">        verify(w, never()).onError(any(Throwable.class));</span>
<span class="fc" id="L125">        verify(w, times(1)).onComplete();</span>
<span class="fc" id="L126">    }</span>

    @Test
    public void testCountZeroItemsFlowable() {
<span class="fc" id="L130">        Flowable&lt;String&gt; flowable = Flowable.empty();</span>
<span class="fc" id="L131">        flowable.count().toFlowable().subscribe(w);</span>
        // we should be called only once
<span class="fc" id="L133">        verify(w).onNext(0L);</span>
<span class="fc" id="L134">        verify(w, never()).onError(any(Throwable.class));</span>
<span class="fc" id="L135">        verify(w, times(1)).onComplete();</span>
<span class="fc" id="L136">    }</span>

    @Test
    public void testCountErrorFlowable() {
<span class="fc" id="L140">        Flowable&lt;String&gt; f = Flowable.error(new Callable&lt;Throwable&gt;() {</span>
            @Override
            public Throwable call() {
<span class="fc" id="L143">                return new RuntimeException();</span>
            }
        });

<span class="fc" id="L147">        f.count().toFlowable().subscribe(w);</span>
<span class="fc" id="L148">        verify(w, never()).onNext(anyInt());</span>
<span class="fc" id="L149">        verify(w, never()).onComplete();</span>
<span class="fc" id="L150">        verify(w, times(1)).onError(any(RuntimeException.class));</span>
<span class="fc" id="L151">    }</span>

    @Test
    public void testCountAFewItems() {
<span class="fc" id="L155">        Flowable&lt;String&gt; flowable = Flowable.just(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;);</span>

<span class="fc" id="L157">        flowable.count().subscribe(wo);</span>

        // we should be called only once
<span class="fc" id="L160">        verify(wo).onSuccess(4L);</span>
<span class="fc" id="L161">        verify(wo, never()).onError(any(Throwable.class));</span>
<span class="fc" id="L162">    }</span>

    @Test
    public void testCountZeroItems() {
<span class="fc" id="L166">        Flowable&lt;String&gt; flowable = Flowable.empty();</span>
<span class="fc" id="L167">        flowable.count().subscribe(wo);</span>
        // we should be called only once
<span class="fc" id="L169">        verify(wo).onSuccess(0L);</span>
<span class="fc" id="L170">        verify(wo, never()).onError(any(Throwable.class));</span>
<span class="fc" id="L171">    }</span>

    @Test
    public void testCountError() {
<span class="fc" id="L175">        Flowable&lt;String&gt; f = Flowable.error(new Callable&lt;Throwable&gt;() {</span>
            @Override
            public Throwable call() {
<span class="fc" id="L178">                return new RuntimeException();</span>
            }
        });

<span class="fc" id="L182">        f.count().subscribe(wo);</span>
<span class="fc" id="L183">        verify(wo, never()).onSuccess(anyInt());</span>
<span class="fc" id="L184">        verify(wo, times(1)).onError(any(RuntimeException.class));</span>
<span class="fc" id="L185">    }</span>

    @Test
    public void testTakeFirstWithPredicateOfSome() {
<span class="fc" id="L189">        Flowable&lt;Integer&gt; flowable = Flowable.just(1, 3, 5, 4, 6, 3);</span>
<span class="fc" id="L190">        flowable.filter(IS_EVEN).take(1).subscribe(w);</span>
<span class="fc" id="L191">        verify(w, times(1)).onNext(anyInt());</span>
<span class="fc" id="L192">        verify(w).onNext(4);</span>
<span class="fc" id="L193">        verify(w, times(1)).onComplete();</span>
<span class="fc" id="L194">        verify(w, never()).onError(any(Throwable.class));</span>
<span class="fc" id="L195">    }</span>

    @Test
    public void testTakeFirstWithPredicateOfNoneMatchingThePredicate() {
<span class="fc" id="L199">        Flowable&lt;Integer&gt; flowable = Flowable.just(1, 3, 5, 7, 9, 7, 5, 3, 1);</span>
<span class="fc" id="L200">        flowable.filter(IS_EVEN).take(1).subscribe(w);</span>
<span class="fc" id="L201">        verify(w, never()).onNext(anyInt());</span>
<span class="fc" id="L202">        verify(w, times(1)).onComplete();</span>
<span class="fc" id="L203">        verify(w, never()).onError(any(Throwable.class));</span>
<span class="fc" id="L204">    }</span>

    @Test
    public void testTakeFirstOfSome() {
<span class="fc" id="L208">        Flowable&lt;Integer&gt; flowable = Flowable.just(1, 2, 3);</span>
<span class="fc" id="L209">        flowable.take(1).subscribe(w);</span>
<span class="fc" id="L210">        verify(w, times(1)).onNext(anyInt());</span>
<span class="fc" id="L211">        verify(w).onNext(1);</span>
<span class="fc" id="L212">        verify(w, times(1)).onComplete();</span>
<span class="fc" id="L213">        verify(w, never()).onError(any(Throwable.class));</span>
<span class="fc" id="L214">    }</span>

    @Test
    public void testTakeFirstOfNone() {
<span class="fc" id="L218">        Flowable&lt;Integer&gt; flowable = Flowable.empty();</span>
<span class="fc" id="L219">        flowable.take(1).subscribe(w);</span>
<span class="fc" id="L220">        verify(w, never()).onNext(anyInt());</span>
<span class="fc" id="L221">        verify(w, times(1)).onComplete();</span>
<span class="fc" id="L222">        verify(w, never()).onError(any(Throwable.class));</span>
<span class="fc" id="L223">    }</span>

    @Test
    public void testFirstOfNoneFlowable() {
<span class="fc" id="L227">        Flowable&lt;Integer&gt; flowable = Flowable.empty();</span>
<span class="fc" id="L228">        flowable.firstElement().toFlowable().subscribe(w);</span>
<span class="fc" id="L229">        verify(w, never()).onNext(anyInt());</span>
<span class="fc" id="L230">        verify(w).onComplete();</span>
<span class="fc" id="L231">        verify(w, never()).onError(any(Throwable.class));</span>
<span class="fc" id="L232">    }</span>

    @Test
    public void testFirstWithPredicateOfNoneMatchingThePredicateFlowable() {
<span class="fc" id="L236">        Flowable&lt;Integer&gt; flowable = Flowable.just(1, 3, 5, 7, 9, 7, 5, 3, 1);</span>
<span class="fc" id="L237">        flowable.filter(IS_EVEN).firstElement().toFlowable().subscribe(w);</span>
<span class="fc" id="L238">        verify(w, never()).onNext(anyInt());</span>
<span class="fc" id="L239">        verify(w).onComplete();</span>
<span class="fc" id="L240">        verify(w, never()).onError(any(Throwable.class));</span>
<span class="fc" id="L241">    }</span>

    @Test
    public void testFirstOfNone() {
<span class="fc" id="L245">        Flowable&lt;Integer&gt; flowable = Flowable.empty();</span>
<span class="fc" id="L246">        flowable.firstElement().subscribe(wm);</span>
<span class="fc" id="L247">        verify(wm, never()).onSuccess(anyInt());</span>
<span class="fc" id="L248">        verify(wm).onComplete();</span>
<span class="fc" id="L249">        verify(wm, never()).onError(isA(NoSuchElementException.class));</span>
<span class="fc" id="L250">    }</span>

    @Test
    public void testFirstWithPredicateOfNoneMatchingThePredicate() {
<span class="fc" id="L254">        Flowable&lt;Integer&gt; flowable = Flowable.just(1, 3, 5, 7, 9, 7, 5, 3, 1);</span>
<span class="fc" id="L255">        flowable.filter(IS_EVEN).firstElement().subscribe(wm);</span>
<span class="fc" id="L256">        verify(wm, never()).onSuccess(anyInt());</span>
<span class="fc" id="L257">        verify(wm, times(1)).onComplete();</span>
<span class="fc" id="L258">        verify(wm, never()).onError(isA(NoSuchElementException.class));</span>
<span class="fc" id="L259">    }</span>

    @Test
    public void testReduce() {
<span class="fc" id="L263">        Flowable&lt;Integer&gt; flowable = Flowable.just(1, 2, 3, 4);</span>
<span class="fc" id="L264">        flowable.reduce(new BiFunction&lt;Integer, Integer, Integer&gt;() {</span>
            @Override
            public Integer apply(Integer t1, Integer t2) {
<span class="fc" id="L267">                return t1 + t2;</span>
            }
        })
<span class="fc" id="L270">        .toFlowable()</span>
<span class="fc" id="L271">        .subscribe(w);</span>
        // we should be called only once
<span class="fc" id="L273">        verify(w, times(1)).onNext(anyInt());</span>
<span class="fc" id="L274">        verify(w).onNext(10);</span>
<span class="fc" id="L275">    }</span>

    @Test
    public void testReduceWithEmptyObservable() {
<span class="fc" id="L279">        Flowable&lt;Integer&gt; flowable = Flowable.range(1, 0);</span>
<span class="fc" id="L280">        flowable.reduce(new BiFunction&lt;Integer, Integer, Integer&gt;() {</span>
            @Override
            public Integer apply(Integer t1, Integer t2) {
<span class="nc" id="L283">                return t1 + t2;</span>
            }
        })
<span class="fc" id="L286">        .toFlowable()</span>
<span class="fc" id="L287">        .test()</span>
<span class="fc" id="L288">        .assertResult();</span>
<span class="fc" id="L289">    }</span>

    /**
     * A reduce on an empty Observable and a seed should just pass the seed through.
     *
     * This is confirmed at https://github.com/ReactiveX/RxJava/issues/423#issuecomment-27642456
     */
    @Test
    public void testReduceWithEmptyObservableAndSeed() {
<span class="fc" id="L298">        Flowable&lt;Integer&gt; flowable = Flowable.range(1, 0);</span>
<span class="fc" id="L299">        int value = flowable.reduce(1, new BiFunction&lt;Integer, Integer, Integer&gt;() {</span>
            @Override
            public Integer apply(Integer t1, Integer t2) {
<span class="nc" id="L302">                return t1 + t2;</span>
            }
        })
<span class="fc" id="L305">        .blockingGet();</span>

<span class="fc" id="L307">        assertEquals(1, value);</span>
<span class="fc" id="L308">    }</span>

    @Test
    public void testReduceWithInitialValue() {
<span class="fc" id="L312">        Flowable&lt;Integer&gt; flowable = Flowable.just(1, 2, 3, 4);</span>
<span class="fc" id="L313">        flowable.reduce(50, new BiFunction&lt;Integer, Integer, Integer&gt;() {</span>
            @Override
            public Integer apply(Integer t1, Integer t2) {
<span class="fc" id="L316">                return t1 + t2;</span>
            }
        })
<span class="fc" id="L319">        .subscribe(wo);</span>
        // we should be called only once
<span class="fc" id="L321">        verify(wo, times(1)).onSuccess(anyInt());</span>
<span class="fc" id="L322">        verify(wo).onSuccess(60);</span>
<span class="fc" id="L323">    }</span>

    @Ignore(&quot;Throwing is not allowed from the unsafeCreate?!&quot;)
    @Test // FIXME throwing is not allowed from the create?!
    public void testOnSubscribeFails() {
<span class="nc" id="L328">        Subscriber&lt;String&gt; subscriber = TestHelper.mockSubscriber();</span>

<span class="nc" id="L330">        final RuntimeException re = new RuntimeException(&quot;bad impl&quot;);</span>
<span class="nc" id="L331">        Flowable&lt;String&gt; f = Flowable.unsafeCreate(new Publisher&lt;String&gt;() {</span>
            @Override
<span class="nc" id="L333">            public void subscribe(Subscriber&lt;? super String&gt; s) { throw re; }</span>
        });

<span class="nc" id="L336">        f.subscribe(subscriber);</span>

<span class="nc" id="L338">        verify(subscriber, times(0)).onNext(anyString());</span>
<span class="nc" id="L339">        verify(subscriber, times(0)).onComplete();</span>
<span class="nc" id="L340">        verify(subscriber, times(1)).onError(re);</span>
<span class="nc" id="L341">    }</span>

    @Test
    public void testMaterializeDematerializeChaining() {
<span class="fc" id="L345">        Flowable&lt;Integer&gt; obs = Flowable.just(1);</span>
<span class="fc" id="L346">        Flowable&lt;Integer&gt; chained = obs.materialize()</span>
<span class="fc" id="L347">                .dematerialize(Functions.&lt;Notification&lt;Integer&gt;&gt;identity());</span>

<span class="fc" id="L349">        Subscriber&lt;Integer&gt; subscriber = TestHelper.mockSubscriber();</span>

<span class="fc" id="L351">        chained.subscribe(subscriber);</span>

<span class="fc" id="L353">        verify(subscriber, times(1)).onNext(1);</span>
<span class="fc" id="L354">        verify(subscriber, times(1)).onComplete();</span>
<span class="fc" id="L355">        verify(subscriber, times(0)).onError(any(Throwable.class));</span>
<span class="fc" id="L356">    }</span>

    /**
     * The error from the user provided Observer is not handled by the subscribe method try/catch.
     *
     * It is handled by the AtomicObserver that wraps the provided Observer.
     *
     * Result: Passes (if AtomicObserver functionality exists)
     * @throws InterruptedException if the test is interrupted
     */
    @Test
    public void testCustomObservableWithErrorInObserverAsynchronous() throws InterruptedException {
<span class="fc" id="L368">        final CountDownLatch latch = new CountDownLatch(1);</span>
<span class="fc" id="L369">        final AtomicInteger count = new AtomicInteger();</span>
<span class="fc" id="L370">        final AtomicReference&lt;Throwable&gt; error = new AtomicReference&lt;Throwable&gt;();</span>

        // FIXME custom built???
<span class="fc" id="L373">        Flowable.just(&quot;1&quot;, &quot;2&quot;, &quot;three&quot;, &quot;4&quot;)</span>
<span class="fc" id="L374">        .subscribeOn(Schedulers.newThread())</span>
<span class="fc" id="L375">        .safeSubscribe(new DefaultSubscriber&lt;String&gt;() {</span>
            @Override
            public void onComplete() {
<span class="nc" id="L378">                System.out.println(&quot;completed&quot;);</span>
<span class="nc" id="L379">                latch.countDown();</span>
<span class="nc" id="L380">            }</span>

            @Override
            public void onError(Throwable e) {
<span class="fc" id="L384">                error.set(e);</span>
<span class="fc" id="L385">                System.out.println(&quot;error&quot;);</span>
<span class="fc" id="L386">                e.printStackTrace();</span>
<span class="fc" id="L387">                latch.countDown();</span>
<span class="fc" id="L388">            }</span>

            @Override
            public void onNext(String v) {
<span class="fc" id="L392">                int num = Integer.parseInt(v);</span>
<span class="fc" id="L393">                System.out.println(num);</span>
                // doSomething(num);
<span class="fc" id="L395">                count.incrementAndGet();</span>
<span class="fc" id="L396">            }</span>

        });

        // wait for async sequence to complete
<span class="fc" id="L401">        latch.await();</span>

<span class="fc" id="L403">        assertEquals(2, count.get());</span>
<span class="fc" id="L404">        assertNotNull(error.get());</span>
<span class="pc bpc" id="L405" title="1 of 2 branches missed.">        if (!(error.get() instanceof NumberFormatException)) {</span>
<span class="nc" id="L406">            fail(&quot;It should be a NumberFormatException&quot;);</span>
        }
<span class="fc" id="L408">    }</span>

    /**
     * The error from the user provided Observer is handled by the subscribe try/catch because this is synchronous.
     *
     * Result: Passes
     */
    @Test
    public void testCustomObservableWithErrorInObserverSynchronous() {
<span class="fc" id="L417">        final AtomicInteger count = new AtomicInteger();</span>
<span class="fc" id="L418">        final AtomicReference&lt;Throwable&gt; error = new AtomicReference&lt;Throwable&gt;();</span>

        // FIXME custom built???
<span class="fc" id="L421">        Flowable.just(&quot;1&quot;, &quot;2&quot;, &quot;three&quot;, &quot;4&quot;)</span>
<span class="fc" id="L422">        .safeSubscribe(new DefaultSubscriber&lt;String&gt;() {</span>

            @Override
            public void onComplete() {
<span class="nc" id="L426">                System.out.println(&quot;completed&quot;);</span>
<span class="nc" id="L427">            }</span>

            @Override
            public void onError(Throwable e) {
<span class="fc" id="L431">                error.set(e);</span>
<span class="fc" id="L432">                System.out.println(&quot;error&quot;);</span>
<span class="fc" id="L433">                e.printStackTrace();</span>
<span class="fc" id="L434">            }</span>

            @Override
            public void onNext(String v) {
<span class="fc" id="L438">                int num = Integer.parseInt(v);</span>
<span class="fc" id="L439">                System.out.println(num);</span>
                // doSomething(num);
<span class="fc" id="L441">                count.incrementAndGet();</span>
<span class="fc" id="L442">            }</span>

        });
<span class="fc" id="L445">        assertEquals(2, count.get());</span>
<span class="fc" id="L446">        assertNotNull(error.get());</span>
<span class="pc bpc" id="L447" title="1 of 2 branches missed.">        if (!(error.get() instanceof NumberFormatException)) {</span>
<span class="nc" id="L448">            fail(&quot;It should be a NumberFormatException&quot;);</span>
        }
<span class="fc" id="L450">    }</span>

    /**
     * The error from the user provided Observable is handled by the subscribe try/catch because this is synchronous.
     *
     * Result: Passes
     */
    @Test
    public void testCustomObservableWithErrorInObservableSynchronous() {
<span class="fc" id="L459">        final AtomicInteger count = new AtomicInteger();</span>
<span class="fc" id="L460">        final AtomicReference&lt;Throwable&gt; error = new AtomicReference&lt;Throwable&gt;();</span>
        // FIXME custom built???
<span class="fc" id="L462">        Flowable.just(&quot;1&quot;, &quot;2&quot;).concatWith(Flowable.&lt;String&gt;error(new Callable&lt;Throwable&gt;() {</span>
            @Override
            public Throwable call() {
<span class="fc" id="L465">                return new NumberFormatException();</span>
            }
        }))
<span class="fc" id="L468">        .subscribe(new DefaultSubscriber&lt;String&gt;() {</span>

            @Override
            public void onComplete() {
<span class="nc" id="L472">                System.out.println(&quot;completed&quot;);</span>
<span class="nc" id="L473">            }</span>

            @Override
            public void onError(Throwable e) {
<span class="fc" id="L477">                error.set(e);</span>
<span class="fc" id="L478">                System.out.println(&quot;error&quot;);</span>
<span class="fc" id="L479">                e.printStackTrace();</span>
<span class="fc" id="L480">            }</span>

            @Override
            public void onNext(String v) {
<span class="fc" id="L484">                System.out.println(v);</span>
<span class="fc" id="L485">                count.incrementAndGet();</span>
<span class="fc" id="L486">            }</span>

        });
<span class="fc" id="L489">        assertEquals(2, count.get());</span>
<span class="fc" id="L490">        assertNotNull(error.get());</span>
<span class="pc bpc" id="L491" title="1 of 2 branches missed.">        if (!(error.get() instanceof NumberFormatException)) {</span>
<span class="nc" id="L492">            fail(&quot;It should be a NumberFormatException&quot;);</span>
        }
<span class="fc" id="L494">    }</span>

    @Test
    public void testPublishLast() throws InterruptedException {
<span class="fc" id="L498">        final AtomicInteger count = new AtomicInteger();</span>
<span class="fc" id="L499">        ConnectableFlowable&lt;String&gt; connectable = Flowable.&lt;String&gt;unsafeCreate(new Publisher&lt;String&gt;() {</span>
            @Override
            public void subscribe(final Subscriber&lt;? super String&gt; subscriber) {
<span class="fc" id="L502">                subscriber.onSubscribe(new BooleanSubscription());</span>
<span class="fc" id="L503">                count.incrementAndGet();</span>
<span class="fc" id="L504">                new Thread(new Runnable() {</span>
                    @Override
                    public void run() {
<span class="fc" id="L507">                        subscriber.onNext(&quot;first&quot;);</span>
<span class="fc" id="L508">                        subscriber.onNext(&quot;last&quot;);</span>
<span class="fc" id="L509">                        subscriber.onComplete();</span>
<span class="fc" id="L510">                    }</span>
<span class="fc" id="L511">                }).start();</span>
<span class="fc" id="L512">            }</span>
<span class="fc" id="L513">        }).takeLast(1).publish();</span>

        // subscribe once
<span class="fc" id="L516">        final CountDownLatch latch = new CountDownLatch(1);</span>
<span class="fc" id="L517">        connectable.subscribe(new Consumer&lt;String&gt;() {</span>
            @Override
            public void accept(String value) {
<span class="fc" id="L520">                assertEquals(&quot;last&quot;, value);</span>
<span class="fc" id="L521">                latch.countDown();</span>
<span class="fc" id="L522">            }</span>
        });

        // subscribe twice
<span class="fc" id="L526">        connectable.subscribe();</span>

<span class="fc" id="L528">        Disposable subscription = connectable.connect();</span>
<span class="fc" id="L529">        assertTrue(latch.await(1000, TimeUnit.MILLISECONDS));</span>
<span class="fc" id="L530">        assertEquals(1, count.get());</span>
<span class="fc" id="L531">        subscription.dispose();</span>
<span class="fc" id="L532">    }</span>

    @Test
    public void testReplay() throws InterruptedException {
<span class="fc" id="L536">        final AtomicInteger counter = new AtomicInteger();</span>
<span class="fc" id="L537">        ConnectableFlowable&lt;String&gt; f = Flowable.&lt;String&gt;unsafeCreate(new Publisher&lt;String&gt;() {</span>
            @Override
            public void subscribe(final Subscriber&lt;? super String&gt; subscriber) {
<span class="fc" id="L540">                    subscriber.onSubscribe(new BooleanSubscription());</span>
<span class="fc" id="L541">                    new Thread(new Runnable() {</span>

                        @Override
                        public void run() {
<span class="fc" id="L545">                            counter.incrementAndGet();</span>
<span class="fc" id="L546">                            subscriber.onNext(&quot;one&quot;);</span>
<span class="fc" id="L547">                            subscriber.onComplete();</span>
<span class="fc" id="L548">                        }</span>
<span class="fc" id="L549">                    }).start();</span>
<span class="fc" id="L550">            }</span>
<span class="fc" id="L551">        }).replay();</span>

        // we connect immediately and it will emit the value
<span class="fc" id="L554">        Disposable connection = f.connect();</span>
        try {

            // we then expect the following 2 subscriptions to get that same value
<span class="fc" id="L558">            final CountDownLatch latch = new CountDownLatch(2);</span>

            // subscribe once
<span class="fc" id="L561">            f.subscribe(new Consumer&lt;String&gt;() {</span>
                @Override
                public void accept(String v) {
<span class="fc" id="L564">                    assertEquals(&quot;one&quot;, v);</span>
<span class="fc" id="L565">                    latch.countDown();</span>
<span class="fc" id="L566">                }</span>
            });

            // subscribe again
<span class="fc" id="L570">            f.subscribe(new Consumer&lt;String&gt;() {</span>
                @Override
                public void accept(String v) {
<span class="fc" id="L573">                    assertEquals(&quot;one&quot;, v);</span>
<span class="fc" id="L574">                    latch.countDown();</span>
<span class="fc" id="L575">                }</span>
            });

<span class="pc bpc" id="L578" title="1 of 2 branches missed.">            if (!latch.await(1000, TimeUnit.MILLISECONDS)) {</span>
<span class="nc" id="L579">                fail(&quot;subscriptions did not receive values&quot;);</span>
            }
<span class="fc" id="L581">            assertEquals(1, counter.get());</span>
        } finally {
<span class="fc" id="L583">            connection.dispose();</span>
        }
<span class="fc" id="L585">    }</span>

    @Test
    public void testCache() throws InterruptedException {
<span class="fc" id="L589">        final AtomicInteger counter = new AtomicInteger();</span>
<span class="fc" id="L590">        Flowable&lt;String&gt; f = Flowable.&lt;String&gt;unsafeCreate(new Publisher&lt;String&gt;() {</span>
            @Override
            public void subscribe(final Subscriber&lt;? super String&gt; subscriber) {
<span class="fc" id="L593">                    subscriber.onSubscribe(new BooleanSubscription());</span>
<span class="fc" id="L594">                    new Thread(new Runnable() {</span>
                        @Override
                        public void run() {
<span class="fc" id="L597">                            counter.incrementAndGet();</span>
<span class="fc" id="L598">                            subscriber.onNext(&quot;one&quot;);</span>
<span class="fc" id="L599">                            subscriber.onComplete();</span>
<span class="fc" id="L600">                        }</span>
<span class="fc" id="L601">                    }).start();</span>
<span class="fc" id="L602">            }</span>
<span class="fc" id="L603">        }).cache();</span>

        // we then expect the following 2 subscriptions to get that same value
<span class="fc" id="L606">        final CountDownLatch latch = new CountDownLatch(2);</span>

        // subscribe once
<span class="fc" id="L609">        f.subscribe(new Consumer&lt;String&gt;() {</span>
            @Override
            public void accept(String v) {
<span class="fc" id="L612">                assertEquals(&quot;one&quot;, v);</span>
<span class="fc" id="L613">                latch.countDown();</span>
<span class="fc" id="L614">            }</span>
        });

        // subscribe again
<span class="fc" id="L618">        f.subscribe(new Consumer&lt;String&gt;() {</span>
            @Override
            public void accept(String v) {
<span class="fc" id="L621">                assertEquals(&quot;one&quot;, v);</span>
<span class="fc" id="L622">                latch.countDown();</span>
<span class="fc" id="L623">            }</span>
        });

<span class="pc bpc" id="L626" title="1 of 2 branches missed.">        if (!latch.await(1000, TimeUnit.MILLISECONDS)) {</span>
<span class="nc" id="L627">            fail(&quot;subscriptions did not receive values&quot;);</span>
        }
<span class="fc" id="L629">        assertEquals(1, counter.get());</span>
<span class="fc" id="L630">    }</span>

    @Test
    public void testCacheWithCapacity() throws InterruptedException {
<span class="fc" id="L634">        final AtomicInteger counter = new AtomicInteger();</span>
<span class="fc" id="L635">        Flowable&lt;String&gt; f = Flowable.&lt;String&gt;unsafeCreate(new Publisher&lt;String&gt;() {</span>
            @Override
            public void subscribe(final Subscriber&lt;? super String&gt; subscriber) {
<span class="fc" id="L638">                subscriber.onSubscribe(new BooleanSubscription());</span>
<span class="fc" id="L639">                new Thread(new Runnable() {</span>
                    @Override
                    public void run() {
<span class="fc" id="L642">                        counter.incrementAndGet();</span>
<span class="fc" id="L643">                        subscriber.onNext(&quot;one&quot;);</span>
<span class="fc" id="L644">                        subscriber.onComplete();</span>
<span class="fc" id="L645">                    }</span>
<span class="fc" id="L646">                }).start();</span>
<span class="fc" id="L647">            }</span>
<span class="fc" id="L648">        }).cacheWithInitialCapacity(1);</span>

        // we then expect the following 2 subscriptions to get that same value
<span class="fc" id="L651">        final CountDownLatch latch = new CountDownLatch(2);</span>

        // subscribe once
<span class="fc" id="L654">        f.subscribe(new Consumer&lt;String&gt;() {</span>
            @Override
            public void accept(String v) {
<span class="fc" id="L657">                assertEquals(&quot;one&quot;, v);</span>
<span class="fc" id="L658">                latch.countDown();</span>
<span class="fc" id="L659">            }</span>
        });

        // subscribe again
<span class="fc" id="L663">        f.subscribe(new Consumer&lt;String&gt;() {</span>
            @Override
            public void accept(String v) {
<span class="fc" id="L666">                assertEquals(&quot;one&quot;, v);</span>
<span class="fc" id="L667">                latch.countDown();</span>
<span class="fc" id="L668">            }</span>
        });

<span class="pc bpc" id="L671" title="1 of 2 branches missed.">        if (!latch.await(1000, TimeUnit.MILLISECONDS)) {</span>
<span class="nc" id="L672">            fail(&quot;subscriptions did not receive values&quot;);</span>
        }
<span class="fc" id="L674">        assertEquals(1, counter.get());</span>
<span class="fc" id="L675">    }</span>

    /**
     * https://github.com/ReactiveX/RxJava/issues/198
     *
     * Rx Design Guidelines 5.2
     *
     * &quot;when calling the Subscribe method that only has an onNext argument, the OnError behavior will be
     * to rethrow the exception on the thread that the message comes out from the Observable.
     * The OnCompleted behavior in this case is to do nothing.&quot;
     */
    @Test
    @Ignore(&quot;Subscribers can't throw&quot;)
    public void testErrorThrownWithoutErrorHandlerSynchronous() {
        try {
<span class="nc" id="L690">            Flowable.error(new RuntimeException(&quot;failure&quot;))</span>
<span class="nc" id="L691">            .subscribe();</span>
<span class="nc" id="L692">            fail(&quot;expected exception&quot;);</span>
<span class="nc" id="L693">        } catch (Throwable e) {</span>
<span class="nc" id="L694">            assertEquals(&quot;failure&quot;, e.getMessage());</span>
<span class="nc" id="L695">        }</span>
<span class="nc" id="L696">    }</span>

    /**
     * https://github.com/ReactiveX/RxJava/issues/198
     *
     * Rx Design Guidelines 5.2
     *
     * &quot;when calling the Subscribe method that only has an onNext argument, the OnError behavior will be
     * to rethrow the exception on the thread that the message comes out from the Observable.
     * The OnCompleted behavior in this case is to do nothing.&quot;
     *
     * @throws InterruptedException if the await is interrupted
     */
    @Test
    @Ignore(&quot;Subscribers can't throw&quot;)
    public void testErrorThrownWithoutErrorHandlerAsynchronous() throws InterruptedException {
<span class="nc" id="L712">        final CountDownLatch latch = new CountDownLatch(1);</span>
<span class="nc" id="L713">        final AtomicReference&lt;Throwable&gt; exception = new AtomicReference&lt;Throwable&gt;();</span>
<span class="nc" id="L714">        Flowable.unsafeCreate(new Publisher&lt;Object&gt;() {</span>
            @Override
            public void subscribe(final Subscriber&lt;? super Object&gt; subscriber) {
<span class="nc" id="L717">                subscriber.onSubscribe(new BooleanSubscription());</span>
<span class="nc" id="L718">                new Thread(new Runnable() {</span>
                    @Override
                    public void run() {
                        try {
<span class="nc" id="L722">                            subscriber.onError(new Error(&quot;failure&quot;));</span>
<span class="nc" id="L723">                        } catch (Throwable e) {</span>
                            // without an onError handler it has to just throw on whatever thread invokes it
<span class="nc" id="L725">                            exception.set(e);</span>
<span class="nc" id="L726">                        }</span>
<span class="nc" id="L727">                        latch.countDown();</span>
<span class="nc" id="L728">                    }</span>
<span class="nc" id="L729">                }).start();</span>
<span class="nc" id="L730">            }</span>
<span class="nc" id="L731">        }).subscribe();</span>
        // wait for exception
<span class="nc" id="L733">        latch.await(3000, TimeUnit.MILLISECONDS);</span>
<span class="nc" id="L734">        assertNotNull(exception.get());</span>
<span class="nc" id="L735">        assertEquals(&quot;failure&quot;, exception.get().getMessage());</span>
<span class="nc" id="L736">    }</span>

    @Test
    public void testTakeWithErrorInObserver() {
<span class="fc" id="L740">        final AtomicInteger count = new AtomicInteger();</span>
<span class="fc" id="L741">        final AtomicReference&lt;Throwable&gt; error = new AtomicReference&lt;Throwable&gt;();</span>
<span class="fc" id="L742">        Flowable.just(&quot;1&quot;, &quot;2&quot;, &quot;three&quot;, &quot;4&quot;).take(3)</span>
<span class="fc" id="L743">        .safeSubscribe(new DefaultSubscriber&lt;String&gt;() {</span>

            @Override
            public void onComplete() {
<span class="nc" id="L747">                System.out.println(&quot;completed&quot;);</span>
<span class="nc" id="L748">            }</span>

            @Override
            public void onError(Throwable e) {
<span class="fc" id="L752">                error.set(e);</span>
<span class="fc" id="L753">                System.out.println(&quot;error&quot;);</span>
<span class="fc" id="L754">                e.printStackTrace();</span>
<span class="fc" id="L755">            }</span>

            @Override
            public void onNext(String v) {
<span class="fc" id="L759">                int num = Integer.parseInt(v);</span>
<span class="fc" id="L760">                System.out.println(num);</span>
                // doSomething(num);
<span class="fc" id="L762">                count.incrementAndGet();</span>
<span class="fc" id="L763">            }</span>

        });
<span class="fc" id="L766">        assertEquals(2, count.get());</span>
<span class="fc" id="L767">        assertNotNull(error.get());</span>
<span class="pc bpc" id="L768" title="1 of 2 branches missed.">        if (!(error.get() instanceof NumberFormatException)) {</span>
<span class="nc" id="L769">            fail(&quot;It should be a NumberFormatException&quot;);</span>
        }
<span class="fc" id="L771">    }</span>

    @Test
    public void testOfType() {
<span class="fc" id="L775">        Flowable&lt;String&gt; flowable = Flowable.just(1, &quot;abc&quot;, false, 2L).ofType(String.class);</span>

<span class="fc" id="L777">        Subscriber&lt;Object&gt; subscriber = TestHelper.mockSubscriber();</span>

<span class="fc" id="L779">        flowable.subscribe(subscriber);</span>

<span class="fc" id="L781">        verify(subscriber, never()).onNext(1);</span>
<span class="fc" id="L782">        verify(subscriber, times(1)).onNext(&quot;abc&quot;);</span>
<span class="fc" id="L783">        verify(subscriber, never()).onNext(false);</span>
<span class="fc" id="L784">        verify(subscriber, never()).onNext(2L);</span>
<span class="fc" id="L785">        verify(subscriber, never()).onError(any(Throwable.class));</span>
<span class="fc" id="L786">        verify(subscriber, times(1)).onComplete();</span>
<span class="fc" id="L787">    }</span>

    @Test
    public void testOfTypeWithPolymorphism() {
<span class="fc" id="L791">        ArrayList&lt;Integer&gt; l1 = new ArrayList&lt;Integer&gt;();</span>
<span class="fc" id="L792">        l1.add(1);</span>
<span class="fc" id="L793">        LinkedList&lt;Integer&gt; l2 = new LinkedList&lt;Integer&gt;();</span>
<span class="fc" id="L794">        l2.add(2);</span>

        @SuppressWarnings(&quot;rawtypes&quot;)
<span class="fc" id="L797">        Flowable&lt;List&gt; flowable = Flowable.&lt;Object&gt; just(l1, l2, &quot;123&quot;).ofType(List.class);</span>

<span class="fc" id="L799">        Subscriber&lt;Object&gt; subscriber = TestHelper.mockSubscriber();</span>

<span class="fc" id="L801">        flowable.subscribe(subscriber);</span>

<span class="fc" id="L803">        verify(subscriber, times(1)).onNext(l1);</span>
<span class="fc" id="L804">        verify(subscriber, times(1)).onNext(l2);</span>
<span class="fc" id="L805">        verify(subscriber, never()).onNext(&quot;123&quot;);</span>
<span class="fc" id="L806">        verify(subscriber, never()).onError(any(Throwable.class));</span>
<span class="fc" id="L807">        verify(subscriber, times(1)).onComplete();</span>
<span class="fc" id="L808">    }</span>

    @Test
    public void testContainsFlowable() {
<span class="fc" id="L812">        Flowable&lt;Boolean&gt; flowable = Flowable.just(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;).contains(&quot;b&quot;).toFlowable();</span>

<span class="fc" id="L814">        FlowableSubscriber&lt;Boolean&gt; subscriber = TestHelper.mockSubscriber();</span>

<span class="fc" id="L816">        flowable.subscribe(subscriber);</span>

<span class="fc" id="L818">        verify(subscriber, times(1)).onNext(true);</span>
<span class="fc" id="L819">        verify(subscriber, never()).onNext(false);</span>
<span class="fc" id="L820">        verify(subscriber, never()).onError(any(Throwable.class));</span>
<span class="fc" id="L821">        verify(subscriber, times(1)).onComplete();</span>
<span class="fc" id="L822">    }</span>

    @Test
    public void testContainsWithInexistenceFlowable() {
<span class="fc" id="L826">        Flowable&lt;Boolean&gt; flowable = Flowable.just(&quot;a&quot;, &quot;b&quot;).contains(&quot;c&quot;).toFlowable();</span>

<span class="fc" id="L828">        Subscriber&lt;Object&gt; subscriber = TestHelper.mockSubscriber();</span>

<span class="fc" id="L830">        flowable.subscribe(subscriber);</span>

<span class="fc" id="L832">        verify(subscriber, times(1)).onNext(false);</span>
<span class="fc" id="L833">        verify(subscriber, never()).onNext(true);</span>
<span class="fc" id="L834">        verify(subscriber, never()).onError(any(Throwable.class));</span>
<span class="fc" id="L835">        verify(subscriber, times(1)).onComplete();</span>
<span class="fc" id="L836">    }</span>

    @Test
    @Ignore(&quot;null values are not allowed&quot;)
    public void testContainsWithNullFlowable() {
<span class="nc" id="L841">        Flowable&lt;Boolean&gt; flowable = Flowable.just(&quot;a&quot;, &quot;b&quot;, null).contains(null).toFlowable();</span>

<span class="nc" id="L843">        Subscriber&lt;Object&gt; subscriber = TestHelper.mockSubscriber();</span>

<span class="nc" id="L845">        flowable.subscribe(subscriber);</span>

<span class="nc" id="L847">        verify(subscriber, times(1)).onNext(true);</span>
<span class="nc" id="L848">        verify(subscriber, never()).onNext(false);</span>
<span class="nc" id="L849">        verify(subscriber, never()).onError(any(Throwable.class));</span>
<span class="nc" id="L850">        verify(subscriber, times(1)).onComplete();</span>
<span class="nc" id="L851">    }</span>

    @Test
    public void testContainsWithEmptyObservableFlowable() {
<span class="fc" id="L855">        Flowable&lt;Boolean&gt; flowable = Flowable.&lt;String&gt; empty().contains(&quot;a&quot;).toFlowable();</span>

<span class="fc" id="L857">        FlowableSubscriber&lt;Object&gt; subscriber = TestHelper.mockSubscriber();</span>

<span class="fc" id="L859">        flowable.subscribe(subscriber);</span>

<span class="fc" id="L861">        verify(subscriber, times(1)).onNext(false);</span>
<span class="fc" id="L862">        verify(subscriber, never()).onNext(true);</span>
<span class="fc" id="L863">        verify(subscriber, never()).onError(any(Throwable.class));</span>
<span class="fc" id="L864">        verify(subscriber, times(1)).onComplete();</span>
<span class="fc" id="L865">    }</span>

    @Test
    public void testContains() {
<span class="fc" id="L869">        Single&lt;Boolean&gt; single = Flowable.just(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;).contains(&quot;b&quot;); // FIXME nulls not allowed, changed to &quot;c&quot;</span>

<span class="fc" id="L871">        SingleObserver&lt;Boolean&gt; observer = TestHelper.mockSingleObserver();</span>

<span class="fc" id="L873">        single.subscribe(observer);</span>

<span class="fc" id="L875">        verify(observer, times(1)).onSuccess(true);</span>
<span class="fc" id="L876">        verify(observer, never()).onSuccess(false);</span>
<span class="fc" id="L877">        verify(observer, never()).onError(</span>
<span class="fc" id="L878">                any(Throwable.class));</span>
<span class="fc" id="L879">    }</span>

    @Test
    public void testContainsWithInexistence() {
<span class="fc" id="L883">        Single&lt;Boolean&gt; single = Flowable.just(&quot;a&quot;, &quot;b&quot;).contains(&quot;c&quot;); // FIXME null values are not allowed, removed</span>

<span class="fc" id="L885">        SingleObserver&lt;Boolean&gt; observer = TestHelper.mockSingleObserver();</span>

<span class="fc" id="L887">        single.subscribe(observer);</span>

<span class="fc" id="L889">        verify(observer, times(1)).onSuccess(false);</span>
<span class="fc" id="L890">        verify(observer, never()).onSuccess(true);</span>
<span class="fc" id="L891">        verify(observer, never()).onError(</span>
<span class="fc" id="L892">                any(Throwable.class));</span>
<span class="fc" id="L893">    }</span>

    @Test
    @Ignore(&quot;null values are not allowed&quot;)
    public void testContainsWithNull() {
<span class="nc" id="L898">        Single&lt;Boolean&gt; single = Flowable.just(&quot;a&quot;, &quot;b&quot;, null).contains(null);</span>

<span class="nc" id="L900">        SingleObserver&lt;Boolean&gt; observer = TestHelper.mockSingleObserver();</span>

<span class="nc" id="L902">        single.subscribe(observer);</span>

<span class="nc" id="L904">        verify(observer, times(1)).onSuccess(true);</span>
<span class="nc" id="L905">        verify(observer, never()).onSuccess(false);</span>
<span class="nc" id="L906">        verify(observer, never()).onError(</span>
<span class="nc" id="L907">                any(Throwable.class));</span>
<span class="nc" id="L908">    }</span>

    @Test
    public void testContainsWithEmptyObservable() {
<span class="fc" id="L912">        Single&lt;Boolean&gt; single = Flowable.&lt;String&gt; empty().contains(&quot;a&quot;);</span>

<span class="fc" id="L914">        SingleObserver&lt;Boolean&gt; observer = TestHelper.mockSingleObserver();</span>

<span class="fc" id="L916">        single.subscribe(observer);</span>

<span class="fc" id="L918">        verify(observer, times(1)).onSuccess(false);</span>
<span class="fc" id="L919">        verify(observer, never()).onSuccess(true);</span>
<span class="fc" id="L920">        verify(observer, never()).onError(</span>
<span class="fc" id="L921">                any(Throwable.class));</span>
<span class="fc" id="L922">    }</span>

    @Test
    public void testIgnoreElementsFlowable() {
<span class="fc" id="L926">        Flowable&lt;Integer&gt; flowable = Flowable.just(1, 2, 3).ignoreElements().toFlowable();</span>

<span class="fc" id="L928">        Subscriber&lt;Object&gt; subscriber = TestHelper.mockSubscriber();</span>

<span class="fc" id="L930">        flowable.subscribe(subscriber);</span>

<span class="fc" id="L932">        verify(subscriber, never()).onNext(any(Integer.class));</span>
<span class="fc" id="L933">        verify(subscriber, never()).onError(any(Throwable.class));</span>
<span class="fc" id="L934">        verify(subscriber, times(1)).onComplete();</span>
<span class="fc" id="L935">    }</span>

    @Test
    public void testIgnoreElements() {
<span class="fc" id="L939">        Completable completable = Flowable.just(1, 2, 3).ignoreElements();</span>

<span class="fc" id="L941">        CompletableObserver observer = TestHelper.mockCompletableObserver();</span>

<span class="fc" id="L943">        completable.subscribe(observer);</span>

<span class="fc" id="L945">        verify(observer, never()).onError(any(Throwable.class));</span>
<span class="fc" id="L946">        verify(observer, times(1)).onComplete();</span>
<span class="fc" id="L947">    }</span>

    @Test
    public void testJustWithScheduler() {
<span class="fc" id="L951">        TestScheduler scheduler = new TestScheduler();</span>
<span class="fc" id="L952">        Flowable&lt;Integer&gt; flowable = Flowable.fromArray(1, 2).subscribeOn(scheduler);</span>

<span class="fc" id="L954">        Subscriber&lt;Integer&gt; subscriber = TestHelper.mockSubscriber();</span>

<span class="fc" id="L956">        flowable.subscribe(subscriber);</span>

<span class="fc" id="L958">        scheduler.advanceTimeBy(1, TimeUnit.MILLISECONDS);</span>

<span class="fc" id="L960">        InOrder inOrder = inOrder(subscriber);</span>
<span class="fc" id="L961">        inOrder.verify(subscriber, times(1)).onNext(1);</span>
<span class="fc" id="L962">        inOrder.verify(subscriber, times(1)).onNext(2);</span>
<span class="fc" id="L963">        inOrder.verify(subscriber, times(1)).onComplete();</span>
<span class="fc" id="L964">        inOrder.verifyNoMoreInteractions();</span>
<span class="fc" id="L965">    }</span>

    @Test
    public void testStartWithWithScheduler() {
<span class="fc" id="L969">        TestScheduler scheduler = new TestScheduler();</span>
<span class="fc" id="L970">        Flowable&lt;Integer&gt; flowable = Flowable.just(3, 4).startWith(Arrays.asList(1, 2)).subscribeOn(scheduler);</span>

<span class="fc" id="L972">        Subscriber&lt;Integer&gt; subscriber = TestHelper.mockSubscriber();</span>

<span class="fc" id="L974">        flowable.subscribe(subscriber);</span>

<span class="fc" id="L976">        scheduler.advanceTimeBy(1, TimeUnit.MILLISECONDS);</span>

<span class="fc" id="L978">        InOrder inOrder = inOrder(subscriber);</span>
<span class="fc" id="L979">        inOrder.verify(subscriber, times(1)).onNext(1);</span>
<span class="fc" id="L980">        inOrder.verify(subscriber, times(1)).onNext(2);</span>
<span class="fc" id="L981">        inOrder.verify(subscriber, times(1)).onNext(3);</span>
<span class="fc" id="L982">        inOrder.verify(subscriber, times(1)).onNext(4);</span>
<span class="fc" id="L983">        inOrder.verify(subscriber, times(1)).onComplete();</span>
<span class="fc" id="L984">        inOrder.verifyNoMoreInteractions();</span>
<span class="fc" id="L985">    }</span>

    @Test
    public void testRangeWithScheduler() {
<span class="fc" id="L989">        TestScheduler scheduler = new TestScheduler();</span>
<span class="fc" id="L990">        Flowable&lt;Integer&gt; flowable = Flowable.range(3, 4).subscribeOn(scheduler);</span>

<span class="fc" id="L992">        Subscriber&lt;Integer&gt; subscriber = TestHelper.mockSubscriber();</span>

<span class="fc" id="L994">        flowable.subscribe(subscriber);</span>

<span class="fc" id="L996">        scheduler.advanceTimeBy(1, TimeUnit.MILLISECONDS);</span>

<span class="fc" id="L998">        InOrder inOrder = inOrder(subscriber);</span>
<span class="fc" id="L999">        inOrder.verify(subscriber, times(1)).onNext(3);</span>
<span class="fc" id="L1000">        inOrder.verify(subscriber, times(1)).onNext(4);</span>
<span class="fc" id="L1001">        inOrder.verify(subscriber, times(1)).onNext(5);</span>
<span class="fc" id="L1002">        inOrder.verify(subscriber, times(1)).onNext(6);</span>
<span class="fc" id="L1003">        inOrder.verify(subscriber, times(1)).onComplete();</span>
<span class="fc" id="L1004">        inOrder.verifyNoMoreInteractions();</span>
<span class="fc" id="L1005">    }</span>

    @Test
    public void testMergeWith() {
<span class="fc" id="L1009">        TestSubscriber&lt;Integer&gt; ts = new TestSubscriber&lt;Integer&gt;();</span>
<span class="fc" id="L1010">        Flowable.just(1).mergeWith(Flowable.just(2)).subscribe(ts);</span>
<span class="fc" id="L1011">        ts.assertValues(1, 2);</span>
<span class="fc" id="L1012">    }</span>

    @Test
    public void testConcatWith() {
<span class="fc" id="L1016">        TestSubscriber&lt;Integer&gt; ts = new TestSubscriber&lt;Integer&gt;();</span>
<span class="fc" id="L1017">        Flowable.just(1).concatWith(Flowable.just(2)).subscribe(ts);</span>
<span class="fc" id="L1018">        ts.assertValues(1, 2);</span>
<span class="fc" id="L1019">    }</span>

    @Test
    public void testAmbWith() {
<span class="fc" id="L1023">        TestSubscriber&lt;Integer&gt; ts = new TestSubscriber&lt;Integer&gt;();</span>
<span class="fc" id="L1024">        Flowable.just(1).ambWith(Flowable.just(2)).subscribe(ts);</span>
<span class="fc" id="L1025">        ts.assertValue(1);</span>
<span class="fc" id="L1026">    }</span>

    @Test
    public void testTakeWhileToList() {
<span class="fc" id="L1030">        final int expectedCount = 3;</span>
<span class="fc" id="L1031">        final AtomicInteger count = new AtomicInteger();</span>
<span class="fc bfc" id="L1032" title="All 2 branches covered.">        for (int i = 0; i &lt; expectedCount; i++) {</span>
<span class="fc" id="L1033">            Flowable</span>
<span class="fc" id="L1034">                    .just(Boolean.TRUE, Boolean.FALSE)</span>
<span class="fc" id="L1035">                    .takeWhile(new Predicate&lt;Boolean&gt;() {</span>
                        @Override
                        public boolean test(Boolean v) {
<span class="fc" id="L1038">                            return v;</span>
                        }
                    })
<span class="fc" id="L1041">                    .toList()</span>
<span class="fc" id="L1042">                    .doOnSuccess(new Consumer&lt;List&lt;Boolean&gt;&gt;() {</span>
                        @Override
                        public void accept(List&lt;Boolean&gt; booleans) {
<span class="fc" id="L1045">                            count.incrementAndGet();</span>
<span class="fc" id="L1046">                        }</span>
                    })
<span class="fc" id="L1048">                    .subscribe();</span>
        }
<span class="fc" id="L1050">        assertEquals(expectedCount, count.get());</span>
<span class="fc" id="L1051">    }</span>

    @Test
    public void testCompose() {
<span class="fc" id="L1055">        TestSubscriber&lt;String&gt; ts = new TestSubscriber&lt;String&gt;();</span>
<span class="fc" id="L1056">        Flowable.just(1, 2, 3).compose(new FlowableTransformer&lt;Integer, String&gt;() {</span>
            @Override
            public Publisher&lt;String&gt; apply(Flowable&lt;Integer&gt; t1) {
<span class="fc" id="L1059">                return t1.map(new Function&lt;Integer, String&gt;() {</span>
                    @Override
                    public String apply(Integer v) {
<span class="fc" id="L1062">                        return String.valueOf(v);</span>
                    }
                });
            }
        })
<span class="fc" id="L1067">        .subscribe(ts);</span>
<span class="fc" id="L1068">        ts.assertTerminated();</span>
<span class="fc" id="L1069">        ts.assertNoErrors();</span>
<span class="fc" id="L1070">        ts.assertValues(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;);</span>
<span class="fc" id="L1071">    }</span>

    @Test
    public void testErrorThrownIssue1685() {
<span class="fc" id="L1075">        List&lt;Throwable&gt; errors = TestHelper.trackPluginErrors();</span>
        try {
<span class="fc" id="L1077">            FlowableProcessor&lt;Object&gt; processor = ReplayProcessor.create();</span>

<span class="fc" id="L1079">            Flowable.error(new RuntimeException(&quot;oops&quot;))</span>
<span class="fc" id="L1080">                .materialize()</span>
<span class="fc" id="L1081">                .delay(1, TimeUnit.SECONDS)</span>
<span class="fc" id="L1082">                .dematerialize(Functions.&lt;Notification&lt;Object&gt;&gt;identity())</span>
<span class="fc" id="L1083">                .subscribe(processor);</span>

<span class="fc" id="L1085">            processor.subscribe();</span>
<span class="fc" id="L1086">            processor.materialize().blockingFirst();</span>

<span class="fc" id="L1088">            System.out.println(&quot;Done&quot;);</span>

<span class="fc" id="L1090">            TestHelper.assertError(errors, 0, OnErrorNotImplementedException.class);</span>
        } finally {
<span class="fc" id="L1092">            RxJavaPlugins.reset();</span>
        }
<span class="fc" id="L1094">    }</span>

    @Test
    public void testEmptyIdentity() {
<span class="fc" id="L1098">        assertEquals(Flowable.empty(), Flowable.empty());</span>
<span class="fc" id="L1099">    }</span>

    @Test
    public void testEmptyIsEmpty() {
<span class="fc" id="L1103">        Flowable.&lt;Integer&gt;empty().subscribe(w);</span>

<span class="fc" id="L1105">        verify(w).onComplete();</span>
<span class="fc" id="L1106">        verify(w, never()).onNext(any(Integer.class));</span>
<span class="fc" id="L1107">        verify(w, never()).onError(any(Throwable.class));</span>
<span class="fc" id="L1108">    }</span>

    @Test(expected = NullPointerException.class)
    public void testForEachWithNull() {
<span class="fc" id="L1112">        Flowable.error(new Exception(&quot;boo&quot;))</span>
        //
<span class="nc" id="L1114">        .forEach(null);</span>
<span class="nc" id="L1115">    }</span>

    @Test
    public void testExtend() {
<span class="fc" id="L1119">        final TestSubscriber&lt;Object&gt; subscriber = new TestSubscriber&lt;Object&gt;();</span>
<span class="fc" id="L1120">        final Object value = new Object();</span>
<span class="fc" id="L1121">        Object returned = Flowable.just(value).to(new Function&lt;Flowable&lt;Object&gt;, Object&gt;() {</span>
            @Override
            public Object apply(Flowable&lt;Object&gt; onSubscribe) {
<span class="fc" id="L1124">                    onSubscribe.subscribe(subscriber);</span>
<span class="fc" id="L1125">                    subscriber.assertNoErrors();</span>
<span class="fc" id="L1126">                    subscriber.assertComplete();</span>
<span class="fc" id="L1127">                    subscriber.assertValue(value);</span>
<span class="fc" id="L1128">                    return subscriber.values().get(0);</span>
                }
        });
<span class="fc" id="L1131">        assertSame(returned, value);</span>
<span class="fc" id="L1132">    }</span>

    @Test
    public void testAsExtend() {
<span class="fc" id="L1136">        final TestSubscriber&lt;Object&gt; subscriber = new TestSubscriber&lt;Object&gt;();</span>
<span class="fc" id="L1137">        final Object value = new Object();</span>
<span class="fc" id="L1138">        Object returned = Flowable.just(value).as(new FlowableConverter&lt;Object, Object&gt;() {</span>
            @Override
            public Object apply(Flowable&lt;Object&gt; onSubscribe) {
<span class="fc" id="L1141">                    onSubscribe.subscribe(subscriber);</span>
<span class="fc" id="L1142">                    subscriber.assertNoErrors();</span>
<span class="fc" id="L1143">                    subscriber.assertComplete();</span>
<span class="fc" id="L1144">                    subscriber.assertValue(value);</span>
<span class="fc" id="L1145">                    return subscriber.values().get(0);</span>
                }
        });
<span class="fc" id="L1148">        assertSame(returned, value);</span>
<span class="fc" id="L1149">    }</span>

    @Test
    public void as() {
<span class="fc" id="L1153">        Flowable.just(1).as(new FlowableConverter&lt;Integer, Observable&lt;Integer&gt;&gt;() {</span>
            @Override
            public Observable&lt;Integer&gt; apply(Flowable&lt;Integer&gt; v) {
<span class="fc" id="L1156">                return v.toObservable();</span>
            }
        })
<span class="fc" id="L1159">        .test()</span>
<span class="fc" id="L1160">        .assertResult(1);</span>
<span class="fc" id="L1161">    }</span>

    @Test
    public void toObservableEmpty() {
<span class="fc" id="L1165">        Flowable.empty().toObservable().test().assertResult();</span>
<span class="fc" id="L1166">    }</span>

    @Test
    public void toObservableJust() {
<span class="fc" id="L1170">        Flowable.just(1).toObservable().test().assertResult(1);</span>
<span class="fc" id="L1171">    }</span>

    @Test
    public void toObservableRange() {
<span class="fc" id="L1175">        Flowable.range(1, 5).toObservable().test().assertResult(1, 2, 3, 4, 5);</span>
<span class="fc" id="L1176">    }</span>

    @Test
    public void toObservableError() {
<span class="fc" id="L1180">        Flowable.error(new TestException()).toObservable().test().assertFailure(TestException.class);</span>
<span class="fc" id="L1181">    }</span>

    @Test
    public void zipIterableObject() {
        @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L1186">        final List&lt;Flowable&lt;Integer&gt;&gt; flowables = Arrays.asList(Flowable.just(1, 2, 3), Flowable.just(1, 2, 3));</span>
<span class="fc" id="L1187">        Flowable.zip(flowables, new Function&lt;Object[], Object&gt;() {</span>
            @Override
            public Object apply(Object[] o) throws Exception {
<span class="fc" id="L1190">                int sum = 0;</span>
<span class="fc bfc" id="L1191" title="All 2 branches covered.">                for (Object i : o) {</span>
<span class="fc" id="L1192">                    sum += (Integer) i;</span>
                }
<span class="fc" id="L1194">                return sum;</span>
            }
<span class="fc" id="L1196">        }).test().assertResult(2, 4, 6);</span>
<span class="fc" id="L1197">    }</span>

    @Test
    public void combineLatestObject() {
        @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L1202">        final List&lt;Flowable&lt;Integer&gt;&gt; flowables = Arrays.asList(Flowable.just(1, 2, 3), Flowable.just(1, 2, 3));</span>
<span class="fc" id="L1203">        Flowable.combineLatest(flowables, new Function&lt;Object[], Object&gt;() {</span>
            @Override
            public Object apply(final Object[] o) throws Exception {
<span class="fc" id="L1206">                int sum = 1;</span>
<span class="fc bfc" id="L1207" title="All 2 branches covered.">                for (Object i : o) {</span>
<span class="fc" id="L1208">                    sum *= (Integer) i;</span>
                }
<span class="fc" id="L1210">                return sum;</span>
            }
<span class="fc" id="L1212">        }).test().assertResult(3, 6, 9);</span>
<span class="fc" id="L1213">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>