<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Functions.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">RxJava_2_x$Unnamed.exec</a> &gt; <a href="index.source.html" class="el_package">io.reactivex.internal.functions</a> &gt; <span class="el_source">Functions.java</span></div><h1>Functions.java</h1><pre class="source lang-java linenums">/**
 * Copyright (c) 2016-present, RxJava Contributors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is
 * distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
 * the License for the specific language governing permissions and limitations under the License.
 */
package io.reactivex.internal.functions;

import java.util.*;
import java.util.concurrent.*;

import org.reactivestreams.Subscription;

import io.reactivex.*;
import io.reactivex.exceptions.OnErrorNotImplementedException;
import io.reactivex.functions.*;
import io.reactivex.plugins.RxJavaPlugins;
import io.reactivex.schedulers.Timed;

/**
 * Utility methods to convert the BiFunction, Function3..Function9 instances to Function of Object array.
 */
public final class Functions {

    /** Utility class. */
<span class="fc" id="L32">    private Functions() {</span>
<span class="fc" id="L33">        throw new IllegalStateException(&quot;No instances!&quot;);</span>
    }

    public static &lt;T1, T2, R&gt; Function&lt;Object[], R&gt; toFunction(final BiFunction&lt;? super T1, ? super T2, ? extends R&gt; f) {
<span class="fc" id="L37">        ObjectHelper.requireNonNull(f, &quot;f is null&quot;);</span>
<span class="fc" id="L38">        return new Array2Func&lt;T1, T2, R&gt;(f);</span>
    }

    public static &lt;T1, T2, T3, R&gt; Function&lt;Object[], R&gt; toFunction(final Function3&lt;T1, T2, T3, R&gt; f) {
<span class="fc" id="L42">        ObjectHelper.requireNonNull(f, &quot;f is null&quot;);</span>
<span class="fc" id="L43">        return new Array3Func&lt;T1, T2, T3, R&gt;(f);</span>
    }

    public static &lt;T1, T2, T3, T4, R&gt; Function&lt;Object[], R&gt; toFunction(final Function4&lt;T1, T2, T3, T4, R&gt; f) {
<span class="fc" id="L47">        ObjectHelper.requireNonNull(f, &quot;f is null&quot;);</span>
<span class="fc" id="L48">        return new Array4Func&lt;T1, T2, T3, T4, R&gt;(f);</span>
    }

    public static &lt;T1, T2, T3, T4, T5, R&gt; Function&lt;Object[], R&gt; toFunction(final Function5&lt;T1, T2, T3, T4, T5, R&gt; f) {
<span class="fc" id="L52">        ObjectHelper.requireNonNull(f, &quot;f is null&quot;);</span>
<span class="fc" id="L53">        return new Array5Func&lt;T1, T2, T3, T4, T5, R&gt;(f);</span>
    }

    public static &lt;T1, T2, T3, T4, T5, T6, R&gt; Function&lt;Object[], R&gt; toFunction(
            final Function6&lt;T1, T2, T3, T4, T5, T6, R&gt; f) {
<span class="fc" id="L58">        ObjectHelper.requireNonNull(f, &quot;f is null&quot;);</span>
<span class="fc" id="L59">        return new Array6Func&lt;T1, T2, T3, T4, T5, T6, R&gt;(f);</span>
    }

    public static &lt;T1, T2, T3, T4, T5, T6, T7, R&gt; Function&lt;Object[], R&gt; toFunction(
            final Function7&lt;T1, T2, T3, T4, T5, T6, T7, R&gt; f) {
<span class="fc" id="L64">        ObjectHelper.requireNonNull(f, &quot;f is null&quot;);</span>
<span class="fc" id="L65">        return new Array7Func&lt;T1, T2, T3, T4, T5, T6, T7, R&gt;(f);</span>
    }

    public static &lt;T1, T2, T3, T4, T5, T6, T7, T8, R&gt; Function&lt;Object[], R&gt; toFunction(
            final Function8&lt;T1, T2, T3, T4, T5, T6, T7, T8, R&gt; f) {
<span class="fc" id="L70">        ObjectHelper.requireNonNull(f, &quot;f is null&quot;);</span>
<span class="fc" id="L71">        return new Array8Func&lt;T1, T2, T3, T4, T5, T6, T7, T8, R&gt;(f);</span>
    }

    public static &lt;T1, T2, T3, T4, T5, T6, T7, T8, T9, R&gt; Function&lt;Object[], R&gt; toFunction(
            final Function9&lt;T1, T2, T3, T4, T5, T6, T7, T8, T9, R&gt; f) {
<span class="fc" id="L76">        ObjectHelper.requireNonNull(f, &quot;f is null&quot;);</span>
<span class="fc" id="L77">        return new Array9Func&lt;T1, T2, T3, T4, T5, T6, T7, T8, T9, R&gt;(f);</span>
    }

    /** A singleton identity function. */
<span class="fc" id="L81">    static final Function&lt;Object, Object&gt; IDENTITY = new Identity();</span>

    /**
     * Returns an identity function that simply returns its argument.
     * @param &lt;T&gt; the input and output value type
     * @return the identity function
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; Function&lt;T, T&gt; identity() {
<span class="fc" id="L90">        return (Function&lt;T, T&gt;)IDENTITY;</span>
    }

<span class="fc" id="L93">    public static final Runnable EMPTY_RUNNABLE = new EmptyRunnable();</span>

<span class="fc" id="L95">    public static final Action EMPTY_ACTION = new EmptyAction();</span>

<span class="fc" id="L97">    static final Consumer&lt;Object&gt; EMPTY_CONSUMER = new EmptyConsumer();</span>

    /**
     * Returns an empty consumer that does nothing.
     * @param &lt;T&gt; the consumed value type, the value is ignored
     * @return an empty consumer that does nothing.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; Consumer&lt;T&gt; emptyConsumer() {
<span class="fc" id="L106">        return (Consumer&lt;T&gt;)EMPTY_CONSUMER;</span>
    }

<span class="fc" id="L109">    public static final Consumer&lt;Throwable&gt; ERROR_CONSUMER = new ErrorConsumer();</span>

    /**
     * Wraps the consumed Throwable into an OnErrorNotImplementedException and
     * signals it to the plugin error handler.
     */
<span class="fc" id="L115">    public static final Consumer&lt;Throwable&gt; ON_ERROR_MISSING = new OnErrorMissingConsumer();</span>

<span class="fc" id="L117">    public static final LongConsumer EMPTY_LONG_CONSUMER = new EmptyLongConsumer();</span>

<span class="fc" id="L119">    static final Predicate&lt;Object&gt; ALWAYS_TRUE = new TruePredicate();</span>

<span class="fc" id="L121">    static final Predicate&lt;Object&gt; ALWAYS_FALSE = new FalsePredicate();</span>

<span class="fc" id="L123">    static final Callable&lt;Object&gt; NULL_SUPPLIER = new NullCallable();</span>

<span class="fc" id="L125">    static final Comparator&lt;Object&gt; NATURAL_COMPARATOR = new NaturalObjectComparator();</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; Predicate&lt;T&gt; alwaysTrue() {
<span class="fc" id="L129">        return (Predicate&lt;T&gt;)ALWAYS_TRUE;</span>
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; Predicate&lt;T&gt; alwaysFalse() {
<span class="fc" id="L134">        return (Predicate&lt;T&gt;)ALWAYS_FALSE;</span>
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; Callable&lt;T&gt; nullSupplier() {
<span class="fc" id="L139">        return (Callable&lt;T&gt;)NULL_SUPPLIER;</span>
    }

    /**
     * Returns a natural order comparator which casts the parameters to Comparable.
     * @param &lt;T&gt; the value type
     * @return a natural order comparator which casts the parameters to Comparable
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; Comparator&lt;T&gt; naturalOrder() {
<span class="fc" id="L149">        return (Comparator&lt;T&gt;)NATURAL_COMPARATOR;</span>
    }

    static final class FutureAction implements Action {
        final Future&lt;?&gt; future;

<span class="fc" id="L155">        FutureAction(Future&lt;?&gt; future) {</span>
<span class="fc" id="L156">            this.future = future;</span>
<span class="fc" id="L157">        }</span>

        @Override
        public void run() throws Exception {
<span class="fc" id="L161">            future.get();</span>
<span class="fc" id="L162">        }</span>
    }

    /**
     * Wraps the blocking get call of the Future into an Action.
     * @param future the future to call get() on, not null
     * @return the new Action instance
     */
    public static Action futureAction(Future&lt;?&gt; future) {
<span class="fc" id="L171">        return new FutureAction(future);</span>
    }

    static final class JustValue&lt;T, U&gt; implements Callable&lt;U&gt;, Function&lt;T, U&gt; {
        final U value;

<span class="fc" id="L177">        JustValue(U value) {</span>
<span class="fc" id="L178">            this.value = value;</span>
<span class="fc" id="L179">        }</span>

        @Override
        public U call() throws Exception {
<span class="fc" id="L183">            return value;</span>
        }

        @Override
        public U apply(T t) throws Exception {
<span class="fc" id="L188">            return value;</span>
        }
    }

    /**
     * Returns a Callable that returns the given value.
     * @param &lt;T&gt; the value type
     * @param value the value to return
     * @return the new Callable instance
     */
    public static &lt;T&gt; Callable&lt;T&gt; justCallable(T value) {
<span class="fc" id="L199">        return new JustValue&lt;Object, T&gt;(value);</span>
    }

    /**
     * Returns a Function that ignores its parameter and returns the given value.
     * @param &lt;T&gt; the function's input type
     * @param &lt;U&gt; the value and return type of the function
     * @param value the value to return
     * @return the new Function instance
     */
    public static &lt;T, U&gt; Function&lt;T, U&gt; justFunction(U value) {
<span class="fc" id="L210">        return new JustValue&lt;T, U&gt;(value);</span>
    }

    static final class CastToClass&lt;T, U&gt; implements Function&lt;T, U&gt; {
        final Class&lt;U&gt; clazz;

<span class="fc" id="L216">        CastToClass(Class&lt;U&gt; clazz) {</span>
<span class="fc" id="L217">            this.clazz = clazz;</span>
<span class="fc" id="L218">        }</span>

        @Override
        public U apply(T t) throws Exception {
<span class="fc" id="L222">            return clazz.cast(t);</span>
        }
    }

    /**
     * Returns a function that cast the incoming values via a Class object.
     * @param &lt;T&gt; the input value type
     * @param &lt;U&gt; the output and target type
     * @param target the target class
     * @return the new Function instance
     */
    public static &lt;T, U&gt; Function&lt;T, U&gt; castFunction(Class&lt;U&gt; target) {
<span class="fc" id="L234">        return new CastToClass&lt;T, U&gt;(target);</span>
    }

    static final class ArrayListCapacityCallable&lt;T&gt; implements Callable&lt;List&lt;T&gt;&gt; {
        final int capacity;

<span class="fc" id="L240">        ArrayListCapacityCallable(int capacity) {</span>
<span class="fc" id="L241">            this.capacity = capacity;</span>
<span class="fc" id="L242">        }</span>

        @Override
        public List&lt;T&gt; call() throws Exception {
<span class="fc" id="L246">            return new ArrayList&lt;T&gt;(capacity);</span>
        }
    }

    public static &lt;T&gt; Callable&lt;List&lt;T&gt;&gt; createArrayList(int capacity) {
<span class="fc" id="L251">        return new ArrayListCapacityCallable&lt;T&gt;(capacity);</span>
    }

    static final class EqualsPredicate&lt;T&gt; implements Predicate&lt;T&gt; {
        final T value;

<span class="fc" id="L257">        EqualsPredicate(T value) {</span>
<span class="fc" id="L258">            this.value = value;</span>
<span class="fc" id="L259">        }</span>

        @Override
        public boolean test(T t) throws Exception {
<span class="fc" id="L263">            return ObjectHelper.equals(t, value);</span>
        }
    }

    public static &lt;T&gt; Predicate&lt;T&gt; equalsWith(T value) {
<span class="fc" id="L268">        return new EqualsPredicate&lt;T&gt;(value);</span>
    }

<span class="fc" id="L271">    enum HashSetCallable implements Callable&lt;Set&lt;Object&gt;&gt; {</span>
<span class="fc" id="L272">        INSTANCE;</span>
        @Override
        public Set&lt;Object&gt; call() throws Exception {
<span class="fc" id="L275">            return new HashSet&lt;Object&gt;();</span>
        }
    }

    @SuppressWarnings({ &quot;rawtypes&quot;, &quot;unchecked&quot; })
    public static &lt;T&gt; Callable&lt;Set&lt;T&gt;&gt; createHashSet() {
<span class="fc" id="L281">        return (Callable)HashSetCallable.INSTANCE;</span>
    }

    static final class NotificationOnNext&lt;T&gt; implements Consumer&lt;T&gt; {
        final Consumer&lt;? super Notification&lt;T&gt;&gt; onNotification;

<span class="fc" id="L287">        NotificationOnNext(Consumer&lt;? super Notification&lt;T&gt;&gt; onNotification) {</span>
<span class="fc" id="L288">            this.onNotification = onNotification;</span>
<span class="fc" id="L289">        }</span>

        @Override
        public void accept(T v) throws Exception {
<span class="fc" id="L293">            onNotification.accept(Notification.createOnNext(v));</span>
<span class="fc" id="L294">        }</span>
    }

    static final class NotificationOnError&lt;T&gt; implements Consumer&lt;Throwable&gt; {
        final Consumer&lt;? super Notification&lt;T&gt;&gt; onNotification;

<span class="fc" id="L300">        NotificationOnError(Consumer&lt;? super Notification&lt;T&gt;&gt; onNotification) {</span>
<span class="fc" id="L301">            this.onNotification = onNotification;</span>
<span class="fc" id="L302">        }</span>

        @Override
        public void accept(Throwable v) throws Exception {
<span class="fc" id="L306">            onNotification.accept(Notification.&lt;T&gt;createOnError(v));</span>
<span class="fc" id="L307">        }</span>
    }

    static final class NotificationOnComplete&lt;T&gt; implements Action {
        final Consumer&lt;? super Notification&lt;T&gt;&gt; onNotification;

<span class="fc" id="L313">        NotificationOnComplete(Consumer&lt;? super Notification&lt;T&gt;&gt; onNotification) {</span>
<span class="fc" id="L314">            this.onNotification = onNotification;</span>
<span class="fc" id="L315">        }</span>

        @Override
        public void run() throws Exception {
<span class="fc" id="L319">            onNotification.accept(Notification.&lt;T&gt;createOnComplete());</span>
<span class="fc" id="L320">        }</span>
    }

    public static &lt;T&gt; Consumer&lt;T&gt; notificationOnNext(Consumer&lt;? super Notification&lt;T&gt;&gt; onNotification) {
<span class="fc" id="L324">        return new NotificationOnNext&lt;T&gt;(onNotification);</span>
    }

    public static &lt;T&gt; Consumer&lt;Throwable&gt; notificationOnError(Consumer&lt;? super Notification&lt;T&gt;&gt; onNotification) {
<span class="fc" id="L328">        return new NotificationOnError&lt;T&gt;(onNotification);</span>
    }

    public static &lt;T&gt; Action notificationOnComplete(Consumer&lt;? super Notification&lt;T&gt;&gt; onNotification) {
<span class="fc" id="L332">        return new NotificationOnComplete&lt;T&gt;(onNotification);</span>
    }

    static final class ActionConsumer&lt;T&gt; implements Consumer&lt;T&gt; {
        final Action action;

<span class="fc" id="L338">        ActionConsumer(Action action) {</span>
<span class="fc" id="L339">            this.action = action;</span>
<span class="fc" id="L340">        }</span>

        @Override
        public void accept(T t) throws Exception {
<span class="fc" id="L344">            action.run();</span>
<span class="fc" id="L345">        }</span>
    }

    public static &lt;T&gt; Consumer&lt;T&gt; actionConsumer(Action action) {
<span class="fc" id="L349">        return new ActionConsumer&lt;T&gt;(action);</span>
    }

    static final class ClassFilter&lt;T, U&gt; implements Predicate&lt;T&gt; {
        final Class&lt;U&gt; clazz;

<span class="fc" id="L355">        ClassFilter(Class&lt;U&gt; clazz) {</span>
<span class="fc" id="L356">            this.clazz = clazz;</span>
<span class="fc" id="L357">        }</span>

        @Override
        public boolean test(T t) throws Exception {
<span class="fc" id="L361">            return clazz.isInstance(t);</span>
        }
    }

    public static &lt;T, U&gt; Predicate&lt;T&gt; isInstanceOf(Class&lt;U&gt; clazz) {
<span class="fc" id="L366">        return new ClassFilter&lt;T, U&gt;(clazz);</span>
    }

    static final class BooleanSupplierPredicateReverse&lt;T&gt; implements Predicate&lt;T&gt; {
        final BooleanSupplier supplier;

<span class="fc" id="L372">        BooleanSupplierPredicateReverse(BooleanSupplier supplier) {</span>
<span class="fc" id="L373">            this.supplier = supplier;</span>
<span class="fc" id="L374">        }</span>

        @Override
        public boolean test(T t) throws Exception {
<span class="fc bfc" id="L378" title="All 2 branches covered.">            return !supplier.getAsBoolean();</span>
        }
    }

    public static &lt;T&gt; Predicate&lt;T&gt; predicateReverseFor(BooleanSupplier supplier) {
<span class="fc" id="L383">        return new BooleanSupplierPredicateReverse&lt;T&gt;(supplier);</span>
    }

    static final class TimestampFunction&lt;T&gt; implements Function&lt;T, Timed&lt;T&gt;&gt; {
        final TimeUnit unit;

        final Scheduler scheduler;

<span class="fc" id="L391">        TimestampFunction(TimeUnit unit, Scheduler scheduler) {</span>
<span class="fc" id="L392">            this.unit = unit;</span>
<span class="fc" id="L393">            this.scheduler = scheduler;</span>
<span class="fc" id="L394">        }</span>

        @Override
        public Timed&lt;T&gt; apply(T t) throws Exception {
<span class="fc" id="L398">            return new Timed&lt;T&gt;(t, scheduler.now(unit), unit);</span>
        }
    }

    public static &lt;T&gt; Function&lt;T, Timed&lt;T&gt;&gt; timestampWith(TimeUnit unit, Scheduler scheduler) {
<span class="fc" id="L403">        return new TimestampFunction&lt;T&gt;(unit, scheduler);</span>
    }

    static final class ToMapKeySelector&lt;K, T&gt; implements BiConsumer&lt;Map&lt;K, T&gt;, T&gt; {
        private final Function&lt;? super T, ? extends K&gt; keySelector;

<span class="fc" id="L409">        ToMapKeySelector(Function&lt;? super T, ? extends K&gt; keySelector) {</span>
<span class="fc" id="L410">            this.keySelector = keySelector;</span>
<span class="fc" id="L411">        }</span>

        @Override
        public void accept(Map&lt;K, T&gt; m, T t) throws Exception {
<span class="fc" id="L415">            K key = keySelector.apply(t);</span>
<span class="fc" id="L416">            m.put(key, t);</span>
<span class="fc" id="L417">        }</span>
    }

    public static &lt;T, K&gt; BiConsumer&lt;Map&lt;K, T&gt;, T&gt; toMapKeySelector(final Function&lt;? super T, ? extends K&gt; keySelector) {
<span class="fc" id="L421">        return new ToMapKeySelector&lt;K, T&gt;(keySelector);</span>
    }

    static final class ToMapKeyValueSelector&lt;K, V, T&gt; implements BiConsumer&lt;Map&lt;K, V&gt;, T&gt; {
        private final Function&lt;? super T, ? extends V&gt; valueSelector;
        private final Function&lt;? super T, ? extends K&gt; keySelector;

        ToMapKeyValueSelector(Function&lt;? super T, ? extends V&gt; valueSelector,
<span class="fc" id="L429">                Function&lt;? super T, ? extends K&gt; keySelector) {</span>
<span class="fc" id="L430">            this.valueSelector = valueSelector;</span>
<span class="fc" id="L431">            this.keySelector = keySelector;</span>
<span class="fc" id="L432">        }</span>

        @Override
        public void accept(Map&lt;K, V&gt; m, T t) throws Exception {
<span class="fc" id="L436">            K key = keySelector.apply(t);</span>
<span class="fc" id="L437">            V value = valueSelector.apply(t);</span>
<span class="fc" id="L438">            m.put(key, value);</span>
<span class="fc" id="L439">        }</span>
    }

    public static &lt;T, K, V&gt; BiConsumer&lt;Map&lt;K, V&gt;, T&gt; toMapKeyValueSelector(final Function&lt;? super T, ? extends K&gt; keySelector, final Function&lt;? super T, ? extends V&gt; valueSelector) {
<span class="fc" id="L443">        return new ToMapKeyValueSelector&lt;K, V, T&gt;(valueSelector, keySelector);</span>
    }

    static final class ToMultimapKeyValueSelector&lt;K, V, T&gt; implements BiConsumer&lt;Map&lt;K, Collection&lt;V&gt;&gt;, T&gt; {
        private final Function&lt;? super K, ? extends Collection&lt;? super V&gt;&gt; collectionFactory;
        private final Function&lt;? super T, ? extends V&gt; valueSelector;
        private final Function&lt;? super T, ? extends K&gt; keySelector;

        ToMultimapKeyValueSelector(Function&lt;? super K, ? extends Collection&lt;? super V&gt;&gt; collectionFactory,
<span class="fc" id="L452">                Function&lt;? super T, ? extends V&gt; valueSelector, Function&lt;? super T, ? extends K&gt; keySelector) {</span>
<span class="fc" id="L453">            this.collectionFactory = collectionFactory;</span>
<span class="fc" id="L454">            this.valueSelector = valueSelector;</span>
<span class="fc" id="L455">            this.keySelector = keySelector;</span>
<span class="fc" id="L456">        }</span>

        @SuppressWarnings(&quot;unchecked&quot;)
        @Override
        public void accept(Map&lt;K, Collection&lt;V&gt;&gt; m, T t) throws Exception {
<span class="fc" id="L461">            K key = keySelector.apply(t);</span>

<span class="fc" id="L463">            Collection&lt;V&gt; coll = m.get(key);</span>
<span class="fc bfc" id="L464" title="All 2 branches covered.">            if (coll == null) {</span>
<span class="fc" id="L465">                coll = (Collection&lt;V&gt;)collectionFactory.apply(key);</span>
<span class="fc" id="L466">                m.put(key, coll);</span>
            }

<span class="fc" id="L469">            V value = valueSelector.apply(t);</span>

<span class="fc" id="L471">            coll.add(value);</span>
<span class="fc" id="L472">        }</span>
    }

    public static &lt;T, K, V&gt; BiConsumer&lt;Map&lt;K, Collection&lt;V&gt;&gt;, T&gt; toMultimapKeyValueSelector(
            final Function&lt;? super T, ? extends K&gt; keySelector, final Function&lt;? super T, ? extends V&gt; valueSelector,
            final Function&lt;? super K, ? extends Collection&lt;? super V&gt;&gt; collectionFactory) {
<span class="fc" id="L478">        return new ToMultimapKeyValueSelector&lt;K, V, T&gt;(collectionFactory, valueSelector, keySelector);</span>
    }

<span class="fc" id="L481">    enum NaturalComparator implements Comparator&lt;Object&gt; {</span>
<span class="fc" id="L482">        INSTANCE;</span>

        @SuppressWarnings(&quot;unchecked&quot;)
        @Override
        public int compare(Object o1, Object o2) {
<span class="fc" id="L487">            return ((Comparable&lt;Object&gt;)o1).compareTo(o2);</span>
        }
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; Comparator&lt;T&gt; naturalComparator() {
<span class="fc" id="L493">        return (Comparator&lt;T&gt;)NaturalComparator.INSTANCE;</span>
    }

    static final class ListSorter&lt;T&gt; implements Function&lt;List&lt;T&gt;, List&lt;T&gt;&gt; {
        final Comparator&lt;? super T&gt; comparator;

<span class="fc" id="L499">        ListSorter(Comparator&lt;? super T&gt; comparator) {</span>
<span class="fc" id="L500">            this.comparator = comparator;</span>
<span class="fc" id="L501">        }</span>

        @Override
        public List&lt;T&gt; apply(List&lt;T&gt; v) {
<span class="fc" id="L505">            Collections.sort(v, comparator);</span>
<span class="fc" id="L506">            return v;</span>
        }
    }

    public static &lt;T&gt; Function&lt;List&lt;T&gt;, List&lt;T&gt;&gt; listSorter(final Comparator&lt;? super T&gt; comparator) {
<span class="fc" id="L511">        return new ListSorter&lt;T&gt;(comparator);</span>
    }

<span class="fc" id="L514">    public static final Consumer&lt;Subscription&gt; REQUEST_MAX = new MaxRequestSubscription();</span>

    static final class Array2Func&lt;T1, T2, R&gt; implements Function&lt;Object[], R&gt; {
        final BiFunction&lt;? super T1, ? super T2, ? extends R&gt; f;

<span class="fc" id="L519">        Array2Func(BiFunction&lt;? super T1, ? super T2, ? extends R&gt; f) {</span>
<span class="fc" id="L520">            this.f = f;</span>
<span class="fc" id="L521">        }</span>

        @SuppressWarnings(&quot;unchecked&quot;)
        @Override
        public R apply(Object[] a) throws Exception {
<span class="fc bfc" id="L526" title="All 2 branches covered.">            if (a.length != 2) {</span>
<span class="fc" id="L527">                throw new IllegalArgumentException(&quot;Array of size 2 expected but got &quot; + a.length);</span>
            }
<span class="fc" id="L529">            return f.apply((T1)a[0], (T2)a[1]);</span>
        }
    }

    static final class Array3Func&lt;T1, T2, T3, R&gt; implements Function&lt;Object[], R&gt; {
        final Function3&lt;T1, T2, T3, R&gt; f;

<span class="fc" id="L536">        Array3Func(Function3&lt;T1, T2, T3, R&gt; f) {</span>
<span class="fc" id="L537">            this.f = f;</span>
<span class="fc" id="L538">        }</span>

        @SuppressWarnings(&quot;unchecked&quot;)
        @Override
        public R apply(Object[] a) throws Exception {
<span class="fc bfc" id="L543" title="All 2 branches covered.">            if (a.length != 3) {</span>
<span class="fc" id="L544">                throw new IllegalArgumentException(&quot;Array of size 3 expected but got &quot; + a.length);</span>
            }
<span class="fc" id="L546">            return f.apply((T1)a[0], (T2)a[1], (T3)a[2]);</span>
        }
    }

    static final class Array4Func&lt;T1, T2, T3, T4, R&gt; implements Function&lt;Object[], R&gt; {
        final Function4&lt;T1, T2, T3, T4, R&gt; f;

<span class="fc" id="L553">        Array4Func(Function4&lt;T1, T2, T3, T4, R&gt; f) {</span>
<span class="fc" id="L554">            this.f = f;</span>
<span class="fc" id="L555">        }</span>

        @SuppressWarnings(&quot;unchecked&quot;)
        @Override
        public R apply(Object[] a) throws Exception {
<span class="fc bfc" id="L560" title="All 2 branches covered.">            if (a.length != 4) {</span>
<span class="fc" id="L561">                throw new IllegalArgumentException(&quot;Array of size 4 expected but got &quot; + a.length);</span>
            }
<span class="fc" id="L563">            return f.apply((T1)a[0], (T2)a[1], (T3)a[2], (T4)a[3]);</span>
        }
    }

    static final class Array5Func&lt;T1, T2, T3, T4, T5, R&gt; implements Function&lt;Object[], R&gt; {
        private final Function5&lt;T1, T2, T3, T4, T5, R&gt; f;

<span class="fc" id="L570">        Array5Func(Function5&lt;T1, T2, T3, T4, T5, R&gt; f) {</span>
<span class="fc" id="L571">            this.f = f;</span>
<span class="fc" id="L572">        }</span>

        @SuppressWarnings(&quot;unchecked&quot;)
        @Override
        public R apply(Object[] a) throws Exception {
<span class="fc bfc" id="L577" title="All 2 branches covered.">            if (a.length != 5) {</span>
<span class="fc" id="L578">                throw new IllegalArgumentException(&quot;Array of size 5 expected but got &quot; + a.length);</span>
            }
<span class="fc" id="L580">            return f.apply((T1)a[0], (T2)a[1], (T3)a[2], (T4)a[3], (T5)a[4]);</span>
        }
    }

    static final class Array6Func&lt;T1, T2, T3, T4, T5, T6, R&gt; implements Function&lt;Object[], R&gt; {
        final Function6&lt;T1, T2, T3, T4, T5, T6, R&gt; f;

<span class="fc" id="L587">        Array6Func(Function6&lt;T1, T2, T3, T4, T5, T6, R&gt; f) {</span>
<span class="fc" id="L588">            this.f = f;</span>
<span class="fc" id="L589">        }</span>

        @SuppressWarnings(&quot;unchecked&quot;)
        @Override
        public R apply(Object[] a) throws Exception {
<span class="fc bfc" id="L594" title="All 2 branches covered.">            if (a.length != 6) {</span>
<span class="fc" id="L595">                throw new IllegalArgumentException(&quot;Array of size 6 expected but got &quot; + a.length);</span>
            }
<span class="fc" id="L597">            return f.apply((T1)a[0], (T2)a[1], (T3)a[2], (T4)a[3], (T5)a[4], (T6)a[5]);</span>
        }
    }

    static final class Array7Func&lt;T1, T2, T3, T4, T5, T6, T7, R&gt; implements Function&lt;Object[], R&gt; {
        final Function7&lt;T1, T2, T3, T4, T5, T6, T7, R&gt; f;

<span class="fc" id="L604">        Array7Func(Function7&lt;T1, T2, T3, T4, T5, T6, T7, R&gt; f) {</span>
<span class="fc" id="L605">            this.f = f;</span>
<span class="fc" id="L606">        }</span>

        @SuppressWarnings(&quot;unchecked&quot;)
        @Override
        public R apply(Object[] a) throws Exception {
<span class="fc bfc" id="L611" title="All 2 branches covered.">            if (a.length != 7) {</span>
<span class="fc" id="L612">                throw new IllegalArgumentException(&quot;Array of size 7 expected but got &quot; + a.length);</span>
            }
<span class="fc" id="L614">            return f.apply((T1)a[0], (T2)a[1], (T3)a[2], (T4)a[3], (T5)a[4], (T6)a[5], (T7)a[6]);</span>
        }
    }

    static final class Array8Func&lt;T1, T2, T3, T4, T5, T6, T7, T8, R&gt; implements Function&lt;Object[], R&gt; {
        final Function8&lt;T1, T2, T3, T4, T5, T6, T7, T8, R&gt; f;

<span class="fc" id="L621">        Array8Func(Function8&lt;T1, T2, T3, T4, T5, T6, T7, T8, R&gt; f) {</span>
<span class="fc" id="L622">            this.f = f;</span>
<span class="fc" id="L623">        }</span>

        @SuppressWarnings(&quot;unchecked&quot;)
        @Override
        public R apply(Object[] a) throws Exception {
<span class="fc bfc" id="L628" title="All 2 branches covered.">            if (a.length != 8) {</span>
<span class="fc" id="L629">                throw new IllegalArgumentException(&quot;Array of size 8 expected but got &quot; + a.length);</span>
            }
<span class="fc" id="L631">            return f.apply((T1)a[0], (T2)a[1], (T3)a[2], (T4)a[3], (T5)a[4], (T6)a[5], (T7)a[6], (T8)a[7]);</span>
        }
    }

    static final class Array9Func&lt;T1, T2, T3, T4, T5, T6, T7, T8, T9, R&gt; implements Function&lt;Object[], R&gt; {
        final Function9&lt;T1, T2, T3, T4, T5, T6, T7, T8, T9, R&gt; f;

<span class="fc" id="L638">        Array9Func(Function9&lt;T1, T2, T3, T4, T5, T6, T7, T8, T9, R&gt; f) {</span>
<span class="fc" id="L639">            this.f = f;</span>
<span class="fc" id="L640">        }</span>

        @SuppressWarnings(&quot;unchecked&quot;)
        @Override
        public R apply(Object[] a) throws Exception {
<span class="fc bfc" id="L645" title="All 2 branches covered.">            if (a.length != 9) {</span>
<span class="fc" id="L646">                throw new IllegalArgumentException(&quot;Array of size 9 expected but got &quot; + a.length);</span>
            }
<span class="fc" id="L648">            return f.apply((T1)a[0], (T2)a[1], (T3)a[2], (T4)a[3], (T5)a[4], (T6)a[5], (T7)a[6], (T8)a[7], (T9)a[8]);</span>
        }
    }

<span class="fc" id="L652">    static final class Identity implements Function&lt;Object, Object&gt; {</span>
        @Override
        public Object apply(Object v) {
<span class="fc" id="L655">            return v;</span>
        }

        @Override
        public String toString() {
<span class="fc" id="L660">            return &quot;IdentityFunction&quot;;</span>
        }
    }

<span class="fc" id="L664">    static final class EmptyRunnable implements Runnable {</span>
        @Override
<span class="fc" id="L666">        public void run() { }</span>

        @Override
        public String toString() {
<span class="fc" id="L670">            return &quot;EmptyRunnable&quot;;</span>
        }
    }

<span class="fc" id="L674">    static final class EmptyAction implements Action {</span>
        @Override
<span class="fc" id="L676">        public void run() { }</span>

        @Override
        public String toString() {
<span class="fc" id="L680">            return &quot;EmptyAction&quot;;</span>
        }
    }

<span class="fc" id="L684">    static final class EmptyConsumer implements Consumer&lt;Object&gt; {</span>
        @Override
<span class="fc" id="L686">        public void accept(Object v) { }</span>

        @Override
        public String toString() {
<span class="fc" id="L690">            return &quot;EmptyConsumer&quot;;</span>
        }
    }

<span class="fc" id="L694">    static final class ErrorConsumer implements Consumer&lt;Throwable&gt; {</span>
        @Override
        public void accept(Throwable error) {
<span class="fc" id="L697">            RxJavaPlugins.onError(error);</span>
<span class="fc" id="L698">        }</span>
    }

<span class="fc" id="L701">    static final class OnErrorMissingConsumer implements Consumer&lt;Throwable&gt; {</span>
        @Override
        public void accept(Throwable error) {
<span class="fc" id="L704">            RxJavaPlugins.onError(new OnErrorNotImplementedException(error));</span>
<span class="fc" id="L705">        }</span>
    }

<span class="fc" id="L708">    static final class EmptyLongConsumer implements LongConsumer {</span>
        @Override
<span class="fc" id="L710">        public void accept(long v) { }</span>
    }

<span class="fc" id="L713">    static final class TruePredicate implements Predicate&lt;Object&gt; {</span>
        @Override
        public boolean test(Object o) {
<span class="fc" id="L716">            return true;</span>
        }
    }

<span class="fc" id="L720">    static final class FalsePredicate implements Predicate&lt;Object&gt; {</span>
        @Override
        public boolean test(Object o) {
<span class="fc" id="L723">            return false;</span>
        }
    }

<span class="fc" id="L727">    static final class NullCallable implements Callable&lt;Object&gt; {</span>
        @Override
        public Object call() {
<span class="fc" id="L730">            return null;</span>
        }
    }

<span class="fc" id="L734">    static final class NaturalObjectComparator implements Comparator&lt;Object&gt; {</span>
        @SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
        @Override
        public int compare(Object a, Object b) {
<span class="fc" id="L738">            return ((Comparable)a).compareTo(b);</span>
        }
    }

<span class="fc" id="L742">    static final class MaxRequestSubscription implements Consumer&lt;Subscription&gt; {</span>
        @Override
        public void accept(Subscription t) throws Exception {
<span class="fc" id="L745">            t.request(Long.MAX_VALUE);</span>
<span class="fc" id="L746">        }</span>
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; Consumer&lt;T&gt; boundedConsumer(int bufferSize) {
<span class="fc" id="L751">        return (Consumer&lt;T&gt;) new BoundedConsumer(bufferSize);</span>
    }

    public static class BoundedConsumer implements Consumer&lt;Subscription&gt; {

        final int bufferSize;

<span class="fc" id="L758">        BoundedConsumer(int bufferSize) {</span>
<span class="fc" id="L759">            this.bufferSize = bufferSize;</span>
<span class="fc" id="L760">        }</span>

        @Override
        public void accept(Subscription s) throws Exception {
<span class="fc" id="L764">            s.request(bufferSize);</span>
<span class="fc" id="L765">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>