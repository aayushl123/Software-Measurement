<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BlockingFlowableNextTest.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">RxJava_2_x$Unnamed.exec</a> &gt; <a href="index.source.html" class="el_package">io.reactivex.internal.operators.flowable</a> &gt; <span class="el_source">BlockingFlowableNextTest.java</span></div><h1>BlockingFlowableNextTest.java</h1><pre class="source lang-java linenums">/**
 * Copyright (c) 2016-present, RxJava Contributors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is
 * distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
 * the License for the specific language governing permissions and limitations under the License.
 */

package io.reactivex.internal.operators.flowable;

import static org.junit.Assert.*;

import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.*;

import org.junit.*;
import org.reactivestreams.*;

import io.reactivex.*;
import io.reactivex.disposables.SerialDisposable;
import io.reactivex.exceptions.TestException;
import io.reactivex.internal.operators.flowable.BlockingFlowableNext.NextSubscriber;
import io.reactivex.internal.subscriptions.BooleanSubscription;
import io.reactivex.plugins.RxJavaPlugins;
import io.reactivex.processors.*;
import io.reactivex.schedulers.Schedulers;

<span class="fc" id="L34">public class BlockingFlowableNextTest {</span>

    private void fireOnNextInNewThread(final FlowableProcessor&lt;String&gt; o, final String value) {
<span class="fc" id="L37">        new Thread() {</span>
            @Override
            public void run() {
                try {
<span class="fc" id="L41">                    Thread.sleep(500);</span>
<span class="nc" id="L42">                } catch (InterruptedException e) {</span>
                    // ignore
<span class="fc" id="L44">                }</span>
<span class="fc" id="L45">                o.onNext(value);</span>
<span class="fc" id="L46">            }</span>
<span class="fc" id="L47">        }.start();</span>
<span class="fc" id="L48">    }</span>

    private void fireOnErrorInNewThread(final FlowableProcessor&lt;String&gt; o) {
<span class="fc" id="L51">        new Thread() {</span>
            @Override
            public void run() {
                try {
<span class="fc" id="L55">                    Thread.sleep(500);</span>
<span class="nc" id="L56">                } catch (InterruptedException e) {</span>
                    // ignore
<span class="fc" id="L58">                }</span>
<span class="fc" id="L59">                o.onError(new TestException());</span>
<span class="fc" id="L60">            }</span>
<span class="fc" id="L61">        }.start();</span>
<span class="fc" id="L62">    }</span>

    @Test
    public void testNext() {
<span class="fc" id="L66">        FlowableProcessor&lt;String&gt; obs = PublishProcessor.create();</span>
<span class="fc" id="L67">        Iterator&lt;String&gt; it = obs.blockingNext().iterator();</span>
<span class="fc" id="L68">        fireOnNextInNewThread(obs, &quot;one&quot;);</span>
<span class="fc" id="L69">        assertTrue(it.hasNext());</span>
<span class="fc" id="L70">        assertEquals(&quot;one&quot;, it.next());</span>

<span class="fc" id="L72">        fireOnNextInNewThread(obs, &quot;two&quot;);</span>
<span class="fc" id="L73">        assertTrue(it.hasNext());</span>
<span class="fc" id="L74">        assertEquals(&quot;two&quot;, it.next());</span>

<span class="fc" id="L76">        fireOnNextInNewThread(obs, &quot;three&quot;);</span>
        try {
<span class="fc" id="L78">            assertEquals(&quot;three&quot;, it.next());</span>
<span class="nc" id="L79">        } catch (NoSuchElementException e) {</span>
<span class="nc" id="L80">            fail(&quot;Calling next() without hasNext() should wait for next fire&quot;);</span>
<span class="fc" id="L81">        }</span>

<span class="fc" id="L83">        obs.onComplete();</span>
<span class="fc" id="L84">        assertFalse(it.hasNext());</span>
        try {
<span class="nc" id="L86">            it.next();</span>
<span class="nc" id="L87">            fail(&quot;At the end of an iterator should throw a NoSuchElementException&quot;);</span>
<span class="fc" id="L88">        } catch (NoSuchElementException e) {</span>
<span class="nc" id="L89">        }</span>

        // If the observable is completed, hasNext always returns false and next always throw a NoSuchElementException.
<span class="fc" id="L92">        assertFalse(it.hasNext());</span>
        try {
<span class="nc" id="L94">            it.next();</span>
<span class="nc" id="L95">            fail(&quot;At the end of an iterator should throw a NoSuchElementException&quot;);</span>
<span class="fc" id="L96">        } catch (NoSuchElementException e) {</span>
<span class="nc" id="L97">        }</span>
<span class="fc" id="L98">    }</span>

    @Test
    public void testNextWithError() {
<span class="fc" id="L102">        FlowableProcessor&lt;String&gt; obs = PublishProcessor.create();</span>
<span class="fc" id="L103">        Iterator&lt;String&gt; it = obs.blockingNext().iterator();</span>
<span class="fc" id="L104">        fireOnNextInNewThread(obs, &quot;one&quot;);</span>
<span class="fc" id="L105">        assertTrue(it.hasNext());</span>
<span class="fc" id="L106">        assertEquals(&quot;one&quot;, it.next());</span>

<span class="fc" id="L108">        fireOnErrorInNewThread(obs);</span>
        try {
<span class="nc" id="L110">            it.hasNext();</span>
<span class="nc" id="L111">            fail(&quot;Expected an TestException&quot;);</span>
<span class="fc" id="L112">        } catch (TestException e) {</span>
<span class="nc" id="L113">        }</span>

<span class="fc" id="L115">        assertErrorAfterObservableFail(it);</span>
<span class="fc" id="L116">    }</span>

    @Test
    public void testNextWithEmpty() {
<span class="fc" id="L120">        Flowable&lt;String&gt; obs = Flowable.&lt;String&gt; empty().observeOn(Schedulers.newThread());</span>
<span class="fc" id="L121">        Iterator&lt;String&gt; it = obs.blockingNext().iterator();</span>

<span class="fc" id="L123">        assertFalse(it.hasNext());</span>
        try {
<span class="nc" id="L125">            it.next();</span>
<span class="nc" id="L126">            fail(&quot;At the end of an iterator should throw a NoSuchElementException&quot;);</span>
<span class="fc" id="L127">        } catch (NoSuchElementException e) {</span>
<span class="nc" id="L128">        }</span>

        // If the observable is completed, hasNext always returns false and next always throw a NoSuchElementException.
<span class="fc" id="L131">        assertFalse(it.hasNext());</span>
        try {
<span class="nc" id="L133">            it.next();</span>
<span class="nc" id="L134">            fail(&quot;At the end of an iterator should throw a NoSuchElementException&quot;);</span>
<span class="fc" id="L135">        } catch (NoSuchElementException e) {</span>
<span class="nc" id="L136">        }</span>
<span class="fc" id="L137">    }</span>

    @Test
    public void testOnError() throws Throwable {
<span class="fc" id="L141">        FlowableProcessor&lt;String&gt; obs = PublishProcessor.create();</span>
<span class="fc" id="L142">        Iterator&lt;String&gt; it = obs.blockingNext().iterator();</span>

<span class="fc" id="L144">        obs.onError(new TestException());</span>
        try {
<span class="nc" id="L146">            it.hasNext();</span>
<span class="nc" id="L147">            fail(&quot;Expected an TestException&quot;);</span>
<span class="fc" id="L148">        } catch (TestException e) {</span>
            // successful
<span class="nc" id="L150">        }</span>

<span class="fc" id="L152">        assertErrorAfterObservableFail(it);</span>
<span class="fc" id="L153">    }</span>

    @Test
    public void testOnErrorInNewThread() {
<span class="fc" id="L157">        FlowableProcessor&lt;String&gt; obs = PublishProcessor.create();</span>
<span class="fc" id="L158">        Iterator&lt;String&gt; it = obs.blockingNext().iterator();</span>

<span class="fc" id="L160">        fireOnErrorInNewThread(obs);</span>

        try {
<span class="nc" id="L163">            it.hasNext();</span>
<span class="nc" id="L164">            fail(&quot;Expected an TestException&quot;);</span>
<span class="fc" id="L165">        } catch (TestException e) {</span>
            // successful
<span class="nc" id="L167">        }</span>

<span class="fc" id="L169">        assertErrorAfterObservableFail(it);</span>
<span class="fc" id="L170">    }</span>

    private void assertErrorAfterObservableFail(Iterator&lt;String&gt; it) {
        // After the observable fails, hasNext and next always throw the exception.
        try {
<span class="nc" id="L175">            it.hasNext();</span>
<span class="nc" id="L176">            fail(&quot;hasNext should throw a TestException&quot;);</span>
<span class="fc" id="L177">        } catch (TestException e) {</span>
<span class="nc" id="L178">        }</span>
        try {
<span class="nc" id="L180">            it.next();</span>
<span class="nc" id="L181">            fail(&quot;next should throw a TestException&quot;);</span>
<span class="fc" id="L182">        } catch (TestException e) {</span>
<span class="nc" id="L183">        }</span>
<span class="fc" id="L184">    }</span>

    @Test
    public void testNextWithOnlyUsingNextMethod() {
<span class="fc" id="L188">        FlowableProcessor&lt;String&gt; obs = PublishProcessor.create();</span>
<span class="fc" id="L189">        Iterator&lt;String&gt; it = obs.blockingNext().iterator();</span>
<span class="fc" id="L190">        fireOnNextInNewThread(obs, &quot;one&quot;);</span>
<span class="fc" id="L191">        assertEquals(&quot;one&quot;, it.next());</span>

<span class="fc" id="L193">        fireOnNextInNewThread(obs, &quot;two&quot;);</span>
<span class="fc" id="L194">        assertEquals(&quot;two&quot;, it.next());</span>

<span class="fc" id="L196">        obs.onComplete();</span>
        try {
<span class="nc" id="L198">            it.next();</span>
<span class="nc" id="L199">            fail(&quot;At the end of an iterator should throw a NoSuchElementException&quot;);</span>
<span class="fc" id="L200">        } catch (NoSuchElementException e) {</span>
<span class="nc" id="L201">        }</span>
<span class="fc" id="L202">    }</span>

    @Test
    public void testNextWithCallingHasNextMultipleTimes() {
<span class="fc" id="L206">        FlowableProcessor&lt;String&gt; obs = PublishProcessor.create();</span>
<span class="fc" id="L207">        Iterator&lt;String&gt; it = obs.blockingNext().iterator();</span>
<span class="fc" id="L208">        fireOnNextInNewThread(obs, &quot;one&quot;);</span>
<span class="fc" id="L209">        assertTrue(it.hasNext());</span>
<span class="fc" id="L210">        assertTrue(it.hasNext());</span>
<span class="fc" id="L211">        assertTrue(it.hasNext());</span>
<span class="fc" id="L212">        assertTrue(it.hasNext());</span>
<span class="fc" id="L213">        assertEquals(&quot;one&quot;, it.next());</span>

<span class="fc" id="L215">        obs.onComplete();</span>
        try {
<span class="nc" id="L217">            it.next();</span>
<span class="nc" id="L218">            fail(&quot;At the end of an iterator should throw a NoSuchElementException&quot;);</span>
<span class="fc" id="L219">        } catch (NoSuchElementException e) {</span>
<span class="nc" id="L220">        }</span>
<span class="fc" id="L221">    }</span>

    /**
     * Confirm that no buffering or blocking of the Observable onNext calls occurs and it just grabs the next emitted value.
     * &lt;p/&gt;
     * This results in output such as =&gt; a: 1 b: 2 c: 89
     *
     * @throws Throwable some method call is declared throws
     */
    @Test
    public void testNoBufferingOrBlockingOfSequence() throws Throwable {
<span class="fc" id="L232">        int repeat = 0;</span>
        for (;;) {
<span class="fc" id="L234">            final SerialDisposable task = new SerialDisposable();</span>
            try {
<span class="fc" id="L236">                final CountDownLatch finished = new CountDownLatch(1);</span>
<span class="fc" id="L237">                final int COUNT = 30;</span>
<span class="fc" id="L238">                final CountDownLatch timeHasPassed = new CountDownLatch(COUNT);</span>
<span class="fc" id="L239">                final AtomicBoolean running = new AtomicBoolean(true);</span>
<span class="fc" id="L240">                final AtomicInteger count = new AtomicInteger(0);</span>
<span class="fc" id="L241">                final Flowable&lt;Integer&gt; obs = Flowable.unsafeCreate(new Publisher&lt;Integer&gt;() {</span>

                    @Override
                    public void subscribe(final Subscriber&lt;? super Integer&gt; subscriber) {
<span class="fc" id="L245">                        subscriber.onSubscribe(new BooleanSubscription());</span>
<span class="fc" id="L246">                        task.replace(Schedulers.single().scheduleDirect(new Runnable() {</span>

                            @Override
                            public void run() {
                                try {
<span class="pc bpc" id="L251" title="1 of 4 branches missed.">                                    while (running.get() &amp;&amp; !task.isDisposed()) {</span>
<span class="fc" id="L252">                                        subscriber.onNext(count.incrementAndGet());</span>
<span class="fc" id="L253">                                        timeHasPassed.countDown();</span>
                                    }
<span class="fc" id="L255">                                    subscriber.onComplete();</span>
<span class="nc" id="L256">                                } catch (Throwable e) {</span>
<span class="nc" id="L257">                                    subscriber.onError(e);</span>
                                } finally {
<span class="fc" id="L259">                                    finished.countDown();</span>
                                }
<span class="fc" id="L261">                            }</span>
                        }));
<span class="fc" id="L263">                    }</span>

                });

<span class="fc" id="L267">                Iterator&lt;Integer&gt; it = obs.blockingNext().iterator();</span>

<span class="fc" id="L269">                assertTrue(it.hasNext());</span>
<span class="fc" id="L270">                int a = it.next();</span>
<span class="fc" id="L271">                assertTrue(it.hasNext());</span>
<span class="fc" id="L272">                int b = it.next();</span>
                // we should have a different value
<span class="pc bpc" id="L274" title="1 of 2 branches missed.">                assertTrue(&quot;a and b should be different&quot;, a != b);</span>

                // wait for some time (if times out we are blocked somewhere so fail ... set very high for very slow, constrained machines)
<span class="fc" id="L277">                timeHasPassed.await(8000, TimeUnit.MILLISECONDS);</span>

<span class="fc" id="L279">                assertTrue(it.hasNext());</span>
<span class="fc" id="L280">                int c = it.next();</span>

<span class="pc bpc" id="L282" title="1 of 2 branches missed.">                assertTrue(&quot;c should not just be the next in sequence&quot;, c != (b + 1));</span>
<span class="pc bpc" id="L283" title="1 of 2 branches missed.">                assertTrue(&quot;expected that c [&quot; + c + &quot;] is higher than or equal to &quot; + COUNT, c &gt;= COUNT);</span>

<span class="fc" id="L285">                assertTrue(it.hasNext());</span>
<span class="fc" id="L286">                int d = it.next();</span>
<span class="pc bpc" id="L287" title="1 of 2 branches missed.">                assertTrue(d &gt; c);</span>

                // shut down the thread
<span class="fc" id="L290">                running.set(false);</span>

<span class="fc" id="L292">                finished.await();</span>

<span class="fc" id="L294">                assertFalse(it.hasNext());</span>

<span class="fc" id="L296">                System.out.println(&quot;a: &quot; + a + &quot; b: &quot; + b + &quot; c: &quot; + c);</span>
                break;
<span class="nc" id="L298">            } catch (AssertionError ex) {</span>
<span class="nc bnc" id="L299" title="All 2 branches missed.">                if (++repeat == 3) {</span>
<span class="nc" id="L300">                    throw ex;</span>
                }
<span class="nc" id="L302">                Thread.sleep((int)(1000 * Math.pow(2, repeat - 1)));</span>
            } finally {
<span class="fc" id="L304">                task.dispose();</span>
            }
<span class="nc" id="L306">        }</span>
<span class="fc" id="L307">    }</span>

    @Test /* (timeout = 8000) */
    public void testSingleSourceManyIterators() throws InterruptedException {
<span class="fc" id="L311">        Flowable&lt;Long&gt; f = Flowable.interval(250, TimeUnit.MILLISECONDS);</span>
<span class="fc" id="L312">        PublishProcessor&lt;Integer&gt; terminal = PublishProcessor.create();</span>
<span class="fc" id="L313">        Flowable&lt;Long&gt; source = f.takeUntil(terminal);</span>

<span class="fc" id="L315">        Iterable&lt;Long&gt; iter = source.blockingNext();</span>

<span class="fc bfc" id="L317" title="All 2 branches covered.">        for (int j = 0; j &lt; 3; j++) {</span>
<span class="fc" id="L318">            BlockingFlowableNext.NextIterator&lt;Long&gt; it = (BlockingFlowableNext.NextIterator&lt;Long&gt;)iter.iterator();</span>

<span class="fc bfc" id="L320" title="All 2 branches covered.">            for (long i = 0; i &lt; 10; i++) {</span>
<span class="fc" id="L321">                Assert.assertEquals(true, it.hasNext());</span>
<span class="fc" id="L322">                Assert.assertEquals(j + &quot;th iteration next&quot;, Long.valueOf(i), it.next());</span>
            }
<span class="fc" id="L324">            terminal.onNext(1);</span>
        }
<span class="fc" id="L326">    }</span>

    @Test
    public void testSynchronousNext() {
<span class="fc" id="L330">        assertEquals(1, BehaviorProcessor.createDefault(1).take(1).blockingSingle().intValue());</span>
<span class="fc" id="L331">        assertEquals(2, BehaviorProcessor.createDefault(2).blockingIterable().iterator().next().intValue());</span>
<span class="fc" id="L332">        assertEquals(3, BehaviorProcessor.createDefault(3).blockingNext().iterator().next().intValue());</span>
<span class="fc" id="L333">    }</span>

    @Ignore(&quot;THe target is an enum&quot;)
    @Test
    public void constructorshouldbeprivate() {
<span class="nc" id="L338">        TestHelper.checkUtilityClass(BlockingFlowableNext.class);</span>
<span class="nc" id="L339">    }</span>

    @Test(expected = UnsupportedOperationException.class)
    public void remove() {
<span class="nc" id="L343">        Flowable.never().blockingNext().iterator().remove();</span>
<span class="nc" id="L344">    }</span>

    @Test
    public void interrupt() {
<span class="fc" id="L348">        Iterator&lt;Object&gt; it = Flowable.never().blockingNext().iterator();</span>

        try {
<span class="fc" id="L351">            Thread.currentThread().interrupt();</span>
<span class="nc" id="L352">            it.next();</span>
<span class="fc" id="L353">        } catch (RuntimeException ex) {</span>
<span class="fc" id="L354">            assertTrue(ex.toString(), ex.getCause() instanceof InterruptedException);</span>
<span class="nc" id="L355">        }</span>
<span class="fc" id="L356">    }</span>

    @Test
    public void nextObserverError() {
<span class="fc" id="L360">        NextSubscriber&lt;Integer&gt; no = new NextSubscriber&lt;Integer&gt;();</span>

<span class="fc" id="L362">        List&lt;Throwable&gt; errors = TestHelper.trackPluginErrors();</span>
        try {
<span class="fc" id="L364">            no.onError(new TestException());</span>

<span class="fc" id="L366">            TestHelper.assertUndeliverable(errors, 0, TestException.class);</span>
        } finally {
<span class="fc" id="L368">            RxJavaPlugins.reset();</span>
        }
<span class="fc" id="L370">    }</span>

    @Test
    public void nextObserverOnNext() throws Exception {
<span class="fc" id="L374">        NextSubscriber&lt;Integer&gt; no = new NextSubscriber&lt;Integer&gt;();</span>

<span class="fc" id="L376">        no.setWaiting();</span>
<span class="fc" id="L377">        no.onNext(Notification.createOnNext(1));</span>

<span class="fc" id="L379">        no.setWaiting();</span>
<span class="fc" id="L380">        no.onNext(Notification.createOnNext(1));</span>

<span class="fc" id="L382">        assertEquals(1, no.takeNext().getValue().intValue());</span>
<span class="fc" id="L383">    }</span>

    @Test
    public void nextObserverOnCompleteOnNext() throws Exception {
<span class="fc" id="L387">        NextSubscriber&lt;Integer&gt; no = new NextSubscriber&lt;Integer&gt;();</span>

<span class="fc" id="L389">        no.setWaiting();</span>
<span class="fc" id="L390">        no.onNext(Notification.&lt;Integer&gt;createOnComplete());</span>

<span class="fc" id="L392">        no.setWaiting();</span>
<span class="fc" id="L393">        no.onNext(Notification.createOnNext(1));</span>

<span class="fc" id="L395">        assertTrue(no.takeNext().isOnComplete());</span>
<span class="fc" id="L396">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>