<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FlowableBufferTest.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">RxJava_2_x$Unnamed.exec</a> &gt; <a href="index.source.html" class="el_package">io.reactivex.internal.operators.flowable</a> &gt; <span class="el_source">FlowableBufferTest.java</span></div><h1>FlowableBufferTest.java</h1><pre class="source lang-java linenums">/**
 * Copyright (c) 2016-present, RxJava Contributors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is
 * distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
 * the License for the specific language governing permissions and limitations under the License.
 */

package io.reactivex.internal.operators.flowable;

import static org.junit.Assert.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.*;

import org.junit.*;
import org.mockito.*;
import org.reactivestreams.*;

import io.reactivex.*;
import io.reactivex.disposables.Disposable;
import io.reactivex.exceptions.*;
import io.reactivex.functions.*;
import io.reactivex.internal.disposables.DisposableHelper;
import io.reactivex.internal.functions.Functions;
import io.reactivex.internal.operators.flowable.FlowableBufferBoundarySupplier.BufferBoundarySupplierSubscriber;
import io.reactivex.internal.operators.flowable.FlowableBufferTimed.*;
import io.reactivex.internal.subscriptions.BooleanSubscription;
import io.reactivex.plugins.RxJavaPlugins;
import io.reactivex.processors.*;
import io.reactivex.schedulers.*;
import io.reactivex.subscribers.*;

<span class="fc" id="L43">public class FlowableBufferTest {</span>

    private Subscriber&lt;List&lt;String&gt;&gt; subscriber;
    private TestScheduler scheduler;
    private Scheduler.Worker innerScheduler;

    @Before
    public void before() {
<span class="fc" id="L51">        subscriber = TestHelper.mockSubscriber();</span>
<span class="fc" id="L52">        scheduler = new TestScheduler();</span>
<span class="fc" id="L53">        innerScheduler = scheduler.createWorker();</span>
<span class="fc" id="L54">    }</span>

    @Test
    public void testComplete() {
<span class="fc" id="L58">        Flowable&lt;String&gt; source = Flowable.empty();</span>

<span class="fc" id="L60">        Flowable&lt;List&lt;String&gt;&gt; buffered = source.buffer(3, 3);</span>
<span class="fc" id="L61">        buffered.subscribe(subscriber);</span>

<span class="fc" id="L63">        Mockito.verify(subscriber, Mockito.never()).onNext(Mockito.&lt;String&gt;anyList());</span>
<span class="fc" id="L64">        Mockito.verify(subscriber, Mockito.never()).onError(Mockito.any(Throwable.class));</span>
<span class="fc" id="L65">        Mockito.verify(subscriber, Mockito.times(1)).onComplete();</span>
<span class="fc" id="L66">    }</span>

    @Test
    public void testSkipAndCountOverlappingBuffers() {
<span class="fc" id="L70">        Flowable&lt;String&gt; source = Flowable.unsafeCreate(new Publisher&lt;String&gt;() {</span>
            @Override
            public void subscribe(Subscriber&lt;? super String&gt; subscriber) {
<span class="fc" id="L73">                subscriber.onSubscribe(new BooleanSubscription());</span>
<span class="fc" id="L74">                subscriber.onNext(&quot;one&quot;);</span>
<span class="fc" id="L75">                subscriber.onNext(&quot;two&quot;);</span>
<span class="fc" id="L76">                subscriber.onNext(&quot;three&quot;);</span>
<span class="fc" id="L77">                subscriber.onNext(&quot;four&quot;);</span>
<span class="fc" id="L78">                subscriber.onNext(&quot;five&quot;);</span>
<span class="fc" id="L79">            }</span>
        });

<span class="fc" id="L82">        Flowable&lt;List&lt;String&gt;&gt; buffered = source.buffer(3, 1);</span>
<span class="fc" id="L83">        buffered.subscribe(subscriber);</span>

<span class="fc" id="L85">        InOrder inOrder = Mockito.inOrder(subscriber);</span>
<span class="fc" id="L86">        inOrder.verify(subscriber, Mockito.times(1)).onNext(list(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;));</span>
<span class="fc" id="L87">        inOrder.verify(subscriber, Mockito.times(1)).onNext(list(&quot;two&quot;, &quot;three&quot;, &quot;four&quot;));</span>
<span class="fc" id="L88">        inOrder.verify(subscriber, Mockito.times(1)).onNext(list(&quot;three&quot;, &quot;four&quot;, &quot;five&quot;));</span>
<span class="fc" id="L89">        inOrder.verify(subscriber, Mockito.never()).onNext(Mockito.&lt;String&gt;anyList());</span>
<span class="fc" id="L90">        inOrder.verify(subscriber, Mockito.never()).onError(Mockito.any(Throwable.class));</span>
<span class="fc" id="L91">        inOrder.verify(subscriber, Mockito.never()).onComplete();</span>
<span class="fc" id="L92">    }</span>

    @Test
    public void testSkipAndCountGaplessBuffers() {
<span class="fc" id="L96">        Flowable&lt;String&gt; source = Flowable.just(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;);</span>

<span class="fc" id="L98">        Flowable&lt;List&lt;String&gt;&gt; buffered = source.buffer(3, 3);</span>
<span class="fc" id="L99">        buffered.subscribe(subscriber);</span>

<span class="fc" id="L101">        InOrder inOrder = Mockito.inOrder(subscriber);</span>
<span class="fc" id="L102">        inOrder.verify(subscriber, Mockito.times(1)).onNext(list(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;));</span>
<span class="fc" id="L103">        inOrder.verify(subscriber, Mockito.times(1)).onNext(list(&quot;four&quot;, &quot;five&quot;));</span>
<span class="fc" id="L104">        inOrder.verify(subscriber, Mockito.never()).onNext(Mockito.&lt;String&gt;anyList());</span>
<span class="fc" id="L105">        inOrder.verify(subscriber, Mockito.never()).onError(Mockito.any(Throwable.class));</span>
<span class="fc" id="L106">        inOrder.verify(subscriber, Mockito.times(1)).onComplete();</span>
<span class="fc" id="L107">    }</span>

    @Test
    public void testSkipAndCountBuffersWithGaps() {
<span class="fc" id="L111">        Flowable&lt;String&gt; source = Flowable.just(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;);</span>

<span class="fc" id="L113">        Flowable&lt;List&lt;String&gt;&gt; buffered = source.buffer(2, 3);</span>
<span class="fc" id="L114">        buffered.subscribe(subscriber);</span>

<span class="fc" id="L116">        InOrder inOrder = Mockito.inOrder(subscriber);</span>
<span class="fc" id="L117">        inOrder.verify(subscriber, Mockito.times(1)).onNext(list(&quot;one&quot;, &quot;two&quot;));</span>
<span class="fc" id="L118">        inOrder.verify(subscriber, Mockito.times(1)).onNext(list(&quot;four&quot;, &quot;five&quot;));</span>
<span class="fc" id="L119">        inOrder.verify(subscriber, Mockito.never()).onNext(Mockito.&lt;String&gt;anyList());</span>
<span class="fc" id="L120">        inOrder.verify(subscriber, Mockito.never()).onError(Mockito.any(Throwable.class));</span>
<span class="fc" id="L121">        inOrder.verify(subscriber, Mockito.times(1)).onComplete();</span>
<span class="fc" id="L122">    }</span>

    @Test
    public void testTimedAndCount() {
<span class="fc" id="L126">        Flowable&lt;String&gt; source = Flowable.unsafeCreate(new Publisher&lt;String&gt;() {</span>
            @Override
            public void subscribe(Subscriber&lt;? super String&gt; subscriber) {
<span class="fc" id="L129">                subscriber.onSubscribe(new BooleanSubscription());</span>
<span class="fc" id="L130">                push(subscriber, &quot;one&quot;, 10);</span>
<span class="fc" id="L131">                push(subscriber, &quot;two&quot;, 90);</span>
<span class="fc" id="L132">                push(subscriber, &quot;three&quot;, 110);</span>
<span class="fc" id="L133">                push(subscriber, &quot;four&quot;, 190);</span>
<span class="fc" id="L134">                push(subscriber, &quot;five&quot;, 210);</span>
<span class="fc" id="L135">                complete(subscriber, 250);</span>
<span class="fc" id="L136">            }</span>
        });

<span class="fc" id="L139">        Flowable&lt;List&lt;String&gt;&gt; buffered = source.buffer(100, TimeUnit.MILLISECONDS, scheduler, 2);</span>
<span class="fc" id="L140">        buffered.subscribe(subscriber);</span>

<span class="fc" id="L142">        InOrder inOrder = Mockito.inOrder(subscriber);</span>
<span class="fc" id="L143">        scheduler.advanceTimeTo(100, TimeUnit.MILLISECONDS);</span>
<span class="fc" id="L144">        inOrder.verify(subscriber, Mockito.times(1)).onNext(list(&quot;one&quot;, &quot;two&quot;));</span>

<span class="fc" id="L146">        scheduler.advanceTimeTo(200, TimeUnit.MILLISECONDS);</span>
<span class="fc" id="L147">        inOrder.verify(subscriber, Mockito.times(1)).onNext(list(&quot;three&quot;, &quot;four&quot;));</span>

<span class="fc" id="L149">        scheduler.advanceTimeTo(300, TimeUnit.MILLISECONDS);</span>
<span class="fc" id="L150">        inOrder.verify(subscriber, Mockito.times(1)).onNext(list(&quot;five&quot;));</span>
<span class="fc" id="L151">        inOrder.verify(subscriber, Mockito.never()).onNext(Mockito.&lt;String&gt;anyList());</span>
<span class="fc" id="L152">        inOrder.verify(subscriber, Mockito.never()).onError(Mockito.any(Throwable.class));</span>
<span class="fc" id="L153">        inOrder.verify(subscriber, Mockito.times(1)).onComplete();</span>
<span class="fc" id="L154">    }</span>

    @Test
    public void testTimed() {
<span class="fc" id="L158">        Flowable&lt;String&gt; source = Flowable.unsafeCreate(new Publisher&lt;String&gt;() {</span>
            @Override
            public void subscribe(Subscriber&lt;? super String&gt; subscriber) {
<span class="fc" id="L161">                subscriber.onSubscribe(new BooleanSubscription());</span>
<span class="fc" id="L162">                push(subscriber, &quot;one&quot;, 97);</span>
<span class="fc" id="L163">                push(subscriber, &quot;two&quot;, 98);</span>
                /**
                 * Changed from 100. Because scheduling the cut to 100ms happens before this
                 * Flowable even runs due how lift works, pushing at 100ms would execute after the
                 * buffer cut.
                 */
<span class="fc" id="L169">                push(subscriber, &quot;three&quot;, 99);</span>
<span class="fc" id="L170">                push(subscriber, &quot;four&quot;, 101);</span>
<span class="fc" id="L171">                push(subscriber, &quot;five&quot;, 102);</span>
<span class="fc" id="L172">                complete(subscriber, 150);</span>
<span class="fc" id="L173">            }</span>
        });

<span class="fc" id="L176">        Flowable&lt;List&lt;String&gt;&gt; buffered = source.buffer(100, TimeUnit.MILLISECONDS, scheduler);</span>
<span class="fc" id="L177">        buffered.subscribe(subscriber);</span>

<span class="fc" id="L179">        InOrder inOrder = Mockito.inOrder(subscriber);</span>
<span class="fc" id="L180">        scheduler.advanceTimeTo(101, TimeUnit.MILLISECONDS);</span>
<span class="fc" id="L181">        inOrder.verify(subscriber, Mockito.times(1)).onNext(list(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;));</span>

<span class="fc" id="L183">        scheduler.advanceTimeTo(201, TimeUnit.MILLISECONDS);</span>
<span class="fc" id="L184">        inOrder.verify(subscriber, Mockito.times(1)).onNext(list(&quot;four&quot;, &quot;five&quot;));</span>
<span class="fc" id="L185">        inOrder.verify(subscriber, Mockito.never()).onNext(Mockito.&lt;String&gt;anyList());</span>
<span class="fc" id="L186">        inOrder.verify(subscriber, Mockito.never()).onError(Mockito.any(Throwable.class));</span>
<span class="fc" id="L187">        inOrder.verify(subscriber, Mockito.times(1)).onComplete();</span>
<span class="fc" id="L188">    }</span>

    @Test
    public void testFlowableBasedOpenerAndCloser() {
<span class="fc" id="L192">        Flowable&lt;String&gt; source = Flowable.unsafeCreate(new Publisher&lt;String&gt;() {</span>
            @Override
            public void subscribe(Subscriber&lt;? super String&gt; subscriber) {
<span class="fc" id="L195">                subscriber.onSubscribe(new BooleanSubscription());</span>
<span class="fc" id="L196">                push(subscriber, &quot;one&quot;, 10);</span>
<span class="fc" id="L197">                push(subscriber, &quot;two&quot;, 60);</span>
<span class="fc" id="L198">                push(subscriber, &quot;three&quot;, 110);</span>
<span class="fc" id="L199">                push(subscriber, &quot;four&quot;, 160);</span>
<span class="fc" id="L200">                push(subscriber, &quot;five&quot;, 210);</span>
<span class="fc" id="L201">                complete(subscriber, 500);</span>
<span class="fc" id="L202">            }</span>
        });

<span class="fc" id="L205">        Flowable&lt;Object&gt; openings = Flowable.unsafeCreate(new Publisher&lt;Object&gt;() {</span>
            @Override
            public void subscribe(Subscriber&lt;Object&gt; subscriber) {
<span class="fc" id="L208">                subscriber.onSubscribe(new BooleanSubscription());</span>
<span class="fc" id="L209">                push(subscriber, new Object(), 50);</span>
<span class="fc" id="L210">                push(subscriber, new Object(), 200);</span>
<span class="fc" id="L211">                complete(subscriber, 250);</span>
<span class="fc" id="L212">            }</span>
        });

<span class="fc" id="L215">        Function&lt;Object, Flowable&lt;Object&gt;&gt; closer = new Function&lt;Object, Flowable&lt;Object&gt;&gt;() {</span>
            @Override
            public Flowable&lt;Object&gt; apply(Object opening) {
<span class="fc" id="L218">                return Flowable.unsafeCreate(new Publisher&lt;Object&gt;() {</span>
                    @Override
                    public void subscribe(Subscriber&lt;? super Object&gt; subscriber) {
<span class="fc" id="L221">                        subscriber.onSubscribe(new BooleanSubscription());</span>
<span class="fc" id="L222">                        push(subscriber, new Object(), 100);</span>
<span class="fc" id="L223">                        complete(subscriber, 101);</span>
<span class="fc" id="L224">                    }</span>
                });
            }
        };

<span class="fc" id="L229">        Flowable&lt;List&lt;String&gt;&gt; buffered = source.buffer(openings, closer);</span>
<span class="fc" id="L230">        buffered.subscribe(subscriber);</span>

<span class="fc" id="L232">        InOrder inOrder = Mockito.inOrder(subscriber);</span>
<span class="fc" id="L233">        scheduler.advanceTimeTo(500, TimeUnit.MILLISECONDS);</span>
<span class="fc" id="L234">        inOrder.verify(subscriber, Mockito.times(1)).onNext(list(&quot;two&quot;, &quot;three&quot;));</span>
<span class="fc" id="L235">        inOrder.verify(subscriber, Mockito.times(1)).onNext(list(&quot;five&quot;));</span>
<span class="fc" id="L236">        inOrder.verify(subscriber, Mockito.never()).onNext(Mockito.&lt;String&gt;anyList());</span>
<span class="fc" id="L237">        inOrder.verify(subscriber, Mockito.never()).onError(Mockito.any(Throwable.class));</span>
<span class="fc" id="L238">        inOrder.verify(subscriber, Mockito.times(1)).onComplete();</span>
<span class="fc" id="L239">    }</span>

    @Test
    public void testFlowableBasedCloser() {
<span class="fc" id="L243">        Flowable&lt;String&gt; source = Flowable.unsafeCreate(new Publisher&lt;String&gt;() {</span>
            @Override
            public void subscribe(Subscriber&lt;? super String&gt; subscriber) {
<span class="fc" id="L246">                subscriber.onSubscribe(new BooleanSubscription());</span>
<span class="fc" id="L247">                push(subscriber, &quot;one&quot;, 10);</span>
<span class="fc" id="L248">                push(subscriber, &quot;two&quot;, 60);</span>
<span class="fc" id="L249">                push(subscriber, &quot;three&quot;, 110);</span>
<span class="fc" id="L250">                push(subscriber, &quot;four&quot;, 160);</span>
<span class="fc" id="L251">                push(subscriber, &quot;five&quot;, 210);</span>
<span class="fc" id="L252">                complete(subscriber, 250);</span>
<span class="fc" id="L253">            }</span>
        });

<span class="fc" id="L256">        Callable&lt;Flowable&lt;Object&gt;&gt; closer = new Callable&lt;Flowable&lt;Object&gt;&gt;() {</span>
            @Override
            public Flowable&lt;Object&gt; call() {
<span class="fc" id="L259">                return Flowable.unsafeCreate(new Publisher&lt;Object&gt;() {</span>
                    @Override
                    public void subscribe(Subscriber&lt;? super Object&gt; subscriber) {
<span class="fc" id="L262">                        subscriber.onSubscribe(new BooleanSubscription());</span>
<span class="fc" id="L263">                        push(subscriber, new Object(), 100);</span>
<span class="fc" id="L264">                        push(subscriber, new Object(), 200);</span>
<span class="fc" id="L265">                        push(subscriber, new Object(), 300);</span>
<span class="fc" id="L266">                        complete(subscriber, 301);</span>
<span class="fc" id="L267">                    }</span>
                });
            }
        };

<span class="fc" id="L272">        Flowable&lt;List&lt;String&gt;&gt; buffered = source.buffer(closer);</span>
<span class="fc" id="L273">        buffered.subscribe(subscriber);</span>

<span class="fc" id="L275">        InOrder inOrder = Mockito.inOrder(subscriber);</span>
<span class="fc" id="L276">        scheduler.advanceTimeTo(500, TimeUnit.MILLISECONDS);</span>
<span class="fc" id="L277">        inOrder.verify(subscriber, Mockito.times(1)).onNext(list(&quot;one&quot;, &quot;two&quot;));</span>
<span class="fc" id="L278">        inOrder.verify(subscriber, Mockito.times(1)).onNext(list(&quot;three&quot;, &quot;four&quot;));</span>
<span class="fc" id="L279">        inOrder.verify(subscriber, Mockito.times(1)).onNext(list(&quot;five&quot;));</span>
<span class="fc" id="L280">        inOrder.verify(subscriber, Mockito.never()).onNext(Mockito.&lt;String&gt;anyList());</span>
<span class="fc" id="L281">        inOrder.verify(subscriber, Mockito.never()).onError(Mockito.any(Throwable.class));</span>
<span class="fc" id="L282">        inOrder.verify(subscriber, Mockito.times(1)).onComplete();</span>
<span class="fc" id="L283">    }</span>

    @Test
    public void testLongTimeAction() throws InterruptedException {
<span class="fc" id="L287">        final CountDownLatch latch = new CountDownLatch(1);</span>
<span class="fc" id="L288">        LongTimeAction action = new LongTimeAction(latch);</span>
<span class="fc" id="L289">        Flowable.just(1).buffer(10, TimeUnit.MILLISECONDS, 10)</span>
<span class="fc" id="L290">                .subscribe(action);</span>
<span class="fc" id="L291">        latch.await();</span>
<span class="fc" id="L292">        assertFalse(action.fail);</span>
<span class="fc" id="L293">    }</span>

    static final class LongTimeAction implements Consumer&lt;List&lt;Integer&gt;&gt; {

        CountDownLatch latch;
        boolean fail;

<span class="fc" id="L300">        LongTimeAction(CountDownLatch latch) {</span>
<span class="fc" id="L301">            this.latch = latch;</span>
<span class="fc" id="L302">        }</span>

        @Override
        public void accept(List&lt;Integer&gt; t1) {
            try {
<span class="pc bpc" id="L307" title="1 of 2 branches missed.">                if (fail) {</span>
<span class="nc" id="L308">                    return;</span>
                }
<span class="fc" id="L310">                Thread.sleep(200);</span>
<span class="nc" id="L311">            } catch (InterruptedException e) {</span>
<span class="nc" id="L312">                fail = true;</span>
            } finally {
<span class="fc" id="L314">                latch.countDown();</span>
            }
<span class="fc" id="L316">        }</span>
    }

    private List&lt;String&gt; list(String... args) {
<span class="fc" id="L320">        List&lt;String&gt; list = new ArrayList&lt;String&gt;();</span>
<span class="fc bfc" id="L321" title="All 2 branches covered.">        for (String arg : args) {</span>
<span class="fc" id="L322">            list.add(arg);</span>
        }
<span class="fc" id="L324">        return list;</span>
    }

    private &lt;T&gt; void push(final Subscriber&lt;T&gt; subscriber, final T value, int delay) {
<span class="fc" id="L328">        innerScheduler.schedule(new Runnable() {</span>
            @Override
            public void run() {
<span class="fc" id="L331">                subscriber.onNext(value);</span>
<span class="fc" id="L332">            }</span>
        }, delay, TimeUnit.MILLISECONDS);
<span class="fc" id="L334">    }</span>

    private void complete(final Subscriber&lt;?&gt; subscriber, int delay) {
<span class="fc" id="L337">        innerScheduler.schedule(new Runnable() {</span>
            @Override
            public void run() {
<span class="fc" id="L340">                subscriber.onComplete();</span>
<span class="fc" id="L341">            }</span>
        }, delay, TimeUnit.MILLISECONDS);
<span class="fc" id="L343">    }</span>

    @Test
    public void testBufferStopsWhenUnsubscribed1() {
<span class="fc" id="L347">        Flowable&lt;Integer&gt; source = Flowable.never();</span>

<span class="fc" id="L349">        Subscriber&lt;List&lt;Integer&gt;&gt; subscriber = TestHelper.mockSubscriber();</span>
<span class="fc" id="L350">        TestSubscriber&lt;List&lt;Integer&gt;&gt; ts = new TestSubscriber&lt;List&lt;Integer&gt;&gt;(subscriber, 0L);</span>

<span class="fc" id="L352">        source.buffer(100, 200, TimeUnit.MILLISECONDS, scheduler)</span>
<span class="fc" id="L353">        .doOnNext(new Consumer&lt;List&lt;Integer&gt;&gt;() {</span>
            @Override
            public void accept(List&lt;Integer&gt; pv) {
<span class="fc" id="L356">                System.out.println(pv);</span>
<span class="fc" id="L357">            }</span>
        })
<span class="fc" id="L359">        .subscribe(ts);</span>

<span class="fc" id="L361">        InOrder inOrder = Mockito.inOrder(subscriber);</span>

<span class="fc" id="L363">        scheduler.advanceTimeBy(1001, TimeUnit.MILLISECONDS);</span>

<span class="fc" id="L365">        inOrder.verify(subscriber, times(5)).onNext(Arrays.&lt;Integer&gt; asList());</span>

<span class="fc" id="L367">        ts.dispose();</span>

<span class="fc" id="L369">        scheduler.advanceTimeBy(999, TimeUnit.MILLISECONDS);</span>

<span class="fc" id="L371">        inOrder.verifyNoMoreInteractions();</span>
<span class="fc" id="L372">    }</span>

    @Test
    public void bufferWithBONormal1() {
<span class="fc" id="L376">        PublishProcessor&lt;Integer&gt; source = PublishProcessor.create();</span>
<span class="fc" id="L377">        PublishProcessor&lt;Integer&gt; boundary = PublishProcessor.create();</span>

<span class="fc" id="L379">        Subscriber&lt;Object&gt; subscriber = TestHelper.mockSubscriber();</span>
<span class="fc" id="L380">        InOrder inOrder = Mockito.inOrder(subscriber);</span>

<span class="fc" id="L382">        source.buffer(boundary).subscribe(subscriber);</span>

<span class="fc" id="L384">        source.onNext(1);</span>
<span class="fc" id="L385">        source.onNext(2);</span>
<span class="fc" id="L386">        source.onNext(3);</span>

<span class="fc" id="L388">        boundary.onNext(1);</span>

<span class="fc" id="L390">        inOrder.verify(subscriber, times(1)).onNext(Arrays.asList(1, 2, 3));</span>

<span class="fc" id="L392">        source.onNext(4);</span>
<span class="fc" id="L393">        source.onNext(5);</span>

<span class="fc" id="L395">        boundary.onNext(2);</span>

<span class="fc" id="L397">        inOrder.verify(subscriber, times(1)).onNext(Arrays.asList(4, 5));</span>

<span class="fc" id="L399">        source.onNext(6);</span>
<span class="fc" id="L400">        boundary.onComplete();</span>

<span class="fc" id="L402">        inOrder.verify(subscriber, times(1)).onNext(Arrays.asList(6));</span>

<span class="fc" id="L404">        inOrder.verify(subscriber).onComplete();</span>

<span class="fc" id="L406">        verify(subscriber, never()).onError(any(Throwable.class));</span>
<span class="fc" id="L407">    }</span>

    @Test
    public void bufferWithBOEmptyLastViaBoundary() {
<span class="fc" id="L411">        PublishProcessor&lt;Integer&gt; source = PublishProcessor.create();</span>
<span class="fc" id="L412">        PublishProcessor&lt;Integer&gt; boundary = PublishProcessor.create();</span>

<span class="fc" id="L414">        Subscriber&lt;Object&gt; subscriber = TestHelper.mockSubscriber();</span>
<span class="fc" id="L415">        InOrder inOrder = Mockito.inOrder(subscriber);</span>

<span class="fc" id="L417">        source.buffer(boundary).subscribe(subscriber);</span>

<span class="fc" id="L419">        boundary.onComplete();</span>

<span class="fc" id="L421">        inOrder.verify(subscriber, times(1)).onNext(Arrays.asList());</span>

<span class="fc" id="L423">        inOrder.verify(subscriber).onComplete();</span>

<span class="fc" id="L425">        verify(subscriber, never()).onError(any(Throwable.class));</span>
<span class="fc" id="L426">    }</span>

    @Test
    public void bufferWithBOEmptyLastViaSource() {
<span class="fc" id="L430">        PublishProcessor&lt;Integer&gt; source = PublishProcessor.create();</span>
<span class="fc" id="L431">        PublishProcessor&lt;Integer&gt; boundary = PublishProcessor.create();</span>

<span class="fc" id="L433">        Subscriber&lt;Object&gt; subscriber = TestHelper.mockSubscriber();</span>
<span class="fc" id="L434">        InOrder inOrder = Mockito.inOrder(subscriber);</span>

<span class="fc" id="L436">        source.buffer(boundary).subscribe(subscriber);</span>

<span class="fc" id="L438">        source.onComplete();</span>

<span class="fc" id="L440">        inOrder.verify(subscriber, times(1)).onNext(Arrays.asList());</span>

<span class="fc" id="L442">        inOrder.verify(subscriber).onComplete();</span>

<span class="fc" id="L444">        verify(subscriber, never()).onError(any(Throwable.class));</span>
<span class="fc" id="L445">    }</span>

    @Test
    public void bufferWithBOEmptyLastViaBoth() {
<span class="fc" id="L449">        PublishProcessor&lt;Integer&gt; source = PublishProcessor.create();</span>
<span class="fc" id="L450">        PublishProcessor&lt;Integer&gt; boundary = PublishProcessor.create();</span>

<span class="fc" id="L452">        Subscriber&lt;Object&gt; subscriber = TestHelper.mockSubscriber();</span>
<span class="fc" id="L453">        InOrder inOrder = Mockito.inOrder(subscriber);</span>

<span class="fc" id="L455">        source.buffer(boundary).subscribe(subscriber);</span>

<span class="fc" id="L457">        source.onComplete();</span>
<span class="fc" id="L458">        boundary.onComplete();</span>

<span class="fc" id="L460">        inOrder.verify(subscriber, times(1)).onNext(Arrays.asList());</span>

<span class="fc" id="L462">        inOrder.verify(subscriber).onComplete();</span>

<span class="fc" id="L464">        verify(subscriber, never()).onError(any(Throwable.class));</span>
<span class="fc" id="L465">    }</span>

    @Test
    public void bufferWithBOSourceThrows() {
<span class="fc" id="L469">        PublishProcessor&lt;Integer&gt; source = PublishProcessor.create();</span>
<span class="fc" id="L470">        PublishProcessor&lt;Integer&gt; boundary = PublishProcessor.create();</span>

<span class="fc" id="L472">        Subscriber&lt;Object&gt; subscriber = TestHelper.mockSubscriber();</span>

<span class="fc" id="L474">        source.buffer(boundary).subscribe(subscriber);</span>
<span class="fc" id="L475">        source.onNext(1);</span>
<span class="fc" id="L476">        source.onError(new TestException());</span>

<span class="fc" id="L478">        verify(subscriber).onError(any(TestException.class));</span>
<span class="fc" id="L479">        verify(subscriber, never()).onComplete();</span>
<span class="fc" id="L480">        verify(subscriber, never()).onNext(any());</span>
<span class="fc" id="L481">    }</span>

    @Test
    public void bufferWithBOBoundaryThrows() {
<span class="fc" id="L485">        PublishProcessor&lt;Integer&gt; source = PublishProcessor.create();</span>
<span class="fc" id="L486">        PublishProcessor&lt;Integer&gt; boundary = PublishProcessor.create();</span>

<span class="fc" id="L488">        Subscriber&lt;Object&gt; subscriber = TestHelper.mockSubscriber();</span>

<span class="fc" id="L490">        source.buffer(boundary).subscribe(subscriber);</span>

<span class="fc" id="L492">        source.onNext(1);</span>
<span class="fc" id="L493">        boundary.onError(new TestException());</span>

<span class="fc" id="L495">        verify(subscriber).onError(any(TestException.class));</span>
<span class="fc" id="L496">        verify(subscriber, never()).onComplete();</span>
<span class="fc" id="L497">        verify(subscriber, never()).onNext(any());</span>
<span class="fc" id="L498">    }</span>

    @Test(timeout = 2000)
    public void bufferWithSizeTake1() {
<span class="fc" id="L502">        Flowable&lt;Integer&gt; source = Flowable.just(1).repeat();</span>

<span class="fc" id="L504">        Flowable&lt;List&lt;Integer&gt;&gt; result = source.buffer(2).take(1);</span>

<span class="fc" id="L506">        Subscriber&lt;Object&gt; subscriber = TestHelper.mockSubscriber();</span>

<span class="fc" id="L508">        result.subscribe(subscriber);</span>

<span class="fc" id="L510">        verify(subscriber).onNext(Arrays.asList(1, 1));</span>
<span class="fc" id="L511">        verify(subscriber).onComplete();</span>
<span class="fc" id="L512">        verify(subscriber, never()).onError(any(Throwable.class));</span>
<span class="fc" id="L513">    }</span>

    @Test(timeout = 2000)
    public void bufferWithSizeSkipTake1() {
<span class="fc" id="L517">        Flowable&lt;Integer&gt; source = Flowable.just(1).repeat();</span>

<span class="fc" id="L519">        Flowable&lt;List&lt;Integer&gt;&gt; result = source.buffer(2, 3).take(1);</span>

<span class="fc" id="L521">        Subscriber&lt;Object&gt; subscriber = TestHelper.mockSubscriber();</span>

<span class="fc" id="L523">        result.subscribe(subscriber);</span>

<span class="fc" id="L525">        verify(subscriber).onNext(Arrays.asList(1, 1));</span>
<span class="fc" id="L526">        verify(subscriber).onComplete();</span>
<span class="fc" id="L527">        verify(subscriber, never()).onError(any(Throwable.class));</span>
<span class="fc" id="L528">    }</span>

    @Test(timeout = 2000)
    public void bufferWithTimeTake1() {
<span class="fc" id="L532">        Flowable&lt;Long&gt; source = Flowable.interval(40, 40, TimeUnit.MILLISECONDS, scheduler);</span>

<span class="fc" id="L534">        Flowable&lt;List&lt;Long&gt;&gt; result = source.buffer(100, TimeUnit.MILLISECONDS, scheduler).take(1);</span>

<span class="fc" id="L536">        Subscriber&lt;Object&gt; subscriber = TestHelper.mockSubscriber();</span>

<span class="fc" id="L538">        result.subscribe(subscriber);</span>

<span class="fc" id="L540">        scheduler.advanceTimeBy(5, TimeUnit.SECONDS);</span>

<span class="fc" id="L542">        verify(subscriber).onNext(Arrays.asList(0L, 1L));</span>
<span class="fc" id="L543">        verify(subscriber).onComplete();</span>
<span class="fc" id="L544">        verify(subscriber, never()).onError(any(Throwable.class));</span>
<span class="fc" id="L545">    }</span>

    @Test(timeout = 2000)
    public void bufferWithTimeSkipTake2() {
<span class="fc" id="L549">        Flowable&lt;Long&gt; source = Flowable.interval(40, 40, TimeUnit.MILLISECONDS, scheduler);</span>

<span class="fc" id="L551">        Flowable&lt;List&lt;Long&gt;&gt; result = source.buffer(100, 60, TimeUnit.MILLISECONDS, scheduler).take(2);</span>

<span class="fc" id="L553">        Subscriber&lt;Object&gt; subscriber = TestHelper.mockSubscriber();</span>
<span class="fc" id="L554">        InOrder inOrder = inOrder(subscriber);</span>

<span class="fc" id="L556">        result.subscribe(subscriber);</span>

<span class="fc" id="L558">        scheduler.advanceTimeBy(5, TimeUnit.SECONDS);</span>

<span class="fc" id="L560">        inOrder.verify(subscriber).onNext(Arrays.asList(0L, 1L));</span>
<span class="fc" id="L561">        inOrder.verify(subscriber).onNext(Arrays.asList(1L, 2L));</span>
<span class="fc" id="L562">        inOrder.verify(subscriber).onComplete();</span>
<span class="fc" id="L563">        verify(subscriber, never()).onError(any(Throwable.class));</span>
<span class="fc" id="L564">    }</span>

    @Test(timeout = 2000)
    public void bufferWithBoundaryTake2() {
<span class="fc" id="L568">        Flowable&lt;Long&gt; boundary = Flowable.interval(60, 60, TimeUnit.MILLISECONDS, scheduler);</span>
<span class="fc" id="L569">        Flowable&lt;Long&gt; source = Flowable.interval(40, 40, TimeUnit.MILLISECONDS, scheduler);</span>

<span class="fc" id="L571">        Flowable&lt;List&lt;Long&gt;&gt; result = source.buffer(boundary).take(2);</span>

<span class="fc" id="L573">        Subscriber&lt;Object&gt; subscriber = TestHelper.mockSubscriber();</span>
<span class="fc" id="L574">        InOrder inOrder = inOrder(subscriber);</span>

<span class="fc" id="L576">        result.subscribe(subscriber);</span>

<span class="fc" id="L578">        scheduler.advanceTimeBy(5, TimeUnit.SECONDS);</span>

<span class="fc" id="L580">        inOrder.verify(subscriber).onNext(Arrays.asList(0L));</span>
<span class="fc" id="L581">        inOrder.verify(subscriber).onNext(Arrays.asList(1L));</span>
<span class="fc" id="L582">        inOrder.verify(subscriber).onComplete();</span>
<span class="fc" id="L583">        verify(subscriber, never()).onError(any(Throwable.class));</span>

<span class="fc" id="L585">    }</span>

    @Test(timeout = 2000)
    public void bufferWithStartEndBoundaryTake2() {
<span class="fc" id="L589">        Flowable&lt;Long&gt; start = Flowable.interval(61, 61, TimeUnit.MILLISECONDS, scheduler);</span>
<span class="fc" id="L590">        Function&lt;Long, Flowable&lt;Long&gt;&gt; end = new Function&lt;Long, Flowable&lt;Long&gt;&gt;() {</span>
            @Override
            public Flowable&lt;Long&gt; apply(Long t1) {
<span class="fc" id="L593">                return Flowable.interval(100, 100, TimeUnit.MILLISECONDS, scheduler);</span>
            }
        };

<span class="fc" id="L597">        Flowable&lt;Long&gt; source = Flowable.interval(40, 40, TimeUnit.MILLISECONDS, scheduler);</span>

<span class="fc" id="L599">        Flowable&lt;List&lt;Long&gt;&gt; result = source.buffer(start, end).take(2);</span>

<span class="fc" id="L601">        Subscriber&lt;Object&gt; subscriber = TestHelper.mockSubscriber();</span>
<span class="fc" id="L602">        InOrder inOrder = inOrder(subscriber);</span>

<span class="fc" id="L604">        result</span>
<span class="fc" id="L605">        .doOnNext(new Consumer&lt;List&lt;Long&gt;&gt;() {</span>
            @Override
            public void accept(List&lt;Long&gt; pv) {
<span class="fc" id="L608">                System.out.println(pv);</span>
<span class="fc" id="L609">            }</span>
        })
<span class="fc" id="L611">        .subscribe(subscriber);</span>

<span class="fc" id="L613">        scheduler.advanceTimeBy(5, TimeUnit.SECONDS);</span>

<span class="fc" id="L615">        inOrder.verify(subscriber).onNext(Arrays.asList(1L, 2L, 3L));</span>
<span class="fc" id="L616">        inOrder.verify(subscriber).onNext(Arrays.asList(3L, 4L));</span>
<span class="fc" id="L617">        inOrder.verify(subscriber).onComplete();</span>
<span class="fc" id="L618">        verify(subscriber, never()).onError(any(Throwable.class));</span>
<span class="fc" id="L619">    }</span>

    @Test
    public void bufferWithSizeThrows() {
<span class="fc" id="L623">        PublishProcessor&lt;Integer&gt; source = PublishProcessor.create();</span>

<span class="fc" id="L625">        Flowable&lt;List&lt;Integer&gt;&gt; result = source.buffer(2);</span>

<span class="fc" id="L627">        Subscriber&lt;Object&gt; subscriber = TestHelper.mockSubscriber();</span>

<span class="fc" id="L629">        InOrder inOrder = inOrder(subscriber);</span>

<span class="fc" id="L631">        result.subscribe(subscriber);</span>

<span class="fc" id="L633">        source.onNext(1);</span>
<span class="fc" id="L634">        source.onNext(2);</span>
<span class="fc" id="L635">        source.onNext(3);</span>
<span class="fc" id="L636">        source.onError(new TestException());</span>

<span class="fc" id="L638">        inOrder.verify(subscriber).onNext(Arrays.asList(1, 2));</span>
<span class="fc" id="L639">        inOrder.verify(subscriber).onError(any(TestException.class));</span>
<span class="fc" id="L640">        inOrder.verifyNoMoreInteractions();</span>
<span class="fc" id="L641">        verify(subscriber, never()).onNext(Arrays.asList(3));</span>
<span class="fc" id="L642">        verify(subscriber, never()).onComplete();</span>

<span class="fc" id="L644">    }</span>

    @Test
    public void bufferWithTimeThrows() {
<span class="fc" id="L648">        PublishProcessor&lt;Integer&gt; source = PublishProcessor.create();</span>

<span class="fc" id="L650">        Flowable&lt;List&lt;Integer&gt;&gt; result = source.buffer(100, TimeUnit.MILLISECONDS, scheduler);</span>

<span class="fc" id="L652">        Subscriber&lt;Object&gt; subscriber = TestHelper.mockSubscriber();</span>
<span class="fc" id="L653">        InOrder inOrder = inOrder(subscriber);</span>

<span class="fc" id="L655">        result.subscribe(subscriber);</span>

<span class="fc" id="L657">        source.onNext(1);</span>
<span class="fc" id="L658">        source.onNext(2);</span>
<span class="fc" id="L659">        scheduler.advanceTimeBy(100, TimeUnit.MILLISECONDS);</span>
<span class="fc" id="L660">        source.onNext(3);</span>
<span class="fc" id="L661">        source.onError(new TestException());</span>
<span class="fc" id="L662">        scheduler.advanceTimeBy(100, TimeUnit.MILLISECONDS);</span>

<span class="fc" id="L664">        inOrder.verify(subscriber).onNext(Arrays.asList(1, 2));</span>
<span class="fc" id="L665">        inOrder.verify(subscriber).onError(any(TestException.class));</span>
<span class="fc" id="L666">        inOrder.verifyNoMoreInteractions();</span>
<span class="fc" id="L667">        verify(subscriber, never()).onNext(Arrays.asList(3));</span>
<span class="fc" id="L668">        verify(subscriber, never()).onComplete();</span>

<span class="fc" id="L670">    }</span>

    @Test
    public void bufferWithTimeAndSize() {
<span class="fc" id="L674">        Flowable&lt;Long&gt; source = Flowable.interval(30, 30, TimeUnit.MILLISECONDS, scheduler);</span>

<span class="fc" id="L676">        Flowable&lt;List&lt;Long&gt;&gt; result = source.buffer(100, TimeUnit.MILLISECONDS, scheduler, 2).take(3);</span>

<span class="fc" id="L678">        Subscriber&lt;Object&gt; subscriber = TestHelper.mockSubscriber();</span>
<span class="fc" id="L679">        InOrder inOrder = inOrder(subscriber);</span>

<span class="fc" id="L681">        result.subscribe(subscriber);</span>

<span class="fc" id="L683">        scheduler.advanceTimeBy(5, TimeUnit.SECONDS);</span>

<span class="fc" id="L685">        inOrder.verify(subscriber).onNext(Arrays.asList(0L, 1L));</span>
<span class="fc" id="L686">        inOrder.verify(subscriber).onNext(Arrays.asList(2L));</span>
<span class="fc" id="L687">        inOrder.verify(subscriber).onComplete();</span>
<span class="fc" id="L688">        verify(subscriber, never()).onError(any(Throwable.class));</span>
<span class="fc" id="L689">    }</span>

    @Test
    public void bufferWithStartEndStartThrows() {
<span class="fc" id="L693">        PublishProcessor&lt;Integer&gt; start = PublishProcessor.create();</span>

<span class="fc" id="L695">        Function&lt;Integer, Flowable&lt;Integer&gt;&gt; end = new Function&lt;Integer, Flowable&lt;Integer&gt;&gt;() {</span>
            @Override
            public Flowable&lt;Integer&gt; apply(Integer t1) {
<span class="fc" id="L698">                return Flowable.never();</span>
            }
        };

<span class="fc" id="L702">        PublishProcessor&lt;Integer&gt; source = PublishProcessor.create();</span>

<span class="fc" id="L704">        Flowable&lt;List&lt;Integer&gt;&gt; result = source.buffer(start, end);</span>

<span class="fc" id="L706">        Subscriber&lt;Object&gt; subscriber = TestHelper.mockSubscriber();</span>

<span class="fc" id="L708">        result.subscribe(subscriber);</span>

<span class="fc" id="L710">        start.onNext(1);</span>
<span class="fc" id="L711">        source.onNext(1);</span>
<span class="fc" id="L712">        source.onNext(2);</span>
<span class="fc" id="L713">        start.onError(new TestException());</span>

<span class="fc" id="L715">        verify(subscriber, never()).onNext(any());</span>
<span class="fc" id="L716">        verify(subscriber, never()).onComplete();</span>
<span class="fc" id="L717">        verify(subscriber).onError(any(TestException.class));</span>
<span class="fc" id="L718">    }</span>

    @Test
    public void bufferWithStartEndEndFunctionThrows() {
<span class="fc" id="L722">        PublishProcessor&lt;Integer&gt; start = PublishProcessor.create();</span>

<span class="fc" id="L724">        Function&lt;Integer, Flowable&lt;Integer&gt;&gt; end = new Function&lt;Integer, Flowable&lt;Integer&gt;&gt;() {</span>
            @Override
            public Flowable&lt;Integer&gt; apply(Integer t1) {
<span class="fc" id="L727">                throw new TestException();</span>
            }
        };

<span class="fc" id="L731">        PublishProcessor&lt;Integer&gt; source = PublishProcessor.create();</span>

<span class="fc" id="L733">        Flowable&lt;List&lt;Integer&gt;&gt; result = source.buffer(start, end);</span>

<span class="fc" id="L735">        Subscriber&lt;Object&gt; subscriber = TestHelper.mockSubscriber();</span>

<span class="fc" id="L737">        result.subscribe(subscriber);</span>

<span class="fc" id="L739">        start.onNext(1);</span>
<span class="fc" id="L740">        source.onNext(1);</span>
<span class="fc" id="L741">        source.onNext(2);</span>

<span class="fc" id="L743">        verify(subscriber, never()).onNext(any());</span>
<span class="fc" id="L744">        verify(subscriber, never()).onComplete();</span>
<span class="fc" id="L745">        verify(subscriber).onError(any(TestException.class));</span>
<span class="fc" id="L746">    }</span>

    @Test
    public void bufferWithStartEndEndThrows() {
<span class="fc" id="L750">        PublishProcessor&lt;Integer&gt; start = PublishProcessor.create();</span>

<span class="fc" id="L752">        Function&lt;Integer, Flowable&lt;Integer&gt;&gt; end = new Function&lt;Integer, Flowable&lt;Integer&gt;&gt;() {</span>
            @Override
            public Flowable&lt;Integer&gt; apply(Integer t1) {
<span class="fc" id="L755">                return Flowable.error(new TestException());</span>
            }
        };

<span class="fc" id="L759">        PublishProcessor&lt;Integer&gt; source = PublishProcessor.create();</span>

<span class="fc" id="L761">        Flowable&lt;List&lt;Integer&gt;&gt; result = source.buffer(start, end);</span>

<span class="fc" id="L763">        Subscriber&lt;Object&gt; subscriber = TestHelper.mockSubscriber();</span>

<span class="fc" id="L765">        result.subscribe(subscriber);</span>

<span class="fc" id="L767">        start.onNext(1);</span>
<span class="fc" id="L768">        source.onNext(1);</span>
<span class="fc" id="L769">        source.onNext(2);</span>

<span class="fc" id="L771">        verify(subscriber, never()).onNext(any());</span>
<span class="fc" id="L772">        verify(subscriber, never()).onComplete();</span>
<span class="fc" id="L773">        verify(subscriber).onError(any(TestException.class));</span>
<span class="fc" id="L774">    }</span>

    @Test
    public void testProducerRequestThroughBufferWithSize1() {
<span class="fc" id="L778">        TestSubscriber&lt;List&lt;Integer&gt;&gt; ts = new TestSubscriber&lt;List&lt;Integer&gt;&gt;(3L);</span>

<span class="fc" id="L780">        final AtomicLong requested = new AtomicLong();</span>
<span class="fc" id="L781">        Flowable.unsafeCreate(new Publisher&lt;Integer&gt;() {</span>

            @Override
            public void subscribe(Subscriber&lt;? super Integer&gt; s) {
<span class="fc" id="L785">                s.onSubscribe(new Subscription() {</span>

                    @Override
                    public void request(long n) {
<span class="fc" id="L789">                        requested.set(n);</span>
<span class="fc" id="L790">                    }</span>

                    @Override
                    public void cancel() {

<span class="nc" id="L795">                    }</span>

                });
<span class="fc" id="L798">            }</span>

<span class="fc" id="L800">        }).buffer(5, 5).subscribe(ts);</span>
<span class="fc" id="L801">        assertEquals(15, requested.get());</span>

<span class="fc" id="L803">        ts.request(4);</span>
<span class="fc" id="L804">        assertEquals(20, requested.get());</span>
<span class="fc" id="L805">    }</span>

    @Test
    public void testProducerRequestThroughBufferWithSize2() {
<span class="fc" id="L809">        TestSubscriber&lt;List&lt;Integer&gt;&gt; ts = new TestSubscriber&lt;List&lt;Integer&gt;&gt;();</span>
<span class="fc" id="L810">        final AtomicLong requested = new AtomicLong();</span>

<span class="fc" id="L812">        Flowable.unsafeCreate(new Publisher&lt;Integer&gt;() {</span>

            @Override
            public void subscribe(Subscriber&lt;? super Integer&gt; s) {
<span class="fc" id="L816">                s.onSubscribe(new Subscription() {</span>

                    @Override
                    public void request(long n) {
<span class="fc" id="L820">                        requested.set(n);</span>
<span class="fc" id="L821">                    }</span>

                    @Override
                    public void cancel() {

<span class="nc" id="L826">                    }</span>

                });
<span class="fc" id="L829">            }</span>

<span class="fc" id="L831">        }).buffer(5, 5).subscribe(ts);</span>
<span class="fc" id="L832">        assertEquals(Long.MAX_VALUE, requested.get());</span>
<span class="fc" id="L833">    }</span>

    @Test
    public void testProducerRequestThroughBufferWithSize3() {
<span class="fc" id="L837">        TestSubscriber&lt;List&lt;Integer&gt;&gt; ts = new TestSubscriber&lt;List&lt;Integer&gt;&gt;(3L);</span>
<span class="fc" id="L838">        final AtomicLong requested = new AtomicLong();</span>
<span class="fc" id="L839">        Flowable.unsafeCreate(new Publisher&lt;Integer&gt;() {</span>

            @Override
            public void subscribe(Subscriber&lt;? super Integer&gt; s) {
<span class="fc" id="L843">                s.onSubscribe(new Subscription() {</span>

                    @Override
                    public void request(long n) {
<span class="fc" id="L847">                        requested.set(n);</span>
<span class="fc" id="L848">                    }</span>

                    @Override
                    public void cancel() {

<span class="nc" id="L853">                    }</span>

                });
<span class="fc" id="L856">            }</span>

<span class="fc" id="L858">        }).buffer(5, 2).subscribe(ts);</span>
<span class="fc" id="L859">        assertEquals(9, requested.get());</span>
<span class="fc" id="L860">        ts.request(3);</span>
<span class="fc" id="L861">        assertEquals(6, requested.get());</span>
<span class="fc" id="L862">    }</span>

    @Test
    public void testProducerRequestThroughBufferWithSize4() {
<span class="fc" id="L866">        TestSubscriber&lt;List&lt;Integer&gt;&gt; ts = new TestSubscriber&lt;List&lt;Integer&gt;&gt;();</span>
<span class="fc" id="L867">        final AtomicLong requested = new AtomicLong();</span>
<span class="fc" id="L868">        Flowable.unsafeCreate(new Publisher&lt;Integer&gt;() {</span>

            @Override
            public void subscribe(Subscriber&lt;? super Integer&gt; s) {
<span class="fc" id="L872">                s.onSubscribe(new Subscription() {</span>

                    @Override
                    public void request(long n) {
<span class="fc" id="L876">                        requested.set(n);</span>
<span class="fc" id="L877">                    }</span>

                    @Override
                    public void cancel() {

<span class="nc" id="L882">                    }</span>

                });
<span class="fc" id="L885">            }</span>

<span class="fc" id="L887">        }).buffer(5, 2).subscribe(ts);</span>
<span class="fc" id="L888">        assertEquals(Long.MAX_VALUE, requested.get());</span>
<span class="fc" id="L889">    }</span>

    @Test
    public void testProducerRequestOverflowThroughBufferWithSize1() {
<span class="fc" id="L893">        TestSubscriber&lt;List&lt;Integer&gt;&gt; ts = new TestSubscriber&lt;List&lt;Integer&gt;&gt;(Long.MAX_VALUE &gt;&gt; 1);</span>

<span class="fc" id="L895">        final AtomicLong requested = new AtomicLong();</span>

<span class="fc" id="L897">        Flowable.unsafeCreate(new Publisher&lt;Integer&gt;() {</span>

            @Override
            public void subscribe(Subscriber&lt;? super Integer&gt; s) {
<span class="fc" id="L901">                s.onSubscribe(new Subscription() {</span>

                    @Override
                    public void request(long n) {
<span class="fc" id="L905">                        requested.set(n);</span>
<span class="fc" id="L906">                    }</span>

                    @Override
                    public void cancel() {

<span class="nc" id="L911">                    }</span>

                });
<span class="fc" id="L914">            }</span>

<span class="fc" id="L916">        }).buffer(3, 3).subscribe(ts);</span>
<span class="fc" id="L917">        assertEquals(Long.MAX_VALUE, requested.get());</span>
<span class="fc" id="L918">    }</span>

    @Test
    public void testProducerRequestOverflowThroughBufferWithSize2() {
<span class="fc" id="L922">        TestSubscriber&lt;List&lt;Integer&gt;&gt; ts = new TestSubscriber&lt;List&lt;Integer&gt;&gt;(Long.MAX_VALUE &gt;&gt; 1);</span>

<span class="fc" id="L924">        final AtomicLong requested = new AtomicLong();</span>

<span class="fc" id="L926">        Flowable.unsafeCreate(new Publisher&lt;Integer&gt;() {</span>

            @Override
            public void subscribe(Subscriber&lt;? super Integer&gt; s) {
<span class="fc" id="L930">                s.onSubscribe(new Subscription() {</span>

                    @Override
                    public void request(long n) {
<span class="fc" id="L934">                        requested.set(n);</span>
<span class="fc" id="L935">                    }</span>

                    @Override
                    public void cancel() {

<span class="nc" id="L940">                    }</span>

                });
<span class="fc" id="L943">            }</span>

<span class="fc" id="L945">        }).buffer(3, 2).subscribe(ts);</span>
<span class="fc" id="L946">        assertEquals(Long.MAX_VALUE, requested.get());</span>
<span class="fc" id="L947">    }</span>

    @Test
    public void testProducerRequestOverflowThroughBufferWithSize3() {
<span class="fc" id="L951">        final AtomicLong requested = new AtomicLong();</span>
<span class="fc" id="L952">        Flowable.unsafeCreate(new Publisher&lt;Integer&gt;() {</span>

            @Override
            public void subscribe(final Subscriber&lt;? super Integer&gt; s) {
<span class="fc" id="L956">                s.onSubscribe(new Subscription() {</span>
<span class="fc" id="L957">                    AtomicBoolean once = new AtomicBoolean();</span>
                    @Override
                    public void request(long n) {
<span class="fc" id="L960">                        requested.set(n);</span>
<span class="fc bfc" id="L961" title="All 2 branches covered.">                        if (once.compareAndSet(false, true)) {</span>
<span class="fc" id="L962">                            s.onNext(1);</span>
<span class="fc" id="L963">                            s.onNext(2);</span>
<span class="fc" id="L964">                            s.onNext(3);</span>
                        }
<span class="fc" id="L966">                    }</span>

                    @Override
                    public void cancel() {

<span class="nc" id="L971">                    }</span>

                });
<span class="fc" id="L974">            }</span>

<span class="fc" id="L976">        }).buffer(3, 2).subscribe(new DefaultSubscriber&lt;List&lt;Integer&gt;&gt;() {</span>

            @Override
            public void onStart() {
<span class="fc" id="L980">                request(Long.MAX_VALUE / 2 - 4);</span>
<span class="fc" id="L981">            }</span>

            @Override
            public void onComplete() {
<span class="nc" id="L985">            }</span>

            @Override
            public void onError(Throwable e) {
<span class="nc" id="L989">            }</span>

            @Override
            public void onNext(List&lt;Integer&gt; t) {
<span class="fc" id="L993">                request(Long.MAX_VALUE / 2);</span>
<span class="fc" id="L994">            }</span>

        });
        // FIXME I'm not sure why this is MAX_VALUE in 1.x because MAX_VALUE/2 is even and thus can't overflow when multiplied by 2
<span class="fc" id="L998">        assertEquals(Long.MAX_VALUE - 1, requested.get());</span>
<span class="fc" id="L999">    }</span>

    @Test(timeout = 3000)
    public void testBufferWithTimeDoesntUnsubscribeDownstream() throws InterruptedException {
<span class="fc" id="L1003">        final Subscriber&lt;Object&gt; subscriber = TestHelper.mockSubscriber();</span>

<span class="fc" id="L1005">        final CountDownLatch cdl = new CountDownLatch(1);</span>
<span class="fc" id="L1006">        ResourceSubscriber&lt;Object&gt; s = new ResourceSubscriber&lt;Object&gt;() {</span>
            @Override
            public void onNext(Object t) {
<span class="fc" id="L1009">                subscriber.onNext(t);</span>
<span class="fc" id="L1010">            }</span>

            @Override
            public void onError(Throwable e) {
<span class="nc" id="L1014">                subscriber.onError(e);</span>
<span class="nc" id="L1015">                cdl.countDown();</span>
<span class="nc" id="L1016">            }</span>

            @Override
            public void onComplete() {
<span class="fc" id="L1020">                subscriber.onComplete();</span>
<span class="fc" id="L1021">                cdl.countDown();</span>
<span class="fc" id="L1022">            }</span>
        };

<span class="fc" id="L1025">        Flowable.range(1, 1).delay(1, TimeUnit.SECONDS).buffer(2, TimeUnit.SECONDS).subscribe(s);</span>

<span class="fc" id="L1027">        cdl.await();</span>

<span class="fc" id="L1029">        verify(subscriber).onNext(Arrays.asList(1));</span>
<span class="fc" id="L1030">        verify(subscriber).onComplete();</span>
<span class="fc" id="L1031">        verify(subscriber, never()).onError(any(Throwable.class));</span>

<span class="fc" id="L1033">        assertFalse(s.isDisposed());</span>
<span class="fc" id="L1034">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void testPostCompleteBackpressure() {
<span class="fc" id="L1039">        Flowable&lt;List&lt;Integer&gt;&gt; source = Flowable.range(1, 10).buffer(3, 1);</span>

<span class="fc" id="L1041">        TestSubscriber&lt;List&lt;Integer&gt;&gt; ts = TestSubscriber.create(0L);</span>

<span class="fc" id="L1043">        source.subscribe(ts);</span>

<span class="fc" id="L1045">        ts.assertNoValues();</span>
<span class="fc" id="L1046">        ts.assertNotComplete();</span>
<span class="fc" id="L1047">        ts.assertNoErrors();</span>

<span class="fc" id="L1049">        ts.request(7);</span>

<span class="fc" id="L1051">        ts.assertValues(</span>
<span class="fc" id="L1052">                Arrays.asList(1, 2, 3),</span>
<span class="fc" id="L1053">                Arrays.asList(2, 3, 4),</span>
<span class="fc" id="L1054">                Arrays.asList(3, 4, 5),</span>
<span class="fc" id="L1055">                Arrays.asList(4, 5, 6),</span>
<span class="fc" id="L1056">                Arrays.asList(5, 6, 7),</span>
<span class="fc" id="L1057">                Arrays.asList(6, 7, 8),</span>
<span class="fc" id="L1058">                Arrays.asList(7, 8, 9)</span>
        );
<span class="fc" id="L1060">        ts.assertNotComplete();</span>
<span class="fc" id="L1061">        ts.assertNoErrors();</span>

<span class="fc" id="L1063">        ts.request(1);</span>

<span class="fc" id="L1065">        ts.assertValues(</span>
<span class="fc" id="L1066">                Arrays.asList(1, 2, 3),</span>
<span class="fc" id="L1067">                Arrays.asList(2, 3, 4),</span>
<span class="fc" id="L1068">                Arrays.asList(3, 4, 5),</span>
<span class="fc" id="L1069">                Arrays.asList(4, 5, 6),</span>
<span class="fc" id="L1070">                Arrays.asList(5, 6, 7),</span>
<span class="fc" id="L1071">                Arrays.asList(6, 7, 8),</span>
<span class="fc" id="L1072">                Arrays.asList(7, 8, 9),</span>
<span class="fc" id="L1073">                Arrays.asList(8, 9, 10)</span>
        );
<span class="fc" id="L1075">        ts.assertNotComplete();</span>
<span class="fc" id="L1076">        ts.assertNoErrors();</span>

<span class="fc" id="L1078">        ts.request(1);</span>

<span class="fc" id="L1080">        ts.assertValues(</span>
<span class="fc" id="L1081">                Arrays.asList(1, 2, 3),</span>
<span class="fc" id="L1082">                Arrays.asList(2, 3, 4),</span>
<span class="fc" id="L1083">                Arrays.asList(3, 4, 5),</span>
<span class="fc" id="L1084">                Arrays.asList(4, 5, 6),</span>
<span class="fc" id="L1085">                Arrays.asList(5, 6, 7),</span>
<span class="fc" id="L1086">                Arrays.asList(6, 7, 8),</span>
<span class="fc" id="L1087">                Arrays.asList(7, 8, 9),</span>
<span class="fc" id="L1088">                Arrays.asList(8, 9, 10),</span>
<span class="fc" id="L1089">                Arrays.asList(9, 10)</span>
        );
<span class="fc" id="L1091">        ts.assertNotComplete();</span>
<span class="fc" id="L1092">        ts.assertNoErrors();</span>

<span class="fc" id="L1094">        ts.request(1);</span>

<span class="fc" id="L1096">        ts.assertValues(</span>
<span class="fc" id="L1097">                Arrays.asList(1, 2, 3),</span>
<span class="fc" id="L1098">                Arrays.asList(2, 3, 4),</span>
<span class="fc" id="L1099">                Arrays.asList(3, 4, 5),</span>
<span class="fc" id="L1100">                Arrays.asList(4, 5, 6),</span>
<span class="fc" id="L1101">                Arrays.asList(5, 6, 7),</span>
<span class="fc" id="L1102">                Arrays.asList(6, 7, 8),</span>
<span class="fc" id="L1103">                Arrays.asList(7, 8, 9),</span>
<span class="fc" id="L1104">                Arrays.asList(8, 9, 10),</span>
<span class="fc" id="L1105">                Arrays.asList(9, 10),</span>
<span class="fc" id="L1106">                Arrays.asList(10)</span>
        );
<span class="fc" id="L1108">        ts.assertComplete();</span>
<span class="fc" id="L1109">        ts.assertNoErrors();</span>
<span class="fc" id="L1110">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void timeAndSkipOverlap() {

<span class="fc" id="L1116">        PublishProcessor&lt;Integer&gt; pp = PublishProcessor.create();</span>

<span class="fc" id="L1118">        TestSubscriber&lt;List&lt;Integer&gt;&gt; ts = TestSubscriber.create();</span>

<span class="fc" id="L1120">        pp.buffer(2, 1, TimeUnit.SECONDS, scheduler).subscribe(ts);</span>

<span class="fc" id="L1122">        pp.onNext(1);</span>

<span class="fc" id="L1124">        scheduler.advanceTimeBy(1, TimeUnit.SECONDS);</span>

<span class="fc" id="L1126">        pp.onNext(2);</span>

<span class="fc" id="L1128">        scheduler.advanceTimeBy(1, TimeUnit.SECONDS);</span>

<span class="fc" id="L1130">        pp.onNext(3);</span>

<span class="fc" id="L1132">        scheduler.advanceTimeBy(1, TimeUnit.SECONDS);</span>

<span class="fc" id="L1134">        pp.onNext(4);</span>

<span class="fc" id="L1136">        scheduler.advanceTimeBy(1, TimeUnit.SECONDS);</span>

<span class="fc" id="L1138">        pp.onComplete();</span>

<span class="fc" id="L1140">        ts.assertValues(</span>
<span class="fc" id="L1141">                Arrays.asList(1, 2),</span>
<span class="fc" id="L1142">                Arrays.asList(2, 3),</span>
<span class="fc" id="L1143">                Arrays.asList(3, 4),</span>
<span class="fc" id="L1144">                Arrays.asList(4),</span>
<span class="fc" id="L1145">                Collections.&lt;Integer&gt;emptyList()</span>
        );

<span class="fc" id="L1148">        ts.assertNoErrors();</span>
<span class="fc" id="L1149">        ts.assertComplete();</span>
<span class="fc" id="L1150">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void timeAndSkipSkip() {

<span class="fc" id="L1156">        PublishProcessor&lt;Integer&gt; pp = PublishProcessor.create();</span>

<span class="fc" id="L1158">        TestSubscriber&lt;List&lt;Integer&gt;&gt; ts = TestSubscriber.create();</span>

<span class="fc" id="L1160">        pp.buffer(2, 3, TimeUnit.SECONDS, scheduler).subscribe(ts);</span>

<span class="fc" id="L1162">        pp.onNext(1);</span>

<span class="fc" id="L1164">        scheduler.advanceTimeBy(1, TimeUnit.SECONDS);</span>

<span class="fc" id="L1166">        pp.onNext(2);</span>

<span class="fc" id="L1168">        scheduler.advanceTimeBy(1, TimeUnit.SECONDS);</span>

<span class="fc" id="L1170">        pp.onNext(3);</span>

<span class="fc" id="L1172">        scheduler.advanceTimeBy(1, TimeUnit.SECONDS);</span>

<span class="fc" id="L1174">        pp.onNext(4);</span>

<span class="fc" id="L1176">        scheduler.advanceTimeBy(1, TimeUnit.SECONDS);</span>

<span class="fc" id="L1178">        pp.onComplete();</span>

<span class="fc" id="L1180">        ts.assertValues(</span>
<span class="fc" id="L1181">                Arrays.asList(1, 2),</span>
<span class="fc" id="L1182">                Arrays.asList(4)</span>
        );

<span class="fc" id="L1185">        ts.assertNoErrors();</span>
<span class="fc" id="L1186">        ts.assertComplete();</span>
<span class="fc" id="L1187">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void timeAndSkipOverlapScheduler() {

<span class="fc" id="L1193">        RxJavaPlugins.setComputationSchedulerHandler(new Function&lt;Scheduler, Scheduler&gt;() {</span>
            @Override
            public Scheduler apply(Scheduler t) {
<span class="fc" id="L1196">                return scheduler;</span>
            }
        });

        try {
<span class="fc" id="L1201">            PublishProcessor&lt;Integer&gt; pp = PublishProcessor.create();</span>

<span class="fc" id="L1203">            TestSubscriber&lt;List&lt;Integer&gt;&gt; ts = TestSubscriber.create();</span>

<span class="fc" id="L1205">            pp.buffer(2, 1, TimeUnit.SECONDS).subscribe(ts);</span>

<span class="fc" id="L1207">            pp.onNext(1);</span>

<span class="fc" id="L1209">            scheduler.advanceTimeBy(1, TimeUnit.SECONDS);</span>

<span class="fc" id="L1211">            pp.onNext(2);</span>

<span class="fc" id="L1213">            scheduler.advanceTimeBy(1, TimeUnit.SECONDS);</span>

<span class="fc" id="L1215">            pp.onNext(3);</span>

<span class="fc" id="L1217">            scheduler.advanceTimeBy(1, TimeUnit.SECONDS);</span>

<span class="fc" id="L1219">            pp.onNext(4);</span>

<span class="fc" id="L1221">            scheduler.advanceTimeBy(1, TimeUnit.SECONDS);</span>

<span class="fc" id="L1223">            pp.onComplete();</span>

<span class="fc" id="L1225">            ts.assertValues(</span>
<span class="fc" id="L1226">                    Arrays.asList(1, 2),</span>
<span class="fc" id="L1227">                    Arrays.asList(2, 3),</span>
<span class="fc" id="L1228">                    Arrays.asList(3, 4),</span>
<span class="fc" id="L1229">                    Arrays.asList(4),</span>
<span class="fc" id="L1230">                    Collections.&lt;Integer&gt;emptyList()</span>
            );

<span class="fc" id="L1233">            ts.assertNoErrors();</span>
<span class="fc" id="L1234">            ts.assertComplete();</span>
        } finally {
<span class="fc" id="L1236">            RxJavaPlugins.reset();</span>
        }
<span class="fc" id="L1238">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void timeAndSkipSkipDefaultScheduler() {
<span class="fc" id="L1243">        RxJavaPlugins.setComputationSchedulerHandler(new Function&lt;Scheduler, Scheduler&gt;() {</span>
            @Override
            public Scheduler apply(Scheduler t) {
<span class="fc" id="L1246">                return scheduler;</span>
            }
        });

        try {

<span class="fc" id="L1252">            PublishProcessor&lt;Integer&gt; pp = PublishProcessor.create();</span>

<span class="fc" id="L1254">            TestSubscriber&lt;List&lt;Integer&gt;&gt; ts = TestSubscriber.create();</span>

<span class="fc" id="L1256">            pp.buffer(2, 3, TimeUnit.SECONDS).subscribe(ts);</span>

<span class="fc" id="L1258">            pp.onNext(1);</span>

<span class="fc" id="L1260">            scheduler.advanceTimeBy(1, TimeUnit.SECONDS);</span>

<span class="fc" id="L1262">            pp.onNext(2);</span>

<span class="fc" id="L1264">            scheduler.advanceTimeBy(1, TimeUnit.SECONDS);</span>

<span class="fc" id="L1266">            pp.onNext(3);</span>

<span class="fc" id="L1268">            scheduler.advanceTimeBy(1, TimeUnit.SECONDS);</span>

<span class="fc" id="L1270">            pp.onNext(4);</span>

<span class="fc" id="L1272">            scheduler.advanceTimeBy(1, TimeUnit.SECONDS);</span>

<span class="fc" id="L1274">            pp.onComplete();</span>

<span class="fc" id="L1276">            ts.assertValues(</span>
<span class="fc" id="L1277">                    Arrays.asList(1, 2),</span>
<span class="fc" id="L1278">                    Arrays.asList(4)</span>
            );

<span class="fc" id="L1281">            ts.assertNoErrors();</span>
<span class="fc" id="L1282">            ts.assertComplete();</span>
        } finally {
<span class="fc" id="L1284">            RxJavaPlugins.reset();</span>
        }
<span class="fc" id="L1286">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void bufferBoundaryHint() {
<span class="fc" id="L1291">        Flowable.range(1, 5).buffer(Flowable.timer(1, TimeUnit.MINUTES), 2)</span>
<span class="fc" id="L1292">        .test()</span>
<span class="fc" id="L1293">        .assertResult(Arrays.asList(1, 2, 3, 4, 5));</span>
<span class="fc" id="L1294">    }</span>

    static HashSet&lt;Integer&gt; set(Integer... values) {
<span class="fc" id="L1297">        return new HashSet&lt;Integer&gt;(Arrays.asList(values));</span>
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void bufferIntoCustomCollection() {
<span class="fc" id="L1303">        Flowable.just(1, 1, 2, 2, 3, 3, 4, 4)</span>
<span class="fc" id="L1304">        .buffer(3, new Callable&lt;Collection&lt;Integer&gt;&gt;() {</span>
            @Override
            public Collection&lt;Integer&gt; call() throws Exception {
<span class="fc" id="L1307">                return new HashSet&lt;Integer&gt;();</span>
            }
        })
<span class="fc" id="L1310">        .test()</span>
<span class="fc" id="L1311">        .assertResult(set(1, 2), set(2, 3), set(4));</span>
<span class="fc" id="L1312">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void bufferSkipIntoCustomCollection() {
<span class="fc" id="L1317">        Flowable.just(1, 1, 2, 2, 3, 3, 4, 4)</span>
<span class="fc" id="L1318">        .buffer(3, 3, new Callable&lt;Collection&lt;Integer&gt;&gt;() {</span>
            @Override
            public Collection&lt;Integer&gt; call() throws Exception {
<span class="fc" id="L1321">                return new HashSet&lt;Integer&gt;();</span>
            }
        })
<span class="fc" id="L1324">        .test()</span>
<span class="fc" id="L1325">        .assertResult(set(1, 2), set(2, 3), set(4));</span>
<span class="fc" id="L1326">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void bufferTimeSkipDefault() {
<span class="fc" id="L1331">        Flowable.range(1, 5).buffer(1, 1, TimeUnit.MINUTES)</span>
<span class="fc" id="L1332">        .test()</span>
<span class="fc" id="L1333">        .assertResult(Arrays.asList(1, 2, 3, 4, 5));</span>
<span class="fc" id="L1334">    }</span>

    @Test
    @SuppressWarnings(&quot;unchecked&quot;)
    public void boundaryBufferSupplierThrows() {
<span class="fc" id="L1339">        Flowable.never()</span>
<span class="fc" id="L1340">        .buffer(Functions.justCallable(Flowable.never()), new Callable&lt;Collection&lt;Object&gt;&gt;() {</span>
            @Override
            public Collection&lt;Object&gt; call() throws Exception {
<span class="fc" id="L1343">                throw new TestException();</span>
            }
        })
<span class="fc" id="L1346">        .test()</span>
<span class="fc" id="L1347">        .assertFailure(TestException.class);</span>
<span class="fc" id="L1348">    }</span>

    @Test
    @SuppressWarnings(&quot;unchecked&quot;)
    public void boundaryBoundarySupplierThrows() {
<span class="fc" id="L1353">        Flowable.never()</span>
<span class="fc" id="L1354">        .buffer(new Callable&lt;Publisher&lt;Object&gt;&gt;() {</span>
            @Override
            public Publisher&lt;Object&gt; call() throws Exception {
<span class="fc" id="L1357">                throw new TestException();</span>
            }
<span class="fc" id="L1359">        }, new Callable&lt;Collection&lt;Object&gt;&gt;() {</span>
            @Override
            public Collection&lt;Object&gt; call() throws Exception {
<span class="fc" id="L1362">                return new ArrayList&lt;Object&gt;();</span>
            }
        })
<span class="fc" id="L1365">        .test()</span>
<span class="fc" id="L1366">        .assertFailure(TestException.class);</span>
<span class="fc" id="L1367">    }</span>

    @Test
    @SuppressWarnings(&quot;unchecked&quot;)
    public void boundaryBufferSupplierThrows2() {
<span class="fc" id="L1372">        Flowable.never()</span>
<span class="fc" id="L1373">        .buffer(Functions.justCallable(Flowable.timer(1, TimeUnit.MILLISECONDS)), new Callable&lt;Collection&lt;Object&gt;&gt;() {</span>
            int count;
            @Override
            public Collection&lt;Object&gt; call() throws Exception {
<span class="fc bfc" id="L1377" title="All 2 branches covered.">                if (count++ == 1) {</span>
<span class="fc" id="L1378">                    throw new TestException();</span>
                } else {
<span class="fc" id="L1380">                    return new ArrayList&lt;Object&gt;();</span>
                }
            }
        })
<span class="fc" id="L1384">        .test()</span>
<span class="fc" id="L1385">        .awaitDone(5, TimeUnit.SECONDS)</span>
<span class="fc" id="L1386">        .assertFailure(TestException.class);</span>
<span class="fc" id="L1387">    }</span>

    @Test
    @SuppressWarnings(&quot;unchecked&quot;)
    public void boundaryBufferSupplierReturnsNull() {
<span class="fc" id="L1392">        Flowable.never()</span>
<span class="fc" id="L1393">        .buffer(Functions.justCallable(Flowable.timer(1, TimeUnit.MILLISECONDS)), new Callable&lt;Collection&lt;Object&gt;&gt;() {</span>
            int count;
            @Override
            public Collection&lt;Object&gt; call() throws Exception {
<span class="fc bfc" id="L1397" title="All 2 branches covered.">                if (count++ == 1) {</span>
<span class="fc" id="L1398">                    return null;</span>
                } else {
<span class="fc" id="L1400">                    return new ArrayList&lt;Object&gt;();</span>
                }
            }
        })
<span class="fc" id="L1404">        .test()</span>
<span class="fc" id="L1405">        .awaitDone(5, TimeUnit.SECONDS)</span>
<span class="fc" id="L1406">        .assertFailure(NullPointerException.class);</span>
<span class="fc" id="L1407">    }</span>

    @Test
    @SuppressWarnings(&quot;unchecked&quot;)
    public void boundaryBoundarySupplierThrows2() {
<span class="fc" id="L1412">        Flowable.never()</span>
<span class="fc" id="L1413">        .buffer(new Callable&lt;Publisher&lt;Long&gt;&gt;() {</span>
            int count;
            @Override
            public Publisher&lt;Long&gt; call() throws Exception {
<span class="fc bfc" id="L1417" title="All 2 branches covered.">                if (count++ == 1) {</span>
<span class="fc" id="L1418">                    throw new TestException();</span>
                }
<span class="fc" id="L1420">                return Flowable.timer(1, TimeUnit.MILLISECONDS);</span>
            }
<span class="fc" id="L1422">        }, new Callable&lt;Collection&lt;Object&gt;&gt;() {</span>
            @Override
            public Collection&lt;Object&gt; call() throws Exception {
<span class="fc" id="L1425">                return new ArrayList&lt;Object&gt;();</span>
            }
        })
<span class="fc" id="L1428">        .test()</span>
<span class="fc" id="L1429">        .awaitDone(5, TimeUnit.SECONDS)</span>
<span class="fc" id="L1430">        .assertFailure(TestException.class);</span>
<span class="fc" id="L1431">    }</span>

    @Test
    public void boundaryCancel() {
<span class="fc" id="L1435">        PublishProcessor&lt;Object&gt; pp = PublishProcessor.create();</span>

<span class="fc" id="L1437">        TestSubscriber&lt;Collection&lt;Object&gt;&gt; ts = pp</span>
<span class="fc" id="L1438">        .buffer(Functions.justCallable(Flowable.never()), new Callable&lt;Collection&lt;Object&gt;&gt;() {</span>
            @Override
            public Collection&lt;Object&gt; call() throws Exception {
<span class="fc" id="L1441">                return new ArrayList&lt;Object&gt;();</span>
            }
        })
<span class="fc" id="L1444">        .test();</span>

<span class="fc" id="L1446">        assertTrue(pp.hasSubscribers());</span>

<span class="fc" id="L1448">        ts.dispose();</span>

<span class="fc" id="L1450">        assertFalse(pp.hasSubscribers());</span>
<span class="fc" id="L1451">    }</span>

    @Test
    @SuppressWarnings(&quot;unchecked&quot;)
    public void boundaryBoundarySupplierReturnsNull() {
<span class="fc" id="L1456">        Flowable.never()</span>
<span class="fc" id="L1457">        .buffer(new Callable&lt;Publisher&lt;Long&gt;&gt;() {</span>
            int count;
            @Override
            public Publisher&lt;Long&gt; call() throws Exception {
<span class="fc bfc" id="L1461" title="All 2 branches covered.">                if (count++ == 1) {</span>
<span class="fc" id="L1462">                    return null;</span>
                }
<span class="fc" id="L1464">                return Flowable.timer(1, TimeUnit.MILLISECONDS);</span>
            }
<span class="fc" id="L1466">        }, new Callable&lt;Collection&lt;Object&gt;&gt;() {</span>
            @Override
            public Collection&lt;Object&gt; call() throws Exception {
<span class="fc" id="L1469">                return new ArrayList&lt;Object&gt;();</span>
            }
        })
<span class="fc" id="L1472">        .test()</span>
<span class="fc" id="L1473">        .awaitDone(5, TimeUnit.SECONDS)</span>
<span class="fc" id="L1474">        .assertFailure(NullPointerException.class);</span>
<span class="fc" id="L1475">    }</span>

    @Test
    @SuppressWarnings(&quot;unchecked&quot;)
    public void boundaryBoundarySupplierReturnsNull2() {
<span class="fc" id="L1480">        Flowable.never()</span>
<span class="fc" id="L1481">        .buffer(new Callable&lt;Publisher&lt;Long&gt;&gt;() {</span>
            int count;
            @Override
            public Publisher&lt;Long&gt; call() throws Exception {
<span class="fc bfc" id="L1485" title="All 2 branches covered.">                if (count++ == 1) {</span>
<span class="fc" id="L1486">                    return null;</span>
                }
<span class="fc" id="L1488">                return Flowable.empty();</span>
            }
<span class="fc" id="L1490">        }, new Callable&lt;Collection&lt;Object&gt;&gt;() {</span>
            @Override
            public Collection&lt;Object&gt; call() throws Exception {
<span class="fc" id="L1493">                return new ArrayList&lt;Object&gt;();</span>
            }
        })
<span class="fc" id="L1496">        .test()</span>
<span class="fc" id="L1497">        .awaitDone(5, TimeUnit.SECONDS)</span>
<span class="fc" id="L1498">        .assertFailure(NullPointerException.class);</span>
<span class="fc" id="L1499">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void boundaryMainError() {
<span class="fc" id="L1504">        PublishProcessor&lt;Object&gt; pp = PublishProcessor.create();</span>

<span class="fc" id="L1506">        TestSubscriber&lt;Collection&lt;Object&gt;&gt; ts = pp</span>
<span class="fc" id="L1507">        .buffer(Functions.justCallable(Flowable.never()), new Callable&lt;Collection&lt;Object&gt;&gt;() {</span>
            @Override
            public Collection&lt;Object&gt; call() throws Exception {
<span class="fc" id="L1510">                return new ArrayList&lt;Object&gt;();</span>
            }
        })
<span class="fc" id="L1513">        .test();</span>

<span class="fc" id="L1515">        pp.onError(new TestException());</span>

<span class="fc" id="L1517">        ts.assertFailure(TestException.class);</span>
<span class="fc" id="L1518">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void boundaryBoundaryError() {
<span class="fc" id="L1523">        PublishProcessor&lt;Object&gt; pp = PublishProcessor.create();</span>

<span class="fc" id="L1525">        TestSubscriber&lt;Collection&lt;Object&gt;&gt; ts = pp</span>
<span class="fc" id="L1526">        .buffer(Functions.justCallable(Flowable.error(new TestException())), new Callable&lt;Collection&lt;Object&gt;&gt;() {</span>
            @Override
            public Collection&lt;Object&gt; call() throws Exception {
<span class="fc" id="L1529">                return new ArrayList&lt;Object&gt;();</span>
            }
        })
<span class="fc" id="L1532">        .test();</span>

<span class="fc" id="L1534">        pp.onError(new TestException());</span>

<span class="fc" id="L1536">        ts.assertFailure(TestException.class);</span>
<span class="fc" id="L1537">    }</span>

    @Test
    public void dispose() {
<span class="fc" id="L1541">        TestHelper.checkDisposed(Flowable.range(1, 5).buffer(1, TimeUnit.DAYS, Schedulers.single()));</span>

<span class="fc" id="L1543">        TestHelper.checkDisposed(Flowable.range(1, 5).buffer(2, 1, TimeUnit.DAYS, Schedulers.single()));</span>

<span class="fc" id="L1545">        TestHelper.checkDisposed(Flowable.range(1, 5).buffer(1, 2, TimeUnit.DAYS, Schedulers.single()));</span>

<span class="fc" id="L1547">        TestHelper.checkDisposed(Flowable.range(1, 5)</span>
<span class="fc" id="L1548">                .buffer(1, TimeUnit.DAYS, Schedulers.single(), 2, Functions.&lt;Integer&gt;createArrayList(16), true));</span>

<span class="fc" id="L1550">        TestHelper.checkDisposed(Flowable.range(1, 5).buffer(1));</span>

<span class="fc" id="L1552">        TestHelper.checkDisposed(Flowable.range(1, 5).buffer(2, 1));</span>

<span class="fc" id="L1554">        TestHelper.checkDisposed(Flowable.range(1, 5).buffer(1, 2));</span>
<span class="fc" id="L1555">    }</span>

    @Test
    @SuppressWarnings(&quot;unchecked&quot;)
    public void supplierReturnsNull() {
<span class="fc" id="L1560">        Flowable.&lt;Integer&gt;never()</span>
<span class="fc" id="L1561">        .buffer(1, TimeUnit.MILLISECONDS, Schedulers.single(), Integer.MAX_VALUE, new Callable&lt;Collection&lt;Integer&gt;&gt;() {</span>
            int count;
            @Override
            public Collection&lt;Integer&gt; call() throws Exception {
<span class="fc bfc" id="L1565" title="All 2 branches covered.">                if (count++ == 1) {</span>
<span class="fc" id="L1566">                    return null;</span>
                } else {
<span class="fc" id="L1568">                    return new ArrayList&lt;Integer&gt;();</span>
                }
            }
        }, false)
<span class="fc" id="L1572">        .test()</span>
<span class="fc" id="L1573">        .awaitDone(5, TimeUnit.SECONDS)</span>
<span class="fc" id="L1574">        .assertFailure(NullPointerException.class);</span>
<span class="fc" id="L1575">    }</span>

    @Test
    @SuppressWarnings(&quot;unchecked&quot;)
    public void supplierReturnsNull2() {
<span class="fc" id="L1580">        Flowable.&lt;Integer&gt;never()</span>
<span class="fc" id="L1581">        .buffer(1, TimeUnit.MILLISECONDS, Schedulers.single(), 10, new Callable&lt;Collection&lt;Integer&gt;&gt;() {</span>
            int count;
            @Override
            public Collection&lt;Integer&gt; call() throws Exception {
<span class="fc bfc" id="L1585" title="All 2 branches covered.">                if (count++ == 1) {</span>
<span class="fc" id="L1586">                    return null;</span>
                } else {
<span class="fc" id="L1588">                    return new ArrayList&lt;Integer&gt;();</span>
                }
            }
        }, false)
<span class="fc" id="L1592">        .test()</span>
<span class="fc" id="L1593">        .awaitDone(5, TimeUnit.SECONDS)</span>
<span class="fc" id="L1594">        .assertFailure(NullPointerException.class);</span>
<span class="fc" id="L1595">    }</span>

    @Test
    @SuppressWarnings(&quot;unchecked&quot;)
    public void supplierReturnsNull3() {
<span class="fc" id="L1600">        Flowable.&lt;Integer&gt;never()</span>
<span class="fc" id="L1601">        .buffer(2, 1, TimeUnit.MILLISECONDS, Schedulers.single(), new Callable&lt;Collection&lt;Integer&gt;&gt;() {</span>
            int count;
            @Override
            public Collection&lt;Integer&gt; call() throws Exception {
<span class="fc bfc" id="L1605" title="All 2 branches covered.">                if (count++ == 1) {</span>
<span class="fc" id="L1606">                    return null;</span>
                } else {
<span class="fc" id="L1608">                    return new ArrayList&lt;Integer&gt;();</span>
                }
            }
        })
<span class="fc" id="L1612">        .test()</span>
<span class="fc" id="L1613">        .awaitDone(5, TimeUnit.SECONDS)</span>
<span class="fc" id="L1614">        .assertFailure(NullPointerException.class);</span>
<span class="fc" id="L1615">    }</span>

    @Test
    @SuppressWarnings(&quot;unchecked&quot;)
    public void supplierThrows() {
<span class="fc" id="L1620">        Flowable.just(1)</span>
<span class="fc" id="L1621">        .buffer(1, TimeUnit.SECONDS, Schedulers.single(), Integer.MAX_VALUE, new Callable&lt;Collection&lt;Integer&gt;&gt;() {</span>
            @Override
            public Collection&lt;Integer&gt; call() throws Exception {
<span class="fc" id="L1624">                throw new TestException();</span>
            }
        }, false)
<span class="fc" id="L1627">        .test()</span>
<span class="fc" id="L1628">        .assertFailure(TestException.class);</span>
<span class="fc" id="L1629">    }</span>

    @Test
    @SuppressWarnings(&quot;unchecked&quot;)
    public void supplierThrows2() {
<span class="fc" id="L1634">        Flowable.just(1)</span>
<span class="fc" id="L1635">        .buffer(1, TimeUnit.SECONDS, Schedulers.single(), 10, new Callable&lt;Collection&lt;Integer&gt;&gt;() {</span>
            @Override
            public Collection&lt;Integer&gt; call() throws Exception {
<span class="fc" id="L1638">                throw new TestException();</span>
            }
        }, false)
<span class="fc" id="L1641">        .test()</span>
<span class="fc" id="L1642">        .assertFailure(TestException.class);</span>
<span class="fc" id="L1643">    }</span>

    @Test
    @SuppressWarnings(&quot;unchecked&quot;)
    public void supplierThrows3() {
<span class="fc" id="L1648">        Flowable.just(1)</span>
<span class="fc" id="L1649">        .buffer(2, 1, TimeUnit.SECONDS, Schedulers.single(), new Callable&lt;Collection&lt;Integer&gt;&gt;() {</span>
            @Override
            public Collection&lt;Integer&gt; call() throws Exception {
<span class="fc" id="L1652">                throw new TestException();</span>
            }
        })
<span class="fc" id="L1655">        .test()</span>
<span class="fc" id="L1656">        .assertFailure(TestException.class);</span>
<span class="fc" id="L1657">    }</span>

    @Test
    @SuppressWarnings(&quot;unchecked&quot;)
    public void supplierThrows4() {
<span class="fc" id="L1662">        Flowable.&lt;Integer&gt;never()</span>
<span class="fc" id="L1663">        .buffer(1, TimeUnit.MILLISECONDS, Schedulers.single(), Integer.MAX_VALUE, new Callable&lt;Collection&lt;Integer&gt;&gt;() {</span>
            int count;
            @Override
            public Collection&lt;Integer&gt; call() throws Exception {
<span class="fc bfc" id="L1667" title="All 2 branches covered.">                if (count++ == 1) {</span>
<span class="fc" id="L1668">                    throw new TestException();</span>
                } else {
<span class="fc" id="L1670">                    return new ArrayList&lt;Integer&gt;();</span>
                }
            }
        }, false)
<span class="fc" id="L1674">        .test()</span>
<span class="fc" id="L1675">        .awaitDone(5, TimeUnit.SECONDS)</span>
<span class="fc" id="L1676">        .assertFailure(TestException.class);</span>
<span class="fc" id="L1677">    }</span>

    @Test
    @SuppressWarnings(&quot;unchecked&quot;)
    public void supplierThrows5() {
<span class="fc" id="L1682">        Flowable.&lt;Integer&gt;never()</span>
<span class="fc" id="L1683">        .buffer(1, TimeUnit.MILLISECONDS, Schedulers.single(), 10, new Callable&lt;Collection&lt;Integer&gt;&gt;() {</span>
            int count;
            @Override
            public Collection&lt;Integer&gt; call() throws Exception {
<span class="fc bfc" id="L1687" title="All 2 branches covered.">                if (count++ == 1) {</span>
<span class="fc" id="L1688">                    throw new TestException();</span>
                } else {
<span class="fc" id="L1690">                    return new ArrayList&lt;Integer&gt;();</span>
                }
            }
        }, false)
<span class="fc" id="L1694">        .test()</span>
<span class="fc" id="L1695">        .awaitDone(5, TimeUnit.SECONDS)</span>
<span class="fc" id="L1696">        .assertFailure(TestException.class);</span>
<span class="fc" id="L1697">    }</span>

    @Test
    @SuppressWarnings(&quot;unchecked&quot;)
    public void supplierThrows6() {
<span class="fc" id="L1702">        Flowable.&lt;Integer&gt;never()</span>
<span class="fc" id="L1703">        .buffer(2, 1, TimeUnit.MILLISECONDS, Schedulers.single(), new Callable&lt;Collection&lt;Integer&gt;&gt;() {</span>
            int count;
            @Override
            public Collection&lt;Integer&gt; call() throws Exception {
<span class="fc bfc" id="L1707" title="All 2 branches covered.">                if (count++ == 1) {</span>
<span class="fc" id="L1708">                    throw new TestException();</span>
                } else {
<span class="fc" id="L1710">                    return new ArrayList&lt;Integer&gt;();</span>
                }
            }
        })
<span class="fc" id="L1714">        .test()</span>
<span class="fc" id="L1715">        .awaitDone(5, TimeUnit.SECONDS)</span>
<span class="fc" id="L1716">        .assertFailure(TestException.class);</span>
<span class="fc" id="L1717">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void restartTimer() {
<span class="fc" id="L1722">        Flowable.range(1, 5)</span>
<span class="fc" id="L1723">        .buffer(1, TimeUnit.DAYS, Schedulers.single(), 2, Functions.&lt;Integer&gt;createArrayList(16), true)</span>
<span class="fc" id="L1724">        .test()</span>
<span class="fc" id="L1725">        .assertResult(Arrays.asList(1, 2), Arrays.asList(3, 4), Arrays.asList(5));</span>
<span class="fc" id="L1726">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void bufferSkipError() {
<span class="fc" id="L1731">        Flowable.&lt;Integer&gt;error(new TestException())</span>
<span class="fc" id="L1732">        .buffer(2, 1)</span>
<span class="fc" id="L1733">        .test()</span>
<span class="fc" id="L1734">        .assertFailure(TestException.class);</span>
<span class="fc" id="L1735">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void bufferSupplierCrash2() {
<span class="fc" id="L1740">        Flowable.range(1, 2)</span>
<span class="fc" id="L1741">        .buffer(1, new Callable&lt;List&lt;Integer&gt;&gt;() {</span>
            int calls;
            @Override
            public List&lt;Integer&gt; call() throws Exception {
<span class="fc bfc" id="L1745" title="All 2 branches covered.">                if (++calls == 2) {</span>
<span class="fc" id="L1746">                    throw new TestException();</span>
                }
<span class="fc" id="L1748">                return new ArrayList&lt;Integer&gt;();</span>
            }
        })
<span class="fc" id="L1751">        .test()</span>
<span class="fc" id="L1752">        .assertFailure(TestException.class, Arrays.asList(1));</span>
<span class="fc" id="L1753">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void bufferSkipSupplierCrash2() {
<span class="fc" id="L1758">        Flowable.range(1, 2)</span>
<span class="fc" id="L1759">        .buffer(1, 2, new Callable&lt;List&lt;Integer&gt;&gt;() {</span>
            int calls;
            @Override
            public List&lt;Integer&gt; call() throws Exception {
<span class="pc bpc" id="L1763" title="1 of 2 branches missed.">                if (++calls == 1) {</span>
<span class="fc" id="L1764">                    throw new TestException();</span>
                }
<span class="nc" id="L1766">                return new ArrayList&lt;Integer&gt;();</span>
            }
        })
<span class="fc" id="L1769">        .test()</span>
<span class="fc" id="L1770">        .assertFailure(TestException.class);</span>
<span class="fc" id="L1771">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void bufferOverlapSupplierCrash2() {
<span class="fc" id="L1776">        Flowable.range(1, 2)</span>
<span class="fc" id="L1777">        .buffer(2, 1, new Callable&lt;List&lt;Integer&gt;&gt;() {</span>
            int calls;
            @Override
            public List&lt;Integer&gt; call() throws Exception {
<span class="fc bfc" id="L1781" title="All 2 branches covered.">                if (++calls == 2) {</span>
<span class="fc" id="L1782">                    throw new TestException();</span>
                }
<span class="fc" id="L1784">                return new ArrayList&lt;Integer&gt;();</span>
            }
        })
<span class="fc" id="L1787">        .test()</span>
<span class="fc" id="L1788">        .assertFailure(TestException.class);</span>
<span class="fc" id="L1789">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void bufferSkipOverlap() {
<span class="fc" id="L1794">        Flowable.range(1, 5)</span>
<span class="fc" id="L1795">        .buffer(5, 1)</span>
<span class="fc" id="L1796">        .test()</span>
<span class="fc" id="L1797">        .assertResult(</span>
<span class="fc" id="L1798">            Arrays.asList(1, 2, 3, 4, 5),</span>
<span class="fc" id="L1799">            Arrays.asList(2, 3, 4, 5),</span>
<span class="fc" id="L1800">            Arrays.asList(3, 4, 5),</span>
<span class="fc" id="L1801">            Arrays.asList(4, 5),</span>
<span class="fc" id="L1802">            Arrays.asList(5)</span>
        );
<span class="fc" id="L1804">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void bufferTimedExactError() {
<span class="fc" id="L1809">        Flowable.error(new TestException())</span>
<span class="fc" id="L1810">        .buffer(1, TimeUnit.DAYS)</span>
<span class="fc" id="L1811">        .test()</span>
<span class="fc" id="L1812">        .assertFailure(TestException.class);</span>
<span class="fc" id="L1813">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void bufferTimedSkipError() {
<span class="fc" id="L1818">        Flowable.error(new TestException())</span>
<span class="fc" id="L1819">        .buffer(1, 2, TimeUnit.DAYS)</span>
<span class="fc" id="L1820">        .test()</span>
<span class="fc" id="L1821">        .assertFailure(TestException.class);</span>
<span class="fc" id="L1822">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void bufferTimedOverlapError() {
<span class="fc" id="L1827">        Flowable.error(new TestException())</span>
<span class="fc" id="L1828">        .buffer(2, 1, TimeUnit.DAYS)</span>
<span class="fc" id="L1829">        .test()</span>
<span class="fc" id="L1830">        .assertFailure(TestException.class);</span>
<span class="fc" id="L1831">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void bufferTimedExactEmpty() {
<span class="fc" id="L1836">        Flowable.empty()</span>
<span class="fc" id="L1837">        .buffer(1, TimeUnit.DAYS)</span>
<span class="fc" id="L1838">        .test()</span>
<span class="fc" id="L1839">        .assertResult(Collections.emptyList());</span>
<span class="fc" id="L1840">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void bufferTimedSkipEmpty() {
<span class="fc" id="L1845">        Flowable.empty()</span>
<span class="fc" id="L1846">        .buffer(1, 2, TimeUnit.DAYS)</span>
<span class="fc" id="L1847">        .test()</span>
<span class="fc" id="L1848">        .assertResult(Collections.emptyList());</span>
<span class="fc" id="L1849">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void bufferTimedOverlapEmpty() {
<span class="fc" id="L1854">        Flowable.empty()</span>
<span class="fc" id="L1855">        .buffer(2, 1, TimeUnit.DAYS)</span>
<span class="fc" id="L1856">        .test()</span>
<span class="fc" id="L1857">        .assertResult(Collections.emptyList());</span>
<span class="fc" id="L1858">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void bufferTimedExactSupplierCrash() {
<span class="fc" id="L1863">        TestScheduler scheduler = new TestScheduler();</span>

<span class="fc" id="L1865">        PublishProcessor&lt;Integer&gt; pp = PublishProcessor.create();</span>

<span class="fc" id="L1867">        TestSubscriber&lt;List&lt;Integer&gt;&gt; ts = pp</span>
<span class="fc" id="L1868">        .buffer(1, TimeUnit.MILLISECONDS, scheduler, 1, new Callable&lt;List&lt;Integer&gt;&gt;() {</span>
            int calls;
            @Override
            public List&lt;Integer&gt; call() throws Exception {
<span class="fc bfc" id="L1872" title="All 2 branches covered.">                if (++calls == 2) {</span>
<span class="fc" id="L1873">                    throw new TestException();</span>
                }
<span class="fc" id="L1875">                return new ArrayList&lt;Integer&gt;();</span>
            }
        }, true)
<span class="fc" id="L1878">        .test();</span>

<span class="fc" id="L1880">        pp.onNext(1);</span>

<span class="fc" id="L1882">        scheduler.advanceTimeBy(1, TimeUnit.MILLISECONDS);</span>

<span class="fc" id="L1884">        pp.onNext(2);</span>

<span class="fc" id="L1886">        ts</span>
<span class="fc" id="L1887">        .assertFailure(TestException.class, Arrays.asList(1));</span>
<span class="fc" id="L1888">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void bufferTimedExactBoundedError() {
<span class="fc" id="L1893">        TestScheduler scheduler = new TestScheduler();</span>

<span class="fc" id="L1895">        PublishProcessor&lt;Integer&gt; pp = PublishProcessor.create();</span>

<span class="fc" id="L1897">        TestSubscriber&lt;List&lt;Integer&gt;&gt; ts = pp</span>
<span class="fc" id="L1898">        .buffer(1, TimeUnit.MILLISECONDS, scheduler, 1, Functions.&lt;Integer&gt;createArrayList(16), true)</span>
<span class="fc" id="L1899">        .test();</span>

<span class="fc" id="L1901">        pp.onError(new TestException());</span>

<span class="fc" id="L1903">        ts</span>
<span class="fc" id="L1904">        .assertFailure(TestException.class);</span>
<span class="fc" id="L1905">    }</span>

    @Test
    public void badSource() {
<span class="fc" id="L1909">        TestHelper.checkBadSourceFlowable(new Function&lt;Flowable&lt;Integer&gt;, Object&gt;() {</span>
            @Override
            public Object apply(Flowable&lt;Integer&gt; f) throws Exception {
<span class="fc" id="L1912">                return f.buffer(1);</span>
            }
<span class="fc" id="L1914">        }, false, 1, 1, Arrays.asList(1));</span>

<span class="fc" id="L1916">        TestHelper.checkBadSourceFlowable(new Function&lt;Flowable&lt;Integer&gt;, Object&gt;() {</span>
            @Override
            public Object apply(Flowable&lt;Integer&gt; f) throws Exception {
<span class="fc" id="L1919">                return f.buffer(1, 2);</span>
            }
<span class="fc" id="L1921">        }, false, 1, 1, Arrays.asList(1));</span>

<span class="fc" id="L1923">        TestHelper.checkBadSourceFlowable(new Function&lt;Flowable&lt;Integer&gt;, Object&gt;() {</span>
            @Override
            public Object apply(Flowable&lt;Integer&gt; f) throws Exception {
<span class="fc" id="L1926">                return f.buffer(2, 1);</span>
            }
<span class="fc" id="L1928">        }, false, 1, 1, Arrays.asList(1));</span>
<span class="fc" id="L1929">    }</span>

    @Test
    public void doubleOnSubscribe() {
<span class="fc" id="L1933">        TestHelper.checkDoubleOnSubscribeFlowable(new Function&lt;Flowable&lt;Object&gt;, Publisher&lt;List&lt;Object&gt;&gt;&gt;() {</span>
            @Override
            public Publisher&lt;List&lt;Object&gt;&gt; apply(Flowable&lt;Object&gt; f) throws Exception {
<span class="fc" id="L1936">                return f.buffer(1);</span>
            }
        });

<span class="fc" id="L1940">        TestHelper.checkDoubleOnSubscribeFlowable(new Function&lt;Flowable&lt;Object&gt;, Publisher&lt;List&lt;Object&gt;&gt;&gt;() {</span>
            @Override
            public Publisher&lt;List&lt;Object&gt;&gt; apply(Flowable&lt;Object&gt; f) throws Exception {
<span class="fc" id="L1943">                return f.buffer(1, 2);</span>
            }
        });

<span class="fc" id="L1947">        TestHelper.checkDoubleOnSubscribeFlowable(new Function&lt;Flowable&lt;Object&gt;, Publisher&lt;List&lt;Object&gt;&gt;&gt;() {</span>
            @Override
            public Publisher&lt;List&lt;Object&gt;&gt; apply(Flowable&lt;Object&gt; f) throws Exception {
<span class="fc" id="L1950">                return f.buffer(2, 1);</span>
            }
        });
<span class="fc" id="L1953">    }</span>

    @Test
    public void badRequest() {
<span class="fc" id="L1957">        TestHelper.assertBadRequestReported(PublishProcessor.create().buffer(1));</span>

<span class="fc" id="L1959">        TestHelper.assertBadRequestReported(PublishProcessor.create().buffer(1, 2));</span>

<span class="fc" id="L1961">        TestHelper.assertBadRequestReported(PublishProcessor.create().buffer(2, 1));</span>
<span class="fc" id="L1962">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void skipError() {
<span class="fc" id="L1967">        Flowable.error(new TestException())</span>
<span class="fc" id="L1968">        .buffer(1, 2)</span>
<span class="fc" id="L1969">        .test()</span>
<span class="fc" id="L1970">        .assertFailure(TestException.class);</span>
<span class="fc" id="L1971">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void skipSingleResult() {
<span class="fc" id="L1976">        Flowable.just(1)</span>
<span class="fc" id="L1977">        .buffer(2, 3)</span>
<span class="fc" id="L1978">        .test()</span>
<span class="fc" id="L1979">        .assertResult(Arrays.asList(1));</span>
<span class="fc" id="L1980">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void skipBackpressure() {
<span class="fc" id="L1985">        Flowable.range(1, 10)</span>
<span class="fc" id="L1986">        .buffer(2, 3)</span>
<span class="fc" id="L1987">        .rebatchRequests(1)</span>
<span class="fc" id="L1988">        .test()</span>
<span class="fc" id="L1989">        .assertResult(Arrays.asList(1, 2), Arrays.asList(4, 5), Arrays.asList(7, 8), Arrays.asList(10));</span>
<span class="fc" id="L1990">    }</span>

    @Test
    public void withTimeAndSizeCapacityRace() {
<span class="fc bfc" id="L1994" title="All 2 branches covered.">        for (int i = 0; i &lt; TestHelper.RACE_DEFAULT_LOOPS; i++) {</span>
<span class="fc" id="L1995">            final TestScheduler scheduler = new TestScheduler();</span>

<span class="fc" id="L1997">            final PublishProcessor&lt;Object&gt; pp = PublishProcessor.create();</span>

<span class="fc" id="L1999">            TestSubscriber&lt;List&lt;Object&gt;&gt; ts = pp.buffer(1, TimeUnit.SECONDS, scheduler, 5).test();</span>

<span class="fc" id="L2001">            pp.onNext(1);</span>
<span class="fc" id="L2002">            pp.onNext(2);</span>
<span class="fc" id="L2003">            pp.onNext(3);</span>
<span class="fc" id="L2004">            pp.onNext(4);</span>

<span class="fc" id="L2006">            Runnable r1 = new Runnable() {</span>
                @Override
                public void run() {
<span class="fc" id="L2009">                    pp.onNext(5);</span>
<span class="fc" id="L2010">                }</span>
            };

<span class="fc" id="L2013">            Runnable r2 = new Runnable() {</span>
                @Override
                public void run() {
<span class="fc" id="L2016">                    scheduler.advanceTimeBy(1, TimeUnit.SECONDS);</span>
<span class="fc" id="L2017">                }</span>
            };

<span class="fc" id="L2020">            TestHelper.race(r1, r2);</span>

<span class="fc" id="L2022">            pp.onComplete();</span>

<span class="fc" id="L2024">            int items = 0;</span>
<span class="fc bfc" id="L2025" title="All 2 branches covered.">            for (List&lt;Object&gt; o : ts.values()) {</span>
<span class="fc" id="L2026">                items += o.size();</span>
<span class="fc" id="L2027">            }</span>

<span class="fc" id="L2029">            assertEquals(&quot;Round: &quot; + i, 5, items);</span>
        }
<span class="fc" id="L2031">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void noCompletionCancelExact() {
<span class="fc" id="L2036">        final AtomicInteger counter = new AtomicInteger();</span>

<span class="fc" id="L2038">        Flowable.&lt;Integer&gt;empty()</span>
<span class="fc" id="L2039">        .doOnCancel(new Action() {</span>
            @Override
            public void run() throws Exception {
<span class="nc" id="L2042">                counter.getAndIncrement();</span>
<span class="nc" id="L2043">            }</span>
        })
<span class="fc" id="L2045">        .buffer(5, TimeUnit.SECONDS)</span>
<span class="fc" id="L2046">        .test()</span>
<span class="fc" id="L2047">        .awaitDone(5, TimeUnit.SECONDS)</span>
<span class="fc" id="L2048">        .assertResult(Collections.&lt;Integer&gt;emptyList());</span>

<span class="fc" id="L2050">        assertEquals(0, counter.get());</span>
<span class="fc" id="L2051">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void noCompletionCancelSkip() {
<span class="fc" id="L2056">        final AtomicInteger counter = new AtomicInteger();</span>

<span class="fc" id="L2058">        Flowable.&lt;Integer&gt;empty()</span>
<span class="fc" id="L2059">        .doOnCancel(new Action() {</span>
            @Override
            public void run() throws Exception {
<span class="nc" id="L2062">                counter.getAndIncrement();</span>
<span class="nc" id="L2063">            }</span>
        })
<span class="fc" id="L2065">        .buffer(5, 10, TimeUnit.SECONDS)</span>
<span class="fc" id="L2066">        .test()</span>
<span class="fc" id="L2067">        .awaitDone(5, TimeUnit.SECONDS)</span>
<span class="fc" id="L2068">        .assertResult(Collections.&lt;Integer&gt;emptyList());</span>

<span class="fc" id="L2070">        assertEquals(0, counter.get());</span>
<span class="fc" id="L2071">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void noCompletionCancelOverlap() {
<span class="fc" id="L2076">        final AtomicInteger counter = new AtomicInteger();</span>

<span class="fc" id="L2078">        Flowable.&lt;Integer&gt;empty()</span>
<span class="fc" id="L2079">        .doOnCancel(new Action() {</span>
            @Override
            public void run() throws Exception {
<span class="nc" id="L2082">                counter.getAndIncrement();</span>
<span class="nc" id="L2083">            }</span>
        })
<span class="fc" id="L2085">        .buffer(10, 5, TimeUnit.SECONDS)</span>
<span class="fc" id="L2086">        .test()</span>
<span class="fc" id="L2087">        .awaitDone(5, TimeUnit.SECONDS)</span>
<span class="fc" id="L2088">        .assertResult(Collections.&lt;Integer&gt;emptyList());</span>

<span class="fc" id="L2090">        assertEquals(0, counter.get());</span>
<span class="fc" id="L2091">    }</span>

    @Test
    @SuppressWarnings(&quot;unchecked&quot;)
    public void boundaryOpenCloseDisposedOnComplete() {
<span class="fc" id="L2096">        PublishProcessor&lt;Integer&gt; source = PublishProcessor.create();</span>

<span class="fc" id="L2098">        PublishProcessor&lt;Integer&gt; openIndicator = PublishProcessor.create();</span>

<span class="fc" id="L2100">        PublishProcessor&lt;Integer&gt; closeIndicator = PublishProcessor.create();</span>

<span class="fc" id="L2102">        TestSubscriber&lt;List&lt;Integer&gt;&gt; ts = source</span>
<span class="fc" id="L2103">        .buffer(openIndicator, Functions.justFunction(closeIndicator))</span>
<span class="fc" id="L2104">        .test();</span>

<span class="fc" id="L2106">        assertTrue(source.hasSubscribers());</span>
<span class="fc" id="L2107">        assertTrue(openIndicator.hasSubscribers());</span>
<span class="fc" id="L2108">        assertFalse(closeIndicator.hasSubscribers());</span>

<span class="fc" id="L2110">        openIndicator.onNext(1);</span>

<span class="fc" id="L2112">        assertTrue(openIndicator.hasSubscribers());</span>
<span class="fc" id="L2113">        assertTrue(closeIndicator.hasSubscribers());</span>

<span class="fc" id="L2115">        source.onComplete();</span>

<span class="fc" id="L2117">        ts.assertResult(Collections.&lt;Integer&gt;emptyList());</span>

<span class="fc" id="L2119">        assertFalse(openIndicator.hasSubscribers());</span>
<span class="fc" id="L2120">        assertFalse(closeIndicator.hasSubscribers());</span>
<span class="fc" id="L2121">    }</span>

    @Test
    public void bufferedCanCompleteIfOpenNeverCompletesDropping() {
<span class="fc" id="L2125">        Flowable.range(1, 50)</span>
<span class="fc" id="L2126">                .zipWith(Flowable.interval(5, TimeUnit.MILLISECONDS),</span>
<span class="fc" id="L2127">                        new BiFunction&lt;Integer, Long, Integer&gt;() {</span>
                            @Override
                            public Integer apply(Integer integer, Long aLong) {
<span class="fc" id="L2130">                                return integer;</span>
                            }
                        })
<span class="fc" id="L2133">                .buffer(Flowable.interval(0, 200, TimeUnit.MILLISECONDS),</span>
<span class="fc" id="L2134">                        new Function&lt;Long, Publisher&lt;?&gt;&gt;() {</span>
                            @Override
                            public Publisher&lt;?&gt; apply(Long a) {
<span class="fc" id="L2137">                                return Flowable.just(a).delay(100, TimeUnit.MILLISECONDS);</span>
                            }
                        })
<span class="fc" id="L2140">                .test()</span>
<span class="fc" id="L2141">                .assertSubscribed()</span>
<span class="fc" id="L2142">                .awaitDone(3, TimeUnit.SECONDS)</span>
<span class="fc" id="L2143">                .assertComplete();</span>
<span class="fc" id="L2144">    }</span>

    @Test
    public void bufferedCanCompleteIfOpenNeverCompletesOverlapping() {
<span class="fc" id="L2148">        Flowable.range(1, 50)</span>
<span class="fc" id="L2149">                .zipWith(Flowable.interval(5, TimeUnit.MILLISECONDS),</span>
<span class="fc" id="L2150">                        new BiFunction&lt;Integer, Long, Integer&gt;() {</span>
                            @Override
                            public Integer apply(Integer integer, Long aLong) {
<span class="fc" id="L2153">                                return integer;</span>
                            }
                        })
<span class="fc" id="L2156">                .buffer(Flowable.interval(0, 100, TimeUnit.MILLISECONDS),</span>
<span class="fc" id="L2157">                        new Function&lt;Long, Publisher&lt;?&gt;&gt;() {</span>
                            @Override
                            public Publisher&lt;?&gt; apply(Long a) {
<span class="fc" id="L2160">                                return Flowable.just(a).delay(200, TimeUnit.MILLISECONDS);</span>
                            }
                        })
<span class="fc" id="L2163">                .test()</span>
<span class="fc" id="L2164">                .assertSubscribed()</span>
<span class="fc" id="L2165">                .awaitDone(3, TimeUnit.SECONDS)</span>
<span class="fc" id="L2166">                .assertComplete();</span>
<span class="fc" id="L2167">    }</span>

    @Test
    @SuppressWarnings(&quot;unchecked&quot;)
    public void openClosemainError() {
<span class="fc" id="L2172">        Flowable.error(new TestException())</span>
<span class="fc" id="L2173">        .buffer(Flowable.never(), Functions.justFunction(Flowable.never()))</span>
<span class="fc" id="L2174">        .test()</span>
<span class="fc" id="L2175">        .assertFailure(TestException.class);</span>
<span class="fc" id="L2176">    }</span>

    @Test
    @SuppressWarnings(&quot;unchecked&quot;)
    public void openClosebadSource() {
<span class="fc" id="L2181">        List&lt;Throwable&gt; errors = TestHelper.trackPluginErrors();</span>
        try {
<span class="fc" id="L2183">            new Flowable&lt;Object&gt;() {</span>
                @Override
                protected void subscribeActual(Subscriber&lt;? super Object&gt; s) {
<span class="fc" id="L2186">                    BooleanSubscription bs1 = new BooleanSubscription();</span>
<span class="fc" id="L2187">                    BooleanSubscription bs2 = new BooleanSubscription();</span>

<span class="fc" id="L2189">                    s.onSubscribe(bs1);</span>

<span class="fc" id="L2191">                    assertFalse(bs1.isCancelled());</span>
<span class="fc" id="L2192">                    assertFalse(bs2.isCancelled());</span>

<span class="fc" id="L2194">                    s.onSubscribe(bs2);</span>

<span class="fc" id="L2196">                    assertFalse(bs1.isCancelled());</span>
<span class="fc" id="L2197">                    assertTrue(bs2.isCancelled());</span>

<span class="fc" id="L2199">                    s.onError(new IOException());</span>
<span class="fc" id="L2200">                    s.onComplete();</span>
<span class="fc" id="L2201">                    s.onNext(1);</span>
<span class="fc" id="L2202">                    s.onError(new TestException());</span>
<span class="fc" id="L2203">                }</span>
            }
<span class="fc" id="L2205">            .buffer(Flowable.never(), Functions.justFunction(Flowable.never()))</span>
<span class="fc" id="L2206">            .test()</span>
<span class="fc" id="L2207">            .assertFailure(IOException.class);</span>

<span class="fc" id="L2209">            TestHelper.assertError(errors, 0, ProtocolViolationException.class);</span>
<span class="fc" id="L2210">            TestHelper.assertUndeliverable(errors, 1, TestException.class);</span>
        } finally {
<span class="fc" id="L2212">            RxJavaPlugins.reset();</span>
        }
<span class="fc" id="L2214">    }</span>

    @Test
    @SuppressWarnings(&quot;unchecked&quot;)
    public void openCloseOpenCompletes() {
<span class="fc" id="L2219">        PublishProcessor&lt;Integer&gt; source = PublishProcessor.create();</span>

<span class="fc" id="L2221">        PublishProcessor&lt;Integer&gt; openIndicator = PublishProcessor.create();</span>

<span class="fc" id="L2223">        PublishProcessor&lt;Integer&gt; closeIndicator = PublishProcessor.create();</span>

<span class="fc" id="L2225">        TestSubscriber&lt;List&lt;Integer&gt;&gt; ts = source</span>
<span class="fc" id="L2226">        .buffer(openIndicator, Functions.justFunction(closeIndicator))</span>
<span class="fc" id="L2227">        .test();</span>

<span class="fc" id="L2229">        openIndicator.onNext(1);</span>

<span class="fc" id="L2231">        assertTrue(closeIndicator.hasSubscribers());</span>

<span class="fc" id="L2233">        openIndicator.onComplete();</span>

<span class="fc" id="L2235">        assertTrue(source.hasSubscribers());</span>
<span class="fc" id="L2236">        assertTrue(closeIndicator.hasSubscribers());</span>

<span class="fc" id="L2238">        closeIndicator.onComplete();</span>

<span class="fc" id="L2240">        assertFalse(source.hasSubscribers());</span>

<span class="fc" id="L2242">        ts.assertResult(Collections.&lt;Integer&gt;emptyList());</span>
<span class="fc" id="L2243">    }</span>

    @Test
    @SuppressWarnings(&quot;unchecked&quot;)
    public void openCloseOpenCompletesNoBuffers() {
<span class="fc" id="L2248">        PublishProcessor&lt;Integer&gt; source = PublishProcessor.create();</span>

<span class="fc" id="L2250">        PublishProcessor&lt;Integer&gt; openIndicator = PublishProcessor.create();</span>

<span class="fc" id="L2252">        PublishProcessor&lt;Integer&gt; closeIndicator = PublishProcessor.create();</span>

<span class="fc" id="L2254">        TestSubscriber&lt;List&lt;Integer&gt;&gt; ts = source</span>
<span class="fc" id="L2255">        .buffer(openIndicator, Functions.justFunction(closeIndicator))</span>
<span class="fc" id="L2256">        .test();</span>

<span class="fc" id="L2258">        openIndicator.onNext(1);</span>

<span class="fc" id="L2260">        assertTrue(closeIndicator.hasSubscribers());</span>

<span class="fc" id="L2262">        closeIndicator.onComplete();</span>

<span class="fc" id="L2264">        assertTrue(source.hasSubscribers());</span>
<span class="fc" id="L2265">        assertTrue(openIndicator.hasSubscribers());</span>

<span class="fc" id="L2267">        openIndicator.onComplete();</span>

<span class="fc" id="L2269">        assertFalse(source.hasSubscribers());</span>

<span class="fc" id="L2271">        ts.assertResult(Collections.&lt;Integer&gt;emptyList());</span>
<span class="fc" id="L2272">    }</span>

    @Test
    @SuppressWarnings(&quot;unchecked&quot;)
    public void openCloseTake() {
<span class="fc" id="L2277">        PublishProcessor&lt;Integer&gt; source = PublishProcessor.create();</span>

<span class="fc" id="L2279">        PublishProcessor&lt;Integer&gt; openIndicator = PublishProcessor.create();</span>

<span class="fc" id="L2281">        PublishProcessor&lt;Integer&gt; closeIndicator = PublishProcessor.create();</span>

<span class="fc" id="L2283">        TestSubscriber&lt;List&lt;Integer&gt;&gt; ts = source</span>
<span class="fc" id="L2284">        .buffer(openIndicator, Functions.justFunction(closeIndicator))</span>
<span class="fc" id="L2285">        .take(1)</span>
<span class="fc" id="L2286">        .test(2);</span>

<span class="fc" id="L2288">        openIndicator.onNext(1);</span>
<span class="fc" id="L2289">        closeIndicator.onComplete();</span>

<span class="fc" id="L2291">        assertFalse(source.hasSubscribers());</span>
<span class="fc" id="L2292">        assertFalse(openIndicator.hasSubscribers());</span>
<span class="fc" id="L2293">        assertFalse(closeIndicator.hasSubscribers());</span>

<span class="fc" id="L2295">        ts.assertResult(Collections.&lt;Integer&gt;emptyList());</span>
<span class="fc" id="L2296">    }</span>

    @Test
    @SuppressWarnings(&quot;unchecked&quot;)
    public void openCloseLimit() {
<span class="fc" id="L2301">        PublishProcessor&lt;Integer&gt; source = PublishProcessor.create();</span>

<span class="fc" id="L2303">        PublishProcessor&lt;Integer&gt; openIndicator = PublishProcessor.create();</span>

<span class="fc" id="L2305">        PublishProcessor&lt;Integer&gt; closeIndicator = PublishProcessor.create();</span>

<span class="fc" id="L2307">        TestSubscriber&lt;List&lt;Integer&gt;&gt; ts = source</span>
<span class="fc" id="L2308">        .buffer(openIndicator, Functions.justFunction(closeIndicator))</span>
<span class="fc" id="L2309">        .limit(1)</span>
<span class="fc" id="L2310">        .test(2);</span>

<span class="fc" id="L2312">        openIndicator.onNext(1);</span>
<span class="fc" id="L2313">        closeIndicator.onComplete();</span>

<span class="fc" id="L2315">        assertFalse(source.hasSubscribers());</span>
<span class="fc" id="L2316">        assertFalse(openIndicator.hasSubscribers());</span>
<span class="fc" id="L2317">        assertFalse(closeIndicator.hasSubscribers());</span>

<span class="fc" id="L2319">        ts.assertResult(Collections.&lt;Integer&gt;emptyList());</span>
<span class="fc" id="L2320">    }</span>

    @Test
    @SuppressWarnings(&quot;unchecked&quot;)
    public void openCloseEmptyBackpressure() {
<span class="fc" id="L2325">        PublishProcessor&lt;Integer&gt; source = PublishProcessor.create();</span>

<span class="fc" id="L2327">        PublishProcessor&lt;Integer&gt; openIndicator = PublishProcessor.create();</span>

<span class="fc" id="L2329">        PublishProcessor&lt;Integer&gt; closeIndicator = PublishProcessor.create();</span>

<span class="fc" id="L2331">        TestSubscriber&lt;List&lt;Integer&gt;&gt; ts = source</span>
<span class="fc" id="L2332">        .buffer(openIndicator, Functions.justFunction(closeIndicator))</span>
<span class="fc" id="L2333">        .test(0);</span>

<span class="fc" id="L2335">        source.onComplete();</span>

<span class="fc" id="L2337">        assertFalse(openIndicator.hasSubscribers());</span>
<span class="fc" id="L2338">        assertFalse(closeIndicator.hasSubscribers());</span>

<span class="fc" id="L2340">        ts.assertResult();</span>
<span class="fc" id="L2341">    }</span>

    @Test
    @SuppressWarnings(&quot;unchecked&quot;)
    public void openCloseErrorBackpressure() {
<span class="fc" id="L2346">        PublishProcessor&lt;Integer&gt; source = PublishProcessor.create();</span>

<span class="fc" id="L2348">        PublishProcessor&lt;Integer&gt; openIndicator = PublishProcessor.create();</span>

<span class="fc" id="L2350">        PublishProcessor&lt;Integer&gt; closeIndicator = PublishProcessor.create();</span>

<span class="fc" id="L2352">        TestSubscriber&lt;List&lt;Integer&gt;&gt; ts = source</span>
<span class="fc" id="L2353">        .buffer(openIndicator, Functions.justFunction(closeIndicator))</span>
<span class="fc" id="L2354">        .test(0);</span>

<span class="fc" id="L2356">        source.onError(new TestException());</span>

<span class="fc" id="L2358">        assertFalse(openIndicator.hasSubscribers());</span>
<span class="fc" id="L2359">        assertFalse(closeIndicator.hasSubscribers());</span>

<span class="fc" id="L2361">        ts.assertFailure(TestException.class);</span>
<span class="fc" id="L2362">    }</span>

    @Test
    @SuppressWarnings(&quot;unchecked&quot;)
    public void openCloseBadOpen() {
<span class="fc" id="L2367">        List&lt;Throwable&gt; errors = TestHelper.trackPluginErrors();</span>
        try {
<span class="fc" id="L2369">            Flowable.never()</span>
<span class="fc" id="L2370">            .buffer(new Flowable&lt;Object&gt;() {</span>
                @Override
                protected void subscribeActual(Subscriber&lt;? super Object&gt; s) {

<span class="fc" id="L2374">                    assertFalse(((Disposable)s).isDisposed());</span>

<span class="fc" id="L2376">                    BooleanSubscription bs1 = new BooleanSubscription();</span>
<span class="fc" id="L2377">                    BooleanSubscription bs2 = new BooleanSubscription();</span>

<span class="fc" id="L2379">                    s.onSubscribe(bs1);</span>

<span class="fc" id="L2381">                    assertFalse(bs1.isCancelled());</span>
<span class="fc" id="L2382">                    assertFalse(bs2.isCancelled());</span>

<span class="fc" id="L2384">                    s.onSubscribe(bs2);</span>

<span class="fc" id="L2386">                    assertFalse(bs1.isCancelled());</span>
<span class="fc" id="L2387">                    assertTrue(bs2.isCancelled());</span>

<span class="fc" id="L2389">                    s.onError(new IOException());</span>

<span class="fc" id="L2391">                    assertTrue(((Disposable)s).isDisposed());</span>

<span class="fc" id="L2393">                    s.onComplete();</span>
<span class="fc" id="L2394">                    s.onNext(1);</span>
<span class="fc" id="L2395">                    s.onError(new TestException());</span>
<span class="fc" id="L2396">                }</span>
<span class="fc" id="L2397">            }, Functions.justFunction(Flowable.never()))</span>
<span class="fc" id="L2398">            .test()</span>
<span class="fc" id="L2399">            .assertFailure(IOException.class);</span>

<span class="fc" id="L2401">            TestHelper.assertError(errors, 0, ProtocolViolationException.class);</span>
<span class="fc" id="L2402">            TestHelper.assertUndeliverable(errors, 1, TestException.class);</span>
        } finally {
<span class="fc" id="L2404">            RxJavaPlugins.reset();</span>
        }
<span class="fc" id="L2406">    }</span>

    @Test
    @SuppressWarnings(&quot;unchecked&quot;)
    public void openCloseBadClose() {
<span class="fc" id="L2411">        List&lt;Throwable&gt; errors = TestHelper.trackPluginErrors();</span>
        try {
<span class="fc" id="L2413">            Flowable.never()</span>
<span class="fc" id="L2414">            .buffer(Flowable.just(1).concatWith(Flowable.&lt;Integer&gt;never()),</span>
<span class="fc" id="L2415">                    Functions.justFunction(new Flowable&lt;Object&gt;() {</span>
                @Override
                protected void subscribeActual(Subscriber&lt;? super Object&gt; s) {

<span class="fc" id="L2419">                    assertFalse(((Disposable)s).isDisposed());</span>

<span class="fc" id="L2421">                    BooleanSubscription bs1 = new BooleanSubscription();</span>
<span class="fc" id="L2422">                    BooleanSubscription bs2 = new BooleanSubscription();</span>

<span class="fc" id="L2424">                    s.onSubscribe(bs1);</span>

<span class="fc" id="L2426">                    assertFalse(bs1.isCancelled());</span>
<span class="fc" id="L2427">                    assertFalse(bs2.isCancelled());</span>

<span class="fc" id="L2429">                    s.onSubscribe(bs2);</span>

<span class="fc" id="L2431">                    assertFalse(bs1.isCancelled());</span>
<span class="fc" id="L2432">                    assertTrue(bs2.isCancelled());</span>

<span class="fc" id="L2434">                    s.onError(new IOException());</span>

<span class="fc" id="L2436">                    assertTrue(((Disposable)s).isDisposed());</span>

<span class="fc" id="L2438">                    s.onComplete();</span>
<span class="fc" id="L2439">                    s.onNext(1);</span>
<span class="fc" id="L2440">                    s.onError(new TestException());</span>
<span class="fc" id="L2441">                }</span>
            }))
<span class="fc" id="L2443">            .test()</span>
<span class="fc" id="L2444">            .assertFailure(IOException.class);</span>

<span class="fc" id="L2446">            TestHelper.assertError(errors, 0, ProtocolViolationException.class);</span>
<span class="fc" id="L2447">            TestHelper.assertUndeliverable(errors, 1, TestException.class);</span>
        } finally {
<span class="fc" id="L2449">            RxJavaPlugins.reset();</span>
        }
<span class="fc" id="L2451">    }</span>

    @Test
    public void bufferExactBoundaryDoubleOnSubscribe() {
<span class="fc" id="L2455">        TestHelper.checkDoubleOnSubscribeFlowable(</span>
<span class="fc" id="L2456">                new Function&lt;Flowable&lt;Object&gt;, Flowable&lt;List&lt;Object&gt;&gt;&gt;() {</span>
                    @Override
                    public Flowable&lt;List&lt;Object&gt;&gt; apply(Flowable&lt;Object&gt; f)
                            throws Exception {
<span class="fc" id="L2460">                        return f.buffer(Flowable.never());</span>
                    }
                }
        );
<span class="fc" id="L2464">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void bufferExactBoundarySecondBufferCrash() {
<span class="fc" id="L2469">        PublishProcessor&lt;Integer&gt; pp = PublishProcessor.create();</span>
<span class="fc" id="L2470">        PublishProcessor&lt;Integer&gt; b = PublishProcessor.create();</span>

<span class="fc" id="L2472">        TestSubscriber&lt;List&lt;Integer&gt;&gt; ts = pp.buffer(b, new Callable&lt;List&lt;Integer&gt;&gt;() {</span>
            int calls;
            @Override
            public List&lt;Integer&gt; call() throws Exception {
<span class="fc bfc" id="L2476" title="All 2 branches covered.">                if (++calls == 2) {</span>
<span class="fc" id="L2477">                    throw new TestException();</span>
                }
<span class="fc" id="L2479">                return new ArrayList&lt;Integer&gt;();</span>
            }
<span class="fc" id="L2481">        }).test();</span>

<span class="fc" id="L2483">        b.onNext(1);</span>

<span class="fc" id="L2485">        ts.assertFailure(TestException.class);</span>
<span class="fc" id="L2486">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void bufferExactBoundaryBadSource() {
<span class="fc" id="L2491">        Flowable&lt;Integer&gt; pp = new Flowable&lt;Integer&gt;() {</span>
            @Override
            protected void subscribeActual(Subscriber&lt;? super Integer&gt; subscriber) {
<span class="fc" id="L2494">                subscriber.onSubscribe(new BooleanSubscription());</span>
<span class="fc" id="L2495">                subscriber.onComplete();</span>
<span class="fc" id="L2496">                subscriber.onNext(1);</span>
<span class="fc" id="L2497">                subscriber.onComplete();</span>
<span class="fc" id="L2498">            }</span>
        };

<span class="fc" id="L2501">        final AtomicReference&lt;Subscriber&lt;? super Integer&gt;&gt; ref = new AtomicReference&lt;Subscriber&lt;? super Integer&gt;&gt;();</span>
<span class="fc" id="L2502">        Flowable&lt;Integer&gt; b = new Flowable&lt;Integer&gt;() {</span>
            @Override
            protected void subscribeActual(Subscriber&lt;? super Integer&gt; subscriber) {
<span class="fc" id="L2505">                subscriber.onSubscribe(new BooleanSubscription());</span>
<span class="fc" id="L2506">                ref.set(subscriber);</span>
<span class="fc" id="L2507">            }</span>
        };

<span class="fc" id="L2510">        TestSubscriber&lt;List&lt;Integer&gt;&gt; ts = pp.buffer(b).test();</span>

<span class="fc" id="L2512">        ref.get().onNext(1);</span>

<span class="fc" id="L2514">        ts.assertResult(Collections.&lt;Integer&gt;emptyList());</span>
<span class="fc" id="L2515">    }</span>

    @Test
    public void bufferExactBoundaryCancelUpfront() {
<span class="fc" id="L2519">        PublishProcessor&lt;Integer&gt; pp = PublishProcessor.create();</span>
<span class="fc" id="L2520">        PublishProcessor&lt;Integer&gt; b = PublishProcessor.create();</span>

<span class="fc" id="L2522">        pp.buffer(b).test(0L, true)</span>
<span class="fc" id="L2523">        .assertEmpty();</span>

<span class="fc" id="L2525">        assertFalse(pp.hasSubscribers());</span>
<span class="fc" id="L2526">        assertFalse(b.hasSubscribers());</span>
<span class="fc" id="L2527">    }</span>

    @Test
    public void bufferExactBoundaryDisposed() {
<span class="fc" id="L2531">        Flowable&lt;Integer&gt; pp = new Flowable&lt;Integer&gt;() {</span>
            @Override
            protected void subscribeActual(Subscriber&lt;? super Integer&gt; s) {
<span class="fc" id="L2534">                s.onSubscribe(new BooleanSubscription());</span>

<span class="fc" id="L2536">                Disposable d = (Disposable)s;</span>

<span class="fc" id="L2538">                assertFalse(d.isDisposed());</span>

<span class="fc" id="L2540">                d.dispose();</span>

<span class="fc" id="L2542">                assertTrue(d.isDisposed());</span>
<span class="fc" id="L2543">            }</span>
        };
<span class="fc" id="L2545">        PublishProcessor&lt;Integer&gt; b = PublishProcessor.create();</span>

<span class="fc" id="L2547">        pp.buffer(b).test();</span>
<span class="fc" id="L2548">    }</span>

    @Test
    public void bufferBoundaryErrorTwice() {
<span class="fc" id="L2552">        List&lt;Throwable&gt; errors = TestHelper.trackPluginErrors();</span>
        try {
<span class="fc" id="L2554">            BehaviorProcessor.createDefault(1)</span>
<span class="fc" id="L2555">            .buffer(Functions.justCallable(new Flowable&lt;Integer&gt;() {</span>
                @Override
                protected void subscribeActual(Subscriber&lt;? super Integer&gt; s) {
<span class="fc" id="L2558">                    s.onSubscribe(new BooleanSubscription());</span>
<span class="fc" id="L2559">                    s.onError(new TestException(&quot;first&quot;));</span>
<span class="fc" id="L2560">                    s.onError(new TestException(&quot;second&quot;));</span>
<span class="fc" id="L2561">                }</span>
            }))
<span class="fc" id="L2563">            .test()</span>
<span class="fc" id="L2564">            .assertError(TestException.class)</span>
<span class="fc" id="L2565">            .assertErrorMessage(&quot;first&quot;)</span>
<span class="fc" id="L2566">            .assertNotComplete();</span>

<span class="fc" id="L2568">            TestHelper.assertUndeliverable(errors, 0, TestException.class, &quot;second&quot;);</span>
        } finally {
<span class="fc" id="L2570">            RxJavaPlugins.reset();</span>
        }
<span class="fc" id="L2572">    }</span>

    @Test
    public void bufferBoundarySupplierDisposed() {
<span class="fc" id="L2576">        TestSubscriber&lt;List&lt;Integer&gt;&gt; ts = new TestSubscriber&lt;List&lt;Integer&gt;&gt;();</span>
<span class="fc" id="L2577">        BufferBoundarySupplierSubscriber&lt;Integer, List&lt;Integer&gt;, Integer&gt; sub =</span>
                new BufferBoundarySupplierSubscriber&lt;Integer, List&lt;Integer&gt;, Integer&gt;(
<span class="fc" id="L2579">                        ts, Functions.justCallable((List&lt;Integer&gt;)new ArrayList&lt;Integer&gt;()),</span>
<span class="fc" id="L2580">                        Functions.justCallable(Flowable.&lt;Integer&gt;never())</span>
        );

<span class="fc" id="L2583">        BooleanSubscription bs = new BooleanSubscription();</span>

<span class="fc" id="L2585">        sub.onSubscribe(bs);</span>

<span class="fc" id="L2587">        assertFalse(sub.isDisposed());</span>

<span class="fc" id="L2589">        sub.dispose();</span>

<span class="fc" id="L2591">        assertTrue(sub.isDisposed());</span>

<span class="fc" id="L2593">        sub.next();</span>

<span class="fc" id="L2595">        assertSame(DisposableHelper.DISPOSED, sub.other.get());</span>

<span class="fc" id="L2597">        sub.cancel();</span>
<span class="fc" id="L2598">        sub.cancel();</span>

<span class="fc" id="L2600">        assertTrue(bs.isCancelled());</span>
<span class="fc" id="L2601">    }</span>

    @Test
    public void bufferBoundarySupplierBufferAlreadyCleared() {
<span class="fc" id="L2605">        TestSubscriber&lt;List&lt;Integer&gt;&gt; ts = new TestSubscriber&lt;List&lt;Integer&gt;&gt;();</span>
<span class="fc" id="L2606">        BufferBoundarySupplierSubscriber&lt;Integer, List&lt;Integer&gt;, Integer&gt; sub =</span>
                new BufferBoundarySupplierSubscriber&lt;Integer, List&lt;Integer&gt;, Integer&gt;(
<span class="fc" id="L2608">                        ts, Functions.justCallable((List&lt;Integer&gt;)new ArrayList&lt;Integer&gt;()),</span>
<span class="fc" id="L2609">                        Functions.justCallable(Flowable.&lt;Integer&gt;never())</span>
        );

<span class="fc" id="L2612">        BooleanSubscription bs = new BooleanSubscription();</span>

<span class="fc" id="L2614">        sub.onSubscribe(bs);</span>

<span class="fc" id="L2616">        sub.buffer = null;</span>

<span class="fc" id="L2618">        sub.next();</span>

<span class="fc" id="L2620">        sub.onNext(1);</span>

<span class="fc" id="L2622">        sub.onComplete();</span>
<span class="fc" id="L2623">    }</span>

    @Test
    public void timedDoubleOnSubscribe() {
<span class="fc" id="L2627">        TestHelper.checkDoubleOnSubscribeFlowable(new Function&lt;Flowable&lt;Object&gt;, Publisher&lt;List&lt;Object&gt;&gt;&gt;() {</span>
            @Override
            public Publisher&lt;List&lt;Object&gt;&gt; apply(Flowable&lt;Object&gt; f)
                    throws Exception {
<span class="fc" id="L2631">                return f.buffer(1, TimeUnit.SECONDS);</span>
            }
        });
<span class="fc" id="L2634">    }</span>

    @Test
    public void timedCancelledUpfront() {
<span class="fc" id="L2638">        TestScheduler sch = new TestScheduler();</span>

<span class="fc" id="L2640">        TestSubscriber&lt;List&lt;Object&gt;&gt; ts = Flowable.never()</span>
<span class="fc" id="L2641">        .buffer(1, TimeUnit.MILLISECONDS, sch)</span>
<span class="fc" id="L2642">        .test(1L, true);</span>

<span class="fc" id="L2644">        sch.advanceTimeBy(1, TimeUnit.MILLISECONDS);</span>

<span class="fc" id="L2646">        ts.assertEmpty();</span>
<span class="fc" id="L2647">    }</span>

    @Test
    public void timedInternalState() {
<span class="fc" id="L2651">        TestScheduler sch = new TestScheduler();</span>

<span class="fc" id="L2653">        TestSubscriber&lt;List&lt;Integer&gt;&gt; ts = new TestSubscriber&lt;List&lt;Integer&gt;&gt;();</span>

<span class="fc" id="L2655">        BufferExactUnboundedSubscriber&lt;Integer, List&lt;Integer&gt;&gt; sub = new BufferExactUnboundedSubscriber&lt;Integer, List&lt;Integer&gt;&gt;(</span>
<span class="fc" id="L2656">                ts, Functions.justCallable((List&lt;Integer&gt;)new ArrayList&lt;Integer&gt;()), 1, TimeUnit.SECONDS, sch);</span>

<span class="fc" id="L2658">        sub.onSubscribe(new BooleanSubscription());</span>

<span class="fc" id="L2660">        assertFalse(sub.isDisposed());</span>

<span class="fc" id="L2662">        sub.onError(new TestException());</span>
<span class="fc" id="L2663">        sub.onNext(1);</span>
<span class="fc" id="L2664">        sub.onComplete();</span>

<span class="fc" id="L2666">        sub.run();</span>

<span class="fc" id="L2668">        sub.dispose();</span>

<span class="fc" id="L2670">        assertTrue(sub.isDisposed());</span>

<span class="fc" id="L2672">        sub.buffer = new ArrayList&lt;Integer&gt;();</span>
<span class="fc" id="L2673">        sub.enter();</span>
<span class="fc" id="L2674">        sub.onComplete();</span>
<span class="fc" id="L2675">    }</span>

    @Test
    public void timedSkipDoubleOnSubscribe() {
<span class="fc" id="L2679">        TestHelper.checkDoubleOnSubscribeFlowable(new Function&lt;Flowable&lt;Object&gt;, Publisher&lt;List&lt;Object&gt;&gt;&gt;() {</span>
            @Override
            public Publisher&lt;List&lt;Object&gt;&gt; apply(Flowable&lt;Object&gt; f)
                    throws Exception {
<span class="fc" id="L2683">                return f.buffer(2, 1, TimeUnit.SECONDS);</span>
            }
        });
<span class="fc" id="L2686">    }</span>

    @Test
    public void timedSizedDoubleOnSubscribe() {
<span class="fc" id="L2690">        TestHelper.checkDoubleOnSubscribeFlowable(new Function&lt;Flowable&lt;Object&gt;, Publisher&lt;List&lt;Object&gt;&gt;&gt;() {</span>
            @Override
            public Publisher&lt;List&lt;Object&gt;&gt; apply(Flowable&lt;Object&gt; f)
                    throws Exception {
<span class="fc" id="L2694">                return f.buffer(2, TimeUnit.SECONDS, 10);</span>
            }
        });
<span class="fc" id="L2697">    }</span>

    @Test
    public void timedSkipInternalState() {
<span class="fc" id="L2701">        TestScheduler sch = new TestScheduler();</span>

<span class="fc" id="L2703">        TestSubscriber&lt;List&lt;Integer&gt;&gt; ts = new TestSubscriber&lt;List&lt;Integer&gt;&gt;();</span>

<span class="fc" id="L2705">        BufferSkipBoundedSubscriber&lt;Integer, List&lt;Integer&gt;&gt; sub = new BufferSkipBoundedSubscriber&lt;Integer, List&lt;Integer&gt;&gt;(</span>
<span class="fc" id="L2706">                ts, Functions.justCallable((List&lt;Integer&gt;)new ArrayList&lt;Integer&gt;()), 1, 1, TimeUnit.SECONDS, sch.createWorker());</span>

<span class="fc" id="L2708">        sub.onSubscribe(new BooleanSubscription());</span>

<span class="fc" id="L2710">        sub.enter();</span>
<span class="fc" id="L2711">        sub.onComplete();</span>

<span class="fc" id="L2713">        sub.cancel();</span>

<span class="fc" id="L2715">        sub.run();</span>
<span class="fc" id="L2716">    }</span>

    @Test
    public void timedSkipCancelWhenSecondBuffer() {
<span class="fc" id="L2720">        TestScheduler sch = new TestScheduler();</span>

<span class="fc" id="L2722">        final TestSubscriber&lt;List&lt;Integer&gt;&gt; ts = new TestSubscriber&lt;List&lt;Integer&gt;&gt;();</span>

<span class="fc" id="L2724">        BufferSkipBoundedSubscriber&lt;Integer, List&lt;Integer&gt;&gt; sub = new BufferSkipBoundedSubscriber&lt;Integer, List&lt;Integer&gt;&gt;(</span>
<span class="fc" id="L2725">                ts, new Callable&lt;List&lt;Integer&gt;&gt;() {</span>
                    int calls;
                    @Override
                    public List&lt;Integer&gt; call() throws Exception {
<span class="fc bfc" id="L2729" title="All 2 branches covered.">                        if (++calls == 2) {</span>
<span class="fc" id="L2730">                            ts.cancel();</span>
                        }
<span class="fc" id="L2732">                        return new ArrayList&lt;Integer&gt;();</span>
                    }
<span class="fc" id="L2734">                }, 1, 1, TimeUnit.SECONDS, sch.createWorker());</span>

<span class="fc" id="L2736">        sub.onSubscribe(new BooleanSubscription());</span>

<span class="fc" id="L2738">        sub.run();</span>

<span class="fc" id="L2740">        assertTrue(ts.isCancelled());</span>
<span class="fc" id="L2741">    }</span>

    @Test
    public void timedSizeBufferAlreadyCleared() {
<span class="fc" id="L2745">        TestScheduler sch = new TestScheduler();</span>

<span class="fc" id="L2747">        TestSubscriber&lt;List&lt;Integer&gt;&gt; ts = new TestSubscriber&lt;List&lt;Integer&gt;&gt;();</span>

<span class="fc" id="L2749">        BufferExactBoundedSubscriber&lt;Integer, List&lt;Integer&gt;&gt; sub =</span>
                new BufferExactBoundedSubscriber&lt;Integer, List&lt;Integer&gt;&gt;(
<span class="fc" id="L2751">                        ts, Functions.justCallable((List&lt;Integer&gt;)new ArrayList&lt;Integer&gt;()),</span>
<span class="fc" id="L2752">                        1, TimeUnit.SECONDS, 1, false, sch.createWorker())</span>
        ;

<span class="fc" id="L2755">        BooleanSubscription bs = new BooleanSubscription();</span>

<span class="fc" id="L2757">        sub.onSubscribe(bs);</span>

<span class="fc" id="L2759">        sub.producerIndex++;</span>

<span class="fc" id="L2761">        sub.run();</span>

<span class="fc" id="L2763">        assertFalse(sub.isDisposed());</span>

<span class="fc" id="L2765">        sub.enter();</span>
<span class="fc" id="L2766">        sub.onComplete();</span>

<span class="fc" id="L2768">        assertTrue(sub.isDisposed());</span>

<span class="fc" id="L2770">        sub.run();</span>
<span class="fc" id="L2771">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>