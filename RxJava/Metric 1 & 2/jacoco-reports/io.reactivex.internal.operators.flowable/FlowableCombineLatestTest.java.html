<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FlowableCombineLatestTest.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">RxJava_2_x$Unnamed.exec</a> &gt; <a href="index.source.html" class="el_package">io.reactivex.internal.operators.flowable</a> &gt; <span class="el_source">FlowableCombineLatestTest.java</span></div><h1>FlowableCombineLatestTest.java</h1><pre class="source lang-java linenums">/**
 * Copyright (c) 2016-present, RxJava Contributors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is
 * distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
 * the License for the specific language governing permissions and limitations under the License.
 */

package io.reactivex.internal.operators.flowable;

import static org.junit.Assert.*;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;

import java.lang.reflect.*;
import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.*;

import org.junit.*;
import org.mockito.*;
import org.reactivestreams.*;

import io.reactivex.*;
import io.reactivex.exceptions.*;
import io.reactivex.functions.*;
import io.reactivex.internal.functions.Functions;
import io.reactivex.internal.fuseable.QueueFuseable;
import io.reactivex.internal.operators.flowable.FlowableZipTest.ArgsToString;
import io.reactivex.plugins.RxJavaPlugins;
import io.reactivex.processors.PublishProcessor;
import io.reactivex.schedulers.*;
import io.reactivex.subscribers.*;

<span class="fc" id="L40">public class FlowableCombineLatestTest {</span>

    @Test
    public void testCombineLatestWithFunctionThatThrowsAnException() {
<span class="fc" id="L44">        Subscriber&lt;String&gt; w = TestHelper.mockSubscriber();</span>

<span class="fc" id="L46">        PublishProcessor&lt;String&gt; w1 = PublishProcessor.create();</span>
<span class="fc" id="L47">        PublishProcessor&lt;String&gt; w2 = PublishProcessor.create();</span>

<span class="fc" id="L49">        Flowable&lt;String&gt; combined = Flowable.combineLatest(w1, w2, new BiFunction&lt;String, String, String&gt;() {</span>
            @Override
            public String apply(String v1, String v2) {
<span class="fc" id="L52">                throw new RuntimeException(&quot;I don't work.&quot;);</span>
            }
        });
<span class="fc" id="L55">        combined.subscribe(w);</span>

<span class="fc" id="L57">        w1.onNext(&quot;first value of w1&quot;);</span>
<span class="fc" id="L58">        w2.onNext(&quot;first value of w2&quot;);</span>

<span class="fc" id="L60">        verify(w, never()).onNext(anyString());</span>
<span class="fc" id="L61">        verify(w, never()).onComplete();</span>
<span class="fc" id="L62">        verify(w, times(1)).onError(Mockito.&lt;RuntimeException&gt; any());</span>
<span class="fc" id="L63">    }</span>

    @Test
    public void testCombineLatestDifferentLengthFlowableSequences1() {
<span class="fc" id="L67">        Subscriber&lt;String&gt; w = TestHelper.mockSubscriber();</span>

<span class="fc" id="L69">        PublishProcessor&lt;String&gt; w1 = PublishProcessor.create();</span>
<span class="fc" id="L70">        PublishProcessor&lt;String&gt; w2 = PublishProcessor.create();</span>
<span class="fc" id="L71">        PublishProcessor&lt;String&gt; w3 = PublishProcessor.create();</span>

<span class="fc" id="L73">        Flowable&lt;String&gt; combineLatestW = Flowable.combineLatest(w1, w2, w3,</span>
<span class="fc" id="L74">                getConcat3StringsCombineLatestFunction());</span>
<span class="fc" id="L75">        combineLatestW.subscribe(w);</span>

        /* simulate sending data */
        // once for w1
<span class="fc" id="L79">        w1.onNext(&quot;1a&quot;);</span>
<span class="fc" id="L80">        w2.onNext(&quot;2a&quot;);</span>
<span class="fc" id="L81">        w3.onNext(&quot;3a&quot;);</span>
<span class="fc" id="L82">        w1.onComplete();</span>
        // twice for w2
<span class="fc" id="L84">        w2.onNext(&quot;2b&quot;);</span>
<span class="fc" id="L85">        w2.onComplete();</span>
        // 4 times for w3
<span class="fc" id="L87">        w3.onNext(&quot;3b&quot;);</span>
<span class="fc" id="L88">        w3.onNext(&quot;3c&quot;);</span>
<span class="fc" id="L89">        w3.onNext(&quot;3d&quot;);</span>
<span class="fc" id="L90">        w3.onComplete();</span>

        /* we should have been called 4 times on the Observer */
<span class="fc" id="L93">        InOrder inOrder = inOrder(w);</span>
<span class="fc" id="L94">        inOrder.verify(w).onNext(&quot;1a2a3a&quot;);</span>
<span class="fc" id="L95">        inOrder.verify(w).onNext(&quot;1a2b3a&quot;);</span>
<span class="fc" id="L96">        inOrder.verify(w).onNext(&quot;1a2b3b&quot;);</span>
<span class="fc" id="L97">        inOrder.verify(w).onNext(&quot;1a2b3c&quot;);</span>
<span class="fc" id="L98">        inOrder.verify(w).onNext(&quot;1a2b3d&quot;);</span>
<span class="fc" id="L99">        inOrder.verify(w, never()).onNext(anyString());</span>
<span class="fc" id="L100">        inOrder.verify(w, times(1)).onComplete();</span>
<span class="fc" id="L101">    }</span>

    @Test
    public void testCombineLatestDifferentLengthFlowableSequences2() {
<span class="fc" id="L105">        Subscriber&lt;String&gt; w = TestHelper.mockSubscriber();</span>

<span class="fc" id="L107">        PublishProcessor&lt;String&gt; w1 = PublishProcessor.create();</span>
<span class="fc" id="L108">        PublishProcessor&lt;String&gt; w2 = PublishProcessor.create();</span>
<span class="fc" id="L109">        PublishProcessor&lt;String&gt; w3 = PublishProcessor.create();</span>

<span class="fc" id="L111">        Flowable&lt;String&gt; combineLatestW = Flowable.combineLatest(w1, w2, w3, getConcat3StringsCombineLatestFunction());</span>
<span class="fc" id="L112">        combineLatestW.subscribe(w);</span>

        /* simulate sending data */
        // 4 times for w1
<span class="fc" id="L116">        w1.onNext(&quot;1a&quot;);</span>
<span class="fc" id="L117">        w1.onNext(&quot;1b&quot;);</span>
<span class="fc" id="L118">        w1.onNext(&quot;1c&quot;);</span>
<span class="fc" id="L119">        w1.onNext(&quot;1d&quot;);</span>
<span class="fc" id="L120">        w1.onComplete();</span>
        // twice for w2
<span class="fc" id="L122">        w2.onNext(&quot;2a&quot;);</span>
<span class="fc" id="L123">        w2.onNext(&quot;2b&quot;);</span>
<span class="fc" id="L124">        w2.onComplete();</span>
        // 1 times for w3
<span class="fc" id="L126">        w3.onNext(&quot;3a&quot;);</span>
<span class="fc" id="L127">        w3.onComplete();</span>

        /* we should have been called 1 time only on the Observer since we only combine the &quot;latest&quot; we don't go back and loop through others once completed */
<span class="fc" id="L130">        InOrder inOrder = inOrder(w);</span>
<span class="fc" id="L131">        inOrder.verify(w, times(1)).onNext(&quot;1d2b3a&quot;);</span>
<span class="fc" id="L132">        inOrder.verify(w, never()).onNext(anyString());</span>

<span class="fc" id="L134">        inOrder.verify(w, times(1)).onComplete();</span>

<span class="fc" id="L136">    }</span>

    @Test
    public void testCombineLatestWithInterleavingSequences() {
<span class="fc" id="L140">        Subscriber&lt;String&gt; w = TestHelper.mockSubscriber();</span>

<span class="fc" id="L142">        PublishProcessor&lt;String&gt; w1 = PublishProcessor.create();</span>
<span class="fc" id="L143">        PublishProcessor&lt;String&gt; w2 = PublishProcessor.create();</span>
<span class="fc" id="L144">        PublishProcessor&lt;String&gt; w3 = PublishProcessor.create();</span>

<span class="fc" id="L146">        Flowable&lt;String&gt; combineLatestW = Flowable.combineLatest(w1, w2, w3, getConcat3StringsCombineLatestFunction());</span>
<span class="fc" id="L147">        combineLatestW.subscribe(w);</span>

        /* simulate sending data */
<span class="fc" id="L150">        w1.onNext(&quot;1a&quot;);</span>
<span class="fc" id="L151">        w2.onNext(&quot;2a&quot;);</span>
<span class="fc" id="L152">        w2.onNext(&quot;2b&quot;);</span>
<span class="fc" id="L153">        w3.onNext(&quot;3a&quot;);</span>

<span class="fc" id="L155">        w1.onNext(&quot;1b&quot;);</span>
<span class="fc" id="L156">        w2.onNext(&quot;2c&quot;);</span>
<span class="fc" id="L157">        w2.onNext(&quot;2d&quot;);</span>
<span class="fc" id="L158">        w3.onNext(&quot;3b&quot;);</span>

<span class="fc" id="L160">        w1.onComplete();</span>
<span class="fc" id="L161">        w2.onComplete();</span>
<span class="fc" id="L162">        w3.onComplete();</span>

        /* we should have been called 5 times on the Observer */
<span class="fc" id="L165">        InOrder inOrder = inOrder(w);</span>
<span class="fc" id="L166">        inOrder.verify(w).onNext(&quot;1a2b3a&quot;);</span>
<span class="fc" id="L167">        inOrder.verify(w).onNext(&quot;1b2b3a&quot;);</span>
<span class="fc" id="L168">        inOrder.verify(w).onNext(&quot;1b2c3a&quot;);</span>
<span class="fc" id="L169">        inOrder.verify(w).onNext(&quot;1b2d3a&quot;);</span>
<span class="fc" id="L170">        inOrder.verify(w).onNext(&quot;1b2d3b&quot;);</span>

<span class="fc" id="L172">        inOrder.verify(w, never()).onNext(anyString());</span>
<span class="fc" id="L173">        inOrder.verify(w, times(1)).onComplete();</span>
<span class="fc" id="L174">    }</span>

    @Test
    public void testCombineLatest2Types() {
<span class="fc" id="L178">        BiFunction&lt;String, Integer, String&gt; combineLatestFunction = getConcatStringIntegerCombineLatestFunction();</span>

        /* define an Observer to receive aggregated events */
<span class="fc" id="L181">        Subscriber&lt;String&gt; subscriber = TestHelper.mockSubscriber();</span>

<span class="fc" id="L183">        Flowable&lt;String&gt; w = Flowable.combineLatest(Flowable.just(&quot;one&quot;, &quot;two&quot;), Flowable.just(2, 3, 4), combineLatestFunction);</span>
<span class="fc" id="L184">        w.subscribe(subscriber);</span>

<span class="fc" id="L186">        verify(subscriber, never()).onError(any(Throwable.class));</span>
<span class="fc" id="L187">        verify(subscriber, times(1)).onComplete();</span>
<span class="fc" id="L188">        verify(subscriber, times(1)).onNext(&quot;two2&quot;);</span>
<span class="fc" id="L189">        verify(subscriber, times(1)).onNext(&quot;two3&quot;);</span>
<span class="fc" id="L190">        verify(subscriber, times(1)).onNext(&quot;two4&quot;);</span>
<span class="fc" id="L191">    }</span>

    @Test
    public void testCombineLatest3TypesA() {
<span class="fc" id="L195">        Function3&lt;String, Integer, int[], String&gt; combineLatestFunction = getConcatStringIntegerIntArrayCombineLatestFunction();</span>

        /* define an Observer to receive aggregated events */
<span class="fc" id="L198">        Subscriber&lt;String&gt; subscriber = TestHelper.mockSubscriber();</span>

<span class="fc" id="L200">        Flowable&lt;String&gt; w = Flowable.combineLatest(Flowable.just(&quot;one&quot;, &quot;two&quot;), Flowable.just(2), Flowable.just(new int[] { 4, 5, 6 }), combineLatestFunction);</span>
<span class="fc" id="L201">        w.subscribe(subscriber);</span>

<span class="fc" id="L203">        verify(subscriber, never()).onError(any(Throwable.class));</span>
<span class="fc" id="L204">        verify(subscriber, times(1)).onComplete();</span>
<span class="fc" id="L205">        verify(subscriber, times(1)).onNext(&quot;two2[4, 5, 6]&quot;);</span>
<span class="fc" id="L206">    }</span>

    @Test
    public void testCombineLatest3TypesB() {
<span class="fc" id="L210">        Function3&lt;String, Integer, int[], String&gt; combineLatestFunction = getConcatStringIntegerIntArrayCombineLatestFunction();</span>

        /* define an Observer to receive aggregated events */
<span class="fc" id="L213">        Subscriber&lt;String&gt; subscriber = TestHelper.mockSubscriber();</span>

<span class="fc" id="L215">        Flowable&lt;String&gt; w = Flowable.combineLatest(Flowable.just(&quot;one&quot;), Flowable.just(2), Flowable.just(new int[] { 4, 5, 6 }, new int[] { 7, 8 }), combineLatestFunction);</span>
<span class="fc" id="L216">        w.subscribe(subscriber);</span>

<span class="fc" id="L218">        verify(subscriber, never()).onError(any(Throwable.class));</span>
<span class="fc" id="L219">        verify(subscriber, times(1)).onComplete();</span>
<span class="fc" id="L220">        verify(subscriber, times(1)).onNext(&quot;one2[4, 5, 6]&quot;);</span>
<span class="fc" id="L221">        verify(subscriber, times(1)).onNext(&quot;one2[7, 8]&quot;);</span>
<span class="fc" id="L222">    }</span>

    private Function3&lt;String, String, String, String&gt; getConcat3StringsCombineLatestFunction() {
<span class="fc" id="L225">        Function3&lt;String, String, String, String&gt; combineLatestFunction = new Function3&lt;String, String, String, String&gt;() {</span>
            @Override
            public String apply(String a1, String a2, String a3) {
<span class="pc bpc" id="L228" title="1 of 2 branches missed.">                if (a1 == null) {</span>
<span class="nc" id="L229">                    a1 = &quot;&quot;;</span>
                }
<span class="pc bpc" id="L231" title="1 of 2 branches missed.">                if (a2 == null) {</span>
<span class="nc" id="L232">                    a2 = &quot;&quot;;</span>
                }
<span class="pc bpc" id="L234" title="1 of 2 branches missed.">                if (a3 == null) {</span>
<span class="nc" id="L235">                    a3 = &quot;&quot;;</span>
                }
<span class="fc" id="L237">                return a1 + a2 + a3;</span>
            }
        };
<span class="fc" id="L240">        return combineLatestFunction;</span>
    }

    private BiFunction&lt;String, Integer, String&gt; getConcatStringIntegerCombineLatestFunction() {
<span class="fc" id="L244">        BiFunction&lt;String, Integer, String&gt; combineLatestFunction = new BiFunction&lt;String, Integer, String&gt;() {</span>
            @Override
            public String apply(String s, Integer i) {
<span class="fc" id="L247">                return getStringValue(s) + getStringValue(i);</span>
            }
        };
<span class="fc" id="L250">        return combineLatestFunction;</span>
    }

    private Function3&lt;String, Integer, int[], String&gt; getConcatStringIntegerIntArrayCombineLatestFunction() {
<span class="fc" id="L254">        return new Function3&lt;String, Integer, int[], String&gt;() {</span>
            @Override
            public String apply(String s, Integer i, int[] iArray) {
<span class="fc" id="L257">                return getStringValue(s) + getStringValue(i) + getStringValue(iArray);</span>
            }
        };
    }

    private static String getStringValue(Object o) {
<span class="pc bpc" id="L263" title="1 of 2 branches missed.">        if (o == null) {</span>
<span class="nc" id="L264">            return &quot;&quot;;</span>
        } else {
<span class="fc bfc" id="L266" title="All 2 branches covered.">            if (o instanceof int[]) {</span>
<span class="fc" id="L267">                return Arrays.toString((int[]) o);</span>
            } else {
<span class="fc" id="L269">                return String.valueOf(o);</span>
            }
        }
    }

<span class="fc" id="L274">    BiFunction&lt;Integer, Integer, Integer&gt; or = new BiFunction&lt;Integer, Integer, Integer&gt;() {</span>
        @Override
        public Integer apply(Integer t1, Integer t2) {
<span class="fc" id="L277">            return t1 | t2;</span>
        }
    };

    @Test
    public void combineSimple() {
<span class="fc" id="L283">        PublishProcessor&lt;Integer&gt; a = PublishProcessor.create();</span>
<span class="fc" id="L284">        PublishProcessor&lt;Integer&gt; b = PublishProcessor.create();</span>

<span class="fc" id="L286">        Flowable&lt;Integer&gt; source = Flowable.combineLatest(a, b, or);</span>

<span class="fc" id="L288">        Subscriber&lt;Object&gt; subscriber = TestHelper.mockSubscriber();</span>
<span class="fc" id="L289">        InOrder inOrder = inOrder(subscriber);</span>

<span class="fc" id="L291">        source.subscribe(subscriber);</span>

<span class="fc" id="L293">        a.onNext(1);</span>

<span class="fc" id="L295">        inOrder.verify(subscriber, never()).onNext(any());</span>

<span class="fc" id="L297">        a.onNext(2);</span>

<span class="fc" id="L299">        inOrder.verify(subscriber, never()).onNext(any());</span>

<span class="fc" id="L301">        b.onNext(0x10);</span>

<span class="fc" id="L303">        inOrder.verify(subscriber, times(1)).onNext(0x12);</span>

<span class="fc" id="L305">        b.onNext(0x20);</span>
<span class="fc" id="L306">        inOrder.verify(subscriber, times(1)).onNext(0x22);</span>

<span class="fc" id="L308">        b.onComplete();</span>

<span class="fc" id="L310">        inOrder.verify(subscriber, never()).onComplete();</span>

<span class="fc" id="L312">        a.onComplete();</span>

<span class="fc" id="L314">        inOrder.verify(subscriber, times(1)).onComplete();</span>

<span class="fc" id="L316">        a.onNext(3);</span>
<span class="fc" id="L317">        b.onNext(0x30);</span>
<span class="fc" id="L318">        a.onComplete();</span>
<span class="fc" id="L319">        b.onComplete();</span>

<span class="fc" id="L321">        inOrder.verifyNoMoreInteractions();</span>
<span class="fc" id="L322">        verify(subscriber, never()).onError(any(Throwable.class));</span>
<span class="fc" id="L323">    }</span>

    @Test
    public void combineMultipleObservers() {
<span class="fc" id="L327">        PublishProcessor&lt;Integer&gt; a = PublishProcessor.create();</span>
<span class="fc" id="L328">        PublishProcessor&lt;Integer&gt; b = PublishProcessor.create();</span>

<span class="fc" id="L330">        Flowable&lt;Integer&gt; source = Flowable.combineLatest(a, b, or);</span>

<span class="fc" id="L332">        Subscriber&lt;Object&gt; subscriber1 = TestHelper.mockSubscriber();</span>

<span class="fc" id="L334">        Subscriber&lt;Object&gt; subscriber2 = TestHelper.mockSubscriber();</span>

<span class="fc" id="L336">        InOrder inOrder1 = inOrder(subscriber1);</span>
<span class="fc" id="L337">        InOrder inOrder2 = inOrder(subscriber2);</span>

<span class="fc" id="L339">        source.subscribe(subscriber1);</span>
<span class="fc" id="L340">        source.subscribe(subscriber2);</span>

<span class="fc" id="L342">        a.onNext(1);</span>

<span class="fc" id="L344">        inOrder1.verify(subscriber1, never()).onNext(any());</span>
<span class="fc" id="L345">        inOrder2.verify(subscriber2, never()).onNext(any());</span>

<span class="fc" id="L347">        a.onNext(2);</span>

<span class="fc" id="L349">        inOrder1.verify(subscriber1, never()).onNext(any());</span>
<span class="fc" id="L350">        inOrder2.verify(subscriber2, never()).onNext(any());</span>

<span class="fc" id="L352">        b.onNext(0x10);</span>

<span class="fc" id="L354">        inOrder1.verify(subscriber1, times(1)).onNext(0x12);</span>
<span class="fc" id="L355">        inOrder2.verify(subscriber2, times(1)).onNext(0x12);</span>

<span class="fc" id="L357">        b.onNext(0x20);</span>
<span class="fc" id="L358">        inOrder1.verify(subscriber1, times(1)).onNext(0x22);</span>
<span class="fc" id="L359">        inOrder2.verify(subscriber2, times(1)).onNext(0x22);</span>

<span class="fc" id="L361">        b.onComplete();</span>

<span class="fc" id="L363">        inOrder1.verify(subscriber1, never()).onComplete();</span>
<span class="fc" id="L364">        inOrder2.verify(subscriber2, never()).onComplete();</span>

<span class="fc" id="L366">        a.onComplete();</span>

<span class="fc" id="L368">        inOrder1.verify(subscriber1, times(1)).onComplete();</span>
<span class="fc" id="L369">        inOrder2.verify(subscriber2, times(1)).onComplete();</span>

<span class="fc" id="L371">        a.onNext(3);</span>
<span class="fc" id="L372">        b.onNext(0x30);</span>
<span class="fc" id="L373">        a.onComplete();</span>
<span class="fc" id="L374">        b.onComplete();</span>

<span class="fc" id="L376">        inOrder1.verifyNoMoreInteractions();</span>
<span class="fc" id="L377">        inOrder2.verifyNoMoreInteractions();</span>
<span class="fc" id="L378">        verify(subscriber1, never()).onError(any(Throwable.class));</span>
<span class="fc" id="L379">        verify(subscriber2, never()).onError(any(Throwable.class));</span>
<span class="fc" id="L380">    }</span>

    @Test
    public void testFirstNeverProduces() {
<span class="fc" id="L384">        PublishProcessor&lt;Integer&gt; a = PublishProcessor.create();</span>
<span class="fc" id="L385">        PublishProcessor&lt;Integer&gt; b = PublishProcessor.create();</span>

<span class="fc" id="L387">        Flowable&lt;Integer&gt; source = Flowable.combineLatest(a, b, or);</span>

<span class="fc" id="L389">        Subscriber&lt;Object&gt; subscriber = TestHelper.mockSubscriber();</span>
<span class="fc" id="L390">        InOrder inOrder = inOrder(subscriber);</span>

<span class="fc" id="L392">        source.subscribe(subscriber);</span>

<span class="fc" id="L394">        b.onNext(0x10);</span>
<span class="fc" id="L395">        b.onNext(0x20);</span>

<span class="fc" id="L397">        a.onComplete();</span>

<span class="fc" id="L399">        inOrder.verify(subscriber, times(1)).onComplete();</span>
<span class="fc" id="L400">        verify(subscriber, never()).onNext(any());</span>
<span class="fc" id="L401">        verify(subscriber, never()).onError(any(Throwable.class));</span>
<span class="fc" id="L402">    }</span>

    @Test
    public void testSecondNeverProduces() {
<span class="fc" id="L406">        PublishProcessor&lt;Integer&gt; a = PublishProcessor.create();</span>
<span class="fc" id="L407">        PublishProcessor&lt;Integer&gt; b = PublishProcessor.create();</span>

<span class="fc" id="L409">        Flowable&lt;Integer&gt; source = Flowable.combineLatest(a, b, or);</span>

<span class="fc" id="L411">        Subscriber&lt;Object&gt; subscriber = TestHelper.mockSubscriber();</span>
<span class="fc" id="L412">        InOrder inOrder = inOrder(subscriber);</span>

<span class="fc" id="L414">        source.subscribe(subscriber);</span>

<span class="fc" id="L416">        a.onNext(0x1);</span>
<span class="fc" id="L417">        a.onNext(0x2);</span>

<span class="fc" id="L419">        b.onComplete();</span>
<span class="fc" id="L420">        a.onComplete();</span>

<span class="fc" id="L422">        inOrder.verify(subscriber, times(1)).onComplete();</span>
<span class="fc" id="L423">        verify(subscriber, never()).onNext(any());</span>
<span class="fc" id="L424">        verify(subscriber, never()).onError(any(Throwable.class));</span>
<span class="fc" id="L425">    }</span>

    public void test0Sources() {

<span class="nc" id="L429">    }</span>

    @Test
    public void test1ToNSources() {
<span class="fc" id="L433">        int n = 30;</span>
<span class="fc" id="L434">        Function&lt;Object[], List&lt;Object&gt;&gt; func = new Function&lt;Object[], List&lt;Object&gt;&gt;() {</span>

            @Override
            public List&lt;Object&gt; apply(Object[] args) {
<span class="fc" id="L438">                return Arrays.asList(args);</span>
            }
        };
<span class="fc bfc" id="L441" title="All 2 branches covered.">        for (int i = 1; i &lt;= n; i++) {</span>
<span class="fc" id="L442">            System.out.println(&quot;test1ToNSources: &quot; + i + &quot; sources&quot;);</span>
<span class="fc" id="L443">            List&lt;Flowable&lt;Integer&gt;&gt; sources = new ArrayList&lt;Flowable&lt;Integer&gt;&gt;();</span>
<span class="fc" id="L444">            List&lt;Object&gt; values = new ArrayList&lt;Object&gt;();</span>
<span class="fc bfc" id="L445" title="All 2 branches covered.">            for (int j = 0; j &lt; i; j++) {</span>
<span class="fc" id="L446">                sources.add(Flowable.just(j));</span>
<span class="fc" id="L447">                values.add(j);</span>
            }

<span class="fc" id="L450">            Flowable&lt;List&lt;Object&gt;&gt; result = Flowable.combineLatest(sources, func);</span>

<span class="fc" id="L452">            Subscriber&lt;List&lt;Object&gt;&gt; subscriber = TestHelper.mockSubscriber();</span>

<span class="fc" id="L454">            result.subscribe(subscriber);</span>

<span class="fc" id="L456">            verify(subscriber).onNext(values);</span>
<span class="fc" id="L457">            verify(subscriber).onComplete();</span>
<span class="fc" id="L458">            verify(subscriber, never()).onError(any(Throwable.class));</span>
        }
<span class="fc" id="L460">    }</span>

    @Test(timeout = 5000)
    public void test1ToNSourcesScheduled() throws InterruptedException {
<span class="fc" id="L464">        int n = 10;</span>
<span class="fc" id="L465">        Function&lt;Object[], List&lt;Object&gt;&gt; func = new Function&lt;Object[], List&lt;Object&gt;&gt;() {</span>

            @Override
            public List&lt;Object&gt; apply(Object[] args) {
<span class="fc" id="L469">                return Arrays.asList(args);</span>
            }
        };
<span class="fc bfc" id="L472" title="All 2 branches covered.">        for (int i = 1; i &lt;= n; i++) {</span>
<span class="fc" id="L473">            System.out.println(&quot;test1ToNSourcesScheduled: &quot; + i + &quot; sources&quot;);</span>
<span class="fc" id="L474">            List&lt;Flowable&lt;Integer&gt;&gt; sources = new ArrayList&lt;Flowable&lt;Integer&gt;&gt;();</span>
<span class="fc" id="L475">            List&lt;Object&gt; values = new ArrayList&lt;Object&gt;();</span>
<span class="fc bfc" id="L476" title="All 2 branches covered.">            for (int j = 0; j &lt; i; j++) {</span>
<span class="fc" id="L477">                sources.add(Flowable.just(j).subscribeOn(Schedulers.io()));</span>
<span class="fc" id="L478">                values.add(j);</span>
            }

<span class="fc" id="L481">            Flowable&lt;List&lt;Object&gt;&gt; result = Flowable.combineLatest(sources, func);</span>

<span class="fc" id="L483">            final Subscriber&lt;List&lt;Object&gt;&gt; subscriber = TestHelper.mockSubscriber();</span>

<span class="fc" id="L485">            final CountDownLatch cdl = new CountDownLatch(1);</span>

<span class="fc" id="L487">            Subscriber&lt;List&lt;Object&gt;&gt; s = new DefaultSubscriber&lt;List&lt;Object&gt;&gt;() {</span>

                @Override
                public void onNext(List&lt;Object&gt; t) {
<span class="fc" id="L491">                    subscriber.onNext(t);</span>
<span class="fc" id="L492">                }</span>

                @Override
                public void onError(Throwable e) {
<span class="nc" id="L496">                    subscriber.onError(e);</span>
<span class="nc" id="L497">                    cdl.countDown();</span>
<span class="nc" id="L498">                }</span>

                @Override
                public void onComplete() {
<span class="fc" id="L502">                    subscriber.onComplete();</span>
<span class="fc" id="L503">                    cdl.countDown();</span>
<span class="fc" id="L504">                }</span>
            };

<span class="fc" id="L507">            result.subscribe(s);</span>

<span class="fc" id="L509">            cdl.await();</span>

<span class="fc" id="L511">            verify(subscriber).onNext(values);</span>
<span class="fc" id="L512">            verify(subscriber).onComplete();</span>
<span class="fc" id="L513">            verify(subscriber, never()).onError(any(Throwable.class));</span>
        }
<span class="fc" id="L515">    }</span>

    @Test
    public void test2SourcesOverload() {
<span class="fc" id="L519">        Flowable&lt;Integer&gt; s1 = Flowable.just(1);</span>
<span class="fc" id="L520">        Flowable&lt;Integer&gt; s2 = Flowable.just(2);</span>

<span class="fc" id="L522">        Flowable&lt;List&lt;Integer&gt;&gt; result = Flowable.combineLatest(s1, s2,</span>
<span class="fc" id="L523">                new BiFunction&lt;Integer, Integer, List&lt;Integer&gt;&gt;() {</span>
                    @Override
                    public List&lt;Integer&gt; apply(Integer t1, Integer t2) {
<span class="fc" id="L526">                        return Arrays.asList(t1, t2);</span>
                    }
                });

<span class="fc" id="L530">        Subscriber&lt;Object&gt; subscriber = TestHelper.mockSubscriber();</span>

<span class="fc" id="L532">        result.subscribe(subscriber);</span>

<span class="fc" id="L534">        verify(subscriber).onNext(Arrays.asList(1, 2));</span>
<span class="fc" id="L535">        verify(subscriber).onComplete();</span>
<span class="fc" id="L536">        verify(subscriber, never()).onError(any(Throwable.class));</span>
<span class="fc" id="L537">    }</span>

    @Test
    public void test3SourcesOverload() {
<span class="fc" id="L541">        Flowable&lt;Integer&gt; s1 = Flowable.just(1);</span>
<span class="fc" id="L542">        Flowable&lt;Integer&gt; s2 = Flowable.just(2);</span>
<span class="fc" id="L543">        Flowable&lt;Integer&gt; s3 = Flowable.just(3);</span>

<span class="fc" id="L545">        Flowable&lt;List&lt;Integer&gt;&gt; result = Flowable.combineLatest(s1, s2, s3,</span>
<span class="fc" id="L546">                new Function3&lt;Integer, Integer, Integer, List&lt;Integer&gt;&gt;() {</span>
                    @Override
                    public List&lt;Integer&gt; apply(Integer t1, Integer t2, Integer t3) {
<span class="fc" id="L549">                        return Arrays.asList(t1, t2, t3);</span>
                    }
                });

<span class="fc" id="L553">        Subscriber&lt;Object&gt; subscriber = TestHelper.mockSubscriber();</span>

<span class="fc" id="L555">        result.subscribe(subscriber);</span>

<span class="fc" id="L557">        verify(subscriber).onNext(Arrays.asList(1, 2, 3));</span>
<span class="fc" id="L558">        verify(subscriber).onComplete();</span>
<span class="fc" id="L559">        verify(subscriber, never()).onError(any(Throwable.class));</span>
<span class="fc" id="L560">    }</span>

    @Test
    public void test4SourcesOverload() {
<span class="fc" id="L564">        Flowable&lt;Integer&gt; s1 = Flowable.just(1);</span>
<span class="fc" id="L565">        Flowable&lt;Integer&gt; s2 = Flowable.just(2);</span>
<span class="fc" id="L566">        Flowable&lt;Integer&gt; s3 = Flowable.just(3);</span>
<span class="fc" id="L567">        Flowable&lt;Integer&gt; s4 = Flowable.just(4);</span>

<span class="fc" id="L569">        Flowable&lt;List&lt;Integer&gt;&gt; result = Flowable.combineLatest(s1, s2, s3, s4,</span>
<span class="fc" id="L570">                new Function4&lt;Integer, Integer, Integer, Integer, List&lt;Integer&gt;&gt;() {</span>
                    @Override
                    public List&lt;Integer&gt; apply(Integer t1, Integer t2, Integer t3, Integer t4) {
<span class="fc" id="L573">                        return Arrays.asList(t1, t2, t3, t4);</span>
                    }
                });

<span class="fc" id="L577">        Subscriber&lt;Object&gt; subscriber = TestHelper.mockSubscriber();</span>

<span class="fc" id="L579">        result.subscribe(subscriber);</span>

<span class="fc" id="L581">        verify(subscriber).onNext(Arrays.asList(1, 2, 3, 4));</span>
<span class="fc" id="L582">        verify(subscriber).onComplete();</span>
<span class="fc" id="L583">        verify(subscriber, never()).onError(any(Throwable.class));</span>
<span class="fc" id="L584">    }</span>

    @Test
    public void test5SourcesOverload() {
<span class="fc" id="L588">        Flowable&lt;Integer&gt; s1 = Flowable.just(1);</span>
<span class="fc" id="L589">        Flowable&lt;Integer&gt; s2 = Flowable.just(2);</span>
<span class="fc" id="L590">        Flowable&lt;Integer&gt; s3 = Flowable.just(3);</span>
<span class="fc" id="L591">        Flowable&lt;Integer&gt; s4 = Flowable.just(4);</span>
<span class="fc" id="L592">        Flowable&lt;Integer&gt; s5 = Flowable.just(5);</span>

<span class="fc" id="L594">        Flowable&lt;List&lt;Integer&gt;&gt; result = Flowable.combineLatest(s1, s2, s3, s4, s5,</span>
<span class="fc" id="L595">                new Function5&lt;Integer, Integer, Integer, Integer, Integer, List&lt;Integer&gt;&gt;() {</span>
                    @Override
                    public List&lt;Integer&gt; apply(Integer t1, Integer t2, Integer t3, Integer t4, Integer t5) {
<span class="fc" id="L598">                        return Arrays.asList(t1, t2, t3, t4, t5);</span>
                    }
                });

<span class="fc" id="L602">        Subscriber&lt;Object&gt; subscriber = TestHelper.mockSubscriber();</span>

<span class="fc" id="L604">        result.subscribe(subscriber);</span>

<span class="fc" id="L606">        verify(subscriber).onNext(Arrays.asList(1, 2, 3, 4, 5));</span>
<span class="fc" id="L607">        verify(subscriber).onComplete();</span>
<span class="fc" id="L608">        verify(subscriber, never()).onError(any(Throwable.class));</span>
<span class="fc" id="L609">    }</span>

    @Test
    public void test6SourcesOverload() {
<span class="fc" id="L613">        Flowable&lt;Integer&gt; s1 = Flowable.just(1);</span>
<span class="fc" id="L614">        Flowable&lt;Integer&gt; s2 = Flowable.just(2);</span>
<span class="fc" id="L615">        Flowable&lt;Integer&gt; s3 = Flowable.just(3);</span>
<span class="fc" id="L616">        Flowable&lt;Integer&gt; s4 = Flowable.just(4);</span>
<span class="fc" id="L617">        Flowable&lt;Integer&gt; s5 = Flowable.just(5);</span>
<span class="fc" id="L618">        Flowable&lt;Integer&gt; s6 = Flowable.just(6);</span>

<span class="fc" id="L620">        Flowable&lt;List&lt;Integer&gt;&gt; result = Flowable.combineLatest(s1, s2, s3, s4, s5, s6,</span>
<span class="fc" id="L621">                new Function6&lt;Integer, Integer, Integer, Integer, Integer, Integer, List&lt;Integer&gt;&gt;() {</span>
                    @Override
                    public List&lt;Integer&gt; apply(Integer t1, Integer t2, Integer t3, Integer t4, Integer t5, Integer t6) {
<span class="fc" id="L624">                        return Arrays.asList(t1, t2, t3, t4, t5, t6);</span>
                    }
                });

<span class="fc" id="L628">        Subscriber&lt;Object&gt; subscriber = TestHelper.mockSubscriber();</span>

<span class="fc" id="L630">        result.subscribe(subscriber);</span>

<span class="fc" id="L632">        verify(subscriber).onNext(Arrays.asList(1, 2, 3, 4, 5, 6));</span>
<span class="fc" id="L633">        verify(subscriber).onComplete();</span>
<span class="fc" id="L634">        verify(subscriber, never()).onError(any(Throwable.class));</span>
<span class="fc" id="L635">    }</span>

    @Test
    public void test7SourcesOverload() {
<span class="fc" id="L639">        Flowable&lt;Integer&gt; s1 = Flowable.just(1);</span>
<span class="fc" id="L640">        Flowable&lt;Integer&gt; s2 = Flowable.just(2);</span>
<span class="fc" id="L641">        Flowable&lt;Integer&gt; s3 = Flowable.just(3);</span>
<span class="fc" id="L642">        Flowable&lt;Integer&gt; s4 = Flowable.just(4);</span>
<span class="fc" id="L643">        Flowable&lt;Integer&gt; s5 = Flowable.just(5);</span>
<span class="fc" id="L644">        Flowable&lt;Integer&gt; s6 = Flowable.just(6);</span>
<span class="fc" id="L645">        Flowable&lt;Integer&gt; s7 = Flowable.just(7);</span>

<span class="fc" id="L647">        Flowable&lt;List&lt;Integer&gt;&gt; result = Flowable.combineLatest(s1, s2, s3, s4, s5, s6, s7,</span>
<span class="fc" id="L648">                new Function7&lt;Integer, Integer, Integer, Integer, Integer, Integer, Integer, List&lt;Integer&gt;&gt;() {</span>
                    @Override
                    public List&lt;Integer&gt; apply(Integer t1, Integer t2, Integer t3, Integer t4, Integer t5, Integer t6, Integer t7) {
<span class="fc" id="L651">                        return Arrays.asList(t1, t2, t3, t4, t5, t6, t7);</span>
                    }
                });

<span class="fc" id="L655">        Subscriber&lt;Object&gt; subscriber = TestHelper.mockSubscriber();</span>

<span class="fc" id="L657">        result.subscribe(subscriber);</span>

<span class="fc" id="L659">        verify(subscriber).onNext(Arrays.asList(1, 2, 3, 4, 5, 6, 7));</span>
<span class="fc" id="L660">        verify(subscriber).onComplete();</span>
<span class="fc" id="L661">        verify(subscriber, never()).onError(any(Throwable.class));</span>
<span class="fc" id="L662">    }</span>

    @Test
    public void test8SourcesOverload() {
<span class="fc" id="L666">        Flowable&lt;Integer&gt; s1 = Flowable.just(1);</span>
<span class="fc" id="L667">        Flowable&lt;Integer&gt; s2 = Flowable.just(2);</span>
<span class="fc" id="L668">        Flowable&lt;Integer&gt; s3 = Flowable.just(3);</span>
<span class="fc" id="L669">        Flowable&lt;Integer&gt; s4 = Flowable.just(4);</span>
<span class="fc" id="L670">        Flowable&lt;Integer&gt; s5 = Flowable.just(5);</span>
<span class="fc" id="L671">        Flowable&lt;Integer&gt; s6 = Flowable.just(6);</span>
<span class="fc" id="L672">        Flowable&lt;Integer&gt; s7 = Flowable.just(7);</span>
<span class="fc" id="L673">        Flowable&lt;Integer&gt; s8 = Flowable.just(8);</span>

<span class="fc" id="L675">        Flowable&lt;List&lt;Integer&gt;&gt; result = Flowable.combineLatest(s1, s2, s3, s4, s5, s6, s7, s8,</span>
<span class="fc" id="L676">                new Function8&lt;Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, List&lt;Integer&gt;&gt;() {</span>
                    @Override
                    public List&lt;Integer&gt; apply(Integer t1, Integer t2, Integer t3, Integer t4, Integer t5, Integer t6, Integer t7, Integer t8) {
<span class="fc" id="L679">                        return Arrays.asList(t1, t2, t3, t4, t5, t6, t7, t8);</span>
                    }
                });

<span class="fc" id="L683">        Subscriber&lt;Object&gt; subscriber = TestHelper.mockSubscriber();</span>

<span class="fc" id="L685">        result.subscribe(subscriber);</span>

<span class="fc" id="L687">        verify(subscriber).onNext(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8));</span>
<span class="fc" id="L688">        verify(subscriber).onComplete();</span>
<span class="fc" id="L689">        verify(subscriber, never()).onError(any(Throwable.class));</span>
<span class="fc" id="L690">    }</span>

    @Test
    public void test9SourcesOverload() {
<span class="fc" id="L694">        Flowable&lt;Integer&gt; s1 = Flowable.just(1);</span>
<span class="fc" id="L695">        Flowable&lt;Integer&gt; s2 = Flowable.just(2);</span>
<span class="fc" id="L696">        Flowable&lt;Integer&gt; s3 = Flowable.just(3);</span>
<span class="fc" id="L697">        Flowable&lt;Integer&gt; s4 = Flowable.just(4);</span>
<span class="fc" id="L698">        Flowable&lt;Integer&gt; s5 = Flowable.just(5);</span>
<span class="fc" id="L699">        Flowable&lt;Integer&gt; s6 = Flowable.just(6);</span>
<span class="fc" id="L700">        Flowable&lt;Integer&gt; s7 = Flowable.just(7);</span>
<span class="fc" id="L701">        Flowable&lt;Integer&gt; s8 = Flowable.just(8);</span>
<span class="fc" id="L702">        Flowable&lt;Integer&gt; s9 = Flowable.just(9);</span>

<span class="fc" id="L704">        Flowable&lt;List&lt;Integer&gt;&gt; result = Flowable.combineLatest(s1, s2, s3, s4, s5, s6, s7, s8, s9,</span>
<span class="fc" id="L705">                new Function9&lt;Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, Integer, List&lt;Integer&gt;&gt;() {</span>
                    @Override
                    public List&lt;Integer&gt; apply(Integer t1, Integer t2, Integer t3, Integer t4, Integer t5, Integer t6, Integer t7, Integer t8, Integer t9) {
<span class="fc" id="L708">                        return Arrays.asList(t1, t2, t3, t4, t5, t6, t7, t8, t9);</span>
                    }
                });

<span class="fc" id="L712">        Subscriber&lt;Object&gt; subscriber = TestHelper.mockSubscriber();</span>

<span class="fc" id="L714">        result.subscribe(subscriber);</span>

<span class="fc" id="L716">        verify(subscriber).onNext(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9));</span>
<span class="fc" id="L717">        verify(subscriber).onComplete();</span>
<span class="fc" id="L718">        verify(subscriber, never()).onError(any(Throwable.class));</span>
<span class="fc" id="L719">    }</span>

    @Test
    public void testZeroSources() {
<span class="fc" id="L723">        Flowable&lt;Object&gt; result = Flowable.combineLatest(</span>
<span class="fc" id="L724">                Collections.&lt;Flowable&lt;Object&gt;&gt; emptyList(), new Function&lt;Object[], Object&gt;() {</span>

            @Override
            public Object apply(Object[] args) {
<span class="nc" id="L728">                return args;</span>
            }

        });

<span class="fc" id="L733">        Subscriber&lt;Object&gt; subscriber = TestHelper.mockSubscriber();</span>

<span class="fc" id="L735">        result.subscribe(subscriber);</span>

<span class="fc" id="L737">        verify(subscriber).onComplete();</span>
<span class="fc" id="L738">        verify(subscriber, never()).onNext(any());</span>
<span class="fc" id="L739">        verify(subscriber, never()).onError(any(Throwable.class));</span>

<span class="fc" id="L741">    }</span>

    @Test
    public void testBackpressureLoop() {
<span class="fc bfc" id="L745" title="All 2 branches covered.">        for (int i = 0; i &lt; 5000; i++) {</span>
<span class="fc" id="L746">            testBackpressure();</span>
        }
<span class="fc" id="L748">    }</span>

    @Test//(timeout = 2000)
    public void testBackpressure() {
<span class="fc" id="L752">        BiFunction&lt;String, Integer, String&gt; combineLatestFunction = getConcatStringIntegerCombineLatestFunction();</span>

<span class="fc" id="L754">        int num = Flowable.bufferSize() * 4;</span>
<span class="fc" id="L755">        TestSubscriber&lt;String&gt; ts = new TestSubscriber&lt;String&gt;();</span>
<span class="fc" id="L756">        Flowable.combineLatest(</span>
<span class="fc" id="L757">                Flowable.just(&quot;one&quot;, &quot;two&quot;),</span>
<span class="fc" id="L758">                Flowable.range(2, num),</span>
                combineLatestFunction
        )
<span class="fc" id="L761">        .observeOn(Schedulers.computation())</span>
<span class="fc" id="L762">        .subscribe(ts);</span>

<span class="fc" id="L764">        ts.awaitTerminalEvent();</span>
<span class="fc" id="L765">        ts.assertNoErrors();</span>
<span class="fc" id="L766">        List&lt;String&gt; events = ts.values();</span>
<span class="fc" id="L767">        assertEquals(&quot;two2&quot;, events.get(0));</span>
<span class="fc" id="L768">        assertEquals(&quot;two3&quot;, events.get(1));</span>
<span class="fc" id="L769">        assertEquals(&quot;two4&quot;, events.get(2));</span>
<span class="fc" id="L770">        assertEquals(num, events.size());</span>
<span class="fc" id="L771">    }</span>

    @Test
    public void testWithCombineLatestIssue1717() throws InterruptedException {
<span class="fc" id="L775">        final CountDownLatch latch = new CountDownLatch(1);</span>
<span class="fc" id="L776">        final AtomicInteger count = new AtomicInteger();</span>
<span class="fc" id="L777">        final int SIZE = 2000;</span>
<span class="fc" id="L778">        Flowable&lt;Long&gt; timer = Flowable.interval(0, 1, TimeUnit.MILLISECONDS)</span>
<span class="fc" id="L779">                .observeOn(Schedulers.newThread())</span>
<span class="fc" id="L780">                .doOnEach(new Consumer&lt;Notification&lt;Long&gt;&gt;() {</span>
                    @Override
                    public void accept(Notification&lt;Long&gt; n) {
                            //                        System.out.println(n);
<span class="fc bfc" id="L784" title="All 2 branches covered.">                            if (count.incrementAndGet() &gt;= SIZE) {</span>
<span class="fc" id="L785">                                latch.countDown();</span>
                            }
<span class="fc" id="L787">                    }</span>
<span class="fc" id="L788">                }).take(SIZE);</span>

<span class="fc" id="L790">        TestSubscriber&lt;Long&gt; ts = new TestSubscriber&lt;Long&gt;();</span>

<span class="fc" id="L792">        Flowable.combineLatest(timer, Flowable.&lt;Integer&gt; never(), new BiFunction&lt;Long, Integer, Long&gt;() {</span>
            @Override
            public Long apply(Long t1, Integer t2) {
<span class="nc" id="L795">                return t1;</span>
            }
<span class="fc" id="L797">        }).subscribe(ts);</span>

<span class="pc bpc" id="L799" title="1 of 2 branches missed.">        if (!latch.await(SIZE + 2000, TimeUnit.MILLISECONDS)) {</span>
<span class="nc" id="L800">            fail(&quot;timed out&quot;);</span>
        }

<span class="fc" id="L803">        assertEquals(SIZE, count.get());</span>
<span class="fc" id="L804">    }</span>

    @Test(timeout = 10000)
    public void testCombineLatestRequestOverflow() throws InterruptedException {
        @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L809">        List&lt;Flowable&lt;Integer&gt;&gt; sources = Arrays.asList(Flowable.fromArray(1, 2, 3, 4),</span>
<span class="fc" id="L810">                Flowable.fromArray(5, 6, 7, 8));</span>
<span class="fc" id="L811">        Flowable&lt;Integer&gt; f = Flowable.combineLatest(sources, new Function&lt;Object[], Integer&gt;() {</span>
            @Override
            public Integer apply(Object[] args) {
<span class="fc" id="L814">               return (Integer) args[0];</span>
            }});
        //should get at least 4
<span class="fc" id="L817">        final CountDownLatch latch = new CountDownLatch(4);</span>
<span class="fc" id="L818">        f.subscribeOn(Schedulers.computation()).subscribe(new DefaultSubscriber&lt;Integer&gt;() {</span>

            @Override
            public void onStart() {
<span class="fc" id="L822">                request(2);</span>
<span class="fc" id="L823">            }</span>

            @Override
            public void onComplete() {
                //ignore
<span class="fc" id="L828">            }</span>

            @Override
            public void onError(Throwable e) {
<span class="nc" id="L832">                throw new RuntimeException(e);</span>
            }

            @Override
            public void onNext(Integer t) {
<span class="fc" id="L837">                latch.countDown();</span>
<span class="fc" id="L838">                request(Long.MAX_VALUE - 1);</span>
<span class="fc" id="L839">            }});</span>
<span class="fc" id="L840">        assertTrue(latch.await(10, TimeUnit.SECONDS));</span>
<span class="fc" id="L841">    }</span>

<span class="fc" id="L843">    private static final Function&lt;Object[], Integer&gt; THROW_NON_FATAL = new Function&lt;Object[], Integer&gt;() {</span>
        @Override
        public Integer apply(Object[] args) {
<span class="fc" id="L846">            throw new RuntimeException();</span>
        }

    };

    @Test
    public void testNonFatalExceptionThrownByCombinatorForSingleSourceIsNotReportedByUpstreamOperator() {
<span class="fc" id="L853">        final AtomicBoolean errorOccurred = new AtomicBoolean(false);</span>
<span class="fc" id="L854">        TestSubscriber&lt;Integer&gt; ts = TestSubscriber.create(1);</span>
<span class="fc" id="L855">        Flowable&lt;Integer&gt; source = Flowable.just(1)</span>
          // if haven't caught exception in combineLatest operator then would incorrectly
          // be picked up by this call to doOnError
<span class="fc" id="L858">          .doOnError(new Consumer&lt;Throwable&gt;() {</span>
                @Override
                public void accept(Throwable t) {
<span class="nc" id="L861">                    errorOccurred.set(true);</span>
<span class="nc" id="L862">                }</span>
            });
<span class="fc" id="L864">        Flowable</span>
<span class="fc" id="L865">          .combineLatest(Collections.singletonList(source), THROW_NON_FATAL)</span>
<span class="fc" id="L866">          .subscribe(ts);</span>
<span class="fc" id="L867">        assertFalse(errorOccurred.get());</span>
<span class="fc" id="L868">    }</span>

    @Ignore(&quot;Nulls are not allowed&quot;)
    @Test
    public void testCombineManyNulls() {
<span class="nc" id="L873">        int n = Flowable.bufferSize() * 3;</span>

<span class="nc" id="L875">        Flowable&lt;Integer&gt; source = Flowable.just((Integer)null);</span>

<span class="nc" id="L877">        List&lt;Flowable&lt;Integer&gt;&gt; sources = new ArrayList&lt;Flowable&lt;Integer&gt;&gt;();</span>

<span class="nc bnc" id="L879" title="All 2 branches missed.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="nc" id="L880">            sources.add(source);</span>
        }

<span class="nc" id="L883">        TestSubscriber&lt;Integer&gt; ts = TestSubscriber.create();</span>

<span class="nc" id="L885">        Flowable.combineLatest(sources, new Function&lt;Object[], Integer&gt;() {</span>
            @Override
            public Integer apply(Object[] args) {
<span class="nc" id="L888">                int sum = 0;</span>
<span class="nc bnc" id="L889" title="All 2 branches missed.">                for (Object o : args) {</span>
<span class="nc bnc" id="L890" title="All 2 branches missed.">                    if (o == null) {</span>
<span class="nc" id="L891">                        sum ++;</span>
                    }
                }
<span class="nc" id="L894">                return sum;</span>
            }
<span class="nc" id="L896">        }).subscribe(ts);</span>

<span class="nc" id="L898">        ts.assertValue(n);</span>
<span class="nc" id="L899">        ts.assertNoErrors();</span>
<span class="nc" id="L900">        ts.assertComplete();</span>
<span class="nc" id="L901">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void combineLatestIterable() {
<span class="fc" id="L906">        Flowable&lt;Integer&gt; source = Flowable.just(1);</span>

<span class="fc" id="L908">        TestSubscriber&lt;Integer&gt; ts = TestSubscriber.create();</span>

<span class="fc" id="L910">        Flowable.combineLatest(Arrays.asList(source, source),</span>
<span class="fc" id="L911">        new Function&lt;Object[], Integer&gt;() {</span>
            @Override
            public Integer apply(Object[] args) {
<span class="fc" id="L914">                return (Integer)args[0] + (Integer)args[1];</span>
            }
        })
<span class="fc" id="L917">        .subscribe(ts);</span>

<span class="fc" id="L919">        ts.assertValue(2);</span>
<span class="fc" id="L920">        ts.assertNoErrors();</span>
<span class="fc" id="L921">        ts.assertComplete();</span>
<span class="fc" id="L922">    }</span>

    @Test
    public void testCombineMany() {
<span class="fc" id="L926">        int n = Flowable.bufferSize() * 3;</span>

<span class="fc" id="L928">        List&lt;Flowable&lt;Integer&gt;&gt; sources = new ArrayList&lt;Flowable&lt;Integer&gt;&gt;();</span>

<span class="fc" id="L930">        StringBuilder expected = new StringBuilder(n * 2);</span>

<span class="fc bfc" id="L932" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L933">            sources.add(Flowable.just(i));</span>
<span class="fc" id="L934">            expected.append(i);</span>
        }

<span class="fc" id="L937">        TestSubscriber&lt;String&gt; ts = TestSubscriber.create();</span>

<span class="fc" id="L939">        Flowable.combineLatest(sources, new Function&lt;Object[], String&gt;() {</span>
            @Override
            public String apply(Object[] args) {
<span class="fc" id="L942">                StringBuilder b = new StringBuilder();</span>
<span class="fc bfc" id="L943" title="All 2 branches covered.">                for (Object o : args) {</span>
<span class="fc" id="L944">                    b.append(o);</span>
                }
<span class="fc" id="L946">                return b.toString();</span>
            }
<span class="fc" id="L948">        }).subscribe(ts);</span>

<span class="fc" id="L950">        ts.assertNoErrors();</span>
<span class="fc" id="L951">        ts.assertValue(expected.toString());</span>
<span class="fc" id="L952">        ts.assertComplete();</span>
<span class="fc" id="L953">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void firstJustError() {
<span class="fc" id="L958">        TestSubscriber&lt;Integer&gt; ts = TestSubscriber.create();</span>

<span class="fc" id="L960">        Flowable.combineLatestDelayError(</span>
<span class="fc" id="L961">                Arrays.asList(Flowable.just(1), Flowable.&lt;Integer&gt;error(new TestException())),</span>
<span class="fc" id="L962">                new Function&lt;Object[], Integer&gt;() {</span>
                    @Override
                    public Integer apply(Object[] args) {
<span class="nc" id="L965">                        return ((Integer)args[0]) + ((Integer)args[1]);</span>
                    }
                }
<span class="fc" id="L968">        ).subscribe(ts);</span>

<span class="fc" id="L970">        ts.assertNoValues();</span>
<span class="fc" id="L971">        ts.assertError(TestException.class);</span>
<span class="fc" id="L972">        ts.assertNotComplete();</span>
<span class="fc" id="L973">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void secondJustError() {
<span class="fc" id="L978">        TestSubscriber&lt;Integer&gt; ts = TestSubscriber.create();</span>

<span class="fc" id="L980">        Flowable.combineLatestDelayError(</span>
<span class="fc" id="L981">                Arrays.asList(Flowable.&lt;Integer&gt;error(new TestException()), Flowable.just(1)),</span>
<span class="fc" id="L982">                new Function&lt;Object[], Integer&gt;() {</span>
                    @Override
                    public Integer apply(Object[] args) {
<span class="nc" id="L985">                        return ((Integer)args[0]) + ((Integer)args[1]);</span>
                    }
                }
<span class="fc" id="L988">        ).subscribe(ts);</span>

<span class="fc" id="L990">        ts.assertNoValues();</span>
<span class="fc" id="L991">        ts.assertError(TestException.class);</span>
<span class="fc" id="L992">        ts.assertNotComplete();</span>
<span class="fc" id="L993">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void oneErrors() {
<span class="fc" id="L998">        TestSubscriber&lt;Integer&gt; ts = TestSubscriber.create();</span>

<span class="fc" id="L1000">        Flowable.combineLatestDelayError(</span>
<span class="fc" id="L1001">                Arrays.asList(Flowable.just(10).concatWith(Flowable.&lt;Integer&gt;error(new TestException())), Flowable.just(1)),</span>
<span class="fc" id="L1002">                new Function&lt;Object[], Integer&gt;() {</span>
                    @Override
                    public Integer apply(Object[] args) {
<span class="fc" id="L1005">                        return ((Integer)args[0]) + ((Integer)args[1]);</span>
                    }
                }
<span class="fc" id="L1008">        ).subscribe(ts);</span>

<span class="fc" id="L1010">        ts.assertValues(11);</span>
<span class="fc" id="L1011">        ts.assertError(TestException.class);</span>
<span class="fc" id="L1012">        ts.assertNotComplete();</span>
<span class="fc" id="L1013">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void twoErrors() {
<span class="fc" id="L1018">        TestSubscriber&lt;Integer&gt; ts = TestSubscriber.create();</span>

<span class="fc" id="L1020">        Flowable.combineLatestDelayError(</span>
<span class="fc" id="L1021">                Arrays.asList(Flowable.just(1), Flowable.just(10).concatWith(Flowable.&lt;Integer&gt;error(new TestException()))),</span>
<span class="fc" id="L1022">                new Function&lt;Object[], Integer&gt;() {</span>
                    @Override
                    public Integer apply(Object[] args) {
<span class="fc" id="L1025">                        return ((Integer)args[0]) + ((Integer)args[1]);</span>
                    }
                }
<span class="fc" id="L1028">        ).subscribe(ts);</span>

<span class="fc" id="L1030">        ts.assertValues(11);</span>
<span class="fc" id="L1031">        ts.assertError(TestException.class);</span>
<span class="fc" id="L1032">        ts.assertNotComplete();</span>
<span class="fc" id="L1033">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void bothError() {
<span class="fc" id="L1038">        TestSubscriber&lt;Integer&gt; ts = TestSubscriber.create();</span>

<span class="fc" id="L1040">        Flowable.combineLatestDelayError(</span>
<span class="fc" id="L1041">                Arrays.asList(Flowable.just(1).concatWith(Flowable.&lt;Integer&gt;error(new TestException())),</span>
<span class="fc" id="L1042">                        Flowable.just(10).concatWith(Flowable.&lt;Integer&gt;error(new TestException()))),</span>
<span class="fc" id="L1043">                new Function&lt;Object[], Integer&gt;() {</span>
                    @Override
                    public Integer apply(Object[] args) {
<span class="fc" id="L1046">                        return ((Integer)args[0]) + ((Integer)args[1]);</span>
                    }
                }
<span class="fc" id="L1049">        ).subscribe(ts);</span>

<span class="fc" id="L1051">        ts.assertValues(11);</span>
<span class="fc" id="L1052">        ts.assertError(CompositeException.class);</span>
<span class="fc" id="L1053">        ts.assertNotComplete();</span>
<span class="fc" id="L1054">    }</span>

    @SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
    @Test
    public void combineLatestNArguments() throws Exception {
<span class="fc" id="L1059">        Flowable source = Flowable.just(1);</span>

<span class="fc bfc" id="L1061" title="All 2 branches covered.">        for (int i = 2; i &lt; 10; i++) {</span>
<span class="fc" id="L1062">            Class&lt;?&gt;[] types = new Class[i + 1];</span>
<span class="fc" id="L1063">            Arrays.fill(types, Publisher.class);</span>
<span class="fc bfc" id="L1064" title="All 2 branches covered.">            types[i] = i == 2 ? BiFunction.class : Class.forName(&quot;io.reactivex.functions.Function&quot; + i);</span>

<span class="fc" id="L1066">            Method m = Flowable.class.getMethod(&quot;combineLatest&quot;, types);</span>

<span class="fc" id="L1068">            Object[] params = new Object[i + 1];</span>
<span class="fc" id="L1069">            Arrays.fill(params, source);</span>
<span class="fc" id="L1070">            params[i] = ArgsToString.INSTANCE;</span>

<span class="fc" id="L1072">            StringBuilder b = new StringBuilder();</span>
<span class="fc bfc" id="L1073" title="All 2 branches covered.">            for (int j = 0; j &lt; i; j++) {</span>
<span class="fc" id="L1074">                b.append('1');</span>
            }

<span class="fc" id="L1077">            ((Flowable)m.invoke(null, params)).test().assertResult(b.toString());</span>

<span class="fc bfc" id="L1079" title="All 2 branches covered.">            for (int j = 0; j &lt; params.length; j++) {</span>
<span class="fc" id="L1080">                Object[] params0 = params.clone();</span>
<span class="fc" id="L1081">                params0[j] = null;</span>

                try {
<span class="nc" id="L1084">                    m.invoke(null, params0);</span>
<span class="nc" id="L1085">                    fail(&quot;Should have thrown @ &quot; + m);</span>
<span class="fc" id="L1086">                } catch (InvocationTargetException ex) {</span>
<span class="fc" id="L1087">                    assertTrue(ex.toString(), ex.getCause() instanceof NullPointerException);</span>

<span class="fc bfc" id="L1089" title="All 2 branches covered.">                    if (j &lt; i) {</span>
<span class="fc" id="L1090">                        assertEquals(&quot;source&quot; + (j + 1) + &quot; is null&quot;, ex.getCause().getMessage());</span>
                    } else {
<span class="fc" id="L1092">                        assertEquals(&quot;f is null&quot;, ex.getCause().getMessage());</span>
                    }
<span class="nc" id="L1094">                }</span>
            }
        }
<span class="fc" id="L1097">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void combineLatestNSources() {
<span class="fc bfc" id="L1102" title="All 2 branches covered.">        for (int i = 1; i &lt; 100; i++) {</span>
<span class="fc" id="L1103">            Flowable&lt;Integer&gt;[] sources = new Flowable[i];</span>
<span class="fc" id="L1104">            Arrays.fill(sources, Flowable.just(1));</span>
<span class="fc" id="L1105">            List&lt;Object&gt; expected = new ArrayList&lt;Object&gt;(i);</span>
<span class="fc bfc" id="L1106" title="All 2 branches covered.">            for (int j = 1; j &lt;= i; j++) {</span>
<span class="fc" id="L1107">                expected.add(1);</span>
            }

<span class="fc" id="L1110">            Flowable.combineLatest(sources, new Function&lt;Object[], List&lt;Object&gt;&gt;() {</span>
                @Override
                public List&lt;Object&gt; apply(Object[] t) throws Exception {
<span class="fc" id="L1113">                    return Arrays.asList(t);</span>
                }
            })
<span class="fc" id="L1116">            .test()</span>
<span class="fc" id="L1117">            .assertResult(expected);</span>

<span class="fc" id="L1119">            Flowable.combineLatestDelayError(sources, new Function&lt;Object[], List&lt;Object&gt;&gt;() {</span>
                @Override
                public List&lt;Object&gt; apply(Object[] t) throws Exception {
<span class="fc" id="L1122">                    return Arrays.asList(t);</span>
                }
            })
<span class="fc" id="L1125">            .test()</span>
<span class="fc" id="L1126">            .assertResult(expected);</span>
        }
<span class="fc" id="L1128">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void combineLatestArrayOfSources() {

<span class="fc" id="L1134">        Flowable.combineLatest(new Flowable[] {</span>
<span class="fc" id="L1135">                Flowable.just(1), Flowable.just(2)</span>
<span class="fc" id="L1136">        }, new Function&lt;Object[], Object&gt;() {</span>
            @Override
            public Object apply(Object[] a) throws Exception {
<span class="fc" id="L1139">                return Arrays.toString(a);</span>
            }
        })
<span class="fc" id="L1142">        .test()</span>
<span class="fc" id="L1143">        .assertResult(&quot;[1, 2]&quot;);</span>
<span class="fc" id="L1144">    }</span>

    @Test
    @SuppressWarnings(&quot;unchecked&quot;)
    public void combineLatestDelayErrorArrayOfSources() {

<span class="fc" id="L1150">        Flowable.combineLatestDelayError(new Flowable[] {</span>
<span class="fc" id="L1151">                Flowable.just(1), Flowable.just(2)</span>
<span class="fc" id="L1152">        }, new Function&lt;Object[], Object&gt;() {</span>
            @Override
            public Object apply(Object[] a) throws Exception {
<span class="fc" id="L1155">                return Arrays.toString(a);</span>
            }
        })
<span class="fc" id="L1158">        .test()</span>
<span class="fc" id="L1159">        .assertResult(&quot;[1, 2]&quot;);</span>
<span class="fc" id="L1160">    }</span>

    @Test
    @SuppressWarnings(&quot;unchecked&quot;)
    public void combineLatestDelayErrorArrayOfSourcesWithError() {

<span class="fc" id="L1166">        Flowable.combineLatestDelayError(new Flowable[] {</span>
<span class="fc" id="L1167">                Flowable.just(1), Flowable.just(2).concatWith(Flowable.&lt;Integer&gt;error(new TestException()))</span>
<span class="fc" id="L1168">        }, new Function&lt;Object[], Object&gt;() {</span>
            @Override
            public Object apply(Object[] a) throws Exception {
<span class="fc" id="L1171">                return Arrays.toString(a);</span>
            }
        })
<span class="fc" id="L1174">        .test()</span>
<span class="fc" id="L1175">        .assertFailure(TestException.class, &quot;[1, 2]&quot;);</span>
<span class="fc" id="L1176">    }</span>

    @Test
    @SuppressWarnings(&quot;unchecked&quot;)
    public void combineLatestDelayErrorIterableOfSources() {

<span class="fc" id="L1182">        Flowable.combineLatestDelayError(Arrays.asList(</span>
<span class="fc" id="L1183">                Flowable.just(1), Flowable.just(2)</span>
<span class="fc" id="L1184">        ), new Function&lt;Object[], Object&gt;() {</span>
            @Override
            public Object apply(Object[] a) throws Exception {
<span class="fc" id="L1187">                return Arrays.toString(a);</span>
            }
        })
<span class="fc" id="L1190">        .test()</span>
<span class="fc" id="L1191">        .assertResult(&quot;[1, 2]&quot;);</span>
<span class="fc" id="L1192">    }</span>

    @Test
    @SuppressWarnings(&quot;unchecked&quot;)
    public void combineLatestDelayErrorIterableOfSourcesWithError() {

<span class="fc" id="L1198">        Flowable.combineLatestDelayError(Arrays.asList(</span>
<span class="fc" id="L1199">                Flowable.just(1), Flowable.just(2).concatWith(Flowable.&lt;Integer&gt;error(new TestException()))</span>
<span class="fc" id="L1200">        ), new Function&lt;Object[], Object&gt;() {</span>
            @Override
            public Object apply(Object[] a) throws Exception {
<span class="fc" id="L1203">                return Arrays.toString(a);</span>
            }
        })
<span class="fc" id="L1206">        .test()</span>
<span class="fc" id="L1207">        .assertFailure(TestException.class, &quot;[1, 2]&quot;);</span>
<span class="fc" id="L1208">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void combineLatestEmpty() {
<span class="fc" id="L1213">        assertSame(Flowable.empty(), Flowable.combineLatest(new Flowable[0], Functions.&lt;Object[]&gt;identity(), 16));</span>
<span class="fc" id="L1214">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void combineLatestDelayErrorEmpty() {
<span class="fc" id="L1219">        assertSame(Flowable.empty(), Flowable.combineLatestDelayError(new Flowable[0], Functions.&lt;Object[]&gt;identity(), 16));</span>
<span class="fc" id="L1220">    }</span>

    @Test
    public void error() {
<span class="fc" id="L1224">        Flowable.combineLatest(Flowable.never(), Flowable.error(new TestException()), new BiFunction&lt;Object, Object, Object&gt;() {</span>
            @Override
            public Object apply(Object a, Object b) throws Exception {
<span class="nc" id="L1227">                return a;</span>
            }
        })
<span class="fc" id="L1230">        .test()</span>
<span class="fc" id="L1231">        .assertFailure(TestException.class);</span>
<span class="fc" id="L1232">    }</span>

    @Test
    public void disposed() {
<span class="fc" id="L1236">        TestHelper.checkDisposed(Flowable.combineLatest(Flowable.never(), Flowable.never(), new BiFunction&lt;Object, Object, Object&gt;() {</span>
            @Override
            public Object apply(Object a, Object b) throws Exception {
<span class="nc" id="L1239">                return a;</span>
            }
        }));
<span class="fc" id="L1242">    }</span>

    @Test
    public void cancelWhileSubscribing() {
<span class="fc" id="L1246">        final TestSubscriber&lt;Object&gt; ts = new TestSubscriber&lt;Object&gt;();</span>

<span class="fc" id="L1248">        Flowable.combineLatest(</span>
<span class="fc" id="L1249">                Flowable.just(1)</span>
<span class="fc" id="L1250">                .doOnNext(new Consumer&lt;Integer&gt;() {</span>
                    @Override
                    public void accept(Integer v) throws Exception {
<span class="fc" id="L1253">                        ts.cancel();</span>
<span class="fc" id="L1254">                    }</span>
                }),
<span class="fc" id="L1256">                Flowable.never(),</span>
<span class="fc" id="L1257">                new BiFunction&lt;Object, Object, Object&gt;() {</span>
            @Override
            public Object apply(Object a, Object b) throws Exception {
<span class="nc" id="L1260">                return a;</span>
            }
        })
<span class="fc" id="L1263">        .subscribe(ts);</span>
<span class="fc" id="L1264">    }</span>

    @Test
    public void onErrorRace() {
<span class="fc bfc" id="L1268" title="All 2 branches covered.">        for (int i = 0; i &lt; TestHelper.RACE_DEFAULT_LOOPS; i++) {</span>
<span class="fc" id="L1269">            List&lt;Throwable&gt; errors = TestHelper.trackPluginErrors();</span>
            try {
<span class="fc" id="L1271">                final PublishProcessor&lt;Integer&gt; pp1 = PublishProcessor.create();</span>
<span class="fc" id="L1272">                final PublishProcessor&lt;Integer&gt; pp2 = PublishProcessor.create();</span>

<span class="fc" id="L1274">                TestSubscriber&lt;Integer&gt; ts = Flowable.combineLatest(pp1, pp2, new BiFunction&lt;Integer, Integer, Integer&gt;() {</span>
                    @Override
                    public Integer apply(Integer a, Integer b) throws Exception {
<span class="nc" id="L1277">                        return a;</span>
                    }
<span class="fc" id="L1279">                }).test();</span>

<span class="fc" id="L1281">                final TestException ex1 = new TestException();</span>
<span class="fc" id="L1282">                final TestException ex2 = new TestException();</span>

<span class="fc" id="L1284">                Runnable r1 = new Runnable() {</span>
                    @Override
                    public void run() {
<span class="fc" id="L1287">                        pp1.onError(ex1);</span>
<span class="fc" id="L1288">                    }</span>
                };
<span class="fc" id="L1290">                Runnable r2 = new Runnable() {</span>
                    @Override
                    public void run() {
<span class="fc" id="L1293">                        pp2.onError(ex2);</span>
<span class="fc" id="L1294">                    }</span>
                };

<span class="fc" id="L1297">                TestHelper.race(r1, r2);</span>

<span class="pc bpc" id="L1299" title="1 of 2 branches missed.">                if (ts.errorCount() != 0) {</span>
<span class="fc bfc" id="L1300" title="All 2 branches covered.">                    if (ts.errors().get(0) instanceof CompositeException) {</span>
<span class="fc" id="L1301">                        ts.assertSubscribed()</span>
<span class="fc" id="L1302">                        .assertNotComplete()</span>
<span class="fc" id="L1303">                        .assertNoValues();</span>

<span class="fc bfc" id="L1305" title="All 2 branches covered.">                        for (Throwable e : TestHelper.errorList(ts)) {</span>
<span class="fc" id="L1306">                            assertTrue(e.toString(), e instanceof TestException);</span>
<span class="fc" id="L1307">                        }</span>

                    } else {
<span class="fc" id="L1310">                        ts.assertFailure(TestException.class);</span>
                    }
                }

<span class="fc bfc" id="L1314" title="All 2 branches covered.">                for (Throwable e : errors) {</span>
<span class="fc" id="L1315">                    assertTrue(e.toString(), e.getCause() instanceof TestException);</span>
<span class="fc" id="L1316">                }</span>
            } finally {
<span class="fc" id="L1318">                RxJavaPlugins.reset();</span>
            }
        }
<span class="fc" id="L1321">    }</span>

    @Test
    public void combineAsync() {
<span class="fc" id="L1325">        Flowable&lt;Integer&gt; source = Flowable.range(1, 1000).subscribeOn(Schedulers.computation());</span>

<span class="fc" id="L1327">        Flowable.combineLatest(source, source, new BiFunction&lt;Object, Object, Object&gt;() {</span>
            @Override
            public Object apply(Object a, Object b) throws Exception {
<span class="fc" id="L1330">                return a;</span>
            }
        })
<span class="fc" id="L1333">        .take(500)</span>
<span class="fc" id="L1334">        .test()</span>
<span class="fc" id="L1335">        .awaitDone(5, TimeUnit.SECONDS)</span>
<span class="fc" id="L1336">        .assertNoErrors()</span>
<span class="fc" id="L1337">        .assertComplete();</span>
<span class="fc" id="L1338">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void errorDelayed() {
<span class="fc" id="L1343">        Flowable.combineLatestDelayError(</span>
<span class="fc" id="L1344">                new Function&lt;Object[], Object&gt;() {</span>
                    @Override
                    public Object apply(Object[] a) throws Exception {
<span class="nc" id="L1347">                        return a;</span>
                    }
                },
                128,
<span class="fc" id="L1351">                Flowable.error(new TestException()),</span>
<span class="fc" id="L1352">                Flowable.just(1)</span>
        )
<span class="fc" id="L1354">        .test()</span>
<span class="fc" id="L1355">        .assertFailure(TestException.class);</span>
<span class="fc" id="L1356">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void errorDelayed2() {
<span class="fc" id="L1361">        Flowable.combineLatestDelayError(</span>
<span class="fc" id="L1362">                new Function&lt;Object[], Object&gt;() {</span>
                    @Override
                    public Object apply(Object[] a) throws Exception {
<span class="nc" id="L1365">                        return a;</span>
                    }
                },
                128,
<span class="fc" id="L1369">                Flowable.error(new TestException()).startWith(1),</span>
<span class="fc" id="L1370">                Flowable.empty()</span>
        )
<span class="fc" id="L1372">        .test()</span>
<span class="fc" id="L1373">        .assertFailure(TestException.class);</span>
<span class="fc" id="L1374">    }</span>

    @Test
    public void dontSubscribeIfDone() {
<span class="fc" id="L1378">        List&lt;Throwable&gt; errors = TestHelper.trackPluginErrors();</span>
        try {
<span class="fc" id="L1380">            final int[] count = { 0 };</span>

<span class="fc" id="L1382">            Flowable.combineLatest(Flowable.empty(),</span>
<span class="fc" id="L1383">                    Flowable.error(new TestException())</span>
<span class="fc" id="L1384">                    .doOnSubscribe(new Consumer&lt;Subscription&gt;() {</span>
                        @Override
                        public void accept(Subscription s) throws Exception {
<span class="nc" id="L1387">                            count[0]++;</span>
<span class="nc" id="L1388">                        }</span>
                    }),
<span class="fc" id="L1390">                    new BiFunction&lt;Object, Object, Object&gt;() {</span>
                        @Override
                        public Object apply(Object a, Object b) throws Exception {
<span class="nc" id="L1393">                            return 0;</span>
                        }
                    })
<span class="fc" id="L1396">            .test()</span>
<span class="fc" id="L1397">            .assertResult();</span>

<span class="fc" id="L1399">            assertEquals(0, count[0]);</span>

<span class="fc" id="L1401">            assertTrue(errors.toString(), errors.isEmpty());</span>
        } finally {
<span class="fc" id="L1403">            RxJavaPlugins.reset();</span>
        }
<span class="fc" id="L1405">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void dontSubscribeIfDone2() {
<span class="fc" id="L1410">        List&lt;Throwable&gt; errors = TestHelper.trackPluginErrors();</span>
        try {
<span class="fc" id="L1412">            final int[] count = { 0 };</span>

<span class="fc" id="L1414">            Flowable.combineLatestDelayError(</span>
<span class="fc" id="L1415">                    Arrays.asList(Flowable.empty(),</span>
<span class="fc" id="L1416">                        Flowable.error(new TestException())</span>
<span class="fc" id="L1417">                        .doOnSubscribe(new Consumer&lt;Subscription&gt;() {</span>
                            @Override
                            public void accept(Subscription s) throws Exception {
<span class="nc" id="L1420">                                count[0]++;</span>
<span class="nc" id="L1421">                            }</span>
                        })
                    ),
<span class="fc" id="L1424">                    new Function&lt;Object[], Object&gt;() {</span>
                        @Override
                        public Object apply(Object[] a) throws Exception {
<span class="nc" id="L1427">                            return 0;</span>
                        }
                    })
<span class="fc" id="L1430">            .test()</span>
<span class="fc" id="L1431">            .assertResult();</span>

<span class="fc" id="L1433">            assertEquals(0, count[0]);</span>

<span class="fc" id="L1435">            assertTrue(errors.toString(), errors.isEmpty());</span>
        } finally {
<span class="fc" id="L1437">            RxJavaPlugins.reset();</span>
        }
<span class="fc" id="L1439">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void combine2Flowable2Errors() throws Exception {
<span class="fc" id="L1444">        List&lt;Throwable&gt; errors = TestHelper.trackPluginErrors();</span>
        try {
<span class="fc" id="L1446">            TestSubscriber&lt;Object&gt; testObserver = TestSubscriber.create();</span>

<span class="fc" id="L1448">            TestScheduler testScheduler = new TestScheduler();</span>

<span class="fc" id="L1450">            Flowable&lt;Integer&gt; emptyFlowable = Flowable.timer(10, TimeUnit.MILLISECONDS, testScheduler)</span>
<span class="fc" id="L1451">                    .flatMap(new Function&lt;Long, Publisher&lt;Integer&gt;&gt;() {</span>
                        @Override
                        public Publisher&lt;Integer&gt; apply(Long aLong) throws Exception {
<span class="fc" id="L1454">                            return Flowable.error(new Exception());</span>
                        }
                    });
<span class="fc" id="L1457">            Flowable&lt;Object&gt; errorFlowable = Flowable.timer(100, TimeUnit.MILLISECONDS, testScheduler).map(new Function&lt;Long, Object&gt;() {</span>
                @Override
                public Object apply(Long aLong) throws Exception {
<span class="nc" id="L1460">                    throw new Exception();</span>
                }
            });

<span class="fc" id="L1464">            Flowable.combineLatestDelayError(</span>
<span class="fc" id="L1465">                    Arrays.asList(</span>
                            emptyFlowable
<span class="fc" id="L1467">                                    .doOnEach(new Consumer&lt;Notification&lt;Integer&gt;&gt;() {</span>
                                        @Override
                                        public void accept(Notification&lt;Integer&gt; integerNotification) throws Exception {
<span class="fc" id="L1470">                                            System.out.println(&quot;emptyFlowable: &quot; + integerNotification);</span>
<span class="fc" id="L1471">                                        }</span>
                                    })
<span class="fc" id="L1473">                                    .doFinally(new Action() {</span>
                                        @Override
                                        public void run() throws Exception {
<span class="fc" id="L1476">                                            System.out.println(&quot;emptyFlowable: doFinally&quot;);</span>
<span class="fc" id="L1477">                                        }</span>
                                    }),
                            errorFlowable
<span class="fc" id="L1480">                                    .doOnEach(new Consumer&lt;Notification&lt;Object&gt;&gt;() {</span>
                                        @Override
                                        public void accept(Notification&lt;Object&gt; integerNotification) throws Exception {
<span class="nc" id="L1483">                                            System.out.println(&quot;errorFlowable: &quot; + integerNotification);</span>
<span class="nc" id="L1484">                                        }</span>
                                    })
<span class="fc" id="L1486">                                    .doFinally(new Action() {</span>
                                        @Override
                                        public void run() throws Exception {
<span class="fc" id="L1489">                                            System.out.println(&quot;errorFlowable: doFinally&quot;);</span>
<span class="fc" id="L1490">                                        }</span>
                                    })),
<span class="fc" id="L1492">                    new Function&lt;Object[], Object&gt;() {</span>
                        @Override
                        public Object apply(Object[] objects) throws Exception {
<span class="nc" id="L1495">                            return 0;</span>
                        }
                    }
            )
<span class="fc" id="L1499">                    .doOnEach(new Consumer&lt;Notification&lt;Object&gt;&gt;() {</span>
                        @Override
                        public void accept(Notification&lt;Object&gt; integerNotification) throws Exception {
<span class="fc" id="L1502">                            System.out.println(&quot;combineLatestDelayError: &quot; + integerNotification);</span>
<span class="fc" id="L1503">                        }</span>
                    })
<span class="fc" id="L1505">                    .doFinally(new Action() {</span>
                        @Override
                        public void run() throws Exception {
<span class="fc" id="L1508">                            System.out.println(&quot;combineLatestDelayError: doFinally&quot;);</span>
<span class="fc" id="L1509">                        }</span>
                    })
<span class="fc" id="L1511">                    .subscribe(testObserver);</span>

<span class="fc" id="L1513">            testScheduler.advanceTimeBy(100, TimeUnit.MILLISECONDS);</span>

<span class="fc" id="L1515">            testObserver.awaitTerminalEvent();</span>

<span class="fc" id="L1517">            assertTrue(errors.toString(), errors.isEmpty());</span>
        } finally {
<span class="fc" id="L1519">            RxJavaPlugins.reset();</span>
        }
<span class="fc" id="L1521">    }</span>

    @Test
    public void eagerDispose() {
<span class="fc" id="L1525">        final PublishProcessor&lt;Integer&gt; pp1 = PublishProcessor.create();</span>
<span class="fc" id="L1526">        final PublishProcessor&lt;Integer&gt; pp2 = PublishProcessor.create();</span>

<span class="fc" id="L1528">        TestSubscriber&lt;Integer&gt; ts = new TestSubscriber&lt;Integer&gt;() {</span>
            @Override
            public void onNext(Integer t) {
<span class="fc" id="L1531">                super.onNext(t);</span>
<span class="fc" id="L1532">                cancel();</span>
<span class="pc bpc" id="L1533" title="1 of 2 branches missed.">                if (pp1.hasSubscribers()) {</span>
<span class="nc" id="L1534">                    onError(new IllegalStateException(&quot;pp1 not disposed&quot;));</span>
                } else
<span class="pc bpc" id="L1536" title="1 of 2 branches missed.">                if (pp2.hasSubscribers()) {</span>
<span class="nc" id="L1537">                    onError(new IllegalStateException(&quot;pp2 not disposed&quot;));</span>
                } else {
<span class="fc" id="L1539">                    onComplete();</span>
                }
<span class="fc" id="L1541">            }</span>
        };

<span class="fc" id="L1544">        Flowable.combineLatest(pp1, pp2, new BiFunction&lt;Integer, Integer, Integer&gt;() {</span>
            @Override
            public Integer apply(Integer t1, Integer t2) throws Exception {
<span class="fc" id="L1547">                return t1 + t2;</span>
            }
        })
<span class="fc" id="L1550">        .subscribe(ts);</span>

<span class="fc" id="L1552">        pp1.onNext(1);</span>
<span class="fc" id="L1553">        pp2.onNext(2);</span>
<span class="fc" id="L1554">        ts.assertResult(3);</span>
<span class="fc" id="L1555">    }</span>

    @Test
    public void fusedNullCheck() {
<span class="fc" id="L1559">        TestSubscriber&lt;Integer&gt; ts = SubscriberFusion.newTest(QueueFuseable.ASYNC);</span>

<span class="fc" id="L1561">        Flowable.combineLatest(Flowable.just(1), Flowable.just(2), new BiFunction&lt;Integer, Integer, Integer&gt;() {</span>
            @Override
            public Integer apply(Integer t1, Integer t2) throws Exception {
<span class="fc" id="L1564">                return null;</span>
            }
        })
<span class="fc" id="L1567">        .subscribe(ts);</span>

<span class="fc" id="L1569">        ts</span>
<span class="fc" id="L1570">        .assertOf(SubscriberFusion.&lt;Integer&gt;assertFusionMode(QueueFuseable.ASYNC))</span>
<span class="fc" id="L1571">        .assertFailureAndMessage(NullPointerException.class, &quot;The combiner returned a null value&quot;);</span>
<span class="fc" id="L1572">    }</span>

    @Test
    @SuppressWarnings(&quot;unchecked&quot;)
    public void syncFirstErrorsAfterItemDelayError() {
<span class="fc" id="L1577">        Flowable.combineLatestDelayError(Arrays.asList(</span>
<span class="fc" id="L1578">                    Flowable.just(21).concatWith(Flowable.&lt;Integer&gt;error(new TestException())),</span>
<span class="fc" id="L1579">                    Flowable.just(21).delay(100, TimeUnit.MILLISECONDS)</span>
                ),
<span class="fc" id="L1581">                new Function&lt;Object[], Object&gt;() {</span>
                    @Override
                    public Object apply(Object[] a) throws Exception {
<span class="fc" id="L1584">                        return (Integer)a[0] + (Integer)a[1];</span>
                    }
                }
                )
<span class="fc" id="L1588">        .test()</span>
<span class="fc" id="L1589">        .awaitDone(5, TimeUnit.SECONDS)</span>
<span class="fc" id="L1590">        .assertFailure(TestException.class, 42);</span>
<span class="fc" id="L1591">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>