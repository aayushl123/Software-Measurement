<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FlowableConcatMap.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">RxJava_2_x$Unnamed.exec</a> &gt; <a href="index.source.html" class="el_package">io.reactivex.internal.operators.flowable</a> &gt; <span class="el_source">FlowableConcatMap.java</span></div><h1>FlowableConcatMap.java</h1><pre class="source lang-java linenums">/**
 * Copyright (c) 2016-present, RxJava Contributors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is
 * distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
 * the License for the specific language governing permissions and limitations under the License.
 */
package io.reactivex.internal.operators.flowable;

import java.util.concurrent.Callable;
import java.util.concurrent.atomic.AtomicInteger;

import org.reactivestreams.*;

import io.reactivex.*;
import io.reactivex.exceptions.Exceptions;
import io.reactivex.functions.Function;
import io.reactivex.internal.functions.ObjectHelper;
import io.reactivex.internal.fuseable.*;
import io.reactivex.internal.queue.SpscArrayQueue;
import io.reactivex.internal.subscriptions.*;
import io.reactivex.internal.util.*;
import io.reactivex.plugins.RxJavaPlugins;

public final class FlowableConcatMap&lt;T, R&gt; extends AbstractFlowableWithUpstream&lt;T, R&gt; {

    final Function&lt;? super T, ? extends Publisher&lt;? extends R&gt;&gt; mapper;

    final int prefetch;

    final ErrorMode errorMode;

    public FlowableConcatMap(Flowable&lt;T&gt; source,
            Function&lt;? super T, ? extends Publisher&lt;? extends R&gt;&gt; mapper,
            int prefetch, ErrorMode errorMode) {
<span class="fc" id="L41">        super(source);</span>
<span class="fc" id="L42">        this.mapper = mapper;</span>
<span class="fc" id="L43">        this.prefetch = prefetch;</span>
<span class="fc" id="L44">        this.errorMode = errorMode;</span>
<span class="fc" id="L45">    }</span>

    public static &lt;T, R&gt; Subscriber&lt;T&gt; subscribe(Subscriber&lt;? super R&gt; s, Function&lt;? super T, ? extends Publisher&lt;? extends R&gt;&gt; mapper,
            int prefetch, ErrorMode errorMode) {
<span class="fc bfc" id="L49" title="All 3 branches covered.">        switch (errorMode) {</span>
        case BOUNDARY:
<span class="fc" id="L51">            return new ConcatMapDelayed&lt;T, R&gt;(s, mapper, prefetch, false);</span>
        case END:
<span class="fc" id="L53">            return new ConcatMapDelayed&lt;T, R&gt;(s, mapper, prefetch, true);</span>
        default:
<span class="fc" id="L55">            return new ConcatMapImmediate&lt;T, R&gt;(s, mapper, prefetch);</span>
        }
    }

    @Override
    protected void subscribeActual(Subscriber&lt;? super R&gt; s) {

<span class="fc bfc" id="L62" title="All 2 branches covered.">        if (FlowableScalarXMap.tryScalarXMapSubscribe(source, s, mapper)) {</span>
<span class="fc" id="L63">            return;</span>
        }

<span class="fc" id="L66">        source.subscribe(subscribe(s, mapper, prefetch, errorMode));</span>
<span class="fc" id="L67">    }</span>

    abstract static class BaseConcatMapSubscriber&lt;T, R&gt;
    extends AtomicInteger
    implements FlowableSubscriber&lt;T&gt;, ConcatMapSupport&lt;R&gt;, Subscription {

        private static final long serialVersionUID = -3511336836796789179L;

        final ConcatMapInner&lt;R&gt; inner;

        final Function&lt;? super T, ? extends Publisher&lt;? extends R&gt;&gt; mapper;

        final int prefetch;

        final int limit;

        Subscription upstream;

        int consumed;

        SimpleQueue&lt;T&gt; queue;

        volatile boolean done;

        volatile boolean cancelled;

        final AtomicThrowable errors;

        volatile boolean active;

        int sourceMode;

        BaseConcatMapSubscriber(
                Function&lt;? super T, ? extends Publisher&lt;? extends R&gt;&gt; mapper,
<span class="fc" id="L101">                int prefetch) {</span>
<span class="fc" id="L102">            this.mapper = mapper;</span>
<span class="fc" id="L103">            this.prefetch = prefetch;</span>
<span class="fc" id="L104">            this.limit = prefetch - (prefetch &gt;&gt; 2);</span>
<span class="fc" id="L105">            this.inner = new ConcatMapInner&lt;R&gt;(this);</span>
<span class="fc" id="L106">            this.errors = new AtomicThrowable();</span>
<span class="fc" id="L107">        }</span>

        @Override
        public final void onSubscribe(Subscription s) {
<span class="fc bfc" id="L111" title="All 2 branches covered.">            if (SubscriptionHelper.validate(this.upstream, s))  {</span>
<span class="fc" id="L112">                this.upstream = s;</span>

<span class="fc bfc" id="L114" title="All 2 branches covered.">                if (s instanceof QueueSubscription) {</span>
<span class="fc" id="L115">                    @SuppressWarnings(&quot;unchecked&quot;) QueueSubscription&lt;T&gt; f = (QueueSubscription&lt;T&gt;)s;</span>
<span class="fc" id="L116">                    int m = f.requestFusion(QueueSubscription.ANY | QueueSubscription.BOUNDARY);</span>
<span class="fc bfc" id="L117" title="All 2 branches covered.">                    if (m == QueueSubscription.SYNC) {</span>
<span class="fc" id="L118">                        sourceMode = m;</span>
<span class="fc" id="L119">                        queue = f;</span>
<span class="fc" id="L120">                        done = true;</span>

<span class="fc" id="L122">                        subscribeActual();</span>

<span class="fc" id="L124">                        drain();</span>
<span class="fc" id="L125">                        return;</span>
                    }
<span class="fc bfc" id="L127" title="All 2 branches covered.">                    if (m == QueueSubscription.ASYNC) {</span>
<span class="fc" id="L128">                        sourceMode = m;</span>
<span class="fc" id="L129">                        queue = f;</span>

<span class="fc" id="L131">                        subscribeActual();</span>

<span class="fc" id="L133">                        s.request(prefetch);</span>
<span class="fc" id="L134">                        return;</span>
                    }
                }

<span class="fc" id="L138">                queue = new SpscArrayQueue&lt;T&gt;(prefetch);</span>

<span class="fc" id="L140">                subscribeActual();</span>

<span class="fc" id="L142">                s.request(prefetch);</span>
            }
<span class="fc" id="L144">        }</span>

        abstract void drain();

        abstract void subscribeActual();

        @Override
        public final void onNext(T t) {
<span class="fc bfc" id="L152" title="All 2 branches covered.">            if (sourceMode != QueueSubscription.ASYNC) {</span>
<span class="fc bfc" id="L153" title="All 2 branches covered.">                if (!queue.offer(t)) {</span>
<span class="fc" id="L154">                    upstream.cancel();</span>
<span class="fc" id="L155">                    onError(new IllegalStateException(&quot;Queue full?!&quot;));</span>
<span class="fc" id="L156">                    return;</span>
                }
            }
<span class="fc" id="L159">            drain();</span>
<span class="fc" id="L160">        }</span>

        @Override
        public final void onComplete() {
<span class="fc" id="L164">            done = true;</span>
<span class="fc" id="L165">            drain();</span>
<span class="fc" id="L166">        }</span>

        @Override
        public final void innerComplete() {
<span class="fc" id="L170">            active = false;</span>
<span class="fc" id="L171">            drain();</span>
<span class="fc" id="L172">        }</span>

    }

    static final class ConcatMapImmediate&lt;T, R&gt;
    extends BaseConcatMapSubscriber&lt;T, R&gt; {

        private static final long serialVersionUID = 7898995095634264146L;

        final Subscriber&lt;? super R&gt; downstream;

        final AtomicInteger wip;

        ConcatMapImmediate(Subscriber&lt;? super R&gt; actual,
                Function&lt;? super T, ? extends Publisher&lt;? extends R&gt;&gt; mapper,
                int prefetch) {
<span class="fc" id="L188">            super(mapper, prefetch);</span>
<span class="fc" id="L189">            this.downstream = actual;</span>
<span class="fc" id="L190">            this.wip = new AtomicInteger();</span>
<span class="fc" id="L191">        }</span>

        @Override
        void subscribeActual() {
<span class="fc" id="L195">            downstream.onSubscribe(this);</span>
<span class="fc" id="L196">        }</span>

        @Override
        public void onError(Throwable t) {
<span class="fc bfc" id="L200" title="All 2 branches covered.">            if (errors.addThrowable(t)) {</span>
<span class="fc" id="L201">                inner.cancel();</span>

<span class="fc bfc" id="L203" title="All 2 branches covered.">                if (getAndIncrement() == 0) {</span>
<span class="fc" id="L204">                    downstream.onError(errors.terminate());</span>
                }
            } else {
<span class="fc" id="L207">                RxJavaPlugins.onError(t);</span>
            }
<span class="fc" id="L209">        }</span>

        @Override
        public void innerNext(R value) {
<span class="pc bpc" id="L213" title="2 of 4 branches missed.">            if (get() == 0 &amp;&amp; compareAndSet(0, 1)) {</span>
<span class="fc" id="L214">                downstream.onNext(value);</span>
<span class="fc bfc" id="L215" title="All 2 branches covered.">                if (compareAndSet(1, 0)) {</span>
<span class="fc" id="L216">                    return;</span>
                }
<span class="fc" id="L218">                downstream.onError(errors.terminate());</span>
            }
<span class="fc" id="L220">        }</span>

        @Override
        public void innerError(Throwable e) {
<span class="fc bfc" id="L224" title="All 2 branches covered.">            if (errors.addThrowable(e)) {</span>
<span class="fc" id="L225">                upstream.cancel();</span>

<span class="pc bpc" id="L227" title="1 of 2 branches missed.">                if (getAndIncrement() == 0) {</span>
<span class="fc" id="L228">                    downstream.onError(errors.terminate());</span>
                }
            } else {
<span class="fc" id="L231">                RxJavaPlugins.onError(e);</span>
            }
<span class="fc" id="L233">        }</span>

        @Override
        public void request(long n) {
<span class="fc" id="L237">            inner.request(n);</span>
<span class="fc" id="L238">        }</span>

        @Override
        public void cancel() {
<span class="fc bfc" id="L242" title="All 2 branches covered.">            if (!cancelled) {</span>
<span class="fc" id="L243">                cancelled = true;</span>

<span class="fc" id="L245">                inner.cancel();</span>
<span class="fc" id="L246">                upstream.cancel();</span>
            }
<span class="fc" id="L248">        }</span>

        @Override
        void drain() {
<span class="fc bfc" id="L252" title="All 2 branches covered.">            if (wip.getAndIncrement() == 0) {</span>
                for (;;) {
<span class="fc bfc" id="L254" title="All 2 branches covered.">                    if (cancelled) {</span>
<span class="fc" id="L255">                        return;</span>
                    }

<span class="fc bfc" id="L258" title="All 2 branches covered.">                    if (!active) {</span>
<span class="fc" id="L259">                        boolean d = done;</span>

                        T v;

                        try {
<span class="fc" id="L264">                            v = queue.poll();</span>
<span class="fc" id="L265">                        } catch (Throwable e) {</span>
<span class="fc" id="L266">                            Exceptions.throwIfFatal(e);</span>
<span class="fc" id="L267">                            upstream.cancel();</span>
<span class="fc" id="L268">                            errors.addThrowable(e);</span>
<span class="fc" id="L269">                            downstream.onError(errors.terminate());</span>
<span class="fc" id="L270">                            return;</span>
<span class="fc" id="L271">                        }</span>

<span class="fc bfc" id="L273" title="All 2 branches covered.">                        boolean empty = v == null;</span>

<span class="fc bfc" id="L275" title="All 4 branches covered.">                        if (d &amp;&amp; empty) {</span>
<span class="fc" id="L276">                            downstream.onComplete();</span>
<span class="fc" id="L277">                            return;</span>
                        }

<span class="fc bfc" id="L280" title="All 2 branches covered.">                        if (!empty) {</span>
                            Publisher&lt;? extends R&gt; p;

                            try {
<span class="fc" id="L284">                                p = ObjectHelper.requireNonNull(mapper.apply(v), &quot;The mapper returned a null Publisher&quot;);</span>
<span class="fc" id="L285">                            } catch (Throwable e) {</span>
<span class="fc" id="L286">                                Exceptions.throwIfFatal(e);</span>

<span class="fc" id="L288">                                upstream.cancel();</span>
<span class="fc" id="L289">                                errors.addThrowable(e);</span>
<span class="fc" id="L290">                                downstream.onError(errors.terminate());</span>
<span class="fc" id="L291">                                return;</span>
<span class="fc" id="L292">                            }</span>

<span class="fc bfc" id="L294" title="All 2 branches covered.">                            if (sourceMode != QueueSubscription.SYNC) {</span>
<span class="fc" id="L295">                                int c = consumed + 1;</span>
<span class="fc bfc" id="L296" title="All 2 branches covered.">                                if (c == limit) {</span>
<span class="fc" id="L297">                                    consumed = 0;</span>
<span class="fc" id="L298">                                    upstream.request(c);</span>
                                } else {
<span class="fc" id="L300">                                    consumed = c;</span>
                                }
                            }

<span class="fc bfc" id="L304" title="All 2 branches covered.">                            if (p instanceof Callable) {</span>
                                @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L306">                                Callable&lt;R&gt; callable = (Callable&lt;R&gt;) p;</span>

                                R vr;

                                try {
<span class="fc" id="L311">                                    vr = callable.call();</span>
<span class="fc" id="L312">                                } catch (Throwable e) {</span>
<span class="fc" id="L313">                                    Exceptions.throwIfFatal(e);</span>
<span class="fc" id="L314">                                    upstream.cancel();</span>
<span class="fc" id="L315">                                    errors.addThrowable(e);</span>
<span class="fc" id="L316">                                    downstream.onError(errors.terminate());</span>
<span class="fc" id="L317">                                    return;</span>
<span class="fc" id="L318">                                }</span>

<span class="fc bfc" id="L320" title="All 2 branches covered.">                                if (vr == null) {</span>
<span class="fc" id="L321">                                    continue;</span>
                                }

<span class="fc bfc" id="L324" title="All 2 branches covered.">                                if (inner.isUnbounded()) {</span>
<span class="pc bpc" id="L325" title="2 of 4 branches missed.">                                    if (get() == 0 &amp;&amp; compareAndSet(0, 1)) {</span>
<span class="fc" id="L326">                                        downstream.onNext(vr);</span>
<span class="fc bfc" id="L327" title="All 2 branches covered.">                                        if (!compareAndSet(1, 0)) {</span>
<span class="fc" id="L328">                                            downstream.onError(errors.terminate());</span>
<span class="fc" id="L329">                                            return;</span>
                                        }
                                    }
                                    continue;
                                } else {
<span class="fc" id="L334">                                    active = true;</span>
<span class="fc" id="L335">                                    inner.setSubscription(new WeakScalarSubscription&lt;R&gt;(vr, inner));</span>
                                }

<span class="fc" id="L338">                            } else {</span>
<span class="fc" id="L339">                                active = true;</span>
<span class="fc" id="L340">                                p.subscribe(inner);</span>
                            }
                        }
                    }
<span class="fc bfc" id="L344" title="All 2 branches covered.">                    if (wip.decrementAndGet() == 0) {</span>
<span class="fc" id="L345">                        break;</span>
                    }
                }
            }
<span class="fc" id="L349">        }</span>
    }

    static final class WeakScalarSubscription&lt;T&gt; implements Subscription {
        final Subscriber&lt;? super T&gt; downstream;
        final T value;
        boolean once;

<span class="fc" id="L357">        WeakScalarSubscription(T value, Subscriber&lt;? super T&gt; downstream) {</span>
<span class="fc" id="L358">            this.value = value;</span>
<span class="fc" id="L359">            this.downstream = downstream;</span>
<span class="fc" id="L360">        }</span>

        @Override
        public void request(long n) {
<span class="fc bfc" id="L364" title="All 4 branches covered.">            if (n &gt; 0 &amp;&amp; !once) {</span>
<span class="fc" id="L365">                once = true;</span>
<span class="fc" id="L366">                Subscriber&lt;? super T&gt; a = downstream;</span>
<span class="fc" id="L367">                a.onNext(value);</span>
<span class="fc" id="L368">                a.onComplete();</span>
            }
<span class="fc" id="L370">        }</span>

        @Override
        public void cancel() {

<span class="fc" id="L375">        }</span>
    }

    static final class ConcatMapDelayed&lt;T, R&gt;
    extends BaseConcatMapSubscriber&lt;T, R&gt; {

        private static final long serialVersionUID = -2945777694260521066L;

        final Subscriber&lt;? super R&gt; downstream;

        final boolean veryEnd;

        ConcatMapDelayed(Subscriber&lt;? super R&gt; actual,
                Function&lt;? super T, ? extends Publisher&lt;? extends R&gt;&gt; mapper,
                int prefetch, boolean veryEnd) {
<span class="fc" id="L390">            super(mapper, prefetch);</span>
<span class="fc" id="L391">            this.downstream = actual;</span>
<span class="fc" id="L392">            this.veryEnd = veryEnd;</span>
<span class="fc" id="L393">        }</span>

        @Override
        void subscribeActual() {
<span class="fc" id="L397">            downstream.onSubscribe(this);</span>
<span class="fc" id="L398">        }</span>

        @Override
        public void onError(Throwable t) {
<span class="pc bpc" id="L402" title="1 of 2 branches missed.">            if (errors.addThrowable(t)) {</span>
<span class="fc" id="L403">                done = true;</span>
<span class="fc" id="L404">                drain();</span>
            } else {
<span class="nc" id="L406">                RxJavaPlugins.onError(t);</span>
            }
<span class="fc" id="L408">        }</span>

        @Override
        public void innerNext(R value) {
<span class="fc" id="L412">            downstream.onNext(value);</span>
<span class="fc" id="L413">        }</span>

        @Override
        public void innerError(Throwable e) {
<span class="fc bfc" id="L417" title="All 2 branches covered.">            if (errors.addThrowable(e)) {</span>
<span class="fc bfc" id="L418" title="All 2 branches covered.">                if (!veryEnd) {</span>
<span class="fc" id="L419">                    upstream.cancel();</span>
<span class="fc" id="L420">                    done = true;</span>
                }
<span class="fc" id="L422">                active = false;</span>
<span class="fc" id="L423">                drain();</span>
            } else {
<span class="fc" id="L425">                RxJavaPlugins.onError(e);</span>
            }
<span class="fc" id="L427">        }</span>

        @Override
        public void request(long n) {
<span class="fc" id="L431">            inner.request(n);</span>
<span class="fc" id="L432">        }</span>

        @Override
        public void cancel() {
<span class="fc bfc" id="L436" title="All 2 branches covered.">            if (!cancelled) {</span>
<span class="fc" id="L437">                cancelled = true;</span>

<span class="fc" id="L439">                inner.cancel();</span>
<span class="fc" id="L440">                upstream.cancel();</span>
            }
<span class="fc" id="L442">        }</span>

        @Override
        void drain() {
<span class="fc bfc" id="L446" title="All 2 branches covered.">            if (getAndIncrement() == 0) {</span>

                for (;;) {
<span class="fc bfc" id="L449" title="All 2 branches covered.">                    if (cancelled) {</span>
<span class="fc" id="L450">                        return;</span>
                    }

<span class="fc bfc" id="L453" title="All 2 branches covered.">                    if (!active) {</span>

<span class="fc" id="L455">                        boolean d = done;</span>

<span class="fc bfc" id="L457" title="All 4 branches covered.">                        if (d &amp;&amp; !veryEnd) {</span>
<span class="fc" id="L458">                            Throwable ex = errors.get();</span>
<span class="fc bfc" id="L459" title="All 2 branches covered.">                            if (ex != null) {</span>
<span class="fc" id="L460">                                downstream.onError(errors.terminate());</span>
<span class="fc" id="L461">                                return;</span>
                            }
                        }

                        T v;

                        try {
<span class="fc" id="L468">                            v = queue.poll();</span>
<span class="fc" id="L469">                        } catch (Throwable e) {</span>
<span class="fc" id="L470">                            Exceptions.throwIfFatal(e);</span>
<span class="fc" id="L471">                            upstream.cancel();</span>
<span class="fc" id="L472">                            errors.addThrowable(e);</span>
<span class="fc" id="L473">                            downstream.onError(errors.terminate());</span>
<span class="fc" id="L474">                            return;</span>
<span class="fc" id="L475">                        }</span>

<span class="fc bfc" id="L477" title="All 2 branches covered.">                        boolean empty = v == null;</span>

<span class="fc bfc" id="L479" title="All 4 branches covered.">                        if (d &amp;&amp; empty) {</span>
<span class="fc" id="L480">                            Throwable ex = errors.terminate();</span>
<span class="fc bfc" id="L481" title="All 2 branches covered.">                            if (ex != null) {</span>
<span class="fc" id="L482">                                downstream.onError(ex);</span>
                            } else {
<span class="fc" id="L484">                                downstream.onComplete();</span>
                            }
<span class="fc" id="L486">                            return;</span>
                        }

<span class="fc bfc" id="L489" title="All 2 branches covered.">                        if (!empty) {</span>
                            Publisher&lt;? extends R&gt; p;

                            try {
<span class="fc" id="L493">                                p = ObjectHelper.requireNonNull(mapper.apply(v), &quot;The mapper returned a null Publisher&quot;);</span>
<span class="fc" id="L494">                            } catch (Throwable e) {</span>
<span class="fc" id="L495">                                Exceptions.throwIfFatal(e);</span>

<span class="fc" id="L497">                                upstream.cancel();</span>
<span class="fc" id="L498">                                errors.addThrowable(e);</span>
<span class="fc" id="L499">                                downstream.onError(errors.terminate());</span>
<span class="fc" id="L500">                                return;</span>
<span class="fc" id="L501">                            }</span>

<span class="fc bfc" id="L503" title="All 2 branches covered.">                            if (sourceMode != QueueSubscription.SYNC) {</span>
<span class="fc" id="L504">                                int c = consumed + 1;</span>
<span class="fc bfc" id="L505" title="All 2 branches covered.">                                if (c == limit) {</span>
<span class="fc" id="L506">                                    consumed = 0;</span>
<span class="fc" id="L507">                                    upstream.request(c);</span>
                                } else {
<span class="fc" id="L509">                                    consumed = c;</span>
                                }
                            }

<span class="fc bfc" id="L513" title="All 2 branches covered.">                            if (p instanceof Callable) {</span>
                                @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L515">                                Callable&lt;R&gt; supplier = (Callable&lt;R&gt;) p;</span>

                                R vr;

                                try {
<span class="fc" id="L520">                                    vr = supplier.call();</span>
<span class="fc" id="L521">                                } catch (Throwable e) {</span>
<span class="fc" id="L522">                                    Exceptions.throwIfFatal(e);</span>
<span class="fc" id="L523">                                    upstream.cancel();</span>
<span class="fc" id="L524">                                    errors.addThrowable(e);</span>
<span class="fc" id="L525">                                    downstream.onError(errors.terminate());</span>
<span class="fc" id="L526">                                    return;</span>
<span class="fc" id="L527">                                }</span>

<span class="fc bfc" id="L529" title="All 2 branches covered.">                                if (vr == null) {</span>
<span class="fc" id="L530">                                    continue;</span>
                                }

<span class="fc bfc" id="L533" title="All 2 branches covered.">                                if (inner.isUnbounded()) {</span>
<span class="fc" id="L534">                                    downstream.onNext(vr);</span>
<span class="fc" id="L535">                                    continue;</span>
                                } else {
<span class="fc" id="L537">                                    active = true;</span>
<span class="fc" id="L538">                                    inner.setSubscription(new WeakScalarSubscription&lt;R&gt;(vr, inner));</span>
                                }
<span class="fc" id="L540">                            } else {</span>
<span class="fc" id="L541">                                active = true;</span>
<span class="fc" id="L542">                                p.subscribe(inner);</span>
                            }
                        }
                    }
<span class="fc bfc" id="L546" title="All 2 branches covered.">                    if (decrementAndGet() == 0) {</span>
<span class="fc" id="L547">                        break;</span>
                    }
                }
            }
<span class="fc" id="L551">        }</span>
    }

    interface ConcatMapSupport&lt;T&gt; {

        void innerNext(T value);

        void innerComplete();

        void innerError(Throwable e);
    }

    static final class ConcatMapInner&lt;R&gt;
    extends SubscriptionArbiter
    implements FlowableSubscriber&lt;R&gt; {

        private static final long serialVersionUID = 897683679971470653L;

        final ConcatMapSupport&lt;R&gt; parent;

        long produced;

        ConcatMapInner(ConcatMapSupport&lt;R&gt; parent) {
<span class="fc" id="L574">            super(false);</span>
<span class="fc" id="L575">            this.parent = parent;</span>
<span class="fc" id="L576">        }</span>

        @Override
        public void onSubscribe(Subscription s) {
<span class="fc" id="L580">            setSubscription(s);</span>
<span class="fc" id="L581">        }</span>

        @Override
        public void onNext(R t) {
<span class="fc" id="L585">            produced++;</span>

<span class="fc" id="L587">            parent.innerNext(t);</span>
<span class="fc" id="L588">        }</span>

        @Override
        public void onError(Throwable t) {
<span class="fc" id="L592">            long p = produced;</span>

<span class="fc bfc" id="L594" title="All 2 branches covered.">            if (p != 0L) {</span>
<span class="fc" id="L595">                produced = 0L;</span>
<span class="fc" id="L596">                produced(p);</span>
            }

<span class="fc" id="L599">            parent.innerError(t);</span>
<span class="fc" id="L600">        }</span>

        @Override
        public void onComplete() {
<span class="fc" id="L604">            long p = produced;</span>

<span class="fc bfc" id="L606" title="All 2 branches covered.">            if (p != 0L) {</span>
<span class="fc" id="L607">                produced = 0L;</span>
<span class="fc" id="L608">                produced(p);</span>
            }

<span class="fc" id="L611">            parent.innerComplete();</span>
<span class="fc" id="L612">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>