<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FlowableConcatMapEagerTest.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">RxJava_2_x$Unnamed.exec</a> &gt; <a href="index.source.html" class="el_package">io.reactivex.internal.operators.flowable</a> &gt; <span class="el_source">FlowableConcatMapEagerTest.java</span></div><h1>FlowableConcatMapEagerTest.java</h1><pre class="source lang-java linenums">/**
 * Copyright (c) 2016-present, RxJava Contributors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is
 * distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
 * the License for the specific language governing permissions and limitations under the License.
 */

package io.reactivex.internal.operators.flowable;

import static org.junit.Assert.*;

import java.lang.reflect.Method;
import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.*;

import org.junit.*;
import org.reactivestreams.*;

import io.reactivex.*;
import io.reactivex.exceptions.*;
import io.reactivex.functions.*;
import io.reactivex.internal.functions.Functions;
import io.reactivex.internal.subscriptions.BooleanSubscription;
import io.reactivex.plugins.RxJavaPlugins;
import io.reactivex.processors.*;
import io.reactivex.schedulers.Schedulers;
import io.reactivex.subscribers.TestSubscriber;

<span class="fc" id="L36">public class FlowableConcatMapEagerTest {</span>

    @Test
    public void normal() {
<span class="fc" id="L40">        Flowable.range(1, 5)</span>
<span class="fc" id="L41">        .concatMapEager(new Function&lt;Integer, Publisher&lt;Integer&gt;&gt;() {</span>
            @Override
            public Publisher&lt;Integer&gt; apply(Integer t) {
<span class="fc" id="L44">                return Flowable.range(t, 2);</span>
            }
        })
<span class="fc" id="L47">        .test()</span>
<span class="fc" id="L48">        .assertResult(1, 2, 2, 3, 3, 4, 4, 5, 5, 6);</span>
<span class="fc" id="L49">    }</span>

    @Test
    public void normalBackpressured() {
<span class="fc" id="L53">        TestSubscriber&lt;Integer&gt; ts = Flowable.range(1, 5)</span>
<span class="fc" id="L54">        .concatMapEager(new Function&lt;Integer, Publisher&lt;Integer&gt;&gt;() {</span>
            @Override
            public Publisher&lt;Integer&gt; apply(Integer t) {
<span class="fc" id="L57">                return Flowable.range(t, 2);</span>
            }
        })
<span class="fc" id="L60">        .test(3);</span>

<span class="fc" id="L62">        ts.assertValues(1, 2, 2);</span>

<span class="fc" id="L64">        ts.request(1);</span>

<span class="fc" id="L66">        ts.assertValues(1, 2, 2, 3);</span>

<span class="fc" id="L68">        ts.request(1);</span>

<span class="fc" id="L70">        ts.assertValues(1, 2, 2, 3, 3);</span>

<span class="fc" id="L72">        ts.request(5);</span>

<span class="fc" id="L74">        ts.assertResult(1, 2, 2, 3, 3, 4, 4, 5, 5, 6);</span>
<span class="fc" id="L75">    }</span>

    @Test
    public void normalDelayBoundary() {
<span class="fc" id="L79">        Flowable.range(1, 5)</span>
<span class="fc" id="L80">        .concatMapEagerDelayError(new Function&lt;Integer, Publisher&lt;Integer&gt;&gt;() {</span>
            @Override
            public Publisher&lt;Integer&gt; apply(Integer t) {
<span class="fc" id="L83">                return Flowable.range(t, 2);</span>
            }
        }, false)
<span class="fc" id="L86">        .test()</span>
<span class="fc" id="L87">        .assertResult(1, 2, 2, 3, 3, 4, 4, 5, 5, 6);</span>
<span class="fc" id="L88">    }</span>

    @Test
    public void normalDelayBoundaryBackpressured() {
<span class="fc" id="L92">        TestSubscriber&lt;Integer&gt; ts = Flowable.range(1, 5)</span>
<span class="fc" id="L93">        .concatMapEagerDelayError(new Function&lt;Integer, Publisher&lt;Integer&gt;&gt;() {</span>
            @Override
            public Publisher&lt;Integer&gt; apply(Integer t) {
<span class="fc" id="L96">                return Flowable.range(t, 2);</span>
            }
        }, false)
<span class="fc" id="L99">        .test(3);</span>

<span class="fc" id="L101">        ts.assertValues(1, 2, 2);</span>

<span class="fc" id="L103">        ts.request(1);</span>

<span class="fc" id="L105">        ts.assertValues(1, 2, 2, 3);</span>

<span class="fc" id="L107">        ts.request(1);</span>

<span class="fc" id="L109">        ts.assertValues(1, 2, 2, 3, 3);</span>

<span class="fc" id="L111">        ts.request(5);</span>

<span class="fc" id="L113">        ts.assertResult(1, 2, 2, 3, 3, 4, 4, 5, 5, 6);</span>
<span class="fc" id="L114">    }</span>

    @Test
    public void normalDelayEnd() {
<span class="fc" id="L118">        Flowable.range(1, 5)</span>
<span class="fc" id="L119">        .concatMapEagerDelayError(new Function&lt;Integer, Publisher&lt;Integer&gt;&gt;() {</span>
            @Override
            public Publisher&lt;Integer&gt; apply(Integer t) {
<span class="fc" id="L122">                return Flowable.range(t, 2);</span>
            }
        }, true)
<span class="fc" id="L125">        .test()</span>
<span class="fc" id="L126">        .assertResult(1, 2, 2, 3, 3, 4, 4, 5, 5, 6);</span>
<span class="fc" id="L127">    }</span>

    @Test
    public void normalDelayEndBackpressured() {
<span class="fc" id="L131">        TestSubscriber&lt;Integer&gt; ts = Flowable.range(1, 5)</span>
<span class="fc" id="L132">        .concatMapEagerDelayError(new Function&lt;Integer, Publisher&lt;Integer&gt;&gt;() {</span>
            @Override
            public Publisher&lt;Integer&gt; apply(Integer t) {
<span class="fc" id="L135">                return Flowable.range(t, 2);</span>
            }
        }, true)
<span class="fc" id="L138">        .test(3);</span>

<span class="fc" id="L140">        ts.assertValues(1, 2, 2);</span>

<span class="fc" id="L142">        ts.request(1);</span>

<span class="fc" id="L144">        ts.assertValues(1, 2, 2, 3);</span>

<span class="fc" id="L146">        ts.request(1);</span>

<span class="fc" id="L148">        ts.assertValues(1, 2, 2, 3, 3);</span>

<span class="fc" id="L150">        ts.request(5);</span>

<span class="fc" id="L152">        ts.assertResult(1, 2, 2, 3, 3, 4, 4, 5, 5, 6);</span>
<span class="fc" id="L153">    }</span>

    @Test
    public void mainErrorsDelayBoundary() {
<span class="fc" id="L157">        PublishProcessor&lt;Integer&gt; main = PublishProcessor.create();</span>
<span class="fc" id="L158">        final PublishProcessor&lt;Integer&gt; inner = PublishProcessor.create();</span>

<span class="fc" id="L160">        TestSubscriber&lt;Integer&gt; ts = main.concatMapEagerDelayError(</span>
<span class="fc" id="L161">                new Function&lt;Integer, Publisher&lt;Integer&gt;&gt;() {</span>
                    @Override
                    public Publisher&lt;Integer&gt; apply(Integer t) {
<span class="fc" id="L164">                        return inner;</span>
                    }
<span class="fc" id="L166">                }, false).test();</span>

<span class="fc" id="L168">        main.onNext(1);</span>

<span class="fc" id="L170">        inner.onNext(2);</span>

<span class="fc" id="L172">        ts.assertValue(2);</span>

<span class="fc" id="L174">        main.onError(new TestException(&quot;Forced failure&quot;));</span>

<span class="fc" id="L176">        ts.assertNoErrors();</span>

<span class="fc" id="L178">        inner.onNext(3);</span>
<span class="fc" id="L179">        inner.onComplete();</span>

<span class="fc" id="L181">        ts.assertFailureAndMessage(TestException.class, &quot;Forced failure&quot;, 2, 3);</span>
<span class="fc" id="L182">    }</span>

    @Test
    public void mainErrorsDelayEnd() {
<span class="fc" id="L186">        PublishProcessor&lt;Integer&gt; main = PublishProcessor.create();</span>
<span class="fc" id="L187">        final PublishProcessor&lt;Integer&gt; inner = PublishProcessor.create();</span>

<span class="fc" id="L189">        TestSubscriber&lt;Integer&gt; ts = main.concatMapEagerDelayError(</span>
<span class="fc" id="L190">                new Function&lt;Integer, Publisher&lt;Integer&gt;&gt;() {</span>
                    @Override
                    public Publisher&lt;Integer&gt; apply(Integer t) {
<span class="fc" id="L193">                        return inner;</span>
                    }
<span class="fc" id="L195">                }, true).test();</span>

<span class="fc" id="L197">        main.onNext(1);</span>
<span class="fc" id="L198">        main.onNext(2);</span>

<span class="fc" id="L200">        inner.onNext(2);</span>

<span class="fc" id="L202">        ts.assertValue(2);</span>

<span class="fc" id="L204">        main.onError(new TestException(&quot;Forced failure&quot;));</span>

<span class="fc" id="L206">        ts.assertNoErrors();</span>

<span class="fc" id="L208">        inner.onNext(3);</span>
<span class="fc" id="L209">        inner.onComplete();</span>

<span class="fc" id="L211">        ts.assertFailureAndMessage(TestException.class, &quot;Forced failure&quot;, 2, 3, 2, 3);</span>
<span class="fc" id="L212">    }</span>

    @Test
    public void mainErrorsImmediate() {
<span class="fc" id="L216">        PublishProcessor&lt;Integer&gt; main = PublishProcessor.create();</span>
<span class="fc" id="L217">        final PublishProcessor&lt;Integer&gt; inner = PublishProcessor.create();</span>

<span class="fc" id="L219">        TestSubscriber&lt;Integer&gt; ts = main.concatMapEager(</span>
<span class="fc" id="L220">                new Function&lt;Integer, Publisher&lt;Integer&gt;&gt;() {</span>
                    @Override
                    public Publisher&lt;Integer&gt; apply(Integer t) {
<span class="fc" id="L223">                        return inner;</span>
                    }
<span class="fc" id="L225">                }).test();</span>

<span class="fc" id="L227">        main.onNext(1);</span>
<span class="fc" id="L228">        main.onNext(2);</span>

<span class="fc" id="L230">        inner.onNext(2);</span>

<span class="fc" id="L232">        ts.assertValue(2);</span>

<span class="fc" id="L234">        main.onError(new TestException(&quot;Forced failure&quot;));</span>

<span class="fc" id="L236">        assertFalse(&quot;inner has subscribers?&quot;, inner.hasSubscribers());</span>

<span class="fc" id="L238">        inner.onNext(3);</span>
<span class="fc" id="L239">        inner.onComplete();</span>

<span class="fc" id="L241">        ts.assertFailureAndMessage(TestException.class, &quot;Forced failure&quot;, 2);</span>
<span class="fc" id="L242">    }</span>

    @Test
    public void longEager() {

<span class="fc" id="L247">        Flowable.range(1, 2 * Flowable.bufferSize())</span>
<span class="fc" id="L248">        .concatMapEager(new Function&lt;Integer, Publisher&lt;Integer&gt;&gt;() {</span>
            @Override
            public Publisher&lt;Integer&gt; apply(Integer v) {
<span class="fc" id="L251">                return Flowable.just(1);</span>
            }
        })
<span class="fc" id="L254">        .test()</span>
<span class="fc" id="L255">        .assertValueCount(2 * Flowable.bufferSize())</span>
<span class="fc" id="L256">        .assertNoErrors()</span>
<span class="fc" id="L257">        .assertComplete();</span>
<span class="fc" id="L258">    }</span>

    TestSubscriber&lt;Object&gt; ts;
    TestSubscriber&lt;Object&gt; tsBp;

<span class="fc" id="L263">    Function&lt;Integer, Flowable&lt;Integer&gt;&gt; toJust = new Function&lt;Integer, Flowable&lt;Integer&gt;&gt;() {</span>
        @Override
        public Flowable&lt;Integer&gt; apply(Integer t) {
<span class="fc" id="L266">            return Flowable.just(t);</span>
        }
    };

<span class="fc" id="L270">    Function&lt;Integer, Flowable&lt;Integer&gt;&gt; toRange = new Function&lt;Integer, Flowable&lt;Integer&gt;&gt;() {</span>
        @Override
        public Flowable&lt;Integer&gt; apply(Integer t) {
<span class="fc" id="L273">            return Flowable.range(t, 2);</span>
        }
    };

    @Before
    public void before() {
<span class="fc" id="L279">        ts = new TestSubscriber&lt;Object&gt;();</span>
<span class="fc" id="L280">        tsBp = new TestSubscriber&lt;Object&gt;(0L);</span>
<span class="fc" id="L281">    }</span>

    @Test
    public void testSimple() {
<span class="fc" id="L285">        Flowable.range(1, 100).concatMapEager(toJust).subscribe(ts);</span>

<span class="fc" id="L287">        ts.assertNoErrors();</span>
<span class="fc" id="L288">        ts.assertValueCount(100);</span>
<span class="fc" id="L289">        ts.assertComplete();</span>
<span class="fc" id="L290">    }</span>

    @Test
    public void testSimple2() {
<span class="fc" id="L294">        Flowable.range(1, 100).concatMapEager(toRange).subscribe(ts);</span>

<span class="fc" id="L296">        ts.assertNoErrors();</span>
<span class="fc" id="L297">        ts.assertValueCount(200);</span>
<span class="fc" id="L298">        ts.assertComplete();</span>
<span class="fc" id="L299">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void testEagerness2() {
<span class="fc" id="L304">        final AtomicInteger count = new AtomicInteger();</span>
<span class="fc" id="L305">        Flowable&lt;Integer&gt; source = Flowable.just(1).doOnNext(new Consumer&lt;Integer&gt;() {</span>
            @Override
            public void accept(Integer t) {
<span class="fc" id="L308">                count.getAndIncrement();</span>
<span class="fc" id="L309">            }</span>
<span class="fc" id="L310">        }).hide();</span>

<span class="fc" id="L312">        Flowable.concatArrayEager(source, source).subscribe(tsBp);</span>

<span class="fc" id="L314">        Assert.assertEquals(2, count.get());</span>
<span class="fc" id="L315">        tsBp.assertNoErrors();</span>
<span class="fc" id="L316">        tsBp.assertNotComplete();</span>
<span class="fc" id="L317">        tsBp.assertNoValues();</span>

<span class="fc" id="L319">        tsBp.request(Long.MAX_VALUE);</span>

<span class="fc" id="L321">        tsBp.assertValueCount(count.get());</span>
<span class="fc" id="L322">        tsBp.assertNoErrors();</span>
<span class="fc" id="L323">        tsBp.assertComplete();</span>
<span class="fc" id="L324">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void testEagerness3() {
<span class="fc" id="L329">        final AtomicInteger count = new AtomicInteger();</span>
<span class="fc" id="L330">        Flowable&lt;Integer&gt; source = Flowable.just(1).doOnNext(new Consumer&lt;Integer&gt;() {</span>
            @Override
            public void accept(Integer t) {
<span class="fc" id="L333">                count.getAndIncrement();</span>
<span class="fc" id="L334">            }</span>
<span class="fc" id="L335">        }).hide();</span>

<span class="fc" id="L337">        Flowable.concatArrayEager(source, source, source).subscribe(tsBp);</span>

<span class="fc" id="L339">        Assert.assertEquals(3, count.get());</span>
<span class="fc" id="L340">        tsBp.assertNoErrors();</span>
<span class="fc" id="L341">        tsBp.assertNotComplete();</span>
<span class="fc" id="L342">        tsBp.assertNoValues();</span>

<span class="fc" id="L344">        tsBp.request(Long.MAX_VALUE);</span>

<span class="fc" id="L346">        tsBp.assertValueCount(count.get());</span>
<span class="fc" id="L347">        tsBp.assertNoErrors();</span>
<span class="fc" id="L348">        tsBp.assertComplete();</span>
<span class="fc" id="L349">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void testEagerness4() {
<span class="fc" id="L354">        final AtomicInteger count = new AtomicInteger();</span>
<span class="fc" id="L355">        Flowable&lt;Integer&gt; source = Flowable.just(1).doOnNext(new Consumer&lt;Integer&gt;() {</span>
            @Override
            public void accept(Integer t) {
<span class="fc" id="L358">                count.getAndIncrement();</span>
<span class="fc" id="L359">            }</span>
<span class="fc" id="L360">        }).hide();</span>

<span class="fc" id="L362">        Flowable.concatArrayEager(source, source, source, source).subscribe(tsBp);</span>

<span class="fc" id="L364">        Assert.assertEquals(4, count.get());</span>
<span class="fc" id="L365">        tsBp.assertNoErrors();</span>
<span class="fc" id="L366">        tsBp.assertNotComplete();</span>
<span class="fc" id="L367">        tsBp.assertNoValues();</span>

<span class="fc" id="L369">        tsBp.request(Long.MAX_VALUE);</span>

<span class="fc" id="L371">        tsBp.assertValueCount(count.get());</span>
<span class="fc" id="L372">        tsBp.assertNoErrors();</span>
<span class="fc" id="L373">        tsBp.assertComplete();</span>
<span class="fc" id="L374">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void testEagerness5() {
<span class="fc" id="L379">        final AtomicInteger count = new AtomicInteger();</span>
<span class="fc" id="L380">        Flowable&lt;Integer&gt; source = Flowable.just(1).doOnNext(new Consumer&lt;Integer&gt;() {</span>
            @Override
            public void accept(Integer t) {
<span class="fc" id="L383">                count.getAndIncrement();</span>
<span class="fc" id="L384">            }</span>
<span class="fc" id="L385">        }).hide();</span>

<span class="fc" id="L387">        Flowable.concatArrayEager(source, source, source, source, source).subscribe(tsBp);</span>

<span class="fc" id="L389">        Assert.assertEquals(5, count.get());</span>
<span class="fc" id="L390">        tsBp.assertNoErrors();</span>
<span class="fc" id="L391">        tsBp.assertNotComplete();</span>
<span class="fc" id="L392">        tsBp.assertNoValues();</span>

<span class="fc" id="L394">        tsBp.request(Long.MAX_VALUE);</span>

<span class="fc" id="L396">        tsBp.assertValueCount(count.get());</span>
<span class="fc" id="L397">        tsBp.assertNoErrors();</span>
<span class="fc" id="L398">        tsBp.assertComplete();</span>
<span class="fc" id="L399">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void testEagerness6() {
<span class="fc" id="L404">        final AtomicInteger count = new AtomicInteger();</span>
<span class="fc" id="L405">        Flowable&lt;Integer&gt; source = Flowable.just(1).doOnNext(new Consumer&lt;Integer&gt;() {</span>
            @Override
            public void accept(Integer t) {
<span class="fc" id="L408">                count.getAndIncrement();</span>
<span class="fc" id="L409">            }</span>
<span class="fc" id="L410">        }).hide();</span>

<span class="fc" id="L412">        Flowable.concatArrayEager(source, source, source, source, source, source).subscribe(tsBp);</span>

<span class="fc" id="L414">        Assert.assertEquals(6, count.get());</span>
<span class="fc" id="L415">        tsBp.assertNoErrors();</span>
<span class="fc" id="L416">        tsBp.assertNotComplete();</span>
<span class="fc" id="L417">        tsBp.assertNoValues();</span>

<span class="fc" id="L419">        tsBp.request(Long.MAX_VALUE);</span>

<span class="fc" id="L421">        tsBp.assertValueCount(count.get());</span>
<span class="fc" id="L422">        tsBp.assertNoErrors();</span>
<span class="fc" id="L423">        tsBp.assertComplete();</span>
<span class="fc" id="L424">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void testEagerness7() {
<span class="fc" id="L429">        final AtomicInteger count = new AtomicInteger();</span>
<span class="fc" id="L430">        Flowable&lt;Integer&gt; source = Flowable.just(1).doOnNext(new Consumer&lt;Integer&gt;() {</span>
            @Override
            public void accept(Integer t) {
<span class="fc" id="L433">                count.getAndIncrement();</span>
<span class="fc" id="L434">            }</span>
<span class="fc" id="L435">        }).hide();</span>

<span class="fc" id="L437">        Flowable.concatArrayEager(source, source, source, source, source, source, source).subscribe(tsBp);</span>

<span class="fc" id="L439">        Assert.assertEquals(7, count.get());</span>
<span class="fc" id="L440">        tsBp.assertNoErrors();</span>
<span class="fc" id="L441">        tsBp.assertNotComplete();</span>
<span class="fc" id="L442">        tsBp.assertNoValues();</span>

<span class="fc" id="L444">        tsBp.request(Long.MAX_VALUE);</span>

<span class="fc" id="L446">        tsBp.assertValueCount(count.get());</span>
<span class="fc" id="L447">        tsBp.assertNoErrors();</span>
<span class="fc" id="L448">        tsBp.assertComplete();</span>
<span class="fc" id="L449">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void testEagerness8() {
<span class="fc" id="L454">        final AtomicInteger count = new AtomicInteger();</span>
<span class="fc" id="L455">        Flowable&lt;Integer&gt; source = Flowable.just(1).doOnNext(new Consumer&lt;Integer&gt;() {</span>
            @Override
            public void accept(Integer t) {
<span class="fc" id="L458">                count.getAndIncrement();</span>
<span class="fc" id="L459">            }</span>
<span class="fc" id="L460">        }).hide();</span>

<span class="fc" id="L462">        Flowable.concatArrayEager(source, source, source, source, source, source, source, source).subscribe(tsBp);</span>

<span class="fc" id="L464">        Assert.assertEquals(8, count.get());</span>
<span class="fc" id="L465">        tsBp.assertNoErrors();</span>
<span class="fc" id="L466">        tsBp.assertNotComplete();</span>
<span class="fc" id="L467">        tsBp.assertNoValues();</span>

<span class="fc" id="L469">        tsBp.request(Long.MAX_VALUE);</span>

<span class="fc" id="L471">        tsBp.assertValueCount(count.get());</span>
<span class="fc" id="L472">        tsBp.assertNoErrors();</span>
<span class="fc" id="L473">        tsBp.assertComplete();</span>
<span class="fc" id="L474">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void testEagerness9() {
<span class="fc" id="L479">        final AtomicInteger count = new AtomicInteger();</span>
<span class="fc" id="L480">        Flowable&lt;Integer&gt; source = Flowable.just(1).doOnNext(new Consumer&lt;Integer&gt;() {</span>
            @Override
            public void accept(Integer t) {
<span class="fc" id="L483">                count.getAndIncrement();</span>
<span class="fc" id="L484">            }</span>
<span class="fc" id="L485">        }).hide();</span>

<span class="fc" id="L487">        Flowable.concatArrayEager(source, source, source, source, source, source, source, source, source).subscribe(tsBp);</span>

<span class="fc" id="L489">        Assert.assertEquals(9, count.get());</span>
<span class="fc" id="L490">        tsBp.assertNoErrors();</span>
<span class="fc" id="L491">        tsBp.assertNotComplete();</span>
<span class="fc" id="L492">        tsBp.assertNoValues();</span>

<span class="fc" id="L494">        tsBp.request(Long.MAX_VALUE);</span>

<span class="fc" id="L496">        tsBp.assertValueCount(count.get());</span>
<span class="fc" id="L497">        tsBp.assertNoErrors();</span>
<span class="fc" id="L498">        tsBp.assertComplete();</span>
<span class="fc" id="L499">    }</span>

    @Test
    public void testMainError() {
<span class="fc" id="L503">        Flowable.&lt;Integer&gt;error(new TestException()).concatMapEager(toJust).subscribe(ts);</span>

<span class="fc" id="L505">        ts.assertNoValues();</span>
<span class="fc" id="L506">        ts.assertError(TestException.class);</span>
<span class="fc" id="L507">        ts.assertNotComplete();</span>
<span class="fc" id="L508">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void testInnerError() {
<span class="fc" id="L513">        Flowable.concatArrayEager(Flowable.just(1), Flowable.error(new TestException())).subscribe(ts);</span>

<span class="fc" id="L515">        ts.assertValue(1);</span>
<span class="fc" id="L516">        ts.assertError(TestException.class);</span>
<span class="fc" id="L517">        ts.assertNotComplete();</span>
<span class="fc" id="L518">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void testInnerEmpty() {
<span class="fc" id="L523">        Flowable.concatArrayEager(Flowable.empty(), Flowable.empty()).subscribe(ts);</span>

<span class="fc" id="L525">        ts.assertNoValues();</span>
<span class="fc" id="L526">        ts.assertNoErrors();</span>
<span class="fc" id="L527">        ts.assertComplete();</span>
<span class="fc" id="L528">    }</span>

    @Test
    public void testMapperThrows() {
<span class="fc" id="L532">        Flowable.just(1).concatMapEager(new Function&lt;Integer, Flowable&lt;Integer&gt;&gt;() {</span>
            @Override
            public Flowable&lt;Integer&gt; apply(Integer t) {
<span class="fc" id="L535">                throw new TestException();</span>
            }
<span class="fc" id="L537">        }).subscribe(ts);</span>

<span class="fc" id="L539">        ts.assertNoValues();</span>
<span class="fc" id="L540">        ts.assertNotComplete();</span>
<span class="fc" id="L541">        ts.assertError(TestException.class);</span>
<span class="fc" id="L542">    }</span>

    @Test(expected = IllegalArgumentException.class)
    public void testInvalidMaxConcurrent() {
<span class="nc" id="L546">        Flowable.just(1).concatMapEager(toJust, 0, Flowable.bufferSize());</span>
<span class="nc" id="L547">    }</span>

    @Test(expected = IllegalArgumentException.class)
    public void testInvalidCapacityHint() {
<span class="nc" id="L551">        Flowable.just(1).concatMapEager(toJust, Flowable.bufferSize(), 0);</span>
<span class="nc" id="L552">    }</span>

    @Test
    @SuppressWarnings(&quot;unchecked&quot;)
    public void testBackpressure() {
<span class="fc" id="L557">        Flowable.concatArrayEager(Flowable.just(1), Flowable.just(1)).subscribe(tsBp);</span>

<span class="fc" id="L559">        tsBp.assertNoErrors();</span>
<span class="fc" id="L560">        tsBp.assertNoValues();</span>
<span class="fc" id="L561">        tsBp.assertNotComplete();</span>

<span class="fc" id="L563">        tsBp.request(1);</span>
<span class="fc" id="L564">        tsBp.assertValue(1);</span>
<span class="fc" id="L565">        tsBp.assertNoErrors();</span>
<span class="fc" id="L566">        tsBp.assertNotComplete();</span>

<span class="fc" id="L568">        tsBp.request(1);</span>
<span class="fc" id="L569">        tsBp.assertValues(1, 1);</span>
<span class="fc" id="L570">        tsBp.assertNoErrors();</span>
<span class="fc" id="L571">        tsBp.assertComplete();</span>
<span class="fc" id="L572">    }</span>

    @Test
    public void testAsynchronousRun() {
<span class="fc" id="L576">        Flowable.range(1, 2).concatMapEager(new Function&lt;Integer, Flowable&lt;Integer&gt;&gt;() {</span>
            @Override
            public Flowable&lt;Integer&gt; apply(Integer t) {
<span class="fc" id="L579">                return Flowable.range(1, 1000).subscribeOn(Schedulers.computation());</span>
            }
<span class="fc" id="L581">        }).observeOn(Schedulers.single())</span>
<span class="fc" id="L582">        .test()</span>
<span class="fc" id="L583">        .awaitDone(5, TimeUnit.SECONDS)</span>
<span class="fc" id="L584">        .assertNoErrors()</span>
<span class="fc" id="L585">        .assertValueCount(2000)</span>
<span class="fc" id="L586">        .assertComplete();</span>
<span class="fc" id="L587">    }</span>

    @Test
    public void testReentrantWork() {
<span class="fc" id="L591">        final PublishProcessor&lt;Integer&gt; processor = PublishProcessor.create();</span>

<span class="fc" id="L593">        final AtomicBoolean once = new AtomicBoolean();</span>

<span class="fc" id="L595">        processor.concatMapEager(new Function&lt;Integer, Flowable&lt;Integer&gt;&gt;() {</span>
            @Override
            public Flowable&lt;Integer&gt; apply(Integer t) {
<span class="fc" id="L598">                return Flowable.just(t);</span>
            }
        })
<span class="fc" id="L601">        .doOnNext(new Consumer&lt;Integer&gt;() {</span>
            @Override
            public void accept(Integer t) {
<span class="fc bfc" id="L604" title="All 2 branches covered.">                if (once.compareAndSet(false, true)) {</span>
<span class="fc" id="L605">                    processor.onNext(2);</span>
                }
<span class="fc" id="L607">            }</span>
        })
<span class="fc" id="L609">        .subscribe(ts);</span>

<span class="fc" id="L611">        processor.onNext(1);</span>

<span class="fc" id="L613">        ts.assertNoErrors();</span>
<span class="fc" id="L614">        ts.assertNotComplete();</span>
<span class="fc" id="L615">        ts.assertValues(1, 2);</span>
<span class="fc" id="L616">    }</span>

    @Test
    public void testPrefetchIsBounded() {
<span class="fc" id="L620">        final AtomicInteger count = new AtomicInteger();</span>

<span class="fc" id="L622">        TestSubscriber&lt;Object&gt; ts = TestSubscriber.create(0);</span>

<span class="fc" id="L624">        Flowable.just(1).concatMapEager(new Function&lt;Integer, Flowable&lt;Integer&gt;&gt;() {</span>
            @Override
            public Flowable&lt;Integer&gt; apply(Integer t) {
<span class="fc" id="L627">                return Flowable.range(1, Flowable.bufferSize() * 2)</span>
<span class="fc" id="L628">                        .doOnNext(new Consumer&lt;Integer&gt;() {</span>
                            @Override
                            public void accept(Integer t) {
<span class="fc" id="L631">                                count.getAndIncrement();</span>
<span class="fc" id="L632">                            }</span>
<span class="fc" id="L633">                        }).hide();</span>
            }
<span class="fc" id="L635">        }).subscribe(ts);</span>

<span class="fc" id="L637">        ts.assertNoErrors();</span>
<span class="fc" id="L638">        ts.assertNoValues();</span>
<span class="fc" id="L639">        ts.assertNotComplete();</span>
<span class="fc" id="L640">        Assert.assertEquals(Flowable.bufferSize(), count.get());</span>
<span class="fc" id="L641">    }</span>

    @Test
    @Ignore(&quot;Null values are not allowed in RS&quot;)
    public void testInnerNull() {
<span class="nc" id="L646">        Flowable.just(1).concatMapEager(new Function&lt;Integer, Flowable&lt;Integer&gt;&gt;() {</span>
            @Override
            public Flowable&lt;Integer&gt; apply(Integer t) {
<span class="nc" id="L649">                return Flowable.just(null);</span>
            }
<span class="nc" id="L651">        }).subscribe(ts);</span>

<span class="nc" id="L653">        ts.assertNoErrors();</span>
<span class="nc" id="L654">        ts.assertComplete();</span>
<span class="nc" id="L655">        ts.assertValue(null);</span>
<span class="nc" id="L656">    }</span>

    @Test
    public void testMaxConcurrent5() {
<span class="fc" id="L660">        final List&lt;Long&gt; requests = new ArrayList&lt;Long&gt;();</span>
<span class="fc" id="L661">        Flowable.range(1, 100).doOnRequest(new LongConsumer() {</span>
            @Override
            public void accept(long reqCount) {
<span class="fc" id="L664">                requests.add(reqCount);</span>
<span class="fc" id="L665">            }</span>
<span class="fc" id="L666">        }).concatMapEager(toJust, 5, Flowable.bufferSize()).subscribe(ts);</span>

<span class="fc" id="L668">        ts.assertNoErrors();</span>
<span class="fc" id="L669">        ts.assertValueCount(100);</span>
<span class="fc" id="L670">        ts.assertComplete();</span>

<span class="fc" id="L672">        Assert.assertEquals(5, (long) requests.get(0));</span>
<span class="fc" id="L673">        Assert.assertEquals(1, (long) requests.get(1));</span>
<span class="fc" id="L674">        Assert.assertEquals(1, (long) requests.get(2));</span>
<span class="fc" id="L675">        Assert.assertEquals(1, (long) requests.get(3));</span>
<span class="fc" id="L676">        Assert.assertEquals(1, (long) requests.get(4));</span>
<span class="fc" id="L677">        Assert.assertEquals(1, (long) requests.get(5));</span>
<span class="fc" id="L678">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    @Ignore(&quot;Currently there are no 2-9 argument variants, use concatArrayEager()&quot;)
    public void many() throws Exception {
<span class="nc bnc" id="L684" title="All 2 branches missed.">        for (int i = 2; i &lt; 10; i++) {</span>
<span class="nc" id="L685">            Class&lt;?&gt;[] clazz = new Class[i];</span>
<span class="nc" id="L686">            Arrays.fill(clazz, Flowable.class);</span>

<span class="nc" id="L688">            Flowable&lt;Integer&gt;[] obs = new Flowable[i];</span>
<span class="nc" id="L689">            Arrays.fill(obs, Flowable.just(1));</span>

<span class="nc" id="L691">            Integer[] expected = new Integer[i];</span>
<span class="nc" id="L692">            Arrays.fill(expected, 1);</span>

<span class="nc" id="L694">            Method m = Flowable.class.getMethod(&quot;concatEager&quot;, clazz);</span>

<span class="nc" id="L696">            TestSubscriber&lt;Integer&gt; ts = TestSubscriber.create();</span>

<span class="nc" id="L698">            ((Flowable&lt;Integer&gt;)m.invoke(null, (Object[])obs)).subscribe(ts);</span>

<span class="nc" id="L700">            ts.assertValues(expected);</span>
<span class="nc" id="L701">            ts.assertNoErrors();</span>
<span class="nc" id="L702">            ts.assertComplete();</span>
        }
<span class="nc" id="L704">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void capacityHint() {
<span class="fc" id="L709">        Flowable&lt;Integer&gt; source = Flowable.just(1);</span>
<span class="fc" id="L710">        TestSubscriber&lt;Integer&gt; ts = TestSubscriber.create();</span>

<span class="fc" id="L712">        Flowable.concatEager(Arrays.asList(source, source, source), 1, 1).subscribe(ts);</span>

<span class="fc" id="L714">        ts.assertValues(1, 1, 1);</span>
<span class="fc" id="L715">        ts.assertNoErrors();</span>
<span class="fc" id="L716">        ts.assertComplete();</span>
<span class="fc" id="L717">    }</span>

    @Test
    public void flowable() {
<span class="fc" id="L721">        Flowable&lt;Integer&gt; source = Flowable.just(1);</span>
<span class="fc" id="L722">        TestSubscriber&lt;Integer&gt; ts = TestSubscriber.create();</span>

<span class="fc" id="L724">        Flowable.concatEager(Flowable.just(source, source, source)).subscribe(ts);</span>

<span class="fc" id="L726">        ts.assertValues(1, 1, 1);</span>
<span class="fc" id="L727">        ts.assertNoErrors();</span>
<span class="fc" id="L728">        ts.assertComplete();</span>
<span class="fc" id="L729">    }</span>

    @Test
    public void flowableCapacityHint() {
<span class="fc" id="L733">        Flowable&lt;Integer&gt; source = Flowable.just(1);</span>
<span class="fc" id="L734">        TestSubscriber&lt;Integer&gt; ts = TestSubscriber.create();</span>

<span class="fc" id="L736">        Flowable.concatEager(Flowable.just(source, source, source), 1, 1).subscribe(ts);</span>

<span class="fc" id="L738">        ts.assertValues(1, 1, 1);</span>
<span class="fc" id="L739">        ts.assertNoErrors();</span>
<span class="fc" id="L740">        ts.assertComplete();</span>
<span class="fc" id="L741">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void badCapacityHint() throws Exception {
<span class="fc" id="L746">        Flowable&lt;Integer&gt; source = Flowable.just(1);</span>
        try {
<span class="nc" id="L748">            Flowable.concatEager(Arrays.asList(source, source, source), 1, -99);</span>
<span class="fc" id="L749">        } catch (IllegalArgumentException ex) {</span>
<span class="fc" id="L750">            assertEquals(&quot;prefetch &gt; 0 required but it was -99&quot;, ex.getMessage());</span>
<span class="nc" id="L751">        }</span>

<span class="fc" id="L753">    }</span>

    @SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
    @Test
    public void mappingBadCapacityHint() throws Exception {
<span class="fc" id="L758">        Flowable&lt;Integer&gt; source = Flowable.just(1);</span>
        try {
<span class="nc" id="L760">            Flowable.just(source, source, source).concatMapEager((Function)Functions.identity(), 10, -99);</span>
<span class="fc" id="L761">        } catch (IllegalArgumentException ex) {</span>
<span class="fc" id="L762">            assertEquals(&quot;prefetch &gt; 0 required but it was -99&quot;, ex.getMessage());</span>
<span class="nc" id="L763">        }</span>

<span class="fc" id="L765">    }</span>

    @Test
    public void concatEagerZero() {
<span class="fc" id="L769">        Flowable.concatEager(Collections.&lt;Flowable&lt;Integer&gt;&gt;emptyList())</span>
<span class="fc" id="L770">        .test()</span>
<span class="fc" id="L771">        .assertResult();</span>
<span class="fc" id="L772">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void concatEagerOne() {
<span class="fc" id="L777">        Flowable.concatEager(Arrays.asList(Flowable.just(1)))</span>
<span class="fc" id="L778">        .test()</span>
<span class="fc" id="L779">        .assertResult(1);</span>
<span class="fc" id="L780">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void concatEagerTwo() {
<span class="fc" id="L785">        Flowable.concatEager(Arrays.asList(Flowable.just(1), Flowable.just(2)))</span>
<span class="fc" id="L786">        .test()</span>
<span class="fc" id="L787">        .assertResult(1, 2);</span>
<span class="fc" id="L788">    }</span>

    @Test
    public void Flowable() {
<span class="fc" id="L792">        Flowable&lt;Integer&gt; source = Flowable.just(1);</span>
<span class="fc" id="L793">        TestSubscriber&lt;Integer&gt; ts = TestSubscriber.create();</span>

<span class="fc" id="L795">        Flowable.concatEager(Flowable.just(source, source, source)).subscribe(ts);</span>

<span class="fc" id="L797">        ts.assertValues(1, 1, 1);</span>
<span class="fc" id="L798">        ts.assertNoErrors();</span>
<span class="fc" id="L799">        ts.assertComplete();</span>
<span class="fc" id="L800">    }</span>

    @Test
    public void ObservableCapacityHint() {
<span class="fc" id="L804">        Flowable&lt;Integer&gt; source = Flowable.just(1);</span>
<span class="fc" id="L805">        TestSubscriber&lt;Integer&gt; ts = TestSubscriber.create();</span>

<span class="fc" id="L807">        Flowable.concatEager(Flowable.just(source, source, source), 1, 1).subscribe(ts);</span>

<span class="fc" id="L809">        ts.assertValues(1, 1, 1);</span>
<span class="fc" id="L810">        ts.assertNoErrors();</span>
<span class="fc" id="L811">        ts.assertComplete();</span>
<span class="fc" id="L812">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void concatEagerIterable() {
<span class="fc" id="L817">        Flowable.concatEager(Arrays.asList(Flowable.just(1), Flowable.just(2)))</span>
<span class="fc" id="L818">        .test()</span>
<span class="fc" id="L819">        .assertResult(1, 2);</span>
<span class="fc" id="L820">    }</span>

    @Test
    public void empty() {
<span class="fc" id="L824">        Flowable.&lt;Integer&gt;empty().hide().concatMapEager(new Function&lt;Integer, Flowable&lt;Integer&gt;&gt;() {</span>
            @Override
            public Flowable&lt;Integer&gt; apply(Integer v) throws Exception {
<span class="nc" id="L827">                return Flowable.range(1, 2);</span>
            }
        })
<span class="fc" id="L830">        .test()</span>
<span class="fc" id="L831">        .assertResult();</span>
<span class="fc" id="L832">    }</span>

    @Test
    public void dispose() {
<span class="fc" id="L836">        TestHelper.checkDisposed(Flowable.just(1).hide().concatMapEager(new Function&lt;Integer, Flowable&lt;Integer&gt;&gt;() {</span>
            @Override
            public Flowable&lt;Integer&gt; apply(Integer v) throws Exception {
<span class="nc" id="L839">                return Flowable.range(1, 2);</span>
            }
        }));
<span class="fc" id="L842">    }</span>

    @Test
    public void innerError() {
<span class="fc" id="L846">        Flowable.&lt;Integer&gt;just(1).hide().concatMapEager(new Function&lt;Integer, Flowable&lt;Integer&gt;&gt;() {</span>
            @Override
            public Flowable&lt;Integer&gt; apply(Integer v) throws Exception {
<span class="fc" id="L849">                return Flowable.error(new TestException());</span>
            }
        })
<span class="fc" id="L852">        .test()</span>
<span class="fc" id="L853">        .assertFailure(TestException.class);</span>
<span class="fc" id="L854">    }</span>

    @Test
    public void innerOuterRace() {
<span class="fc bfc" id="L858" title="All 2 branches covered.">        for (int i = 0; i &lt; TestHelper.RACE_DEFAULT_LOOPS; i++) {</span>
<span class="fc" id="L859">            List&lt;Throwable&gt; errors = TestHelper.trackPluginErrors();</span>
            try {
<span class="fc" id="L861">                final PublishProcessor&lt;Integer&gt; pp1 = PublishProcessor.create();</span>
<span class="fc" id="L862">                final PublishProcessor&lt;Integer&gt; pp2 = PublishProcessor.create();</span>

<span class="fc" id="L864">                TestSubscriber&lt;Integer&gt; ts = pp1.concatMapEager(new Function&lt;Integer, Flowable&lt;Integer&gt;&gt;() {</span>
                    @Override
                    public Flowable&lt;Integer&gt; apply(Integer v) throws Exception {
<span class="fc" id="L867">                        return pp2;</span>
                    }
<span class="fc" id="L869">                }).test();</span>

<span class="fc" id="L871">                final TestException ex1 = new TestException();</span>
<span class="fc" id="L872">                final TestException ex2 = new TestException();</span>

<span class="fc" id="L874">                pp1.onNext(1);</span>

<span class="fc" id="L876">                Runnable r1 = new Runnable() {</span>
                    @Override
                    public void run() {
<span class="fc" id="L879">                        pp1.onError(ex1);</span>
<span class="fc" id="L880">                    }</span>
                };
<span class="fc" id="L882">                Runnable r2 = new Runnable() {</span>
                    @Override
                    public void run() {
<span class="fc" id="L885">                        pp2.onError(ex2);</span>
<span class="fc" id="L886">                    }</span>
                };

<span class="fc" id="L889">                TestHelper.race(r1, r2);</span>

<span class="fc" id="L891">                ts.assertSubscribed().assertNoValues().assertNotComplete();</span>

<span class="fc" id="L893">                Throwable ex = ts.errors().get(0);</span>

<span class="fc bfc" id="L895" title="All 2 branches covered.">                if (ex instanceof CompositeException) {</span>
<span class="fc" id="L896">                    List&lt;Throwable&gt; es = TestHelper.errorList(ts);</span>
<span class="fc" id="L897">                    TestHelper.assertError(es, 0, TestException.class);</span>
<span class="fc" id="L898">                    TestHelper.assertError(es, 1, TestException.class);</span>
<span class="fc" id="L899">                } else {</span>
<span class="fc" id="L900">                    ts.assertError(TestException.class);</span>
<span class="fc bfc" id="L901" title="All 2 branches covered.">                    if (!errors.isEmpty()) {</span>
<span class="fc" id="L902">                        TestHelper.assertUndeliverable(errors, 0, TestException.class);</span>
                    }
                }
            } finally {
<span class="fc" id="L906">                RxJavaPlugins.reset();</span>
            }
        }
<span class="fc" id="L909">    }</span>

    @Test
    public void innerErrorMaxConcurrency() {
<span class="fc" id="L913">        Flowable.&lt;Integer&gt;just(1).hide().concatMapEager(new Function&lt;Integer, Flowable&lt;Integer&gt;&gt;() {</span>
            @Override
            public Flowable&lt;Integer&gt; apply(Integer v) throws Exception {
<span class="fc" id="L916">                return Flowable.error(new TestException());</span>
            }
        }, 1, 128)
<span class="fc" id="L919">        .test()</span>
<span class="fc" id="L920">        .assertFailure(TestException.class);</span>
<span class="fc" id="L921">    }</span>

    @Test
    public void innerCallableThrows() {
<span class="fc" id="L925">        Flowable.&lt;Integer&gt;just(1).hide().concatMapEager(new Function&lt;Integer, Flowable&lt;Integer&gt;&gt;() {</span>
            @Override
            public Flowable&lt;Integer&gt; apply(Integer v) throws Exception {
<span class="fc" id="L928">                return Flowable.fromCallable(new Callable&lt;Integer&gt;() {</span>
                    @Override
                    public Integer call() throws Exception {
<span class="fc" id="L931">                        throw new TestException();</span>
                    }
                });
            }
        })
<span class="fc" id="L936">        .test()</span>
<span class="fc" id="L937">        .assertFailure(TestException.class);</span>
<span class="fc" id="L938">    }</span>

    @Test
    public void innerErrorAfterPoll() {
<span class="fc" id="L942">        final UnicastProcessor&lt;Integer&gt; us = UnicastProcessor.create();</span>
<span class="fc" id="L943">        us.onNext(1);</span>

<span class="fc" id="L945">        TestSubscriber&lt;Integer&gt; ts = new TestSubscriber&lt;Integer&gt;() {</span>
            @Override
            public void onNext(Integer t) {
<span class="fc" id="L948">                super.onNext(t);</span>
<span class="fc" id="L949">                us.onError(new TestException());</span>
<span class="fc" id="L950">            }</span>
        };

<span class="fc" id="L953">        Flowable.&lt;Integer&gt;just(1).hide()</span>
<span class="fc" id="L954">        .concatMapEager(new Function&lt;Integer, Flowable&lt;Integer&gt;&gt;() {</span>
            @Override
            public Flowable&lt;Integer&gt; apply(Integer v) throws Exception {
<span class="fc" id="L957">                return us;</span>
            }
        }, 1, 128)
<span class="fc" id="L960">        .subscribe(ts);</span>

<span class="fc" id="L962">        ts</span>
<span class="fc" id="L963">        .assertFailure(TestException.class, 1);</span>
<span class="fc" id="L964">    }</span>

    @Test
    public void nextCancelRace() {
<span class="fc bfc" id="L968" title="All 2 branches covered.">        for (int i = 0; i &lt; TestHelper.RACE_DEFAULT_LOOPS; i++) {</span>
<span class="fc" id="L969">            final PublishProcessor&lt;Integer&gt; pp1 = PublishProcessor.create();</span>

<span class="fc" id="L971">            final TestSubscriber&lt;Integer&gt; ts = pp1.concatMapEager(new Function&lt;Integer, Flowable&lt;Integer&gt;&gt;() {</span>
                @Override
                public Flowable&lt;Integer&gt; apply(Integer v) throws Exception {
<span class="fc" id="L974">                    return Flowable.never();</span>
                }
<span class="fc" id="L976">            }).test();</span>

<span class="fc" id="L978">            Runnable r1 = new Runnable() {</span>
                @Override
                public void run() {
<span class="fc" id="L981">                    pp1.onNext(1);</span>
<span class="fc" id="L982">                }</span>
            };
<span class="fc" id="L984">            Runnable r2 = new Runnable() {</span>
                @Override
                public void run() {
<span class="fc" id="L987">                    ts.cancel();</span>
<span class="fc" id="L988">                }</span>
            };

<span class="fc" id="L991">            TestHelper.race(r1, r2);</span>

<span class="fc" id="L993">            ts.assertEmpty();</span>
        }
<span class="fc" id="L995">    }</span>

    @Test
    public void mapperCancels() {
<span class="fc" id="L999">        final TestSubscriber&lt;Integer&gt; ts = new TestSubscriber&lt;Integer&gt;();</span>

<span class="fc" id="L1001">        Flowable.just(1).hide()</span>
<span class="fc" id="L1002">        .concatMapEager(new Function&lt;Integer, Flowable&lt;Integer&gt;&gt;() {</span>
            @Override
            public Flowable&lt;Integer&gt; apply(Integer v) throws Exception {
<span class="fc" id="L1005">                ts.cancel();</span>
<span class="fc" id="L1006">                return Flowable.never();</span>
            }
        }, 1, 128)
<span class="fc" id="L1009">        .subscribe(ts);</span>

<span class="fc" id="L1011">        ts.assertEmpty();</span>
<span class="fc" id="L1012">    }</span>

    @Test
    public void innerErrorFused() {
<span class="fc" id="L1016">        Flowable.&lt;Integer&gt;just(1).hide().concatMapEager(new Function&lt;Integer, Flowable&lt;Integer&gt;&gt;() {</span>
            @Override
            public Flowable&lt;Integer&gt; apply(Integer v) throws Exception {
<span class="fc" id="L1019">                return Flowable.range(1, 2).map(new Function&lt;Integer, Integer&gt;() {</span>
                    @Override
                    public Integer apply(Integer v) throws Exception {
<span class="fc" id="L1022">                        throw new TestException();</span>
                    }
                });
            }
        })
<span class="fc" id="L1027">        .test()</span>
<span class="fc" id="L1028">        .assertFailure(TestException.class);</span>
<span class="fc" id="L1029">    }</span>

    @Test
    public void fuseAndTake() {
<span class="fc" id="L1033">        UnicastProcessor&lt;Integer&gt; us = UnicastProcessor.create();</span>

<span class="fc" id="L1035">        us.onNext(1);</span>
<span class="fc" id="L1036">        us.onComplete();</span>

<span class="fc" id="L1038">        us.concatMapEager(new Function&lt;Integer, Flowable&lt;Integer&gt;&gt;() {</span>
            @Override
            public Flowable&lt;Integer&gt; apply(Integer v) throws Exception {
<span class="fc" id="L1041">                return Flowable.just(1);</span>
            }
        })
<span class="fc" id="L1044">        .take(1)</span>
<span class="fc" id="L1045">        .test()</span>
<span class="fc" id="L1046">        .assertResult(1);</span>
<span class="fc" id="L1047">    }</span>

    @Test
    public void doubleOnSubscribe() {
<span class="fc" id="L1051">        TestHelper.checkDoubleOnSubscribeFlowable(new Function&lt;Flowable&lt;Object&gt;, Flowable&lt;Object&gt;&gt;() {</span>
            @Override
            public Flowable&lt;Object&gt; apply(Flowable&lt;Object&gt; f) throws Exception {
<span class="fc" id="L1054">                return f.concatMapEager(new Function&lt;Object, Flowable&lt;Object&gt;&gt;() {</span>
                    @Override
                    public Flowable&lt;Object&gt; apply(Object v) throws Exception {
<span class="nc" id="L1057">                        return Flowable.just(v);</span>
                    }
                });
            }
        });
<span class="fc" id="L1062">    }</span>

    @Test
    public void doubleOnError() {
<span class="fc" id="L1066">        List&lt;Throwable&gt; errors = TestHelper.trackPluginErrors();</span>
        try {
            @SuppressWarnings(&quot;rawtypes&quot;)
<span class="fc" id="L1069">            final Subscriber[] sub = { null };</span>

<span class="fc" id="L1071">            new Flowable&lt;Integer&gt;() {</span>
                @Override
                protected void subscribeActual(Subscriber&lt;? super Integer&gt; s) {
<span class="fc" id="L1074">                    sub[0] = s;</span>
<span class="fc" id="L1075">                    s.onSubscribe(new BooleanSubscription());</span>
<span class="fc" id="L1076">                    s.onNext(1);</span>
<span class="fc" id="L1077">                    s.onError(new TestException(&quot;First&quot;));</span>
<span class="fc" id="L1078">                }</span>
            }
<span class="fc" id="L1080">            .concatMapEager(Functions.justFunction(Flowable.just(1)))</span>
<span class="fc" id="L1081">            .test()</span>
<span class="fc" id="L1082">            .assertFailureAndMessage(TestException.class, &quot;First&quot;, 1);</span>

<span class="fc" id="L1084">            sub[0].onError(new TestException(&quot;Second&quot;));</span>

<span class="fc" id="L1086">            TestHelper.assertUndeliverable(errors, 0, TestException.class, &quot;Second&quot;);</span>
        } finally {
<span class="fc" id="L1088">            RxJavaPlugins.reset();</span>
        }
<span class="fc" id="L1090">    }</span>

    @Test
    public void innerOverflow() {
<span class="fc" id="L1094">        List&lt;Throwable&gt; errors = TestHelper.trackPluginErrors();</span>
        try {
<span class="fc" id="L1096">            Flowable.just(1)</span>
<span class="fc" id="L1097">            .concatMapEager(new Function&lt;Integer, Publisher&lt;Integer&gt;&gt;() {</span>
                @Override
                public Publisher&lt;Integer&gt; apply(Integer v) throws Exception {
<span class="fc" id="L1100">                    return new Flowable&lt;Integer&gt;() {</span>
                        @Override
                        protected void subscribeActual(Subscriber&lt;? super Integer&gt; s) {
<span class="fc" id="L1103">                            s.onSubscribe(new BooleanSubscription());</span>
<span class="fc" id="L1104">                            s.onNext(1);</span>
<span class="fc" id="L1105">                            s.onNext(2);</span>
<span class="fc" id="L1106">                            s.onError(new TestException());</span>
<span class="fc" id="L1107">                        }</span>
                    };
                }
            }, 1, 1)
<span class="fc" id="L1111">            .test(0L)</span>
<span class="fc" id="L1112">            .assertFailure(MissingBackpressureException.class);</span>

<span class="fc" id="L1114">            TestHelper.assertUndeliverable(errors, 0, TestException.class);</span>
        } finally {
<span class="fc" id="L1116">            RxJavaPlugins.reset();</span>
        }
<span class="fc" id="L1118">    }</span>

    @Test
    public void unboundedIn() {
<span class="fc" id="L1122">        int n = Flowable.bufferSize() * 2;</span>
<span class="fc" id="L1123">        Flowable.range(1, n)</span>
<span class="fc" id="L1124">        .concatMapEager(new Function&lt;Integer, Publisher&lt;Integer&gt;&gt;() {</span>
            @Override
            public Publisher&lt;Integer&gt; apply(Integer v) throws Exception {
<span class="fc" id="L1127">                return Flowable.just(1);</span>
            }
        }, Integer.MAX_VALUE, 16)
<span class="fc" id="L1130">        .test()</span>
<span class="fc" id="L1131">        .assertValueCount(n)</span>
<span class="fc" id="L1132">        .assertComplete()</span>
<span class="fc" id="L1133">        .assertNoErrors();</span>
<span class="fc" id="L1134">    }</span>

    @Test
    public void drainCancelRaceOnEmpty() {
<span class="fc bfc" id="L1138" title="All 2 branches covered.">        for (int i = 0; i &lt; TestHelper.RACE_DEFAULT_LOOPS; i++) {</span>
<span class="fc" id="L1139">            final PublishProcessor&lt;Integer&gt; pp = PublishProcessor.create();</span>

<span class="fc" id="L1141">            final TestSubscriber&lt;Integer&gt; ts = new TestSubscriber&lt;Integer&gt;(0L);</span>

<span class="fc" id="L1143">            Flowable.just(1)</span>
<span class="fc" id="L1144">            .concatMapEager(Functions.justFunction(pp))</span>
<span class="fc" id="L1145">            .subscribe(ts);</span>

<span class="fc" id="L1147">            Runnable r1 = new Runnable() {</span>
                @Override
                public void run() {
<span class="fc" id="L1150">                    pp.onComplete();</span>
<span class="fc" id="L1151">                }</span>
            };

<span class="fc" id="L1154">            Runnable r2 = new Runnable() {</span>
                @Override
                public void run() {
<span class="fc" id="L1157">                    ts.cancel();</span>
<span class="fc" id="L1158">                }</span>
            };

<span class="fc" id="L1161">            TestHelper.race(r1, r2);</span>
        }
<span class="fc" id="L1163">    }</span>

    @Test
    public void innerLong() {
<span class="fc" id="L1167">        int n = Flowable.bufferSize() * 2;</span>

<span class="fc" id="L1169">        Flowable.just(1).hide()</span>
<span class="fc" id="L1170">        .concatMapEager(Functions.justFunction(Flowable.range(1, n).hide()))</span>
<span class="fc" id="L1171">        .rebatchRequests(1)</span>
<span class="fc" id="L1172">        .test()</span>
<span class="fc" id="L1173">        .assertValueCount(n)</span>
<span class="fc" id="L1174">        .assertComplete()</span>
<span class="fc" id="L1175">        .assertNoErrors();</span>
<span class="fc" id="L1176">    }</span>

    @Test
    public void oneDelayed() {
<span class="fc" id="L1180">        Flowable.just(1, 2, 3, 4, 5)</span>
<span class="fc" id="L1181">        .concatMapEager(new Function&lt;Integer, Flowable&lt;Integer&gt;&gt;() {</span>
            @Override
            public Flowable&lt;Integer&gt; apply(Integer i) throws Exception {
<span class="fc bfc" id="L1184" title="All 2 branches covered.">                return i == 3 ? Flowable.just(i) : Flowable</span>
<span class="fc" id="L1185">                        .just(i)</span>
<span class="fc" id="L1186">                        .delay(1, TimeUnit.MILLISECONDS, Schedulers.io());</span>
            }
        })
<span class="fc" id="L1189">        .observeOn(Schedulers.io())</span>
<span class="fc" id="L1190">        .test()</span>
<span class="fc" id="L1191">        .awaitDone(5, TimeUnit.SECONDS)</span>
<span class="fc" id="L1192">        .assertResult(1, 2, 3, 4, 5)</span>
        ;
<span class="fc" id="L1194">    }</span>

    @Test
    @SuppressWarnings(&quot;unchecked&quot;)
    public void maxConcurrencyOf2() {
<span class="fc" id="L1199">        List&lt;Integer&gt;[] list = new ArrayList[100];</span>
<span class="fc bfc" id="L1200" title="All 2 branches covered.">        for (int i = 0; i &lt; 100; i++) {</span>
<span class="fc" id="L1201">            List&lt;Integer&gt; lst = new ArrayList&lt;Integer&gt;();</span>
<span class="fc" id="L1202">            list[i] = lst;</span>
<span class="fc bfc" id="L1203" title="All 2 branches covered.">            for (int k = 1; k &lt;= 10; k++) {</span>
<span class="fc" id="L1204">                lst.add((i) * 10 + k);</span>
            }
        }

<span class="fc" id="L1208">        Flowable.range(1, 1000)</span>
<span class="fc" id="L1209">        .buffer(10)</span>
<span class="fc" id="L1210">        .concatMapEager(new Function&lt;List&lt;Integer&gt;, Flowable&lt;List&lt;Integer&gt;&gt;&gt;() {</span>
            @Override
            public Flowable&lt;List&lt;Integer&gt;&gt; apply(List&lt;Integer&gt; v)
                    throws Exception {
<span class="fc" id="L1214">                return Flowable.just(v)</span>
<span class="fc" id="L1215">                        .subscribeOn(Schedulers.io())</span>
<span class="fc" id="L1216">                        .doOnNext(new Consumer&lt;List&lt;Integer&gt;&gt;() {</span>
                            @Override
                            public void accept(List&lt;Integer&gt; v)
                                    throws Exception {
<span class="fc" id="L1220">                                Thread.sleep(new Random().nextInt(20));</span>
<span class="fc" id="L1221">                            }</span>
                        });
            }
        }
                , 2, 3)
<span class="fc" id="L1226">        .test()</span>
<span class="fc" id="L1227">        .awaitDone(5, TimeUnit.SECONDS)</span>
<span class="fc" id="L1228">        .assertResult(list);</span>
<span class="fc" id="L1229">    }</span>

    @Test
    public void arrayDelayErrorDefault() {
<span class="fc" id="L1233">        PublishProcessor&lt;Integer&gt; pp1 = PublishProcessor.create();</span>
<span class="fc" id="L1234">        PublishProcessor&lt;Integer&gt; pp2 = PublishProcessor.create();</span>
<span class="fc" id="L1235">        PublishProcessor&lt;Integer&gt; pp3 = PublishProcessor.create();</span>

        @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L1238">        TestSubscriber&lt;Integer&gt; ts = Flowable.concatArrayEagerDelayError(pp1, pp2, pp3)</span>
<span class="fc" id="L1239">        .test();</span>

<span class="fc" id="L1241">        ts.assertEmpty();</span>

<span class="fc" id="L1243">        assertTrue(pp1.hasSubscribers());</span>
<span class="fc" id="L1244">        assertTrue(pp2.hasSubscribers());</span>
<span class="fc" id="L1245">        assertTrue(pp3.hasSubscribers());</span>

<span class="fc" id="L1247">        pp2.onNext(2);</span>
<span class="fc" id="L1248">        pp2.onComplete();</span>

<span class="fc" id="L1250">        ts.assertEmpty();</span>

<span class="fc" id="L1252">        pp1.onNext(1);</span>

<span class="fc" id="L1254">        ts.assertValuesOnly(1);</span>

<span class="fc" id="L1256">        pp1.onComplete();</span>

<span class="fc" id="L1258">        ts.assertValuesOnly(1, 2);</span>

<span class="fc" id="L1260">        pp3.onComplete();</span>

<span class="fc" id="L1262">        ts.assertResult(1, 2);</span>
<span class="fc" id="L1263">    }</span>

    @Test
    public void arrayDelayErrorMaxConcurrency() {
<span class="fc" id="L1267">        PublishProcessor&lt;Integer&gt; pp1 = PublishProcessor.create();</span>
<span class="fc" id="L1268">        PublishProcessor&lt;Integer&gt; pp2 = PublishProcessor.create();</span>
<span class="fc" id="L1269">        PublishProcessor&lt;Integer&gt; pp3 = PublishProcessor.create();</span>

        @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L1272">        TestSubscriber&lt;Integer&gt; ts = Flowable.concatArrayEagerDelayError(2, 2, pp1, pp2, pp3)</span>
<span class="fc" id="L1273">        .test();</span>

<span class="fc" id="L1275">        ts.assertEmpty();</span>

<span class="fc" id="L1277">        assertTrue(pp1.hasSubscribers());</span>
<span class="fc" id="L1278">        assertTrue(pp2.hasSubscribers());</span>
<span class="fc" id="L1279">        assertFalse(pp3.hasSubscribers());</span>

<span class="fc" id="L1281">        pp2.onNext(2);</span>
<span class="fc" id="L1282">        pp2.onComplete();</span>

<span class="fc" id="L1284">        ts.assertEmpty();</span>

<span class="fc" id="L1286">        pp1.onNext(1);</span>

<span class="fc" id="L1288">        ts.assertValuesOnly(1);</span>

<span class="fc" id="L1290">        pp1.onComplete();</span>

<span class="fc" id="L1292">        assertTrue(pp3.hasSubscribers());</span>

<span class="fc" id="L1294">        ts.assertValuesOnly(1, 2);</span>

<span class="fc" id="L1296">        pp3.onComplete();</span>

<span class="fc" id="L1298">        ts.assertResult(1, 2);</span>
<span class="fc" id="L1299">    }</span>

    @Test
    public void arrayDelayErrorMaxConcurrencyErrorDelayed() {
<span class="fc" id="L1303">        PublishProcessor&lt;Integer&gt; pp1 = PublishProcessor.create();</span>
<span class="fc" id="L1304">        PublishProcessor&lt;Integer&gt; pp2 = PublishProcessor.create();</span>
<span class="fc" id="L1305">        PublishProcessor&lt;Integer&gt; pp3 = PublishProcessor.create();</span>

        @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L1308">        TestSubscriber&lt;Integer&gt; ts = Flowable.concatArrayEagerDelayError(2, 2, pp1, pp2, pp3)</span>
<span class="fc" id="L1309">        .test();</span>

<span class="fc" id="L1311">        ts.assertEmpty();</span>

<span class="fc" id="L1313">        assertTrue(pp1.hasSubscribers());</span>
<span class="fc" id="L1314">        assertTrue(pp2.hasSubscribers());</span>
<span class="fc" id="L1315">        assertFalse(pp3.hasSubscribers());</span>

<span class="fc" id="L1317">        pp2.onNext(2);</span>
<span class="fc" id="L1318">        pp2.onError(new TestException());</span>

<span class="fc" id="L1320">        ts.assertEmpty();</span>

<span class="fc" id="L1322">        pp1.onNext(1);</span>

<span class="fc" id="L1324">        ts.assertValuesOnly(1);</span>

<span class="fc" id="L1326">        pp1.onComplete();</span>

<span class="fc" id="L1328">        assertTrue(pp3.hasSubscribers());</span>

<span class="fc" id="L1330">        ts.assertValuesOnly(1, 2);</span>

<span class="fc" id="L1332">        pp3.onComplete();</span>

<span class="fc" id="L1334">        ts.assertFailure(TestException.class, 1, 2);</span>
<span class="fc" id="L1335">    }</span>

    @Test
    public void cancelActive() {
<span class="fc" id="L1339">        PublishProcessor&lt;Integer&gt; pp1 = PublishProcessor.create();</span>
<span class="fc" id="L1340">        PublishProcessor&lt;Integer&gt; pp2 = PublishProcessor.create();</span>

<span class="fc" id="L1342">        TestSubscriber&lt;Integer&gt; ts = Flowable</span>
<span class="fc" id="L1343">                .concatEager(Flowable.just(pp1, pp2))</span>
<span class="fc" id="L1344">                .test();</span>

<span class="fc" id="L1346">        assertTrue(pp1.hasSubscribers());</span>
<span class="fc" id="L1347">        assertTrue(pp2.hasSubscribers());</span>

<span class="fc" id="L1349">        ts.cancel();</span>

<span class="fc" id="L1351">        assertFalse(pp1.hasSubscribers());</span>
<span class="fc" id="L1352">        assertFalse(pp2.hasSubscribers());</span>
<span class="fc" id="L1353">    }</span>

    @Test
    public void cancelNoInnerYet() {
<span class="fc" id="L1357">        PublishProcessor&lt;Flowable&lt;Integer&gt;&gt; pp1 = PublishProcessor.create();</span>

<span class="fc" id="L1359">        TestSubscriber&lt;Integer&gt; ts = Flowable</span>
<span class="fc" id="L1360">                .concatEager(pp1)</span>
<span class="fc" id="L1361">                .test();</span>

<span class="fc" id="L1363">        assertTrue(pp1.hasSubscribers());</span>

<span class="fc" id="L1365">        ts.cancel();</span>

<span class="fc" id="L1367">        assertFalse(pp1.hasSubscribers());</span>
<span class="fc" id="L1368">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>