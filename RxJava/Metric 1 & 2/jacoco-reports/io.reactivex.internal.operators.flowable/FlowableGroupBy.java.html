<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FlowableGroupBy.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">RxJava_2_x$Unnamed.exec</a> &gt; <a href="index.source.html" class="el_package">io.reactivex.internal.operators.flowable</a> &gt; <span class="el_source">FlowableGroupBy.java</span></div><h1>FlowableGroupBy.java</h1><pre class="source lang-java linenums">/**
 * Copyright (c) 2016-present, RxJava Contributors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is
 * distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
 * the License for the specific language governing permissions and limitations under the License.
 */

package io.reactivex.internal.operators.flowable;

import java.util.Map;
import java.util.Queue;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.atomic.*;

import org.reactivestreams.*;

import io.reactivex.*;
import io.reactivex.annotations.Nullable;
import io.reactivex.exceptions.Exceptions;
import io.reactivex.flowables.GroupedFlowable;
import io.reactivex.functions.Consumer;
import io.reactivex.functions.Function;
import io.reactivex.internal.functions.ObjectHelper;
import io.reactivex.internal.queue.SpscLinkedArrayQueue;
import io.reactivex.internal.subscriptions.*;
import io.reactivex.internal.util.BackpressureHelper;
import io.reactivex.internal.util.EmptyComponent;
import io.reactivex.plugins.RxJavaPlugins;

public final class FlowableGroupBy&lt;T, K, V&gt; extends AbstractFlowableWithUpstream&lt;T, GroupedFlowable&lt;K, V&gt;&gt; {
    final Function&lt;? super T, ? extends K&gt; keySelector;
    final Function&lt;? super T, ? extends V&gt; valueSelector;
    final int bufferSize;
    final boolean delayError;
    final Function&lt;? super Consumer&lt;Object&gt;, ? extends Map&lt;K, Object&gt;&gt; mapFactory;

    public FlowableGroupBy(Flowable&lt;T&gt; source, Function&lt;? super T, ? extends K&gt; keySelector, Function&lt;? super T, ? extends V&gt; valueSelector,
            int bufferSize, boolean delayError, Function&lt;? super Consumer&lt;Object&gt;, ? extends Map&lt;K, Object&gt;&gt; mapFactory) {
<span class="fc" id="L46">        super(source);</span>
<span class="fc" id="L47">        this.keySelector = keySelector;</span>
<span class="fc" id="L48">        this.valueSelector = valueSelector;</span>
<span class="fc" id="L49">        this.bufferSize = bufferSize;</span>
<span class="fc" id="L50">        this.delayError = delayError;</span>
<span class="fc" id="L51">        this.mapFactory = mapFactory;</span>
<span class="fc" id="L52">    }</span>

    @Override
    @SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
    protected void subscribeActual(Subscriber&lt;? super GroupedFlowable&lt;K, V&gt;&gt; s) {

        final Map&lt;Object, GroupedUnicast&lt;K, V&gt;&gt; groups;
        final Queue&lt;GroupedUnicast&lt;K, V&gt;&gt; evictedGroups;

        try {
<span class="fc bfc" id="L62" title="All 2 branches covered.">            if (mapFactory == null) {</span>
<span class="fc" id="L63">                evictedGroups = null;</span>
<span class="fc" id="L64">                groups = new ConcurrentHashMap&lt;Object, GroupedUnicast&lt;K, V&gt;&gt;();</span>
            } else {
<span class="fc" id="L66">                evictedGroups = new ConcurrentLinkedQueue&lt;GroupedUnicast&lt;K, V&gt;&gt;();</span>
<span class="fc" id="L67">                Consumer&lt;Object&gt; evictionAction = (Consumer) new EvictionAction&lt;K, V&gt;(evictedGroups);</span>
<span class="fc" id="L68">                groups = (Map) mapFactory.apply(evictionAction);</span>
            }
<span class="fc" id="L70">        } catch (Exception e) {</span>
<span class="fc" id="L71">            Exceptions.throwIfFatal(e);</span>
<span class="fc" id="L72">            s.onSubscribe(EmptyComponent.INSTANCE);</span>
<span class="fc" id="L73">            s.onError(e);</span>
<span class="fc" id="L74">            return;</span>
<span class="fc" id="L75">        }</span>
<span class="fc" id="L76">        GroupBySubscriber&lt;T, K, V&gt; subscriber =</span>
                new GroupBySubscriber&lt;T, K, V&gt;(s, keySelector, valueSelector, bufferSize, delayError, groups, evictedGroups);
<span class="fc" id="L78">        source.subscribe(subscriber);</span>
<span class="fc" id="L79">    }</span>

    public static final class GroupBySubscriber&lt;T, K, V&gt;
    extends BasicIntQueueSubscription&lt;GroupedFlowable&lt;K, V&gt;&gt;
    implements FlowableSubscriber&lt;T&gt; {

        private static final long serialVersionUID = -3688291656102519502L;

        final Subscriber&lt;? super GroupedFlowable&lt;K, V&gt;&gt; downstream;
        final Function&lt;? super T, ? extends K&gt; keySelector;
        final Function&lt;? super T, ? extends V&gt; valueSelector;
        final int bufferSize;
        final boolean delayError;
        final Map&lt;Object, GroupedUnicast&lt;K, V&gt;&gt; groups;
        final SpscLinkedArrayQueue&lt;GroupedFlowable&lt;K, V&gt;&gt; queue;
        final Queue&lt;GroupedUnicast&lt;K, V&gt;&gt; evictedGroups;

<span class="fc" id="L96">        static final Object NULL_KEY = new Object();</span>

        Subscription upstream;

<span class="fc" id="L100">        final AtomicBoolean cancelled = new AtomicBoolean();</span>

<span class="fc" id="L102">        final AtomicLong requested = new AtomicLong();</span>

<span class="fc" id="L104">        final AtomicInteger groupCount = new AtomicInteger(1);</span>

        Throwable error;
        volatile boolean finished;
        boolean done;

        boolean outputFused;

        public GroupBySubscriber(Subscriber&lt;? super GroupedFlowable&lt;K, V&gt;&gt; actual, Function&lt;? super T, ? extends K&gt; keySelector,
                Function&lt;? super T, ? extends V&gt; valueSelector, int bufferSize, boolean delayError,
<span class="fc" id="L114">                Map&lt;Object, GroupedUnicast&lt;K, V&gt;&gt; groups, Queue&lt;GroupedUnicast&lt;K, V&gt;&gt; evictedGroups) {</span>
<span class="fc" id="L115">            this.downstream = actual;</span>
<span class="fc" id="L116">            this.keySelector = keySelector;</span>
<span class="fc" id="L117">            this.valueSelector = valueSelector;</span>
<span class="fc" id="L118">            this.bufferSize = bufferSize;</span>
<span class="fc" id="L119">            this.delayError = delayError;</span>
<span class="fc" id="L120">            this.groups = groups;</span>
<span class="fc" id="L121">            this.evictedGroups = evictedGroups;</span>
<span class="fc" id="L122">            this.queue = new SpscLinkedArrayQueue&lt;GroupedFlowable&lt;K, V&gt;&gt;(bufferSize);</span>
<span class="fc" id="L123">        }</span>

        @Override
        public void onSubscribe(Subscription s) {
<span class="fc bfc" id="L127" title="All 2 branches covered.">            if (SubscriptionHelper.validate(this.upstream, s)) {</span>
<span class="fc" id="L128">                this.upstream = s;</span>
<span class="fc" id="L129">                downstream.onSubscribe(this);</span>
<span class="fc" id="L130">                s.request(bufferSize);</span>
            }
<span class="fc" id="L132">        }</span>

        @Override
        public void onNext(T t) {
<span class="fc bfc" id="L136" title="All 2 branches covered.">            if (done) {</span>
<span class="fc" id="L137">                return;</span>
            }

<span class="fc" id="L140">            final SpscLinkedArrayQueue&lt;GroupedFlowable&lt;K, V&gt;&gt; q = this.queue;</span>

            K key;
            try {
<span class="fc" id="L144">                key = keySelector.apply(t);</span>
<span class="fc" id="L145">            } catch (Throwable ex) {</span>
<span class="fc" id="L146">                Exceptions.throwIfFatal(ex);</span>
<span class="fc" id="L147">                upstream.cancel();</span>
<span class="fc" id="L148">                onError(ex);</span>
<span class="fc" id="L149">                return;</span>
<span class="fc" id="L150">            }</span>

<span class="fc" id="L152">            boolean newGroup = false;</span>
<span class="fc bfc" id="L153" title="All 2 branches covered.">            Object mapKey = key != null ? key : NULL_KEY;</span>
<span class="fc" id="L154">            GroupedUnicast&lt;K, V&gt; group = groups.get(mapKey);</span>
<span class="fc bfc" id="L155" title="All 2 branches covered.">            if (group == null) {</span>
                // if the main has been cancelled, stop creating groups
                // and skip this value
<span class="fc bfc" id="L158" title="All 2 branches covered.">                if (cancelled.get()) {</span>
<span class="fc" id="L159">                    return;</span>
                }

<span class="fc" id="L162">                group = GroupedUnicast.createWith(key, bufferSize, this, delayError);</span>
<span class="fc" id="L163">                groups.put(mapKey, group);</span>

<span class="fc" id="L165">                groupCount.getAndIncrement();</span>

<span class="fc" id="L167">                newGroup = true;</span>
            }

            V v;
            try {
<span class="fc" id="L172">                v = ObjectHelper.requireNonNull(valueSelector.apply(t), &quot;The valueSelector returned null&quot;);</span>
<span class="fc" id="L173">            } catch (Throwable ex) {</span>
<span class="fc" id="L174">                Exceptions.throwIfFatal(ex);</span>
<span class="fc" id="L175">                upstream.cancel();</span>
<span class="fc" id="L176">                onError(ex);</span>
<span class="fc" id="L177">                return;</span>
<span class="fc" id="L178">            }</span>

<span class="fc" id="L180">            group.onNext(v);</span>

<span class="fc" id="L182">            completeEvictions();</span>

<span class="fc bfc" id="L184" title="All 2 branches covered.">            if (newGroup) {</span>
<span class="fc" id="L185">                q.offer(group);</span>
<span class="fc" id="L186">                drain();</span>
            }
<span class="fc" id="L188">        }</span>

        @Override
        public void onError(Throwable t) {
<span class="fc bfc" id="L192" title="All 2 branches covered.">            if (done) {</span>
<span class="fc" id="L193">                RxJavaPlugins.onError(t);</span>
<span class="fc" id="L194">                return;</span>
            }
<span class="fc" id="L196">            done = true;</span>
<span class="fc bfc" id="L197" title="All 2 branches covered.">            for (GroupedUnicast&lt;K, V&gt; g : groups.values()) {</span>
<span class="fc" id="L198">                g.onError(t);</span>
<span class="fc" id="L199">            }</span>
<span class="fc" id="L200">            groups.clear();</span>
<span class="fc bfc" id="L201" title="All 2 branches covered.">            if (evictedGroups != null) {</span>
<span class="fc" id="L202">                evictedGroups.clear();</span>
            }
<span class="fc" id="L204">            error = t;</span>
<span class="fc" id="L205">            finished = true;</span>
<span class="fc" id="L206">            drain();</span>
<span class="fc" id="L207">        }</span>

        @Override
        public void onComplete() {
<span class="fc bfc" id="L211" title="All 2 branches covered.">            if (!done) {</span>
<span class="fc bfc" id="L212" title="All 2 branches covered.">                for (GroupedUnicast&lt;K, V&gt; g : groups.values()) {</span>
<span class="fc" id="L213">                    g.onComplete();</span>
<span class="fc" id="L214">                }</span>
<span class="fc" id="L215">                groups.clear();</span>
<span class="fc bfc" id="L216" title="All 2 branches covered.">                if (evictedGroups != null) {</span>
<span class="fc" id="L217">                    evictedGroups.clear();</span>
                }
<span class="fc" id="L219">                done = true;</span>
<span class="fc" id="L220">                finished = true;</span>
<span class="fc" id="L221">                drain();</span>
            }
<span class="fc" id="L223">        }</span>

        @Override
        public void request(long n) {
<span class="fc bfc" id="L227" title="All 2 branches covered.">            if (SubscriptionHelper.validate(n)) {</span>
<span class="fc" id="L228">                BackpressureHelper.add(requested, n);</span>
<span class="fc" id="L229">                drain();</span>
            }
<span class="fc" id="L231">        }</span>

        @Override
        public void cancel() {
            // cancelling the main source means we don't want any more groups
            // but running groups still require new values
<span class="fc bfc" id="L237" title="All 2 branches covered.">            if (cancelled.compareAndSet(false, true)) {</span>
<span class="fc" id="L238">                completeEvictions();</span>
<span class="fc bfc" id="L239" title="All 2 branches covered.">                if (groupCount.decrementAndGet() == 0) {</span>
<span class="fc" id="L240">                    upstream.cancel();</span>
                }
            }
<span class="fc" id="L243">        }</span>

        private void completeEvictions() {
<span class="fc bfc" id="L246" title="All 2 branches covered.">            if (evictedGroups != null) {</span>
<span class="fc" id="L247">                int count = 0;</span>
                GroupedUnicast&lt;K, V&gt; evictedGroup;
<span class="fc bfc" id="L249" title="All 2 branches covered.">                while ((evictedGroup = evictedGroups.poll()) != null) {</span>
<span class="fc" id="L250">                    evictedGroup.onComplete();</span>
<span class="fc" id="L251">                    count++;</span>
                }
<span class="fc bfc" id="L253" title="All 2 branches covered.">                if (count != 0) {</span>
<span class="fc" id="L254">                    groupCount.addAndGet(-count);</span>
                }
            }
<span class="fc" id="L257">        }</span>

        public void cancel(K key) {
<span class="fc bfc" id="L260" title="All 2 branches covered.">            Object mapKey = key != null ? key : NULL_KEY;</span>
<span class="fc" id="L261">            groups.remove(mapKey);</span>
<span class="fc bfc" id="L262" title="All 2 branches covered.">            if (groupCount.decrementAndGet() == 0) {</span>
<span class="fc" id="L263">                upstream.cancel();</span>

<span class="fc bfc" id="L265" title="All 2 branches covered.">                if (getAndIncrement() == 0) {</span>
<span class="fc" id="L266">                    queue.clear();</span>
                }
            }
<span class="fc" id="L269">        }</span>

        void drain() {
<span class="fc bfc" id="L272" title="All 2 branches covered.">            if (getAndIncrement() != 0) {</span>
<span class="fc" id="L273">                return;</span>
            }

<span class="fc bfc" id="L276" title="All 2 branches covered.">            if (outputFused) {</span>
<span class="fc" id="L277">                drainFused();</span>
            } else {
<span class="fc" id="L279">                drainNormal();</span>
            }
<span class="fc" id="L281">        }</span>

        void drainFused() {
<span class="fc" id="L284">            int missed = 1;</span>

<span class="fc" id="L286">            final SpscLinkedArrayQueue&lt;GroupedFlowable&lt;K, V&gt;&gt; q = this.queue;</span>
<span class="fc" id="L287">            final Subscriber&lt;? super GroupedFlowable&lt;K, V&gt;&gt; a = this.downstream;</span>

            for (;;) {
<span class="pc bpc" id="L290" title="1 of 2 branches missed.">                if (cancelled.get()) {</span>
<span class="nc" id="L291">                    q.clear();</span>
<span class="nc" id="L292">                    return;</span>
                }

<span class="fc" id="L295">                boolean d = finished;</span>

<span class="fc bfc" id="L297" title="All 4 branches covered.">                if (d &amp;&amp; !delayError) {</span>
<span class="fc" id="L298">                    Throwable ex = error;</span>
<span class="fc bfc" id="L299" title="All 2 branches covered.">                    if (ex != null) {</span>
<span class="fc" id="L300">                        q.clear();</span>
<span class="fc" id="L301">                        a.onError(ex);</span>
<span class="fc" id="L302">                        return;</span>
                    }
                }

<span class="fc" id="L306">                a.onNext(null);</span>

<span class="fc bfc" id="L308" title="All 2 branches covered.">                if (d) {</span>
<span class="fc" id="L309">                    Throwable ex = error;</span>
<span class="fc bfc" id="L310" title="All 2 branches covered.">                    if (ex != null) {</span>
<span class="fc" id="L311">                        a.onError(ex);</span>
                    } else {
<span class="fc" id="L313">                        a.onComplete();</span>
                    }
<span class="fc" id="L315">                    return;</span>
                }

<span class="fc" id="L318">                missed = addAndGet(-missed);</span>
<span class="pc bpc" id="L319" title="1 of 2 branches missed.">                if (missed == 0) {</span>
<span class="fc" id="L320">                    return;</span>
                }
<span class="nc" id="L322">            }</span>
        }

        void drainNormal() {
<span class="fc" id="L326">            int missed = 1;</span>

<span class="fc" id="L328">            final SpscLinkedArrayQueue&lt;GroupedFlowable&lt;K, V&gt;&gt; q = this.queue;</span>
<span class="fc" id="L329">            final Subscriber&lt;? super GroupedFlowable&lt;K, V&gt;&gt; a = this.downstream;</span>

            for (;;) {

<span class="fc" id="L333">                long r = requested.get();</span>
<span class="fc" id="L334">                long e = 0L;</span>

<span class="fc bfc" id="L336" title="All 2 branches covered.">                while (e != r) {</span>
<span class="fc" id="L337">                    boolean d = finished;</span>

<span class="fc" id="L339">                    GroupedFlowable&lt;K, V&gt; t = q.poll();</span>

<span class="fc bfc" id="L341" title="All 2 branches covered.">                    boolean empty = t == null;</span>

<span class="fc bfc" id="L343" title="All 2 branches covered.">                    if (checkTerminated(d, empty, a, q)) {</span>
<span class="fc" id="L344">                        return;</span>
                    }

<span class="fc bfc" id="L347" title="All 2 branches covered.">                    if (empty) {</span>
<span class="fc" id="L348">                        break;</span>
                    }

<span class="fc" id="L351">                    a.onNext(t);</span>

<span class="fc" id="L353">                    e++;</span>
<span class="fc" id="L354">                }</span>

<span class="fc bfc" id="L356" title="All 4 branches covered.">                if (e == r &amp;&amp; checkTerminated(finished, q.isEmpty(), a, q)) {</span>
<span class="fc" id="L357">                    return;</span>
                }

<span class="fc bfc" id="L360" title="All 2 branches covered.">                if (e != 0L) {</span>
<span class="fc bfc" id="L361" title="All 2 branches covered.">                    if (r != Long.MAX_VALUE) {</span>
<span class="fc" id="L362">                        requested.addAndGet(-e);</span>
                    }
<span class="fc" id="L364">                    upstream.request(e);</span>
                }

<span class="fc" id="L367">                missed = addAndGet(-missed);</span>
<span class="fc bfc" id="L368" title="All 2 branches covered.">                if (missed == 0) {</span>
<span class="fc" id="L369">                    break;</span>
                }
<span class="fc" id="L371">            }</span>
<span class="fc" id="L372">        }</span>

        boolean checkTerminated(boolean d, boolean empty, Subscriber&lt;?&gt; a, SpscLinkedArrayQueue&lt;?&gt; q) {
<span class="fc bfc" id="L375" title="All 2 branches covered.">            if (cancelled.get()) {</span>
<span class="fc" id="L376">                q.clear();</span>
<span class="fc" id="L377">                return true;</span>
            }

<span class="fc bfc" id="L380" title="All 2 branches covered.">            if (delayError) {</span>
<span class="pc bpc" id="L381" title="1 of 4 branches missed.">                if (d &amp;&amp; empty) {</span>
<span class="fc" id="L382">                    Throwable ex = error;</span>
<span class="fc bfc" id="L383" title="All 2 branches covered.">                    if (ex != null) {</span>
<span class="fc" id="L384">                        a.onError(ex);</span>
                    } else {
<span class="fc" id="L386">                        a.onComplete();</span>
                    }
<span class="fc" id="L388">                    return true;</span>
                }
            } else {
<span class="fc bfc" id="L391" title="All 2 branches covered.">                if (d) {</span>
<span class="fc" id="L392">                    Throwable ex = error;</span>
<span class="fc bfc" id="L393" title="All 2 branches covered.">                    if (ex != null) {</span>
<span class="fc" id="L394">                        q.clear();</span>
<span class="fc" id="L395">                        a.onError(ex);</span>
<span class="fc" id="L396">                        return true;</span>
<span class="fc bfc" id="L397" title="All 2 branches covered.">                    } else if (empty) {</span>
<span class="fc" id="L398">                        a.onComplete();</span>
<span class="fc" id="L399">                        return true;</span>
                    }
                }
            }

<span class="fc" id="L404">            return false;</span>
        }

        @Override
        public int requestFusion(int mode) {
<span class="fc bfc" id="L409" title="All 2 branches covered.">            if ((mode &amp; ASYNC) != 0) {</span>
<span class="fc" id="L410">                outputFused = true;</span>
<span class="fc" id="L411">                return ASYNC;</span>
            }
<span class="fc" id="L413">            return NONE;</span>
        }

        @Nullable
        @Override
        public GroupedFlowable&lt;K, V&gt; poll() {
<span class="fc" id="L419">            return queue.poll();</span>
        }

        @Override
        public void clear() {
<span class="nc" id="L424">            queue.clear();</span>
<span class="nc" id="L425">        }</span>

        @Override
        public boolean isEmpty() {
<span class="fc" id="L429">            return queue.isEmpty();</span>
        }
    }

    static final class EvictionAction&lt;K, V&gt; implements Consumer&lt;GroupedUnicast&lt;K, V&gt;&gt; {

        final Queue&lt;GroupedUnicast&lt;K, V&gt;&gt; evictedGroups;

<span class="fc" id="L437">        EvictionAction(Queue&lt;GroupedUnicast&lt;K, V&gt;&gt; evictedGroups) {</span>
<span class="fc" id="L438">            this.evictedGroups = evictedGroups;</span>
<span class="fc" id="L439">        }</span>

        @Override
        public void accept(GroupedUnicast&lt;K, V&gt; value) {
<span class="fc" id="L443">            evictedGroups.offer(value);</span>
<span class="fc" id="L444">        }</span>
    }

    static final class GroupedUnicast&lt;K, T&gt; extends GroupedFlowable&lt;K, T&gt; {

        final State&lt;T, K&gt; state;

        public static &lt;T, K&gt; GroupedUnicast&lt;K, T&gt; createWith(K key, int bufferSize, GroupBySubscriber&lt;?, K, T&gt; parent, boolean delayError) {
<span class="fc" id="L452">            State&lt;T, K&gt; state = new State&lt;T, K&gt;(bufferSize, parent, key, delayError);</span>
<span class="fc" id="L453">            return new GroupedUnicast&lt;K, T&gt;(key, state);</span>
        }

        protected GroupedUnicast(K key, State&lt;T, K&gt; state) {
<span class="fc" id="L457">            super(key);</span>
<span class="fc" id="L458">            this.state = state;</span>
<span class="fc" id="L459">        }</span>

        @Override
        protected void subscribeActual(Subscriber&lt;? super T&gt; s) {
<span class="fc" id="L463">            state.subscribe(s);</span>
<span class="fc" id="L464">        }</span>

        public void onNext(T t) {
<span class="fc" id="L467">            state.onNext(t);</span>
<span class="fc" id="L468">        }</span>

        public void onError(Throwable e) {
<span class="fc" id="L471">            state.onError(e);</span>
<span class="fc" id="L472">        }</span>

        public void onComplete() {
<span class="fc" id="L475">            state.onComplete();</span>
<span class="fc" id="L476">        }</span>
    }

    static final class State&lt;T, K&gt; extends BasicIntQueueSubscription&lt;T&gt; implements Publisher&lt;T&gt; {

        private static final long serialVersionUID = -3852313036005250360L;

        final K key;
        final SpscLinkedArrayQueue&lt;T&gt; queue;
        final GroupBySubscriber&lt;?, K, T&gt; parent;
        final boolean delayError;

<span class="fc" id="L488">        final AtomicLong requested = new AtomicLong();</span>

        volatile boolean done;
        Throwable error;

<span class="fc" id="L493">        final AtomicBoolean cancelled = new AtomicBoolean();</span>

<span class="fc" id="L495">        final AtomicReference&lt;Subscriber&lt;? super T&gt;&gt; actual = new AtomicReference&lt;Subscriber&lt;? super T&gt;&gt;();</span>

<span class="fc" id="L497">        final AtomicBoolean once = new AtomicBoolean();</span>

        boolean outputFused;

        int produced;

<span class="fc" id="L503">        State(int bufferSize, GroupBySubscriber&lt;?, K, T&gt; parent, K key, boolean delayError) {</span>
<span class="fc" id="L504">            this.queue = new SpscLinkedArrayQueue&lt;T&gt;(bufferSize);</span>
<span class="fc" id="L505">            this.parent = parent;</span>
<span class="fc" id="L506">            this.key = key;</span>
<span class="fc" id="L507">            this.delayError = delayError;</span>
<span class="fc" id="L508">        }</span>

        @Override
        public void request(long n) {
<span class="pc bpc" id="L512" title="1 of 2 branches missed.">            if (SubscriptionHelper.validate(n)) {</span>
<span class="fc" id="L513">                BackpressureHelper.add(requested, n);</span>
<span class="fc" id="L514">                drain();</span>
            }
<span class="fc" id="L516">        }</span>

        @Override
        public void cancel() {
<span class="fc bfc" id="L520" title="All 2 branches covered.">            if (cancelled.compareAndSet(false, true)) {</span>
<span class="fc" id="L521">                parent.cancel(key);</span>
            }
<span class="fc" id="L523">        }</span>

        @Override
        public void subscribe(Subscriber&lt;? super T&gt; s) {
<span class="fc bfc" id="L527" title="All 2 branches covered.">            if (once.compareAndSet(false, true)) {</span>
<span class="fc" id="L528">                s.onSubscribe(this);</span>
<span class="fc" id="L529">                actual.lazySet(s);</span>
<span class="fc" id="L530">                drain();</span>
            } else {
<span class="fc" id="L532">                EmptySubscription.error(new IllegalStateException(&quot;Only one Subscriber allowed!&quot;), s);</span>
            }
<span class="fc" id="L534">        }</span>

        public void onNext(T t) {
<span class="fc" id="L537">            queue.offer(t);</span>
<span class="fc" id="L538">            drain();</span>
<span class="fc" id="L539">        }</span>

        public void onError(Throwable e) {
<span class="fc" id="L542">            error = e;</span>
<span class="fc" id="L543">            done = true;</span>
<span class="fc" id="L544">            drain();</span>
<span class="fc" id="L545">        }</span>

        public void onComplete() {
<span class="fc" id="L548">            done = true;</span>
<span class="fc" id="L549">            drain();</span>
<span class="fc" id="L550">        }</span>

        void drain() {
<span class="fc bfc" id="L553" title="All 2 branches covered.">            if (getAndIncrement() != 0) {</span>
<span class="fc" id="L554">                return;</span>
            }
<span class="fc bfc" id="L556" title="All 2 branches covered.">            if (outputFused) {</span>
<span class="fc" id="L557">                drainFused();</span>
            } else {
<span class="fc" id="L559">                drainNormal();</span>
            }
<span class="fc" id="L561">        }</span>

        void drainFused() {
<span class="fc" id="L564">            int missed = 1;</span>

<span class="fc" id="L566">            final SpscLinkedArrayQueue&lt;T&gt; q = this.queue;</span>
<span class="fc" id="L567">            Subscriber&lt;? super T&gt; a = this.actual.get();</span>

            for (;;) {
<span class="fc bfc" id="L570" title="All 2 branches covered.">                if (a != null) {</span>
<span class="fc bfc" id="L571" title="All 2 branches covered.">                    if (cancelled.get()) {</span>
<span class="fc" id="L572">                        q.clear();</span>
<span class="fc" id="L573">                        return;</span>
                    }

<span class="fc" id="L576">                    boolean d = done;</span>

<span class="fc bfc" id="L578" title="All 4 branches covered.">                    if (d &amp;&amp; !delayError) {</span>
<span class="fc" id="L579">                        Throwable ex = error;</span>
<span class="fc bfc" id="L580" title="All 2 branches covered.">                        if (ex != null) {</span>
<span class="fc" id="L581">                            q.clear();</span>
<span class="fc" id="L582">                            a.onError(ex);</span>
<span class="fc" id="L583">                            return;</span>
                        }
                    }

<span class="fc" id="L587">                    a.onNext(null);</span>

<span class="fc bfc" id="L589" title="All 2 branches covered.">                    if (d) {</span>
<span class="fc" id="L590">                        Throwable ex = error;</span>
<span class="fc bfc" id="L591" title="All 2 branches covered.">                        if (ex != null) {</span>
<span class="fc" id="L592">                            a.onError(ex);</span>
                        } else {
<span class="fc" id="L594">                            a.onComplete();</span>
                        }
<span class="fc" id="L596">                        return;</span>
                    }
                }

<span class="fc" id="L600">                missed = addAndGet(-missed);</span>
<span class="fc bfc" id="L601" title="All 2 branches covered.">                if (missed == 0) {</span>
<span class="fc" id="L602">                    return;</span>
                }

<span class="pc bpc" id="L605" title="1 of 2 branches missed.">                if (a == null) {</span>
<span class="nc" id="L606">                    a = this.actual.get();</span>
                }
            }
        }

        void drainNormal() {
<span class="fc" id="L612">            int missed = 1;</span>

<span class="fc" id="L614">            final SpscLinkedArrayQueue&lt;T&gt; q = queue;</span>
<span class="fc" id="L615">            final boolean delayError = this.delayError;</span>
<span class="fc" id="L616">            Subscriber&lt;? super T&gt; a = actual.get();</span>
            for (;;) {
<span class="fc bfc" id="L618" title="All 2 branches covered.">                if (a != null) {</span>
<span class="fc" id="L619">                    long r = requested.get();</span>
<span class="fc" id="L620">                    long e = 0;</span>

<span class="fc bfc" id="L622" title="All 2 branches covered.">                    while (e != r) {</span>
<span class="fc" id="L623">                        boolean d = done;</span>
<span class="fc" id="L624">                        T v = q.poll();</span>
<span class="fc bfc" id="L625" title="All 2 branches covered.">                        boolean empty = v == null;</span>

<span class="fc bfc" id="L627" title="All 2 branches covered.">                        if (checkTerminated(d, empty, a, delayError)) {</span>
<span class="fc" id="L628">                            return;</span>
                        }

<span class="fc bfc" id="L631" title="All 2 branches covered.">                        if (empty) {</span>
<span class="fc" id="L632">                            break;</span>
                        }

<span class="fc" id="L635">                        a.onNext(v);</span>

<span class="fc" id="L637">                        e++;</span>
<span class="fc" id="L638">                    }</span>

<span class="fc bfc" id="L640" title="All 4 branches covered.">                    if (e == r &amp;&amp; checkTerminated(done, q.isEmpty(), a, delayError)) {</span>
<span class="fc" id="L641">                        return;</span>
                    }

<span class="fc bfc" id="L644" title="All 2 branches covered.">                    if (e != 0L) {</span>
<span class="fc bfc" id="L645" title="All 2 branches covered.">                        if (r != Long.MAX_VALUE) {</span>
<span class="fc" id="L646">                            requested.addAndGet(-e);</span>
                        }
<span class="fc" id="L648">                        parent.upstream.request(e);</span>
                    }
                }

<span class="fc" id="L652">                missed = addAndGet(-missed);</span>
<span class="fc bfc" id="L653" title="All 2 branches covered.">                if (missed == 0) {</span>
<span class="fc" id="L654">                    break;</span>
                }
<span class="fc bfc" id="L656" title="All 2 branches covered.">                if (a == null) {</span>
<span class="fc" id="L657">                    a = actual.get();</span>
                }
            }
<span class="fc" id="L660">        }</span>

        boolean checkTerminated(boolean d, boolean empty, Subscriber&lt;? super T&gt; a, boolean delayError) {
<span class="fc bfc" id="L663" title="All 2 branches covered.">            if (cancelled.get()) {</span>
<span class="fc" id="L664">                queue.clear();</span>
<span class="fc" id="L665">                return true;</span>
            }

<span class="fc bfc" id="L668" title="All 2 branches covered.">            if (d) {</span>
<span class="fc bfc" id="L669" title="All 2 branches covered.">                if (delayError) {</span>
<span class="pc bpc" id="L670" title="1 of 2 branches missed.">                    if (empty) {</span>
<span class="fc" id="L671">                        Throwable e = error;</span>
<span class="fc bfc" id="L672" title="All 2 branches covered.">                        if (e != null) {</span>
<span class="fc" id="L673">                            a.onError(e);</span>
                        } else {
<span class="fc" id="L675">                            a.onComplete();</span>
                        }
<span class="fc" id="L677">                        return true;</span>
                    }
                } else {
<span class="fc" id="L680">                    Throwable e = error;</span>
<span class="fc bfc" id="L681" title="All 2 branches covered.">                    if (e != null) {</span>
<span class="fc" id="L682">                        queue.clear();</span>
<span class="fc" id="L683">                        a.onError(e);</span>
<span class="fc" id="L684">                        return true;</span>
                    } else
<span class="fc bfc" id="L686" title="All 2 branches covered.">                    if (empty) {</span>
<span class="fc" id="L687">                        a.onComplete();</span>
<span class="fc" id="L688">                        return true;</span>
                    }
                }
            }

<span class="fc" id="L693">            return false;</span>
        }

        @Override
        public int requestFusion(int mode) {
<span class="pc bpc" id="L698" title="1 of 2 branches missed.">            if ((mode &amp; ASYNC) != 0) {</span>
<span class="fc" id="L699">                outputFused = true;</span>
<span class="fc" id="L700">                return ASYNC;</span>
            }
<span class="nc" id="L702">            return NONE;</span>
        }

        @Nullable
        @Override
        public T poll() {
<span class="fc" id="L708">            T v = queue.poll();</span>
<span class="fc bfc" id="L709" title="All 2 branches covered.">            if (v != null) {</span>
<span class="fc" id="L710">                produced++;</span>
<span class="fc" id="L711">                return v;</span>
            }
<span class="fc" id="L713">            int p = produced;</span>
<span class="fc bfc" id="L714" title="All 2 branches covered.">            if (p != 0) {</span>
<span class="fc" id="L715">                produced = 0;</span>
<span class="fc" id="L716">                parent.upstream.request(p);</span>
            }
<span class="fc" id="L718">            return null;</span>
        }

        @Override
        public boolean isEmpty() {
<span class="fc" id="L723">            return queue.isEmpty();</span>
        }

        @Override
        public void clear() {
<span class="nc" id="L728">            queue.clear();</span>
<span class="nc" id="L729">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>