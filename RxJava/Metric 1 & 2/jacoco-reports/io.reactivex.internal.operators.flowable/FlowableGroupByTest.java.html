<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FlowableGroupByTest.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">RxJava_2_x$Unnamed.exec</a> &gt; <a href="index.source.html" class="el_package">io.reactivex.internal.operators.flowable</a> &gt; <span class="el_source">FlowableGroupByTest.java</span></div><h1>FlowableGroupByTest.java</h1><pre class="source lang-java linenums">/**
 * Copyright (c) 2016-present, RxJava Contributors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is
 * distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
 * the License for the specific language governing permissions and limitations under the License.
 */

package io.reactivex.internal.operators.flowable;

import static org.junit.Assert.*;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;

import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.*;

import org.junit.Test;
import org.mockito.Mockito;
import org.reactivestreams.*;

import com.google.common.base.Ticker;
import com.google.common.cache.*;

import io.reactivex.*;
import io.reactivex.exceptions.TestException;
import io.reactivex.flowables.GroupedFlowable;
import io.reactivex.functions.*;
import io.reactivex.internal.functions.Functions;
import io.reactivex.internal.fuseable.QueueFuseable;
import io.reactivex.internal.subscriptions.BooleanSubscription;
import io.reactivex.processors.PublishProcessor;
import io.reactivex.schedulers.Schedulers;
import io.reactivex.subjects.PublishSubject;
import io.reactivex.subscribers.*;

<span class="fc" id="L44">public class FlowableGroupByTest {</span>

<span class="fc" id="L46">    final Function&lt;String, Integer&gt; length = new Function&lt;String, Integer&gt;() {</span>
        @Override
        public Integer apply(String s) {
<span class="fc" id="L49">            return s.length();</span>
        }
    };

    @Test
    public void testGroupBy() {
<span class="fc" id="L55">        Flowable&lt;String&gt; source = Flowable.just(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;, &quot;six&quot;);</span>
<span class="fc" id="L56">        Flowable&lt;GroupedFlowable&lt;Integer, String&gt;&gt; grouped = source.groupBy(length);</span>

<span class="fc" id="L58">        Map&lt;Integer, Collection&lt;String&gt;&gt; map = toMap(grouped);</span>

<span class="fc" id="L60">        assertEquals(3, map.size());</span>
<span class="fc" id="L61">        assertArrayEquals(Arrays.asList(&quot;one&quot;, &quot;two&quot;, &quot;six&quot;).toArray(), map.get(3).toArray());</span>
<span class="fc" id="L62">        assertArrayEquals(Arrays.asList(&quot;four&quot;, &quot;five&quot;).toArray(), map.get(4).toArray());</span>
<span class="fc" id="L63">        assertArrayEquals(Arrays.asList(&quot;three&quot;).toArray(), map.get(5).toArray());</span>
<span class="fc" id="L64">    }</span>

    @Test
    public void testGroupByWithElementSelector() {
<span class="fc" id="L68">        Flowable&lt;String&gt; source = Flowable.just(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;, &quot;six&quot;);</span>
<span class="fc" id="L69">        Flowable&lt;GroupedFlowable&lt;Integer, Integer&gt;&gt; grouped = source.groupBy(length, length);</span>

<span class="fc" id="L71">        Map&lt;Integer, Collection&lt;Integer&gt;&gt; map = toMap(grouped);</span>

<span class="fc" id="L73">        assertEquals(3, map.size());</span>
<span class="fc" id="L74">        assertArrayEquals(Arrays.asList(3, 3, 3).toArray(), map.get(3).toArray());</span>
<span class="fc" id="L75">        assertArrayEquals(Arrays.asList(4, 4).toArray(), map.get(4).toArray());</span>
<span class="fc" id="L76">        assertArrayEquals(Arrays.asList(5).toArray(), map.get(5).toArray());</span>
<span class="fc" id="L77">    }</span>

    @Test
    public void testGroupByWithElementSelector2() {
<span class="fc" id="L81">        Flowable&lt;String&gt; source = Flowable.just(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;, &quot;six&quot;);</span>
<span class="fc" id="L82">        Flowable&lt;GroupedFlowable&lt;Integer, Integer&gt;&gt; grouped = source.groupBy(length, length);</span>

<span class="fc" id="L84">        Map&lt;Integer, Collection&lt;Integer&gt;&gt; map = toMap(grouped);</span>

<span class="fc" id="L86">        assertEquals(3, map.size());</span>
<span class="fc" id="L87">        assertArrayEquals(Arrays.asList(3, 3, 3).toArray(), map.get(3).toArray());</span>
<span class="fc" id="L88">        assertArrayEquals(Arrays.asList(4, 4).toArray(), map.get(4).toArray());</span>
<span class="fc" id="L89">        assertArrayEquals(Arrays.asList(5).toArray(), map.get(5).toArray());</span>
<span class="fc" id="L90">    }</span>

    @Test
    public void testEmpty() {
<span class="fc" id="L94">        Flowable&lt;String&gt; source = Flowable.empty();</span>
<span class="fc" id="L95">        Flowable&lt;GroupedFlowable&lt;Integer, String&gt;&gt; grouped = source.groupBy(length);</span>

<span class="fc" id="L97">        Map&lt;Integer, Collection&lt;String&gt;&gt; map = toMap(grouped);</span>

<span class="fc" id="L99">        assertTrue(map.isEmpty());</span>
<span class="fc" id="L100">    }</span>

    @Test
    public void testError() {
<span class="fc" id="L104">        Flowable&lt;String&gt; sourceStrings = Flowable.just(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;, &quot;six&quot;);</span>
<span class="fc" id="L105">        Flowable&lt;String&gt; errorSource = Flowable.error(new TestException(&quot;forced failure&quot;));</span>
<span class="fc" id="L106">        Flowable&lt;String&gt; source = Flowable.concat(sourceStrings, errorSource);</span>

<span class="fc" id="L108">        Flowable&lt;GroupedFlowable&lt;Integer, String&gt;&gt; grouped = source.groupBy(length);</span>

<span class="fc" id="L110">        final AtomicInteger groupCounter = new AtomicInteger();</span>
<span class="fc" id="L111">        final AtomicInteger eventCounter = new AtomicInteger();</span>
<span class="fc" id="L112">        final AtomicReference&lt;Throwable&gt; error = new AtomicReference&lt;Throwable&gt;();</span>

<span class="fc" id="L114">        grouped.flatMap(new Function&lt;GroupedFlowable&lt;Integer, String&gt;, Flowable&lt;String&gt;&gt;() {</span>

            @Override
            public Flowable&lt;String&gt; apply(final GroupedFlowable&lt;Integer, String&gt; f) {
<span class="fc" id="L118">                groupCounter.incrementAndGet();</span>
<span class="fc" id="L119">                return f.map(new Function&lt;String, String&gt;() {</span>

                    @Override
                    public String apply(String v) {
<span class="fc" id="L123">                        return &quot;Event =&gt; key: &quot; + f.getKey() + &quot; value: &quot; + v;</span>
                    }
                });
            }
<span class="fc" id="L127">        }).subscribe(new DefaultSubscriber&lt;String&gt;() {</span>

            @Override
            public void onComplete() {

<span class="nc" id="L132">            }</span>

            @Override
            public void onError(Throwable e) {
//                e.printStackTrace();
<span class="fc" id="L137">                error.set(e);</span>
<span class="fc" id="L138">            }</span>

            @Override
            public void onNext(String v) {
<span class="fc" id="L142">                eventCounter.incrementAndGet();</span>
<span class="fc" id="L143">                System.out.println(v);</span>

<span class="fc" id="L145">            }</span>
        });

<span class="fc" id="L148">        assertEquals(3, groupCounter.get());</span>
<span class="fc" id="L149">        assertEquals(6, eventCounter.get());</span>
<span class="fc" id="L150">        assertNotNull(error.get());</span>
<span class="fc" id="L151">        assertTrue(&quot;&quot; + error.get(), error.get() instanceof TestException);</span>
<span class="fc" id="L152">        assertEquals(error.get().getMessage(), &quot;forced failure&quot;);</span>
<span class="fc" id="L153">    }</span>

    private static &lt;K, V&gt; Map&lt;K, Collection&lt;V&gt;&gt; toMap(Flowable&lt;GroupedFlowable&lt;K, V&gt;&gt; flowable) {

<span class="fc" id="L157">        final ConcurrentHashMap&lt;K, Collection&lt;V&gt;&gt; result = new ConcurrentHashMap&lt;K, Collection&lt;V&gt;&gt;();</span>

<span class="fc" id="L159">        flowable.blockingForEach(new Consumer&lt;GroupedFlowable&lt;K, V&gt;&gt;() {</span>

            @Override
            public void accept(final GroupedFlowable&lt;K, V&gt; f) {
<span class="fc" id="L163">                result.put(f.getKey(), new ConcurrentLinkedQueue&lt;V&gt;());</span>
<span class="fc" id="L164">                f.subscribe(new Consumer&lt;V&gt;() {</span>

                    @Override
                    public void accept(V v) {
<span class="fc" id="L168">                        result.get(f.getKey()).add(v);</span>
<span class="fc" id="L169">                    }</span>

                });
<span class="fc" id="L172">            }</span>
        });

<span class="fc" id="L175">        return result;</span>
    }

    /**
     * Assert that only a single subscription to a stream occurs and that all events are received.
     *
     * @throws Throwable some method call is declared throws
     */
    @Test
    public void testGroupedEventStream() throws Throwable {

<span class="fc" id="L186">        final AtomicInteger eventCounter = new AtomicInteger();</span>
<span class="fc" id="L187">        final AtomicInteger subscribeCounter = new AtomicInteger();</span>
<span class="fc" id="L188">        final AtomicInteger groupCounter = new AtomicInteger();</span>
<span class="fc" id="L189">        final CountDownLatch latch = new CountDownLatch(1);</span>
<span class="fc" id="L190">        final int count = 100;</span>
<span class="fc" id="L191">        final int groupCount = 2;</span>

<span class="fc" id="L193">        Flowable&lt;Event&gt; es = Flowable.unsafeCreate(new Publisher&lt;Event&gt;() {</span>

            @Override
            public void subscribe(final Subscriber&lt;? super Event&gt; subscriber) {
<span class="fc" id="L197">                subscriber.onSubscribe(new BooleanSubscription());</span>
<span class="fc" id="L198">                System.out.println(&quot;*** Subscribing to EventStream ***&quot;);</span>
<span class="fc" id="L199">                subscribeCounter.incrementAndGet();</span>
<span class="fc" id="L200">                new Thread(new Runnable() {</span>

                    @Override
                    public void run() {
<span class="fc bfc" id="L204" title="All 2 branches covered.">                        for (int i = 0; i &lt; count; i++) {</span>
<span class="fc" id="L205">                            Event e = new Event();</span>
<span class="fc" id="L206">                            e.source = i % groupCount;</span>
<span class="fc" id="L207">                            e.message = &quot;Event-&quot; + i;</span>
<span class="fc" id="L208">                            subscriber.onNext(e);</span>
                        }
<span class="fc" id="L210">                        subscriber.onComplete();</span>
<span class="fc" id="L211">                    }</span>

<span class="fc" id="L213">                }).start();</span>
<span class="fc" id="L214">            }</span>

        });

<span class="fc" id="L218">        es.groupBy(new Function&lt;Event, Integer&gt;() {</span>

            @Override
            public Integer apply(Event e) {
<span class="fc" id="L222">                return e.source;</span>
            }
<span class="fc" id="L224">        }).flatMap(new Function&lt;GroupedFlowable&lt;Integer, Event&gt;, Flowable&lt;String&gt;&gt;() {</span>

            @Override
            public Flowable&lt;String&gt; apply(GroupedFlowable&lt;Integer, Event&gt; eventGroupedFlowable) {
<span class="fc" id="L228">                System.out.println(&quot;GroupedFlowable Key: &quot; + eventGroupedFlowable.getKey());</span>
<span class="fc" id="L229">                groupCounter.incrementAndGet();</span>

<span class="fc" id="L231">                return eventGroupedFlowable.map(new Function&lt;Event, String&gt;() {</span>

                    @Override
                    public String apply(Event event) {
<span class="fc" id="L235">                        return &quot;Source: &quot; + event.source + &quot;  Message: &quot; + event.message;</span>
                    }
                });

            }
<span class="fc" id="L240">        }).subscribe(new DefaultSubscriber&lt;String&gt;() {</span>

            @Override
            public void onComplete() {
<span class="fc" id="L244">                latch.countDown();</span>
<span class="fc" id="L245">            }</span>

            @Override
            public void onError(Throwable e) {
<span class="nc" id="L249">                e.printStackTrace();</span>
<span class="nc" id="L250">                latch.countDown();</span>
<span class="nc" id="L251">            }</span>

            @Override
            public void onNext(String outputMessage) {
<span class="fc" id="L255">                System.out.println(outputMessage);</span>
<span class="fc" id="L256">                eventCounter.incrementAndGet();</span>
<span class="fc" id="L257">            }</span>
        });

<span class="fc" id="L260">        latch.await(5000, TimeUnit.MILLISECONDS);</span>
<span class="fc" id="L261">        assertEquals(1, subscribeCounter.get());</span>
<span class="fc" id="L262">        assertEquals(groupCount, groupCounter.get());</span>
<span class="fc" id="L263">        assertEquals(count, eventCounter.get());</span>

<span class="fc" id="L265">    }</span>

    /*
     * We will only take 1 group with 20 events from it and then unsubscribe.
     */
    @Test
    public void testUnsubscribeOnNestedTakeAndSyncInfiniteStream() throws InterruptedException {
<span class="fc" id="L272">        final AtomicInteger subscribeCounter = new AtomicInteger();</span>
<span class="fc" id="L273">        final AtomicInteger sentEventCounter = new AtomicInteger();</span>
<span class="fc" id="L274">        doTestUnsubscribeOnNestedTakeAndAsyncInfiniteStream(SYNC_INFINITE_OBSERVABLE_OF_EVENT(2, subscribeCounter, sentEventCounter), subscribeCounter);</span>
<span class="fc" id="L275">        Thread.sleep(500);</span>
<span class="fc" id="L276">        assertEquals(39, sentEventCounter.get());</span>
<span class="fc" id="L277">    }</span>

    /*
     * We will only take 1 group with 20 events from it and then unsubscribe.
     */
    @Test
    public void testUnsubscribeOnNestedTakeAndAsyncInfiniteStream() throws InterruptedException {
<span class="fc" id="L284">        final AtomicInteger subscribeCounter = new AtomicInteger();</span>
<span class="fc" id="L285">        final AtomicInteger sentEventCounter = new AtomicInteger();</span>
<span class="fc" id="L286">        doTestUnsubscribeOnNestedTakeAndAsyncInfiniteStream(ASYNC_INFINITE_OBSERVABLE_OF_EVENT(2, subscribeCounter, sentEventCounter), subscribeCounter);</span>
<span class="fc" id="L287">        Thread.sleep(500);</span>
<span class="fc" id="L288">        assertEquals(39, sentEventCounter.get());</span>
<span class="fc" id="L289">    }</span>

    private void doTestUnsubscribeOnNestedTakeAndAsyncInfiniteStream(Flowable&lt;Event&gt; es, AtomicInteger subscribeCounter) throws InterruptedException {
<span class="fc" id="L292">        final AtomicInteger eventCounter = new AtomicInteger();</span>
<span class="fc" id="L293">        final AtomicInteger groupCounter = new AtomicInteger();</span>
<span class="fc" id="L294">        final CountDownLatch latch = new CountDownLatch(1);</span>

<span class="fc" id="L296">        es.groupBy(new Function&lt;Event, Integer&gt;() {</span>

            @Override
            public Integer apply(Event e) {
<span class="fc" id="L300">                return e.source;</span>
            }
        })
<span class="fc" id="L303">                .take(1) // we want only the first group</span>
<span class="fc" id="L304">                .flatMap(new Function&lt;GroupedFlowable&lt;Integer, Event&gt;, Flowable&lt;String&gt;&gt;() {</span>

                    @Override
                    public Flowable&lt;String&gt; apply(GroupedFlowable&lt;Integer, Event&gt; eventGroupedFlowable) {
<span class="fc" id="L308">                        System.out.println(&quot;testUnsubscribe =&gt; GroupedFlowable Key: &quot; + eventGroupedFlowable.getKey());</span>
<span class="fc" id="L309">                        groupCounter.incrementAndGet();</span>

<span class="fc" id="L311">                        return eventGroupedFlowable</span>
<span class="fc" id="L312">                                .take(20) // limit to only 20 events on this group</span>
<span class="fc" id="L313">                                .map(new Function&lt;Event, String&gt;() {</span>

                                    @Override
                                    public String apply(Event event) {
<span class="fc" id="L317">                                        return &quot;testUnsubscribe =&gt; Source: &quot; + event.source + &quot;  Message: &quot; + event.message;</span>
                                    }
                                });

                    }
<span class="fc" id="L322">                }).subscribe(new DefaultSubscriber&lt;String&gt;() {</span>

                    @Override
                    public void onComplete() {
<span class="fc" id="L326">                        latch.countDown();</span>
<span class="fc" id="L327">                    }</span>

                    @Override
                    public void onError(Throwable e) {
<span class="nc" id="L331">                        e.printStackTrace();</span>
<span class="nc" id="L332">                        latch.countDown();</span>
<span class="nc" id="L333">                    }</span>

                    @Override
                    public void onNext(String outputMessage) {
<span class="fc" id="L337">                        System.out.println(outputMessage);</span>
<span class="fc" id="L338">                        eventCounter.incrementAndGet();</span>
<span class="fc" id="L339">                    }</span>
                });

<span class="pc bpc" id="L342" title="1 of 2 branches missed.">        if (!latch.await(2000, TimeUnit.MILLISECONDS)) {</span>
<span class="nc" id="L343">            fail(&quot;timed out so likely did not unsubscribe correctly&quot;);</span>
        }
<span class="fc" id="L345">        assertEquals(1, subscribeCounter.get());</span>
<span class="fc" id="L346">        assertEquals(1, groupCounter.get());</span>
<span class="fc" id="L347">        assertEquals(20, eventCounter.get());</span>
        // sentEvents will go until 'eventCounter' hits 20 and then unsubscribes
        // which means it will also send (but ignore) the 19/20 events for the other group
        // It will not however send all 100 events.
<span class="fc" id="L351">    }</span>

    @Test
    public void testUnsubscribeViaTakeOnGroupThenMergeAndTake() {
<span class="fc" id="L355">        final AtomicInteger subscribeCounter = new AtomicInteger();</span>
<span class="fc" id="L356">        final AtomicInteger sentEventCounter = new AtomicInteger();</span>
<span class="fc" id="L357">        final AtomicInteger eventCounter = new AtomicInteger();</span>

<span class="fc" id="L359">        SYNC_INFINITE_OBSERVABLE_OF_EVENT(4, subscribeCounter, sentEventCounter)</span>
<span class="fc" id="L360">                .groupBy(new Function&lt;Event, Integer&gt;() {</span>

                    @Override
                    public Integer apply(Event e) {
<span class="fc" id="L364">                        return e.source;</span>
                    }
                })
                // take 2 of the 4 groups
<span class="fc" id="L368">                .take(2)</span>
<span class="fc" id="L369">                .flatMap(new Function&lt;GroupedFlowable&lt;Integer, Event&gt;, Flowable&lt;String&gt;&gt;() {</span>

                    @Override
                    public Flowable&lt;String&gt; apply(GroupedFlowable&lt;Integer, Event&gt; eventGroupedFlowable) {
<span class="fc" id="L373">                        return eventGroupedFlowable</span>
<span class="fc" id="L374">                                .map(new Function&lt;Event, String&gt;() {</span>

                                    @Override
                                    public String apply(Event event) {
<span class="fc" id="L378">                                        return &quot;testUnsubscribe =&gt; Source: &quot; + event.source + &quot;  Message: &quot; + event.message;</span>
                                    }
                                });

                    }
                })
<span class="fc" id="L384">                .take(30).subscribe(new Consumer&lt;String&gt;() {</span>

                    @Override
                    public void accept(String s) {
<span class="fc" id="L388">                        eventCounter.incrementAndGet();</span>
<span class="fc" id="L389">                        System.out.println(&quot;=&gt; &quot; + s);</span>
<span class="fc" id="L390">                    }</span>

                });

<span class="fc" id="L394">        assertEquals(30, eventCounter.get());</span>
        // we should send 28 additional events that are filtered out as they are in the groups we skip
<span class="fc" id="L396">        assertEquals(58, sentEventCounter.get());</span>
<span class="fc" id="L397">    }</span>

    @Test
    public void testUnsubscribeViaTakeOnGroupThenTakeOnInner() {
<span class="fc" id="L401">        final AtomicInteger subscribeCounter = new AtomicInteger();</span>
<span class="fc" id="L402">        final AtomicInteger sentEventCounter = new AtomicInteger();</span>
<span class="fc" id="L403">        final AtomicInteger eventCounter = new AtomicInteger();</span>

<span class="fc" id="L405">        SYNC_INFINITE_OBSERVABLE_OF_EVENT(4, subscribeCounter, sentEventCounter)</span>
<span class="fc" id="L406">                .groupBy(new Function&lt;Event, Integer&gt;() {</span>

                    @Override
                    public Integer apply(Event e) {
<span class="fc" id="L410">                        return e.source;</span>
                    }
                })
                // take 2 of the 4 groups
<span class="fc" id="L414">                .take(2)</span>
<span class="fc" id="L415">                .flatMap(new Function&lt;GroupedFlowable&lt;Integer, Event&gt;, Flowable&lt;String&gt;&gt;() {</span>

                    @Override
                    public Flowable&lt;String&gt; apply(GroupedFlowable&lt;Integer, Event&gt; eventGroupedFlowable) {
<span class="fc" id="L419">                        int numToTake = 0;</span>
<span class="fc bfc" id="L420" title="All 2 branches covered.">                        if (eventGroupedFlowable.getKey() == 1) {</span>
<span class="fc" id="L421">                            numToTake = 10;</span>
<span class="pc bpc" id="L422" title="1 of 2 branches missed.">                        } else if (eventGroupedFlowable.getKey() == 2) {</span>
<span class="fc" id="L423">                            numToTake = 5;</span>
                        }
<span class="fc" id="L425">                        return eventGroupedFlowable</span>
<span class="fc" id="L426">                                .take(numToTake)</span>
<span class="fc" id="L427">                                .map(new Function&lt;Event, String&gt;() {</span>

                                    @Override
                                    public String apply(Event event) {
<span class="fc" id="L431">                                        return &quot;testUnsubscribe =&gt; Source: &quot; + event.source + &quot;  Message: &quot; + event.message;</span>
                                    }
                                });

                    }
                })
<span class="fc" id="L437">                .subscribe(new Consumer&lt;String&gt;() {</span>

                    @Override
                    public void accept(String s) {
<span class="fc" id="L441">                        eventCounter.incrementAndGet();</span>
<span class="fc" id="L442">                        System.out.println(&quot;=&gt; &quot; + s);</span>
<span class="fc" id="L443">                    }</span>

                });

<span class="fc" id="L447">        assertEquals(15, eventCounter.get());</span>
        // we should send 22 additional events that are filtered out as they are skipped while taking the 15 we want
<span class="fc" id="L449">        assertEquals(37, sentEventCounter.get());</span>
<span class="fc" id="L450">    }</span>

    @Test
    public void testStaggeredCompletion() throws InterruptedException {
<span class="fc" id="L454">        final AtomicInteger eventCounter = new AtomicInteger();</span>
<span class="fc" id="L455">        final CountDownLatch latch = new CountDownLatch(1);</span>
<span class="fc" id="L456">        Flowable.range(0, 100)</span>
<span class="fc" id="L457">                .groupBy(new Function&lt;Integer, Integer&gt;() {</span>

                    @Override
                    public Integer apply(Integer i) {
<span class="fc" id="L461">                        return i % 2;</span>
                    }
                })
<span class="fc" id="L464">                .flatMap(new Function&lt;GroupedFlowable&lt;Integer, Integer&gt;, Flowable&lt;Integer&gt;&gt;() {</span>

                    @Override
                    public Flowable&lt;Integer&gt; apply(GroupedFlowable&lt;Integer, Integer&gt; group) {
<span class="fc bfc" id="L468" title="All 2 branches covered.">                        if (group.getKey() == 0) {</span>
<span class="fc" id="L469">                            return group.delay(100, TimeUnit.MILLISECONDS).map(new Function&lt;Integer, Integer&gt;() {</span>
                                @Override
                                public Integer apply(Integer t) {
<span class="fc" id="L472">                                    return t * 10;</span>
                                }

                            });
                        } else {
<span class="fc" id="L477">                            return group;</span>
                        }
                    }
                })
<span class="fc" id="L481">                .subscribe(new DefaultSubscriber&lt;Integer&gt;() {</span>

                    @Override
                    public void onComplete() {
<span class="fc" id="L485">                        System.out.println(&quot;=&gt; onComplete&quot;);</span>
<span class="fc" id="L486">                        latch.countDown();</span>
<span class="fc" id="L487">                    }</span>

                    @Override
                    public void onError(Throwable e) {
<span class="nc" id="L491">                        e.printStackTrace();</span>
<span class="nc" id="L492">                        latch.countDown();</span>
<span class="nc" id="L493">                    }</span>

                    @Override
                    public void onNext(Integer s) {
<span class="fc" id="L497">                        eventCounter.incrementAndGet();</span>
<span class="fc" id="L498">                        System.out.println(&quot;=&gt; &quot; + s);</span>
<span class="fc" id="L499">                    }</span>
                });

<span class="pc bpc" id="L502" title="1 of 2 branches missed.">        if (!latch.await(3000, TimeUnit.MILLISECONDS)) {</span>
<span class="nc" id="L503">            fail(&quot;timed out&quot;);</span>
        }

<span class="fc" id="L506">        assertEquals(100, eventCounter.get());</span>
<span class="fc" id="L507">    }</span>

    @Test(timeout = 1000)
    public void testCompletionIfInnerNotSubscribed() throws InterruptedException {
<span class="fc" id="L511">        final CountDownLatch latch = new CountDownLatch(1);</span>
<span class="fc" id="L512">        final AtomicInteger eventCounter = new AtomicInteger();</span>
<span class="fc" id="L513">        Flowable.range(0, 100)</span>
<span class="fc" id="L514">                .groupBy(new Function&lt;Integer, Integer&gt;() {</span>

                    @Override
                    public Integer apply(Integer i) {
<span class="fc" id="L518">                        return i % 2;</span>
                    }
                })
<span class="fc" id="L521">                .subscribe(new DefaultSubscriber&lt;GroupedFlowable&lt;Integer, Integer&gt;&gt;() {</span>

                    @Override
                    public void onComplete() {
<span class="fc" id="L525">                        latch.countDown();</span>
<span class="fc" id="L526">                    }</span>

                    @Override
                    public void onError(Throwable e) {
<span class="nc" id="L530">                        e.printStackTrace();</span>
<span class="nc" id="L531">                        latch.countDown();</span>
<span class="nc" id="L532">                    }</span>

                    @Override
                    public void onNext(GroupedFlowable&lt;Integer, Integer&gt; s) {
<span class="fc" id="L536">                        eventCounter.incrementAndGet();</span>
<span class="fc" id="L537">                        System.out.println(&quot;=&gt; &quot; + s);</span>
<span class="fc" id="L538">                    }</span>
                });
<span class="pc bpc" id="L540" title="1 of 2 branches missed.">        if (!latch.await(500, TimeUnit.MILLISECONDS)) {</span>
<span class="nc" id="L541">            fail(&quot;timed out - never got completion&quot;);</span>
        }
<span class="fc" id="L543">        assertEquals(2, eventCounter.get());</span>
<span class="fc" id="L544">    }</span>

    @Test
    public void testIgnoringGroups() {
<span class="fc" id="L548">        final AtomicInteger subscribeCounter = new AtomicInteger();</span>
<span class="fc" id="L549">        final AtomicInteger sentEventCounter = new AtomicInteger();</span>
<span class="fc" id="L550">        final AtomicInteger eventCounter = new AtomicInteger();</span>

<span class="fc" id="L552">        SYNC_INFINITE_OBSERVABLE_OF_EVENT(4, subscribeCounter, sentEventCounter)</span>
<span class="fc" id="L553">                .groupBy(new Function&lt;Event, Integer&gt;() {</span>

                    @Override
                    public Integer apply(Event e) {
<span class="fc" id="L557">                        return e.source;</span>
                    }
                })
<span class="fc" id="L560">                .flatMap(new Function&lt;GroupedFlowable&lt;Integer, Event&gt;, Flowable&lt;String&gt;&gt;() {</span>

                    @Override
                    public Flowable&lt;String&gt; apply(GroupedFlowable&lt;Integer, Event&gt; eventGroupedFlowable) {
<span class="fc" id="L564">                        Flowable&lt;Event&gt; eventStream = eventGroupedFlowable;</span>
<span class="fc bfc" id="L565" title="All 2 branches covered.">                        if (eventGroupedFlowable.getKey() &gt;= 2) {</span>
                            // filter these
<span class="fc" id="L567">                            eventStream = eventGroupedFlowable.filter(new Predicate&lt;Event&gt;() {</span>
                                @Override
                                public boolean test(Event t1) {
<span class="fc" id="L570">                                    return false;</span>
                                }
                            });
                        }

<span class="fc" id="L575">                        return eventStream</span>
<span class="fc" id="L576">                                .map(new Function&lt;Event, String&gt;() {</span>

                                    @Override
                                    public String apply(Event event) {
<span class="fc" id="L580">                                        return &quot;testUnsubscribe =&gt; Source: &quot; + event.source + &quot;  Message: &quot; + event.message;</span>
                                    }
                                });

                    }
                })
<span class="fc" id="L586">                .take(30).subscribe(new Consumer&lt;String&gt;() {</span>

                    @Override
                    public void accept(String s) {
<span class="fc" id="L590">                        eventCounter.incrementAndGet();</span>
<span class="fc" id="L591">                        System.out.println(&quot;=&gt; &quot; + s);</span>
<span class="fc" id="L592">                    }</span>

                });

<span class="fc" id="L596">        assertEquals(30, eventCounter.get());</span>
        // we should send 30 additional events that are filtered out as they are in the groups we skip
<span class="fc" id="L598">        assertEquals(60, sentEventCounter.get());</span>
<span class="fc" id="L599">    }</span>

    @Test
    public void testFirstGroupsCompleteAndParentSlowToThenEmitFinalGroupsAndThenComplete() throws InterruptedException {
<span class="fc" id="L603">        final CountDownLatch first = new CountDownLatch(2); // there are two groups to first complete</span>
<span class="fc" id="L604">        final ArrayList&lt;String&gt; results = new ArrayList&lt;String&gt;();</span>
<span class="fc" id="L605">        Flowable.unsafeCreate(new Publisher&lt;Integer&gt;() {</span>

            @Override
            public void subscribe(Subscriber&lt;? super Integer&gt; sub) {
<span class="fc" id="L609">                sub.onSubscribe(new BooleanSubscription());</span>
<span class="fc" id="L610">                sub.onNext(1);</span>
<span class="fc" id="L611">                sub.onNext(2);</span>
<span class="fc" id="L612">                sub.onNext(1);</span>
<span class="fc" id="L613">                sub.onNext(2);</span>
                try {
<span class="fc" id="L615">                    first.await();</span>
<span class="nc" id="L616">                } catch (InterruptedException e) {</span>
<span class="nc" id="L617">                    sub.onError(e);</span>
<span class="nc" id="L618">                    return;</span>
<span class="fc" id="L619">                }</span>
<span class="fc" id="L620">                sub.onNext(3);</span>
<span class="fc" id="L621">                sub.onNext(3);</span>
<span class="fc" id="L622">                sub.onComplete();</span>
<span class="fc" id="L623">            }</span>

<span class="fc" id="L625">        }).groupBy(new Function&lt;Integer, Integer&gt;() {</span>

            @Override
            public Integer apply(Integer t) {
<span class="fc" id="L629">                return t;</span>
            }

<span class="fc" id="L632">        }).flatMap(new Function&lt;GroupedFlowable&lt;Integer, Integer&gt;, Flowable&lt;String&gt;&gt;() {</span>

            @Override
            public Flowable&lt;String&gt; apply(final GroupedFlowable&lt;Integer, Integer&gt; group) {
<span class="fc bfc" id="L636" title="All 2 branches covered.">                if (group.getKey() &lt; 3) {</span>
<span class="fc" id="L637">                    return group.map(new Function&lt;Integer, String&gt;() {</span>

                        @Override
                        public String apply(Integer t1) {
<span class="fc" id="L641">                            return &quot;first groups: &quot; + t1;</span>
                        }

                    })
                            // must take(2) so an onComplete + unsubscribe happens on these first 2 groups
<span class="fc" id="L646">                            .take(2).doOnComplete(new Action() {</span>

                                @Override
                                public void run() {
<span class="fc" id="L650">                                    first.countDown();</span>
<span class="fc" id="L651">                                }</span>

                            });
                } else {
<span class="fc" id="L655">                    return group.map(new Function&lt;Integer, String&gt;() {</span>

                        @Override
                        public String apply(Integer t1) {
<span class="fc" id="L659">                            return &quot;last group: &quot; + t1;</span>
                        }

                    });
                }
            }

<span class="fc" id="L666">        }).blockingForEach(new Consumer&lt;String&gt;() {</span>

            @Override
            public void accept(String s) {
<span class="fc" id="L670">                results.add(s);</span>
<span class="fc" id="L671">            }</span>

        });

<span class="fc" id="L675">        System.out.println(&quot;Results: &quot; + results);</span>
<span class="fc" id="L676">        assertEquals(6, results.size());</span>
<span class="fc" id="L677">    }</span>

    @Test
    public void testFirstGroupsCompleteAndParentSlowToThenEmitFinalGroupsWhichThenSubscribesOnAndDelaysAndThenCompletes() throws InterruptedException {
<span class="fc" id="L681">        System.err.println(&quot;----------------------------------------------------------------------------------------------&quot;);</span>
<span class="fc" id="L682">        final CountDownLatch first = new CountDownLatch(2); // there are two groups to first complete</span>
<span class="fc" id="L683">        final ArrayList&lt;String&gt; results = new ArrayList&lt;String&gt;();</span>
<span class="fc" id="L684">        Flowable.unsafeCreate(new Publisher&lt;Integer&gt;() {</span>

            @Override
            public void subscribe(Subscriber&lt;? super Integer&gt; sub) {
<span class="fc" id="L688">                sub.onSubscribe(new BooleanSubscription());</span>
<span class="fc" id="L689">                sub.onNext(1);</span>
<span class="fc" id="L690">                sub.onNext(2);</span>
<span class="fc" id="L691">                sub.onNext(1);</span>
<span class="fc" id="L692">                sub.onNext(2);</span>
                try {
<span class="fc" id="L694">                    first.await();</span>
<span class="nc" id="L695">                } catch (InterruptedException e) {</span>
<span class="nc" id="L696">                    sub.onError(e);</span>
<span class="nc" id="L697">                    return;</span>
<span class="fc" id="L698">                }</span>
<span class="fc" id="L699">                sub.onNext(3);</span>
<span class="fc" id="L700">                sub.onNext(3);</span>
<span class="fc" id="L701">                sub.onComplete();</span>
<span class="fc" id="L702">            }</span>

<span class="fc" id="L704">        }).groupBy(new Function&lt;Integer, Integer&gt;() {</span>

            @Override
            public Integer apply(Integer t) {
<span class="fc" id="L708">                return t;</span>
            }

<span class="fc" id="L711">        }).flatMap(new Function&lt;GroupedFlowable&lt;Integer, Integer&gt;, Flowable&lt;String&gt;&gt;() {</span>

            @Override
            public Flowable&lt;String&gt; apply(final GroupedFlowable&lt;Integer, Integer&gt; group) {
<span class="fc bfc" id="L715" title="All 2 branches covered.">                if (group.getKey() &lt; 3) {</span>
<span class="fc" id="L716">                    return group.map(new Function&lt;Integer, String&gt;() {</span>

                        @Override
                        public String apply(Integer t1) {
<span class="fc" id="L720">                            return &quot;first groups: &quot; + t1;</span>
                        }

                    })
                            // must take(2) so an onComplete + unsubscribe happens on these first 2 groups
<span class="fc" id="L725">                            .take(2).doOnComplete(new Action() {</span>

                                @Override
                                public void run() {
<span class="fc" id="L729">                                    first.countDown();</span>
<span class="fc" id="L730">                                }</span>

                            });
                } else {
<span class="fc" id="L734">                    return group.subscribeOn(Schedulers.newThread()).delay(400, TimeUnit.MILLISECONDS).map(new Function&lt;Integer, String&gt;() {</span>

                        @Override
                        public String apply(Integer t1) {
<span class="fc" id="L738">                            return &quot;last group: &quot; + t1;</span>
                        }

<span class="fc" id="L741">                    }).doOnEach(new Consumer&lt;Notification&lt;String&gt;&gt;() {</span>

                        @Override
                        public void accept(Notification&lt;String&gt; t1) {
<span class="fc" id="L745">                            System.err.println(&quot;subscribeOn notification =&gt; &quot; + t1);</span>
<span class="fc" id="L746">                        }</span>

                    });
                }
            }

<span class="fc" id="L752">        }).doOnEach(new Consumer&lt;Notification&lt;String&gt;&gt;() {</span>

            @Override
            public void accept(Notification&lt;String&gt; t1) {
<span class="fc" id="L756">                System.err.println(&quot;outer notification =&gt; &quot; + t1);</span>
<span class="fc" id="L757">            }</span>

<span class="fc" id="L759">        }).blockingForEach(new Consumer&lt;String&gt;() {</span>

            @Override
            public void accept(String s) {
<span class="fc" id="L763">                results.add(s);</span>
<span class="fc" id="L764">            }</span>

        });

<span class="fc" id="L768">        System.out.println(&quot;Results: &quot; + results);</span>
<span class="fc" id="L769">        assertEquals(6, results.size());</span>
<span class="fc" id="L770">    }</span>

    @Test
    public void testFirstGroupsCompleteAndParentSlowToThenEmitFinalGroupsWhichThenObservesOnAndDelaysAndThenCompletes() throws InterruptedException {
<span class="fc" id="L774">        final CountDownLatch first = new CountDownLatch(2); // there are two groups to first complete</span>
<span class="fc" id="L775">        final ArrayList&lt;String&gt; results = new ArrayList&lt;String&gt;();</span>
<span class="fc" id="L776">        Flowable.unsafeCreate(new Publisher&lt;Integer&gt;() {</span>

            @Override
            public void subscribe(Subscriber&lt;? super Integer&gt; sub) {
<span class="fc" id="L780">                sub.onSubscribe(new BooleanSubscription());</span>
<span class="fc" id="L781">                sub.onNext(1);</span>
<span class="fc" id="L782">                sub.onNext(2);</span>
<span class="fc" id="L783">                sub.onNext(1);</span>
<span class="fc" id="L784">                sub.onNext(2);</span>
                try {
<span class="fc" id="L786">                    first.await();</span>
<span class="nc" id="L787">                } catch (InterruptedException e) {</span>
<span class="nc" id="L788">                    sub.onError(e);</span>
<span class="nc" id="L789">                    return;</span>
<span class="fc" id="L790">                }</span>
<span class="fc" id="L791">                sub.onNext(3);</span>
<span class="fc" id="L792">                sub.onNext(3);</span>
<span class="fc" id="L793">                sub.onComplete();</span>
<span class="fc" id="L794">            }</span>

<span class="fc" id="L796">        }).groupBy(new Function&lt;Integer, Integer&gt;() {</span>

            @Override
            public Integer apply(Integer t) {
<span class="fc" id="L800">                return t;</span>
            }

<span class="fc" id="L803">        }).flatMap(new Function&lt;GroupedFlowable&lt;Integer, Integer&gt;, Flowable&lt;String&gt;&gt;() {</span>

            @Override
            public Flowable&lt;String&gt; apply(final GroupedFlowable&lt;Integer, Integer&gt; group) {
<span class="fc bfc" id="L807" title="All 2 branches covered.">                if (group.getKey() &lt; 3) {</span>
<span class="fc" id="L808">                    return group.map(new Function&lt;Integer, String&gt;() {</span>

                        @Override
                        public String apply(Integer t1) {
<span class="fc" id="L812">                            return &quot;first groups: &quot; + t1;</span>
                        }

                    })
                            // must take(2) so an onComplete + unsubscribe happens on these first 2 groups
<span class="fc" id="L817">                            .take(2).doOnComplete(new Action() {</span>

                                @Override
                                public void run() {
<span class="fc" id="L821">                                    first.countDown();</span>
<span class="fc" id="L822">                                }</span>

                            });
                } else {
<span class="fc" id="L826">                    return group.observeOn(Schedulers.newThread()).delay(400, TimeUnit.MILLISECONDS).map(new Function&lt;Integer, String&gt;() {</span>

                        @Override
                        public String apply(Integer t1) {
<span class="fc" id="L830">                            return &quot;last group: &quot; + t1;</span>
                        }

                    });
                }
            }

<span class="fc" id="L837">        }).blockingForEach(new Consumer&lt;String&gt;() {</span>

            @Override
            public void accept(String s) {
<span class="fc" id="L841">                results.add(s);</span>
<span class="fc" id="L842">            }</span>

        });

<span class="fc" id="L846">        System.out.println(&quot;Results: &quot; + results);</span>
<span class="fc" id="L847">        assertEquals(6, results.size());</span>
<span class="fc" id="L848">    }</span>

    @Test
    public void testGroupsWithNestedSubscribeOn() throws InterruptedException {
<span class="fc" id="L852">        final ArrayList&lt;String&gt; results = new ArrayList&lt;String&gt;();</span>
<span class="fc" id="L853">        Flowable.unsafeCreate(new Publisher&lt;Integer&gt;() {</span>

            @Override
            public void subscribe(Subscriber&lt;? super Integer&gt; sub) {
<span class="fc" id="L857">                sub.onSubscribe(new BooleanSubscription());</span>
<span class="fc" id="L858">                sub.onNext(1);</span>
<span class="fc" id="L859">                sub.onNext(2);</span>
<span class="fc" id="L860">                sub.onNext(1);</span>
<span class="fc" id="L861">                sub.onNext(2);</span>
<span class="fc" id="L862">                sub.onComplete();</span>
<span class="fc" id="L863">            }</span>

<span class="fc" id="L865">        }).groupBy(new Function&lt;Integer, Integer&gt;() {</span>

            @Override
            public Integer apply(Integer t) {
<span class="fc" id="L869">                return t;</span>
            }

<span class="fc" id="L872">        }).flatMap(new Function&lt;GroupedFlowable&lt;Integer, Integer&gt;, Flowable&lt;String&gt;&gt;() {</span>

            @Override
            public Flowable&lt;String&gt; apply(final GroupedFlowable&lt;Integer, Integer&gt; group) {
<span class="fc" id="L876">                return group.subscribeOn(Schedulers.newThread()).map(new Function&lt;Integer, String&gt;() {</span>

                    @Override
                    public String apply(Integer t1) {
<span class="fc" id="L880">                        System.out.println(&quot;Received: &quot; + t1 + &quot; on group : &quot; + group.getKey());</span>
<span class="fc" id="L881">                        return &quot;first groups: &quot; + t1;</span>
                    }

                });
            }

<span class="fc" id="L887">        }).doOnEach(new Consumer&lt;Notification&lt;String&gt;&gt;() {</span>

            @Override
            public void accept(Notification&lt;String&gt; t1) {
<span class="fc" id="L891">                System.out.println(&quot;notification =&gt; &quot; + t1);</span>
<span class="fc" id="L892">            }</span>

<span class="fc" id="L894">        }).blockingForEach(new Consumer&lt;String&gt;() {</span>

            @Override
            public void accept(String s) {
<span class="fc" id="L898">                results.add(s);</span>
<span class="fc" id="L899">            }</span>

        });

<span class="fc" id="L903">        System.out.println(&quot;Results: &quot; + results);</span>
<span class="fc" id="L904">        assertEquals(4, results.size());</span>
<span class="fc" id="L905">    }</span>

    @Test
    public void testGroupsWithNestedObserveOn() throws InterruptedException {
<span class="fc" id="L909">        final ArrayList&lt;String&gt; results = new ArrayList&lt;String&gt;();</span>
<span class="fc" id="L910">        Flowable.unsafeCreate(new Publisher&lt;Integer&gt;() {</span>

            @Override
            public void subscribe(Subscriber&lt;? super Integer&gt; sub) {
<span class="fc" id="L914">                sub.onSubscribe(new BooleanSubscription());</span>
<span class="fc" id="L915">                sub.onNext(1);</span>
<span class="fc" id="L916">                sub.onNext(2);</span>
<span class="fc" id="L917">                sub.onNext(1);</span>
<span class="fc" id="L918">                sub.onNext(2);</span>
<span class="fc" id="L919">                sub.onComplete();</span>
<span class="fc" id="L920">            }</span>

<span class="fc" id="L922">        }).groupBy(new Function&lt;Integer, Integer&gt;() {</span>

            @Override
            public Integer apply(Integer t) {
<span class="fc" id="L926">                return t;</span>
            }

<span class="fc" id="L929">        }).flatMap(new Function&lt;GroupedFlowable&lt;Integer, Integer&gt;, Flowable&lt;String&gt;&gt;() {</span>

            @Override
            public Flowable&lt;String&gt; apply(final GroupedFlowable&lt;Integer, Integer&gt; group) {
<span class="fc" id="L933">                return group.observeOn(Schedulers.newThread()).delay(400, TimeUnit.MILLISECONDS).map(new Function&lt;Integer, String&gt;() {</span>

                    @Override
                    public String apply(Integer t1) {
<span class="fc" id="L937">                        return &quot;first groups: &quot; + t1;</span>
                    }

                });
            }

<span class="fc" id="L943">        }).blockingForEach(new Consumer&lt;String&gt;() {</span>

            @Override
            public void accept(String s) {
<span class="fc" id="L947">                results.add(s);</span>
<span class="fc" id="L948">            }</span>

        });

<span class="fc" id="L952">        System.out.println(&quot;Results: &quot; + results);</span>
<span class="fc" id="L953">        assertEquals(4, results.size());</span>
<span class="fc" id="L954">    }</span>

    private static class Event {
        int source;
        String message;

        @Override
        public String toString() {
<span class="nc" id="L962">            return &quot;Event =&gt; source: &quot; + source + &quot; message: &quot; + message;</span>
        }
    }

    Flowable&lt;Event&gt; ASYNC_INFINITE_OBSERVABLE_OF_EVENT(final int numGroups, final AtomicInteger subscribeCounter, final AtomicInteger sentEventCounter) {
<span class="fc" id="L967">        return SYNC_INFINITE_OBSERVABLE_OF_EVENT(numGroups, subscribeCounter, sentEventCounter).subscribeOn(Schedulers.newThread());</span>
    };

    Flowable&lt;Event&gt; SYNC_INFINITE_OBSERVABLE_OF_EVENT(final int numGroups, final AtomicInteger subscribeCounter, final AtomicInteger sentEventCounter) {
<span class="fc" id="L971">        return Flowable.unsafeCreate(new Publisher&lt;Event&gt;() {</span>

            @Override
            public void subscribe(final Subscriber&lt;? super Event&gt; op) {
<span class="fc" id="L975">                BooleanSubscription bs = new BooleanSubscription();</span>
<span class="fc" id="L976">                op.onSubscribe(bs);</span>
<span class="fc" id="L977">                subscribeCounter.incrementAndGet();</span>
<span class="fc" id="L978">                int i = 0;</span>
<span class="fc bfc" id="L979" title="All 2 branches covered.">                while (!bs.isCancelled()) {</span>
<span class="fc" id="L980">                    i++;</span>
<span class="fc" id="L981">                    Event e = new Event();</span>
<span class="fc" id="L982">                    e.source = i % numGroups;</span>
<span class="fc" id="L983">                    e.message = &quot;Event-&quot; + i;</span>
<span class="fc" id="L984">                    op.onNext(e);</span>
<span class="fc" id="L985">                    sentEventCounter.incrementAndGet();</span>
<span class="fc" id="L986">                }</span>
<span class="fc" id="L987">                op.onComplete();</span>
<span class="fc" id="L988">            }</span>

        });
    };

    @Test
    public void testGroupByOnAsynchronousSourceAcceptsMultipleSubscriptions() throws InterruptedException {

        // choose an asynchronous source
<span class="fc" id="L997">        Flowable&lt;Long&gt; source = Flowable.interval(10, TimeUnit.MILLISECONDS).take(1);</span>

        // apply groupBy to the source
<span class="fc" id="L1000">        Flowable&lt;GroupedFlowable&lt;Boolean, Long&gt;&gt; stream = source.groupBy(IS_EVEN);</span>

        // create two observers
<span class="fc" id="L1003">        Subscriber&lt;GroupedFlowable&lt;Boolean, Long&gt;&gt; f1 = TestHelper.mockSubscriber();</span>
<span class="fc" id="L1004">        Subscriber&lt;GroupedFlowable&lt;Boolean, Long&gt;&gt; f2 = TestHelper.mockSubscriber();</span>

        // subscribe with the observers
<span class="fc" id="L1007">        stream.subscribe(f1);</span>
<span class="fc" id="L1008">        stream.subscribe(f2);</span>

        // check that subscriptions were successful
<span class="fc" id="L1011">        verify(f1, never()).onError(Mockito.&lt;Throwable&gt; any());</span>
<span class="fc" id="L1012">        verify(f2, never()).onError(Mockito.&lt;Throwable&gt; any());</span>
<span class="fc" id="L1013">    }</span>

<span class="fc" id="L1015">    private static Function&lt;Long, Boolean&gt; IS_EVEN = new Function&lt;Long, Boolean&gt;() {</span>

        @Override
        public Boolean apply(Long n) {
<span class="pc bpc" id="L1019" title="1 of 2 branches missed.">            return n % 2 == 0;</span>
        }
    };

<span class="fc" id="L1023">    private static Function&lt;Integer, Boolean&gt; IS_EVEN2 = new Function&lt;Integer, Boolean&gt;() {</span>

        @Override
        public Boolean apply(Integer n) {
<span class="fc bfc" id="L1027" title="All 2 branches covered.">            return n % 2 == 0;</span>
        }
    };

    @Test
    public void testGroupByBackpressure() throws InterruptedException {

<span class="fc" id="L1034">        TestSubscriber&lt;String&gt; ts = new TestSubscriber&lt;String&gt;();</span>

<span class="fc" id="L1036">        Flowable.range(1, 4000)</span>
<span class="fc" id="L1037">                .groupBy(IS_EVEN2)</span>
<span class="fc" id="L1038">                .flatMap(new Function&lt;GroupedFlowable&lt;Boolean, Integer&gt;, Flowable&lt;String&gt;&gt;() {</span>

                    @Override
                    public Flowable&lt;String&gt; apply(final GroupedFlowable&lt;Boolean, Integer&gt; g) {
<span class="fc" id="L1042">                        return g.observeOn(Schedulers.computation()).map(new Function&lt;Integer, String&gt;() {</span>

                            @Override
                            public String apply(Integer l) {
<span class="fc bfc" id="L1046" title="All 2 branches covered.">                                if (g.getKey()) {</span>
                                    try {
<span class="fc" id="L1048">                                        Thread.sleep(1);</span>
<span class="nc" id="L1049">                                    } catch (InterruptedException e) {</span>
<span class="fc" id="L1050">                                    }</span>
<span class="fc" id="L1051">                                    return l + &quot; is even.&quot;;</span>
                                } else {
<span class="fc" id="L1053">                                    return l + &quot; is odd.&quot;;</span>
                                }
                            }

                        });
                    }

<span class="fc" id="L1060">                }).subscribe(ts);</span>
<span class="fc" id="L1061">        ts.awaitTerminalEvent();</span>
<span class="fc" id="L1062">        ts.assertNoErrors();</span>
<span class="fc" id="L1063">    }</span>

    &lt;T, R&gt; Function&lt;T, R&gt; just(final R value) {
<span class="nc" id="L1066">        return new Function&lt;T, R&gt;() {</span>
            @Override
            public R apply(T t1) {
<span class="nc" id="L1069">                return value;</span>
            }
        };
    }

    &lt;T&gt; Function&lt;Integer, T&gt; fail(T dummy) {
<span class="fc" id="L1075">        return new Function&lt;Integer, T&gt;() {</span>
            @Override
            public T apply(Integer t1) {
<span class="fc" id="L1078">                throw new RuntimeException(&quot;Forced failure&quot;);</span>
            }
        };
    }

    &lt;T, R&gt; Function&lt;T, R&gt; fail2(R dummy2) {
<span class="nc" id="L1084">        return new Function&lt;T, R&gt;() {</span>
            @Override
            public R apply(T t1) {
<span class="nc" id="L1087">                throw new RuntimeException(&quot;Forced failure&quot;);</span>
            }
        };
    }

<span class="fc" id="L1092">    Function&lt;Integer, Integer&gt; dbl = new Function&lt;Integer, Integer&gt;() {</span>
        @Override
        public Integer apply(Integer t1) {
<span class="fc" id="L1095">            return t1 * 2;</span>
        }
    };
<span class="fc" id="L1098">    Function&lt;Integer, Integer&gt; identity = new Function&lt;Integer, Integer&gt;() {</span>
        @Override
        public Integer apply(Integer v) {
<span class="fc" id="L1101">            return v;</span>
        }
    };

    @Test
    public void normalBehavior() {
<span class="fc" id="L1107">        Flowable&lt;String&gt; source = Flowable.fromIterable(Arrays.asList(</span>
                &quot;  foo&quot;,
                &quot; FoO &quot;,
                &quot;baR  &quot;,
                &quot;foO &quot;,
                &quot; Baz   &quot;,
                &quot;  qux &quot;,
                &quot;   bar&quot;,
                &quot; BAR  &quot;,
                &quot;FOO &quot;,
                &quot;baz  &quot;,
                &quot; bAZ &quot;,
                &quot;    fOo    &quot;
                ));

        /*
         * foo FoO foO FOO fOo
         * baR bar BAR
         * Baz baz bAZ
         * qux
         *
         */
<span class="fc" id="L1129">        Function&lt;String, String&gt; keysel = new Function&lt;String, String&gt;() {</span>
            @Override
            public String apply(String t1) {
<span class="fc" id="L1132">                return t1.trim().toLowerCase();</span>
            }
        };
<span class="fc" id="L1135">        Function&lt;String, String&gt; valuesel = new Function&lt;String, String&gt;() {</span>
            @Override
            public String apply(String t1) {
<span class="fc" id="L1138">                return t1 + t1;</span>
            }
        };

<span class="fc" id="L1142">        Flowable&lt;String&gt; m = source.groupBy(keysel, valuesel)</span>
<span class="fc" id="L1143">        .flatMap(new Function&lt;GroupedFlowable&lt;String, String&gt;, Publisher&lt;String&gt;&gt;() {</span>
            @Override
            public Publisher&lt;String&gt; apply(final GroupedFlowable&lt;String, String&gt; g) {
<span class="fc" id="L1146">                System.out.println(&quot;-----------&gt; NEXT: &quot; + g.getKey());</span>
<span class="fc" id="L1147">                return g.take(2).map(new Function&lt;String, String&gt;() {</span>

                    int count;

                    @Override
                    public String apply(String v) {
<span class="fc" id="L1153">                        System.out.println(v);</span>
<span class="fc" id="L1154">                        return g.getKey() + &quot;-&quot; + count++;</span>
                    }

                });
            }
        });

<span class="fc" id="L1161">        TestSubscriber&lt;String&gt; ts = new TestSubscriber&lt;String&gt;();</span>
<span class="fc" id="L1162">        m.subscribe(ts);</span>
<span class="fc" id="L1163">        ts.awaitTerminalEvent();</span>
<span class="fc" id="L1164">        System.out.println(&quot;ts .get &quot; + ts.values());</span>
<span class="fc" id="L1165">        ts.assertNoErrors();</span>
<span class="fc" id="L1166">        assertEquals(ts.values(),</span>
<span class="fc" id="L1167">                Arrays.asList(&quot;foo-0&quot;, &quot;foo-1&quot;, &quot;bar-0&quot;, &quot;foo-0&quot;, &quot;baz-0&quot;, &quot;qux-0&quot;, &quot;bar-1&quot;, &quot;bar-0&quot;, &quot;foo-1&quot;, &quot;baz-1&quot;, &quot;baz-0&quot;, &quot;foo-0&quot;));</span>

<span class="fc" id="L1169">    }</span>

    @Test
    public void keySelectorThrows() {
<span class="fc" id="L1173">        Flowable&lt;Integer&gt; source = Flowable.just(0, 1, 2, 3, 4, 5, 6);</span>

<span class="fc" id="L1175">        Flowable&lt;Integer&gt; m = source.groupBy(fail(0), dbl).flatMap(FLATTEN_INTEGER);</span>

<span class="fc" id="L1177">        TestSubscriber&lt;Integer&gt; ts = new TestSubscriber&lt;Integer&gt;();</span>
<span class="fc" id="L1178">        m.subscribe(ts);</span>
<span class="fc" id="L1179">        ts.awaitTerminalEvent();</span>
<span class="fc" id="L1180">        assertEquals(1, ts.errorCount());</span>
<span class="fc" id="L1181">        ts.assertNoValues();</span>
<span class="fc" id="L1182">    }</span>

    @Test
    public void valueSelectorThrows() {
<span class="fc" id="L1186">        Flowable&lt;Integer&gt; source = Flowable.just(0, 1, 2, 3, 4, 5, 6);</span>

<span class="fc" id="L1188">        Flowable&lt;Integer&gt; m = source.groupBy(identity, fail(0)).flatMap(FLATTEN_INTEGER);</span>
<span class="fc" id="L1189">        TestSubscriber&lt;Integer&gt; ts = new TestSubscriber&lt;Integer&gt;();</span>
<span class="fc" id="L1190">        m.subscribe(ts);</span>
<span class="fc" id="L1191">        ts.awaitTerminalEvent();</span>
<span class="fc" id="L1192">        assertEquals(1, ts.errorCount());</span>
<span class="fc" id="L1193">        ts.assertNoValues();</span>

<span class="fc" id="L1195">    }</span>

    @Test
    public void innerEscapeCompleted() {
<span class="fc" id="L1199">        Flowable&lt;Integer&gt; source = Flowable.just(0);</span>

<span class="fc" id="L1201">        Flowable&lt;Integer&gt; m = source.groupBy(identity, dbl).flatMap(FLATTEN_INTEGER);</span>

<span class="fc" id="L1203">        TestSubscriber&lt;Object&gt; ts = new TestSubscriber&lt;Object&gt;();</span>
<span class="fc" id="L1204">        m.subscribe(ts);</span>
<span class="fc" id="L1205">        ts.awaitTerminalEvent();</span>
<span class="fc" id="L1206">        ts.assertNoErrors();</span>
<span class="fc" id="L1207">        System.out.println(ts.values());</span>
<span class="fc" id="L1208">    }</span>

    /**
     * Assert we get an IllegalStateException if trying to subscribe to an inner GroupedFlowable more than once.
     */
    @Test
    public void testExceptionIfSubscribeToChildMoreThanOnce() {
<span class="fc" id="L1215">        Flowable&lt;Integer&gt; source = Flowable.just(0);</span>

<span class="fc" id="L1217">        final AtomicReference&lt;GroupedFlowable&lt;Integer, Integer&gt;&gt; inner = new AtomicReference&lt;GroupedFlowable&lt;Integer, Integer&gt;&gt;();</span>

<span class="fc" id="L1219">        Flowable&lt;GroupedFlowable&lt;Integer, Integer&gt;&gt; m = source.groupBy(identity, dbl);</span>

<span class="fc" id="L1221">        m.subscribe(new Consumer&lt;GroupedFlowable&lt;Integer, Integer&gt;&gt;() {</span>
            @Override
            public void accept(GroupedFlowable&lt;Integer, Integer&gt; t1) {
<span class="fc" id="L1224">                inner.set(t1);</span>
<span class="fc" id="L1225">            }</span>
        });

<span class="fc" id="L1228">        inner.get().subscribe();</span>

<span class="fc" id="L1230">        Subscriber&lt;Integer&gt; subscriber2 = TestHelper.mockSubscriber();</span>

<span class="fc" id="L1232">        inner.get().subscribe(subscriber2);</span>

<span class="fc" id="L1234">        verify(subscriber2, never()).onComplete();</span>
<span class="fc" id="L1235">        verify(subscriber2, never()).onNext(anyInt());</span>
<span class="fc" id="L1236">        verify(subscriber2).onError(any(IllegalStateException.class));</span>
<span class="fc" id="L1237">    }</span>

    @Test
    public void testError2() {
<span class="fc" id="L1241">        Flowable&lt;Integer&gt; source = Flowable.concat(Flowable.just(0),</span>
<span class="fc" id="L1242">                Flowable.&lt;Integer&gt; error(new TestException(&quot;Forced failure&quot;)));</span>

<span class="fc" id="L1244">        Flowable&lt;Integer&gt; m = source.groupBy(identity, dbl).flatMap(FLATTEN_INTEGER);</span>

<span class="fc" id="L1246">        TestSubscriber&lt;Object&gt; ts = new TestSubscriber&lt;Object&gt;();</span>
<span class="fc" id="L1247">        m.subscribe(ts);</span>
<span class="fc" id="L1248">        ts.awaitTerminalEvent();</span>
<span class="fc" id="L1249">        assertEquals(1, ts.errorCount());</span>
<span class="fc" id="L1250">        ts.assertValueCount(1);</span>
<span class="fc" id="L1251">    }</span>

    @Test
    public void testgroupByBackpressure() throws InterruptedException {
<span class="fc" id="L1255">        TestSubscriber&lt;String&gt; ts = new TestSubscriber&lt;String&gt;();</span>

<span class="fc" id="L1257">        Flowable.range(1, 4000).groupBy(IS_EVEN2).flatMap(new Function&lt;GroupedFlowable&lt;Boolean, Integer&gt;, Flowable&lt;String&gt;&gt;() {</span>

            @Override
            public Flowable&lt;String&gt; apply(final GroupedFlowable&lt;Boolean, Integer&gt; g) {
<span class="fc" id="L1261">                return g.doOnComplete(new Action() {</span>

                    @Override
                    public void run() {
<span class="fc" id="L1265">                        System.out.println(&quot;//////////////////// COMPLETED-A&quot;);</span>
<span class="fc" id="L1266">                    }</span>

<span class="fc" id="L1268">                }).observeOn(Schedulers.computation()).map(new Function&lt;Integer, String&gt;() {</span>

                    int c;

                    @Override
                    public String apply(Integer l) {
<span class="fc bfc" id="L1274" title="All 2 branches covered.">                        if (g.getKey()) {</span>
<span class="fc bfc" id="L1275" title="All 2 branches covered.">                            if (c++ &lt; 400) {</span>
                                try {
<span class="fc" id="L1277">                                    Thread.sleep(1);</span>
<span class="nc" id="L1278">                                } catch (InterruptedException e) {</span>
<span class="fc" id="L1279">                                }</span>
                            }
<span class="fc" id="L1281">                            return l + &quot; is even.&quot;;</span>
                        } else {
<span class="fc" id="L1283">                            return l + &quot; is odd.&quot;;</span>
                        }
                    }

<span class="fc" id="L1287">                }).doOnComplete(new Action() {</span>

                    @Override
                    public void run() {
<span class="fc" id="L1291">                        System.out.println(&quot;//////////////////// COMPLETED-B&quot;);</span>
<span class="fc" id="L1292">                    }</span>

                });
            }

<span class="fc" id="L1297">        }).doOnEach(new Consumer&lt;Notification&lt;String&gt;&gt;() {</span>

            @Override
            public void accept(Notification&lt;String&gt; t1) {
<span class="fc" id="L1301">                System.out.println(&quot;NEXT: &quot; + t1);</span>
<span class="fc" id="L1302">            }</span>

<span class="fc" id="L1304">        }).subscribe(ts);</span>
<span class="fc" id="L1305">        ts.awaitTerminalEvent();</span>
<span class="fc" id="L1306">        ts.assertNoErrors();</span>
<span class="fc" id="L1307">    }</span>

    @Test
    public void testgroupByBackpressure2() throws InterruptedException {

<span class="fc" id="L1312">        TestSubscriber&lt;String&gt; ts = new TestSubscriber&lt;String&gt;();</span>

<span class="fc" id="L1314">        Flowable.range(1, 4000)</span>
<span class="fc" id="L1315">            .doOnNext(new Consumer&lt;Integer&gt;() {</span>
                @Override
                public void accept(Integer v) {
<span class="fc" id="L1318">                    System.out.println(&quot;testgroupByBackpressure2 &gt;&gt; &quot; + v);</span>
<span class="fc" id="L1319">                }</span>
            })
<span class="fc" id="L1321">            .groupBy(IS_EVEN2).flatMap(new Function&lt;GroupedFlowable&lt;Boolean, Integer&gt;, Flowable&lt;String&gt;&gt;() {</span>

            @Override
            public Flowable&lt;String&gt; apply(final GroupedFlowable&lt;Boolean, Integer&gt; g) {
<span class="fc" id="L1325">                return g.take(2).observeOn(Schedulers.computation()).map(new Function&lt;Integer, String&gt;() {</span>

                    @Override
                    public String apply(Integer l) {
<span class="fc bfc" id="L1329" title="All 2 branches covered.">                        if (g.getKey()) {</span>
                            try {
<span class="fc" id="L1331">                                Thread.sleep(1);</span>
<span class="nc" id="L1332">                            } catch (InterruptedException e) {</span>
<span class="fc" id="L1333">                            }</span>
<span class="fc" id="L1334">                            return l + &quot; is even.&quot;;</span>
                        } else {
<span class="fc" id="L1336">                            return l + &quot; is odd.&quot;;</span>
                        }
                    }

                });
            }

<span class="fc" id="L1343">        }).subscribe(ts);</span>
<span class="fc" id="L1344">        ts.awaitTerminalEvent();</span>
<span class="fc" id="L1345">        ts.assertNoErrors();</span>
<span class="fc" id="L1346">    }</span>

<span class="fc" id="L1348">    static Function&lt;GroupedFlowable&lt;Integer, Integer&gt;, Flowable&lt;Integer&gt;&gt; FLATTEN_INTEGER = new Function&lt;GroupedFlowable&lt;Integer, Integer&gt;, Flowable&lt;Integer&gt;&gt;() {</span>

        @Override
        public Flowable&lt;Integer&gt; apply(GroupedFlowable&lt;Integer, Integer&gt; t) {
<span class="fc" id="L1352">            return t;</span>
        }

    };

    @Test
    public void testGroupByWithNullKey() {
<span class="fc" id="L1359">        final String[] key = new String[]{&quot;uninitialized&quot;};</span>
<span class="fc" id="L1360">        final List&lt;String&gt; values = new ArrayList&lt;String&gt;();</span>
<span class="fc" id="L1361">        Flowable.just(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;).groupBy(new Function&lt;String, String&gt;() {</span>

            @Override
            public String apply(String value) {
<span class="fc" id="L1365">                return null;</span>
            }
<span class="fc" id="L1367">        }).subscribe(new Consumer&lt;GroupedFlowable&lt;String, String&gt;&gt;() {</span>

            @Override
            public void accept(GroupedFlowable&lt;String, String&gt; groupedFlowable) {
<span class="fc" id="L1371">                key[0] = groupedFlowable.getKey();</span>
<span class="fc" id="L1372">                groupedFlowable.subscribe(new Consumer&lt;String&gt;() {</span>

                    @Override
                    public void accept(String s) {
<span class="fc" id="L1376">                        values.add(s);</span>
<span class="fc" id="L1377">                    }</span>
                });
<span class="fc" id="L1379">            }</span>
        });
<span class="fc" id="L1381">        assertEquals(null, key[0]);</span>
<span class="fc" id="L1382">        assertEquals(Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), values);</span>
<span class="fc" id="L1383">    }</span>

    @Test
    public void testGroupByUnsubscribe() {
<span class="fc" id="L1387">        final Subscription s = mock(Subscription.class);</span>
<span class="fc" id="L1388">        Flowable&lt;Integer&gt; f = Flowable.unsafeCreate(</span>
<span class="fc" id="L1389">                new Publisher&lt;Integer&gt;() {</span>
                    @Override
                    public void subscribe(Subscriber&lt;? super Integer&gt; subscriber) {
<span class="fc" id="L1392">                        subscriber.onSubscribe(s);</span>
<span class="fc" id="L1393">                    }</span>
                }
        );
<span class="fc" id="L1396">        TestSubscriber&lt;Object&gt; ts = new TestSubscriber&lt;Object&gt;();</span>

<span class="fc" id="L1398">        f.groupBy(new Function&lt;Integer, Integer&gt;() {</span>

            @Override
            public Integer apply(Integer integer) {
<span class="nc" id="L1402">                return null;</span>
            }
<span class="fc" id="L1404">        }).subscribe(ts);</span>

<span class="fc" id="L1406">        ts.dispose();</span>

<span class="fc" id="L1408">        verify(s).cancel();</span>
<span class="fc" id="L1409">    }</span>

    @Test
    public void testGroupByShouldPropagateError() {
<span class="fc" id="L1413">        final Throwable e = new RuntimeException(&quot;Oops&quot;);</span>
<span class="fc" id="L1414">        final TestSubscriber&lt;Integer&gt; inner1 = new TestSubscriber&lt;Integer&gt;();</span>
<span class="fc" id="L1415">        final TestSubscriber&lt;Integer&gt; inner2 = new TestSubscriber&lt;Integer&gt;();</span>

<span class="fc" id="L1417">        final TestSubscriber&lt;GroupedFlowable&lt;Integer, Integer&gt;&gt; outer</span>
<span class="fc" id="L1418">                = new TestSubscriber&lt;GroupedFlowable&lt;Integer, Integer&gt;&gt;(new DefaultSubscriber&lt;GroupedFlowable&lt;Integer, Integer&gt;&gt;() {</span>

            @Override
            public void onComplete() {
<span class="nc" id="L1422">            }</span>

            @Override
            public void onError(Throwable e) {
<span class="fc" id="L1426">            }</span>

            @Override
            public void onNext(GroupedFlowable&lt;Integer, Integer&gt; f) {
<span class="fc bfc" id="L1430" title="All 2 branches covered.">                if (f.getKey() == 0) {</span>
<span class="fc" id="L1431">                    f.subscribe(inner1);</span>
                } else {
<span class="fc" id="L1433">                    f.subscribe(inner2);</span>
                }
<span class="fc" id="L1435">            }</span>
        });
<span class="fc" id="L1437">        Flowable.unsafeCreate(</span>
<span class="fc" id="L1438">                new Publisher&lt;Integer&gt;() {</span>
                    @Override
                    public void subscribe(Subscriber&lt;? super Integer&gt; subscriber) {
<span class="fc" id="L1441">                        subscriber.onSubscribe(new BooleanSubscription());</span>
<span class="fc" id="L1442">                        subscriber.onNext(0);</span>
<span class="fc" id="L1443">                        subscriber.onNext(1);</span>
<span class="fc" id="L1444">                        subscriber.onError(e);</span>
<span class="fc" id="L1445">                    }</span>
                }
<span class="fc" id="L1447">        ).groupBy(new Function&lt;Integer, Integer&gt;() {</span>

            @Override
            public Integer apply(Integer i) {
<span class="fc" id="L1451">                return i % 2;</span>
            }
<span class="fc" id="L1453">        }).subscribe(outer);</span>
<span class="fc" id="L1454">        assertEquals(Arrays.asList(e), outer.errors());</span>
<span class="fc" id="L1455">        assertEquals(Arrays.asList(e), inner1.errors());</span>
<span class="fc" id="L1456">        assertEquals(Arrays.asList(e), inner2.errors());</span>
<span class="fc" id="L1457">    }</span>

    @Test
    public void testRequestOverflow() {
<span class="fc" id="L1461">        final AtomicBoolean completed = new AtomicBoolean(false);</span>
<span class="fc" id="L1462">        Flowable</span>
<span class="fc" id="L1463">                .just(1, 2, 3)</span>
                // group into one group
<span class="fc" id="L1465">                .groupBy(new Function&lt;Integer, Integer&gt;() {</span>
                    @Override
                    public Integer apply(Integer t) {
<span class="fc" id="L1468">                        return 1;</span>
                    }
                })
                // flatten
<span class="fc" id="L1472">                .concatMap(new Function&lt;GroupedFlowable&lt;Integer, Integer&gt;, Flowable&lt;Integer&gt;&gt;() {</span>
                    @Override
                    public Flowable&lt;Integer&gt; apply(GroupedFlowable&lt;Integer, Integer&gt; g) {
<span class="fc" id="L1475">                        return g;</span>
                    }
                })
<span class="fc" id="L1478">                .subscribe(new DefaultSubscriber&lt;Integer&gt;() {</span>

                    @Override
                    public void onStart() {
<span class="fc" id="L1482">                        request(2);</span>
<span class="fc" id="L1483">                    }</span>

                    @Override
                    public void onComplete() {
<span class="fc" id="L1487">                        completed.set(true);</span>

<span class="fc" id="L1489">                    }</span>

                    @Override
                    public void onError(Throwable e) {

<span class="nc" id="L1494">                    }</span>

                    @Override
                    public void onNext(Integer t) {
<span class="fc" id="L1498">                        System.out.println(t);</span>
                        //provoke possible request overflow
<span class="fc" id="L1500">                        request(Long.MAX_VALUE - 1);</span>
<span class="fc" id="L1501">                    }});</span>
<span class="fc" id="L1502">        assertTrue(completed.get());</span>
<span class="fc" id="L1503">    }</span>

    /**
     * Issue #3425.
     *
     * The problem is that a request of 1 may create a new group, emit to the desired group
     * or emit to a completely different group. In this test, the merge requests N which
     * must be produced by the range, however it will create a bunch of groups before the actual
     * group receives a value.
     */
    @Test
    public void testBackpressureObserveOnOuter() {
<span class="fc bfc" id="L1515" title="All 2 branches covered.">        for (int j = 0; j &lt; 1000; j++) {</span>
<span class="fc" id="L1516">            Flowable.merge(</span>
<span class="fc" id="L1517">                    Flowable.range(0, 500)</span>
<span class="fc" id="L1518">                    .groupBy(new Function&lt;Integer, Object&gt;() {</span>
                        @Override
                        public Object apply(Integer i) {
<span class="fc" id="L1521">                            return i % (Flowable.bufferSize() + 2);</span>
                        }
                    })
<span class="fc" id="L1524">                    .observeOn(Schedulers.computation())</span>
<span class="fc" id="L1525">            ).blockingLast();</span>
        }
<span class="fc" id="L1527">    }</span>

    /**
     * Synchronous verification of issue #3425.
     */
    @Test
    public void testBackpressureInnerDoesntOverflowOuter() {
<span class="fc" id="L1534">        TestSubscriber&lt;GroupedFlowable&lt;Integer, Integer&gt;&gt; ts = new TestSubscriber&lt;GroupedFlowable&lt;Integer, Integer&gt;&gt;(0L);</span>

<span class="fc" id="L1536">        Flowable.fromArray(1, 2)</span>
<span class="fc" id="L1537">                .groupBy(new Function&lt;Integer, Integer&gt;() {</span>
                    @Override
                    public Integer apply(Integer v) {
<span class="fc" id="L1540">                        return v;</span>
                    }
                })
<span class="fc" id="L1543">                .doOnNext(new Consumer&lt;GroupedFlowable&lt;Integer, Integer&gt;&gt;() {</span>
                    @Override
                    public void accept(GroupedFlowable&lt;Integer, Integer&gt; g) {
<span class="fc" id="L1546">                        g.subscribe();</span>
<span class="fc" id="L1547">                    }</span>
                }) // this will request Long.MAX_VALUE
<span class="fc" id="L1549">                .subscribe(ts)</span>
                ;
<span class="fc" id="L1551">        ts.request(1);</span>

<span class="fc" id="L1553">        ts.assertNotComplete();</span>
<span class="fc" id="L1554">        ts.assertNoErrors();</span>
<span class="fc" id="L1555">        ts.assertValueCount(1);</span>
<span class="fc" id="L1556">    }</span>

    @Test
    public void testOneGroupInnerRequestsTwiceBuffer() {
<span class="fc" id="L1560">        TestSubscriber&lt;Object&gt; ts1 = new TestSubscriber&lt;Object&gt;(0L);</span>
<span class="fc" id="L1561">        final TestSubscriber&lt;Object&gt; ts2 = new TestSubscriber&lt;Object&gt;(0L);</span>

<span class="fc" id="L1563">        Flowable.range(1, Flowable.bufferSize() * 2)</span>
<span class="fc" id="L1564">        .groupBy(new Function&lt;Integer, Object&gt;() {</span>
            @Override
            public Object apply(Integer v) {
<span class="fc" id="L1567">                return 1;</span>
            }
        })
<span class="fc" id="L1570">        .doOnNext(new Consumer&lt;GroupedFlowable&lt;Object, Integer&gt;&gt;() {</span>
            @Override
            public void accept(GroupedFlowable&lt;Object, Integer&gt; g) {
<span class="fc" id="L1573">                g.subscribe(ts2);</span>
<span class="fc" id="L1574">            }</span>
        })
<span class="fc" id="L1576">        .subscribe(ts1);</span>

<span class="fc" id="L1578">        ts1.assertNoValues();</span>
<span class="fc" id="L1579">        ts1.assertNoErrors();</span>
<span class="fc" id="L1580">        ts1.assertNotComplete();</span>

<span class="fc" id="L1582">        ts2.assertNoValues();</span>
<span class="fc" id="L1583">        ts2.assertNoErrors();</span>
<span class="fc" id="L1584">        ts2.assertNotComplete();</span>

<span class="fc" id="L1586">        ts1.request(1);</span>

<span class="fc" id="L1588">        ts1.assertValueCount(1);</span>
<span class="fc" id="L1589">        ts1.assertNoErrors();</span>
<span class="fc" id="L1590">        ts1.assertNotComplete();</span>

<span class="fc" id="L1592">        ts2.assertNoValues();</span>
<span class="fc" id="L1593">        ts2.assertNoErrors();</span>
<span class="fc" id="L1594">        ts2.assertNotComplete();</span>

<span class="fc" id="L1596">        ts2.request(Flowable.bufferSize() * 2);</span>

<span class="fc" id="L1598">        ts2.assertValueCount(Flowable.bufferSize() * 2);</span>
<span class="fc" id="L1599">        ts2.assertNoErrors();</span>
<span class="fc" id="L1600">        ts2.assertComplete();</span>
<span class="fc" id="L1601">    }</span>

    @Test
    public void outerInnerFusion() {
<span class="fc" id="L1605">        final TestSubscriber&lt;Integer&gt; ts1 = SubscriberFusion.newTest(QueueFuseable.ANY);</span>

<span class="fc" id="L1607">        final TestSubscriber&lt;GroupedFlowable&lt;Integer, Integer&gt;&gt; ts2 = SubscriberFusion.newTest(QueueFuseable.ANY);</span>

<span class="fc" id="L1609">        Flowable.range(1, 10).groupBy(new Function&lt;Integer, Integer&gt;() {</span>
            @Override
            public Integer apply(Integer v) {
<span class="fc" id="L1612">                return 1;</span>
            }
<span class="fc" id="L1614">        }, new Function&lt;Integer, Integer&gt;() {</span>
            @Override
            public Integer apply(Integer v) {
<span class="fc" id="L1617">                return v + 1;</span>
            }
        })
<span class="fc" id="L1620">        .doOnNext(new Consumer&lt;GroupedFlowable&lt;Integer, Integer&gt;&gt;() {</span>
            @Override
            public void accept(GroupedFlowable&lt;Integer, Integer&gt; g) {
<span class="fc" id="L1623">                g.subscribe(ts1);</span>
<span class="fc" id="L1624">            }</span>
        })
<span class="fc" id="L1626">        .subscribe(ts2);</span>

<span class="fc" id="L1628">        ts1</span>
<span class="fc" id="L1629">        .assertOf(SubscriberFusion.&lt;Integer&gt;assertFusionMode(QueueFuseable.ASYNC))</span>
<span class="fc" id="L1630">        .assertValues(2, 3, 4, 5, 6, 7, 8, 9, 10, 11)</span>
<span class="fc" id="L1631">        .assertNoErrors()</span>
<span class="fc" id="L1632">        .assertComplete();</span>

<span class="fc" id="L1634">        ts2</span>
<span class="fc" id="L1635">        .assertOf(SubscriberFusion.&lt;GroupedFlowable&lt;Integer, Integer&gt;&gt;assertFusionMode(QueueFuseable.ASYNC))</span>
<span class="fc" id="L1636">        .assertValueCount(1)</span>
<span class="fc" id="L1637">        .assertNoErrors()</span>
<span class="fc" id="L1638">        .assertComplete();</span>
<span class="fc" id="L1639">    }</span>

    @Test
    public void keySelectorAndDelayError() {
<span class="fc" id="L1643">        Flowable.just(1).concatWith(Flowable.&lt;Integer&gt;error(new TestException()))</span>
<span class="fc" id="L1644">        .groupBy(Functions.&lt;Integer&gt;identity(), true)</span>
<span class="fc" id="L1645">        .flatMap(new Function&lt;GroupedFlowable&lt;Integer, Integer&gt;, Flowable&lt;Integer&gt;&gt;() {</span>
            @Override
            public Flowable&lt;Integer&gt; apply(GroupedFlowable&lt;Integer, Integer&gt; g) throws Exception {
<span class="fc" id="L1648">                return g;</span>
            }
        })
<span class="fc" id="L1651">        .test()</span>
<span class="fc" id="L1652">        .assertFailure(TestException.class, 1);</span>
<span class="fc" id="L1653">    }</span>

    @Test
    public void keyAndValueSelectorAndDelayError() {
<span class="fc" id="L1657">        Flowable.just(1).concatWith(Flowable.&lt;Integer&gt;error(new TestException()))</span>
<span class="fc" id="L1658">        .groupBy(Functions.&lt;Integer&gt;identity(), Functions.&lt;Integer&gt;identity(), true)</span>
<span class="fc" id="L1659">        .flatMap(new Function&lt;GroupedFlowable&lt;Integer, Integer&gt;, Flowable&lt;Integer&gt;&gt;() {</span>
            @Override
            public Flowable&lt;Integer&gt; apply(GroupedFlowable&lt;Integer, Integer&gt; g) throws Exception {
<span class="fc" id="L1662">                return g;</span>
            }
        })
<span class="fc" id="L1665">        .test()</span>
<span class="fc" id="L1666">        .assertFailure(TestException.class, 1);</span>
<span class="fc" id="L1667">    }</span>

    @Test
    public void dispose() {
<span class="fc" id="L1671">        TestHelper.checkDisposed(Flowable.just(1).groupBy(Functions.justFunction(1)));</span>

<span class="fc" id="L1673">        Flowable.just(1)</span>
<span class="fc" id="L1674">        .groupBy(Functions.justFunction(1))</span>
<span class="fc" id="L1675">        .doOnNext(new Consumer&lt;GroupedFlowable&lt;Integer, Integer&gt;&gt;() {</span>
            @Override
            public void accept(GroupedFlowable&lt;Integer, Integer&gt; g) throws Exception {
<span class="fc" id="L1678">                TestHelper.checkDisposed(g);</span>
<span class="fc" id="L1679">            }</span>
        })
<span class="fc" id="L1681">        .test();</span>
<span class="fc" id="L1682">    }</span>

    @Test
    public void reentrantComplete() {
<span class="fc" id="L1686">        final PublishProcessor&lt;Integer&gt; pp = PublishProcessor.create();</span>

<span class="fc" id="L1688">        TestSubscriber&lt;Integer&gt; ts = new TestSubscriber&lt;Integer&gt;() {</span>
            @Override
            public void onNext(Integer t) {
<span class="fc" id="L1691">                super.onNext(t);</span>
<span class="pc bpc" id="L1692" title="1 of 2 branches missed.">                if (t == 1) {</span>
<span class="fc" id="L1693">                    pp.onComplete();</span>
                }
<span class="fc" id="L1695">            }</span>
        };

<span class="fc" id="L1698">        Flowable.merge(pp.groupBy(Functions.justFunction(1)))</span>
<span class="fc" id="L1699">        .subscribe(ts);</span>

<span class="fc" id="L1701">        pp.onNext(1);</span>

<span class="fc" id="L1703">        ts.assertResult(1);</span>
<span class="fc" id="L1704">    }</span>

    @Test
    public void reentrantCompleteCancel() {
<span class="fc" id="L1708">        final PublishProcessor&lt;Integer&gt; pp = PublishProcessor.create();</span>

<span class="fc" id="L1710">        TestSubscriber&lt;Integer&gt; ts = new TestSubscriber&lt;Integer&gt;() {</span>
            @Override
            public void onNext(Integer t) {
<span class="fc" id="L1713">                super.onNext(t);</span>
<span class="pc bpc" id="L1714" title="1 of 2 branches missed.">                if (t == 1) {</span>
<span class="fc" id="L1715">                    pp.onComplete();</span>
<span class="fc" id="L1716">                    dispose();</span>
                }
<span class="fc" id="L1718">            }</span>
        };

<span class="fc" id="L1721">        Flowable.merge(pp.groupBy(Functions.justFunction(1)))</span>
<span class="fc" id="L1722">        .subscribe(ts);</span>

<span class="fc" id="L1724">        pp.onNext(1);</span>

<span class="fc" id="L1726">        ts.assertSubscribed().assertValue(1).assertNoErrors().assertNotComplete();</span>
<span class="fc" id="L1727">    }</span>

    @Test
    public void delayErrorSimpleComplete() {
<span class="fc" id="L1731">        Flowable.just(1)</span>
<span class="fc" id="L1732">        .groupBy(Functions.justFunction(1), true)</span>
<span class="fc" id="L1733">        .flatMap(Functions.&lt;Flowable&lt;Integer&gt;&gt;identity())</span>
<span class="fc" id="L1734">        .test()</span>
<span class="fc" id="L1735">        .assertResult(1);</span>
<span class="fc" id="L1736">    }</span>

    @Test
    public void mainFusionRejected() {
<span class="fc" id="L1740">        TestSubscriber&lt;Flowable&lt;Integer&gt;&gt; ts = SubscriberFusion.newTest(QueueFuseable.SYNC);</span>

<span class="fc" id="L1742">        Flowable.just(1)</span>
<span class="fc" id="L1743">        .groupBy(Functions.justFunction(1))</span>
<span class="fc" id="L1744">        .subscribe(ts);</span>

<span class="fc" id="L1746">        SubscriberFusion.assertFusion(ts, QueueFuseable.NONE)</span>
<span class="fc" id="L1747">        .assertValueCount(1)</span>
<span class="fc" id="L1748">        .assertComplete()</span>
<span class="fc" id="L1749">        .assertNoErrors();</span>
<span class="fc" id="L1750">    }</span>

    @Test
    public void badSource() {
<span class="fc" id="L1754">        TestHelper.checkBadSourceFlowable(new Function&lt;Flowable&lt;Object&gt;, Object&gt;() {</span>
            @Override
            public Object apply(Flowable&lt;Object&gt; f) throws Exception {
<span class="fc" id="L1757">                return f.groupBy(Functions.justFunction(1));</span>
            }
<span class="fc" id="L1759">        }, false, 1, 1, (Object[])null);</span>
<span class="fc" id="L1760">    }</span>

    @Test
    public void badRequest() {
<span class="fc" id="L1764">        TestHelper.assertBadRequestReported(Flowable.just(1)</span>
<span class="fc" id="L1765">                .groupBy(Functions.justFunction(1)));</span>
<span class="fc" id="L1766">    }</span>

    @Test
    public void doubleOnSubscribe() {
<span class="fc" id="L1770">        TestHelper.checkDoubleOnSubscribeFlowable(new Function&lt;Flowable&lt;Object&gt;, Publisher&lt;GroupedFlowable&lt;Integer, Object&gt;&gt;&gt;() {</span>
            @Override
            public Publisher&lt;GroupedFlowable&lt;Integer, Object&gt;&gt; apply(Flowable&lt;Object&gt; f) throws Exception {
<span class="fc" id="L1773">                return f.groupBy(Functions.justFunction(1));</span>
            }
        });
<span class="fc" id="L1776">    }</span>

    @Test
    public void nullKeyTakeInner() {
<span class="fc" id="L1780">        Flowable.just(1)</span>
<span class="fc" id="L1781">        .groupBy(new Function&lt;Integer, Object&gt;() {</span>
            @Override
            public Object apply(Integer v) throws Exception {
<span class="fc" id="L1784">                return null;</span>
            }
        })
<span class="fc" id="L1787">        .flatMap(new Function&lt;GroupedFlowable&lt;Object, Integer&gt;, Publisher&lt;Integer&gt;&gt;() {</span>
            @Override
            public Publisher&lt;Integer&gt; apply(GroupedFlowable&lt;Object, Integer&gt; g) throws Exception {
<span class="fc" id="L1790">                return g.take(1);</span>
            }
        })
<span class="fc" id="L1793">        .test()</span>
<span class="fc" id="L1794">        .assertResult(1);</span>
<span class="fc" id="L1795">    }</span>

    @Test
    public void errorFused() {
<span class="fc" id="L1799">        TestSubscriber&lt;Object&gt; ts = SubscriberFusion.newTest(QueueFuseable.ANY);</span>

<span class="fc" id="L1801">        Flowable.error(new TestException())</span>
<span class="fc" id="L1802">        .groupBy(Functions.justFunction(1))</span>
<span class="fc" id="L1803">        .subscribe(ts);</span>

<span class="fc" id="L1805">        SubscriberFusion.assertFusion(ts, QueueFuseable.ASYNC)</span>
<span class="fc" id="L1806">        .assertFailure(TestException.class);</span>
<span class="fc" id="L1807">    }</span>

    @Test
    public void errorFusedDelayed() {
<span class="fc" id="L1811">        TestSubscriber&lt;Object&gt; ts = SubscriberFusion.newTest(QueueFuseable.ANY);</span>

<span class="fc" id="L1813">        Flowable.error(new TestException())</span>
<span class="fc" id="L1814">        .groupBy(Functions.justFunction(1), true)</span>
<span class="fc" id="L1815">        .subscribe(ts);</span>

<span class="fc" id="L1817">        SubscriberFusion.assertFusion(ts, QueueFuseable.ASYNC)</span>
<span class="fc" id="L1818">        .assertFailure(TestException.class);</span>
<span class="fc" id="L1819">    }</span>

    @Test
    public void groupError() {
<span class="fc" id="L1823">        Flowable.just(1).concatWith(Flowable.&lt;Integer&gt;error(new TestException()))</span>
<span class="fc" id="L1824">        .groupBy(Functions.justFunction(1), true)</span>
<span class="fc" id="L1825">        .flatMap(new Function&lt;GroupedFlowable&lt;Integer, Integer&gt;, Publisher&lt;Integer&gt;&gt;() {</span>
            @Override
            public Publisher&lt;Integer&gt; apply(GroupedFlowable&lt;Integer, Integer&gt; g) throws Exception {
<span class="fc" id="L1828">                return g.hide();</span>
            }
        })
<span class="fc" id="L1831">        .test()</span>
<span class="fc" id="L1832">        .assertFailure(TestException.class, 1);</span>
<span class="fc" id="L1833">    }</span>

    @Test
    public void groupComplete() {
<span class="fc" id="L1837">        Flowable.just(1)</span>
<span class="fc" id="L1838">        .groupBy(Functions.justFunction(1), true)</span>
<span class="fc" id="L1839">        .flatMap(new Function&lt;GroupedFlowable&lt;Integer, Integer&gt;, Publisher&lt;Integer&gt;&gt;() {</span>
            @Override
            public Publisher&lt;Integer&gt; apply(GroupedFlowable&lt;Integer, Integer&gt; g) throws Exception {
<span class="fc" id="L1842">                return g.hide();</span>
            }
        })
<span class="fc" id="L1845">        .test()</span>
<span class="fc" id="L1846">        .assertResult(1);</span>
<span class="fc" id="L1847">    }</span>

    @Test
    public void mapFactoryThrows() {
<span class="fc" id="L1851">        final IOException ex = new IOException(&quot;boo&quot;);</span>
<span class="fc" id="L1852">        Function&lt;Consumer&lt;Object&gt;, Map&lt;Integer, Object&gt;&gt; evictingMapFactory =  //</span>
<span class="fc" id="L1853">                new Function&lt;Consumer&lt;Object&gt;, Map&lt;Integer, Object&gt;&gt;() {</span>

                    @Override
                    public Map&lt;Integer, Object&gt; apply(final Consumer&lt;Object&gt; notify) throws Exception {
<span class="fc" id="L1857">                        throw ex;</span>
                    }
                };
<span class="fc" id="L1860">        Flowable.just(1)</span>
<span class="fc" id="L1861">          .groupBy(Functions.&lt;Integer&gt;identity(), Functions.identity(), true, 16, evictingMapFactory)</span>
<span class="fc" id="L1862">          .test()</span>
<span class="fc" id="L1863">          .assertNoValues()</span>
<span class="fc" id="L1864">          .assertError(ex);</span>
<span class="fc" id="L1865">    }</span>

    @Test
    public void mapFactoryExpiryCompletesGroupedFlowable() {
<span class="fc" id="L1869">        final List&lt;Integer&gt; completed = new CopyOnWriteArrayList&lt;Integer&gt;();</span>
<span class="fc" id="L1870">        Function&lt;Consumer&lt;Object&gt;, Map&lt;Integer, Object&gt;&gt; evictingMapFactory = createEvictingMapFactorySynchronousOnly(1);</span>
<span class="fc" id="L1871">        PublishSubject&lt;Integer&gt; subject = PublishSubject.create();</span>
<span class="fc" id="L1872">        TestSubscriber&lt;Integer&gt; ts = subject.toFlowable(BackpressureStrategy.BUFFER)</span>
<span class="fc" id="L1873">                .groupBy(Functions.&lt;Integer&gt;identity(), Functions.&lt;Integer&gt;identity(), true, 16, evictingMapFactory)</span>
<span class="fc" id="L1874">                .flatMap(addCompletedKey(completed))</span>
<span class="fc" id="L1875">                .test();</span>
<span class="fc" id="L1876">        subject.onNext(1);</span>
<span class="fc" id="L1877">        subject.onNext(2);</span>
<span class="fc" id="L1878">        subject.onNext(3);</span>
<span class="fc" id="L1879">        ts.assertValues(1, 2, 3)</span>
<span class="fc" id="L1880">          .assertNotTerminated();</span>
<span class="fc" id="L1881">        assertEquals(Arrays.asList(1, 2), completed);</span>
        //ensure coverage of the code that clears the evicted queue
<span class="fc" id="L1883">        subject.onComplete();</span>
<span class="fc" id="L1884">        ts.assertComplete();</span>
<span class="fc" id="L1885">        ts.assertValueCount(3);</span>
<span class="fc" id="L1886">    }</span>

<span class="fc" id="L1888">    private static final Function&lt;Integer, Integer&gt; mod5 = new Function&lt;Integer, Integer&gt;() {</span>

        @Override
        public Integer apply(Integer n) throws Exception {
<span class="fc" id="L1892">            return n % 5;</span>
        }
    };

    @Test
    public void mapFactoryWithExpiringGuavaCacheDemonstrationCodeForUseInJavadoc() {
        //javadoc will be a version of this using lambdas and without assertions
<span class="fc" id="L1899">        final List&lt;Integer&gt; completed = new CopyOnWriteArrayList&lt;Integer&gt;();</span>
        //size should be less than 5 to notice the effect
<span class="fc" id="L1901">        Function&lt;Consumer&lt;Object&gt;, Map&lt;Integer, Object&gt;&gt; evictingMapFactory = createEvictingMapFactoryGuava(3);</span>
<span class="fc" id="L1902">        int numValues = 1000;</span>
<span class="fc" id="L1903">        TestSubscriber&lt;Integer&gt; ts =</span>
<span class="fc" id="L1904">            Flowable.range(1, numValues)</span>
<span class="fc" id="L1905">                .groupBy(mod5, Functions.&lt;Integer&gt;identity(), true, 16, evictingMapFactory)</span>
<span class="fc" id="L1906">                .flatMap(addCompletedKey(completed))</span>
<span class="fc" id="L1907">                .test()</span>
<span class="fc" id="L1908">                .assertComplete();</span>
<span class="fc" id="L1909">        ts.assertValueCount(numValues);</span>
        //the exact eviction behaviour of the guava cache is not specified so we make some approximate tests
<span class="pc bpc" id="L1911" title="1 of 2 branches missed.">        assertTrue(completed.size() &gt; numValues * 0.9);</span>
<span class="fc" id="L1912">    }</span>

    @Test
    public void mapFactoryEvictionQueueClearedOnErrorCoverageOnly() {
<span class="fc" id="L1916">        Function&lt;Consumer&lt;Object&gt;, Map&lt;Integer, Object&gt;&gt; evictingMapFactory = createEvictingMapFactorySynchronousOnly(1);</span>
<span class="fc" id="L1917">        PublishSubject&lt;Integer&gt; subject = PublishSubject.create();</span>
<span class="fc" id="L1918">        TestSubscriber&lt;Integer&gt; ts = subject</span>
<span class="fc" id="L1919">                .toFlowable(BackpressureStrategy.BUFFER)</span>
<span class="fc" id="L1920">                .groupBy(Functions.&lt;Integer&gt;identity(), Functions.&lt;Integer&gt;identity(), true, 16, evictingMapFactory)</span>
<span class="fc" id="L1921">                .flatMap(new Function&lt;GroupedFlowable&lt;Integer, Integer&gt;, Publisher&lt;Integer&gt;&gt;() {</span>
                    @Override
                    public Publisher&lt;Integer&gt; apply(GroupedFlowable&lt;Integer, Integer&gt; g) throws Exception {
<span class="nc" id="L1924">                        return g;</span>
                    }
                })
<span class="fc" id="L1927">                .test();</span>
<span class="fc" id="L1928">        RuntimeException ex = new RuntimeException();</span>
        //ensure coverage of the code that clears the evicted queue
<span class="fc" id="L1930">        subject.onError(ex);</span>
<span class="fc" id="L1931">        ts.assertNoValues()</span>
<span class="fc" id="L1932">          .assertError(ex);</span>
<span class="fc" id="L1933">    }</span>

    private static Function&lt;GroupedFlowable&lt;Integer, Integer&gt;, Publisher&lt;? extends Integer&gt;&gt; addCompletedKey(
            final List&lt;Integer&gt; completed) {
<span class="fc" id="L1937">        return new Function&lt;GroupedFlowable&lt;Integer, Integer&gt;, Publisher&lt;? extends Integer&gt;&gt;() {</span>
            @Override
            public Publisher&lt;? extends Integer&gt; apply(final GroupedFlowable&lt;Integer, Integer&gt; g) throws Exception {
<span class="fc" id="L1940">                return g.doOnComplete(new Action() {</span>
                    @Override
                    public void run() throws Exception {
<span class="fc" id="L1943">                        completed.add(g.getKey());</span>
<span class="fc" id="L1944">                    }</span>
                });
            }
        };
    }

    private static final class TestTicker extends Ticker {
        long tick;

        @Override
        public long read() {
<span class="fc" id="L1955">            return tick;</span>
        }
    }

    @Test
    public void testGroupByEvictionCancellationOfSource5933() {
<span class="fc" id="L1961">        PublishProcessor&lt;Integer&gt; source = PublishProcessor.create();</span>
<span class="fc" id="L1962">        final TestTicker testTicker = new TestTicker();</span>

<span class="fc" id="L1964">        Function&lt;Consumer&lt;Object&gt;, Map&lt;Integer, Object&gt;&gt; mapFactory = new Function&lt;Consumer&lt;Object&gt;, Map&lt;Integer, Object&gt;&gt;() {</span>
            @Override
            public Map&lt;Integer, Object&gt; apply(final Consumer&lt;Object&gt; action) throws Exception {
<span class="fc" id="L1967">                return CacheBuilder.newBuilder() //</span>
<span class="fc" id="L1968">                        .expireAfterAccess(5, TimeUnit.SECONDS).removalListener(new RemovalListener&lt;Object, Object&gt;() {</span>
                            @Override
                            public void onRemoval(RemovalNotification&lt;Object, Object&gt; notification) {
                                try {
<span class="fc" id="L1972">                                    action.accept(notification.getValue());</span>
<span class="nc" id="L1973">                                } catch (Exception ex) {</span>
<span class="nc" id="L1974">                                    throw new RuntimeException(ex);</span>
<span class="fc" id="L1975">                                }</span>
<span class="fc" id="L1976">                            }</span>
<span class="fc" id="L1977">                        }).ticker(testTicker) //</span>
<span class="fc" id="L1978">                        .&lt;Integer, Object&gt;build().asMap();</span>
            }
        };

<span class="fc" id="L1982">        final List&lt;String&gt; list = new CopyOnWriteArrayList&lt;String&gt;();</span>
<span class="fc" id="L1983">        Flowable&lt;Integer&gt; stream = source //</span>
<span class="fc" id="L1984">                .doOnCancel(new Action() {</span>
                    @Override
                    public void run() throws Exception {
<span class="fc" id="L1987">                        list.add(&quot;Source canceled&quot;);</span>
<span class="fc" id="L1988">                    }</span>
                })
<span class="fc" id="L1990">                .&lt;Integer, Integer&gt;groupBy(Functions.&lt;Integer&gt;identity(), Functions.&lt;Integer&gt;identity(), false,</span>
<span class="fc" id="L1991">                        Flowable.bufferSize(), mapFactory) //</span>
<span class="fc" id="L1992">                .flatMap(new Function&lt;GroupedFlowable&lt;Integer, Integer&gt;, Publisher&lt;? extends Integer&gt;&gt;() {</span>
                    @Override
                    public Publisher&lt;? extends Integer&gt; apply(GroupedFlowable&lt;Integer, Integer&gt; group)
                            throws Exception {
<span class="fc" id="L1996">                        return group //</span>
<span class="fc" id="L1997">                                .doOnComplete(new Action() {</span>
                                    @Override
                                    public void run() throws Exception {
<span class="fc" id="L2000">                                        list.add(&quot;Group completed&quot;);</span>
<span class="fc" id="L2001">                                    }</span>
<span class="fc" id="L2002">                                }).doOnCancel(new Action() {</span>
                                    @Override
                                    public void run() throws Exception {
<span class="fc" id="L2005">                                        list.add(&quot;Group canceled&quot;);</span>
<span class="fc" id="L2006">                                    }</span>
                                });
                    }
                });
<span class="fc" id="L2010">        TestSubscriber&lt;Integer&gt; ts = stream //</span>
<span class="fc" id="L2011">                .doOnCancel(new Action() {</span>
                    @Override
                    public void run() throws Exception {
<span class="fc" id="L2014">                        list.add(&quot;Outer group by canceled&quot;);</span>
<span class="fc" id="L2015">                    }</span>
<span class="fc" id="L2016">                }).test();</span>

        // Send 3 in the same group and wait for them to be seen
<span class="fc" id="L2019">        source.onNext(1);</span>
<span class="fc" id="L2020">        source.onNext(1);</span>
<span class="fc" id="L2021">        source.onNext(1);</span>
<span class="fc" id="L2022">        ts.awaitCount(3);</span>

        // Advance time far enough to evict the group.
        // NOTE -- Comment this line out to make the test &quot;pass&quot;.
<span class="fc" id="L2026">        testTicker.tick = TimeUnit.SECONDS.toNanos(6);</span>

        // Send more data in the group (triggering eviction and recreation)
<span class="fc" id="L2029">        source.onNext(1);</span>

        // Wait for the last 2 and then cancel the subscription
<span class="fc" id="L2032">        ts.awaitCount(4);</span>
<span class="fc" id="L2033">        ts.cancel();</span>

        // Observe the result.  Note that right now the result differs depending on whether eviction occurred or
        // not.  The observed sequence in that case is:  Group completed, Outer group by canceled., Group canceled.
        // The addition of the &quot;Group completed&quot; is actually fine, but the fact that the cancel doesn't reach the
        // source seems like a bug.  Commenting out the setting of &quot;tick&quot; above will produce the &quot;expected&quot; sequence.
<span class="fc" id="L2039">        System.out.println(list);</span>
<span class="fc" id="L2040">        assertTrue(list.contains(&quot;Source canceled&quot;));</span>
<span class="fc" id="L2041">        assertEquals(Arrays.asList(</span>
                &quot;Group completed&quot;, // this is here when eviction occurs
                &quot;Outer group by canceled&quot;,
                &quot;Group canceled&quot;,
                &quot;Source canceled&quot;  // This is *not* here when eviction occurs
        ), list);
<span class="fc" id="L2047">    }</span>

    @Test
    public void testCancellationOfUpstreamWhenGroupedFlowableCompletes() {
<span class="fc" id="L2051">        final AtomicBoolean cancelled = new AtomicBoolean();</span>
<span class="fc" id="L2052">        Flowable.just(1).repeat().doOnCancel(new Action() {</span>
            @Override
            public void run() throws Exception {
<span class="fc" id="L2055">                cancelled.set(true);</span>
<span class="fc" id="L2056">            }</span>
        })
<span class="fc" id="L2058">        .groupBy(Functions.&lt;Integer&gt;identity(), Functions.&lt;Integer&gt;identity()) //</span>
<span class="fc" id="L2059">        .flatMap(new Function&lt;GroupedFlowable&lt;Integer, Integer&gt;, Publisher&lt;? extends Object&gt;&gt;() {</span>
            @Override
            public Publisher&lt;? extends Object&gt; apply(GroupedFlowable&lt;Integer, Integer&gt; g) throws Exception {
<span class="fc" id="L2062">                return g.first(0).toFlowable();</span>
            }
        })
<span class="fc" id="L2065">        .take(4) //</span>
<span class="fc" id="L2066">        .test() //</span>
<span class="fc" id="L2067">        .assertComplete();</span>
<span class="fc" id="L2068">        assertTrue(cancelled.get());</span>
<span class="fc" id="L2069">    }</span>

    //not thread safe
    private static final class SingleThreadEvictingHashMap&lt;K, V&gt; implements Map&lt;K, V&gt; {

<span class="fc" id="L2074">        private final List&lt;K&gt; list = new ArrayList&lt;K&gt;();</span>
<span class="fc" id="L2075">        private final Map&lt;K, V&gt; map = new HashMap&lt;K, V&gt;();</span>
        private final int maxSize;
        private final Consumer&lt;V&gt; evictedListener;

<span class="fc" id="L2079">        SingleThreadEvictingHashMap(int maxSize, Consumer&lt;V&gt; evictedListener) {</span>
<span class="fc" id="L2080">            this.maxSize = maxSize;</span>
<span class="fc" id="L2081">            this.evictedListener = evictedListener;</span>
<span class="fc" id="L2082">        }</span>

        @Override
        public int size() {
<span class="nc" id="L2086">            return map.size();</span>
        }

        @Override
        public boolean isEmpty() {
<span class="nc" id="L2091">            return map.isEmpty();</span>
        }

        @Override
        public boolean containsKey(Object key) {
<span class="nc" id="L2096">            return map.containsKey(key);</span>
        }

        @Override
        public boolean containsValue(Object value) {
<span class="nc" id="L2101">            return map.containsValue(value);</span>
        }

        @Override
        public V get(Object key) {
<span class="fc" id="L2106">            return map.get(key);</span>
        }

        @Override
        public V put(K key, V value) {
<span class="fc" id="L2111">            list.remove(key);</span>
            V v;
<span class="pc bpc" id="L2113" title="1 of 4 branches missed.">            if (maxSize &gt; 0 &amp;&amp; list.size() == maxSize) {</span>
                //remove first
<span class="fc" id="L2115">                K k = list.get(0);</span>
<span class="fc" id="L2116">                list.remove(0);</span>
<span class="fc" id="L2117">                v = map.remove(k);</span>
<span class="fc" id="L2118">            } else {</span>
<span class="fc" id="L2119">                v = null;</span>
            }
<span class="fc" id="L2121">            list.add(key);</span>
<span class="fc" id="L2122">            V result = map.put(key, value);</span>
<span class="fc bfc" id="L2123" title="All 2 branches covered.">            if (v != null) {</span>
                try {
<span class="fc" id="L2125">                    evictedListener.accept(v);</span>
<span class="nc" id="L2126">                } catch (Exception e) {</span>
<span class="nc" id="L2127">                    throw new RuntimeException(e);</span>
<span class="fc" id="L2128">                }</span>
            }
<span class="fc" id="L2130">            return result;</span>
        }

        @Override
        public V remove(Object key) {
<span class="nc" id="L2135">            list.remove(key);</span>
<span class="nc" id="L2136">            return map.remove(key);</span>
        }

        @Override
        public void putAll(Map&lt;? extends K, ? extends V&gt; m) {
<span class="nc bnc" id="L2141" title="All 2 branches missed.">           for (Entry&lt;? extends K, ? extends V&gt; entry: m.entrySet()) {</span>
<span class="nc" id="L2142">               put(entry.getKey(), entry.getValue());</span>
<span class="nc" id="L2143">           }</span>
<span class="nc" id="L2144">        }</span>

        @Override
        public void clear() {
<span class="fc" id="L2148">            list.clear();</span>
<span class="fc" id="L2149">            map.clear();</span>
<span class="fc" id="L2150">        }</span>

        @Override
        public Set&lt;K&gt; keySet() {
<span class="nc" id="L2154">            return map.keySet();</span>
        }

        @Override
        public Collection&lt;V&gt; values() {
<span class="fc" id="L2159">            return map.values();</span>
        }

        @Override
        public Set&lt;Entry&lt;K, V&gt;&gt; entrySet() {
<span class="nc" id="L2164">            return map.entrySet();</span>
        }
    }

    private static Function&lt;Consumer&lt;Object&gt;, Map&lt;Integer, Object&gt;&gt; createEvictingMapFactoryGuava(final int maxSize) {
<span class="fc" id="L2169">        Function&lt;Consumer&lt;Object&gt;, Map&lt;Integer, Object&gt;&gt; evictingMapFactory =  //</span>
<span class="fc" id="L2170">                new Function&lt;Consumer&lt;Object&gt;, Map&lt;Integer, Object&gt;&gt;() {</span>

            @Override
            public Map&lt;Integer, Object&gt; apply(final Consumer&lt;Object&gt; notify) throws Exception {
<span class="fc" id="L2174">                return CacheBuilder.newBuilder() //</span>
<span class="fc" id="L2175">                        .maximumSize(maxSize) //</span>
<span class="fc" id="L2176">                        .removalListener(new RemovalListener&lt;Integer, Object&gt;() {</span>
                            @Override
                            public void onRemoval(RemovalNotification&lt;Integer, Object&gt; notification) {
                                try {
<span class="fc" id="L2180">                                    notify.accept(notification.getValue());</span>
<span class="nc" id="L2181">                                } catch (Exception e) {</span>
<span class="nc" id="L2182">                                    throw new RuntimeException(e);</span>
<span class="fc" id="L2183">                                }</span>
<span class="fc" id="L2184">                            }})</span>
<span class="fc" id="L2185">                        .&lt;Integer, Object&gt; build()</span>
<span class="fc" id="L2186">                        .asMap();</span>
            }};
<span class="fc" id="L2188">        return evictingMapFactory;</span>
    }

    private static Function&lt;Consumer&lt;Object&gt;, Map&lt;Integer, Object&gt;&gt; createEvictingMapFactorySynchronousOnly(final int maxSize) {
<span class="fc" id="L2192">        Function&lt;Consumer&lt;Object&gt;, Map&lt;Integer, Object&gt;&gt; evictingMapFactory =  //</span>
<span class="fc" id="L2193">                new Function&lt;Consumer&lt;Object&gt;, Map&lt;Integer, Object&gt;&gt;() {</span>

                    @Override
                    public Map&lt;Integer, Object&gt; apply(final Consumer&lt;Object&gt; notify) throws Exception {
<span class="fc" id="L2197">                        return new SingleThreadEvictingHashMap&lt;Integer, Object&gt;(maxSize, new Consumer&lt;Object&gt;() {</span>
                                    @Override
                                    public void accept(Object object) {
                                        try {
<span class="fc" id="L2201">                                            notify.accept(object);</span>
<span class="nc" id="L2202">                                        } catch (Exception e) {</span>
<span class="nc" id="L2203">                                            throw new RuntimeException(e);</span>
<span class="fc" id="L2204">                                        }</span>
<span class="fc" id="L2205">                                    }});</span>
                    }};
<span class="fc" id="L2207">        return evictingMapFactory;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>