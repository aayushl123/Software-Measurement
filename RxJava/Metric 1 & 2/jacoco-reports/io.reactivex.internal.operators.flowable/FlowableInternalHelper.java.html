<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FlowableInternalHelper.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">RxJava_2_x$Unnamed.exec</a> &gt; <a href="index.source.html" class="el_package">io.reactivex.internal.operators.flowable</a> &gt; <span class="el_source">FlowableInternalHelper.java</span></div><h1>FlowableInternalHelper.java</h1><pre class="source lang-java linenums">/**
 * Copyright (c) 2016-present, RxJava Contributors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is
 * distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
 * the License for the specific language governing permissions and limitations under the License.
 */
package io.reactivex.internal.operators.flowable;

import java.util.List;
import java.util.concurrent.*;

import org.reactivestreams.*;

import io.reactivex.*;
import io.reactivex.flowables.ConnectableFlowable;
import io.reactivex.functions.*;
import io.reactivex.internal.functions.*;

/**
 * Helper utility class to support Flowable with inner classes.
 */
public final class FlowableInternalHelper {

    /** Utility class. */
<span class="fc" id="L31">    private FlowableInternalHelper() {</span>
<span class="fc" id="L32">        throw new IllegalStateException(&quot;No instances!&quot;);</span>
    }

    static final class SimpleGenerator&lt;T, S&gt; implements BiFunction&lt;S, Emitter&lt;T&gt;, S&gt; {
        final Consumer&lt;Emitter&lt;T&gt;&gt; consumer;

<span class="fc" id="L38">        SimpleGenerator(Consumer&lt;Emitter&lt;T&gt;&gt; consumer) {</span>
<span class="fc" id="L39">            this.consumer = consumer;</span>
<span class="fc" id="L40">        }</span>

        @Override
        public S apply(S t1, Emitter&lt;T&gt; t2) throws Exception {
<span class="fc" id="L44">            consumer.accept(t2);</span>
<span class="fc" id="L45">            return t1;</span>
        }
    }

    public static &lt;T, S&gt; BiFunction&lt;S, Emitter&lt;T&gt;, S&gt; simpleGenerator(Consumer&lt;Emitter&lt;T&gt;&gt; consumer) {
<span class="fc" id="L50">        return new SimpleGenerator&lt;T, S&gt;(consumer);</span>
    }

    static final class SimpleBiGenerator&lt;T, S&gt; implements BiFunction&lt;S, Emitter&lt;T&gt;, S&gt; {
        final BiConsumer&lt;S, Emitter&lt;T&gt;&gt; consumer;

<span class="fc" id="L56">        SimpleBiGenerator(BiConsumer&lt;S, Emitter&lt;T&gt;&gt; consumer) {</span>
<span class="fc" id="L57">            this.consumer = consumer;</span>
<span class="fc" id="L58">        }</span>

        @Override
        public S apply(S t1, Emitter&lt;T&gt; t2) throws Exception {
<span class="fc" id="L62">            consumer.accept(t1, t2);</span>
<span class="fc" id="L63">            return t1;</span>
        }
    }

    public static &lt;T, S&gt; BiFunction&lt;S, Emitter&lt;T&gt;, S&gt; simpleBiGenerator(BiConsumer&lt;S, Emitter&lt;T&gt;&gt; consumer) {
<span class="fc" id="L68">        return new SimpleBiGenerator&lt;T, S&gt;(consumer);</span>
    }

    static final class ItemDelayFunction&lt;T, U&gt; implements Function&lt;T, Publisher&lt;T&gt;&gt; {
        final Function&lt;? super T, ? extends Publisher&lt;U&gt;&gt; itemDelay;

<span class="fc" id="L74">        ItemDelayFunction(Function&lt;? super T, ? extends Publisher&lt;U&gt;&gt; itemDelay) {</span>
<span class="fc" id="L75">            this.itemDelay = itemDelay;</span>
<span class="fc" id="L76">        }</span>

        @Override
        public Publisher&lt;T&gt; apply(final T v) throws Exception {
<span class="fc" id="L80">            Publisher&lt;U&gt; p = ObjectHelper.requireNonNull(itemDelay.apply(v), &quot;The itemDelay returned a null Publisher&quot;);</span>
<span class="fc" id="L81">            return new FlowableTakePublisher&lt;U&gt;(p, 1).map(Functions.justFunction(v)).defaultIfEmpty(v);</span>
        }
    }

    public static &lt;T, U&gt; Function&lt;T, Publisher&lt;T&gt;&gt; itemDelay(final Function&lt;? super T, ? extends Publisher&lt;U&gt;&gt; itemDelay) {
<span class="fc" id="L86">        return new ItemDelayFunction&lt;T, U&gt;(itemDelay);</span>
    }

    static final class SubscriberOnNext&lt;T&gt; implements Consumer&lt;T&gt; {
        final Subscriber&lt;T&gt; subscriber;

<span class="fc" id="L92">        SubscriberOnNext(Subscriber&lt;T&gt; subscriber) {</span>
<span class="fc" id="L93">            this.subscriber = subscriber;</span>
<span class="fc" id="L94">        }</span>

        @Override
        public void accept(T v) throws Exception {
<span class="fc" id="L98">            subscriber.onNext(v);</span>
<span class="fc" id="L99">        }</span>
    }

    static final class SubscriberOnError&lt;T&gt; implements Consumer&lt;Throwable&gt; {
        final Subscriber&lt;T&gt; subscriber;

<span class="fc" id="L105">        SubscriberOnError(Subscriber&lt;T&gt; subscriber) {</span>
<span class="fc" id="L106">            this.subscriber = subscriber;</span>
<span class="fc" id="L107">        }</span>

        @Override
        public void accept(Throwable v) throws Exception {
<span class="fc" id="L111">            subscriber.onError(v);</span>
<span class="fc" id="L112">        }</span>
    }

    static final class SubscriberOnComplete&lt;T&gt; implements Action {
        final Subscriber&lt;T&gt; subscriber;

<span class="fc" id="L118">        SubscriberOnComplete(Subscriber&lt;T&gt; subscriber) {</span>
<span class="fc" id="L119">            this.subscriber = subscriber;</span>
<span class="fc" id="L120">        }</span>

        @Override
        public void run() throws Exception {
<span class="fc" id="L124">            subscriber.onComplete();</span>
<span class="fc" id="L125">        }</span>
    }

    public static &lt;T&gt; Consumer&lt;T&gt; subscriberOnNext(Subscriber&lt;T&gt; subscriber) {
<span class="fc" id="L129">        return new SubscriberOnNext&lt;T&gt;(subscriber);</span>
    }

    public static &lt;T&gt; Consumer&lt;Throwable&gt; subscriberOnError(Subscriber&lt;T&gt; subscriber) {
<span class="fc" id="L133">        return new SubscriberOnError&lt;T&gt;(subscriber);</span>
    }

    public static &lt;T&gt; Action subscriberOnComplete(Subscriber&lt;T&gt; subscriber) {
<span class="fc" id="L137">        return new SubscriberOnComplete&lt;T&gt;(subscriber);</span>
    }

    static final class FlatMapWithCombinerInner&lt;U, R, T&gt; implements Function&lt;U, R&gt; {
        private final BiFunction&lt;? super T, ? super U, ? extends R&gt; combiner;
        private final T t;

<span class="fc" id="L144">        FlatMapWithCombinerInner(BiFunction&lt;? super T, ? super U, ? extends R&gt; combiner, T t) {</span>
<span class="fc" id="L145">            this.combiner = combiner;</span>
<span class="fc" id="L146">            this.t = t;</span>
<span class="fc" id="L147">        }</span>

        @Override
        public R apply(U w) throws Exception {
<span class="fc" id="L151">            return combiner.apply(t, w);</span>
        }
    }

    static final class FlatMapWithCombinerOuter&lt;T, R, U&gt; implements Function&lt;T, Publisher&lt;R&gt;&gt; {
        private final BiFunction&lt;? super T, ? super U, ? extends R&gt; combiner;
        private final Function&lt;? super T, ? extends Publisher&lt;? extends U&gt;&gt; mapper;

        FlatMapWithCombinerOuter(BiFunction&lt;? super T, ? super U, ? extends R&gt; combiner,
<span class="fc" id="L160">                Function&lt;? super T, ? extends Publisher&lt;? extends U&gt;&gt; mapper) {</span>
<span class="fc" id="L161">            this.combiner = combiner;</span>
<span class="fc" id="L162">            this.mapper = mapper;</span>
<span class="fc" id="L163">        }</span>

        @Override
        public Publisher&lt;R&gt; apply(final T t) throws Exception {
            @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L168">            Publisher&lt;U&gt; u = (Publisher&lt;U&gt;)ObjectHelper.requireNonNull(mapper.apply(t), &quot;The mapper returned a null Publisher&quot;);</span>
<span class="fc" id="L169">            return new FlowableMapPublisher&lt;U, R&gt;(u, new FlatMapWithCombinerInner&lt;U, R, T&gt;(combiner, t));</span>
        }
    }

    public static &lt;T, U, R&gt; Function&lt;T, Publisher&lt;R&gt;&gt; flatMapWithCombiner(
            final Function&lt;? super T, ? extends Publisher&lt;? extends U&gt;&gt; mapper,
                    final BiFunction&lt;? super T, ? super U, ? extends R&gt; combiner) {
<span class="fc" id="L176">        return new FlatMapWithCombinerOuter&lt;T, R, U&gt;(combiner, mapper);</span>
    }

    static final class FlatMapIntoIterable&lt;T, U&gt; implements Function&lt;T, Publisher&lt;U&gt;&gt; {
        private final Function&lt;? super T, ? extends Iterable&lt;? extends U&gt;&gt; mapper;

<span class="fc" id="L182">        FlatMapIntoIterable(Function&lt;? super T, ? extends Iterable&lt;? extends U&gt;&gt; mapper) {</span>
<span class="fc" id="L183">            this.mapper = mapper;</span>
<span class="fc" id="L184">        }</span>

        @Override
        public Publisher&lt;U&gt; apply(T t) throws Exception {
<span class="fc" id="L188">            return new FlowableFromIterable&lt;U&gt;(ObjectHelper.requireNonNull(mapper.apply(t), &quot;The mapper returned a null Iterable&quot;));</span>
        }
    }

    public static &lt;T, U&gt; Function&lt;T, Publisher&lt;U&gt;&gt; flatMapIntoIterable(final Function&lt;? super T, ? extends Iterable&lt;? extends U&gt;&gt; mapper) {
<span class="fc" id="L193">        return new FlatMapIntoIterable&lt;T, U&gt;(mapper);</span>
    }

    public static &lt;T&gt; Callable&lt;ConnectableFlowable&lt;T&gt;&gt; replayCallable(final Flowable&lt;T&gt; parent) {
<span class="fc" id="L197">        return new ReplayCallable&lt;T&gt;(parent);</span>
    }

    public static &lt;T&gt; Callable&lt;ConnectableFlowable&lt;T&gt;&gt; replayCallable(final Flowable&lt;T&gt; parent, final int bufferSize) {
<span class="fc" id="L201">        return new BufferedReplayCallable&lt;T&gt;(parent, bufferSize);</span>
    }

    public static &lt;T&gt; Callable&lt;ConnectableFlowable&lt;T&gt;&gt; replayCallable(final Flowable&lt;T&gt; parent, final int bufferSize, final long time, final TimeUnit unit, final Scheduler scheduler) {
<span class="fc" id="L205">        return new BufferedTimedReplay&lt;T&gt;(parent, bufferSize, time, unit, scheduler);</span>
    }

    public static &lt;T&gt; Callable&lt;ConnectableFlowable&lt;T&gt;&gt; replayCallable(final Flowable&lt;T&gt; parent, final long time, final TimeUnit unit, final Scheduler scheduler) {
<span class="fc" id="L209">        return new TimedReplay&lt;T&gt;(parent, time, unit, scheduler);</span>
    }

    public static &lt;T, R&gt; Function&lt;Flowable&lt;T&gt;, Publisher&lt;R&gt;&gt; replayFunction(final Function&lt;? super Flowable&lt;T&gt;, ? extends Publisher&lt;R&gt;&gt; selector, final Scheduler scheduler) {
<span class="fc" id="L213">        return new ReplayFunction&lt;T, R&gt;(selector, scheduler);</span>
    }

<span class="fc" id="L216">    public enum RequestMax implements Consumer&lt;Subscription&gt; {</span>
<span class="fc" id="L217">        INSTANCE;</span>
        @Override
        public void accept(Subscription t) throws Exception {
<span class="fc" id="L220">            t.request(Long.MAX_VALUE);</span>
<span class="fc" id="L221">        }</span>
    }

    static final class ZipIterableFunction&lt;T, R&gt;
    implements Function&lt;List&lt;Publisher&lt;? extends T&gt;&gt;, Publisher&lt;? extends R&gt;&gt; {
        private final Function&lt;? super Object[], ? extends R&gt; zipper;

<span class="fc" id="L228">        ZipIterableFunction(Function&lt;? super Object[], ? extends R&gt; zipper) {</span>
<span class="fc" id="L229">            this.zipper = zipper;</span>
<span class="fc" id="L230">        }</span>

        @Override
        public Publisher&lt;? extends R&gt; apply(List&lt;Publisher&lt;? extends T&gt;&gt; list) {
<span class="fc" id="L234">            return Flowable.zipIterable(list, zipper, false, Flowable.bufferSize());</span>
        }
    }

    public static &lt;T, R&gt; Function&lt;List&lt;Publisher&lt;? extends T&gt;&gt;, Publisher&lt;? extends R&gt;&gt; zipIterable(final Function&lt;? super Object[], ? extends R&gt; zipper) {
<span class="fc" id="L239">        return new ZipIterableFunction&lt;T, R&gt;(zipper);</span>
    }

    static final class ReplayCallable&lt;T&gt; implements Callable&lt;ConnectableFlowable&lt;T&gt;&gt; {
        private final Flowable&lt;T&gt; parent;

<span class="fc" id="L245">        ReplayCallable(Flowable&lt;T&gt; parent) {</span>
<span class="fc" id="L246">            this.parent = parent;</span>
<span class="fc" id="L247">        }</span>

        @Override
        public ConnectableFlowable&lt;T&gt; call() {
<span class="fc" id="L251">            return parent.replay();</span>
        }
    }

    static final class BufferedReplayCallable&lt;T&gt; implements Callable&lt;ConnectableFlowable&lt;T&gt;&gt; {
        private final Flowable&lt;T&gt; parent;
        private final int bufferSize;

<span class="fc" id="L259">        BufferedReplayCallable(Flowable&lt;T&gt; parent, int bufferSize) {</span>
<span class="fc" id="L260">            this.parent = parent;</span>
<span class="fc" id="L261">            this.bufferSize = bufferSize;</span>
<span class="fc" id="L262">        }</span>

        @Override
        public ConnectableFlowable&lt;T&gt; call() {
<span class="fc" id="L266">            return parent.replay(bufferSize);</span>
        }
    }

    static final class BufferedTimedReplay&lt;T&gt; implements Callable&lt;ConnectableFlowable&lt;T&gt;&gt; {
        private final Flowable&lt;T&gt; parent;
        private final int bufferSize;
        private final long time;
        private final TimeUnit unit;
        private final Scheduler scheduler;

<span class="fc" id="L277">        BufferedTimedReplay(Flowable&lt;T&gt; parent, int bufferSize, long time, TimeUnit unit, Scheduler scheduler) {</span>
<span class="fc" id="L278">            this.parent = parent;</span>
<span class="fc" id="L279">            this.bufferSize = bufferSize;</span>
<span class="fc" id="L280">            this.time = time;</span>
<span class="fc" id="L281">            this.unit = unit;</span>
<span class="fc" id="L282">            this.scheduler = scheduler;</span>
<span class="fc" id="L283">        }</span>

        @Override
        public ConnectableFlowable&lt;T&gt; call() {
<span class="fc" id="L287">            return parent.replay(bufferSize, time, unit, scheduler);</span>
        }
    }

    static final class TimedReplay&lt;T&gt; implements Callable&lt;ConnectableFlowable&lt;T&gt;&gt; {
        private final Flowable&lt;T&gt; parent;
        private final long time;
        private final TimeUnit unit;
        private final Scheduler scheduler;

<span class="fc" id="L297">        TimedReplay(Flowable&lt;T&gt; parent, long time, TimeUnit unit, Scheduler scheduler) {</span>
<span class="fc" id="L298">            this.parent = parent;</span>
<span class="fc" id="L299">            this.time = time;</span>
<span class="fc" id="L300">            this.unit = unit;</span>
<span class="fc" id="L301">            this.scheduler = scheduler;</span>
<span class="fc" id="L302">        }</span>

        @Override
        public ConnectableFlowable&lt;T&gt; call() {
<span class="fc" id="L306">            return parent.replay(time, unit, scheduler);</span>
        }
    }

    static final class ReplayFunction&lt;T, R&gt; implements Function&lt;Flowable&lt;T&gt;, Publisher&lt;R&gt;&gt; {
        private final Function&lt;? super Flowable&lt;T&gt;, ? extends Publisher&lt;R&gt;&gt; selector;
        private final Scheduler scheduler;

<span class="fc" id="L314">        ReplayFunction(Function&lt;? super Flowable&lt;T&gt;, ? extends Publisher&lt;R&gt;&gt; selector, Scheduler scheduler) {</span>
<span class="fc" id="L315">            this.selector = selector;</span>
<span class="fc" id="L316">            this.scheduler = scheduler;</span>
<span class="fc" id="L317">        }</span>

        @Override
        public Publisher&lt;R&gt; apply(Flowable&lt;T&gt; t) throws Exception {
<span class="fc" id="L321">            Publisher&lt;R&gt; p = ObjectHelper.requireNonNull(selector.apply(t), &quot;The selector returned a null Publisher&quot;);</span>
<span class="fc" id="L322">            return Flowable.fromPublisher(p).observeOn(scheduler);</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>