<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FlowablePublish.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">RxJava_2_x$Unnamed.exec</a> &gt; <a href="index.source.html" class="el_package">io.reactivex.internal.operators.flowable</a> &gt; <span class="el_source">FlowablePublish.java</span></div><h1>FlowablePublish.java</h1><pre class="source lang-java linenums">/**
 * Copyright (c) 2016-present, RxJava Contributors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is
 * distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
 * the License for the specific language governing permissions and limitations under the License.
 */

package io.reactivex.internal.operators.flowable;

import java.util.concurrent.atomic.*;

import org.reactivestreams.*;

import io.reactivex.*;
import io.reactivex.disposables.Disposable;
import io.reactivex.exceptions.*;
import io.reactivex.flowables.ConnectableFlowable;
import io.reactivex.functions.Consumer;
import io.reactivex.internal.fuseable.*;
import io.reactivex.internal.queue.SpscArrayQueue;
import io.reactivex.internal.subscriptions.SubscriptionHelper;
import io.reactivex.internal.util.*;
import io.reactivex.plugins.RxJavaPlugins;

/**
 * A connectable observable which shares an underlying source and dispatches source values to subscribers in a backpressure-aware
 * manner.
 * @param &lt;T&gt; the value type
 */
public final class FlowablePublish&lt;T&gt; extends ConnectableFlowable&lt;T&gt; implements HasUpstreamPublisher&lt;T&gt; {
    /**
     * Indicates this child has been cancelled: the state is swapped in atomically and
     * will prevent the dispatch() to emit (too many) values to a terminated child subscriber.
     */
    static final long CANCELLED = Long.MIN_VALUE;

    /** The source observable. */
    final Flowable&lt;T&gt; source;
    /** Holds the current subscriber that is, will be or just was subscribed to the source observable. */
    final AtomicReference&lt;PublishSubscriber&lt;T&gt;&gt; current;

    /** The size of the prefetch buffer. */
    final int bufferSize;

    final Publisher&lt;T&gt; onSubscribe;

    /**
     * Creates a OperatorPublish instance to publish values of the given source observable.
     * @param &lt;T&gt; the source value type
     * @param source the source observable
     * @param bufferSize the size of the prefetch buffer
     * @return the connectable observable
     */
    public static &lt;T&gt; ConnectableFlowable&lt;T&gt; create(Flowable&lt;T&gt; source, final int bufferSize) {
        // the current connection to source needs to be shared between the operator and its onSubscribe call
<span class="fc" id="L62">        final AtomicReference&lt;PublishSubscriber&lt;T&gt;&gt; curr = new AtomicReference&lt;PublishSubscriber&lt;T&gt;&gt;();</span>
<span class="fc" id="L63">        Publisher&lt;T&gt; onSubscribe = new FlowablePublisher&lt;T&gt;(curr, bufferSize);</span>
<span class="fc" id="L64">        return RxJavaPlugins.onAssembly(new FlowablePublish&lt;T&gt;(onSubscribe, source, curr, bufferSize));</span>
    }

    private FlowablePublish(Publisher&lt;T&gt; onSubscribe, Flowable&lt;T&gt; source,
<span class="fc" id="L68">            final AtomicReference&lt;PublishSubscriber&lt;T&gt;&gt; current, int bufferSize) {</span>
<span class="fc" id="L69">        this.onSubscribe = onSubscribe;</span>
<span class="fc" id="L70">        this.source = source;</span>
<span class="fc" id="L71">        this.current = current;</span>
<span class="fc" id="L72">        this.bufferSize = bufferSize;</span>
<span class="fc" id="L73">    }</span>

    @Override
    public Publisher&lt;T&gt; source() {
<span class="fc" id="L77">        return source;</span>
    }

    @Override
    protected void subscribeActual(Subscriber&lt;? super T&gt; s) {
<span class="fc" id="L82">        onSubscribe.subscribe(s);</span>
<span class="fc" id="L83">    }</span>

    @Override
    public void connect(Consumer&lt;? super Disposable&gt; connection) {
        boolean doConnect;
        PublishSubscriber&lt;T&gt; ps;
        // we loop because concurrent connect/disconnect and termination may change the state
        for (;;) {
            // retrieve the current subscriber-to-source instance
<span class="fc" id="L92">            ps = current.get();</span>
            // if there is none yet or the current has been disposed
<span class="fc bfc" id="L94" title="All 4 branches covered.">            if (ps == null || ps.isDisposed()) {</span>
                // create a new subscriber-to-source
<span class="fc" id="L96">                PublishSubscriber&lt;T&gt; u = new PublishSubscriber&lt;T&gt;(current, bufferSize);</span>
                // try setting it as the current subscriber-to-source
<span class="fc bfc" id="L98" title="All 2 branches covered.">                if (!current.compareAndSet(ps, u)) {</span>
                    // did not work, perhaps a new subscriber arrived
                    // and created a new subscriber-to-source as well, retry
<span class="fc" id="L101">                    continue;</span>
                }
<span class="fc" id="L103">                ps = u;</span>
            }
            // if connect() was called concurrently, only one of them should actually
            // connect to the source
<span class="fc bfc" id="L107" title="All 4 branches covered.">            doConnect = !ps.shouldConnect.get() &amp;&amp; ps.shouldConnect.compareAndSet(false, true);</span>
<span class="fc" id="L108">            break; // NOPMD</span>
        }
        /*
         * Notify the callback that we have a (new) connection which it can dispose
         * but since ps is unique to a connection, multiple calls to connect() will return the
         * same Subscription and even if there was a connect-disconnect-connect pair, the older
         * references won't disconnect the newer connection.
         * Synchronous source consumers have the opportunity to disconnect via dispose on the
         * Disposable as subscribe() may never return on its own.
         *
         * Note however, that asynchronously disconnecting a running source might leave
         * child subscribers without any terminal event; PublishProcessor does not have this
         * issue because the cancellation was always triggered by the child subscribers
         * themselves.
         */
        try {
<span class="fc" id="L124">            connection.accept(ps);</span>
<span class="fc" id="L125">        } catch (Throwable ex) {</span>
<span class="fc" id="L126">            Exceptions.throwIfFatal(ex);</span>
<span class="fc" id="L127">            throw ExceptionHelper.wrapOrThrow(ex);</span>
<span class="fc" id="L128">        }</span>
<span class="fc bfc" id="L129" title="All 2 branches covered.">        if (doConnect) {</span>
<span class="fc" id="L130">            source.subscribe(ps);</span>
        }
<span class="fc" id="L132">    }</span>

    @SuppressWarnings(&quot;rawtypes&quot;)
    static final class PublishSubscriber&lt;T&gt;
    extends AtomicInteger
    implements FlowableSubscriber&lt;T&gt;, Disposable {
        private static final long serialVersionUID = -202316842419149694L;

        /** Indicates an empty array of inner subscribers. */
<span class="fc" id="L141">        static final InnerSubscriber[] EMPTY = new InnerSubscriber[0];</span>
        /** Indicates a terminated PublishSubscriber. */
<span class="fc" id="L143">        static final InnerSubscriber[] TERMINATED = new InnerSubscriber[0];</span>

        /** Holds onto the current connected PublishSubscriber. */
        final AtomicReference&lt;PublishSubscriber&lt;T&gt;&gt; current;
        /** The prefetch buffer size. */
        final int bufferSize;

        /** Tracks the subscribed InnerSubscribers. */
        final AtomicReference&lt;InnerSubscriber&lt;T&gt;[]&gt; subscribers;
        /**
         * Atomically changed from false to true by connect to make sure the
         * connection is only performed by one thread.
         */
        final AtomicBoolean shouldConnect;

<span class="fc" id="L158">        final AtomicReference&lt;Subscription&gt; upstream = new AtomicReference&lt;Subscription&gt;();</span>

        /** Contains either an onComplete or an onError token from upstream. */
        volatile Object terminalEvent;

        int sourceMode;

        /** Holds notifications from upstream. */
        volatile SimpleQueue&lt;T&gt; queue;

        @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L169">        PublishSubscriber(AtomicReference&lt;PublishSubscriber&lt;T&gt;&gt; current, int bufferSize) {</span>
<span class="fc" id="L170">            this.subscribers = new AtomicReference&lt;InnerSubscriber&lt;T&gt;[]&gt;(EMPTY);</span>
<span class="fc" id="L171">            this.current = current;</span>
<span class="fc" id="L172">            this.shouldConnect = new AtomicBoolean();</span>
<span class="fc" id="L173">            this.bufferSize = bufferSize;</span>
<span class="fc" id="L174">        }</span>

        @Override
        public void dispose() {
<span class="fc bfc" id="L178" title="All 2 branches covered.">            if (subscribers.get() != TERMINATED) {</span>
                @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L180">                InnerSubscriber[] ps = subscribers.getAndSet(TERMINATED);</span>
<span class="fc bfc" id="L181" title="All 2 branches covered.">                if (ps != TERMINATED) {</span>
<span class="fc" id="L182">                    current.compareAndSet(PublishSubscriber.this, null);</span>
<span class="fc" id="L183">                    SubscriptionHelper.cancel(upstream);</span>
                }
            }
<span class="fc" id="L186">        }</span>

        @Override
        public boolean isDisposed() {
<span class="fc bfc" id="L190" title="All 2 branches covered.">            return subscribers.get() == TERMINATED;</span>
        }

        @Override
        public void onSubscribe(Subscription s) {
<span class="fc bfc" id="L195" title="All 2 branches covered.">            if (SubscriptionHelper.setOnce(this.upstream, s)) {</span>
<span class="fc bfc" id="L196" title="All 2 branches covered.">                if (s instanceof QueueSubscription) {</span>
                    @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L198">                    QueueSubscription&lt;T&gt; qs = (QueueSubscription&lt;T&gt;) s;</span>

<span class="fc" id="L200">                    int m = qs.requestFusion(QueueSubscription.ANY | QueueSubscription.BOUNDARY);</span>
<span class="fc bfc" id="L201" title="All 2 branches covered.">                    if (m == QueueSubscription.SYNC) {</span>
<span class="fc" id="L202">                        sourceMode = m;</span>
<span class="fc" id="L203">                        queue = qs;</span>
<span class="fc" id="L204">                        terminalEvent = NotificationLite.complete();</span>
<span class="fc" id="L205">                        dispatch();</span>
<span class="fc" id="L206">                        return;</span>
                    }
<span class="fc bfc" id="L208" title="All 2 branches covered.">                    if (m == QueueSubscription.ASYNC) {</span>
<span class="fc" id="L209">                        sourceMode = m;</span>
<span class="fc" id="L210">                        queue = qs;</span>
<span class="fc" id="L211">                        s.request(bufferSize);</span>
<span class="fc" id="L212">                        return;</span>
                    }
                }

<span class="fc" id="L216">                queue = new SpscArrayQueue&lt;T&gt;(bufferSize);</span>

<span class="fc" id="L218">                s.request(bufferSize);</span>
            }
<span class="fc" id="L220">        }</span>

        @Override
        public void onNext(T t) {
            // we expect upstream to honor backpressure requests
<span class="fc bfc" id="L225" title="All 4 branches covered.">            if (sourceMode == QueueSubscription.NONE &amp;&amp; !queue.offer(t)) {</span>
<span class="fc" id="L226">                onError(new MissingBackpressureException(&quot;Prefetch queue is full?!&quot;));</span>
<span class="fc" id="L227">                return;</span>
            }
            // since many things can happen concurrently, we have a common dispatch
            // loop to act on the current state serially
<span class="fc" id="L231">            dispatch();</span>
<span class="fc" id="L232">        }</span>

        @Override
        public void onError(Throwable e) {
            // The observer front is accessed serially as required by spec so
            // no need to CAS in the terminal value
<span class="fc bfc" id="L238" title="All 2 branches covered.">            if (terminalEvent == null) {</span>
<span class="fc" id="L239">                terminalEvent = NotificationLite.error(e);</span>
                // since many things can happen concurrently, we have a common dispatch
                // loop to act on the current state serially
<span class="fc" id="L242">                dispatch();</span>
            } else {
<span class="fc" id="L244">                RxJavaPlugins.onError(e);</span>
            }
<span class="fc" id="L246">        }</span>

        @Override
        public void onComplete() {
            // The observer front is accessed serially as required by spec so
            // no need to CAS in the terminal value
<span class="fc bfc" id="L252" title="All 2 branches covered.">            if (terminalEvent == null) {</span>
<span class="fc" id="L253">                terminalEvent = NotificationLite.complete();</span>
                // since many things can happen concurrently, we have a common dispatch loop
                // to act on the current state serially
<span class="fc" id="L256">                dispatch();</span>
            }
<span class="fc" id="L258">        }</span>

        /**
         * Atomically try adding a new InnerSubscriber to this Subscriber or return false if this
         * Subscriber was terminated.
         * @param producer the producer to add
         * @return true if succeeded, false otherwise
         */
        boolean add(InnerSubscriber&lt;T&gt; producer) {
            // the state can change so we do a CAS loop to achieve atomicity
            for (;;) {
                // get the current producer array
<span class="fc" id="L270">                InnerSubscriber&lt;T&gt;[] c = subscribers.get();</span>
                // if this subscriber-to-source reached a terminal state by receiving
                // an onError or onComplete, just refuse to add the new producer
<span class="fc bfc" id="L273" title="All 2 branches covered.">                if (c == TERMINATED) {</span>
<span class="fc" id="L274">                    return false;</span>
                }
                // we perform a copy-on-write logic
<span class="fc" id="L277">                int len = c.length;</span>
                @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L279">                InnerSubscriber&lt;T&gt;[] u = new InnerSubscriber[len + 1];</span>
<span class="fc" id="L280">                System.arraycopy(c, 0, u, 0, len);</span>
<span class="fc" id="L281">                u[len] = producer;</span>
                // try setting the subscribers array
<span class="fc bfc" id="L283" title="All 2 branches covered.">                if (subscribers.compareAndSet(c, u)) {</span>
<span class="fc" id="L284">                    return true;</span>
                }
                // if failed, some other operation succeeded (another add, remove or termination)
                // so retry
<span class="fc" id="L288">            }</span>
        }

        /**
         * Atomically removes the given InnerSubscriber from the subscribers array.
         * @param producer the producer to remove
         */
        @SuppressWarnings(&quot;unchecked&quot;)
        void remove(InnerSubscriber&lt;T&gt; producer) {
            // the state can change so we do a CAS loop to achieve atomicity
            for (;;) {
                // let's read the current subscribers array
<span class="fc" id="L300">                InnerSubscriber&lt;T&gt;[] c = subscribers.get();</span>
<span class="fc" id="L301">                int len = c.length;</span>
                // if it is either empty or terminated, there is nothing to remove so we quit
<span class="pc bpc" id="L303" title="1 of 2 branches missed.">                if (len == 0) {</span>
<span class="nc" id="L304">                    break;</span>
                }
                // let's find the supplied producer in the array
                // although this is O(n), we don't expect too many child subscribers in general
<span class="fc" id="L308">                int j = -1;</span>
<span class="fc bfc" id="L309" title="All 2 branches covered.">                for (int i = 0; i &lt; len; i++) {</span>
<span class="fc bfc" id="L310" title="All 2 branches covered.">                    if (c[i].equals(producer)) {</span>
<span class="fc" id="L311">                        j = i;</span>
<span class="fc" id="L312">                        break;</span>
                    }
                }
                // we didn't find it so just quit
<span class="fc bfc" id="L316" title="All 2 branches covered.">                if (j &lt; 0) {</span>
<span class="fc" id="L317">                    return;</span>
                }
                // we do copy-on-write logic here
                InnerSubscriber&lt;T&gt;[] u;
                // we don't create a new empty array if producer was the single inhabitant
                // but rather reuse an empty array
<span class="fc bfc" id="L323" title="All 2 branches covered.">                if (len == 1) {</span>
<span class="fc" id="L324">                    u = EMPTY;</span>
                } else {
                    // otherwise, create a new array one less in size
<span class="fc" id="L327">                    u = new InnerSubscriber[len - 1];</span>
                    // copy elements being before the given producer
<span class="fc" id="L329">                    System.arraycopy(c, 0, u, 0, j);</span>
                    // copy elements being after the given producer
<span class="fc" id="L331">                    System.arraycopy(c, j + 1, u, j, len - j - 1);</span>
                }
                // try setting this new array as
<span class="fc bfc" id="L334" title="All 2 branches covered.">                if (subscribers.compareAndSet(c, u)) {</span>
<span class="fc" id="L335">                    break;</span>
                }
                // if we failed, it means something else happened
                // (a concurrent add/remove or termination), we need to retry
<span class="fc" id="L339">            }</span>
<span class="fc" id="L340">        }</span>

        /**
         * Perform termination actions in case the source has terminated in some way and
         * the queue has also become empty.
         * @param term the terminal event (a NotificationLite.error or completed)
         * @param empty set to true if the queue is empty
         * @return true if there is indeed a terminal condition
         */
        @SuppressWarnings(&quot;unchecked&quot;)
        boolean checkTerminated(Object term, boolean empty) {
            // first of all, check if there is actually a terminal event
<span class="fc bfc" id="L352" title="All 2 branches covered.">            if (term != null) {</span>
                // is it a completion event (impl. note, this is much cheaper than checking for isError)
<span class="fc bfc" id="L354" title="All 2 branches covered.">                if (NotificationLite.isComplete(term)) {</span>
                    // but we also need to have an empty queue
<span class="fc bfc" id="L356" title="All 2 branches covered.">                    if (empty) {</span>
                        // this will prevent OnSubscribe spinning on a terminated but
                        // not yet cancelled PublishSubscriber
<span class="fc" id="L359">                        current.compareAndSet(this, null);</span>
                        /*
                         * This will swap in a terminated array so add() in OnSubscribe will reject
                         * child subscribers to associate themselves with a terminated and thus
                         * never again emitting chain.
                         *
                         * Since we atomically change the contents of 'subscribers' only one
                         * operation wins at a time. If an add() wins before this getAndSet,
                         * its value will be part of the returned array by getAndSet and thus
                         * will receive the terminal notification. Otherwise, if getAndSet wins,
                         * add() will refuse to add the child producer and will trigger the
                         * creation of subscriber-to-source.
                         */
<span class="fc bfc" id="L372" title="All 2 branches covered.">                        for (InnerSubscriber&lt;?&gt; ip : subscribers.getAndSet(TERMINATED)) {</span>
<span class="fc" id="L373">                            ip.child.onComplete();</span>
                        }
                        // indicate we reached the terminal state
<span class="fc" id="L376">                        return true;</span>
                    }
                } else {
<span class="fc" id="L379">                    Throwable t = NotificationLite.getError(term);</span>
                    // this will prevent OnSubscribe spinning on a terminated
                    // but not yet cancelled PublishSubscriber
<span class="fc" id="L382">                    current.compareAndSet(this, null);</span>
                    // this will swap in a terminated array so add() in OnSubscribe will reject
                    // child subscribers to associate themselves with a terminated and thus
                    // never again emitting chain
<span class="fc" id="L386">                    InnerSubscriber[] a = subscribers.getAndSet(TERMINATED);</span>
<span class="fc bfc" id="L387" title="All 2 branches covered.">                    if (a.length != 0) {</span>
<span class="fc bfc" id="L388" title="All 2 branches covered.">                        for (InnerSubscriber&lt;?&gt; ip : a) {</span>
<span class="fc" id="L389">                            ip.child.onError(t);</span>
                        }
                    } else {
<span class="fc" id="L392">                        RxJavaPlugins.onError(t);</span>
                    }
                    // indicate we reached the terminal state
<span class="fc" id="L395">                    return true;</span>
                }
            }
            // there is still work to be done
<span class="fc" id="L399">            return false;</span>
        }

        /**
         * The common serialization point of events arriving from upstream and child subscribers
         * requesting more.
         */
        void dispatch() {
            // standard construct of queue-drain
            // if there is an emission going on, indicate that more work needs to be done
            // the exact nature of this work needs to be determined from other data structures
<span class="fc bfc" id="L410" title="All 2 branches covered.">            if (getAndIncrement() != 0) {</span>
<span class="fc" id="L411">                return;</span>
            }
<span class="fc" id="L413">            int missed = 1;</span>

            // saving a local copy because this will be accessed after every item
            // delivered to detect changes in the subscribers due to an onNext
            // and thus not dropping items
<span class="fc" id="L418">            AtomicReference&lt;InnerSubscriber&lt;T&gt;[]&gt; subscribers = this.subscribers;</span>

            // We take a snapshot of the current child subscribers.
            // Concurrent subscribers may miss this iteration, but it is to be expected
<span class="fc" id="L422">            InnerSubscriber&lt;T&gt;[] ps = subscribers.get();</span>

            outer:
            for (;;) {
                /*
                 * We need to read terminalEvent before checking the queue for emptiness because
                 * all enqueue happens before setting the terminal event.
                 * If it were the other way around, when the emission is paused between
                 * checking isEmpty and checking terminalEvent, some other thread might
                 * have produced elements and set the terminalEvent and we'd quit emitting
                 * prematurely.
                 */
<span class="fc" id="L434">                Object term = terminalEvent;</span>
                /*
                 * See if the queue is empty; since we need this information multiple
                 * times later on, we read it one.
                 * Although the queue can become non-empty in the mean time, we will
                 * detect it through the missing flag and will do another iteration.
                 */
<span class="fc" id="L441">                SimpleQueue&lt;T&gt; q = queue;</span>

<span class="fc bfc" id="L443" title="All 4 branches covered.">                boolean empty = q == null || q.isEmpty();</span>
                // if the queue is empty and the terminal event was received, quit
                // and don't bother restoring emitting to false: no further activity is
                // possible at this point
<span class="fc bfc" id="L447" title="All 2 branches covered.">                if (checkTerminated(term, empty)) {</span>
<span class="fc" id="L448">                    return;</span>
                }

                // We have elements queued. Note that due to the serialization nature of dispatch()
                // this loop is the only one which can turn a non-empty queue into an empty one
                // and as such, no need to ask the queue itself again for that.
<span class="fc bfc" id="L454" title="All 2 branches covered.">                if (!empty) {</span>

<span class="fc" id="L456">                    int len = ps.length;</span>
                    // Let's assume everyone requested the maximum value.
<span class="fc" id="L458">                    long maxRequested = Long.MAX_VALUE;</span>
                    // count how many have triggered cancellation
<span class="fc" id="L460">                    int cancelled = 0;</span>

                    // Now find the minimum amount each child-subscriber requested
                    // since we can only emit that much to all of them without violating
                    // backpressure constraints
<span class="fc bfc" id="L465" title="All 2 branches covered.">                    for (InnerSubscriber&lt;T&gt; ip : ps) {</span>
<span class="fc" id="L466">                        long r = ip.get();</span>
                        // if there is one child subscriber that hasn't requested yet
                        // we can't emit anything to anyone
<span class="fc bfc" id="L469" title="All 2 branches covered.">                        if (r != CANCELLED) {</span>
<span class="fc" id="L470">                            maxRequested = Math.min(maxRequested, r - ip.emitted);</span>
                        } else {
<span class="fc" id="L472">                            cancelled++;</span>
                        }
                    }

                    // it may happen everyone has cancelled between here and subscribers.get()
                    // or we have no subscribers at all to begin with
<span class="fc bfc" id="L478" title="All 2 branches covered.">                    if (len == cancelled) {</span>
<span class="fc" id="L479">                        term = terminalEvent;</span>
                        // so let's consume a value from the queue
                        T v;

                        try {
<span class="fc" id="L484">                            v = q.poll();</span>
<span class="fc" id="L485">                        } catch (Throwable ex) {</span>
<span class="fc" id="L486">                            Exceptions.throwIfFatal(ex);</span>
<span class="fc" id="L487">                            upstream.get().cancel();</span>
<span class="fc" id="L488">                            term = NotificationLite.error(ex);</span>
<span class="fc" id="L489">                            terminalEvent = term;</span>
<span class="fc" id="L490">                            v = null;</span>
<span class="fc" id="L491">                        }</span>
                        // or terminate if there was a terminal event and the queue is empty
<span class="fc bfc" id="L493" title="All 4 branches covered.">                        if (checkTerminated(term, v == null)) {</span>
<span class="fc" id="L494">                            return;</span>
                        }
                        // otherwise, just ask for a new value
<span class="fc bfc" id="L497" title="All 2 branches covered.">                        if (sourceMode != QueueSubscription.SYNC) {</span>
<span class="fc" id="L498">                            upstream.get().request(1);</span>
                        }
                        // and retry emitting to potential new child subscribers
                        continue;
                    }
                    // if we get here, it means there are non-cancelled child subscribers
                    // and we count the number of emitted values because the queue
                    // may contain less than requested
<span class="fc" id="L506">                    int d = 0;</span>
<span class="fc bfc" id="L507" title="All 2 branches covered.">                    while (d &lt; maxRequested) {</span>
<span class="fc" id="L508">                        term = terminalEvent;</span>
                        T v;

                        try {
<span class="fc" id="L512">                            v = q.poll();</span>
<span class="fc" id="L513">                        } catch (Throwable ex) {</span>
<span class="fc" id="L514">                            Exceptions.throwIfFatal(ex);</span>
<span class="fc" id="L515">                            upstream.get().cancel();</span>
<span class="fc" id="L516">                            term = NotificationLite.error(ex);</span>
<span class="fc" id="L517">                            terminalEvent = term;</span>
<span class="fc" id="L518">                            v = null;</span>
<span class="fc" id="L519">                        }</span>

<span class="fc bfc" id="L521" title="All 2 branches covered.">                        empty = v == null;</span>
                        // let's check if there is a terminal event and the queue became empty just now
<span class="fc bfc" id="L523" title="All 2 branches covered.">                        if (checkTerminated(term, empty)) {</span>
<span class="fc" id="L524">                            return;</span>
                        }
                        // the queue is empty but we aren't terminated yet, finish this emission loop
<span class="fc bfc" id="L527" title="All 2 branches covered.">                        if (empty) {</span>
<span class="fc" id="L528">                            break;</span>
                        }
                        // we need to unwrap potential nulls
<span class="fc" id="L531">                        T value = NotificationLite.getValue(v);</span>

<span class="fc" id="L533">                        boolean subscribersChanged = false;</span>

                        // let's emit this value to all child subscribers
<span class="fc bfc" id="L536" title="All 2 branches covered.">                        for (InnerSubscriber&lt;T&gt; ip : ps) {</span>
                            // if ip.get() is negative, the child has either cancelled in the
                            // meantime or hasn't requested anything yet
                            // this eager behavior will skip cancelled children in case
                            // multiple values are available in the queue
<span class="fc" id="L541">                            long ipr = ip.get();</span>
<span class="fc bfc" id="L542" title="All 2 branches covered.">                            if (ipr != CANCELLED) {</span>
<span class="fc bfc" id="L543" title="All 2 branches covered.">                                if (ipr != Long.MAX_VALUE) {</span>
                                    // indicate this child has received 1 element
<span class="fc" id="L545">                                    ip.emitted++;</span>
                                }
<span class="fc" id="L547">                                ip.child.onNext(value);</span>
                            } else {
<span class="fc" id="L549">                                subscribersChanged = true;</span>
                            }
                        }
                        // indicate we emitted one element
<span class="fc" id="L553">                        d++;</span>

                        // see if the array of subscribers changed as a consequence
                        // of emission or concurrent activity
<span class="fc" id="L557">                        InnerSubscriber&lt;T&gt;[] freshArray = subscribers.get();</span>
<span class="fc bfc" id="L558" title="All 4 branches covered.">                        if (subscribersChanged || freshArray != ps) {</span>
<span class="fc" id="L559">                            ps = freshArray;</span>

                            // if we did emit at least one element, request more to replenish the queue
<span class="pc bpc" id="L562" title="1 of 2 branches missed.">                            if (d != 0) {</span>
<span class="fc bfc" id="L563" title="All 2 branches covered.">                                if (sourceMode != QueueSubscription.SYNC) {</span>
<span class="fc" id="L564">                                    upstream.get().request(d);</span>
                                }
                            }

                            continue outer;
                        }
<span class="fc" id="L570">                    }</span>

                    // if we did emit at least one element, request more to replenish the queue
<span class="fc bfc" id="L573" title="All 2 branches covered.">                    if (d != 0) {</span>
<span class="fc bfc" id="L574" title="All 2 branches covered.">                        if (sourceMode != QueueSubscription.SYNC) {</span>
<span class="fc" id="L575">                            upstream.get().request(d);</span>
                        }
                    }
                    // if we have requests but not an empty queue after emission
                    // let's try again to see if more requests/child subscribers are
                    // ready to receive more
<span class="fc bfc" id="L581" title="All 4 branches covered.">                    if (maxRequested != 0L &amp;&amp; !empty) {</span>
<span class="fc" id="L582">                        continue;</span>
                    }
                }

<span class="fc" id="L586">                missed = addAndGet(-missed);</span>
<span class="fc bfc" id="L587" title="All 2 branches covered.">                if (missed == 0) {</span>
<span class="fc" id="L588">                    break;</span>
                }

                // get a fresh copy of the current subscribers
<span class="fc" id="L592">                ps = subscribers.get();</span>
<span class="fc" id="L593">            }</span>
<span class="fc" id="L594">        }</span>
    }
    /**
     * A Subscription that manages the request and cancellation state of a
     * child subscriber in thread-safe manner.
     * @param &lt;T&gt; the value type
     */
    static final class InnerSubscriber&lt;T&gt; extends AtomicLong implements Subscription {

        private static final long serialVersionUID = -4453897557930727610L;
        /** The actual child subscriber. */
        final Subscriber&lt;? super T&gt; child;
        /**
         * The parent subscriber-to-source used to allow removing the child in case of
         * child cancellation.
         */
        volatile PublishSubscriber&lt;T&gt; parent;

        /** Track the number of emitted items (avoids decrementing the request counter). */
        long emitted;

<span class="fc" id="L615">        InnerSubscriber(Subscriber&lt;? super T&gt; child) {</span>
<span class="fc" id="L616">            this.child = child;</span>
<span class="fc" id="L617">        }</span>

        @Override
        public void request(long n) {
<span class="fc bfc" id="L621" title="All 2 branches covered.">            if (SubscriptionHelper.validate(n)) {</span>
<span class="fc" id="L622">                BackpressureHelper.addCancel(this, n);</span>
<span class="fc" id="L623">                PublishSubscriber&lt;T&gt; p = parent;</span>
<span class="fc bfc" id="L624" title="All 2 branches covered.">                if (p != null) {</span>
<span class="fc" id="L625">                    p.dispatch();</span>
                }
            }
<span class="fc" id="L628">        }</span>

        @Override
        public void cancel() {
<span class="fc" id="L632">            long r = get();</span>
            // let's see if we are cancelled
<span class="fc bfc" id="L634" title="All 2 branches covered.">            if (r != CANCELLED) {</span>
                // if not, swap in the terminal state, this is idempotent
                // because other methods using CAS won't overwrite this value,
                // concurrent calls to cancel will atomically swap in the same
                // terminal value
<span class="fc" id="L639">                r = getAndSet(CANCELLED);</span>
                // and only one of them will see a non-terminated value before the swap
<span class="pc bpc" id="L641" title="1 of 2 branches missed.">                if (r != CANCELLED) {</span>
<span class="fc" id="L642">                    PublishSubscriber&lt;T&gt; p = parent;</span>
<span class="fc bfc" id="L643" title="All 2 branches covered.">                    if (p != null) {</span>
                        // remove this from the parent
<span class="fc" id="L645">                        p.remove(this);</span>
                        // After removal, we might have unblocked the other child subscribers:
                        // let's assume this child had 0 requested before the cancellation while
                        // the others had non-zero. By removing this 'blocking' child, the others
                        // are now free to receive events
<span class="fc" id="L650">                        p.dispatch();</span>
                    }
                }
            }
<span class="fc" id="L654">        }</span>
    }

    static final class FlowablePublisher&lt;T&gt; implements Publisher&lt;T&gt; {
        private final AtomicReference&lt;PublishSubscriber&lt;T&gt;&gt; curr;
        private final int bufferSize;

<span class="fc" id="L661">        FlowablePublisher(AtomicReference&lt;PublishSubscriber&lt;T&gt;&gt; curr, int bufferSize) {</span>
<span class="fc" id="L662">            this.curr = curr;</span>
<span class="fc" id="L663">            this.bufferSize = bufferSize;</span>
<span class="fc" id="L664">        }</span>

        @Override
        public void subscribe(Subscriber&lt;? super T&gt; child) {
            // create the backpressure-managing producer for this child
<span class="fc" id="L669">            InnerSubscriber&lt;T&gt; inner = new InnerSubscriber&lt;T&gt;(child);</span>
<span class="fc" id="L670">            child.onSubscribe(inner);</span>
            // concurrent connection/disconnection may change the state,
            // we loop to be atomic while the child subscribes
            for (;;) {
                // get the current subscriber-to-source
<span class="fc" id="L675">                PublishSubscriber&lt;T&gt; r = curr.get();</span>
                // if there isn't one or it is cancelled/disposed
<span class="fc bfc" id="L677" title="All 4 branches covered.">                if (r == null || r.isDisposed()) {</span>
                    // create a new subscriber to source
<span class="fc" id="L679">                    PublishSubscriber&lt;T&gt; u = new PublishSubscriber&lt;T&gt;(curr, bufferSize);</span>
                    // let's try setting it as the current subscriber-to-source
<span class="fc bfc" id="L681" title="All 2 branches covered.">                    if (!curr.compareAndSet(r, u)) {</span>
                        // didn't work, maybe someone else did it or the current subscriber
                        // to source has just finished
<span class="fc" id="L684">                        continue;</span>
                    }
                    // we won, let's use it going onwards
<span class="fc" id="L687">                    r = u;</span>
                }

                /*
                 * Try adding it to the current subscriber-to-source, add is atomic in respect
                 * to other adds and the termination of the subscriber-to-source.
                 */
<span class="fc bfc" id="L694" title="All 2 branches covered.">                if (r.add(inner)) {</span>
<span class="fc bfc" id="L695" title="All 2 branches covered.">                    if (inner.get() == CANCELLED) {</span>
<span class="fc" id="L696">                        r.remove(inner);</span>
                    } else {
<span class="fc" id="L698">                        inner.parent = r;</span>
                    }
<span class="fc" id="L700">                    r.dispatch();</span>
<span class="fc" id="L701">                    break; // NOPMD</span>
                }
                /*
                 * The current PublishSubscriber has been terminated, try with a newer one.
                 */
                /*
                 * Note: although technically correct, concurrent disconnects can cause
                 * unexpected behavior such as child subscribers never receiving anything
                 * (unless connected again). An alternative approach, similar to
                 * PublishProcessor would be to immediately terminate such child
                 * subscribers as well:
                 *
                 * Object term = r.terminalEvent;
                 * if (r.nl.isCompleted(term)) {
                 *     child.onComplete();
                 * } else {
                 *     child.onError(r.nl.getError(term));
                 * }
                 * return;
                 *
                 * The original concurrent behavior was non-deterministic in this regard as well.
                 * Allowing this behavior, however, may introduce another unexpected behavior:
                 * after disconnecting a previous connection, one might not be able to prepare
                 * a new connection right after a previous termination by subscribing new child
                 * subscribers asynchronously before a connect call.
                 */
<span class="fc" id="L727">            }</span>
<span class="fc" id="L728">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>