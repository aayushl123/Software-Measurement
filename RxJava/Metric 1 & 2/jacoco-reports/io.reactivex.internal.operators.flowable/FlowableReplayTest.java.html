<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FlowableReplayTest.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">RxJava_2_x$Unnamed.exec</a> &gt; <a href="index.source.html" class="el_package">io.reactivex.internal.operators.flowable</a> &gt; <span class="el_source">FlowableReplayTest.java</span></div><h1>FlowableReplayTest.java</h1><pre class="source lang-java linenums">/**
 * Copyright (c) 2016-present, RxJava Contributors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is
 * distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
 * the License for the specific language governing permissions and limitations under the License.
 */

package io.reactivex.internal.operators.flowable;

import static org.junit.Assert.*;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;

import java.lang.management.*;
import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.*;

import org.junit.*;
import org.mockito.InOrder;
import org.reactivestreams.*;

import io.reactivex.*;
import io.reactivex.Scheduler.Worker;
import io.reactivex.annotations.NonNull;
import io.reactivex.disposables.Disposable;
import io.reactivex.exceptions.TestException;
import io.reactivex.flowables.ConnectableFlowable;
import io.reactivex.functions.*;
import io.reactivex.internal.functions.Functions;
import io.reactivex.internal.fuseable.HasUpstreamPublisher;
import io.reactivex.internal.operators.flowable.FlowableReplay.*;
import io.reactivex.internal.subscriptions.BooleanSubscription;
import io.reactivex.plugins.RxJavaPlugins;
import io.reactivex.processors.PublishProcessor;
import io.reactivex.schedulers.*;
import io.reactivex.subscribers.TestSubscriber;

<span class="fc" id="L45">public class FlowableReplayTest {</span>
    @Test
    public void testBufferedReplay() {
<span class="fc" id="L48">        PublishProcessor&lt;Integer&gt; source = PublishProcessor.create();</span>

<span class="fc" id="L50">        ConnectableFlowable&lt;Integer&gt; cf = source.replay(3);</span>
<span class="fc" id="L51">        cf.connect();</span>

        {
<span class="fc" id="L54">            Subscriber&lt;Object&gt; subscriber1 = TestHelper.mockSubscriber();</span>
<span class="fc" id="L55">            InOrder inOrder = inOrder(subscriber1);</span>

<span class="fc" id="L57">            cf.subscribe(subscriber1);</span>

<span class="fc" id="L59">            source.onNext(1);</span>
<span class="fc" id="L60">            source.onNext(2);</span>
<span class="fc" id="L61">            source.onNext(3);</span>

<span class="fc" id="L63">            inOrder.verify(subscriber1, times(1)).onNext(1);</span>
<span class="fc" id="L64">            inOrder.verify(subscriber1, times(1)).onNext(2);</span>
<span class="fc" id="L65">            inOrder.verify(subscriber1, times(1)).onNext(3);</span>

<span class="fc" id="L67">            source.onNext(4);</span>
<span class="fc" id="L68">            source.onComplete();</span>
<span class="fc" id="L69">            inOrder.verify(subscriber1, times(1)).onNext(4);</span>
<span class="fc" id="L70">            inOrder.verify(subscriber1, times(1)).onComplete();</span>
<span class="fc" id="L71">            inOrder.verifyNoMoreInteractions();</span>
<span class="fc" id="L72">            verify(subscriber1, never()).onError(any(Throwable.class));</span>

        }

        {
<span class="fc" id="L77">            Subscriber&lt;Object&gt; subscriber1 = TestHelper.mockSubscriber();</span>
<span class="fc" id="L78">            InOrder inOrder = inOrder(subscriber1);</span>

<span class="fc" id="L80">            cf.subscribe(subscriber1);</span>

<span class="fc" id="L82">            inOrder.verify(subscriber1, times(1)).onNext(2);</span>
<span class="fc" id="L83">            inOrder.verify(subscriber1, times(1)).onNext(3);</span>
<span class="fc" id="L84">            inOrder.verify(subscriber1, times(1)).onNext(4);</span>
<span class="fc" id="L85">            inOrder.verify(subscriber1, times(1)).onComplete();</span>
<span class="fc" id="L86">            inOrder.verifyNoMoreInteractions();</span>
<span class="fc" id="L87">            verify(subscriber1, never()).onError(any(Throwable.class));</span>
        }
<span class="fc" id="L89">    }</span>

    @Test
    public void testBufferedWindowReplay() {
<span class="fc" id="L93">        PublishProcessor&lt;Integer&gt; source = PublishProcessor.create();</span>
<span class="fc" id="L94">        TestScheduler scheduler = new TestScheduler();</span>
<span class="fc" id="L95">        ConnectableFlowable&lt;Integer&gt; cf = source.replay(3, 100, TimeUnit.MILLISECONDS, scheduler);</span>
<span class="fc" id="L96">        cf.connect();</span>

        {
<span class="fc" id="L99">            Subscriber&lt;Object&gt; subscriber1 = TestHelper.mockSubscriber();</span>
<span class="fc" id="L100">            InOrder inOrder = inOrder(subscriber1);</span>

<span class="fc" id="L102">            cf.subscribe(subscriber1);</span>

<span class="fc" id="L104">            source.onNext(1);</span>
<span class="fc" id="L105">            scheduler.advanceTimeBy(10, TimeUnit.MILLISECONDS);</span>
<span class="fc" id="L106">            source.onNext(2);</span>
<span class="fc" id="L107">            scheduler.advanceTimeBy(10, TimeUnit.MILLISECONDS);</span>
<span class="fc" id="L108">            source.onNext(3);</span>
<span class="fc" id="L109">            scheduler.advanceTimeBy(10, TimeUnit.MILLISECONDS);</span>

<span class="fc" id="L111">            inOrder.verify(subscriber1, times(1)).onNext(1);</span>
<span class="fc" id="L112">            inOrder.verify(subscriber1, times(1)).onNext(2);</span>
<span class="fc" id="L113">            inOrder.verify(subscriber1, times(1)).onNext(3);</span>

<span class="fc" id="L115">            source.onNext(4);</span>
<span class="fc" id="L116">            source.onNext(5);</span>
<span class="fc" id="L117">            scheduler.advanceTimeBy(90, TimeUnit.MILLISECONDS);</span>

<span class="fc" id="L119">            inOrder.verify(subscriber1, times(1)).onNext(4);</span>

<span class="fc" id="L121">            inOrder.verify(subscriber1, times(1)).onNext(5);</span>

<span class="fc" id="L123">            inOrder.verifyNoMoreInteractions();</span>
<span class="fc" id="L124">            verify(subscriber1, never()).onError(any(Throwable.class));</span>

        }

        {
<span class="fc" id="L129">            Subscriber&lt;Object&gt; subscriber1 = TestHelper.mockSubscriber();</span>
<span class="fc" id="L130">            InOrder inOrder = inOrder(subscriber1);</span>

<span class="fc" id="L132">            cf.subscribe(subscriber1);</span>

<span class="fc" id="L134">            inOrder.verify(subscriber1, times(1)).onNext(4);</span>
<span class="fc" id="L135">            inOrder.verify(subscriber1, times(1)).onNext(5);</span>
<span class="fc" id="L136">            inOrder.verifyNoMoreInteractions();</span>
<span class="fc" id="L137">            verify(subscriber1, never()).onError(any(Throwable.class));</span>
        }
<span class="fc" id="L139">    }</span>

    @Test
    public void testWindowedReplay() {
<span class="fc" id="L143">        TestScheduler scheduler = new TestScheduler();</span>

<span class="fc" id="L145">        PublishProcessor&lt;Integer&gt; source = PublishProcessor.create();</span>

<span class="fc" id="L147">        ConnectableFlowable&lt;Integer&gt; cf = source.replay(100, TimeUnit.MILLISECONDS, scheduler);</span>
<span class="fc" id="L148">        cf.connect();</span>

        {
<span class="fc" id="L151">            Subscriber&lt;Object&gt; subscriber1 = TestHelper.mockSubscriber();</span>
<span class="fc" id="L152">            InOrder inOrder = inOrder(subscriber1);</span>

<span class="fc" id="L154">            cf.subscribe(subscriber1);</span>

<span class="fc" id="L156">            source.onNext(1);</span>
<span class="fc" id="L157">            scheduler.advanceTimeBy(60, TimeUnit.MILLISECONDS);</span>
<span class="fc" id="L158">            source.onNext(2);</span>
<span class="fc" id="L159">            scheduler.advanceTimeBy(60, TimeUnit.MILLISECONDS);</span>
<span class="fc" id="L160">            source.onNext(3);</span>
<span class="fc" id="L161">            scheduler.advanceTimeBy(60, TimeUnit.MILLISECONDS);</span>
<span class="fc" id="L162">            source.onComplete();</span>
<span class="fc" id="L163">            scheduler.advanceTimeBy(60, TimeUnit.MILLISECONDS);</span>

<span class="fc" id="L165">            inOrder.verify(subscriber1, times(1)).onNext(1);</span>
<span class="fc" id="L166">            inOrder.verify(subscriber1, times(1)).onNext(2);</span>
<span class="fc" id="L167">            inOrder.verify(subscriber1, times(1)).onNext(3);</span>

<span class="fc" id="L169">            inOrder.verify(subscriber1, times(1)).onComplete();</span>
<span class="fc" id="L170">            inOrder.verifyNoMoreInteractions();</span>
<span class="fc" id="L171">            verify(subscriber1, never()).onError(any(Throwable.class));</span>

        }
        {
<span class="fc" id="L175">            Subscriber&lt;Object&gt; subscriber1 = TestHelper.mockSubscriber();</span>
<span class="fc" id="L176">            InOrder inOrder = inOrder(subscriber1);</span>

<span class="fc" id="L178">            cf.subscribe(subscriber1);</span>
<span class="fc" id="L179">            inOrder.verify(subscriber1, never()).onNext(3);</span>

<span class="fc" id="L181">            inOrder.verify(subscriber1, times(1)).onComplete();</span>
<span class="fc" id="L182">            inOrder.verifyNoMoreInteractions();</span>
<span class="fc" id="L183">            verify(subscriber1, never()).onError(any(Throwable.class));</span>
        }
<span class="fc" id="L185">    }</span>

    @Test
    public void testReplaySelector() {
<span class="fc" id="L189">        final Function&lt;Integer, Integer&gt; dbl = new Function&lt;Integer, Integer&gt;() {</span>

            @Override
            public Integer apply(Integer t1) {
<span class="fc" id="L193">                return t1 * 2;</span>
            }

        };

<span class="fc" id="L198">        Function&lt;Flowable&lt;Integer&gt;, Flowable&lt;Integer&gt;&gt; selector = new Function&lt;Flowable&lt;Integer&gt;, Flowable&lt;Integer&gt;&gt;() {</span>

            @Override
            public Flowable&lt;Integer&gt; apply(Flowable&lt;Integer&gt; t1) {
<span class="fc" id="L202">                return t1.map(dbl);</span>
            }

        };

<span class="fc" id="L207">        PublishProcessor&lt;Integer&gt; source = PublishProcessor.create();</span>

<span class="fc" id="L209">        Flowable&lt;Integer&gt; co = source.replay(selector);</span>

        {
<span class="fc" id="L212">            Subscriber&lt;Object&gt; subscriber1 = TestHelper.mockSubscriber();</span>
<span class="fc" id="L213">            InOrder inOrder = inOrder(subscriber1);</span>

<span class="fc" id="L215">            co.subscribe(subscriber1);</span>

<span class="fc" id="L217">            source.onNext(1);</span>
<span class="fc" id="L218">            source.onNext(2);</span>
<span class="fc" id="L219">            source.onNext(3);</span>

<span class="fc" id="L221">            inOrder.verify(subscriber1, times(1)).onNext(2);</span>
<span class="fc" id="L222">            inOrder.verify(subscriber1, times(1)).onNext(4);</span>
<span class="fc" id="L223">            inOrder.verify(subscriber1, times(1)).onNext(6);</span>

<span class="fc" id="L225">            source.onNext(4);</span>
<span class="fc" id="L226">            source.onComplete();</span>
<span class="fc" id="L227">            inOrder.verify(subscriber1, times(1)).onNext(8);</span>
<span class="fc" id="L228">            inOrder.verify(subscriber1, times(1)).onComplete();</span>
<span class="fc" id="L229">            inOrder.verifyNoMoreInteractions();</span>
<span class="fc" id="L230">            verify(subscriber1, never()).onError(any(Throwable.class));</span>

        }

        {
<span class="fc" id="L235">            Subscriber&lt;Object&gt; subscriber1 = TestHelper.mockSubscriber();</span>
<span class="fc" id="L236">            InOrder inOrder = inOrder(subscriber1);</span>

<span class="fc" id="L238">            co.subscribe(subscriber1);</span>

<span class="fc" id="L240">            inOrder.verify(subscriber1, times(1)).onComplete();</span>
<span class="fc" id="L241">            inOrder.verifyNoMoreInteractions();</span>
<span class="fc" id="L242">            verify(subscriber1, never()).onError(any(Throwable.class));</span>

        }

<span class="fc" id="L246">    }</span>

    @Test
    public void testBufferedReplaySelector() {

<span class="fc" id="L251">        final Function&lt;Integer, Integer&gt; dbl = new Function&lt;Integer, Integer&gt;() {</span>

            @Override
            public Integer apply(Integer t1) {
<span class="fc" id="L255">                return t1 * 2;</span>
            }

        };

<span class="fc" id="L260">        Function&lt;Flowable&lt;Integer&gt;, Flowable&lt;Integer&gt;&gt; selector = new Function&lt;Flowable&lt;Integer&gt;, Flowable&lt;Integer&gt;&gt;() {</span>

            @Override
            public Flowable&lt;Integer&gt; apply(Flowable&lt;Integer&gt; t1) {
<span class="fc" id="L264">                return t1.map(dbl);</span>
            }

        };

<span class="fc" id="L269">        PublishProcessor&lt;Integer&gt; source = PublishProcessor.create();</span>

<span class="fc" id="L271">        Flowable&lt;Integer&gt; co = source.replay(selector, 3);</span>

        {
<span class="fc" id="L274">            Subscriber&lt;Object&gt; subscriber1 = TestHelper.mockSubscriber();</span>
<span class="fc" id="L275">            InOrder inOrder = inOrder(subscriber1);</span>

<span class="fc" id="L277">            co.subscribe(subscriber1);</span>

<span class="fc" id="L279">            source.onNext(1);</span>
<span class="fc" id="L280">            source.onNext(2);</span>
<span class="fc" id="L281">            source.onNext(3);</span>

<span class="fc" id="L283">            inOrder.verify(subscriber1, times(1)).onNext(2);</span>
<span class="fc" id="L284">            inOrder.verify(subscriber1, times(1)).onNext(4);</span>
<span class="fc" id="L285">            inOrder.verify(subscriber1, times(1)).onNext(6);</span>

<span class="fc" id="L287">            source.onNext(4);</span>
<span class="fc" id="L288">            source.onComplete();</span>
<span class="fc" id="L289">            inOrder.verify(subscriber1, times(1)).onNext(8);</span>
<span class="fc" id="L290">            inOrder.verify(subscriber1, times(1)).onComplete();</span>
<span class="fc" id="L291">            inOrder.verifyNoMoreInteractions();</span>
<span class="fc" id="L292">            verify(subscriber1, never()).onError(any(Throwable.class));</span>

        }

        {
<span class="fc" id="L297">            Subscriber&lt;Object&gt; subscriber1 = TestHelper.mockSubscriber();</span>
<span class="fc" id="L298">            InOrder inOrder = inOrder(subscriber1);</span>

<span class="fc" id="L300">            co.subscribe(subscriber1);</span>

<span class="fc" id="L302">            inOrder.verify(subscriber1, times(1)).onComplete();</span>
<span class="fc" id="L303">            inOrder.verifyNoMoreInteractions();</span>
<span class="fc" id="L304">            verify(subscriber1, never()).onError(any(Throwable.class));</span>
        }
<span class="fc" id="L306">    }</span>

    @Test
    public void testWindowedReplaySelector() {

<span class="fc" id="L311">        final Function&lt;Integer, Integer&gt; dbl = new Function&lt;Integer, Integer&gt;() {</span>

            @Override
            public Integer apply(Integer t1) {
<span class="fc" id="L315">                return t1 * 2;</span>
            }

        };

<span class="fc" id="L320">        Function&lt;Flowable&lt;Integer&gt;, Flowable&lt;Integer&gt;&gt; selector = new Function&lt;Flowable&lt;Integer&gt;, Flowable&lt;Integer&gt;&gt;() {</span>

            @Override
            public Flowable&lt;Integer&gt; apply(Flowable&lt;Integer&gt; t1) {
<span class="fc" id="L324">                return t1.map(dbl);</span>
            }

        };

<span class="fc" id="L329">        TestScheduler scheduler = new TestScheduler();</span>

<span class="fc" id="L331">        PublishProcessor&lt;Integer&gt; source = PublishProcessor.create();</span>

<span class="fc" id="L333">        Flowable&lt;Integer&gt; co = source.replay(selector, 100, TimeUnit.MILLISECONDS, scheduler);</span>

        {
<span class="fc" id="L336">            Subscriber&lt;Object&gt; subscriber1 = TestHelper.mockSubscriber();</span>
<span class="fc" id="L337">            InOrder inOrder = inOrder(subscriber1);</span>

<span class="fc" id="L339">            co.subscribe(subscriber1);</span>

<span class="fc" id="L341">            source.onNext(1);</span>
<span class="fc" id="L342">            scheduler.advanceTimeBy(60, TimeUnit.MILLISECONDS);</span>
<span class="fc" id="L343">            source.onNext(2);</span>
<span class="fc" id="L344">            scheduler.advanceTimeBy(60, TimeUnit.MILLISECONDS);</span>
<span class="fc" id="L345">            source.onNext(3);</span>
<span class="fc" id="L346">            scheduler.advanceTimeBy(60, TimeUnit.MILLISECONDS);</span>
<span class="fc" id="L347">            source.onComplete();</span>
<span class="fc" id="L348">            scheduler.advanceTimeBy(60, TimeUnit.MILLISECONDS);</span>

<span class="fc" id="L350">            inOrder.verify(subscriber1, times(1)).onNext(2);</span>
<span class="fc" id="L351">            inOrder.verify(subscriber1, times(1)).onNext(4);</span>
<span class="fc" id="L352">            inOrder.verify(subscriber1, times(1)).onNext(6);</span>

<span class="fc" id="L354">            inOrder.verify(subscriber1, times(1)).onComplete();</span>
<span class="fc" id="L355">            inOrder.verifyNoMoreInteractions();</span>
<span class="fc" id="L356">            verify(subscriber1, never()).onError(any(Throwable.class));</span>

        }
        {
<span class="fc" id="L360">            Subscriber&lt;Object&gt; subscriber1 = TestHelper.mockSubscriber();</span>
<span class="fc" id="L361">            InOrder inOrder = inOrder(subscriber1);</span>

<span class="fc" id="L363">            co.subscribe(subscriber1);</span>

<span class="fc" id="L365">            inOrder.verify(subscriber1, times(1)).onComplete();</span>
<span class="fc" id="L366">            inOrder.verifyNoMoreInteractions();</span>
<span class="fc" id="L367">            verify(subscriber1, never()).onError(any(Throwable.class));</span>
        }
<span class="fc" id="L369">    }</span>

    @Test
    public void testBufferedReplayError() {
<span class="fc" id="L373">        PublishProcessor&lt;Integer&gt; source = PublishProcessor.create();</span>

<span class="fc" id="L375">        ConnectableFlowable&lt;Integer&gt; cf = source.replay(3);</span>
<span class="fc" id="L376">        cf.connect();</span>

        {
<span class="fc" id="L379">            Subscriber&lt;Object&gt; subscriber1 = TestHelper.mockSubscriber();</span>
<span class="fc" id="L380">            InOrder inOrder = inOrder(subscriber1);</span>

<span class="fc" id="L382">            cf.subscribe(subscriber1);</span>

<span class="fc" id="L384">            source.onNext(1);</span>
<span class="fc" id="L385">            source.onNext(2);</span>
<span class="fc" id="L386">            source.onNext(3);</span>

<span class="fc" id="L388">            inOrder.verify(subscriber1, times(1)).onNext(1);</span>
<span class="fc" id="L389">            inOrder.verify(subscriber1, times(1)).onNext(2);</span>
<span class="fc" id="L390">            inOrder.verify(subscriber1, times(1)).onNext(3);</span>

<span class="fc" id="L392">            source.onNext(4);</span>
<span class="fc" id="L393">            source.onError(new RuntimeException(&quot;Forced failure&quot;));</span>

<span class="fc" id="L395">            inOrder.verify(subscriber1, times(1)).onNext(4);</span>
<span class="fc" id="L396">            inOrder.verify(subscriber1, times(1)).onError(any(RuntimeException.class));</span>
<span class="fc" id="L397">            inOrder.verifyNoMoreInteractions();</span>
<span class="fc" id="L398">            verify(subscriber1, never()).onComplete();</span>

        }

        {
<span class="fc" id="L403">            Subscriber&lt;Object&gt; subscriber1 = TestHelper.mockSubscriber();</span>
<span class="fc" id="L404">            InOrder inOrder = inOrder(subscriber1);</span>

<span class="fc" id="L406">            cf.subscribe(subscriber1);</span>

<span class="fc" id="L408">            inOrder.verify(subscriber1, times(1)).onNext(2);</span>
<span class="fc" id="L409">            inOrder.verify(subscriber1, times(1)).onNext(3);</span>
<span class="fc" id="L410">            inOrder.verify(subscriber1, times(1)).onNext(4);</span>
<span class="fc" id="L411">            inOrder.verify(subscriber1, times(1)).onError(any(RuntimeException.class));</span>
<span class="fc" id="L412">            inOrder.verifyNoMoreInteractions();</span>
<span class="fc" id="L413">            verify(subscriber1, never()).onComplete();</span>
        }
<span class="fc" id="L415">    }</span>

    @Test
    public void testWindowedReplayError() {
<span class="fc" id="L419">        TestScheduler scheduler = new TestScheduler();</span>

<span class="fc" id="L421">        PublishProcessor&lt;Integer&gt; source = PublishProcessor.create();</span>

<span class="fc" id="L423">        ConnectableFlowable&lt;Integer&gt; cf = source.replay(100, TimeUnit.MILLISECONDS, scheduler);</span>
<span class="fc" id="L424">        cf.connect();</span>

        {
<span class="fc" id="L427">            Subscriber&lt;Object&gt; subscriber1 = TestHelper.mockSubscriber();</span>
<span class="fc" id="L428">            InOrder inOrder = inOrder(subscriber1);</span>

<span class="fc" id="L430">            cf.subscribe(subscriber1);</span>

<span class="fc" id="L432">            source.onNext(1);</span>
<span class="fc" id="L433">            scheduler.advanceTimeBy(60, TimeUnit.MILLISECONDS);</span>
<span class="fc" id="L434">            source.onNext(2);</span>
<span class="fc" id="L435">            scheduler.advanceTimeBy(60, TimeUnit.MILLISECONDS);</span>
<span class="fc" id="L436">            source.onNext(3);</span>
<span class="fc" id="L437">            scheduler.advanceTimeBy(60, TimeUnit.MILLISECONDS);</span>
<span class="fc" id="L438">            source.onError(new RuntimeException(&quot;Forced failure&quot;));</span>
<span class="fc" id="L439">            scheduler.advanceTimeBy(60, TimeUnit.MILLISECONDS);</span>

<span class="fc" id="L441">            inOrder.verify(subscriber1, times(1)).onNext(1);</span>
<span class="fc" id="L442">            inOrder.verify(subscriber1, times(1)).onNext(2);</span>
<span class="fc" id="L443">            inOrder.verify(subscriber1, times(1)).onNext(3);</span>

<span class="fc" id="L445">            inOrder.verify(subscriber1, times(1)).onError(any(RuntimeException.class));</span>
<span class="fc" id="L446">            inOrder.verifyNoMoreInteractions();</span>
<span class="fc" id="L447">            verify(subscriber1, never()).onComplete();</span>

        }
        {
<span class="fc" id="L451">            Subscriber&lt;Object&gt; subscriber1 = TestHelper.mockSubscriber();</span>
<span class="fc" id="L452">            InOrder inOrder = inOrder(subscriber1);</span>

<span class="fc" id="L454">            cf.subscribe(subscriber1);</span>
<span class="fc" id="L455">            inOrder.verify(subscriber1, never()).onNext(3);</span>

<span class="fc" id="L457">            inOrder.verify(subscriber1, times(1)).onError(any(RuntimeException.class));</span>
<span class="fc" id="L458">            inOrder.verifyNoMoreInteractions();</span>
<span class="fc" id="L459">            verify(subscriber1, never()).onComplete();</span>
        }
<span class="fc" id="L461">    }</span>

    @Test
    public void testSynchronousDisconnect() {
<span class="fc" id="L465">        final AtomicInteger effectCounter = new AtomicInteger();</span>
<span class="fc" id="L466">        Flowable&lt;Integer&gt; source = Flowable.just(1, 2, 3, 4)</span>
<span class="fc" id="L467">        .doOnNext(new Consumer&lt;Integer&gt;() {</span>
            @Override
            public void accept(Integer v) {
<span class="fc" id="L470">                effectCounter.incrementAndGet();</span>
<span class="fc" id="L471">                System.out.println(&quot;Sideeffect #&quot; + v);</span>
<span class="fc" id="L472">            }</span>
        });

<span class="fc" id="L475">        Flowable&lt;Integer&gt; result = source.replay(</span>
<span class="fc" id="L476">        new Function&lt;Flowable&lt;Integer&gt;, Flowable&lt;Integer&gt;&gt;() {</span>
            @Override
            public Flowable&lt;Integer&gt; apply(Flowable&lt;Integer&gt; f) {
<span class="fc" id="L479">                return f.take(2);</span>
            }
        });

<span class="fc bfc" id="L483" title="All 2 branches covered.">        for (int i = 1; i &lt; 3; i++) {</span>
<span class="fc" id="L484">            effectCounter.set(0);</span>
<span class="fc" id="L485">            System.out.printf(&quot;- %d -%n&quot;, i);</span>
<span class="fc" id="L486">            result.subscribe(new Consumer&lt;Integer&gt;() {</span>

                @Override
                public void accept(Integer t1) {
<span class="fc" id="L490">                    System.out.println(t1);</span>
<span class="fc" id="L491">                }</span>

<span class="fc" id="L493">            }, new Consumer&lt;Throwable&gt;() {</span>

                @Override
                public void accept(Throwable t1) {
<span class="nc" id="L497">                    t1.printStackTrace();</span>
<span class="nc" id="L498">                }</span>
            },
<span class="fc" id="L500">            new Action() {</span>
                @Override
                public void run() {
<span class="fc" id="L503">                    System.out.println(&quot;Done&quot;);</span>
<span class="fc" id="L504">                }</span>
            });
<span class="fc" id="L506">            assertEquals(2, effectCounter.get());</span>
        }
<span class="fc" id="L508">    }</span>

    /*
     * test the basic expectation of OperatorMulticast via replay
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void testIssue2191_UnsubscribeSource() throws Exception {
        // setup mocks
<span class="fc" id="L517">        Consumer&lt;Integer&gt; sourceNext = mock(Consumer.class);</span>
<span class="fc" id="L518">        Action sourceCompleted = mock(Action.class);</span>
<span class="fc" id="L519">        Action sourceUnsubscribed = mock(Action.class);</span>
<span class="fc" id="L520">        Subscriber&lt;Integer&gt; spiedSubscriberBeforeConnect = TestHelper.mockSubscriber();</span>
<span class="fc" id="L521">        Subscriber&lt;Integer&gt; spiedSubscriberAfterConnect = TestHelper.mockSubscriber();</span>

        // Flowable under test
<span class="fc" id="L524">        Flowable&lt;Integer&gt; source = Flowable.just(1, 2);</span>

<span class="fc" id="L526">        ConnectableFlowable&lt;Integer&gt; replay = source</span>
<span class="fc" id="L527">                .doOnNext(sourceNext)</span>
<span class="fc" id="L528">                .doOnCancel(sourceUnsubscribed)</span>
<span class="fc" id="L529">                .doOnComplete(sourceCompleted)</span>
<span class="fc" id="L530">                .replay();</span>

<span class="fc" id="L532">        replay.subscribe(spiedSubscriberBeforeConnect);</span>
<span class="fc" id="L533">        replay.subscribe(spiedSubscriberBeforeConnect);</span>
<span class="fc" id="L534">        replay.connect();</span>
<span class="fc" id="L535">        replay.subscribe(spiedSubscriberAfterConnect);</span>
<span class="fc" id="L536">        replay.subscribe(spiedSubscriberAfterConnect);</span>

<span class="fc" id="L538">        verify(spiedSubscriberBeforeConnect, times(2)).onSubscribe((Subscription)any());</span>
<span class="fc" id="L539">        verify(spiedSubscriberAfterConnect, times(2)).onSubscribe((Subscription)any());</span>

        // verify interactions
<span class="fc" id="L542">        verify(sourceNext, times(1)).accept(1);</span>
<span class="fc" id="L543">        verify(sourceNext, times(1)).accept(2);</span>
<span class="fc" id="L544">        verify(sourceCompleted, times(1)).run();</span>
<span class="fc" id="L545">        verifyObserverMock(spiedSubscriberBeforeConnect, 2, 4);</span>
<span class="fc" id="L546">        verifyObserverMock(spiedSubscriberAfterConnect, 2, 4);</span>

<span class="fc" id="L548">        verify(sourceUnsubscribed, never()).run();</span>

<span class="fc" id="L550">        verifyNoMoreInteractions(sourceNext);</span>
<span class="fc" id="L551">        verifyNoMoreInteractions(sourceCompleted);</span>
<span class="fc" id="L552">        verifyNoMoreInteractions(sourceUnsubscribed);</span>
<span class="fc" id="L553">        verifyNoMoreInteractions(spiedSubscriberBeforeConnect);</span>
<span class="fc" id="L554">        verifyNoMoreInteractions(spiedSubscriberAfterConnect);</span>

<span class="fc" id="L556">    }</span>

    /**
     * Specifically test interaction with a Scheduler with subscribeOn.
     *
     * @throws Exception functional interfaces declare throws Exception
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void testIssue2191_SchedulerUnsubscribe() throws Exception {
        // setup mocks
<span class="fc" id="L567">        Consumer&lt;Integer&gt; sourceNext = mock(Consumer.class);</span>
<span class="fc" id="L568">        Action sourceCompleted = mock(Action.class);</span>
<span class="fc" id="L569">        Action sourceUnsubscribed = mock(Action.class);</span>
<span class="fc" id="L570">        final Scheduler mockScheduler = mock(Scheduler.class);</span>
<span class="fc" id="L571">        final Disposable mockSubscription = mock(Disposable.class);</span>
<span class="fc" id="L572">        Worker spiedWorker = workerSpy(mockSubscription);</span>
<span class="fc" id="L573">        Subscriber&lt;Integer&gt; mockObserverBeforeConnect = TestHelper.mockSubscriber();</span>
<span class="fc" id="L574">        Subscriber&lt;Integer&gt; mockObserverAfterConnect = TestHelper.mockSubscriber();</span>

<span class="fc" id="L576">        when(mockScheduler.createWorker()).thenReturn(spiedWorker);</span>

        // Flowable under test
<span class="fc" id="L579">        ConnectableFlowable&lt;Integer&gt; replay = Flowable.just(1, 2, 3)</span>
<span class="fc" id="L580">                .doOnNext(sourceNext)</span>
<span class="fc" id="L581">                .doOnCancel(sourceUnsubscribed)</span>
<span class="fc" id="L582">                .doOnComplete(sourceCompleted)</span>
<span class="fc" id="L583">                .subscribeOn(mockScheduler).replay();</span>

<span class="fc" id="L585">        replay.subscribe(mockObserverBeforeConnect);</span>
<span class="fc" id="L586">        replay.subscribe(mockObserverBeforeConnect);</span>
<span class="fc" id="L587">        replay.connect();</span>
<span class="fc" id="L588">        replay.subscribe(mockObserverAfterConnect);</span>
<span class="fc" id="L589">        replay.subscribe(mockObserverAfterConnect);</span>

<span class="fc" id="L591">        verify(mockObserverBeforeConnect, times(2)).onSubscribe((Subscription)any());</span>
<span class="fc" id="L592">        verify(mockObserverAfterConnect, times(2)).onSubscribe((Subscription)any());</span>

        // verify interactions
<span class="fc" id="L595">        verify(sourceNext, times(1)).accept(1);</span>
<span class="fc" id="L596">        verify(sourceNext, times(1)).accept(2);</span>
<span class="fc" id="L597">        verify(sourceNext, times(1)).accept(3);</span>
<span class="fc" id="L598">        verify(sourceCompleted, times(1)).run();</span>
<span class="fc" id="L599">        verify(mockScheduler, times(1)).createWorker();</span>
<span class="fc" id="L600">        verify(spiedWorker, times(1)).schedule((Runnable)notNull());</span>
<span class="fc" id="L601">        verifyObserverMock(mockObserverBeforeConnect, 2, 6);</span>
<span class="fc" id="L602">        verifyObserverMock(mockObserverAfterConnect, 2, 6);</span>

        // FIXME publish calls cancel too
<span class="fc" id="L605">        verify(spiedWorker, times(1)).dispose();</span>
<span class="fc" id="L606">        verify(sourceUnsubscribed, never()).run();</span>

<span class="fc" id="L608">        verifyNoMoreInteractions(sourceNext);</span>
<span class="fc" id="L609">        verifyNoMoreInteractions(sourceCompleted);</span>
<span class="fc" id="L610">        verifyNoMoreInteractions(sourceUnsubscribed);</span>
<span class="fc" id="L611">        verifyNoMoreInteractions(spiedWorker);</span>
<span class="fc" id="L612">        verifyNoMoreInteractions(mockSubscription);</span>
<span class="fc" id="L613">        verifyNoMoreInteractions(mockScheduler);</span>
<span class="fc" id="L614">        verifyNoMoreInteractions(mockObserverBeforeConnect);</span>
<span class="fc" id="L615">        verifyNoMoreInteractions(mockObserverAfterConnect);</span>
<span class="fc" id="L616">    }</span>

    /**
     * Specifically test interaction with a Scheduler with subscribeOn.
     *
     * @throws Exception functional interfaces declare throws Exception
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void testIssue2191_SchedulerUnsubscribeOnError() throws Exception {
        // setup mocks
<span class="fc" id="L627">        Consumer&lt;Integer&gt; sourceNext = mock(Consumer.class);</span>
<span class="fc" id="L628">        Action sourceCompleted = mock(Action.class);</span>
<span class="fc" id="L629">        Consumer&lt;Throwable&gt; sourceError = mock(Consumer.class);</span>
<span class="fc" id="L630">        Action sourceUnsubscribed = mock(Action.class);</span>
<span class="fc" id="L631">        final Scheduler mockScheduler = mock(Scheduler.class);</span>
<span class="fc" id="L632">        final Disposable mockSubscription = mock(Disposable.class);</span>
<span class="fc" id="L633">        Worker spiedWorker = workerSpy(mockSubscription);</span>
<span class="fc" id="L634">        Subscriber&lt;Integer&gt; mockObserverBeforeConnect = TestHelper.mockSubscriber();</span>
<span class="fc" id="L635">        Subscriber&lt;Integer&gt; mockObserverAfterConnect = TestHelper.mockSubscriber();</span>

<span class="fc" id="L637">        when(mockScheduler.createWorker()).thenReturn(spiedWorker);</span>

        // Flowable under test
<span class="fc" id="L640">        Function&lt;Integer, Integer&gt; mockFunc = mock(Function.class);</span>
<span class="fc" id="L641">        IllegalArgumentException illegalArgumentException = new IllegalArgumentException();</span>
<span class="fc" id="L642">        when(mockFunc.apply(1)).thenReturn(1);</span>
<span class="fc" id="L643">        when(mockFunc.apply(2)).thenThrow(illegalArgumentException);</span>
<span class="fc" id="L644">        ConnectableFlowable&lt;Integer&gt; replay = Flowable.just(1, 2, 3).map(mockFunc)</span>
<span class="fc" id="L645">                .doOnNext(sourceNext)</span>
<span class="fc" id="L646">                .doOnCancel(sourceUnsubscribed)</span>
<span class="fc" id="L647">                .doOnComplete(sourceCompleted)</span>
<span class="fc" id="L648">                .doOnError(sourceError)</span>
<span class="fc" id="L649">                .subscribeOn(mockScheduler).replay();</span>

<span class="fc" id="L651">        replay.subscribe(mockObserverBeforeConnect);</span>
<span class="fc" id="L652">        replay.subscribe(mockObserverBeforeConnect);</span>
<span class="fc" id="L653">        replay.connect();</span>
<span class="fc" id="L654">        replay.subscribe(mockObserverAfterConnect);</span>
<span class="fc" id="L655">        replay.subscribe(mockObserverAfterConnect);</span>

<span class="fc" id="L657">        verify(mockObserverBeforeConnect, times(2)).onSubscribe((Subscription)any());</span>
<span class="fc" id="L658">        verify(mockObserverAfterConnect, times(2)).onSubscribe((Subscription)any());</span>

        // verify interactions
<span class="fc" id="L661">        verify(mockScheduler, times(1)).createWorker();</span>
<span class="fc" id="L662">        verify(spiedWorker, times(1)).schedule((Runnable)notNull());</span>
<span class="fc" id="L663">        verify(sourceNext, times(1)).accept(1);</span>
<span class="fc" id="L664">        verify(sourceError, times(1)).accept(illegalArgumentException);</span>
<span class="fc" id="L665">        verifyObserver(mockObserverBeforeConnect, 2, 2, illegalArgumentException);</span>
<span class="fc" id="L666">        verifyObserver(mockObserverAfterConnect, 2, 2, illegalArgumentException);</span>

        // FIXME publish also calls cancel
<span class="fc" id="L669">        verify(spiedWorker, times(1)).dispose();</span>
<span class="fc" id="L670">        verify(sourceUnsubscribed, never()).run();</span>

<span class="fc" id="L672">        verifyNoMoreInteractions(sourceNext);</span>
<span class="fc" id="L673">        verifyNoMoreInteractions(sourceCompleted);</span>
<span class="fc" id="L674">        verifyNoMoreInteractions(sourceError);</span>
<span class="fc" id="L675">        verifyNoMoreInteractions(sourceUnsubscribed);</span>
<span class="fc" id="L676">        verifyNoMoreInteractions(spiedWorker);</span>
<span class="fc" id="L677">        verifyNoMoreInteractions(mockSubscription);</span>
<span class="fc" id="L678">        verifyNoMoreInteractions(mockScheduler);</span>
<span class="fc" id="L679">        verifyNoMoreInteractions(mockObserverBeforeConnect);</span>
<span class="fc" id="L680">        verifyNoMoreInteractions(mockObserverAfterConnect);</span>
<span class="fc" id="L681">    }</span>

    private static void verifyObserverMock(Subscriber&lt;Integer&gt; mock, int numSubscriptions, int numItemsExpected) {
<span class="fc" id="L684">        verify(mock, times(numItemsExpected)).onNext((Integer) notNull());</span>
<span class="fc" id="L685">        verify(mock, times(numSubscriptions)).onComplete();</span>
<span class="fc" id="L686">        verifyNoMoreInteractions(mock);</span>
<span class="fc" id="L687">    }</span>

    private static void verifyObserver(Subscriber&lt;Integer&gt; mock, int numSubscriptions, int numItemsExpected, Throwable error) {
<span class="fc" id="L690">        verify(mock, times(numItemsExpected)).onNext((Integer) notNull());</span>
<span class="fc" id="L691">        verify(mock, times(numSubscriptions)).onError(error);</span>
<span class="fc" id="L692">        verifyNoMoreInteractions(mock);</span>
<span class="fc" id="L693">    }</span>

    public static Worker workerSpy(final Disposable mockDisposable) {
<span class="fc" id="L696">        return spy(new InprocessWorker(mockDisposable));</span>
    }

    private static class InprocessWorker extends Worker {
        private final Disposable mockDisposable;
        public boolean unsubscribed;

<span class="fc" id="L703">        InprocessWorker(Disposable mockDisposable) {</span>
<span class="fc" id="L704">            this.mockDisposable = mockDisposable;</span>
<span class="fc" id="L705">        }</span>

        @NonNull
        @Override
        public Disposable schedule(@NonNull Runnable action) {
<span class="fc" id="L710">            action.run();</span>
<span class="fc" id="L711">            return mockDisposable; // this subscription is returned but discarded</span>
        }

        @NonNull
        @Override
        public Disposable schedule(@NonNull Runnable action, long delayTime, @NonNull TimeUnit unit) {
<span class="nc" id="L717">            action.run();</span>
<span class="nc" id="L718">            return mockDisposable;</span>
        }

        @Override
        public void dispose() {
<span class="fc" id="L723">            unsubscribed = true;</span>
<span class="fc" id="L724">        }</span>

        @Override
        public boolean isDisposed() {
<span class="nc" id="L728">            return unsubscribed;</span>
        }
    }

    @Test
    public void testBoundedReplayBuffer() {
<span class="fc" id="L734">        BoundedReplayBuffer&lt;Integer&gt; buf = new BoundedReplayBuffer&lt;Integer&gt;();</span>
<span class="fc" id="L735">        buf.addLast(new Node(1, 0));</span>
<span class="fc" id="L736">        buf.addLast(new Node(2, 1));</span>
<span class="fc" id="L737">        buf.addLast(new Node(3, 2));</span>
<span class="fc" id="L738">        buf.addLast(new Node(4, 3));</span>
<span class="fc" id="L739">        buf.addLast(new Node(5, 4));</span>

<span class="fc" id="L741">        List&lt;Integer&gt; values = new ArrayList&lt;Integer&gt;();</span>
<span class="fc" id="L742">        buf.collect(values);</span>

<span class="fc" id="L744">        Assert.assertEquals(Arrays.asList(1, 2, 3, 4, 5), values);</span>

<span class="fc" id="L746">        buf.removeSome(2);</span>
<span class="fc" id="L747">        buf.removeFirst();</span>
<span class="fc" id="L748">        buf.removeSome(2);</span>

<span class="fc" id="L750">        values.clear();</span>
<span class="fc" id="L751">        buf.collect(values);</span>
<span class="fc" id="L752">        Assert.assertTrue(values.isEmpty());</span>

<span class="fc" id="L754">        buf.addLast(new Node(5, 5));</span>
<span class="fc" id="L755">        buf.addLast(new Node(6, 6));</span>
<span class="fc" id="L756">        buf.collect(values);</span>

<span class="fc" id="L758">        Assert.assertEquals(Arrays.asList(5, 6), values);</span>

<span class="fc" id="L760">    }</span>

    @Test
    public void testTimedAndSizedTruncation() {
<span class="fc" id="L764">        TestScheduler test = new TestScheduler();</span>
<span class="fc" id="L765">        SizeAndTimeBoundReplayBuffer&lt;Integer&gt; buf = new SizeAndTimeBoundReplayBuffer&lt;Integer&gt;(2, 2000, TimeUnit.MILLISECONDS, test);</span>
<span class="fc" id="L766">        List&lt;Integer&gt; values = new ArrayList&lt;Integer&gt;();</span>

<span class="fc" id="L768">        buf.next(1);</span>
<span class="fc" id="L769">        test.advanceTimeBy(1, TimeUnit.SECONDS);</span>
<span class="fc" id="L770">        buf.next(2);</span>
<span class="fc" id="L771">        test.advanceTimeBy(1, TimeUnit.SECONDS);</span>
<span class="fc" id="L772">        buf.collect(values);</span>
<span class="fc" id="L773">        Assert.assertEquals(Arrays.asList(2), values);</span>

<span class="fc" id="L775">        buf.next(3);</span>
<span class="fc" id="L776">        buf.next(4);</span>
<span class="fc" id="L777">        values.clear();</span>
<span class="fc" id="L778">        buf.collect(values);</span>
<span class="fc" id="L779">        Assert.assertEquals(Arrays.asList(3, 4), values);</span>

<span class="fc" id="L781">        test.advanceTimeBy(2, TimeUnit.SECONDS);</span>
<span class="fc" id="L782">        buf.next(5);</span>

<span class="fc" id="L784">        values.clear();</span>
<span class="fc" id="L785">        buf.collect(values);</span>
<span class="fc" id="L786">        Assert.assertEquals(Arrays.asList(5), values);</span>

<span class="fc" id="L788">        test.advanceTimeBy(2, TimeUnit.SECONDS);</span>
<span class="fc" id="L789">        buf.complete();</span>

<span class="fc" id="L791">        values.clear();</span>
<span class="fc" id="L792">        buf.collect(values);</span>
<span class="fc" id="L793">        Assert.assertTrue(values.isEmpty());</span>

<span class="fc" id="L795">        Assert.assertEquals(1, buf.size);</span>
<span class="fc" id="L796">        Assert.assertTrue(buf.hasCompleted());</span>
<span class="fc" id="L797">    }</span>

    @Test
    public void testBackpressure() {
<span class="fc" id="L801">        final AtomicLong requested = new AtomicLong();</span>
<span class="fc" id="L802">        Flowable&lt;Integer&gt; source = Flowable.range(1, 1000)</span>
<span class="fc" id="L803">                .doOnRequest(new LongConsumer() {</span>
                    @Override
                    public void accept(long t) {
<span class="fc" id="L806">                        requested.addAndGet(t);</span>
<span class="fc" id="L807">                    }</span>
                });
<span class="fc" id="L809">        ConnectableFlowable&lt;Integer&gt; cf = source.replay();</span>

<span class="fc" id="L811">        TestSubscriber&lt;Integer&gt; ts1 = new TestSubscriber&lt;Integer&gt;(10L);</span>
<span class="fc" id="L812">        TestSubscriber&lt;Integer&gt; ts2 = new TestSubscriber&lt;Integer&gt;(90L);</span>

<span class="fc" id="L814">        cf.subscribe(ts1);</span>
<span class="fc" id="L815">        cf.subscribe(ts2);</span>

<span class="fc" id="L817">        ts2.request(10);</span>

<span class="fc" id="L819">        cf.connect();</span>

<span class="fc" id="L821">        ts1.assertValueCount(10);</span>
<span class="fc" id="L822">        ts1.assertNotTerminated();</span>

<span class="fc" id="L824">        ts2.assertValueCount(100);</span>
<span class="fc" id="L825">        ts2.assertNotTerminated();</span>

<span class="fc" id="L827">        Assert.assertEquals(100, requested.get());</span>
<span class="fc" id="L828">    }</span>

    @Test
    public void testBackpressureBounded() {
<span class="fc" id="L832">        final AtomicLong requested = new AtomicLong();</span>
<span class="fc" id="L833">        Flowable&lt;Integer&gt; source = Flowable.range(1, 1000)</span>
<span class="fc" id="L834">                .doOnRequest(new LongConsumer() {</span>
                    @Override
                    public void accept(long t) {
<span class="fc" id="L837">                        requested.addAndGet(t);</span>
<span class="fc" id="L838">                    }</span>
                });
<span class="fc" id="L840">        ConnectableFlowable&lt;Integer&gt; cf = source.replay(50);</span>

<span class="fc" id="L842">        TestSubscriber&lt;Integer&gt; ts1 = new TestSubscriber&lt;Integer&gt;(10L);</span>
<span class="fc" id="L843">        TestSubscriber&lt;Integer&gt; ts2 = new TestSubscriber&lt;Integer&gt;(90L);</span>

<span class="fc" id="L845">        cf.subscribe(ts1);</span>
<span class="fc" id="L846">        cf.subscribe(ts2);</span>

<span class="fc" id="L848">        ts2.request(10);</span>

<span class="fc" id="L850">        cf.connect();</span>

<span class="fc" id="L852">        ts1.assertValueCount(10);</span>
<span class="fc" id="L853">        ts1.assertNotTerminated();</span>

<span class="fc" id="L855">        ts2.assertValueCount(100);</span>
<span class="fc" id="L856">        ts2.assertNotTerminated();</span>

<span class="fc" id="L858">        Assert.assertEquals(100, requested.get());</span>
<span class="fc" id="L859">    }</span>

    @Test
    public void testColdReplayNoBackpressure() {
<span class="fc" id="L863">        Flowable&lt;Integer&gt; source = Flowable.range(0, 1000).replay().autoConnect();</span>

<span class="fc" id="L865">        TestSubscriber&lt;Integer&gt; ts = new TestSubscriber&lt;Integer&gt;();</span>

<span class="fc" id="L867">        source.subscribe(ts);</span>

<span class="fc" id="L869">        ts.assertNoErrors();</span>
<span class="fc" id="L870">        ts.assertTerminated();</span>
<span class="fc" id="L871">        List&lt;Integer&gt; onNextEvents = ts.values();</span>
<span class="fc" id="L872">        assertEquals(1000, onNextEvents.size());</span>

<span class="fc bfc" id="L874" title="All 2 branches covered.">        for (int i = 0; i &lt; 1000; i++) {</span>
<span class="fc" id="L875">            assertEquals((Integer)i, onNextEvents.get(i));</span>
        }
<span class="fc" id="L877">    }</span>

    @Test
    public void testColdReplayBackpressure() {
<span class="fc" id="L881">        Flowable&lt;Integer&gt; source = Flowable.range(0, 1000).replay().autoConnect();</span>

<span class="fc" id="L883">        TestSubscriber&lt;Integer&gt; ts = new TestSubscriber&lt;Integer&gt;(0L);</span>
<span class="fc" id="L884">        ts.request(10);</span>

<span class="fc" id="L886">        source.subscribe(ts);</span>

<span class="fc" id="L888">        ts.assertNoErrors();</span>
<span class="fc" id="L889">        ts.assertNotComplete();</span>
<span class="fc" id="L890">        List&lt;Integer&gt; onNextEvents = ts.values();</span>
<span class="fc" id="L891">        assertEquals(10, onNextEvents.size());</span>

<span class="fc bfc" id="L893" title="All 2 branches covered.">        for (int i = 0; i &lt; 10; i++) {</span>
<span class="fc" id="L894">            assertEquals((Integer)i, onNextEvents.get(i));</span>
        }

<span class="fc" id="L897">        ts.dispose();</span>
<span class="fc" id="L898">    }</span>

    @Test
    public void testCache() throws InterruptedException {
<span class="fc" id="L902">        final AtomicInteger counter = new AtomicInteger();</span>
<span class="fc" id="L903">        Flowable&lt;String&gt; f = Flowable.unsafeCreate(new Publisher&lt;String&gt;() {</span>

            @Override
            public void subscribe(final Subscriber&lt;? super String&gt; subscriber) {
<span class="fc" id="L907">                subscriber.onSubscribe(new BooleanSubscription());</span>
<span class="fc" id="L908">                new Thread(new Runnable() {</span>

                    @Override
                    public void run() {
<span class="fc" id="L912">                        counter.incrementAndGet();</span>
<span class="fc" id="L913">                        System.out.println(&quot;published observable being executed&quot;);</span>
<span class="fc" id="L914">                        subscriber.onNext(&quot;one&quot;);</span>
<span class="fc" id="L915">                        subscriber.onComplete();</span>
<span class="fc" id="L916">                    }</span>
<span class="fc" id="L917">                }).start();</span>
<span class="fc" id="L918">            }</span>
<span class="fc" id="L919">        }).replay().autoConnect();</span>

        // we then expect the following 2 subscriptions to get that same value
<span class="fc" id="L922">        final CountDownLatch latch = new CountDownLatch(2);</span>

        // subscribe once
<span class="fc" id="L925">        f.subscribe(new Consumer&lt;String&gt;() {</span>

            @Override
            public void accept(String v) {
<span class="fc" id="L929">                assertEquals(&quot;one&quot;, v);</span>
<span class="fc" id="L930">                System.out.println(&quot;v: &quot; + v);</span>
<span class="fc" id="L931">                latch.countDown();</span>
<span class="fc" id="L932">            }</span>
        });

        // subscribe again
<span class="fc" id="L936">        f.subscribe(new Consumer&lt;String&gt;() {</span>

            @Override
            public void accept(String v) {
<span class="fc" id="L940">                assertEquals(&quot;one&quot;, v);</span>
<span class="fc" id="L941">                System.out.println(&quot;v: &quot; + v);</span>
<span class="fc" id="L942">                latch.countDown();</span>
<span class="fc" id="L943">            }</span>
        });

<span class="pc bpc" id="L946" title="1 of 2 branches missed.">        if (!latch.await(1000, TimeUnit.MILLISECONDS)) {</span>
<span class="nc" id="L947">            fail(&quot;subscriptions did not receive values&quot;);</span>
        }
<span class="fc" id="L949">        assertEquals(1, counter.get());</span>
<span class="fc" id="L950">    }</span>

    @Test
    public void testUnsubscribeSource() throws Exception {
<span class="fc" id="L954">        Action unsubscribe = mock(Action.class);</span>
<span class="fc" id="L955">        Flowable&lt;Integer&gt; f = Flowable.just(1).doOnCancel(unsubscribe).replay().autoConnect();</span>
<span class="fc" id="L956">        f.subscribe();</span>
<span class="fc" id="L957">        f.subscribe();</span>
<span class="fc" id="L958">        f.subscribe();</span>
<span class="fc" id="L959">        verify(unsubscribe, never()).run();</span>
<span class="fc" id="L960">    }</span>

    @Test
    public void testTake() {
<span class="fc" id="L964">        TestSubscriber&lt;Integer&gt; ts = new TestSubscriber&lt;Integer&gt;();</span>

<span class="fc" id="L966">        Flowable&lt;Integer&gt; cached = Flowable.range(1, 100).replay().autoConnect();</span>
<span class="fc" id="L967">        cached.take(10).subscribe(ts);</span>

<span class="fc" id="L969">        ts.assertNoErrors();</span>
<span class="fc" id="L970">        ts.assertTerminated();</span>
<span class="fc" id="L971">        ts.assertValues(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);</span>
<span class="fc" id="L972">    }</span>

    @Test
    public void testAsync() {
<span class="fc" id="L976">        Flowable&lt;Integer&gt; source = Flowable.range(1, 10000);</span>
<span class="fc bfc" id="L977" title="All 2 branches covered.">        for (int i = 0; i &lt; 100; i++) {</span>
<span class="fc" id="L978">            TestSubscriber&lt;Integer&gt; ts1 = new TestSubscriber&lt;Integer&gt;();</span>

<span class="fc" id="L980">            Flowable&lt;Integer&gt; cached = source.replay().autoConnect();</span>

<span class="fc" id="L982">            cached.observeOn(Schedulers.computation()).subscribe(ts1);</span>

<span class="fc" id="L984">            ts1.awaitTerminalEvent(2, TimeUnit.SECONDS);</span>
<span class="fc" id="L985">            ts1.assertNoErrors();</span>
<span class="fc" id="L986">            ts1.assertTerminated();</span>
<span class="fc" id="L987">            assertEquals(10000, ts1.values().size());</span>

<span class="fc" id="L989">            TestSubscriber&lt;Integer&gt; ts2 = new TestSubscriber&lt;Integer&gt;();</span>
<span class="fc" id="L990">            cached.observeOn(Schedulers.computation()).subscribe(ts2);</span>

<span class="fc" id="L992">            ts2.awaitTerminalEvent(2, TimeUnit.SECONDS);</span>
<span class="fc" id="L993">            ts2.assertNoErrors();</span>
<span class="fc" id="L994">            ts2.assertTerminated();</span>
<span class="fc" id="L995">            assertEquals(10000, ts2.values().size());</span>
        }
<span class="fc" id="L997">    }</span>

    @Test
    public void testAsyncComeAndGo() {
<span class="fc" id="L1001">        Flowable&lt;Long&gt; source = Flowable.interval(1, 1, TimeUnit.MILLISECONDS)</span>
<span class="fc" id="L1002">                .take(1000)</span>
<span class="fc" id="L1003">                .subscribeOn(Schedulers.io());</span>
<span class="fc" id="L1004">        Flowable&lt;Long&gt; cached = source.replay().autoConnect();</span>

<span class="fc" id="L1006">        Flowable&lt;Long&gt; output = cached.observeOn(Schedulers.computation(), false, 1024);</span>

<span class="fc" id="L1008">        List&lt;TestSubscriber&lt;Long&gt;&gt; list = new ArrayList&lt;TestSubscriber&lt;Long&gt;&gt;(100);</span>
<span class="fc bfc" id="L1009" title="All 2 branches covered.">        for (int i = 0; i &lt; 100; i++) {</span>
<span class="fc" id="L1010">            TestSubscriber&lt;Long&gt; ts = new TestSubscriber&lt;Long&gt;();</span>
<span class="fc" id="L1011">            list.add(ts);</span>
<span class="fc" id="L1012">            output.skip(i * 10).take(10).subscribe(ts);</span>
        }

<span class="fc" id="L1015">        List&lt;Long&gt; expected = new ArrayList&lt;Long&gt;();</span>
<span class="fc bfc" id="L1016" title="All 2 branches covered.">        for (int i = 0; i &lt; 10; i++) {</span>
<span class="fc" id="L1017">            expected.add((long)(i - 10));</span>
        }
<span class="fc" id="L1019">        int j = 0;</span>
<span class="fc bfc" id="L1020" title="All 2 branches covered.">        for (TestSubscriber&lt;Long&gt; ts : list) {</span>
<span class="fc" id="L1021">            ts.awaitTerminalEvent(3, TimeUnit.SECONDS);</span>
<span class="fc" id="L1022">            ts.assertNoErrors();</span>
<span class="fc" id="L1023">            ts.assertTerminated();</span>

<span class="fc bfc" id="L1025" title="All 2 branches covered.">            for (int i = j * 10; i &lt; j * 10 + 10; i++) {</span>
<span class="fc" id="L1026">                expected.set(i - j * 10, (long)i);</span>
            }

<span class="fc" id="L1029">            ts.assertValueSequence(expected);</span>

<span class="fc" id="L1031">            j++;</span>
<span class="fc" id="L1032">        }</span>
<span class="fc" id="L1033">    }</span>

    @Test
    public void testNoMissingBackpressureException() {
<span class="fc" id="L1037">        final int m = 4 * 1000 * 1000;</span>
<span class="fc" id="L1038">        Flowable&lt;Integer&gt; firehose = Flowable.unsafeCreate(new Publisher&lt;Integer&gt;() {</span>
            @Override
            public void subscribe(Subscriber&lt;? super Integer&gt; t) {
<span class="fc" id="L1041">                t.onSubscribe(new BooleanSubscription());</span>
<span class="fc bfc" id="L1042" title="All 2 branches covered.">                for (int i = 0; i &lt; m; i++) {</span>
<span class="fc" id="L1043">                    t.onNext(i);</span>
                }
<span class="fc" id="L1045">                t.onComplete();</span>
<span class="fc" id="L1046">            }</span>
        });

<span class="fc" id="L1049">        TestSubscriber&lt;Integer&gt; ts = new TestSubscriber&lt;Integer&gt;();</span>
<span class="fc" id="L1050">        firehose.replay().autoConnect().observeOn(Schedulers.computation()).takeLast(100).subscribe(ts);</span>

<span class="fc" id="L1052">        ts.awaitTerminalEvent(3, TimeUnit.SECONDS);</span>
<span class="fc" id="L1053">        ts.assertNoErrors();</span>
<span class="fc" id="L1054">        ts.assertTerminated();</span>

<span class="fc" id="L1056">        assertEquals(100, ts.values().size());</span>
<span class="fc" id="L1057">    }</span>

    @Test
    public void testValuesAndThenError() {
<span class="fc" id="L1061">        Flowable&lt;Integer&gt; source = Flowable.range(1, 10)</span>
<span class="fc" id="L1062">                .concatWith(Flowable.&lt;Integer&gt;error(new TestException()))</span>
<span class="fc" id="L1063">                .replay().autoConnect();</span>

<span class="fc" id="L1065">        TestSubscriber&lt;Integer&gt; ts = new TestSubscriber&lt;Integer&gt;();</span>
<span class="fc" id="L1066">        source.subscribe(ts);</span>

<span class="fc" id="L1068">        ts.assertValues(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);</span>
<span class="fc" id="L1069">        ts.assertNotComplete();</span>
<span class="fc" id="L1070">        Assert.assertEquals(1, ts.errors().size());</span>

<span class="fc" id="L1072">        TestSubscriber&lt;Integer&gt; ts2 = new TestSubscriber&lt;Integer&gt;();</span>
<span class="fc" id="L1073">        source.subscribe(ts2);</span>

<span class="fc" id="L1075">        ts2.assertValues(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);</span>
<span class="fc" id="L1076">        ts2.assertNotComplete();</span>
<span class="fc" id="L1077">        Assert.assertEquals(1, ts2.errors().size());</span>
<span class="fc" id="L1078">    }</span>

    @Test
    public void unsafeChildThrows() {
<span class="fc" id="L1082">        final AtomicInteger count = new AtomicInteger();</span>

<span class="fc" id="L1084">        Flowable&lt;Integer&gt; source = Flowable.range(1, 100)</span>
<span class="fc" id="L1085">        .doOnNext(new Consumer&lt;Integer&gt;() {</span>
            @Override
            public void accept(Integer t) {
<span class="fc" id="L1088">                count.getAndIncrement();</span>
<span class="fc" id="L1089">            }</span>
        })
<span class="fc" id="L1091">        .replay().autoConnect();</span>

<span class="fc" id="L1093">        TestSubscriber&lt;Integer&gt; ts = new TestSubscriber&lt;Integer&gt;() {</span>
            @Override
            public void onNext(Integer t) {
<span class="fc" id="L1096">                throw new TestException();</span>
            }
        };

<span class="fc" id="L1100">        source.subscribe(ts);</span>

<span class="fc" id="L1102">        Assert.assertEquals(100, count.get());</span>

<span class="fc" id="L1104">        ts.assertNoValues();</span>
<span class="fc" id="L1105">        ts.assertNotComplete();</span>
<span class="fc" id="L1106">        ts.assertError(TestException.class);</span>
<span class="fc" id="L1107">    }</span>

    @Test
    public void unboundedLeavesEarly() {
<span class="fc" id="L1111">        PublishProcessor&lt;Integer&gt; source = PublishProcessor.create();</span>

<span class="fc" id="L1113">        final List&lt;Long&gt; requests = new ArrayList&lt;Long&gt;();</span>

<span class="fc" id="L1115">        Flowable&lt;Integer&gt; out = source</span>
<span class="fc" id="L1116">                .doOnRequest(new LongConsumer() {</span>
                    @Override
                    public void accept(long t) {
<span class="fc" id="L1119">                        requests.add(t);</span>
<span class="fc" id="L1120">                    }</span>
<span class="fc" id="L1121">                }).replay().autoConnect();</span>

<span class="fc" id="L1123">        TestSubscriber&lt;Integer&gt; ts1 = new TestSubscriber&lt;Integer&gt;(5L);</span>
<span class="fc" id="L1124">        TestSubscriber&lt;Integer&gt; ts2 = new TestSubscriber&lt;Integer&gt;(10L);</span>

<span class="fc" id="L1126">        out.subscribe(ts1);</span>
<span class="fc" id="L1127">        out.subscribe(ts2);</span>
<span class="fc" id="L1128">        ts2.dispose();</span>

<span class="fc" id="L1130">        Assert.assertEquals(Arrays.asList(5L, 5L), requests);</span>
<span class="fc" id="L1131">    }</span>

    @Test
    public void testSubscribersComeAndGoAtRequestBoundaries() {
<span class="fc" id="L1135">        ConnectableFlowable&lt;Integer&gt; source = Flowable.range(1, 10).replay(1);</span>
<span class="fc" id="L1136">        source.connect();</span>

<span class="fc" id="L1138">        TestSubscriber&lt;Integer&gt; ts1 = new TestSubscriber&lt;Integer&gt;(2L);</span>

<span class="fc" id="L1140">        source.subscribe(ts1);</span>

<span class="fc" id="L1142">        ts1.assertValues(1, 2);</span>
<span class="fc" id="L1143">        ts1.assertNoErrors();</span>
<span class="fc" id="L1144">        ts1.dispose();</span>

<span class="fc" id="L1146">        TestSubscriber&lt;Integer&gt; ts2 = new TestSubscriber&lt;Integer&gt;(2L);</span>

<span class="fc" id="L1148">        source.subscribe(ts2);</span>

<span class="fc" id="L1150">        ts2.assertValues(2, 3);</span>
<span class="fc" id="L1151">        ts2.assertNoErrors();</span>
<span class="fc" id="L1152">        ts2.dispose();</span>

<span class="fc" id="L1154">        TestSubscriber&lt;Integer&gt; ts21 = new TestSubscriber&lt;Integer&gt;(1L);</span>

<span class="fc" id="L1156">        source.subscribe(ts21);</span>

<span class="fc" id="L1158">        ts21.assertValues(3);</span>
<span class="fc" id="L1159">        ts21.assertNoErrors();</span>
<span class="fc" id="L1160">        ts21.dispose();</span>

<span class="fc" id="L1162">        TestSubscriber&lt;Integer&gt; ts22 = new TestSubscriber&lt;Integer&gt;(1L);</span>

<span class="fc" id="L1164">        source.subscribe(ts22);</span>

<span class="fc" id="L1166">        ts22.assertValues(3);</span>
<span class="fc" id="L1167">        ts22.assertNoErrors();</span>
<span class="fc" id="L1168">        ts22.dispose();</span>

<span class="fc" id="L1170">        TestSubscriber&lt;Integer&gt; ts3 = new TestSubscriber&lt;Integer&gt;();</span>

<span class="fc" id="L1172">        source.subscribe(ts3);</span>

<span class="fc" id="L1174">        ts3.assertNoErrors();</span>
<span class="fc" id="L1175">        System.out.println(ts3.values());</span>
<span class="fc" id="L1176">        ts3.assertValues(3, 4, 5, 6, 7, 8, 9, 10);</span>
<span class="fc" id="L1177">        ts3.assertComplete();</span>
<span class="fc" id="L1178">    }</span>

    @Test
    public void testSubscribersComeAndGoAtRequestBoundaries2() {
<span class="fc" id="L1182">        ConnectableFlowable&lt;Integer&gt; source = Flowable.range(1, 10).replay(2);</span>
<span class="fc" id="L1183">        source.connect();</span>

<span class="fc" id="L1185">        TestSubscriber&lt;Integer&gt; ts1 = new TestSubscriber&lt;Integer&gt;(2L);</span>

<span class="fc" id="L1187">        source.subscribe(ts1);</span>

<span class="fc" id="L1189">        ts1.assertValues(1, 2);</span>
<span class="fc" id="L1190">        ts1.assertNoErrors();</span>
<span class="fc" id="L1191">        ts1.dispose();</span>

<span class="fc" id="L1193">        TestSubscriber&lt;Integer&gt; ts11 = new TestSubscriber&lt;Integer&gt;(2L);</span>

<span class="fc" id="L1195">        source.subscribe(ts11);</span>

<span class="fc" id="L1197">        ts11.assertValues(1, 2);</span>
<span class="fc" id="L1198">        ts11.assertNoErrors();</span>
<span class="fc" id="L1199">        ts11.dispose();</span>

<span class="fc" id="L1201">        TestSubscriber&lt;Integer&gt; ts2 = new TestSubscriber&lt;Integer&gt;(3L);</span>

<span class="fc" id="L1203">        source.subscribe(ts2);</span>

<span class="fc" id="L1205">        ts2.assertValues(1, 2, 3);</span>
<span class="fc" id="L1206">        ts2.assertNoErrors();</span>
<span class="fc" id="L1207">        ts2.dispose();</span>

<span class="fc" id="L1209">        TestSubscriber&lt;Integer&gt; ts21 = new TestSubscriber&lt;Integer&gt;(1L);</span>

<span class="fc" id="L1211">        source.subscribe(ts21);</span>

<span class="fc" id="L1213">        ts21.assertValues(2);</span>
<span class="fc" id="L1214">        ts21.assertNoErrors();</span>
<span class="fc" id="L1215">        ts21.dispose();</span>

<span class="fc" id="L1217">        TestSubscriber&lt;Integer&gt; ts22 = new TestSubscriber&lt;Integer&gt;(1L);</span>

<span class="fc" id="L1219">        source.subscribe(ts22);</span>

<span class="fc" id="L1221">        ts22.assertValues(2);</span>
<span class="fc" id="L1222">        ts22.assertNoErrors();</span>
<span class="fc" id="L1223">        ts22.dispose();</span>

<span class="fc" id="L1225">        TestSubscriber&lt;Integer&gt; ts3 = new TestSubscriber&lt;Integer&gt;();</span>

<span class="fc" id="L1227">        source.subscribe(ts3);</span>

<span class="fc" id="L1229">        ts3.assertNoErrors();</span>
<span class="fc" id="L1230">        System.out.println(ts3.values());</span>
<span class="fc" id="L1231">        ts3.assertValues(2, 3, 4, 5, 6, 7, 8, 9, 10);</span>
<span class="fc" id="L1232">        ts3.assertComplete();</span>
<span class="fc" id="L1233">    }</span>

    @Test
    public void replayScheduler() {

<span class="fc" id="L1238">        Flowable.just(1).replay(Schedulers.computation())</span>
<span class="fc" id="L1239">        .autoConnect()</span>
<span class="fc" id="L1240">        .test()</span>
<span class="fc" id="L1241">        .awaitDone(5, TimeUnit.SECONDS)</span>
<span class="fc" id="L1242">        .assertResult(1);</span>
<span class="fc" id="L1243">    }</span>

    @Test
    public void replayTime() {
<span class="fc" id="L1247">        Flowable.just(1).replay(1, TimeUnit.MINUTES)</span>
<span class="fc" id="L1248">        .autoConnect()</span>
<span class="fc" id="L1249">        .test()</span>
<span class="fc" id="L1250">        .awaitDone(5, TimeUnit.SECONDS)</span>
<span class="fc" id="L1251">        .assertResult(1);</span>
<span class="fc" id="L1252">    }</span>

    @Test
    public void replaySizeScheduler() {

<span class="fc" id="L1257">        Flowable.just(1).replay(1, Schedulers.computation())</span>
<span class="fc" id="L1258">        .autoConnect()</span>
<span class="fc" id="L1259">        .test()</span>
<span class="fc" id="L1260">        .awaitDone(5, TimeUnit.SECONDS)</span>
<span class="fc" id="L1261">        .assertResult(1);</span>
<span class="fc" id="L1262">    }</span>

    @Test
    public void replaySizeAndTime() {
<span class="fc" id="L1266">        Flowable.just(1).replay(1, 1, TimeUnit.MILLISECONDS)</span>
<span class="fc" id="L1267">        .autoConnect()</span>
<span class="fc" id="L1268">        .test()</span>
<span class="fc" id="L1269">        .awaitDone(5, TimeUnit.SECONDS)</span>
<span class="fc" id="L1270">        .assertResult(1);</span>
<span class="fc" id="L1271">    }</span>

    @Test
    public void replaySelectorSizeScheduler() {
<span class="fc" id="L1275">        Flowable.just(1).replay(Functions.&lt;Flowable&lt;Integer&gt;&gt;identity(), 1, Schedulers.io())</span>
<span class="fc" id="L1276">        .test()</span>
<span class="fc" id="L1277">        .awaitDone(5, TimeUnit.SECONDS)</span>
<span class="fc" id="L1278">        .assertResult(1);</span>
<span class="fc" id="L1279">    }</span>

    @Test
    public void replaySelectorScheduler() {
<span class="fc" id="L1283">        Flowable.just(1).replay(Functions.&lt;Flowable&lt;Integer&gt;&gt;identity(), Schedulers.io())</span>
<span class="fc" id="L1284">        .test()</span>
<span class="fc" id="L1285">        .awaitDone(5, TimeUnit.SECONDS)</span>
<span class="fc" id="L1286">        .assertResult(1);</span>
<span class="fc" id="L1287">    }</span>

    @Test
    public void replaySelectorTime() {
<span class="fc" id="L1291">        Flowable.just(1).replay(Functions.&lt;Flowable&lt;Integer&gt;&gt;identity(), 1, TimeUnit.MINUTES)</span>
<span class="fc" id="L1292">        .test()</span>
<span class="fc" id="L1293">        .awaitDone(5, TimeUnit.SECONDS)</span>
<span class="fc" id="L1294">        .assertResult(1);</span>
<span class="fc" id="L1295">    }</span>

    @Test
    public void source() {
<span class="fc" id="L1299">        Flowable&lt;Integer&gt; source = Flowable.range(1, 3);</span>

<span class="fc" id="L1301">        assertSame(source, (((HasUpstreamPublisher&lt;?&gt;)source.replay())).source());</span>
<span class="fc" id="L1302">    }</span>

    @Test
    public void connectRace() {
<span class="fc bfc" id="L1306" title="All 2 branches covered.">        for (int i = 0; i &lt; TestHelper.RACE_DEFAULT_LOOPS; i++) {</span>
<span class="fc" id="L1307">            final ConnectableFlowable&lt;Integer&gt; cf = Flowable.range(1, 3).replay();</span>

<span class="fc" id="L1309">            Runnable r = new Runnable() {</span>
                @Override
                public void run() {
<span class="fc" id="L1312">                    cf.connect();</span>
<span class="fc" id="L1313">                }</span>
            };

<span class="fc" id="L1316">            TestHelper.race(r, r);</span>
        }
<span class="fc" id="L1318">    }</span>

    @Test
    public void subscribeRace() {
<span class="fc bfc" id="L1322" title="All 2 branches covered.">        for (int i = 0; i &lt; TestHelper.RACE_DEFAULT_LOOPS; i++) {</span>
<span class="fc" id="L1323">            final ConnectableFlowable&lt;Integer&gt; cf = Flowable.range(1, 3).replay();</span>

<span class="fc" id="L1325">            final TestSubscriber&lt;Integer&gt; ts1 = new TestSubscriber&lt;Integer&gt;();</span>
<span class="fc" id="L1326">            final TestSubscriber&lt;Integer&gt; ts2 = new TestSubscriber&lt;Integer&gt;();</span>

<span class="fc" id="L1328">            Runnable r1 = new Runnable() {</span>
                @Override
                public void run() {
<span class="fc" id="L1331">                    cf.subscribe(ts1);</span>
<span class="fc" id="L1332">                }</span>
            };

<span class="fc" id="L1335">            Runnable r2 = new Runnable() {</span>
                @Override
                public void run() {
<span class="fc" id="L1338">                    cf.subscribe(ts2);</span>
<span class="fc" id="L1339">                }</span>
            };

<span class="fc" id="L1342">            TestHelper.race(r1, r2);</span>
        }
<span class="fc" id="L1344">    }</span>

    @Test
    public void addRemoveRace() {
<span class="fc bfc" id="L1348" title="All 2 branches covered.">        for (int i = 0; i &lt; TestHelper.RACE_DEFAULT_LOOPS; i++) {</span>
<span class="fc" id="L1349">            final ConnectableFlowable&lt;Integer&gt; cf = Flowable.range(1, 3).replay();</span>

<span class="fc" id="L1351">            final TestSubscriber&lt;Integer&gt; ts1 = new TestSubscriber&lt;Integer&gt;();</span>
<span class="fc" id="L1352">            final TestSubscriber&lt;Integer&gt; ts2 = new TestSubscriber&lt;Integer&gt;();</span>

<span class="fc" id="L1354">            cf.subscribe(ts1);</span>

<span class="fc" id="L1356">            Runnable r1 = new Runnable() {</span>
                @Override
                public void run() {
<span class="fc" id="L1359">                    ts1.cancel();</span>
<span class="fc" id="L1360">                }</span>
            };

<span class="fc" id="L1363">            Runnable r2 = new Runnable() {</span>
                @Override
                public void run() {
<span class="fc" id="L1366">                    cf.subscribe(ts2);</span>
<span class="fc" id="L1367">                }</span>
            };

<span class="fc" id="L1370">            TestHelper.race(r1, r2);</span>
        }
<span class="fc" id="L1372">    }</span>

    @Test
    public void cancelOnArrival() {
<span class="fc" id="L1376">        Flowable.range(1, 2)</span>
<span class="fc" id="L1377">        .replay(Integer.MAX_VALUE)</span>
<span class="fc" id="L1378">        .autoConnect()</span>
<span class="fc" id="L1379">        .test(Long.MAX_VALUE, true)</span>
<span class="fc" id="L1380">        .assertEmpty();</span>
<span class="fc" id="L1381">    }</span>

    @Test
    public void cancelOnArrival2() {
<span class="fc" id="L1385">        ConnectableFlowable&lt;Integer&gt; cf = PublishProcessor.&lt;Integer&gt;create()</span>
<span class="fc" id="L1386">        .replay(Integer.MAX_VALUE);</span>

<span class="fc" id="L1388">        cf.test();</span>

<span class="fc" id="L1390">        cf</span>
<span class="fc" id="L1391">        .autoConnect()</span>
<span class="fc" id="L1392">        .test(Long.MAX_VALUE, true)</span>
<span class="fc" id="L1393">        .assertEmpty();</span>
<span class="fc" id="L1394">    }</span>

    @Test
    public void connectConsumerThrows() {
<span class="fc" id="L1398">        ConnectableFlowable&lt;Integer&gt; cf = Flowable.range(1, 2)</span>
<span class="fc" id="L1399">        .replay();</span>

        try {
<span class="pc" id="L1402">            cf.connect(new Consumer&lt;Disposable&gt;() {</span>
                @Override
                public void accept(Disposable t) throws Exception {
<span class="fc" id="L1405">                    throw new TestException();</span>
                }
            });
<span class="nc" id="L1408">            fail(&quot;Should have thrown&quot;);</span>
<span class="fc" id="L1409">        } catch (TestException ex) {</span>
            // expected
<span class="nc" id="L1411">        }</span>

<span class="fc" id="L1413">        cf.test().assertEmpty().cancel();</span>

<span class="fc" id="L1415">        cf.connect();</span>

<span class="fc" id="L1417">        cf.test().assertResult(1, 2);</span>
<span class="fc" id="L1418">    }</span>

    @Test
    public void badSource() {
<span class="fc" id="L1422">        List&lt;Throwable&gt; errors = TestHelper.trackPluginErrors();</span>
        try {
<span class="fc" id="L1424">            new Flowable&lt;Integer&gt;() {</span>
                @Override
                protected void subscribeActual(Subscriber&lt;? super Integer&gt; subscriber) {
<span class="fc" id="L1427">                    subscriber.onSubscribe(new BooleanSubscription());</span>
<span class="fc" id="L1428">                    subscriber.onError(new TestException(&quot;First&quot;));</span>
<span class="fc" id="L1429">                    subscriber.onNext(1);</span>
<span class="fc" id="L1430">                    subscriber.onError(new TestException(&quot;Second&quot;));</span>
<span class="fc" id="L1431">                    subscriber.onComplete();</span>
<span class="fc" id="L1432">                }</span>
<span class="fc" id="L1433">            }.replay()</span>
<span class="fc" id="L1434">            .autoConnect()</span>
<span class="fc" id="L1435">            .test()</span>
<span class="fc" id="L1436">            .assertFailureAndMessage(TestException.class, &quot;First&quot;);</span>

<span class="fc" id="L1438">            TestHelper.assertUndeliverable(errors, 0, TestException.class, &quot;Second&quot;);</span>
        } finally {
<span class="fc" id="L1440">            RxJavaPlugins.reset();</span>
        }
<span class="fc" id="L1442">    }</span>

    @Test
    public void subscribeOnNextRace() {
<span class="fc bfc" id="L1446" title="All 2 branches covered.">        for (int i = 0; i &lt; TestHelper.RACE_DEFAULT_LOOPS; i++) {</span>
<span class="fc" id="L1447">            final PublishProcessor&lt;Integer&gt; pp = PublishProcessor.create();</span>

<span class="fc" id="L1449">            final ConnectableFlowable&lt;Integer&gt; cf = pp.replay();</span>

<span class="fc" id="L1451">            final TestSubscriber&lt;Integer&gt; ts1 = new TestSubscriber&lt;Integer&gt;();</span>

<span class="fc" id="L1453">            Runnable r1 = new Runnable() {</span>
                @Override
                public void run() {
<span class="fc" id="L1456">                    cf.subscribe(ts1);</span>
<span class="fc" id="L1457">                }</span>
            };

<span class="fc" id="L1460">            Runnable r2 = new Runnable() {</span>
                @Override
                public void run() {
<span class="fc bfc" id="L1463" title="All 2 branches covered.">                    for (int j = 0; j &lt; 1000; j++) {</span>
<span class="fc" id="L1464">                        pp.onNext(j);</span>
                    }
<span class="fc" id="L1466">                }</span>
            };

<span class="fc" id="L1469">            TestHelper.race(r1, r2);</span>
        }
<span class="fc" id="L1471">    }</span>

    @Test
    public void unsubscribeOnNextRace() {
<span class="fc bfc" id="L1475" title="All 2 branches covered.">        for (int i = 0; i &lt; TestHelper.RACE_DEFAULT_LOOPS; i++) {</span>
<span class="fc" id="L1476">            final PublishProcessor&lt;Integer&gt; pp = PublishProcessor.create();</span>

<span class="fc" id="L1478">            final ConnectableFlowable&lt;Integer&gt; cf = pp.replay();</span>

<span class="fc" id="L1480">            final TestSubscriber&lt;Integer&gt; ts1 = new TestSubscriber&lt;Integer&gt;();</span>

<span class="fc" id="L1482">            cf.subscribe(ts1);</span>

<span class="fc" id="L1484">            Runnable r1 = new Runnable() {</span>
                @Override
                public void run() {
<span class="fc" id="L1487">                    ts1.dispose();</span>
<span class="fc" id="L1488">                }</span>
            };

<span class="fc" id="L1491">            Runnable r2 = new Runnable() {</span>
                @Override
                public void run() {
<span class="fc bfc" id="L1494" title="All 2 branches covered.">                    for (int j = 0; j &lt; 1000; j++) {</span>
<span class="fc" id="L1495">                        pp.onNext(j);</span>
                    }
<span class="fc" id="L1497">                }</span>
            };

<span class="fc" id="L1500">            TestHelper.race(r1, r2);</span>
        }
<span class="fc" id="L1502">    }</span>

    @Test
    public void unsubscribeReplayRace() {
<span class="fc bfc" id="L1506" title="All 2 branches covered.">        for (int i = 0; i &lt; TestHelper.RACE_DEFAULT_LOOPS; i++) {</span>
<span class="fc" id="L1507">            final ConnectableFlowable&lt;Integer&gt; cf = Flowable.range(1, 1000).replay();</span>

<span class="fc" id="L1509">            final TestSubscriber&lt;Integer&gt; ts1 = new TestSubscriber&lt;Integer&gt;();</span>

<span class="fc" id="L1511">            cf.connect();</span>

<span class="fc" id="L1513">            Runnable r1 = new Runnable() {</span>
                @Override
                public void run() {
<span class="fc" id="L1516">                    cf.subscribe(ts1);</span>
<span class="fc" id="L1517">                }</span>
            };

<span class="fc" id="L1520">            Runnable r2 = new Runnable() {</span>
                @Override
                public void run() {
<span class="fc" id="L1523">                    ts1.dispose();</span>
<span class="fc" id="L1524">                }</span>
            };

<span class="fc" id="L1527">            TestHelper.race(r1, r2);</span>
        }
<span class="fc" id="L1529">    }</span>

    @Test
    public void reentrantOnNext() {
<span class="fc" id="L1533">        final PublishProcessor&lt;Integer&gt; pp = PublishProcessor.create();</span>

<span class="fc" id="L1535">        TestSubscriber&lt;Integer&gt; ts = new TestSubscriber&lt;Integer&gt;() {</span>
            @Override
            public void onNext(Integer t) {
<span class="fc bfc" id="L1538" title="All 2 branches covered.">                if (t == 1) {</span>
<span class="fc" id="L1539">                    pp.onNext(2);</span>
<span class="fc" id="L1540">                    pp.onComplete();</span>
                }
<span class="fc" id="L1542">                super.onNext(t);</span>
<span class="fc" id="L1543">            }</span>
        };

<span class="fc" id="L1546">        pp.replay().autoConnect().subscribe(ts);</span>

<span class="fc" id="L1548">        pp.onNext(1);</span>

<span class="fc" id="L1550">        ts.assertResult(1, 2);</span>
<span class="fc" id="L1551">    }</span>

    @Test
    public void reentrantOnNextBound() {
<span class="fc" id="L1555">        final PublishProcessor&lt;Integer&gt; pp = PublishProcessor.create();</span>

<span class="fc" id="L1557">        TestSubscriber&lt;Integer&gt; ts = new TestSubscriber&lt;Integer&gt;() {</span>
            @Override
            public void onNext(Integer t) {
<span class="fc bfc" id="L1560" title="All 2 branches covered.">                if (t == 1) {</span>
<span class="fc" id="L1561">                    pp.onNext(2);</span>
<span class="fc" id="L1562">                    pp.onComplete();</span>
                }
<span class="fc" id="L1564">                super.onNext(t);</span>
<span class="fc" id="L1565">            }</span>
        };

<span class="fc" id="L1568">        pp.replay(10).autoConnect().subscribe(ts);</span>

<span class="fc" id="L1570">        pp.onNext(1);</span>

<span class="fc" id="L1572">        ts.assertResult(1, 2);</span>
<span class="fc" id="L1573">    }</span>

    @Test
    public void reentrantOnNextCancel() {
<span class="fc" id="L1577">        final PublishProcessor&lt;Integer&gt; pp = PublishProcessor.create();</span>

<span class="fc" id="L1579">        TestSubscriber&lt;Integer&gt; ts = new TestSubscriber&lt;Integer&gt;() {</span>
            @Override
            public void onNext(Integer t) {
<span class="pc bpc" id="L1582" title="1 of 2 branches missed.">                if (t == 1) {</span>
<span class="fc" id="L1583">                    pp.onNext(2);</span>
<span class="fc" id="L1584">                    cancel();</span>
                }
<span class="fc" id="L1586">                super.onNext(t);</span>
<span class="fc" id="L1587">            }</span>
        };

<span class="fc" id="L1590">        pp.replay().autoConnect().subscribe(ts);</span>

<span class="fc" id="L1592">        pp.onNext(1);</span>

<span class="fc" id="L1594">        ts.assertValues(1);</span>
<span class="fc" id="L1595">    }</span>

    @Test
    public void reentrantOnNextCancelBounded() {
<span class="fc" id="L1599">        final PublishProcessor&lt;Integer&gt; pp = PublishProcessor.create();</span>

<span class="fc" id="L1601">        TestSubscriber&lt;Integer&gt; ts = new TestSubscriber&lt;Integer&gt;() {</span>
            @Override
            public void onNext(Integer t) {
<span class="pc bpc" id="L1604" title="1 of 2 branches missed.">                if (t == 1) {</span>
<span class="fc" id="L1605">                    pp.onNext(2);</span>
<span class="fc" id="L1606">                    cancel();</span>
                }
<span class="fc" id="L1608">                super.onNext(t);</span>
<span class="fc" id="L1609">            }</span>
        };

<span class="fc" id="L1612">        pp.replay(10).autoConnect().subscribe(ts);</span>

<span class="fc" id="L1614">        pp.onNext(1);</span>

<span class="fc" id="L1616">        ts.assertValues(1);</span>
<span class="fc" id="L1617">    }</span>

    @Test
    public void replayMaxInt() {
<span class="fc" id="L1621">        Flowable.range(1, 2)</span>
<span class="fc" id="L1622">        .replay(Integer.MAX_VALUE)</span>
<span class="fc" id="L1623">        .autoConnect()</span>
<span class="fc" id="L1624">        .test()</span>
<span class="fc" id="L1625">        .assertResult(1, 2);</span>
<span class="fc" id="L1626">    }</span>

    @Test
    public void testTimedAndSizedTruncationError() {
<span class="fc" id="L1630">        TestScheduler test = new TestScheduler();</span>
<span class="fc" id="L1631">        SizeAndTimeBoundReplayBuffer&lt;Integer&gt; buf = new SizeAndTimeBoundReplayBuffer&lt;Integer&gt;(2, 2000, TimeUnit.MILLISECONDS, test);</span>

<span class="fc" id="L1633">        Assert.assertFalse(buf.hasCompleted());</span>
<span class="fc" id="L1634">        Assert.assertFalse(buf.hasError());</span>

<span class="fc" id="L1636">        List&lt;Integer&gt; values = new ArrayList&lt;Integer&gt;();</span>

<span class="fc" id="L1638">        buf.next(1);</span>
<span class="fc" id="L1639">        test.advanceTimeBy(1, TimeUnit.SECONDS);</span>
<span class="fc" id="L1640">        buf.next(2);</span>
<span class="fc" id="L1641">        test.advanceTimeBy(1, TimeUnit.SECONDS);</span>
<span class="fc" id="L1642">        buf.collect(values);</span>
<span class="fc" id="L1643">        Assert.assertEquals(Arrays.asList(2), values);</span>

<span class="fc" id="L1645">        buf.next(3);</span>
<span class="fc" id="L1646">        buf.next(4);</span>
<span class="fc" id="L1647">        values.clear();</span>
<span class="fc" id="L1648">        buf.collect(values);</span>
<span class="fc" id="L1649">        Assert.assertEquals(Arrays.asList(3, 4), values);</span>

<span class="fc" id="L1651">        test.advanceTimeBy(2, TimeUnit.SECONDS);</span>
<span class="fc" id="L1652">        buf.next(5);</span>

<span class="fc" id="L1654">        values.clear();</span>
<span class="fc" id="L1655">        buf.collect(values);</span>
<span class="fc" id="L1656">        Assert.assertEquals(Arrays.asList(5), values);</span>
<span class="fc" id="L1657">        Assert.assertFalse(buf.hasCompleted());</span>
<span class="fc" id="L1658">        Assert.assertFalse(buf.hasError());</span>

<span class="fc" id="L1660">        test.advanceTimeBy(2, TimeUnit.SECONDS);</span>
<span class="fc" id="L1661">        buf.error(new TestException());</span>

<span class="fc" id="L1663">        values.clear();</span>
<span class="fc" id="L1664">        buf.collect(values);</span>
<span class="fc" id="L1665">        Assert.assertTrue(values.isEmpty());</span>

<span class="fc" id="L1667">        Assert.assertEquals(1, buf.size);</span>
<span class="fc" id="L1668">        Assert.assertFalse(buf.hasCompleted());</span>
<span class="fc" id="L1669">        Assert.assertTrue(buf.hasError());</span>
<span class="fc" id="L1670">    }</span>

    @Test
    public void testSizedTruncation() {
<span class="fc" id="L1674">        SizeBoundReplayBuffer&lt;Integer&gt; buf = new SizeBoundReplayBuffer&lt;Integer&gt;(2);</span>
<span class="fc" id="L1675">        List&lt;Integer&gt; values = new ArrayList&lt;Integer&gt;();</span>

<span class="fc" id="L1677">        buf.next(1);</span>
<span class="fc" id="L1678">        buf.next(2);</span>
<span class="fc" id="L1679">        buf.collect(values);</span>
<span class="fc" id="L1680">        Assert.assertEquals(Arrays.asList(1, 2), values);</span>

<span class="fc" id="L1682">        buf.next(3);</span>
<span class="fc" id="L1683">        buf.next(4);</span>
<span class="fc" id="L1684">        values.clear();</span>
<span class="fc" id="L1685">        buf.collect(values);</span>
<span class="fc" id="L1686">        Assert.assertEquals(Arrays.asList(3, 4), values);</span>

<span class="fc" id="L1688">        buf.next(5);</span>

<span class="fc" id="L1690">        values.clear();</span>
<span class="fc" id="L1691">        buf.collect(values);</span>
<span class="fc" id="L1692">        Assert.assertEquals(Arrays.asList(4, 5), values);</span>
<span class="fc" id="L1693">        Assert.assertFalse(buf.hasCompleted());</span>

<span class="fc" id="L1695">        buf.complete();</span>

<span class="fc" id="L1697">        values.clear();</span>
<span class="fc" id="L1698">        buf.collect(values);</span>
<span class="fc" id="L1699">        Assert.assertEquals(Arrays.asList(4, 5), values);</span>

<span class="fc" id="L1701">        Assert.assertEquals(3, buf.size);</span>
<span class="fc" id="L1702">        Assert.assertTrue(buf.hasCompleted());</span>
<span class="fc" id="L1703">        Assert.assertFalse(buf.hasError());</span>
<span class="fc" id="L1704">    }</span>

    @Test
    public void delayedUpstreamOnSubscribe() {
<span class="fc" id="L1708">        final Subscriber&lt;?&gt;[] sub = { null };</span>

<span class="fc" id="L1710">        new Flowable&lt;Integer&gt;() {</span>
            @Override
            protected void subscribeActual(Subscriber&lt;? super Integer&gt; s) {
<span class="fc" id="L1713">                sub[0] = s;</span>
<span class="fc" id="L1714">            }</span>
        }
<span class="fc" id="L1716">        .replay()</span>
<span class="fc" id="L1717">        .connect()</span>
<span class="fc" id="L1718">        .dispose();</span>

<span class="fc" id="L1720">        BooleanSubscription bs = new BooleanSubscription();</span>

<span class="fc" id="L1722">        sub[0].onSubscribe(bs);</span>

<span class="fc" id="L1724">        assertTrue(bs.isCancelled());</span>
<span class="fc" id="L1725">    }</span>

    @Test
    public void timedNoOutdatedData() {
<span class="fc" id="L1729">        TestScheduler scheduler = new TestScheduler();</span>

<span class="fc" id="L1731">        Flowable&lt;Integer&gt; source = Flowable.just(1)</span>
<span class="fc" id="L1732">                .replay(2, TimeUnit.SECONDS, scheduler)</span>
<span class="fc" id="L1733">                .autoConnect();</span>

<span class="fc" id="L1735">        source.test().assertResult(1);</span>

<span class="fc" id="L1737">        source.test().assertResult(1);</span>

<span class="fc" id="L1739">        scheduler.advanceTimeBy(3, TimeUnit.SECONDS);</span>

<span class="fc" id="L1741">        source.test().assertResult();</span>
<span class="fc" id="L1742">    }</span>

    @Test
    public void replaySelectorReturnsNull() {
<span class="fc" id="L1746">        Flowable.just(1)</span>
<span class="fc" id="L1747">        .replay(new Function&lt;Flowable&lt;Integer&gt;, Publisher&lt;Object&gt;&gt;() {</span>
            @Override
            public Publisher&lt;Object&gt; apply(Flowable&lt;Integer&gt; v) throws Exception {
<span class="fc" id="L1750">                return null;</span>
            }
<span class="fc" id="L1752">        }, Schedulers.trampoline())</span>
<span class="fc" id="L1753">        .test()</span>
<span class="fc" id="L1754">        .assertFailureAndMessage(NullPointerException.class, &quot;The selector returned a null Publisher&quot;);</span>
<span class="fc" id="L1755">    }</span>

    @Test
    public void multicastSelectorCallableConnectableCrash() {
<span class="fc" id="L1759">        FlowableReplay.multicastSelector(new Callable&lt;ConnectableFlowable&lt;Object&gt;&gt;() {</span>
            @Override
            public ConnectableFlowable&lt;Object&gt; call() throws Exception {
<span class="fc" id="L1762">                throw new TestException();</span>
            }
<span class="fc" id="L1764">        }, Functions.&lt;Flowable&lt;Object&gt;&gt;identity())</span>
<span class="fc" id="L1765">        .test()</span>
<span class="fc" id="L1766">        .assertFailure(TestException.class);</span>
<span class="fc" id="L1767">    }</span>

    @Test
    public void badRequest() {
<span class="fc" id="L1771">        TestHelper.assertBadRequestReported(</span>
<span class="fc" id="L1772">            Flowable.never()</span>
<span class="fc" id="L1773">            .replay()</span>
        );
<span class="fc" id="L1775">    }</span>

    @Test
    public void noHeadRetentionCompleteSize() {
<span class="fc" id="L1779">        PublishProcessor&lt;Integer&gt; source = PublishProcessor.create();</span>

<span class="fc" id="L1781">        FlowableReplay&lt;Integer&gt; co = (FlowableReplay&lt;Integer&gt;)source</span>
<span class="fc" id="L1782">                .replay(1);</span>

        // the backpressure coordination would not accept items from source otherwise
<span class="fc" id="L1785">        co.test();</span>

<span class="fc" id="L1787">        co.connect();</span>

<span class="fc" id="L1789">        BoundedReplayBuffer&lt;Integer&gt; buf = (BoundedReplayBuffer&lt;Integer&gt;)(co.current.get().buffer);</span>

<span class="fc" id="L1791">        source.onNext(1);</span>
<span class="fc" id="L1792">        source.onNext(2);</span>
<span class="fc" id="L1793">        source.onComplete();</span>

<span class="fc" id="L1795">        assertNull(buf.get().value);</span>

<span class="fc" id="L1797">        Object o = buf.get();</span>

<span class="fc" id="L1799">        buf.trimHead();</span>

<span class="fc" id="L1801">        assertSame(o, buf.get());</span>
<span class="fc" id="L1802">    }</span>

    @Test
    public void noHeadRetentionErrorSize() {
<span class="fc" id="L1806">        PublishProcessor&lt;Integer&gt; source = PublishProcessor.create();</span>

<span class="fc" id="L1808">        FlowableReplay&lt;Integer&gt; co = (FlowableReplay&lt;Integer&gt;)source</span>
<span class="fc" id="L1809">                .replay(1);</span>

<span class="fc" id="L1811">        co.test();</span>

<span class="fc" id="L1813">        co.connect();</span>

<span class="fc" id="L1815">        BoundedReplayBuffer&lt;Integer&gt; buf = (BoundedReplayBuffer&lt;Integer&gt;)(co.current.get().buffer);</span>

<span class="fc" id="L1817">        source.onNext(1);</span>
<span class="fc" id="L1818">        source.onNext(2);</span>
<span class="fc" id="L1819">        source.onError(new TestException());</span>

<span class="fc" id="L1821">        assertNull(buf.get().value);</span>

<span class="fc" id="L1823">        Object o = buf.get();</span>

<span class="fc" id="L1825">        buf.trimHead();</span>

<span class="fc" id="L1827">        assertSame(o, buf.get());</span>
<span class="fc" id="L1828">    }</span>

    @Test
    public void noHeadRetentionSize() {
<span class="fc" id="L1832">        PublishProcessor&lt;Integer&gt; source = PublishProcessor.create();</span>

<span class="fc" id="L1834">        FlowableReplay&lt;Integer&gt; co = (FlowableReplay&lt;Integer&gt;)source</span>
<span class="fc" id="L1835">                .replay(1);</span>

<span class="fc" id="L1837">        co.test();</span>

<span class="fc" id="L1839">        co.connect();</span>

<span class="fc" id="L1841">        BoundedReplayBuffer&lt;Integer&gt; buf = (BoundedReplayBuffer&lt;Integer&gt;)(co.current.get().buffer);</span>

<span class="fc" id="L1843">        source.onNext(1);</span>
<span class="fc" id="L1844">        source.onNext(2);</span>

<span class="fc" id="L1846">        assertNotNull(buf.get().value);</span>

<span class="fc" id="L1848">        buf.trimHead();</span>

<span class="fc" id="L1850">        assertNull(buf.get().value);</span>

<span class="fc" id="L1852">        Object o = buf.get();</span>

<span class="fc" id="L1854">        buf.trimHead();</span>

<span class="fc" id="L1856">        assertSame(o, buf.get());</span>
<span class="fc" id="L1857">    }</span>

    @Test
    public void noHeadRetentionCompleteTime() {
<span class="fc" id="L1861">        PublishProcessor&lt;Integer&gt; source = PublishProcessor.create();</span>

<span class="fc" id="L1863">        FlowableReplay&lt;Integer&gt; co = (FlowableReplay&lt;Integer&gt;)source</span>
<span class="fc" id="L1864">                .replay(1, TimeUnit.MINUTES, Schedulers.computation());</span>

<span class="fc" id="L1866">        co.test();</span>

<span class="fc" id="L1868">        co.connect();</span>

<span class="fc" id="L1870">        BoundedReplayBuffer&lt;Integer&gt; buf = (BoundedReplayBuffer&lt;Integer&gt;)(co.current.get().buffer);</span>

<span class="fc" id="L1872">        source.onNext(1);</span>
<span class="fc" id="L1873">        source.onNext(2);</span>
<span class="fc" id="L1874">        source.onComplete();</span>

<span class="fc" id="L1876">        assertNull(buf.get().value);</span>

<span class="fc" id="L1878">        Object o = buf.get();</span>

<span class="fc" id="L1880">        buf.trimHead();</span>

<span class="fc" id="L1882">        assertSame(o, buf.get());</span>
<span class="fc" id="L1883">    }</span>

    @Test
    public void noHeadRetentionErrorTime() {
<span class="fc" id="L1887">        PublishProcessor&lt;Integer&gt; source = PublishProcessor.create();</span>

<span class="fc" id="L1889">        FlowableReplay&lt;Integer&gt; co = (FlowableReplay&lt;Integer&gt;)source</span>
<span class="fc" id="L1890">                .replay(1, TimeUnit.MINUTES, Schedulers.computation());</span>

<span class="fc" id="L1892">        co.test();</span>

<span class="fc" id="L1894">        co.connect();</span>

<span class="fc" id="L1896">        BoundedReplayBuffer&lt;Integer&gt; buf = (BoundedReplayBuffer&lt;Integer&gt;)(co.current.get().buffer);</span>

<span class="fc" id="L1898">        source.onNext(1);</span>
<span class="fc" id="L1899">        source.onNext(2);</span>
<span class="fc" id="L1900">        source.onError(new TestException());</span>

<span class="fc" id="L1902">        assertNull(buf.get().value);</span>

<span class="fc" id="L1904">        Object o = buf.get();</span>

<span class="fc" id="L1906">        buf.trimHead();</span>

<span class="fc" id="L1908">        assertSame(o, buf.get());</span>
<span class="fc" id="L1909">    }</span>

    @Test
    public void noHeadRetentionTime() {
<span class="fc" id="L1913">        TestScheduler sch = new TestScheduler();</span>

<span class="fc" id="L1915">        PublishProcessor&lt;Integer&gt; source = PublishProcessor.create();</span>

<span class="fc" id="L1917">        FlowableReplay&lt;Integer&gt; co = (FlowableReplay&lt;Integer&gt;)source</span>
<span class="fc" id="L1918">                .replay(1, TimeUnit.MILLISECONDS, sch);</span>

<span class="fc" id="L1920">        co.test();</span>

<span class="fc" id="L1922">        co.connect();</span>

<span class="fc" id="L1924">        BoundedReplayBuffer&lt;Integer&gt; buf = (BoundedReplayBuffer&lt;Integer&gt;)(co.current.get().buffer);</span>

<span class="fc" id="L1926">        source.onNext(1);</span>

<span class="fc" id="L1928">        sch.advanceTimeBy(2, TimeUnit.MILLISECONDS);</span>

<span class="fc" id="L1930">        source.onNext(2);</span>

<span class="fc" id="L1932">        assertNotNull(buf.get().value);</span>

<span class="fc" id="L1934">        buf.trimHead();</span>

<span class="fc" id="L1936">        assertNull(buf.get().value);</span>

<span class="fc" id="L1938">        Object o = buf.get();</span>

<span class="fc" id="L1940">        buf.trimHead();</span>

<span class="fc" id="L1942">        assertSame(o, buf.get());</span>
<span class="fc" id="L1943">    }</span>

    @Test(expected = TestException.class)
    public void createBufferFactoryCrash() {
<span class="fc" id="L1947">        FlowableReplay.create(Flowable.just(1), new Callable&lt;ReplayBuffer&lt;Integer&gt;&gt;() {</span>
            @Override
            public ReplayBuffer&lt;Integer&gt; call() throws Exception {
<span class="fc" id="L1950">                throw new TestException();</span>
            }
        })
<span class="nc" id="L1953">        .connect();</span>
<span class="nc" id="L1954">    }</span>

    @Test
    public void createBufferFactoryCrashOnSubscribe() {
<span class="fc" id="L1958">        FlowableReplay.create(Flowable.just(1), new Callable&lt;ReplayBuffer&lt;Integer&gt;&gt;() {</span>
            @Override
            public ReplayBuffer&lt;Integer&gt; call() throws Exception {
<span class="fc" id="L1961">                throw new TestException();</span>
            }
        })
<span class="fc" id="L1964">        .test()</span>
<span class="fc" id="L1965">        .assertFailure(TestException.class);</span>
<span class="fc" id="L1966">    }</span>

    @Test
    public void currentDisposedWhenConnecting() {
<span class="fc" id="L1970">        FlowableReplay&lt;Integer&gt; fr = (FlowableReplay&lt;Integer&gt;)FlowableReplay.create(Flowable.&lt;Integer&gt;never(), 16);</span>
<span class="fc" id="L1971">        fr.connect();</span>

<span class="fc" id="L1973">        fr.current.get().dispose();</span>
<span class="fc" id="L1974">        assertTrue(fr.current.get().isDisposed());</span>

<span class="fc" id="L1976">        fr.connect();</span>

<span class="fc" id="L1978">        assertFalse(fr.current.get().isDisposed());</span>
<span class="fc" id="L1979">    }</span>

    @Test
    public void noBoundedRetentionViaThreadLocal() throws Exception {
<span class="fc" id="L1983">        Flowable&lt;byte[]&gt; source = Flowable.range(1, 200)</span>
<span class="fc" id="L1984">        .map(new Function&lt;Integer, byte[]&gt;() {</span>
            @Override
            public byte[] apply(Integer v) throws Exception {
<span class="fc" id="L1987">                return new byte[1024 * 1024];</span>
            }
        })
<span class="fc" id="L1990">        .replay(new Function&lt;Flowable&lt;byte[]&gt;, Publisher&lt;byte[]&gt;&gt;() {</span>
            @Override
            public Publisher&lt;byte[]&gt; apply(final Flowable&lt;byte[]&gt; f) throws Exception {
<span class="fc" id="L1993">                return f.take(1)</span>
<span class="fc" id="L1994">                .concatMap(new Function&lt;byte[], Publisher&lt;byte[]&gt;&gt;() {</span>
                    @Override
                    public Publisher&lt;byte[]&gt; apply(byte[] v) throws Exception {
<span class="fc" id="L1997">                        return f;</span>
                    }
                });
            }
        }, 1)
<span class="fc" id="L2002">        .takeLast(1)</span>
        ;

<span class="fc" id="L2005">        System.out.println(&quot;Bounded Replay Leak check: Wait before GC&quot;);</span>
<span class="fc" id="L2006">        Thread.sleep(1000);</span>

<span class="fc" id="L2008">        System.out.println(&quot;Bounded Replay Leak check: GC&quot;);</span>
<span class="fc" id="L2009">        System.gc();</span>

<span class="fc" id="L2011">        Thread.sleep(500);</span>

<span class="fc" id="L2013">        final MemoryMXBean memoryMXBean = ManagementFactory.getMemoryMXBean();</span>
<span class="fc" id="L2014">        MemoryUsage memHeap = memoryMXBean.getHeapMemoryUsage();</span>
<span class="fc" id="L2015">        long initial = memHeap.getUsed();</span>

<span class="fc" id="L2017">        System.out.printf(&quot;Bounded Replay Leak check: Starting: %.3f MB%n&quot;, initial / 1024.0 / 1024.0);</span>

<span class="fc" id="L2019">        final AtomicLong after = new AtomicLong();</span>

<span class="fc" id="L2021">        source.subscribe(new Consumer&lt;byte[]&gt;() {</span>
            @Override
            public void accept(byte[] v) throws Exception {
<span class="fc" id="L2024">                System.out.println(&quot;Bounded Replay Leak check: Wait before GC 2&quot;);</span>
<span class="fc" id="L2025">                Thread.sleep(1000);</span>

<span class="fc" id="L2027">                System.out.println(&quot;Bounded Replay Leak check:  GC 2&quot;);</span>
<span class="fc" id="L2028">                System.gc();</span>

<span class="fc" id="L2030">                Thread.sleep(500);</span>

<span class="fc" id="L2032">                after.set(memoryMXBean.getHeapMemoryUsage().getUsed());</span>
<span class="fc" id="L2033">            }</span>
        });

<span class="fc" id="L2036">        System.out.printf(&quot;Bounded Replay Leak check: After: %.3f MB%n&quot;, after.get() / 1024.0 / 1024.0);</span>

<span class="pc bpc" id="L2038" title="1 of 2 branches missed.">        if (initial + 100 * 1024 * 1024 &lt; after.get()) {</span>
<span class="nc" id="L2039">            Assert.fail(&quot;Bounded Replay Leak check: Memory leak detected: &quot; + (initial / 1024.0 / 1024.0)</span>
<span class="nc" id="L2040">                    + &quot; -&gt; &quot; + after.get() / 1024.0 / 1024.0);</span>
        }
<span class="fc" id="L2042">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>