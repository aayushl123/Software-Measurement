<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FlowableRetryTest.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">RxJava_2_x$Unnamed.exec</a> &gt; <a href="index.source.html" class="el_package">io.reactivex.internal.operators.flowable</a> &gt; <span class="el_source">FlowableRetryTest.java</span></div><h1>FlowableRetryTest.java</h1><pre class="source lang-java linenums">/**
 * Copyright (c) 2016-present, RxJava Contributors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is
 * distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
 * the License for the specific language governing permissions and limitations under the License.
 */

package io.reactivex.internal.operators.flowable;

import static org.junit.Assert.*;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;

import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.*;

import org.junit.Test;
import org.mockito.*;
import org.reactivestreams.*;

import io.reactivex.*;
import io.reactivex.disposables.Disposable;
import io.reactivex.exceptions.TestException;
import io.reactivex.flowables.GroupedFlowable;
import io.reactivex.functions.*;
import io.reactivex.internal.functions.Functions;
import io.reactivex.internal.subscriptions.BooleanSubscription;
import io.reactivex.plugins.RxJavaPlugins;
import io.reactivex.processors.PublishProcessor;
import io.reactivex.schedulers.Schedulers;
import io.reactivex.subscribers.*;

<span class="fc" id="L40">public class FlowableRetryTest {</span>

    @Test
    public void iterativeBackoff() {
<span class="fc" id="L44">        Subscriber&lt;String&gt; consumer = TestHelper.mockSubscriber();</span>

<span class="fc" id="L46">        Flowable&lt;String&gt; producer = Flowable.unsafeCreate(new Publisher&lt;String&gt;() {</span>

<span class="fc" id="L48">            private AtomicInteger count = new AtomicInteger(4);</span>
<span class="fc" id="L49">            long last = System.currentTimeMillis();</span>

            @Override
            public void subscribe(Subscriber&lt;? super String&gt; t1) {
<span class="fc" id="L53">                t1.onSubscribe(new BooleanSubscription());</span>
<span class="fc" id="L54">                System.out.println(count.get() + &quot; @ &quot; + String.valueOf(last - System.currentTimeMillis()));</span>
<span class="fc" id="L55">                last = System.currentTimeMillis();</span>
<span class="fc bfc" id="L56" title="All 2 branches covered.">                if (count.getAndDecrement() == 0) {</span>
<span class="fc" id="L57">                    t1.onNext(&quot;hello&quot;);</span>
<span class="fc" id="L58">                    t1.onComplete();</span>
                } else {
<span class="fc" id="L60">                    t1.onError(new RuntimeException());</span>
                }
<span class="fc" id="L62">            }</span>

        });
<span class="fc" id="L65">        TestSubscriber&lt;String&gt; ts = new TestSubscriber&lt;String&gt;(consumer);</span>
<span class="fc" id="L66">        producer.retryWhen(new Function&lt;Flowable&lt;? extends Throwable&gt;, Flowable&lt;Object&gt;&gt;() {</span>

            @Override
            public Flowable&lt;Object&gt; apply(Flowable&lt;? extends Throwable&gt; attempts) {
                // Worker w = Schedulers.computation().createWorker();
<span class="fc" id="L71">                return attempts</span>
<span class="fc" id="L72">                    .map(new Function&lt;Throwable, Tuple&gt;() {</span>
                        @Override
                        public Tuple apply(Throwable n) {
<span class="fc" id="L75">                            return new Tuple(new Long(1), n);</span>
                        }})
<span class="fc" id="L77">                    .scan(new BiFunction&lt;Tuple, Tuple, Tuple&gt;() {</span>
                        @Override
                        public Tuple apply(Tuple t, Tuple n) {
<span class="fc" id="L80">                            return new Tuple(t.count + n.count, n.n);</span>
                        }})
<span class="fc" id="L82">                    .flatMap(new Function&lt;Tuple, Flowable&lt;Object&gt;&gt;() {</span>
                        @Override
                        public Flowable&lt;Object&gt; apply(Tuple t) {
<span class="fc" id="L85">                            System.out.println(&quot;Retry # &quot; + t.count);</span>
<span class="pc bpc" id="L86" title="1 of 2 branches missed.">                            return t.count &gt; 20 ?</span>
<span class="pc" id="L87">                                Flowable.&lt;Object&gt;error(t.n) :</span>
<span class="fc" id="L88">                                Flowable.timer(t.count * 1L, TimeUnit.MILLISECONDS)</span>
<span class="fc" id="L89">                                .cast(Object.class);</span>
                    }});
            }
<span class="fc" id="L92">        }).subscribe(ts);</span>
<span class="fc" id="L93">        ts.awaitTerminalEvent();</span>
<span class="fc" id="L94">        ts.assertNoErrors();</span>

<span class="fc" id="L96">        InOrder inOrder = inOrder(consumer);</span>
<span class="fc" id="L97">        inOrder.verify(consumer, never()).onError(any(Throwable.class));</span>
<span class="fc" id="L98">        inOrder.verify(consumer, times(1)).onNext(&quot;hello&quot;);</span>
<span class="fc" id="L99">        inOrder.verify(consumer, times(1)).onComplete();</span>
<span class="fc" id="L100">        inOrder.verifyNoMoreInteractions();</span>

<span class="fc" id="L102">    }</span>

    public static class Tuple {
        Long count;
        Throwable n;

<span class="fc" id="L108">        Tuple(Long c, Throwable n) {</span>
<span class="fc" id="L109">            count = c;</span>
<span class="fc" id="L110">            this.n = n;</span>
<span class="fc" id="L111">        }</span>
    }

    @Test
    public void testRetryIndefinitely() {
<span class="fc" id="L116">        Subscriber&lt;String&gt; subscriber = TestHelper.mockSubscriber();</span>
<span class="fc" id="L117">        int numRetries = 20;</span>
<span class="fc" id="L118">        Flowable&lt;String&gt; origin = Flowable.unsafeCreate(new FuncWithErrors(numRetries));</span>
<span class="fc" id="L119">        origin.retry().subscribe(new TestSubscriber&lt;String&gt;(subscriber));</span>

<span class="fc" id="L121">        InOrder inOrder = inOrder(subscriber);</span>
        // should show 3 attempts
<span class="fc" id="L123">        inOrder.verify(subscriber, times(numRetries + 1)).onNext(&quot;beginningEveryTime&quot;);</span>
        // should have no errors
<span class="fc" id="L125">        inOrder.verify(subscriber, never()).onError(any(Throwable.class));</span>
        // should have a single success
<span class="fc" id="L127">        inOrder.verify(subscriber, times(1)).onNext(&quot;onSuccessOnly&quot;);</span>
        // should have a single successful onComplete
<span class="fc" id="L129">        inOrder.verify(subscriber, times(1)).onComplete();</span>
<span class="fc" id="L130">        inOrder.verifyNoMoreInteractions();</span>
<span class="fc" id="L131">    }</span>

    @Test
    public void testSchedulingNotificationHandler() {
<span class="fc" id="L135">        Subscriber&lt;String&gt; subscriber = TestHelper.mockSubscriber();</span>
<span class="fc" id="L136">        int numRetries = 2;</span>
<span class="fc" id="L137">        Flowable&lt;String&gt; origin = Flowable.unsafeCreate(new FuncWithErrors(numRetries));</span>
<span class="fc" id="L138">        TestSubscriber&lt;String&gt; ts = new TestSubscriber&lt;String&gt;(subscriber);</span>
<span class="fc" id="L139">        origin.retryWhen(new Function&lt;Flowable&lt;? extends Throwable&gt;, Flowable&lt;Object&gt;&gt;() {</span>
            @Override
            public Flowable&lt;Object&gt; apply(Flowable&lt;? extends Throwable&gt; t1) {
<span class="fc" id="L142">                return t1.observeOn(Schedulers.computation()).map(new Function&lt;Throwable, Integer&gt;() {</span>
                    @Override
                    public Integer apply(Throwable t1) {
<span class="fc" id="L145">                        return 1;</span>
                    }
<span class="fc" id="L147">                }).startWith(1).cast(Object.class);</span>
            }
        })
<span class="fc" id="L150">        .doOnError(new Consumer&lt;Throwable&gt;() {</span>
            @Override
            public void accept(Throwable e) {
<span class="nc" id="L153">                e.printStackTrace();</span>
<span class="nc" id="L154">            }</span>
        })
<span class="fc" id="L156">        .subscribe(ts);</span>

<span class="fc" id="L158">        ts.awaitTerminalEvent();</span>
<span class="fc" id="L159">        InOrder inOrder = inOrder(subscriber);</span>
        // should show 3 attempts
<span class="fc" id="L161">        inOrder.verify(subscriber, times(1 + numRetries)).onNext(&quot;beginningEveryTime&quot;);</span>
        // should have no errors
<span class="fc" id="L163">        inOrder.verify(subscriber, never()).onError(any(Throwable.class));</span>
        // should have a single success
<span class="fc" id="L165">        inOrder.verify(subscriber, times(1)).onNext(&quot;onSuccessOnly&quot;);</span>
        // should have a single successful onComplete
<span class="fc" id="L167">        inOrder.verify(subscriber, times(1)).onComplete();</span>
<span class="fc" id="L168">        inOrder.verifyNoMoreInteractions();</span>
<span class="fc" id="L169">    }</span>

    @Test
    public void testOnNextFromNotificationHandler() {
<span class="fc" id="L173">        Subscriber&lt;String&gt; subscriber = TestHelper.mockSubscriber();</span>
<span class="fc" id="L174">        int numRetries = 2;</span>
<span class="fc" id="L175">        Flowable&lt;String&gt; origin = Flowable.unsafeCreate(new FuncWithErrors(numRetries));</span>
<span class="fc" id="L176">        origin.retryWhen(new Function&lt;Flowable&lt;? extends Throwable&gt;, Flowable&lt;Object&gt;&gt;() {</span>
            @Override
            public Flowable&lt;Object&gt; apply(Flowable&lt;? extends Throwable&gt; t1) {
<span class="fc" id="L179">                return t1.map(new Function&lt;Throwable, Integer&gt;() {</span>

                    @Override
                    public Integer apply(Throwable t1) {
<span class="fc" id="L183">                        return 0;</span>
                    }
<span class="fc" id="L185">                }).startWith(0).cast(Object.class);</span>
            }
<span class="fc" id="L187">        }).subscribe(subscriber);</span>

<span class="fc" id="L189">        InOrder inOrder = inOrder(subscriber);</span>
        // should show 3 attempts
<span class="fc" id="L191">        inOrder.verify(subscriber, times(numRetries + 1)).onNext(&quot;beginningEveryTime&quot;);</span>
        // should have no errors
<span class="fc" id="L193">        inOrder.verify(subscriber, never()).onError(any(Throwable.class));</span>
        // should have a single success
<span class="fc" id="L195">        inOrder.verify(subscriber, times(1)).onNext(&quot;onSuccessOnly&quot;);</span>
        // should have a single successful onComplete
<span class="fc" id="L197">        inOrder.verify(subscriber, times(1)).onComplete();</span>
<span class="fc" id="L198">        inOrder.verifyNoMoreInteractions();</span>
<span class="fc" id="L199">    }</span>

    @Test
    public void testOnCompletedFromNotificationHandler() {
<span class="fc" id="L203">        Subscriber&lt;String&gt; subscriber = TestHelper.mockSubscriber();</span>
<span class="fc" id="L204">        Flowable&lt;String&gt; origin = Flowable.unsafeCreate(new FuncWithErrors(1));</span>
<span class="fc" id="L205">        TestSubscriber&lt;String&gt; ts = new TestSubscriber&lt;String&gt;(subscriber);</span>
<span class="fc" id="L206">        origin.retryWhen(new Function&lt;Flowable&lt;? extends Throwable&gt;, Flowable&lt;Object&gt;&gt;() {</span>
            @Override
            public Flowable&lt;Object&gt; apply(Flowable&lt;? extends Throwable&gt; t1) {
<span class="fc" id="L209">                return Flowable.empty();</span>
            }
<span class="fc" id="L211">        }).subscribe(ts);</span>

<span class="fc" id="L213">        InOrder inOrder = inOrder(subscriber);</span>
<span class="fc" id="L214">        inOrder.verify(subscriber).onSubscribe((Subscription)notNull());</span>
<span class="fc" id="L215">        inOrder.verify(subscriber, never()).onNext(&quot;beginningEveryTime&quot;);</span>
<span class="fc" id="L216">        inOrder.verify(subscriber, never()).onNext(&quot;onSuccessOnly&quot;);</span>
<span class="fc" id="L217">        inOrder.verify(subscriber, times(1)).onComplete();</span>
<span class="fc" id="L218">        inOrder.verify(subscriber, never()).onError(any(Exception.class));</span>
<span class="fc" id="L219">        inOrder.verifyNoMoreInteractions();</span>
<span class="fc" id="L220">    }</span>

    @Test
    public void testOnErrorFromNotificationHandler() {
<span class="fc" id="L224">        Subscriber&lt;String&gt; subscriber = TestHelper.mockSubscriber();</span>
<span class="fc" id="L225">        Flowable&lt;String&gt; origin = Flowable.unsafeCreate(new FuncWithErrors(2));</span>
<span class="fc" id="L226">        origin.retryWhen(new Function&lt;Flowable&lt;? extends Throwable&gt;, Flowable&lt;Object&gt;&gt;() {</span>
            @Override
            public Flowable&lt;Object&gt; apply(Flowable&lt;? extends Throwable&gt; t1) {
<span class="fc" id="L229">                return Flowable.error(new RuntimeException());</span>
            }
<span class="fc" id="L231">        }).subscribe(subscriber);</span>

<span class="fc" id="L233">        InOrder inOrder = inOrder(subscriber);</span>
<span class="fc" id="L234">        inOrder.verify(subscriber).onSubscribe((Subscription)notNull());</span>
<span class="fc" id="L235">        inOrder.verify(subscriber, never()).onNext(&quot;beginningEveryTime&quot;);</span>
<span class="fc" id="L236">        inOrder.verify(subscriber, never()).onNext(&quot;onSuccessOnly&quot;);</span>
<span class="fc" id="L237">        inOrder.verify(subscriber, never()).onComplete();</span>
<span class="fc" id="L238">        inOrder.verify(subscriber, times(1)).onError(any(RuntimeException.class));</span>
<span class="fc" id="L239">        inOrder.verifyNoMoreInteractions();</span>
<span class="fc" id="L240">    }</span>

    @Test
    public void testSingleSubscriptionOnFirst() throws Exception {
<span class="fc" id="L244">        final AtomicInteger inc = new AtomicInteger(0);</span>
<span class="fc" id="L245">        Publisher&lt;Integer&gt; onSubscribe = new Publisher&lt;Integer&gt;() {</span>
            @Override
            public void subscribe(Subscriber&lt;? super Integer&gt; subscriber) {
<span class="fc" id="L248">                subscriber.onSubscribe(new BooleanSubscription());</span>
<span class="fc" id="L249">                final int emit = inc.incrementAndGet();</span>
<span class="fc" id="L250">                subscriber.onNext(emit);</span>
<span class="fc" id="L251">                subscriber.onComplete();</span>
<span class="fc" id="L252">            }</span>
        };

<span class="fc" id="L255">        int first = Flowable.unsafeCreate(onSubscribe)</span>
<span class="fc" id="L256">                .retryWhen(new Function&lt;Flowable&lt;? extends Throwable&gt;, Flowable&lt;Object&gt;&gt;() {</span>
                    @Override
                    public Flowable&lt;Object&gt; apply(Flowable&lt;? extends Throwable&gt; attempt) {
<span class="fc" id="L259">                        return attempt.zipWith(Flowable.just(1), new BiFunction&lt;Throwable, Integer, Object&gt;() {</span>
                            @Override
                            public Object apply(Throwable o, Integer integer) {
<span class="nc" id="L262">                                return 0;</span>
                            }
                        });
                    }
                })
<span class="fc" id="L267">                .blockingFirst();</span>

<span class="fc" id="L269">        assertEquals(&quot;Observer did not receive the expected output&quot;, 1, first);</span>
<span class="fc" id="L270">        assertEquals(&quot;Subscribe was not called once&quot;, 1, inc.get());</span>
<span class="fc" id="L271">    }</span>

    @Test
    public void testOriginFails() {
<span class="fc" id="L275">        Subscriber&lt;String&gt; subscriber = TestHelper.mockSubscriber();</span>
<span class="fc" id="L276">        Flowable&lt;String&gt; origin = Flowable.unsafeCreate(new FuncWithErrors(1));</span>
<span class="fc" id="L277">        origin.subscribe(subscriber);</span>

<span class="fc" id="L279">        InOrder inOrder = inOrder(subscriber);</span>
<span class="fc" id="L280">        inOrder.verify(subscriber, times(1)).onNext(&quot;beginningEveryTime&quot;);</span>
<span class="fc" id="L281">        inOrder.verify(subscriber, times(1)).onError(any(RuntimeException.class));</span>
<span class="fc" id="L282">        inOrder.verify(subscriber, never()).onNext(&quot;onSuccessOnly&quot;);</span>
<span class="fc" id="L283">        inOrder.verify(subscriber, never()).onComplete();</span>
<span class="fc" id="L284">    }</span>

    @Test
    public void testRetryFail() {
<span class="fc" id="L288">        int numRetries = 1;</span>
<span class="fc" id="L289">        int numFailures = 2;</span>
<span class="fc" id="L290">        Subscriber&lt;String&gt; subscriber = TestHelper.mockSubscriber();</span>
<span class="fc" id="L291">        Flowable&lt;String&gt; origin = Flowable.unsafeCreate(new FuncWithErrors(numFailures));</span>
<span class="fc" id="L292">        origin.retry(numRetries).subscribe(subscriber);</span>

<span class="fc" id="L294">        InOrder inOrder = inOrder(subscriber);</span>
        // should show 2 attempts (first time fail, second time (1st retry) fail)
<span class="fc" id="L296">        inOrder.verify(subscriber, times(1 + numRetries)).onNext(&quot;beginningEveryTime&quot;);</span>
        // should only retry once, fail again and emit onError
<span class="fc" id="L298">        inOrder.verify(subscriber, times(1)).onError(any(RuntimeException.class));</span>
        // no success
<span class="fc" id="L300">        inOrder.verify(subscriber, never()).onNext(&quot;onSuccessOnly&quot;);</span>
<span class="fc" id="L301">        inOrder.verify(subscriber, never()).onComplete();</span>
<span class="fc" id="L302">        inOrder.verifyNoMoreInteractions();</span>
<span class="fc" id="L303">    }</span>

    @Test
    public void testRetrySuccess() {
<span class="fc" id="L307">        int numFailures = 1;</span>
<span class="fc" id="L308">        Subscriber&lt;String&gt; subscriber = TestHelper.mockSubscriber();</span>
<span class="fc" id="L309">        Flowable&lt;String&gt; origin = Flowable.unsafeCreate(new FuncWithErrors(numFailures));</span>
<span class="fc" id="L310">        origin.retry(3).subscribe(subscriber);</span>

<span class="fc" id="L312">        InOrder inOrder = inOrder(subscriber);</span>
        // should show 3 attempts
<span class="fc" id="L314">        inOrder.verify(subscriber, times(1 + numFailures)).onNext(&quot;beginningEveryTime&quot;);</span>
        // should have no errors
<span class="fc" id="L316">        inOrder.verify(subscriber, never()).onError(any(Throwable.class));</span>
        // should have a single success
<span class="fc" id="L318">        inOrder.verify(subscriber, times(1)).onNext(&quot;onSuccessOnly&quot;);</span>
        // should have a single successful onComplete
<span class="fc" id="L320">        inOrder.verify(subscriber, times(1)).onComplete();</span>
<span class="fc" id="L321">        inOrder.verifyNoMoreInteractions();</span>
<span class="fc" id="L322">    }</span>

    @Test
    public void testInfiniteRetry() {
<span class="fc" id="L326">        int numFailures = 20;</span>
<span class="fc" id="L327">        Subscriber&lt;String&gt; subscriber = TestHelper.mockSubscriber();</span>
<span class="fc" id="L328">        Flowable&lt;String&gt; origin = Flowable.unsafeCreate(new FuncWithErrors(numFailures));</span>
<span class="fc" id="L329">        origin.retry().subscribe(subscriber);</span>

<span class="fc" id="L331">        InOrder inOrder = inOrder(subscriber);</span>
        // should show 3 attempts
<span class="fc" id="L333">        inOrder.verify(subscriber, times(1 + numFailures)).onNext(&quot;beginningEveryTime&quot;);</span>
        // should have no errors
<span class="fc" id="L335">        inOrder.verify(subscriber, never()).onError(any(Throwable.class));</span>
        // should have a single success
<span class="fc" id="L337">        inOrder.verify(subscriber, times(1)).onNext(&quot;onSuccessOnly&quot;);</span>
        // should have a single successful onComplete
<span class="fc" id="L339">        inOrder.verify(subscriber, times(1)).onComplete();</span>
<span class="fc" id="L340">        inOrder.verifyNoMoreInteractions();</span>
<span class="fc" id="L341">    }</span>

    /*
     * Checks in a simple and synchronous way that retry resubscribes
     * after error. This test fails against 0.16.1-0.17.4, hangs on 0.17.5 and
     * passes in 0.17.6 thanks to fix for issue #1027.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void testRetrySubscribesAgainAfterError() throws Exception {

        // record emitted values with this action
<span class="fc" id="L353">        Consumer&lt;Integer&gt; record = mock(Consumer.class);</span>
<span class="fc" id="L354">        InOrder inOrder = inOrder(record);</span>

        // always throw an exception with this action
<span class="fc" id="L357">        Consumer&lt;Integer&gt; throwException = mock(Consumer.class);</span>
<span class="fc" id="L358">        doThrow(new RuntimeException()).when(throwException).accept(Mockito.anyInt());</span>

        // create a retrying Flowable based on a PublishProcessor
<span class="fc" id="L361">        PublishProcessor&lt;Integer&gt; processor = PublishProcessor.create();</span>
<span class="fc" id="L362">        processor</span>
        // record item
<span class="fc" id="L364">        .doOnNext(record)</span>
        // throw a RuntimeException
<span class="fc" id="L366">                .doOnNext(throwException)</span>
                // retry on error
<span class="fc" id="L368">                .retry()</span>
                // subscribe and ignore
<span class="fc" id="L370">                .subscribe();</span>

<span class="fc" id="L372">        inOrder.verifyNoMoreInteractions();</span>

<span class="fc" id="L374">        processor.onNext(1);</span>
<span class="fc" id="L375">        inOrder.verify(record).accept(1);</span>

<span class="fc" id="L377">        processor.onNext(2);</span>
<span class="fc" id="L378">        inOrder.verify(record).accept(2);</span>

<span class="fc" id="L380">        processor.onNext(3);</span>
<span class="fc" id="L381">        inOrder.verify(record).accept(3);</span>

<span class="fc" id="L383">        inOrder.verifyNoMoreInteractions();</span>
<span class="fc" id="L384">    }</span>

    public static class FuncWithErrors implements Publisher&lt;String&gt; {

        private final int numFailures;
<span class="fc" id="L389">        private final AtomicInteger count = new AtomicInteger(0);</span>

<span class="fc" id="L391">        FuncWithErrors(int count) {</span>
<span class="fc" id="L392">            this.numFailures = count;</span>
<span class="fc" id="L393">        }</span>

        @Override
        public void subscribe(final Subscriber&lt;? super String&gt; subscriber) {
<span class="fc" id="L397">            subscriber.onSubscribe(new Subscription() {</span>
<span class="fc" id="L398">                final AtomicLong req = new AtomicLong();</span>
                // 0 = not set, 1 = fast path, 2 = backpressure
<span class="fc" id="L400">                final AtomicInteger path = new AtomicInteger(0);</span>
                volatile boolean done;

                @Override
                public void request(long n) {
<span class="pc bpc" id="L405" title="1 of 4 branches missed.">                    if (n == Long.MAX_VALUE &amp;&amp; path.compareAndSet(0, 1)) {</span>
<span class="fc" id="L406">                        subscriber.onNext(&quot;beginningEveryTime&quot;);</span>
<span class="fc" id="L407">                        int i = count.getAndIncrement();</span>
<span class="fc bfc" id="L408" title="All 2 branches covered.">                        if (i &lt; numFailures) {</span>
<span class="fc" id="L409">                            subscriber.onError(new RuntimeException(&quot;forced failure: &quot; + (i + 1)));</span>
                        } else {
<span class="fc" id="L411">                            subscriber.onNext(&quot;onSuccessOnly&quot;);</span>
<span class="fc" id="L412">                            subscriber.onComplete();</span>
                        }
<span class="fc" id="L414">                        return;</span>
                    }
<span class="pc bpc" id="L416" title="4 of 10 branches missed.">                    if (n &gt; 0 &amp;&amp; req.getAndAdd(n) == 0 &amp;&amp; (path.get() == 2 || path.compareAndSet(0, 2)) &amp;&amp; !done) {</span>
<span class="fc" id="L417">                        int i = count.getAndIncrement();</span>
<span class="fc bfc" id="L418" title="All 2 branches covered.">                        if (i &lt; numFailures) {</span>
<span class="fc" id="L419">                            subscriber.onNext(&quot;beginningEveryTime&quot;);</span>
<span class="fc" id="L420">                            subscriber.onError(new RuntimeException(&quot;forced failure: &quot; + (i + 1)));</span>
<span class="fc" id="L421">                            done = true;</span>
                        } else {
                            do {
<span class="fc bfc" id="L424" title="All 2 branches covered.">                                if (i == numFailures) {</span>
<span class="fc" id="L425">                                    subscriber.onNext(&quot;beginningEveryTime&quot;);</span>
                                } else
<span class="pc bpc" id="L427" title="1 of 2 branches missed.">                                if (i &gt; numFailures) {</span>
<span class="fc" id="L428">                                    subscriber.onNext(&quot;onSuccessOnly&quot;);</span>
<span class="fc" id="L429">                                    subscriber.onComplete();</span>
<span class="fc" id="L430">                                    done = true;</span>
<span class="fc" id="L431">                                    break;</span>
                                }
<span class="fc" id="L433">                                i = count.getAndIncrement();</span>
<span class="pc bpc" id="L434" title="1 of 2 branches missed.">                            } while (req.decrementAndGet() &gt; 0);</span>
                        }
                    }
<span class="fc" id="L437">                }</span>

                @Override
                public void cancel() {
                    // TODO Auto-generated method stub

<span class="nc" id="L443">                }</span>
            });
<span class="fc" id="L445">        }</span>
    }

    @Test
    public void testUnsubscribeFromRetry() {
<span class="fc" id="L450">        PublishProcessor&lt;Integer&gt; processor = PublishProcessor.create();</span>
<span class="fc" id="L451">        final AtomicInteger count = new AtomicInteger(0);</span>
<span class="fc" id="L452">        Disposable sub = processor.retry().subscribe(new Consumer&lt;Integer&gt;() {</span>
            @Override
            public void accept(Integer n) {
<span class="fc" id="L455">                count.incrementAndGet();</span>
<span class="fc" id="L456">            }</span>
        });
<span class="fc" id="L458">        processor.onNext(1);</span>
<span class="fc" id="L459">        sub.dispose();</span>
<span class="fc" id="L460">        processor.onNext(2);</span>
<span class="fc" id="L461">        assertEquals(1, count.get());</span>
<span class="fc" id="L462">    }</span>

    @Test
    public void testRetryAllowsSubscriptionAfterAllSubscriptionsUnsubscribed() throws InterruptedException {
<span class="fc" id="L466">        final AtomicInteger subsCount = new AtomicInteger(0);</span>
<span class="fc" id="L467">        Publisher&lt;String&gt; onSubscribe = new Publisher&lt;String&gt;() {</span>
            @Override
            public void subscribe(Subscriber&lt;? super String&gt; s) {
<span class="fc" id="L470">                subsCount.incrementAndGet();</span>
<span class="fc" id="L471">                s.onSubscribe(new Subscription() {</span>

                    @Override
                    public void request(long n) {

<span class="fc" id="L476">                    }</span>

                    @Override
                    public void cancel() {
<span class="fc" id="L480">                        subsCount.decrementAndGet();</span>
<span class="fc" id="L481">                    }</span>
                });

<span class="fc" id="L484">            }</span>
        };
<span class="fc" id="L486">        Flowable&lt;String&gt; stream = Flowable.unsafeCreate(onSubscribe);</span>
<span class="fc" id="L487">        Flowable&lt;String&gt; streamWithRetry = stream.retry();</span>
<span class="fc" id="L488">        Disposable sub = streamWithRetry.subscribe();</span>
<span class="fc" id="L489">        assertEquals(1, subsCount.get());</span>
<span class="fc" id="L490">        sub.dispose();</span>
<span class="fc" id="L491">        assertEquals(0, subsCount.get());</span>
<span class="fc" id="L492">        streamWithRetry.subscribe();</span>
<span class="fc" id="L493">        assertEquals(1, subsCount.get());</span>
<span class="fc" id="L494">    }</span>

    @Test
    public void testSourceFlowableCallsUnsubscribe() throws InterruptedException {
<span class="fc" id="L498">        final AtomicInteger subsCount = new AtomicInteger(0);</span>

<span class="fc" id="L500">        final TestSubscriber&lt;String&gt; ts = new TestSubscriber&lt;String&gt;();</span>

<span class="fc" id="L502">        Publisher&lt;String&gt; onSubscribe = new Publisher&lt;String&gt;() {</span>
            @Override
            public void subscribe(Subscriber&lt;? super String&gt; s) {
<span class="fc" id="L505">                BooleanSubscription bs = new BooleanSubscription();</span>
                // if isUnsubscribed is true that means we have a bug such as
                // https://github.com/ReactiveX/RxJava/issues/1024
<span class="pc bpc" id="L508" title="1 of 2 branches missed.">                if (!bs.isCancelled()) {</span>
<span class="fc" id="L509">                    subsCount.incrementAndGet();</span>
<span class="fc" id="L510">                    s.onError(new RuntimeException(&quot;failed&quot;));</span>
                    // it unsubscribes the child directly
                    // this simulates various error/completion scenarios that could occur
                    // or just a source that proactively triggers cleanup
                    // FIXME can't unsubscribe child
//                    s.unsubscribe();
<span class="fc" id="L516">                    bs.cancel();</span>
                } else {
<span class="nc" id="L518">                    s.onError(new RuntimeException());</span>
                }
<span class="fc" id="L520">            }</span>
        };

<span class="fc" id="L523">        Flowable.unsafeCreate(onSubscribe).retry(3).subscribe(ts);</span>
<span class="fc" id="L524">        assertEquals(4, subsCount.get()); // 1 + 3 retries</span>
<span class="fc" id="L525">    }</span>

    @Test
    public void testSourceFlowableRetry1() throws InterruptedException {
<span class="fc" id="L529">        final AtomicInteger subsCount = new AtomicInteger(0);</span>

<span class="fc" id="L531">        final TestSubscriber&lt;String&gt; ts = new TestSubscriber&lt;String&gt;();</span>

<span class="fc" id="L533">        Publisher&lt;String&gt; onSubscribe = new Publisher&lt;String&gt;() {</span>
            @Override
            public void subscribe(Subscriber&lt;? super String&gt; s) {
<span class="fc" id="L536">                s.onSubscribe(new BooleanSubscription());</span>
<span class="fc" id="L537">                subsCount.incrementAndGet();</span>
<span class="fc" id="L538">                s.onError(new RuntimeException(&quot;failed&quot;));</span>
<span class="fc" id="L539">            }</span>
        };

<span class="fc" id="L542">        Flowable.unsafeCreate(onSubscribe).retry(1).subscribe(ts);</span>
<span class="fc" id="L543">        assertEquals(2, subsCount.get());</span>
<span class="fc" id="L544">    }</span>

    @Test
    public void testSourceFlowableRetry0() throws InterruptedException {
<span class="fc" id="L548">        final AtomicInteger subsCount = new AtomicInteger(0);</span>

<span class="fc" id="L550">        final TestSubscriber&lt;String&gt; ts = new TestSubscriber&lt;String&gt;();</span>

<span class="fc" id="L552">        Publisher&lt;String&gt; onSubscribe = new Publisher&lt;String&gt;() {</span>
            @Override
            public void subscribe(Subscriber&lt;? super String&gt; s) {
<span class="fc" id="L555">                s.onSubscribe(new BooleanSubscription());</span>
<span class="fc" id="L556">                subsCount.incrementAndGet();</span>
<span class="fc" id="L557">                s.onError(new RuntimeException(&quot;failed&quot;));</span>
<span class="fc" id="L558">            }</span>
        };

<span class="fc" id="L561">        Flowable.unsafeCreate(onSubscribe).retry(0).subscribe(ts);</span>
<span class="fc" id="L562">        assertEquals(1, subsCount.get());</span>
<span class="fc" id="L563">    }</span>

    static final class SlowFlowable implements Publisher&lt;Long&gt; {

<span class="fc" id="L567">        final AtomicInteger efforts = new AtomicInteger(0);</span>
<span class="fc" id="L568">        final AtomicInteger active = new AtomicInteger(0);</span>
<span class="fc" id="L569">        final AtomicInteger maxActive = new AtomicInteger(0);</span>
        final AtomicInteger nextBeforeFailure;
        final String context;

        private final int emitDelay;

<span class="fc" id="L575">        SlowFlowable(int emitDelay, int countNext, String context) {</span>
<span class="fc" id="L576">            this.emitDelay = emitDelay;</span>
<span class="fc" id="L577">            this.nextBeforeFailure = new AtomicInteger(countNext);</span>
<span class="fc" id="L578">            this.context = context;</span>
<span class="fc" id="L579">        }</span>

        @Override
        public void subscribe(final Subscriber&lt;? super Long&gt; subscriber) {
<span class="fc" id="L583">            final AtomicBoolean terminate = new AtomicBoolean(false);</span>
<span class="fc" id="L584">            subscriber.onSubscribe(new Subscription() {</span>
                @Override
                public void request(long n) {
                    // TODO Auto-generated method stub

<span class="fc" id="L589">                }</span>

                @Override
                public void cancel() {
<span class="fc" id="L593">                    terminate.set(true);</span>
<span class="fc" id="L594">                    active.decrementAndGet();</span>
<span class="fc" id="L595">                }</span>
            });
<span class="fc" id="L597">            efforts.getAndIncrement();</span>
<span class="fc" id="L598">            active.getAndIncrement();</span>
<span class="fc" id="L599">            maxActive.set(Math.max(active.get(), maxActive.get()));</span>
<span class="fc" id="L600">            final Thread thread = new Thread(context) {</span>
                @Override
                public void run() {
<span class="fc" id="L603">                    long nr = 0;</span>
                    try {
<span class="fc bfc" id="L605" title="All 2 branches covered.">                        while (!terminate.get()) {</span>
<span class="fc" id="L606">                            Thread.sleep(emitDelay);</span>
<span class="fc bfc" id="L607" title="All 2 branches covered.">                            if (nextBeforeFailure.getAndDecrement() &gt; 0) {</span>
<span class="fc" id="L608">                                subscriber.onNext(nr++);</span>
                            } else {
<span class="fc" id="L610">                                active.decrementAndGet();</span>
<span class="fc" id="L611">                                subscriber.onError(new RuntimeException(&quot;expected-failed&quot;));</span>
<span class="fc" id="L612">                                break;</span>
                            }
                        }
<span class="nc" id="L615">                    } catch (InterruptedException t) {</span>
<span class="fc" id="L616">                    }</span>
<span class="fc" id="L617">                }</span>
            };
<span class="fc" id="L619">            thread.start();</span>
<span class="fc" id="L620">        }</span>
    }

    /** Observer for listener on seperate thread. */
    static final class AsyncSubscriber&lt;T&gt; extends DefaultSubscriber&lt;T&gt; {

<span class="fc" id="L626">        protected CountDownLatch latch = new CountDownLatch(1);</span>

        protected Subscriber&lt;T&gt; target;

        /**
         * Wrap existing Observer.
         * @param target the target subscriber
         */
<span class="fc" id="L634">        AsyncSubscriber(Subscriber&lt;T&gt; target) {</span>
<span class="fc" id="L635">            this.target = target;</span>
<span class="fc" id="L636">        }</span>

        /** Wait. */
        public void await() {
            try {
<span class="fc" id="L641">                latch.await();</span>
<span class="nc" id="L642">            } catch (InterruptedException e) {</span>
<span class="nc" id="L643">                fail(&quot;Test interrupted&quot;);</span>
<span class="fc" id="L644">            }</span>
<span class="fc" id="L645">        }</span>

        // Observer implementation

        @Override
        public void onComplete() {
<span class="nc" id="L651">            target.onComplete();</span>
<span class="nc" id="L652">            latch.countDown();</span>
<span class="nc" id="L653">        }</span>

        @Override
        public void onError(Throwable t) {
<span class="fc" id="L657">            target.onError(t);</span>
<span class="fc" id="L658">            latch.countDown();</span>
<span class="fc" id="L659">        }</span>

        @Override
        public void onNext(T v) {
<span class="nc" id="L663">            target.onNext(v);</span>
<span class="nc" id="L664">        }</span>
    }

    @Test(timeout = 10000)
    public void testUnsubscribeAfterError() {

<span class="fc" id="L670">        Subscriber&lt;Long&gt; subscriber = TestHelper.mockSubscriber();</span>

        // Flowable that always fails after 100ms
<span class="fc" id="L673">        SlowFlowable so = new SlowFlowable(100, 0, &quot;testUnsubscribeAfterError&quot;);</span>
<span class="fc" id="L674">        Flowable&lt;Long&gt; f = Flowable.unsafeCreate(so).retry(5);</span>

<span class="fc" id="L676">        AsyncSubscriber&lt;Long&gt; async = new AsyncSubscriber&lt;Long&gt;(subscriber);</span>

<span class="fc" id="L678">        f.subscribe(async);</span>

<span class="fc" id="L680">        async.await();</span>

<span class="fc" id="L682">        InOrder inOrder = inOrder(subscriber);</span>
        // Should fail once
<span class="fc" id="L684">        inOrder.verify(subscriber, times(1)).onError(any(Throwable.class));</span>
<span class="fc" id="L685">        inOrder.verify(subscriber, never()).onComplete();</span>

<span class="fc" id="L687">        assertEquals(&quot;Start 6 threads, retry 5 then fail on 6&quot;, 6, so.efforts.get());</span>
<span class="fc" id="L688">        assertEquals(&quot;Only 1 active subscription&quot;, 1, so.maxActive.get());</span>
<span class="fc" id="L689">    }</span>

    @Test//(timeout = 10000)
    public void testTimeoutWithRetry() {

<span class="fc" id="L694">        Subscriber&lt;Long&gt; subscriber = TestHelper.mockSubscriber();</span>

        // Flowable that sends every 100ms (timeout fails instead)
<span class="fc" id="L697">        SlowFlowable sf = new SlowFlowable(100, 10, &quot;testTimeoutWithRetry&quot;);</span>
<span class="fc" id="L698">        Flowable&lt;Long&gt; f = Flowable.unsafeCreate(sf).timeout(80, TimeUnit.MILLISECONDS).retry(5);</span>

<span class="fc" id="L700">        AsyncSubscriber&lt;Long&gt; async = new AsyncSubscriber&lt;Long&gt;(subscriber);</span>

<span class="fc" id="L702">        f.subscribe(async);</span>

<span class="fc" id="L704">        async.await();</span>

<span class="fc" id="L706">        InOrder inOrder = inOrder(subscriber);</span>
        // Should fail once
<span class="fc" id="L708">        inOrder.verify(subscriber, times(1)).onError(any(Throwable.class));</span>
<span class="fc" id="L709">        inOrder.verify(subscriber, never()).onComplete();</span>

<span class="fc" id="L711">        assertEquals(&quot;Start 6 threads, retry 5 then fail on 6&quot;, 6, sf.efforts.get());</span>
<span class="fc" id="L712">    }</span>

    @Test//(timeout = 15000)
    public void testRetryWithBackpressure() throws InterruptedException {
<span class="fc" id="L716">        final int NUM_LOOPS = 1;</span>
<span class="fc bfc" id="L717" title="All 2 branches covered.">        for (int j = 0; j &lt; NUM_LOOPS; j++) {</span>
<span class="fc" id="L718">            final int numRetries = Flowable.bufferSize() * 2;</span>
<span class="fc bfc" id="L719" title="All 2 branches covered.">            for (int i = 0; i &lt; 400; i++) {</span>
<span class="fc" id="L720">                Subscriber&lt;String&gt; subscriber = TestHelper.mockSubscriber();</span>
<span class="fc" id="L721">                Flowable&lt;String&gt; origin = Flowable.unsafeCreate(new FuncWithErrors(numRetries));</span>
<span class="fc" id="L722">                TestSubscriber&lt;String&gt; ts = new TestSubscriber&lt;String&gt;(subscriber);</span>
<span class="fc" id="L723">                origin.retry().observeOn(Schedulers.computation()).subscribe(ts);</span>
<span class="fc" id="L724">                ts.awaitTerminalEvent(5, TimeUnit.SECONDS);</span>

<span class="fc" id="L726">                InOrder inOrder = inOrder(subscriber);</span>
                // should have no errors
<span class="fc" id="L728">                verify(subscriber, never()).onError(any(Throwable.class));</span>
                // should show numRetries attempts
<span class="fc" id="L730">                inOrder.verify(subscriber, times(numRetries + 1)).onNext(&quot;beginningEveryTime&quot;);</span>
                // should have a single success
<span class="fc" id="L732">                inOrder.verify(subscriber, times(1)).onNext(&quot;onSuccessOnly&quot;);</span>
                // should have a single successful onComplete
<span class="fc" id="L734">                inOrder.verify(subscriber, times(1)).onComplete();</span>
<span class="fc" id="L735">                inOrder.verifyNoMoreInteractions();</span>
            }
        }
<span class="fc" id="L738">    }</span>

    @Test//(timeout = 15000)
    public void testRetryWithBackpressureParallel() throws InterruptedException {
<span class="fc" id="L742">        final int NUM_LOOPS = 1;</span>
<span class="fc" id="L743">        final int numRetries = Flowable.bufferSize() * 2;</span>
<span class="fc" id="L744">        int ncpu = Runtime.getRuntime().availableProcessors();</span>
<span class="fc" id="L745">        ExecutorService exec = Executors.newFixedThreadPool(Math.max(ncpu / 2, 2));</span>
        try {
<span class="fc bfc" id="L747" title="All 2 branches covered.">            for (int r = 0; r &lt; NUM_LOOPS; r++) {</span>
<span class="pc bpc" id="L748" title="1 of 2 branches missed.">                if (r % 10 == 0) {</span>
<span class="fc" id="L749">                    System.out.println(&quot;testRetryWithBackpressureParallelLoop -&gt; &quot; + r);</span>
                }

<span class="fc" id="L752">                final AtomicInteger timeouts = new AtomicInteger();</span>
<span class="fc" id="L753">                final Map&lt;Integer, List&lt;String&gt;&gt; data = new ConcurrentHashMap&lt;Integer, List&lt;String&gt;&gt;();</span>

<span class="fc" id="L755">                int m = 5000;</span>
<span class="fc" id="L756">                final CountDownLatch cdl = new CountDownLatch(m);</span>
<span class="fc bfc" id="L757" title="All 2 branches covered.">                for (int i = 0; i &lt; m; i++) {</span>
<span class="fc" id="L758">                    final int j = i;</span>
<span class="fc" id="L759">                    exec.execute(new Runnable() {</span>
                        @Override
                        public void run() {
<span class="fc" id="L762">                            final AtomicInteger nexts = new AtomicInteger();</span>
                            try {
<span class="fc" id="L764">                                Flowable&lt;String&gt; origin = Flowable.unsafeCreate(new FuncWithErrors(numRetries));</span>
<span class="fc" id="L765">                                TestSubscriber&lt;String&gt; ts = new TestSubscriber&lt;String&gt;();</span>
<span class="fc" id="L766">                                origin.retry()</span>
<span class="fc" id="L767">                                .observeOn(Schedulers.computation()).subscribe(ts);</span>
<span class="fc" id="L768">                                ts.awaitTerminalEvent(2500, TimeUnit.MILLISECONDS);</span>
<span class="fc" id="L769">                                List&lt;String&gt; onNextEvents = new ArrayList&lt;String&gt;(ts.values());</span>
<span class="pc bpc" id="L770" title="1 of 2 branches missed.">                                if (onNextEvents.size() != numRetries + 2) {</span>
<span class="nc bnc" id="L771" title="All 2 branches missed.">                                    for (Throwable t : ts.errors()) {</span>
<span class="nc" id="L772">                                        onNextEvents.add(t.toString());</span>
<span class="nc" id="L773">                                    }</span>
<span class="nc bnc" id="L774" title="All 2 branches missed.">                                    for (long err = ts.completions(); err != 0; err--) {</span>
<span class="nc" id="L775">                                        onNextEvents.add(&quot;onComplete&quot;);</span>
                                    }
<span class="nc" id="L777">                                    data.put(j, onNextEvents);</span>
                                }
<span class="nc" id="L779">                            } catch (Throwable t) {</span>
<span class="nc" id="L780">                                timeouts.incrementAndGet();</span>
<span class="nc" id="L781">                                System.out.println(j + &quot; | &quot; + cdl.getCount() + &quot; !!! &quot; + nexts.get());</span>
<span class="fc" id="L782">                            }</span>
<span class="fc" id="L783">                            cdl.countDown();</span>
<span class="fc" id="L784">                        }</span>
                    });
                }
<span class="fc" id="L787">                cdl.await();</span>
<span class="fc" id="L788">                assertEquals(0, timeouts.get());</span>
<span class="pc bpc" id="L789" title="1 of 2 branches missed.">                if (data.size() &gt; 0) {</span>
<span class="nc" id="L790">                    fail(&quot;Data content mismatch: &quot; + allSequenceFrequency(data));</span>
                }
            }
        } finally {
<span class="fc" id="L794">            exec.shutdown();</span>
        }
<span class="fc" id="L796">    }</span>
    static &lt;T&gt; StringBuilder allSequenceFrequency(Map&lt;Integer, List&lt;T&gt;&gt; its) {
<span class="nc" id="L798">        StringBuilder b = new StringBuilder();</span>
<span class="nc bnc" id="L799" title="All 2 branches missed.">        for (Map.Entry&lt;Integer, List&lt;T&gt;&gt; e : its.entrySet()) {</span>
<span class="nc bnc" id="L800" title="All 2 branches missed.">            if (b.length() &gt; 0) {</span>
<span class="nc" id="L801">                b.append(&quot;, &quot;);</span>
            }
<span class="nc" id="L803">            b.append(e.getKey()).append(&quot;={&quot;);</span>
<span class="nc" id="L804">            b.append(sequenceFrequency(e.getValue()));</span>
<span class="nc" id="L805">            b.append(&quot;}&quot;);</span>
<span class="nc" id="L806">        }</span>
<span class="nc" id="L807">        return b;</span>
    }
    static &lt;T&gt; StringBuilder sequenceFrequency(Iterable&lt;T&gt; it) {
<span class="nc" id="L810">        StringBuilder sb = new StringBuilder();</span>

<span class="nc" id="L812">        Object prev = null;</span>
<span class="nc" id="L813">        int cnt = 0;</span>

<span class="nc bnc" id="L815" title="All 2 branches missed.">        for (Object curr : it) {</span>
<span class="nc bnc" id="L816" title="All 2 branches missed.">            if (sb.length() &gt; 0) {</span>
<span class="nc bnc" id="L817" title="All 2 branches missed.">                if (!curr.equals(prev)) {</span>
<span class="nc bnc" id="L818" title="All 2 branches missed.">                    if (cnt &gt; 1) {</span>
<span class="nc" id="L819">                        sb.append(&quot; x &quot;).append(cnt);</span>
<span class="nc" id="L820">                        cnt = 1;</span>
                    }
<span class="nc" id="L822">                    sb.append(&quot;, &quot;);</span>
<span class="nc" id="L823">                    sb.append(curr);</span>
                } else {
<span class="nc" id="L825">                    cnt++;</span>
                }
            } else {
<span class="nc" id="L828">                sb.append(curr);</span>
<span class="nc" id="L829">                cnt++;</span>
            }
<span class="nc" id="L831">            prev = curr;</span>
<span class="nc" id="L832">        }</span>
<span class="nc bnc" id="L833" title="All 2 branches missed.">        if (cnt &gt; 1) {</span>
<span class="nc" id="L834">            sb.append(&quot; x &quot;).append(cnt);</span>
        }

<span class="nc" id="L837">        return sb;</span>
    }

    @Test//(timeout = 3000)
    public void testIssue1900() throws InterruptedException {
<span class="fc" id="L842">        Subscriber&lt;String&gt; subscriber = TestHelper.mockSubscriber();</span>
<span class="fc" id="L843">        final int NUM_MSG = 1034;</span>
<span class="fc" id="L844">        final AtomicInteger count = new AtomicInteger();</span>

<span class="fc" id="L846">        Flowable&lt;String&gt; origin = Flowable.range(0, NUM_MSG)</span>
<span class="fc" id="L847">                .map(new Function&lt;Integer, String&gt;() {</span>
                    @Override
                    public String apply(Integer t1) {
<span class="fc" id="L850">                        return &quot;msg: &quot; + count.incrementAndGet();</span>
                    }
                });

<span class="fc" id="L854">        origin.retry()</span>
<span class="fc" id="L855">        .groupBy(new Function&lt;String, String&gt;() {</span>
            @Override
            public String apply(String t1) {
<span class="fc" id="L858">                return t1;</span>
            }
        })
<span class="fc" id="L861">        .flatMap(new Function&lt;GroupedFlowable&lt;String, String&gt;, Flowable&lt;String&gt;&gt;() {</span>
            @Override
            public Flowable&lt;String&gt; apply(GroupedFlowable&lt;String, String&gt; t1) {
<span class="fc" id="L864">                return t1.take(1);</span>
            }
        })
<span class="fc" id="L867">        .subscribe(new TestSubscriber&lt;String&gt;(subscriber));</span>

<span class="fc" id="L869">        InOrder inOrder = inOrder(subscriber);</span>
        // should show 3 attempts
<span class="fc" id="L871">        inOrder.verify(subscriber, times(NUM_MSG)).onNext(any(java.lang.String.class));</span>
        //        // should have no errors
<span class="fc" id="L873">        inOrder.verify(subscriber, never()).onError(any(Throwable.class));</span>
        // should have a single success
        //inOrder.verify(observer, times(1)).onNext(&quot;onSuccessOnly&quot;);
        // should have a single successful onComplete
<span class="fc" id="L877">        inOrder.verify(subscriber, times(1)).onComplete();</span>
<span class="fc" id="L878">        inOrder.verifyNoMoreInteractions();</span>
<span class="fc" id="L879">    }</span>

    @Test//(timeout = 3000)
    public void testIssue1900SourceNotSupportingBackpressure() {
<span class="fc" id="L883">        Subscriber&lt;String&gt; subscriber = TestHelper.mockSubscriber();</span>
<span class="fc" id="L884">        final int NUM_MSG = 1034;</span>
<span class="fc" id="L885">        final AtomicInteger count = new AtomicInteger();</span>

<span class="fc" id="L887">        Flowable&lt;String&gt; origin = Flowable.unsafeCreate(new Publisher&lt;String&gt;() {</span>

            @Override
            public void subscribe(Subscriber&lt;? super String&gt; subscriber) {
<span class="fc" id="L891">                subscriber.onSubscribe(new BooleanSubscription());</span>
<span class="fc bfc" id="L892" title="All 2 branches covered.">                for (int i = 0; i &lt; NUM_MSG; i++) {</span>
<span class="fc" id="L893">                    subscriber.onNext(&quot;msg:&quot; + count.incrementAndGet());</span>
                }
<span class="fc" id="L895">                subscriber.onComplete();</span>
<span class="fc" id="L896">            }</span>
        });

<span class="fc" id="L899">        origin.retry()</span>
<span class="fc" id="L900">        .groupBy(new Function&lt;String, String&gt;() {</span>
            @Override
            public String apply(String t1) {
<span class="fc" id="L903">                return t1;</span>
            }
        })
<span class="fc" id="L906">        .flatMap(new Function&lt;GroupedFlowable&lt;String, String&gt;, Flowable&lt;String&gt;&gt;() {</span>
            @Override
            public Flowable&lt;String&gt; apply(GroupedFlowable&lt;String, String&gt; t1) {
<span class="fc" id="L909">                return t1.take(1);</span>
            }
        })
<span class="fc" id="L912">        .subscribe(new TestSubscriber&lt;String&gt;(subscriber));</span>

<span class="fc" id="L914">        InOrder inOrder = inOrder(subscriber);</span>
        // should show 3 attempts
<span class="fc" id="L916">        inOrder.verify(subscriber, times(NUM_MSG)).onNext(any(java.lang.String.class));</span>
        //        // should have no errors
<span class="fc" id="L918">        inOrder.verify(subscriber, never()).onError(any(Throwable.class));</span>
        // should have a single success
        //inOrder.verify(observer, times(1)).onNext(&quot;onSuccessOnly&quot;);
        // should have a single successful onComplete
<span class="fc" id="L922">        inOrder.verify(subscriber, times(1)).onComplete();</span>
<span class="fc" id="L923">        inOrder.verifyNoMoreInteractions();</span>
<span class="fc" id="L924">    }</span>

    @SuppressWarnings({ &quot;rawtypes&quot;, &quot;unchecked&quot; })
    @Test
    public void retryWhenDefaultScheduler() {
<span class="fc" id="L929">        TestSubscriber&lt;Integer&gt; ts = TestSubscriber.create();</span>

<span class="fc" id="L931">        Flowable.just(1)</span>
<span class="fc" id="L932">        .concatWith(Flowable.&lt;Integer&gt;error(new TestException()))</span>
<span class="fc" id="L933">        .retryWhen((Function)new Function&lt;Flowable, Flowable&gt;() {</span>
            @Override
            public Flowable apply(Flowable f) {
<span class="fc" id="L936">                return f.take(2);</span>
            }
<span class="fc" id="L938">        }).subscribe(ts);</span>

<span class="fc" id="L940">        ts.assertValues(1, 1);</span>
<span class="fc" id="L941">        ts.assertNoErrors();</span>
<span class="fc" id="L942">        ts.assertComplete();</span>

<span class="fc" id="L944">    }</span>

    @SuppressWarnings({ &quot;rawtypes&quot;, &quot;unchecked&quot; })
    @Test
    public void retryWhenTrampolineScheduler() {
<span class="fc" id="L949">        TestSubscriber&lt;Integer&gt; ts = TestSubscriber.create();</span>

<span class="fc" id="L951">        Flowable.just(1)</span>
<span class="fc" id="L952">        .concatWith(Flowable.&lt;Integer&gt;error(new TestException()))</span>
<span class="fc" id="L953">        .subscribeOn(Schedulers.trampoline())</span>
<span class="fc" id="L954">        .retryWhen((Function)new Function&lt;Flowable, Flowable&gt;() {</span>
            @Override
            public Flowable apply(Flowable f) {
<span class="fc" id="L957">                return f.take(2);</span>
            }
<span class="fc" id="L959">        }).subscribe(ts);</span>

<span class="fc" id="L961">        ts.assertValues(1, 1);</span>
<span class="fc" id="L962">        ts.assertNoErrors();</span>
<span class="fc" id="L963">        ts.assertComplete();</span>
<span class="fc" id="L964">    }</span>

    @Test
    public void retryPredicate() {
<span class="fc" id="L968">        Flowable.just(1).concatWith(Flowable.&lt;Integer&gt;error(new TestException()))</span>
<span class="fc" id="L969">        .retry(new Predicate&lt;Throwable&gt;() {</span>
            @Override
            public boolean test(Throwable v) throws Exception {
<span class="fc" id="L972">                return true;</span>
            }
        })
<span class="fc" id="L975">        .take(5)</span>
<span class="fc" id="L976">        .test()</span>
<span class="fc" id="L977">        .assertResult(1, 1, 1, 1, 1);</span>
<span class="fc" id="L978">    }</span>

    @Test
    public void retryLongPredicateInvalid() {
        try {
<span class="pc" id="L983">            Flowable.just(1).retry(-99, new Predicate&lt;Throwable&gt;() {</span>
                @Override
                public boolean test(Throwable e) throws Exception {
<span class="nc" id="L986">                    return true;</span>
                }
            });
<span class="nc" id="L989">            fail(&quot;Should have thrown&quot;);</span>
<span class="fc" id="L990">        } catch (IllegalArgumentException ex) {</span>
<span class="fc" id="L991">            assertEquals(&quot;times &gt;= 0 required but it was -99&quot;, ex.getMessage());</span>
<span class="nc" id="L992">        }</span>
<span class="fc" id="L993">    }</span>

    @Test
    public void retryUntil() {
<span class="fc" id="L997">        Flowable.just(1).concatWith(Flowable.&lt;Integer&gt;error(new TestException()))</span>
<span class="fc" id="L998">        .retryUntil(new BooleanSupplier() {</span>
            @Override
            public boolean getAsBoolean() throws Exception {
<span class="fc" id="L1001">                return false;</span>
            }
        })
<span class="fc" id="L1004">        .take(5)</span>
<span class="fc" id="L1005">        .test()</span>
<span class="fc" id="L1006">        .assertResult(1, 1, 1, 1, 1);</span>
<span class="fc" id="L1007">    }</span>

    @Test
    public void shouldDisposeInnerFlowable() {
<span class="fc" id="L1011">      final PublishProcessor&lt;Object&gt; processor = PublishProcessor.create();</span>
<span class="fc" id="L1012">      final Disposable disposable = Flowable.error(new RuntimeException(&quot;Leak&quot;))</span>
<span class="fc" id="L1013">          .retryWhen(new Function&lt;Flowable&lt;Throwable&gt;, Flowable&lt;Object&gt;&gt;() {</span>
            @Override
            public Flowable&lt;Object&gt; apply(Flowable&lt;Throwable&gt; errors) throws Exception {
<span class="fc" id="L1016">                return errors.switchMap(new Function&lt;Throwable, Flowable&lt;Object&gt;&gt;() {</span>
                    @Override
                    public Flowable&lt;Object&gt; apply(Throwable ignore) throws Exception {
<span class="fc" id="L1019">                        return processor;</span>
                    }
                });
            }
        })
<span class="fc" id="L1024">          .subscribe();</span>

<span class="fc" id="L1026">      assertTrue(processor.hasSubscribers());</span>
<span class="fc" id="L1027">      disposable.dispose();</span>
<span class="fc" id="L1028">      assertFalse(processor.hasSubscribers());</span>
<span class="fc" id="L1029">    }</span>

    @Test
    public void noCancelPreviousRetry() {
<span class="fc" id="L1033">        final AtomicInteger counter = new AtomicInteger();</span>

<span class="fc" id="L1035">        final AtomicInteger times = new AtomicInteger();</span>

<span class="fc" id="L1037">        Flowable&lt;Integer&gt; source = Flowable.defer(new Callable&lt;Flowable&lt;Integer&gt;&gt;() {</span>
            @Override
            public Flowable&lt;Integer&gt; call() throws Exception {
<span class="fc bfc" id="L1040" title="All 2 branches covered.">                if (times.getAndIncrement() &lt; 4) {</span>
<span class="fc" id="L1041">                    return Flowable.error(new TestException());</span>
                }
<span class="fc" id="L1043">                return Flowable.just(1);</span>
            }
        })
<span class="fc" id="L1046">        .doOnCancel(new Action() {</span>
            @Override
            public void run() throws Exception {
<span class="nc" id="L1049">                counter.getAndIncrement();</span>
<span class="nc" id="L1050">            }</span>
        });

<span class="fc" id="L1053">        source.retry(5)</span>
<span class="fc" id="L1054">        .test()</span>
<span class="fc" id="L1055">        .assertResult(1);</span>

<span class="fc" id="L1057">        assertEquals(0, counter.get());</span>
<span class="fc" id="L1058">    }</span>

    @Test
    public void noCancelPreviousRetryWhile() {
<span class="fc" id="L1062">        final AtomicInteger counter = new AtomicInteger();</span>

<span class="fc" id="L1064">        final AtomicInteger times = new AtomicInteger();</span>

<span class="fc" id="L1066">        Flowable&lt;Integer&gt; source = Flowable.defer(new Callable&lt;Flowable&lt;Integer&gt;&gt;() {</span>
            @Override
            public Flowable&lt;Integer&gt; call() throws Exception {
<span class="fc bfc" id="L1069" title="All 2 branches covered.">                if (times.getAndIncrement() &lt; 4) {</span>
<span class="fc" id="L1070">                    return Flowable.error(new TestException());</span>
                }
<span class="fc" id="L1072">                return Flowable.just(1);</span>
            }
        })
<span class="fc" id="L1075">        .doOnCancel(new Action() {</span>
            @Override
            public void run() throws Exception {
<span class="nc" id="L1078">                counter.getAndIncrement();</span>
<span class="nc" id="L1079">            }</span>
        });

<span class="fc" id="L1082">        source.retry(5, Functions.alwaysTrue())</span>
<span class="fc" id="L1083">        .test()</span>
<span class="fc" id="L1084">        .assertResult(1);</span>

<span class="fc" id="L1086">        assertEquals(0, counter.get());</span>
<span class="fc" id="L1087">    }</span>

    @Test
    public void noCancelPreviousRetryWhile2() {
<span class="fc" id="L1091">        final AtomicInteger counter = new AtomicInteger();</span>

<span class="fc" id="L1093">        final AtomicInteger times = new AtomicInteger();</span>

<span class="fc" id="L1095">        Flowable&lt;Integer&gt; source = Flowable.defer(new Callable&lt;Flowable&lt;Integer&gt;&gt;() {</span>
            @Override
            public Flowable&lt;Integer&gt; call() throws Exception {
<span class="fc bfc" id="L1098" title="All 2 branches covered.">                if (times.getAndIncrement() &lt; 4) {</span>
<span class="fc" id="L1099">                    return Flowable.error(new TestException());</span>
                }
<span class="fc" id="L1101">                return Flowable.just(1);</span>
            }
        })
<span class="fc" id="L1104">        .doOnCancel(new Action() {</span>
            @Override
            public void run() throws Exception {
<span class="nc" id="L1107">                counter.getAndIncrement();</span>
<span class="nc" id="L1108">            }</span>
        });

<span class="fc" id="L1111">        source.retry(new BiPredicate&lt;Integer, Throwable&gt;() {</span>
            @Override
            public boolean test(Integer a, Throwable b) throws Exception {
<span class="pc bpc" id="L1114" title="1 of 2 branches missed.">                return a &lt; 5;</span>
            }
        })
<span class="fc" id="L1117">        .test()</span>
<span class="fc" id="L1118">        .assertResult(1);</span>

<span class="fc" id="L1120">        assertEquals(0, counter.get());</span>
<span class="fc" id="L1121">    }</span>

    @Test
    public void noCancelPreviousRetryUntil() {
<span class="fc" id="L1125">        final AtomicInteger counter = new AtomicInteger();</span>

<span class="fc" id="L1127">        final AtomicInteger times = new AtomicInteger();</span>

<span class="fc" id="L1129">        Flowable&lt;Integer&gt; source = Flowable.defer(new Callable&lt;Flowable&lt;Integer&gt;&gt;() {</span>
            @Override
            public Flowable&lt;Integer&gt; call() throws Exception {
<span class="fc bfc" id="L1132" title="All 2 branches covered.">                if (times.getAndIncrement() &lt; 4) {</span>
<span class="fc" id="L1133">                    return Flowable.error(new TestException());</span>
                }
<span class="fc" id="L1135">                return Flowable.just(1);</span>
            }
        })
<span class="fc" id="L1138">        .doOnCancel(new Action() {</span>
            @Override
            public void run() throws Exception {
<span class="nc" id="L1141">                counter.getAndIncrement();</span>
<span class="nc" id="L1142">            }</span>
        });

<span class="fc" id="L1145">        source.retryUntil(new BooleanSupplier() {</span>
            @Override
            public boolean getAsBoolean() throws Exception {
<span class="fc" id="L1148">                return false;</span>
            }
        })
<span class="fc" id="L1151">        .test()</span>
<span class="fc" id="L1152">        .assertResult(1);</span>

<span class="fc" id="L1154">        assertEquals(0, counter.get());</span>
<span class="fc" id="L1155">    }</span>

    @Test
    public void noCancelPreviousRepeatWhen() {
<span class="fc" id="L1159">        final AtomicInteger counter = new AtomicInteger();</span>

<span class="fc" id="L1161">        final AtomicInteger times = new AtomicInteger();</span>

<span class="fc" id="L1163">        Flowable&lt;Integer&gt; source = Flowable.defer(new Callable&lt;Flowable&lt;Integer&gt;&gt;() {</span>
            @Override
            public Flowable&lt;Integer&gt; call() throws Exception {
<span class="fc bfc" id="L1166" title="All 2 branches covered.">                if (times.get() &lt; 4) {</span>
<span class="fc" id="L1167">                    return Flowable.error(new TestException());</span>
                }
<span class="fc" id="L1169">                return Flowable.just(1);</span>
            }
<span class="fc" id="L1171">        }).doOnCancel(new Action() {</span>
            @Override
            public void run() throws Exception {
<span class="nc" id="L1174">                counter.getAndIncrement();</span>
<span class="nc" id="L1175">            }</span>
        });

<span class="fc" id="L1178">        source.retryWhen(new Function&lt;Flowable&lt;Throwable&gt;, Flowable&lt;?&gt;&gt;() {</span>
            @Override
            public Flowable&lt;?&gt; apply(Flowable&lt;Throwable&gt; e) throws Exception {
<span class="fc" id="L1181">                return e.takeWhile(new Predicate&lt;Object&gt;() {</span>
                    @Override
                    public boolean test(Object v) throws Exception {
<span class="pc bpc" id="L1184" title="1 of 2 branches missed.">                        return times.getAndIncrement() &lt; 4;</span>
                    }
                });
            }
        })
<span class="fc" id="L1189">        .test()</span>
<span class="fc" id="L1190">        .assertResult(1);</span>

<span class="fc" id="L1192">        assertEquals(0, counter.get());</span>
<span class="fc" id="L1193">    }</span>

    @Test
    public void noCancelPreviousRepeatWhen2() {
<span class="fc" id="L1197">        final AtomicInteger counter = new AtomicInteger();</span>

<span class="fc" id="L1199">        final AtomicInteger times = new AtomicInteger();</span>

<span class="fc" id="L1201">        Flowable&lt;Integer&gt; source = Flowable.&lt;Integer&gt;error(new TestException())</span>
<span class="fc" id="L1202">                .doOnCancel(new Action() {</span>
            @Override
            public void run() throws Exception {
<span class="nc" id="L1205">                counter.getAndIncrement();</span>
<span class="nc" id="L1206">            }</span>
        });

<span class="fc" id="L1209">        source.retryWhen(new Function&lt;Flowable&lt;Throwable&gt;, Flowable&lt;?&gt;&gt;() {</span>
            @Override
            public Flowable&lt;?&gt; apply(Flowable&lt;Throwable&gt; e) throws Exception {
<span class="fc" id="L1212">                return e.takeWhile(new Predicate&lt;Object&gt;() {</span>
                    @Override
                    public boolean test(Object v) throws Exception {
<span class="fc bfc" id="L1215" title="All 2 branches covered.">                        return times.getAndIncrement() &lt; 4;</span>
                    }
                });
            }
        })
<span class="fc" id="L1220">        .test()</span>
<span class="fc" id="L1221">        .assertResult();</span>

<span class="fc" id="L1223">        assertEquals(0, counter.get());</span>
<span class="fc" id="L1224">    }</span>

    @Test
    public void repeatFloodNoSubscriptionError() {
<span class="fc" id="L1228">        List&lt;Throwable&gt; errors = TestHelper.trackPluginErrors();</span>

<span class="fc" id="L1230">        final TestException error = new TestException();</span>

        try {
<span class="fc" id="L1233">            final PublishProcessor&lt;Integer&gt; source = PublishProcessor.create();</span>
<span class="fc" id="L1234">            final PublishProcessor&lt;Integer&gt; signaller = PublishProcessor.create();</span>

<span class="fc bfc" id="L1236" title="All 2 branches covered.">            for (int i = 0; i &lt; TestHelper.RACE_DEFAULT_LOOPS; i++) {</span>

<span class="fc" id="L1238">                TestSubscriber&lt;Integer&gt; ts = source.take(1)</span>
<span class="fc" id="L1239">                .map(new Function&lt;Integer, Integer&gt;() {</span>
                    @Override
                    public Integer apply(Integer v) throws Exception {
<span class="fc" id="L1242">                        throw error;</span>
                    }
                })
<span class="fc" id="L1245">                .retryWhen(new Function&lt;Flowable&lt;Throwable&gt;, Flowable&lt;Integer&gt;&gt;() {</span>
                    @Override
                    public Flowable&lt;Integer&gt; apply(Flowable&lt;Throwable&gt; v)
                            throws Exception {
<span class="fc" id="L1249">                        return signaller;</span>
                    }
<span class="fc" id="L1251">                }).test();</span>

<span class="fc" id="L1253">                Runnable r1 = new Runnable() {</span>
                    @Override
                    public void run() {
<span class="fc bfc" id="L1256" title="All 2 branches covered.">                        for (int i = 0; i &lt; TestHelper.RACE_DEFAULT_LOOPS; i++) {</span>
<span class="fc" id="L1257">                            source.onNext(1);</span>
                        }
<span class="fc" id="L1259">                    }</span>
                };
<span class="fc" id="L1261">                Runnable r2 = new Runnable() {</span>
                    @Override
                    public void run() {
<span class="fc bfc" id="L1264" title="All 2 branches covered.">                        for (int i = 0; i &lt; TestHelper.RACE_DEFAULT_LOOPS; i++) {</span>
<span class="fc" id="L1265">                            signaller.offer(1);</span>
                        }
<span class="fc" id="L1267">                    }</span>
                };

<span class="fc" id="L1270">                TestHelper.race(r1, r2);</span>

<span class="fc" id="L1272">                ts.dispose();</span>
            }

<span class="pc bpc" id="L1275" title="1 of 2 branches missed.">            if (!errors.isEmpty()) {</span>
<span class="nc bnc" id="L1276" title="All 2 branches missed.">                for (Throwable e : errors) {</span>
<span class="nc" id="L1277">                    e.printStackTrace();</span>
<span class="nc" id="L1278">                }</span>
<span class="nc" id="L1279">                fail(errors + &quot;&quot;);</span>
            }
        } finally {
<span class="fc" id="L1282">            RxJavaPlugins.reset();</span>
        }
<span class="fc" id="L1284">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>