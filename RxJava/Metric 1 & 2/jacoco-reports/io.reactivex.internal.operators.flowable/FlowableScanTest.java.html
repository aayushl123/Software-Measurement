<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FlowableScanTest.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">RxJava_2_x$Unnamed.exec</a> &gt; <a href="index.source.html" class="el_package">io.reactivex.internal.operators.flowable</a> &gt; <span class="el_source">FlowableScanTest.java</span></div><h1>FlowableScanTest.java</h1><pre class="source lang-java linenums">/**
 * Copyright (c) 2016-present, RxJava Contributors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is
 * distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
 * the License for the specific language governing permissions and limitations under the License.
 */

package io.reactivex.internal.operators.flowable;

import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.*;

import org.junit.*;
import org.reactivestreams.*;

import io.reactivex.*;
import io.reactivex.Flowable;
import io.reactivex.exceptions.*;
import io.reactivex.flowable.*;
import io.reactivex.flowable.FlowableEventStream.Event;
import io.reactivex.functions.*;
import io.reactivex.plugins.RxJavaPlugins;
import io.reactivex.processors.PublishProcessor;
import io.reactivex.subscribers.*;

<span class="fc" id="L36">public class FlowableScanTest {</span>

    @Test
    public void testScanIntegersWithInitialValue() {
<span class="fc" id="L40">        Subscriber&lt;String&gt; subscriber = TestHelper.mockSubscriber();</span>

<span class="fc" id="L42">        Flowable&lt;Integer&gt; flowable = Flowable.just(1, 2, 3);</span>

<span class="fc" id="L44">        Flowable&lt;String&gt; m = flowable.scan(&quot;&quot;, new BiFunction&lt;String, Integer, String&gt;() {</span>

            @Override
            public String apply(String s, Integer n) {
<span class="fc" id="L48">                return s + n.toString();</span>
            }

        });
<span class="fc" id="L52">        m.subscribe(subscriber);</span>

<span class="fc" id="L54">        verify(subscriber, never()).onError(any(Throwable.class));</span>
<span class="fc" id="L55">        verify(subscriber, times(1)).onNext(&quot;&quot;);</span>
<span class="fc" id="L56">        verify(subscriber, times(1)).onNext(&quot;1&quot;);</span>
<span class="fc" id="L57">        verify(subscriber, times(1)).onNext(&quot;12&quot;);</span>
<span class="fc" id="L58">        verify(subscriber, times(1)).onNext(&quot;123&quot;);</span>
<span class="fc" id="L59">        verify(subscriber, times(4)).onNext(anyString());</span>
<span class="fc" id="L60">        verify(subscriber, times(1)).onComplete();</span>
<span class="fc" id="L61">        verify(subscriber, never()).onError(any(Throwable.class));</span>
<span class="fc" id="L62">    }</span>

    @Test
    public void testScanIntegersWithoutInitialValue() {
<span class="fc" id="L66">        Subscriber&lt;Integer&gt; subscriber = TestHelper.mockSubscriber();</span>

<span class="fc" id="L68">        Flowable&lt;Integer&gt; flowable = Flowable.just(1, 2, 3);</span>

<span class="fc" id="L70">        Flowable&lt;Integer&gt; m = flowable.scan(new BiFunction&lt;Integer, Integer, Integer&gt;() {</span>

            @Override
            public Integer apply(Integer t1, Integer t2) {
<span class="fc" id="L74">                return t1 + t2;</span>
            }

        });
<span class="fc" id="L78">        m.subscribe(subscriber);</span>

<span class="fc" id="L80">        verify(subscriber, never()).onError(any(Throwable.class));</span>
<span class="fc" id="L81">        verify(subscriber, never()).onNext(0);</span>
<span class="fc" id="L82">        verify(subscriber, times(1)).onNext(1);</span>
<span class="fc" id="L83">        verify(subscriber, times(1)).onNext(3);</span>
<span class="fc" id="L84">        verify(subscriber, times(1)).onNext(6);</span>
<span class="fc" id="L85">        verify(subscriber, times(3)).onNext(anyInt());</span>
<span class="fc" id="L86">        verify(subscriber, times(1)).onComplete();</span>
<span class="fc" id="L87">        verify(subscriber, never()).onError(any(Throwable.class));</span>
<span class="fc" id="L88">    }</span>

    @Test
    public void testScanIntegersWithoutInitialValueAndOnlyOneValue() {
<span class="fc" id="L92">        Subscriber&lt;Integer&gt; subscriber = TestHelper.mockSubscriber();</span>

<span class="fc" id="L94">        Flowable&lt;Integer&gt; flowable = Flowable.just(1);</span>

<span class="fc" id="L96">        Flowable&lt;Integer&gt; m = flowable.scan(new BiFunction&lt;Integer, Integer, Integer&gt;() {</span>

            @Override
            public Integer apply(Integer t1, Integer t2) {
<span class="nc" id="L100">                return t1 + t2;</span>
            }

        });
<span class="fc" id="L104">        m.subscribe(subscriber);</span>

<span class="fc" id="L106">        verify(subscriber, never()).onError(any(Throwable.class));</span>
<span class="fc" id="L107">        verify(subscriber, never()).onNext(0);</span>
<span class="fc" id="L108">        verify(subscriber, times(1)).onNext(1);</span>
<span class="fc" id="L109">        verify(subscriber, times(1)).onNext(anyInt());</span>
<span class="fc" id="L110">        verify(subscriber, times(1)).onComplete();</span>
<span class="fc" id="L111">        verify(subscriber, never()).onError(any(Throwable.class));</span>
<span class="fc" id="L112">    }</span>

    @Test
    public void shouldNotEmitUntilAfterSubscription() {
<span class="fc" id="L116">        TestSubscriber&lt;Integer&gt; ts = new TestSubscriber&lt;Integer&gt;();</span>
<span class="fc" id="L117">        Flowable.range(1, 100).scan(0, new BiFunction&lt;Integer, Integer, Integer&gt;() {</span>

            @Override
            public Integer apply(Integer t1, Integer t2) {
<span class="fc" id="L121">                return t1 + t2;</span>
            }

<span class="fc" id="L124">        }).filter(new Predicate&lt;Integer&gt;() {</span>

            @Override
            public boolean test(Integer t1) {
                // this will cause request(1) when 0 is emitted
<span class="fc bfc" id="L129" title="All 2 branches covered.">                return t1 &gt; 0;</span>
            }

<span class="fc" id="L132">        }).subscribe(ts);</span>

<span class="fc" id="L134">        assertEquals(100, ts.values().size());</span>
<span class="fc" id="L135">    }</span>

    @Test
    public void testBackpressureWithInitialValue() {
<span class="fc" id="L139">        final AtomicInteger count = new AtomicInteger();</span>
<span class="fc" id="L140">        Flowable.range(1, 100)</span>
<span class="fc" id="L141">                .scan(0, new BiFunction&lt;Integer, Integer, Integer&gt;() {</span>

                    @Override
                    public Integer apply(Integer t1, Integer t2) {
<span class="fc" id="L145">                        return t1 + t2;</span>
                    }

                })
<span class="fc" id="L149">                .subscribe(new DefaultSubscriber&lt;Integer&gt;() {</span>

                    @Override
                    public void onStart() {
<span class="fc" id="L153">                        request(10);</span>
<span class="fc" id="L154">                    }</span>

                    @Override
                    public void onComplete() {

<span class="nc" id="L159">                    }</span>

                    @Override
                    public void onError(Throwable e) {
<span class="nc" id="L163">                        Assert.fail(e.getMessage());</span>
<span class="nc" id="L164">                        e.printStackTrace();</span>
<span class="nc" id="L165">                    }</span>

                    @Override
                    public void onNext(Integer t) {
<span class="fc" id="L169">                        count.incrementAndGet();</span>
<span class="fc" id="L170">                    }</span>

                });

        // we only expect to receive 10 since we request(10)
<span class="fc" id="L175">        assertEquals(10, count.get());</span>
<span class="fc" id="L176">    }</span>

    @Test
    public void testBackpressureWithoutInitialValue() {
<span class="fc" id="L180">        final AtomicInteger count = new AtomicInteger();</span>
<span class="fc" id="L181">        Flowable.range(1, 100)</span>
<span class="fc" id="L182">                .scan(new BiFunction&lt;Integer, Integer, Integer&gt;() {</span>

                    @Override
                    public Integer apply(Integer t1, Integer t2) {
<span class="fc" id="L186">                        return t1 + t2;</span>
                    }

                })
<span class="fc" id="L190">                .subscribe(new DefaultSubscriber&lt;Integer&gt;() {</span>

                    @Override
                    public void onStart() {
<span class="fc" id="L194">                        request(10);</span>
<span class="fc" id="L195">                    }</span>

                    @Override
                    public void onComplete() {

<span class="nc" id="L200">                    }</span>

                    @Override
                    public void onError(Throwable e) {
<span class="nc" id="L204">                        Assert.fail(e.getMessage());</span>
<span class="nc" id="L205">                        e.printStackTrace();</span>
<span class="nc" id="L206">                    }</span>

                    @Override
                    public void onNext(Integer t) {
<span class="fc" id="L210">                        count.incrementAndGet();</span>
<span class="fc" id="L211">                    }</span>

                });

        // we only expect to receive 10 since we request(10)
<span class="fc" id="L216">        assertEquals(10, count.get());</span>
<span class="fc" id="L217">    }</span>

    @Test
    public void testNoBackpressureWithInitialValue() {
<span class="fc" id="L221">        final AtomicInteger count = new AtomicInteger();</span>
<span class="fc" id="L222">        Flowable.range(1, 100)</span>
<span class="fc" id="L223">                .scan(0, new BiFunction&lt;Integer, Integer, Integer&gt;() {</span>

                    @Override
                    public Integer apply(Integer t1, Integer t2) {
<span class="fc" id="L227">                        return t1 + t2;</span>
                    }

                })
<span class="fc" id="L231">                .subscribe(new DefaultSubscriber&lt;Integer&gt;() {</span>

                    @Override
                    public void onComplete() {

<span class="fc" id="L236">                    }</span>

                    @Override
                    public void onError(Throwable e) {
<span class="nc" id="L240">                        Assert.fail(e.getMessage());</span>
<span class="nc" id="L241">                        e.printStackTrace();</span>
<span class="nc" id="L242">                    }</span>

                    @Override
                    public void onNext(Integer t) {
<span class="fc" id="L246">                        count.incrementAndGet();</span>
<span class="fc" id="L247">                    }</span>

                });

        // we only expect to receive 101 as we'll receive all 100 + the initial value
<span class="fc" id="L252">        assertEquals(101, count.get());</span>
<span class="fc" id="L253">    }</span>

    /**
     * This uses the public API collect which uses scan under the covers.
     */
    @Test
    public void testSeedFactory() {
<span class="fc" id="L260">        Single&lt;List&lt;Integer&gt;&gt; o = Flowable.range(1, 10)</span>
<span class="fc" id="L261">                .collect(new Callable&lt;List&lt;Integer&gt;&gt;() {</span>

                    @Override
                    public List&lt;Integer&gt; call() {
<span class="fc" id="L265">                        return new ArrayList&lt;Integer&gt;();</span>
                    }

<span class="fc" id="L268">                }, new BiConsumer&lt;List&lt;Integer&gt;, Integer&gt;() {</span>

                    @Override
                    public void accept(List&lt;Integer&gt; list, Integer t2) {
<span class="fc" id="L272">                        list.add(t2);</span>
<span class="fc" id="L273">                    }</span>

                });

<span class="fc" id="L277">        assertEquals(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10), o.blockingGet());</span>
<span class="fc" id="L278">        assertEquals(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10), o.blockingGet());</span>
<span class="fc" id="L279">    }</span>

    /**
     * This uses the public API collect which uses scan under the covers.
     */
    @Test
    public void testSeedFactoryFlowable() {
<span class="fc" id="L286">        Flowable&lt;List&lt;Integer&gt;&gt; f = Flowable.range(1, 10)</span>
<span class="fc" id="L287">                .collect(new Callable&lt;List&lt;Integer&gt;&gt;() {</span>

                    @Override
                    public List&lt;Integer&gt; call() {
<span class="fc" id="L291">                        return new ArrayList&lt;Integer&gt;();</span>
                    }

<span class="fc" id="L294">                }, new BiConsumer&lt;List&lt;Integer&gt;, Integer&gt;() {</span>

                    @Override
                    public void accept(List&lt;Integer&gt; list, Integer t2) {
<span class="fc" id="L298">                        list.add(t2);</span>
<span class="fc" id="L299">                    }</span>

<span class="fc" id="L301">                }).toFlowable().takeLast(1);</span>

<span class="fc" id="L303">        assertEquals(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10), f.blockingSingle());</span>
<span class="fc" id="L304">        assertEquals(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10), f.blockingSingle());</span>
<span class="fc" id="L305">    }</span>

    @Test
    public void testScanWithRequestOne() {
<span class="fc" id="L309">        Flowable&lt;Integer&gt; f = Flowable.just(1, 2).scan(0, new BiFunction&lt;Integer, Integer, Integer&gt;() {</span>

            @Override
            public Integer apply(Integer t1, Integer t2) {
<span class="nc" id="L313">                return t1 + t2;</span>
            }

<span class="fc" id="L316">        }).take(1);</span>
<span class="fc" id="L317">        TestSubscriber&lt;Integer&gt; subscriber = new TestSubscriber&lt;Integer&gt;();</span>
<span class="fc" id="L318">        f.subscribe(subscriber);</span>
<span class="fc" id="L319">        subscriber.assertValue(0);</span>
<span class="fc" id="L320">        subscriber.assertTerminated();</span>
<span class="fc" id="L321">        subscriber.assertNoErrors();</span>
<span class="fc" id="L322">    }</span>

    @Test
    public void testScanShouldNotRequestZero() {
<span class="fc" id="L326">        final AtomicReference&lt;Subscription&gt; producer = new AtomicReference&lt;Subscription&gt;();</span>
<span class="fc" id="L327">        Flowable&lt;Integer&gt; f = Flowable.unsafeCreate(new Publisher&lt;Integer&gt;() {</span>
            @Override
            public void subscribe(final Subscriber&lt;? super Integer&gt; subscriber) {
<span class="fc" id="L330">                Subscription p = spy(new Subscription() {</span>

<span class="fc" id="L332">                    private AtomicBoolean requested = new AtomicBoolean(false);</span>

                    @Override
                    public void request(long n) {
<span class="pc bpc" id="L336" title="1 of 2 branches missed.">                        if (requested.compareAndSet(false, true)) {</span>
<span class="fc" id="L337">                            subscriber.onNext(1);</span>
<span class="fc" id="L338">                            subscriber.onComplete();</span>
                        }
<span class="fc" id="L340">                    }</span>

                    @Override
                    public void cancel() {

<span class="nc" id="L345">                    }</span>
                });
<span class="fc" id="L347">                producer.set(p);</span>
<span class="fc" id="L348">                subscriber.onSubscribe(p);</span>
<span class="fc" id="L349">            }</span>
<span class="fc" id="L350">        }).scan(100, new BiFunction&lt;Integer, Integer, Integer&gt;() {</span>

            @Override
            public Integer apply(Integer t1, Integer t2) {
<span class="fc" id="L354">                return t1 + t2;</span>
            }

        });

<span class="fc" id="L359">        f.subscribe(new TestSubscriber&lt;Integer&gt;(1L) {</span>

            @Override
            public void onNext(Integer integer) {
<span class="fc" id="L363">                request(1);</span>
<span class="fc" id="L364">            }</span>
        });

<span class="fc" id="L367">        verify(producer.get(), never()).request(0);</span>
<span class="fc" id="L368">        verify(producer.get(), times(1)).request(Flowable.bufferSize() - 1);</span>
<span class="fc" id="L369">    }</span>

    @Test
    @Ignore(&quot;scanSeed no longer emits without upstream signal&quot;)
    public void testInitialValueEmittedNoProducer() {
<span class="nc" id="L374">        PublishProcessor&lt;Integer&gt; source = PublishProcessor.create();</span>

<span class="nc" id="L376">        TestSubscriber&lt;Integer&gt; ts = new TestSubscriber&lt;Integer&gt;();</span>

<span class="nc" id="L378">        source.scan(0, new BiFunction&lt;Integer, Integer, Integer&gt;() {</span>
            @Override
            public Integer apply(Integer t1, Integer t2) {
<span class="nc" id="L381">                return t1 + t2;</span>
            }
<span class="nc" id="L383">        }).subscribe(ts);</span>

<span class="nc" id="L385">        ts.assertNoErrors();</span>
<span class="nc" id="L386">        ts.assertNotComplete();</span>
<span class="nc" id="L387">        ts.assertValue(0);</span>
<span class="nc" id="L388">    }</span>

    @Test
    @Ignore(&quot;scanSeed no longer emits without upstream signal&quot;)
    public void testInitialValueEmittedWithProducer() {
<span class="nc" id="L393">        Flowable&lt;Integer&gt; source = Flowable.never();</span>

<span class="nc" id="L395">        TestSubscriber&lt;Integer&gt; ts = new TestSubscriber&lt;Integer&gt;();</span>

<span class="nc" id="L397">        source.scan(0, new BiFunction&lt;Integer, Integer, Integer&gt;() {</span>
            @Override
            public Integer apply(Integer t1, Integer t2) {
<span class="nc" id="L400">                return t1 + t2;</span>
            }
<span class="nc" id="L402">        }).subscribe(ts);</span>

<span class="nc" id="L404">        ts.assertNoErrors();</span>
<span class="nc" id="L405">        ts.assertNotComplete();</span>
<span class="nc" id="L406">        ts.assertValue(0);</span>
<span class="nc" id="L407">    }</span>

    @Test
    public void dispose() {
<span class="fc" id="L411">        TestHelper.checkDisposed(PublishProcessor.create().scan(new BiFunction&lt;Object, Object, Object&gt;() {</span>
            @Override
            public Object apply(Object a, Object b) throws Exception {
<span class="nc" id="L414">                return a;</span>
            }
        }));

<span class="fc" id="L418">        TestHelper.checkDisposed(PublishProcessor.&lt;Integer&gt;create().scan(0, new BiFunction&lt;Integer, Integer, Integer&gt;() {</span>
            @Override
            public Integer apply(Integer a, Integer b) throws Exception {
<span class="nc" id="L421">                return a + b;</span>
            }
        }));
<span class="fc" id="L424">    }</span>

    @Test
    public void doubleOnSubscribe() {
<span class="fc" id="L428">        TestHelper.checkDoubleOnSubscribeFlowable(new Function&lt;Flowable&lt;Object&gt;, Flowable&lt;Object&gt;&gt;() {</span>
            @Override
            public Flowable&lt;Object&gt; apply(Flowable&lt;Object&gt; f) throws Exception {
<span class="fc" id="L431">                return f.scan(new BiFunction&lt;Object, Object, Object&gt;() {</span>
                    @Override
                    public Object apply(Object a, Object b) throws Exception {
<span class="nc" id="L434">                        return a;</span>
                    }
                });
            }
        });

<span class="fc" id="L440">        TestHelper.checkDoubleOnSubscribeFlowable(new Function&lt;Flowable&lt;Object&gt;, Flowable&lt;Object&gt;&gt;() {</span>
            @Override
            public Flowable&lt;Object&gt; apply(Flowable&lt;Object&gt; f) throws Exception {
<span class="fc" id="L443">                return f.scan(0, new BiFunction&lt;Object, Object, Object&gt;() {</span>
                    @Override
                    public Object apply(Object a, Object b) throws Exception {
<span class="nc" id="L446">                        return a;</span>
                    }
                });
            }
        });
<span class="fc" id="L451">    }</span>

    @Test
    public void error() {
<span class="fc" id="L455">        Flowable.error(new TestException())</span>
<span class="fc" id="L456">        .scan(new BiFunction&lt;Object, Object, Object&gt;() {</span>
            @Override
            public Object apply(Object a, Object b) throws Exception {
<span class="nc" id="L459">                return a;</span>
            }
        })
<span class="fc" id="L462">        .test()</span>
<span class="fc" id="L463">        .assertFailure(TestException.class);</span>
<span class="fc" id="L464">    }</span>

    @Test
    public void neverSource() {
<span class="fc" id="L468">        Flowable.&lt;Integer&gt;never()</span>
<span class="fc" id="L469">        .scan(0, new BiFunction&lt;Integer, Integer, Integer&gt;() {</span>
            @Override
            public Integer apply(Integer a, Integer b) throws Exception {
<span class="nc" id="L472">                return a + b;</span>
            }
        })
<span class="fc" id="L475">        .test()</span>
<span class="fc" id="L476">        .assertValue(0)</span>
<span class="fc" id="L477">        .assertNoErrors()</span>
<span class="fc" id="L478">        .assertNotComplete();</span>
<span class="fc" id="L479">    }</span>

    @Test
    public void testUnsubscribeScan() {

<span class="fc" id="L484">        FlowableEventStream.getEventStream(&quot;HTTP-ClusterB&quot;, 20)</span>
<span class="fc" id="L485">        .scan(new HashMap&lt;String, String&gt;(), new BiFunction&lt;HashMap&lt;String, String&gt;, Event, HashMap&lt;String, String&gt;&gt;() {</span>
            @Override
            public HashMap&lt;String, String&gt; apply(HashMap&lt;String, String&gt; accum, Event perInstanceEvent) {
<span class="fc" id="L488">                accum.put(&quot;instance&quot;, perInstanceEvent.instanceId);</span>
<span class="fc" id="L489">                return accum;</span>
            }
        })
<span class="fc" id="L492">        .take(10)</span>
<span class="fc" id="L493">        .blockingForEach(new Consumer&lt;HashMap&lt;String, String&gt;&gt;() {</span>
            @Override
            public void accept(HashMap&lt;String, String&gt; v) {
<span class="fc" id="L496">                System.out.println(v);</span>
<span class="fc" id="L497">            }</span>
        });
<span class="fc" id="L499">    }</span>

    @Test
    public void testScanWithSeedDoesNotEmitErrorTwiceIfScanFunctionThrows() {
<span class="fc" id="L503">        final List&lt;Throwable&gt; list = new CopyOnWriteArrayList&lt;Throwable&gt;();</span>
<span class="fc" id="L504">        Consumer&lt;Throwable&gt; errorConsumer = new Consumer&lt;Throwable&gt;() {</span>
            @Override
            public void accept(Throwable t) throws Exception {
<span class="fc" id="L507">                 list.add(t);</span>
<span class="fc" id="L508">            }};</span>
        try {
<span class="fc" id="L510">            RxJavaPlugins.setErrorHandler(errorConsumer);</span>
<span class="fc" id="L511">            final RuntimeException e = new RuntimeException();</span>
<span class="fc" id="L512">            final RuntimeException e2 = new RuntimeException();</span>
<span class="fc" id="L513">            Burst.items(1).error(e2)</span>
<span class="fc" id="L514">              .scan(0, throwingBiFunction(e))</span>
<span class="fc" id="L515">              .test()</span>
<span class="fc" id="L516">              .assertValues(0)</span>
<span class="fc" id="L517">              .assertError(e);</span>

<span class="fc" id="L519">            assertEquals(&quot;&quot; + list, 1, list.size());</span>
<span class="fc" id="L520">            assertTrue(&quot;&quot; + list, list.get(0) instanceof UndeliverableException);</span>
<span class="fc" id="L521">            assertEquals(e2, list.get(0).getCause());</span>
        } finally {
<span class="fc" id="L523">            RxJavaPlugins.reset();</span>
        }
<span class="fc" id="L525">    }</span>

    @Test
    public void testScanWithSeedDoesNotEmitTerminalEventTwiceIfScanFunctionThrows() {
<span class="fc" id="L529">        final RuntimeException e = new RuntimeException();</span>
<span class="fc" id="L530">        Burst.item(1).create()</span>
<span class="fc" id="L531">          .scan(0, throwingBiFunction(e))</span>
<span class="fc" id="L532">          .test()</span>
<span class="fc" id="L533">          .assertValue(0)</span>
<span class="fc" id="L534">          .assertError(e);</span>
<span class="fc" id="L535">    }</span>

    @Test
    public void testScanWithSeedDoesNotProcessOnNextAfterTerminalEventIfScanFunctionThrows() {
<span class="fc" id="L539">        final RuntimeException e = new RuntimeException();</span>
<span class="fc" id="L540">        final AtomicInteger count = new AtomicInteger();</span>
<span class="fc" id="L541">        Burst.items(1, 2).create().scan(0, new BiFunction&lt;Integer, Integer, Integer&gt;() {</span>

            @Override
            public Integer apply(Integer n1, Integer n2) throws Exception {
<span class="fc" id="L545">                count.incrementAndGet();</span>
<span class="fc" id="L546">                throw e;</span>
            }})
<span class="fc" id="L548">          .test()</span>
<span class="fc" id="L549">          .assertValues(0)</span>
<span class="fc" id="L550">          .assertError(e);</span>
<span class="fc" id="L551">        assertEquals(1, count.get());</span>
<span class="fc" id="L552">    }</span>

    @Test
    public void testScanWithSeedCompletesNormally() {
<span class="fc" id="L556">        Flowable.just(1, 2, 3).scan(0, SUM)</span>
<span class="fc" id="L557">          .test()</span>
<span class="fc" id="L558">          .assertValues(0, 1, 3, 6)</span>
<span class="fc" id="L559">          .assertComplete();</span>
<span class="fc" id="L560">    }</span>

    @Test
    public void testScanWithSeedWhenScanSeedProviderThrows() {
<span class="fc" id="L564">        final RuntimeException e = new RuntimeException();</span>
<span class="fc" id="L565">        Flowable.just(1, 2, 3).scanWith(throwingCallable(e),</span>
            SUM)
<span class="fc" id="L567">          .test()</span>
<span class="fc" id="L568">          .assertError(e)</span>
<span class="fc" id="L569">          .assertNoValues();</span>
<span class="fc" id="L570">    }</span>

    @Test
    public void testScanNoSeed() {
<span class="fc" id="L574">        Flowable.just(1, 2, 3)</span>
<span class="fc" id="L575">           .scan(SUM)</span>
<span class="fc" id="L576">           .test()</span>
<span class="fc" id="L577">           .assertValues(1, 3, 6)</span>
<span class="fc" id="L578">           .assertComplete();</span>
<span class="fc" id="L579">    }</span>

    @Test
    public void testScanNoSeedDoesNotEmitErrorTwiceIfScanFunctionThrows() {
<span class="fc" id="L583">        final List&lt;Throwable&gt; list = new CopyOnWriteArrayList&lt;Throwable&gt;();</span>
<span class="fc" id="L584">        Consumer&lt;Throwable&gt; errorConsumer = new Consumer&lt;Throwable&gt;() {</span>
            @Override
            public void accept(Throwable t) throws Exception {
<span class="fc" id="L587">                 list.add(t);</span>
<span class="fc" id="L588">            }};</span>
        try {
<span class="fc" id="L590">            RxJavaPlugins.setErrorHandler(errorConsumer);</span>
<span class="fc" id="L591">            final RuntimeException e = new RuntimeException();</span>
<span class="fc" id="L592">            final RuntimeException e2 = new RuntimeException();</span>
<span class="fc" id="L593">            Burst.items(1, 2).error(e2)</span>
<span class="fc" id="L594">              .scan(throwingBiFunction(e))</span>
<span class="fc" id="L595">              .test()</span>
<span class="fc" id="L596">              .assertValue(1)</span>
<span class="fc" id="L597">              .assertError(e);</span>

<span class="fc" id="L599">            assertEquals(&quot;&quot; + list, 1, list.size());</span>
<span class="fc" id="L600">            assertTrue(&quot;&quot; + list, list.get(0) instanceof UndeliverableException);</span>
<span class="fc" id="L601">            assertEquals(e2, list.get(0).getCause());</span>
        } finally {
<span class="fc" id="L603">            RxJavaPlugins.reset();</span>
        }
<span class="fc" id="L605">    }</span>

    @Test
    public void testScanNoSeedDoesNotEmitTerminalEventTwiceIfScanFunctionThrows() {
<span class="fc" id="L609">        final RuntimeException e = new RuntimeException();</span>
<span class="fc" id="L610">        Burst.items(1, 2).create()</span>
<span class="fc" id="L611">          .scan(throwingBiFunction(e))</span>
<span class="fc" id="L612">          .test()</span>
<span class="fc" id="L613">          .assertValue(1)</span>
<span class="fc" id="L614">          .assertError(e);</span>
<span class="fc" id="L615">    }</span>

    @Test
    public void testScanNoSeedDoesNotProcessOnNextAfterTerminalEventIfScanFunctionThrows() {
<span class="fc" id="L619">        final RuntimeException e = new RuntimeException();</span>
<span class="fc" id="L620">        final AtomicInteger count = new AtomicInteger();</span>
<span class="fc" id="L621">        Burst.items(1, 2, 3).create().scan(new BiFunction&lt;Integer, Integer, Integer&gt;() {</span>

            @Override
            public Integer apply(Integer n1, Integer n2) throws Exception {
<span class="fc" id="L625">                count.incrementAndGet();</span>
<span class="fc" id="L626">                throw e;</span>
            }})
<span class="fc" id="L628">          .test()</span>
<span class="fc" id="L629">          .assertValue(1)</span>
<span class="fc" id="L630">          .assertError(e);</span>
<span class="fc" id="L631">        assertEquals(1, count.get());</span>
<span class="fc" id="L632">    }</span>

    private static BiFunction&lt;Integer, Integer, Integer&gt; throwingBiFunction(final RuntimeException e) {
<span class="fc" id="L635">        return new BiFunction&lt;Integer, Integer, Integer&gt;() {</span>
            @Override
            public Integer apply(Integer n1, Integer n2) throws Exception {
<span class="fc" id="L638">                throw e;</span>
            }
        };
    }

<span class="fc" id="L643">    private static final BiFunction&lt;Integer, Integer, Integer&gt; SUM = new BiFunction&lt;Integer, Integer, Integer&gt;() {</span>

        @Override
        public Integer apply(Integer t1, Integer t2) throws Exception {
<span class="fc" id="L647">            return t1 + t2;</span>
        }
    };

    private static Callable&lt;Integer&gt; throwingCallable(final RuntimeException e) {
<span class="fc" id="L652">        return new Callable&lt;Integer&gt;() {</span>
            @Override
            public Integer call() throws Exception {
<span class="fc" id="L655">                throw e;</span>
            }
        };
    }

    @Test
    public void scanEmptyBackpressured() {
<span class="fc" id="L662">        Flowable.&lt;Integer&gt;empty()</span>
<span class="fc" id="L663">        .scan(0, SUM)</span>
<span class="fc" id="L664">        .test(1)</span>
<span class="fc" id="L665">        .assertResult(0);</span>
<span class="fc" id="L666">    }</span>

    @Test
    public void scanErrorBackpressured() {
<span class="fc" id="L670">        Flowable.&lt;Integer&gt;error(new TestException())</span>
<span class="fc" id="L671">        .scan(0, SUM)</span>
<span class="fc" id="L672">        .test(0)</span>
<span class="fc" id="L673">        .assertFailure(TestException.class);</span>
<span class="fc" id="L674">    }</span>

    @Test
    public void scanTake() {
<span class="fc" id="L678">        TestSubscriber&lt;Integer&gt; ts = new TestSubscriber&lt;Integer&gt;() {</span>
            @Override
            public void onNext(Integer t) {
<span class="fc" id="L681">                super.onNext(t);</span>
<span class="fc" id="L682">                onComplete();</span>
<span class="fc" id="L683">                cancel();</span>
<span class="fc" id="L684">            }</span>
        };

<span class="fc" id="L687">        Flowable.range(1, 10)</span>
<span class="fc" id="L688">        .scan(0, SUM)</span>
<span class="fc" id="L689">        .subscribe(ts)</span>
        ;

<span class="fc" id="L692">        ts.assertResult(0);</span>
<span class="fc" id="L693">    }</span>

    @Test
    public void scanLong() {
<span class="fc" id="L697">        int n = 2 * Flowable.bufferSize();</span>

<span class="fc bfc" id="L699" title="All 2 branches covered.">        for (int b = 1; b &lt;= n; b *= 2) {</span>
<span class="fc" id="L700">            List&lt;Integer&gt; list = Flowable.range(1, n)</span>
<span class="fc" id="L701">            .scan(0, new BiFunction&lt;Integer, Integer, Integer&gt;() {</span>
                @Override
                public Integer apply(Integer a, Integer b) throws Exception {
<span class="fc" id="L704">                    return b;</span>
                }
            })
<span class="fc" id="L707">            .rebatchRequests(b)</span>
<span class="fc" id="L708">            .toList()</span>
<span class="fc" id="L709">            .blockingGet();</span>

<span class="fc bfc" id="L711" title="All 2 branches covered.">            for (int i = 0; i &lt;= n; i++) {</span>
<span class="fc" id="L712">                assertEquals(i, list.get(i).intValue());</span>
            }
        }
<span class="fc" id="L715">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>