<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FlowableWindowWithFlowableTest.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">RxJava_2_x$Unnamed.exec</a> &gt; <a href="index.source.html" class="el_package">io.reactivex.internal.operators.flowable</a> &gt; <span class="el_source">FlowableWindowWithFlowableTest.java</span></div><h1>FlowableWindowWithFlowableTest.java</h1><pre class="source lang-java linenums">/**
 * Copyright (c) 2016-present, RxJava Contributors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is
 * distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
 * the License for the specific language governing permissions and limitations under the License.
 */

package io.reactivex.internal.operators.flowable;

import static org.junit.Assert.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.*;

import org.junit.Test;
import org.reactivestreams.*;

import io.reactivex.*;
import io.reactivex.exceptions.*;
import io.reactivex.functions.Function;
import io.reactivex.internal.functions.Functions;
import io.reactivex.internal.subscriptions.BooleanSubscription;
import io.reactivex.plugins.RxJavaPlugins;
import io.reactivex.processors.*;
import io.reactivex.subscribers.*;

<span class="fc" id="L36">public class FlowableWindowWithFlowableTest {</span>

    @Test
    public void testWindowViaFlowableNormal1() {
<span class="fc" id="L40">        PublishProcessor&lt;Integer&gt; source = PublishProcessor.create();</span>
<span class="fc" id="L41">        PublishProcessor&lt;Integer&gt; boundary = PublishProcessor.create();</span>

<span class="fc" id="L43">        final Subscriber&lt;Object&gt; subscriber = TestHelper.mockSubscriber();</span>

<span class="fc" id="L45">        final List&lt;Subscriber&lt;Object&gt;&gt; values = new ArrayList&lt;Subscriber&lt;Object&gt;&gt;();</span>

<span class="fc" id="L47">        Subscriber&lt;Flowable&lt;Integer&gt;&gt; wo = new DefaultSubscriber&lt;Flowable&lt;Integer&gt;&gt;() {</span>
            @Override
            public void onNext(Flowable&lt;Integer&gt; args) {
<span class="fc" id="L50">                final Subscriber&lt;Object&gt; mo = TestHelper.mockSubscriber();</span>
<span class="fc" id="L51">                values.add(mo);</span>

<span class="fc" id="L53">                args.subscribe(mo);</span>
<span class="fc" id="L54">            }</span>

            @Override
            public void onError(Throwable e) {
<span class="nc" id="L58">                subscriber.onError(e);</span>
<span class="nc" id="L59">            }</span>

            @Override
            public void onComplete() {
<span class="fc" id="L63">                subscriber.onComplete();</span>
<span class="fc" id="L64">            }</span>
        };

<span class="fc" id="L67">        source.window(boundary).subscribe(wo);</span>

<span class="fc" id="L69">        int n = 30;</span>
<span class="fc bfc" id="L70" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L71">            source.onNext(i);</span>
<span class="fc bfc" id="L72" title="All 4 branches covered.">            if (i % 3 == 2 &amp;&amp; i &lt; n - 1) {</span>
<span class="fc" id="L73">                boundary.onNext(i / 3);</span>
            }
        }
<span class="fc" id="L76">        source.onComplete();</span>

<span class="fc" id="L78">        verify(subscriber, never()).onError(any(Throwable.class));</span>

<span class="fc" id="L80">        assertEquals(n / 3, values.size());</span>

<span class="fc" id="L82">        int j = 0;</span>
<span class="fc bfc" id="L83" title="All 2 branches covered.">        for (Subscriber&lt;Object&gt; mo : values) {</span>
<span class="fc" id="L84">            verify(mo, never()).onError(any(Throwable.class));</span>
<span class="fc bfc" id="L85" title="All 2 branches covered.">            for (int i = 0; i &lt; 3; i++) {</span>
<span class="fc" id="L86">                verify(mo).onNext(j + i);</span>
            }
<span class="fc" id="L88">            verify(mo).onComplete();</span>
<span class="fc" id="L89">            j += 3;</span>
<span class="fc" id="L90">        }</span>

<span class="fc" id="L92">        verify(subscriber).onComplete();</span>
<span class="fc" id="L93">    }</span>

    @Test
    public void testWindowViaFlowableBoundaryCompletes() {
<span class="fc" id="L97">        PublishProcessor&lt;Integer&gt; source = PublishProcessor.create();</span>
<span class="fc" id="L98">        PublishProcessor&lt;Integer&gt; boundary = PublishProcessor.create();</span>

<span class="fc" id="L100">        final Subscriber&lt;Object&gt; subscriber = TestHelper.mockSubscriber();</span>

<span class="fc" id="L102">        final List&lt;Subscriber&lt;Object&gt;&gt; values = new ArrayList&lt;Subscriber&lt;Object&gt;&gt;();</span>

<span class="fc" id="L104">        Subscriber&lt;Flowable&lt;Integer&gt;&gt; wo = new DefaultSubscriber&lt;Flowable&lt;Integer&gt;&gt;() {</span>
            @Override
            public void onNext(Flowable&lt;Integer&gt; args) {
<span class="fc" id="L107">                final Subscriber&lt;Object&gt; mo = TestHelper.mockSubscriber();</span>
<span class="fc" id="L108">                values.add(mo);</span>

<span class="fc" id="L110">                args.subscribe(mo);</span>
<span class="fc" id="L111">            }</span>

            @Override
            public void onError(Throwable e) {
<span class="nc" id="L115">                subscriber.onError(e);</span>
<span class="nc" id="L116">            }</span>

            @Override
            public void onComplete() {
<span class="fc" id="L120">                subscriber.onComplete();</span>
<span class="fc" id="L121">            }</span>
        };

<span class="fc" id="L124">        source.window(boundary).subscribe(wo);</span>

<span class="fc" id="L126">        int n = 30;</span>
<span class="fc bfc" id="L127" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L128">            source.onNext(i);</span>
<span class="fc bfc" id="L129" title="All 4 branches covered.">            if (i % 3 == 2 &amp;&amp; i &lt; n - 1) {</span>
<span class="fc" id="L130">                boundary.onNext(i / 3);</span>
            }
        }
<span class="fc" id="L133">        boundary.onComplete();</span>

<span class="fc" id="L135">        assertEquals(n / 3, values.size());</span>

<span class="fc" id="L137">        int j = 0;</span>
<span class="fc bfc" id="L138" title="All 2 branches covered.">        for (Subscriber&lt;Object&gt; mo : values) {</span>
<span class="fc bfc" id="L139" title="All 2 branches covered.">            for (int i = 0; i &lt; 3; i++) {</span>
<span class="fc" id="L140">                verify(mo).onNext(j + i);</span>
            }
<span class="fc" id="L142">            verify(mo).onComplete();</span>
<span class="fc" id="L143">            verify(mo, never()).onError(any(Throwable.class));</span>
<span class="fc" id="L144">            j += 3;</span>
<span class="fc" id="L145">        }</span>

<span class="fc" id="L147">        verify(subscriber).onComplete();</span>
<span class="fc" id="L148">        verify(subscriber, never()).onError(any(Throwable.class));</span>
<span class="fc" id="L149">    }</span>

    @Test
    public void testWindowViaFlowableBoundaryThrows() {
<span class="fc" id="L153">        PublishProcessor&lt;Integer&gt; source = PublishProcessor.create();</span>
<span class="fc" id="L154">        PublishProcessor&lt;Integer&gt; boundary = PublishProcessor.create();</span>

<span class="fc" id="L156">        final Subscriber&lt;Object&gt; subscriber = TestHelper.mockSubscriber();</span>

<span class="fc" id="L158">        final List&lt;Subscriber&lt;Object&gt;&gt; values = new ArrayList&lt;Subscriber&lt;Object&gt;&gt;();</span>

<span class="fc" id="L160">        Subscriber&lt;Flowable&lt;Integer&gt;&gt; wo = new DefaultSubscriber&lt;Flowable&lt;Integer&gt;&gt;() {</span>
            @Override
            public void onNext(Flowable&lt;Integer&gt; args) {
<span class="fc" id="L163">                final Subscriber&lt;Object&gt; mo = TestHelper.mockSubscriber();</span>
<span class="fc" id="L164">                values.add(mo);</span>

<span class="fc" id="L166">                args.subscribe(mo);</span>
<span class="fc" id="L167">            }</span>

            @Override
            public void onError(Throwable e) {
<span class="fc" id="L171">                subscriber.onError(e);</span>
<span class="fc" id="L172">            }</span>

            @Override
            public void onComplete() {
<span class="nc" id="L176">                subscriber.onComplete();</span>
<span class="nc" id="L177">            }</span>
        };

<span class="fc" id="L180">        source.window(boundary).subscribe(wo);</span>

<span class="fc" id="L182">        source.onNext(0);</span>
<span class="fc" id="L183">        source.onNext(1);</span>
<span class="fc" id="L184">        source.onNext(2);</span>

<span class="fc" id="L186">        boundary.onError(new TestException());</span>

<span class="fc" id="L188">        assertEquals(1, values.size());</span>

<span class="fc" id="L190">        Subscriber&lt;Object&gt; mo = values.get(0);</span>

<span class="fc" id="L192">        verify(mo).onNext(0);</span>
<span class="fc" id="L193">        verify(mo).onNext(1);</span>
<span class="fc" id="L194">        verify(mo).onNext(2);</span>
<span class="fc" id="L195">        verify(mo).onError(any(TestException.class));</span>

<span class="fc" id="L197">        verify(subscriber, never()).onComplete();</span>
<span class="fc" id="L198">        verify(subscriber).onError(any(TestException.class));</span>
<span class="fc" id="L199">    }</span>

    @Test
    public void testWindowViaFlowableThrows() {
<span class="fc" id="L203">        PublishProcessor&lt;Integer&gt; source = PublishProcessor.create();</span>
<span class="fc" id="L204">        PublishProcessor&lt;Integer&gt; boundary = PublishProcessor.create();</span>

<span class="fc" id="L206">        final Subscriber&lt;Object&gt; subscriber = TestHelper.mockSubscriber();</span>

<span class="fc" id="L208">        final List&lt;Subscriber&lt;Object&gt;&gt; values = new ArrayList&lt;Subscriber&lt;Object&gt;&gt;();</span>

<span class="fc" id="L210">        Subscriber&lt;Flowable&lt;Integer&gt;&gt; wo = new DefaultSubscriber&lt;Flowable&lt;Integer&gt;&gt;() {</span>
            @Override
            public void onNext(Flowable&lt;Integer&gt; args) {
<span class="fc" id="L213">                final Subscriber&lt;Object&gt; mo = TestHelper.mockSubscriber();</span>
<span class="fc" id="L214">                values.add(mo);</span>

<span class="fc" id="L216">                args.subscribe(mo);</span>
<span class="fc" id="L217">            }</span>

            @Override
            public void onError(Throwable e) {
<span class="fc" id="L221">                subscriber.onError(e);</span>
<span class="fc" id="L222">            }</span>

            @Override
            public void onComplete() {
<span class="nc" id="L226">                subscriber.onComplete();</span>
<span class="nc" id="L227">            }</span>
        };

<span class="fc" id="L230">        source.window(boundary).subscribe(wo);</span>

<span class="fc" id="L232">        source.onNext(0);</span>
<span class="fc" id="L233">        source.onNext(1);</span>
<span class="fc" id="L234">        source.onNext(2);</span>

<span class="fc" id="L236">        source.onError(new TestException());</span>

<span class="fc" id="L238">        assertEquals(1, values.size());</span>

<span class="fc" id="L240">        Subscriber&lt;Object&gt; mo = values.get(0);</span>

<span class="fc" id="L242">        verify(mo).onNext(0);</span>
<span class="fc" id="L243">        verify(mo).onNext(1);</span>
<span class="fc" id="L244">        verify(mo).onNext(2);</span>
<span class="fc" id="L245">        verify(mo).onError(any(TestException.class));</span>

<span class="fc" id="L247">        verify(subscriber, never()).onComplete();</span>
<span class="fc" id="L248">        verify(subscriber).onError(any(TestException.class));</span>
<span class="fc" id="L249">    }</span>

    @Test
    public void testWindowNoDuplication() {
<span class="fc" id="L253">        final PublishProcessor&lt;Integer&gt; source = PublishProcessor.create();</span>
<span class="fc" id="L254">        final TestSubscriber&lt;Integer&gt; tsw = new TestSubscriber&lt;Integer&gt;() {</span>
            boolean once;
            @Override
            public void onNext(Integer t) {
<span class="fc bfc" id="L258" title="All 2 branches covered.">                if (!once) {</span>
<span class="fc" id="L259">                    once = true;</span>
<span class="fc" id="L260">                    source.onNext(2);</span>
                }
<span class="fc" id="L262">                super.onNext(t);</span>
<span class="fc" id="L263">            }</span>
        };
<span class="fc" id="L265">        TestSubscriber&lt;Flowable&lt;Integer&gt;&gt; ts = new TestSubscriber&lt;Flowable&lt;Integer&gt;&gt;() {</span>
            @Override
            public void onNext(Flowable&lt;Integer&gt; t) {
<span class="fc" id="L268">                t.subscribe(tsw);</span>
<span class="fc" id="L269">                super.onNext(t);</span>
<span class="fc" id="L270">            }</span>
        };
<span class="fc" id="L272">        source.window(new Callable&lt;Flowable&lt;Object&gt;&gt;() {</span>
            @Override
            public Flowable&lt;Object&gt; call() {
<span class="fc" id="L275">                return Flowable.never();</span>
            }
<span class="fc" id="L277">        }).subscribe(ts);</span>

<span class="fc" id="L279">        source.onNext(1);</span>
<span class="fc" id="L280">        source.onComplete();</span>

<span class="fc" id="L282">        ts.assertValueCount(1);</span>
<span class="fc" id="L283">        tsw.assertValues(1, 2);</span>
<span class="fc" id="L284">    }</span>

    @Test
    public void testWindowViaFlowableNoUnsubscribe() {
<span class="fc" id="L288">        Flowable&lt;Integer&gt; source = Flowable.range(1, 10);</span>
<span class="fc" id="L289">        Callable&lt;Flowable&lt;String&gt;&gt; boundary = new Callable&lt;Flowable&lt;String&gt;&gt;() {</span>
            @Override
            public Flowable&lt;String&gt; call() {
<span class="fc" id="L292">                return Flowable.empty();</span>
            }
        };

<span class="fc" id="L296">        TestSubscriber&lt;Flowable&lt;Integer&gt;&gt; ts = new TestSubscriber&lt;Flowable&lt;Integer&gt;&gt;();</span>
<span class="fc" id="L297">        source.window(boundary).subscribe(ts);</span>

<span class="fc" id="L299">        assertFalse(ts.isCancelled());</span>
<span class="fc" id="L300">    }</span>

    @Test
    public void testBoundaryUnsubscribedOnMainCompletion() {
<span class="fc" id="L304">        PublishProcessor&lt;Integer&gt; source = PublishProcessor.create();</span>
<span class="fc" id="L305">        final PublishProcessor&lt;Integer&gt; boundary = PublishProcessor.create();</span>
<span class="fc" id="L306">        Callable&lt;Flowable&lt;Integer&gt;&gt; boundaryFunc = new Callable&lt;Flowable&lt;Integer&gt;&gt;() {</span>
            @Override
            public Flowable&lt;Integer&gt; call() {
<span class="fc" id="L309">                return boundary;</span>
            }
        };

<span class="fc" id="L313">        TestSubscriber&lt;Flowable&lt;Integer&gt;&gt; ts = new TestSubscriber&lt;Flowable&lt;Integer&gt;&gt;();</span>
<span class="fc" id="L314">        source.window(boundaryFunc).subscribe(ts);</span>

<span class="fc" id="L316">        assertTrue(source.hasSubscribers());</span>
<span class="fc" id="L317">        assertTrue(boundary.hasSubscribers());</span>

<span class="fc" id="L319">        source.onComplete();</span>

<span class="fc" id="L321">        assertFalse(source.hasSubscribers());</span>
<span class="fc" id="L322">        assertFalse(boundary.hasSubscribers());</span>

<span class="fc" id="L324">        ts.assertComplete();</span>
<span class="fc" id="L325">        ts.assertNoErrors();</span>
<span class="fc" id="L326">        ts.assertValueCount(1);</span>
<span class="fc" id="L327">    }</span>

    @Test
    public void testMainUnsubscribedOnBoundaryCompletion() {
<span class="fc" id="L331">        PublishProcessor&lt;Integer&gt; source = PublishProcessor.create();</span>
<span class="fc" id="L332">        final PublishProcessor&lt;Integer&gt; boundary = PublishProcessor.create();</span>
<span class="fc" id="L333">        Callable&lt;Flowable&lt;Integer&gt;&gt; boundaryFunc = new Callable&lt;Flowable&lt;Integer&gt;&gt;() {</span>
            @Override
            public Flowable&lt;Integer&gt; call() {
<span class="fc" id="L336">                return boundary;</span>
            }
        };

<span class="fc" id="L340">        TestSubscriber&lt;Flowable&lt;Integer&gt;&gt; ts = new TestSubscriber&lt;Flowable&lt;Integer&gt;&gt;();</span>
<span class="fc" id="L341">        source.window(boundaryFunc).subscribe(ts);</span>

<span class="fc" id="L343">        assertTrue(source.hasSubscribers());</span>
<span class="fc" id="L344">        assertTrue(boundary.hasSubscribers());</span>

<span class="fc" id="L346">        boundary.onComplete();</span>

<span class="fc" id="L348">        assertFalse(source.hasSubscribers());</span>
<span class="fc" id="L349">        assertFalse(boundary.hasSubscribers());</span>

<span class="fc" id="L351">        ts.assertComplete();</span>
<span class="fc" id="L352">        ts.assertNoErrors();</span>
<span class="fc" id="L353">        ts.assertValueCount(1);</span>
<span class="fc" id="L354">    }</span>

    @Test
    public void testChildUnsubscribed() {
<span class="fc" id="L358">        PublishProcessor&lt;Integer&gt; source = PublishProcessor.create();</span>
<span class="fc" id="L359">        final PublishProcessor&lt;Integer&gt; boundary = PublishProcessor.create();</span>
<span class="fc" id="L360">        Callable&lt;Flowable&lt;Integer&gt;&gt; boundaryFunc = new Callable&lt;Flowable&lt;Integer&gt;&gt;() {</span>
            @Override
            public Flowable&lt;Integer&gt; call() {
<span class="fc" id="L363">                return boundary;</span>
            }
        };

<span class="fc" id="L367">        TestSubscriber&lt;Flowable&lt;Integer&gt;&gt; ts = new TestSubscriber&lt;Flowable&lt;Integer&gt;&gt;();</span>
<span class="fc" id="L368">        source.window(boundaryFunc).subscribe(ts);</span>

<span class="fc" id="L370">        assertTrue(source.hasSubscribers());</span>
<span class="fc" id="L371">        assertTrue(boundary.hasSubscribers());</span>

<span class="fc" id="L373">        ts.dispose();</span>

<span class="fc" id="L375">        assertTrue(source.hasSubscribers());</span>

<span class="fc" id="L377">        assertFalse(boundary.hasSubscribers());</span>

<span class="fc" id="L379">        ts.values().get(0).test().cancel();</span>

<span class="fc" id="L381">        assertFalse(source.hasSubscribers());</span>

<span class="fc" id="L383">        ts.assertNotComplete();</span>
<span class="fc" id="L384">        ts.assertNoErrors();</span>
<span class="fc" id="L385">        ts.assertValueCount(1);</span>
<span class="fc" id="L386">    }</span>

    @Test
    public void testInnerBackpressure() {
<span class="fc" id="L390">        Flowable&lt;Integer&gt; source = Flowable.range(1, 10);</span>
<span class="fc" id="L391">        final PublishProcessor&lt;Integer&gt; boundary = PublishProcessor.create();</span>
<span class="fc" id="L392">        Callable&lt;Flowable&lt;Integer&gt;&gt; boundaryFunc = new Callable&lt;Flowable&lt;Integer&gt;&gt;() {</span>
            @Override
            public Flowable&lt;Integer&gt; call() {
<span class="fc" id="L395">                return boundary;</span>
            }
        };

<span class="fc" id="L399">        final TestSubscriber&lt;Integer&gt; ts = new TestSubscriber&lt;Integer&gt;(1L);</span>
<span class="fc" id="L400">        final TestSubscriber&lt;Flowable&lt;Integer&gt;&gt; ts1 = new TestSubscriber&lt;Flowable&lt;Integer&gt;&gt;(1L) {</span>
            @Override
            public void onNext(Flowable&lt;Integer&gt; t) {
<span class="fc" id="L403">                super.onNext(t);</span>
<span class="fc" id="L404">                t.subscribe(ts);</span>
<span class="fc" id="L405">            }</span>
        };
<span class="fc" id="L407">        source.window(boundaryFunc)</span>
<span class="fc" id="L408">        .subscribe(ts1);</span>

<span class="fc" id="L410">        ts1.assertNoErrors();</span>
<span class="fc" id="L411">        ts1.assertComplete();</span>
<span class="fc" id="L412">        ts1.assertValueCount(1);</span>

<span class="fc" id="L414">        ts.assertNoErrors();</span>
<span class="fc" id="L415">        ts.assertNotComplete();</span>
<span class="fc" id="L416">        ts.assertValues(1);</span>

<span class="fc" id="L418">        ts.request(11);</span>

<span class="fc" id="L420">        ts.assertValues(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);</span>
<span class="fc" id="L421">        ts.assertNoErrors();</span>
<span class="fc" id="L422">        ts.assertComplete();</span>
<span class="fc" id="L423">    }</span>

    @Test
    public void newBoundaryCalledAfterWindowClosed() {
<span class="fc" id="L427">        final AtomicInteger calls = new AtomicInteger();</span>
<span class="fc" id="L428">        PublishProcessor&lt;Integer&gt; source = PublishProcessor.create();</span>
<span class="fc" id="L429">        final PublishProcessor&lt;Integer&gt; boundary = PublishProcessor.create();</span>
<span class="fc" id="L430">        Callable&lt;Flowable&lt;Integer&gt;&gt; boundaryFunc = new Callable&lt;Flowable&lt;Integer&gt;&gt;() {</span>
            @Override
            public Flowable&lt;Integer&gt; call() {
<span class="fc" id="L433">                calls.getAndIncrement();</span>
<span class="fc" id="L434">                return boundary;</span>
            }
        };

<span class="fc" id="L438">        TestSubscriber&lt;Flowable&lt;Integer&gt;&gt; ts = new TestSubscriber&lt;Flowable&lt;Integer&gt;&gt;();</span>
<span class="fc" id="L439">        source.window(boundaryFunc).subscribe(ts);</span>

<span class="fc" id="L441">        source.onNext(1);</span>
<span class="fc" id="L442">        boundary.onNext(1);</span>
<span class="fc" id="L443">        assertTrue(boundary.hasSubscribers());</span>

<span class="fc" id="L445">        source.onNext(2);</span>
<span class="fc" id="L446">        boundary.onNext(2);</span>
<span class="fc" id="L447">        assertTrue(boundary.hasSubscribers());</span>

<span class="fc" id="L449">        source.onNext(3);</span>
<span class="fc" id="L450">        boundary.onNext(3);</span>
<span class="fc" id="L451">        assertTrue(boundary.hasSubscribers());</span>

<span class="fc" id="L453">        source.onNext(4);</span>
<span class="fc" id="L454">        source.onComplete();</span>

<span class="fc" id="L456">        ts.assertNoErrors();</span>
<span class="fc" id="L457">        ts.assertValueCount(4);</span>
<span class="fc" id="L458">        ts.assertComplete();</span>

<span class="fc" id="L460">        assertFalse(source.hasSubscribers());</span>
<span class="fc" id="L461">        assertFalse(boundary.hasSubscribers());</span>
<span class="fc" id="L462">    }</span>

    @Test
    public void boundaryDispose() {
<span class="fc" id="L466">        TestHelper.checkDisposed(Flowable.never().window(Flowable.never()));</span>
<span class="fc" id="L467">    }</span>

    @Test
    public void boundaryDispose2() {
<span class="fc" id="L471">        TestHelper.checkDisposed(Flowable.never().window(Functions.justCallable(Flowable.never())));</span>
<span class="fc" id="L472">    }</span>

    @Test
    public void boundaryOnError() {
<span class="fc" id="L476">        TestSubscriber&lt;Object&gt; ts = Flowable.error(new TestException())</span>
<span class="fc" id="L477">        .window(Flowable.never())</span>
<span class="fc" id="L478">        .flatMap(Functions.&lt;Flowable&lt;Object&gt;&gt;identity(), true)</span>
<span class="fc" id="L479">        .test()</span>
<span class="fc" id="L480">        .assertFailure(CompositeException.class);</span>

<span class="fc" id="L482">        List&lt;Throwable&gt; errors = TestHelper.compositeList(ts.errors().get(0));</span>

<span class="fc" id="L484">        TestHelper.assertError(errors, 0, TestException.class);</span>
<span class="fc" id="L485">    }</span>

    @Test
    public void mainError() {
<span class="fc" id="L489">        Flowable.error(new TestException())</span>
<span class="fc" id="L490">        .window(Functions.justCallable(Flowable.never()))</span>
<span class="fc" id="L491">        .test()</span>
<span class="fc" id="L492">        .assertError(TestException.class);</span>
<span class="fc" id="L493">    }</span>

    @Test
    public void innerBadSource() {
<span class="fc" id="L497">        TestHelper.checkBadSourceFlowable(new Function&lt;Flowable&lt;Integer&gt;, Object&gt;() {</span>
            @Override
            public Object apply(Flowable&lt;Integer&gt; f) throws Exception {
<span class="fc" id="L500">                return Flowable.just(1).window(f).flatMap(new Function&lt;Flowable&lt;Integer&gt;, Flowable&lt;Integer&gt;&gt;() {</span>
                    @Override
                    public Flowable&lt;Integer&gt; apply(Flowable&lt;Integer&gt; v) throws Exception {
<span class="fc" id="L503">                        return v;</span>
                    }
                });
            }
<span class="fc" id="L507">        }, false, 1, 1, (Object[])null);</span>

<span class="fc" id="L509">        TestHelper.checkBadSourceFlowable(new Function&lt;Flowable&lt;Integer&gt;, Object&gt;() {</span>
            @Override
            public Object apply(final Flowable&lt;Integer&gt; f) throws Exception {
<span class="fc" id="L512">                return Flowable.just(1).window(new Callable&lt;Publisher&lt;Integer&gt;&gt;() {</span>
                    int count;
                    @Override
                    public Publisher&lt;Integer&gt; call() throws Exception {
<span class="fc bfc" id="L516" title="All 2 branches covered.">                        if (++count &gt; 1) {</span>
<span class="fc" id="L517">                            return Flowable.never();</span>
                        }
<span class="fc" id="L519">                        return f;</span>
                    }
                })
<span class="fc" id="L522">                        .flatMap(new Function&lt;Flowable&lt;Integer&gt;, Flowable&lt;Integer&gt;&gt;() {</span>
                    @Override
                    public Flowable&lt;Integer&gt; apply(Flowable&lt;Integer&gt; v) throws Exception {
<span class="fc" id="L525">                        return v;</span>
                    }
                });
            }
<span class="fc" id="L529">        }, false, 1, 1, (Object[])null);</span>
<span class="fc" id="L530">    }</span>

    @Test
    public void reentrant() {
<span class="fc" id="L534">        final FlowableProcessor&lt;Integer&gt; ps = PublishProcessor.&lt;Integer&gt;create();</span>

<span class="fc" id="L536">        TestSubscriber&lt;Integer&gt; ts = new TestSubscriber&lt;Integer&gt;() {</span>
            @Override
            public void onNext(Integer t) {
<span class="fc" id="L539">                super.onNext(t);</span>
<span class="fc bfc" id="L540" title="All 2 branches covered.">                if (t == 1) {</span>
<span class="fc" id="L541">                    ps.onNext(2);</span>
<span class="fc" id="L542">                    ps.onComplete();</span>
                }
<span class="fc" id="L544">            }</span>
        };

<span class="fc" id="L547">        ps.window(BehaviorProcessor.createDefault(1))</span>
<span class="fc" id="L548">        .flatMap(new Function&lt;Flowable&lt;Integer&gt;, Flowable&lt;Integer&gt;&gt;() {</span>
            @Override
            public Flowable&lt;Integer&gt; apply(Flowable&lt;Integer&gt; v) throws Exception {
<span class="fc" id="L551">                return v;</span>
            }
        })
<span class="fc" id="L554">        .subscribe(ts);</span>

<span class="fc" id="L556">        ps.onNext(1);</span>

<span class="fc" id="L558">        ts</span>
<span class="fc" id="L559">        .awaitDone(1, TimeUnit.SECONDS)</span>
<span class="fc" id="L560">        .assertResult(1, 2);</span>
<span class="fc" id="L561">    }</span>

    @Test
    public void reentrantCallable() {
<span class="fc" id="L565">        final FlowableProcessor&lt;Integer&gt; ps = PublishProcessor.&lt;Integer&gt;create();</span>

<span class="fc" id="L567">        TestSubscriber&lt;Integer&gt; ts = new TestSubscriber&lt;Integer&gt;() {</span>
            @Override
            public void onNext(Integer t) {
<span class="fc" id="L570">                super.onNext(t);</span>
<span class="fc bfc" id="L571" title="All 2 branches covered.">                if (t == 1) {</span>
<span class="fc" id="L572">                    ps.onNext(2);</span>
<span class="fc" id="L573">                    ps.onComplete();</span>
                }
<span class="fc" id="L575">            }</span>
        };

<span class="fc" id="L578">        ps.window(new Callable&lt;Flowable&lt;Integer&gt;&gt;() {</span>
            boolean once;
            @Override
            public Flowable&lt;Integer&gt; call() throws Exception {
<span class="fc bfc" id="L582" title="All 2 branches covered.">                if (!once) {</span>
<span class="fc" id="L583">                    once = true;</span>
<span class="fc" id="L584">                    return BehaviorProcessor.createDefault(1);</span>
                }
<span class="fc" id="L586">                return Flowable.never();</span>
            }
        })
<span class="fc" id="L589">        .flatMap(new Function&lt;Flowable&lt;Integer&gt;, Flowable&lt;Integer&gt;&gt;() {</span>
            @Override
            public Flowable&lt;Integer&gt; apply(Flowable&lt;Integer&gt; v) throws Exception {
<span class="fc" id="L592">                return v;</span>
            }
        })
<span class="fc" id="L595">        .subscribe(ts);</span>

<span class="fc" id="L597">        ps.onNext(1);</span>

<span class="fc" id="L599">        ts</span>
<span class="fc" id="L600">        .awaitDone(1, TimeUnit.SECONDS)</span>
<span class="fc" id="L601">        .assertResult(1, 2);</span>
<span class="fc" id="L602">    }</span>

    @Test
    public void badSource() {
<span class="fc" id="L606">        TestHelper.checkBadSourceFlowable(new Function&lt;Flowable&lt;Object&gt;, Object&gt;() {</span>
            @Override
            public Object apply(Flowable&lt;Object&gt; f) throws Exception {
<span class="fc" id="L609">                return f.window(Flowable.never()).flatMap(new Function&lt;Flowable&lt;Object&gt;, Flowable&lt;Object&gt;&gt;() {</span>
                    @Override
                    public Flowable&lt;Object&gt; apply(Flowable&lt;Object&gt; v) throws Exception {
<span class="fc" id="L612">                        return v;</span>
                    }
                });
            }
<span class="fc" id="L616">        }, false, 1, 1, 1);</span>
<span class="fc" id="L617">    }</span>

    @Test
    public void badSourceCallable() {
<span class="fc" id="L621">        TestHelper.checkBadSourceFlowable(new Function&lt;Flowable&lt;Object&gt;, Object&gt;() {</span>
            @Override
            public Object apply(Flowable&lt;Object&gt; f) throws Exception {
<span class="fc" id="L624">                return f.window(Functions.justCallable(Flowable.never())).flatMap(new Function&lt;Flowable&lt;Object&gt;, Flowable&lt;Object&gt;&gt;() {</span>
                    @Override
                    public Flowable&lt;Object&gt; apply(Flowable&lt;Object&gt; v) throws Exception {
<span class="fc" id="L627">                        return v;</span>
                    }
                });
            }
<span class="fc" id="L631">        }, false, 1, 1, 1);</span>
<span class="fc" id="L632">    }</span>

    @Test
    public void boundaryError() {
<span class="fc" id="L636">        BehaviorProcessor.createDefault(1)</span>
<span class="fc" id="L637">        .window(Functions.justCallable(Flowable.error(new TestException())))</span>
<span class="fc" id="L638">        .test()</span>
<span class="fc" id="L639">        .assertValueCount(1)</span>
<span class="fc" id="L640">        .assertNotComplete()</span>
<span class="fc" id="L641">        .assertError(TestException.class);</span>
<span class="fc" id="L642">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void boundaryMissingBackpressure() {
<span class="fc" id="L647">        BehaviorProcessor.createDefault(1)</span>
<span class="fc" id="L648">        .window(Functions.justCallable(Flowable.error(new TestException())))</span>
<span class="fc" id="L649">        .test(0)</span>
<span class="fc" id="L650">        .assertFailure(MissingBackpressureException.class);</span>
<span class="fc" id="L651">    }</span>

    @Test
    public void boundaryCallableCrashOnCall2() {
<span class="fc" id="L655">        BehaviorProcessor.createDefault(1)</span>
<span class="fc" id="L656">        .window(new Callable&lt;Flowable&lt;Integer&gt;&gt;() {</span>
            int calls;
            @Override
            public Flowable&lt;Integer&gt; call() throws Exception {
<span class="fc bfc" id="L660" title="All 2 branches covered.">                if (++calls == 2) {</span>
<span class="fc" id="L661">                    throw new TestException();</span>
                }
<span class="fc" id="L663">                return Flowable.just(1);</span>
            }
        })
<span class="fc" id="L666">        .test()</span>
<span class="fc" id="L667">        .assertError(TestException.class)</span>
<span class="fc" id="L668">        .assertNotComplete();</span>
<span class="fc" id="L669">    }</span>

    @Test
    public void boundarySecondMissingBackpressure() {
<span class="fc" id="L673">        BehaviorProcessor.createDefault(1)</span>
<span class="fc" id="L674">        .window(Functions.justCallable(Flowable.just(1)))</span>
<span class="fc" id="L675">        .test(1)</span>
<span class="fc" id="L676">        .assertError(MissingBackpressureException.class)</span>
<span class="fc" id="L677">        .assertNotComplete();</span>
<span class="fc" id="L678">    }</span>

    @Test
    public void oneWindow() {
<span class="fc" id="L682">        PublishProcessor&lt;Integer&gt; pp = PublishProcessor.create();</span>

<span class="fc" id="L684">        TestSubscriber&lt;Flowable&lt;Integer&gt;&gt; ts = BehaviorProcessor.createDefault(1)</span>
<span class="fc" id="L685">        .window(Functions.justCallable(pp))</span>
<span class="fc" id="L686">        .take(1)</span>
<span class="fc" id="L687">        .test();</span>

<span class="fc" id="L689">        pp.onNext(1);</span>

<span class="fc" id="L691">        ts</span>
<span class="fc" id="L692">        .assertValueCount(1)</span>
<span class="fc" id="L693">        .assertNoErrors()</span>
<span class="fc" id="L694">        .assertComplete();</span>
<span class="fc" id="L695">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void boundaryDirectMissingBackpressure() {
<span class="fc" id="L700">        List&lt;Throwable&gt; errors = TestHelper.trackPluginErrors();</span>
        try {
<span class="fc" id="L702">            BehaviorProcessor.create()</span>
<span class="fc" id="L703">            .window(Flowable.error(new TestException()))</span>
<span class="fc" id="L704">            .test(0)</span>
<span class="fc" id="L705">            .assertFailure(MissingBackpressureException.class);</span>

<span class="fc" id="L707">            TestHelper.assertUndeliverable(errors, 0, TestException.class);</span>
        } finally {
<span class="fc" id="L709">            RxJavaPlugins.reset();</span>
        }
<span class="fc" id="L711">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void boundaryDirectMissingBackpressureNoNullPointerException() {
<span class="fc" id="L716">        List&lt;Throwable&gt; errors = TestHelper.trackPluginErrors();</span>
        try {
<span class="fc" id="L718">            BehaviorProcessor.createDefault(1)</span>
<span class="fc" id="L719">            .window(Flowable.error(new TestException()))</span>
<span class="fc" id="L720">            .test(0)</span>
<span class="fc" id="L721">            .assertFailure(MissingBackpressureException.class);</span>

<span class="fc" id="L723">            TestHelper.assertUndeliverable(errors, 0, TestException.class);</span>
        } finally {
<span class="fc" id="L725">            RxJavaPlugins.reset();</span>
        }
<span class="fc" id="L727">    }</span>

    @Test
    public void boundaryDirectSecondMissingBackpressure() {
<span class="fc" id="L731">        BehaviorProcessor.createDefault(1)</span>
<span class="fc" id="L732">        .window(Flowable.just(1))</span>
<span class="fc" id="L733">        .test(1)</span>
<span class="fc" id="L734">        .assertError(MissingBackpressureException.class)</span>
<span class="fc" id="L735">        .assertNotComplete();</span>
<span class="fc" id="L736">    }</span>

    @Test
    public void boundaryDirectDoubleOnSubscribe() {
<span class="fc" id="L740">        TestHelper.checkDoubleOnSubscribeFlowable(new Function&lt;Flowable&lt;Object&gt;, Publisher&lt;Flowable&lt;Object&gt;&gt;&gt;() {</span>
            @Override
            public Publisher&lt;Flowable&lt;Object&gt;&gt; apply(Flowable&lt;Object&gt; f)
                    throws Exception {
<span class="fc" id="L744">                return f.window(Flowable.never()).takeLast(1);</span>
            }
        });
<span class="fc" id="L747">    }</span>

    @Test
    public void upstreamDisposedWhenOutputsDisposed() {
<span class="fc" id="L751">        PublishProcessor&lt;Integer&gt; source = PublishProcessor.create();</span>
<span class="fc" id="L752">        PublishProcessor&lt;Integer&gt; boundary = PublishProcessor.create();</span>

<span class="fc" id="L754">        TestSubscriber&lt;Integer&gt; ts = source.window(boundary)</span>
<span class="fc" id="L755">        .take(1)</span>
<span class="fc" id="L756">        .flatMap(new Function&lt;Flowable&lt;Integer&gt;, Flowable&lt;Integer&gt;&gt;() {</span>
            @Override
            public Flowable&lt;Integer&gt; apply(
                    Flowable&lt;Integer&gt; w) throws Exception {
<span class="fc" id="L760">                return w.take(1);</span>
            }
        })
<span class="fc" id="L763">        .test();</span>

<span class="fc" id="L765">        source.onNext(1);</span>

<span class="fc" id="L767">        assertFalse(&quot;source not disposed&quot;, source.hasSubscribers());</span>
<span class="fc" id="L768">        assertFalse(&quot;boundary not disposed&quot;, boundary.hasSubscribers());</span>

<span class="fc" id="L770">        ts.assertResult(1);</span>
<span class="fc" id="L771">    }</span>

    @Test
    public void mainAndBoundaryBothError() {
<span class="fc" id="L775">        List&lt;Throwable&gt; errors = TestHelper.trackPluginErrors();</span>
        try {
<span class="fc" id="L777">            final AtomicReference&lt;Subscriber&lt;? super Object&gt;&gt; ref = new AtomicReference&lt;Subscriber&lt;? super Object&gt;&gt;();</span>

<span class="fc" id="L779">            TestSubscriber&lt;Flowable&lt;Object&gt;&gt; ts = Flowable.error(new TestException(&quot;main&quot;))</span>
<span class="fc" id="L780">            .window(new Flowable&lt;Object&gt;() {</span>
                @Override
                protected void subscribeActual(Subscriber&lt;? super Object&gt; subscriber) {
<span class="fc" id="L783">                    subscriber.onSubscribe(new BooleanSubscription());</span>
<span class="fc" id="L784">                    ref.set(subscriber);</span>
<span class="fc" id="L785">                }</span>
            })
<span class="fc" id="L787">            .test();</span>

<span class="fc" id="L789">            ts</span>
<span class="fc" id="L790">            .assertValueCount(1)</span>
<span class="fc" id="L791">            .assertError(TestException.class)</span>
<span class="fc" id="L792">            .assertErrorMessage(&quot;main&quot;)</span>
<span class="fc" id="L793">            .assertNotComplete();</span>

<span class="fc" id="L795">            ref.get().onError(new TestException(&quot;inner&quot;));</span>

<span class="fc" id="L797">            TestHelper.assertUndeliverable(errors, 0, TestException.class, &quot;inner&quot;);</span>
        } finally {
<span class="fc" id="L799">            RxJavaPlugins.reset();</span>
        }
<span class="fc" id="L801">    }</span>

    @Test
    public void mainCompleteBoundaryErrorRace() {
<span class="fc" id="L805">        final TestException ex = new TestException();</span>

<span class="fc bfc" id="L807" title="All 2 branches covered.">        for (int i = 0; i &lt; TestHelper.RACE_LONG_LOOPS; i++) {</span>
<span class="fc" id="L808">            List&lt;Throwable&gt; errors = TestHelper.trackPluginErrors();</span>
            try {
<span class="fc" id="L810">                final AtomicReference&lt;Subscriber&lt;? super Object&gt;&gt; refMain = new AtomicReference&lt;Subscriber&lt;? super Object&gt;&gt;();</span>
<span class="fc" id="L811">                final AtomicReference&lt;Subscriber&lt;? super Object&gt;&gt; ref = new AtomicReference&lt;Subscriber&lt;? super Object&gt;&gt;();</span>

<span class="fc" id="L813">                TestSubscriber&lt;Flowable&lt;Object&gt;&gt; ts = new Flowable&lt;Object&gt;() {</span>
                    @Override
                    protected void subscribeActual(Subscriber&lt;? super Object&gt; subscriber) {
<span class="fc" id="L816">                        subscriber.onSubscribe(new BooleanSubscription());</span>
<span class="fc" id="L817">                        refMain.set(subscriber);</span>
<span class="fc" id="L818">                    }</span>
                }
<span class="fc" id="L820">                .window(new Flowable&lt;Object&gt;() {</span>
                    @Override
                    protected void subscribeActual(Subscriber&lt;? super Object&gt; subscriber) {
<span class="fc" id="L823">                        subscriber.onSubscribe(new BooleanSubscription());</span>
<span class="fc" id="L824">                        ref.set(subscriber);</span>
<span class="fc" id="L825">                    }</span>
                })
<span class="fc" id="L827">                .test();</span>

<span class="fc" id="L829">                Runnable r1 = new Runnable() {</span>
                    @Override
                    public void run() {
<span class="fc" id="L832">                        refMain.get().onComplete();</span>
<span class="fc" id="L833">                    }</span>
                };
<span class="fc" id="L835">                Runnable r2 = new Runnable() {</span>
                    @Override
                    public void run() {
<span class="fc" id="L838">                        ref.get().onError(ex);</span>
<span class="fc" id="L839">                    }</span>
                };

<span class="fc" id="L842">                TestHelper.race(r1, r2);</span>

<span class="fc" id="L844">                ts</span>
<span class="fc" id="L845">                .assertValueCount(1)</span>
<span class="fc" id="L846">                .assertTerminated();</span>

<span class="fc bfc" id="L848" title="All 2 branches covered.">                if (!errors.isEmpty()) {</span>
<span class="fc" id="L849">                    TestHelper.assertUndeliverable(errors, 0, TestException.class);</span>
                }
            } finally {
<span class="fc" id="L852">                RxJavaPlugins.reset();</span>
            }
        }
<span class="fc" id="L855">    }</span>

    @Test
    public void mainNextBoundaryNextRace() {
<span class="fc bfc" id="L859" title="All 2 branches covered.">        for (int i = 0; i &lt; TestHelper.RACE_LONG_LOOPS; i++) {</span>
<span class="fc" id="L860">            final AtomicReference&lt;Subscriber&lt;? super Object&gt;&gt; refMain = new AtomicReference&lt;Subscriber&lt;? super Object&gt;&gt;();</span>
<span class="fc" id="L861">            final AtomicReference&lt;Subscriber&lt;? super Object&gt;&gt; ref = new AtomicReference&lt;Subscriber&lt;? super Object&gt;&gt;();</span>

<span class="fc" id="L863">            TestSubscriber&lt;Flowable&lt;Object&gt;&gt; ts = new Flowable&lt;Object&gt;() {</span>
                @Override
                protected void subscribeActual(Subscriber&lt;? super Object&gt; subscriber) {
<span class="fc" id="L866">                    subscriber.onSubscribe(new BooleanSubscription());</span>
<span class="fc" id="L867">                    refMain.set(subscriber);</span>
<span class="fc" id="L868">                }</span>
            }
<span class="fc" id="L870">            .window(new Flowable&lt;Object&gt;() {</span>
                @Override
                protected void subscribeActual(Subscriber&lt;? super Object&gt; subscriber) {
<span class="fc" id="L873">                    subscriber.onSubscribe(new BooleanSubscription());</span>
<span class="fc" id="L874">                    ref.set(subscriber);</span>
<span class="fc" id="L875">                }</span>
            })
<span class="fc" id="L877">            .test();</span>

<span class="fc" id="L879">            Runnable r1 = new Runnable() {</span>
                @Override
                public void run() {
<span class="fc" id="L882">                    refMain.get().onNext(1);</span>
<span class="fc" id="L883">                }</span>
            };
<span class="fc" id="L885">            Runnable r2 = new Runnable() {</span>
                @Override
                public void run() {
<span class="fc" id="L888">                    ref.get().onNext(1);</span>
<span class="fc" id="L889">                }</span>
            };

<span class="fc" id="L892">            TestHelper.race(r1, r2);</span>

<span class="fc" id="L894">            ts</span>
<span class="fc" id="L895">            .assertValueCount(2)</span>
<span class="fc" id="L896">            .assertNotComplete()</span>
<span class="fc" id="L897">            .assertNoErrors();</span>
        }
<span class="fc" id="L899">    }</span>

    @Test
    public void takeOneAnotherBoundary() {
<span class="fc" id="L903">        final AtomicReference&lt;Subscriber&lt;? super Object&gt;&gt; refMain = new AtomicReference&lt;Subscriber&lt;? super Object&gt;&gt;();</span>
<span class="fc" id="L904">        final AtomicReference&lt;Subscriber&lt;? super Object&gt;&gt; ref = new AtomicReference&lt;Subscriber&lt;? super Object&gt;&gt;();</span>

<span class="fc" id="L906">        TestSubscriber&lt;Flowable&lt;Object&gt;&gt; ts = new Flowable&lt;Object&gt;() {</span>
            @Override
            protected void subscribeActual(Subscriber&lt;? super Object&gt; subscriber) {
<span class="fc" id="L909">                subscriber.onSubscribe(new BooleanSubscription());</span>
<span class="fc" id="L910">                refMain.set(subscriber);</span>
<span class="fc" id="L911">            }</span>
        }
<span class="fc" id="L913">        .window(new Flowable&lt;Object&gt;() {</span>
            @Override
            protected void subscribeActual(Subscriber&lt;? super Object&gt; subscriber) {
<span class="fc" id="L916">                subscriber.onSubscribe(new BooleanSubscription());</span>
<span class="fc" id="L917">                ref.set(subscriber);</span>
<span class="fc" id="L918">            }</span>
        })
<span class="fc" id="L920">        .test();</span>

<span class="fc" id="L922">        ts.assertValueCount(1)</span>
<span class="fc" id="L923">        .assertNotTerminated()</span>
<span class="fc" id="L924">        .cancel();</span>

<span class="fc" id="L926">        ref.get().onNext(1);</span>

<span class="fc" id="L928">        ts.assertValueCount(1)</span>
<span class="fc" id="L929">        .assertNotTerminated();</span>
<span class="fc" id="L930">    }</span>

    @Test
    public void disposeMainBoundaryCompleteRace() {
<span class="fc bfc" id="L934" title="All 2 branches covered.">        for (int i = 0; i &lt; TestHelper.RACE_LONG_LOOPS; i++) {</span>
<span class="fc" id="L935">            final AtomicReference&lt;Subscriber&lt;? super Object&gt;&gt; refMain = new AtomicReference&lt;Subscriber&lt;? super Object&gt;&gt;();</span>
<span class="fc" id="L936">            final AtomicReference&lt;Subscriber&lt;? super Object&gt;&gt; ref = new AtomicReference&lt;Subscriber&lt;? super Object&gt;&gt;();</span>

<span class="fc" id="L938">            final TestSubscriber&lt;Flowable&lt;Object&gt;&gt; ts = new Flowable&lt;Object&gt;() {</span>
                 @Override
                 protected void subscribeActual(Subscriber&lt;? super Object&gt; subscriber) {
<span class="fc" id="L941">                     subscriber.onSubscribe(new BooleanSubscription());</span>
<span class="fc" id="L942">                     refMain.set(subscriber);</span>
<span class="fc" id="L943">                 }</span>
             }
<span class="fc" id="L945">             .window(new Flowable&lt;Object&gt;() {</span>
                 @Override
                 protected void subscribeActual(Subscriber&lt;? super Object&gt; subscriber) {
<span class="fc" id="L948">                     final AtomicInteger counter = new AtomicInteger();</span>
<span class="fc" id="L949">                     subscriber.onSubscribe(new Subscription() {</span>

                         @Override
                         public void cancel() {
                             // about a microsecond
<span class="fc bfc" id="L954" title="All 2 branches covered.">                             for (int i = 0; i &lt; 100; i++) {</span>
<span class="fc" id="L955">                                 counter.incrementAndGet();</span>
                             }
<span class="fc" id="L957">                         }</span>

                         @Override
                        public void request(long n) {
<span class="fc" id="L961">                        }</span>
                     });
<span class="fc" id="L963">                     ref.set(subscriber);</span>
<span class="fc" id="L964">                 }</span>
             })
<span class="fc" id="L966">             .test();</span>

<span class="fc" id="L968">             Runnable r1 = new Runnable() {</span>
                 @Override
                 public void run() {
<span class="fc" id="L971">                     ts.cancel();</span>
<span class="fc" id="L972">                 }</span>
             };
<span class="fc" id="L974">             Runnable r2 = new Runnable() {</span>
                 @Override
                 public void run() {
<span class="fc" id="L977">                     Subscriber&lt;Object&gt; subscriber = ref.get();</span>
<span class="fc" id="L978">                     subscriber.onNext(1);</span>
<span class="fc" id="L979">                     subscriber.onComplete();</span>
<span class="fc" id="L980">                 }</span>
             };

<span class="fc" id="L983">             TestHelper.race(r1, r2);</span>
        }
<span class="fc" id="L985">    }</span>

    @Test
    public void disposeMainBoundaryErrorRace() {
<span class="fc" id="L989">        final TestException ex = new TestException();</span>

<span class="fc bfc" id="L991" title="All 2 branches covered.">        for (int i = 0; i &lt; TestHelper.RACE_LONG_LOOPS; i++) {</span>
<span class="fc" id="L992">           final AtomicReference&lt;Subscriber&lt;? super Object&gt;&gt; refMain = new AtomicReference&lt;Subscriber&lt;? super Object&gt;&gt;();</span>
<span class="fc" id="L993">           final AtomicReference&lt;Subscriber&lt;? super Object&gt;&gt; ref = new AtomicReference&lt;Subscriber&lt;? super Object&gt;&gt;();</span>

<span class="fc" id="L995">           final TestSubscriber&lt;Flowable&lt;Object&gt;&gt; ts = new Flowable&lt;Object&gt;() {</span>
               @Override
               protected void subscribeActual(Subscriber&lt;? super Object&gt; subscriber) {
<span class="fc" id="L998">                   subscriber.onSubscribe(new BooleanSubscription());</span>
<span class="fc" id="L999">                   refMain.set(subscriber);</span>
<span class="fc" id="L1000">               }</span>
           }
<span class="fc" id="L1002">           .window(new Flowable&lt;Object&gt;() {</span>
               @Override
               protected void subscribeActual(Subscriber&lt;? super Object&gt; subscriber) {
<span class="fc" id="L1005">                   final AtomicInteger counter = new AtomicInteger();</span>
<span class="fc" id="L1006">                   subscriber.onSubscribe(new Subscription() {</span>

                       @Override
                       public void cancel() {
                           // about a microsecond
<span class="fc bfc" id="L1011" title="All 2 branches covered.">                           for (int i = 0; i &lt; 100; i++) {</span>
<span class="fc" id="L1012">                               counter.incrementAndGet();</span>
                           }
<span class="fc" id="L1014">                       }</span>

                       @Override
                      public void request(long n) {
<span class="fc" id="L1018">                      }</span>
                   });
<span class="fc" id="L1020">                   ref.set(subscriber);</span>
<span class="fc" id="L1021">               }</span>
           })
<span class="fc" id="L1023">           .test();</span>

<span class="fc" id="L1025">            Runnable r1 = new Runnable() {</span>
                @Override
                public void run() {
<span class="fc" id="L1028">                    ts.cancel();</span>
<span class="fc" id="L1029">                }</span>
            };
<span class="fc" id="L1031">            Runnable r2 = new Runnable() {</span>
                @Override
                public void run() {
<span class="fc" id="L1034">                    Subscriber&lt;Object&gt; subscriber = ref.get();</span>
<span class="fc" id="L1035">                    subscriber.onNext(1);</span>
<span class="fc" id="L1036">                    subscriber.onError(ex);</span>
<span class="fc" id="L1037">                }</span>
            };

<span class="fc" id="L1040">            TestHelper.race(r1, r2);</span>
        }
<span class="fc" id="L1042">    }</span>

    @Test
    public void boundarySupplierDoubleOnSubscribe() {
<span class="fc" id="L1046">        TestHelper.checkDoubleOnSubscribeFlowable(new Function&lt;Flowable&lt;Object&gt;, Flowable&lt;Flowable&lt;Object&gt;&gt;&gt;() {</span>
            @Override
            public Flowable&lt;Flowable&lt;Object&gt;&gt; apply(Flowable&lt;Object&gt; f)
                    throws Exception {
<span class="fc" id="L1050">                return f.window(Functions.justCallable(Flowable.never())).takeLast(1);</span>
            }
        });
<span class="fc" id="L1053">    }</span>

    @Test
    public void selectorUpstreamDisposedWhenOutputsDisposed() {
<span class="fc" id="L1057">        PublishProcessor&lt;Integer&gt; source = PublishProcessor.create();</span>
<span class="fc" id="L1058">        PublishProcessor&lt;Integer&gt; boundary = PublishProcessor.create();</span>

<span class="fc" id="L1060">        TestSubscriber&lt;Integer&gt; ts = source.window(Functions.justCallable(boundary))</span>
<span class="fc" id="L1061">        .take(1)</span>
<span class="fc" id="L1062">        .flatMap(new Function&lt;Flowable&lt;Integer&gt;, Flowable&lt;Integer&gt;&gt;() {</span>
            @Override
            public Flowable&lt;Integer&gt; apply(
                    Flowable&lt;Integer&gt; w) throws Exception {
<span class="fc" id="L1066">                return w.take(1);</span>
            }
        })
<span class="fc" id="L1069">        .test();</span>

<span class="fc" id="L1071">        source.onNext(1);</span>

<span class="fc" id="L1073">        assertFalse(&quot;source not disposed&quot;, source.hasSubscribers());</span>
<span class="fc" id="L1074">        assertFalse(&quot;boundary not disposed&quot;, boundary.hasSubscribers());</span>

<span class="fc" id="L1076">        ts.assertResult(1);</span>
<span class="fc" id="L1077">    }</span>

    @Test
    public void supplierMainAndBoundaryBothError() {
<span class="fc" id="L1081">        List&lt;Throwable&gt; errors = TestHelper.trackPluginErrors();</span>
        try {
<span class="fc" id="L1083">            final AtomicReference&lt;Subscriber&lt;? super Object&gt;&gt; ref = new AtomicReference&lt;Subscriber&lt;? super Object&gt;&gt;();</span>

<span class="fc" id="L1085">            TestSubscriber&lt;Flowable&lt;Object&gt;&gt; ts = Flowable.error(new TestException(&quot;main&quot;))</span>
<span class="fc" id="L1086">            .window(Functions.justCallable(new Flowable&lt;Object&gt;() {</span>
                @Override
                protected void subscribeActual(Subscriber&lt;? super Object&gt; subscriber) {
<span class="fc" id="L1089">                    subscriber.onSubscribe(new BooleanSubscription());</span>
<span class="fc" id="L1090">                    ref.set(subscriber);</span>
<span class="fc" id="L1091">                }</span>
            }))
<span class="fc" id="L1093">            .test();</span>

<span class="fc" id="L1095">            ts</span>
<span class="fc" id="L1096">            .assertValueCount(1)</span>
<span class="fc" id="L1097">            .assertError(TestException.class)</span>
<span class="fc" id="L1098">            .assertErrorMessage(&quot;main&quot;)</span>
<span class="fc" id="L1099">            .assertNotComplete();</span>

<span class="fc" id="L1101">            ref.get().onError(new TestException(&quot;inner&quot;));</span>

<span class="fc" id="L1103">            TestHelper.assertUndeliverable(errors, 0, TestException.class, &quot;inner&quot;);</span>
        } finally {
<span class="fc" id="L1105">            RxJavaPlugins.reset();</span>
        }
<span class="fc" id="L1107">    }</span>

    @Test
    public void supplierMainCompleteBoundaryErrorRace() {
<span class="fc" id="L1111">        final TestException ex = new TestException();</span>

<span class="fc bfc" id="L1113" title="All 2 branches covered.">        for (int i = 0; i &lt; TestHelper.RACE_LONG_LOOPS; i++) {</span>
<span class="fc" id="L1114">            List&lt;Throwable&gt; errors = TestHelper.trackPluginErrors();</span>
            try {
<span class="fc" id="L1116">                final AtomicReference&lt;Subscriber&lt;? super Object&gt;&gt; refMain = new AtomicReference&lt;Subscriber&lt;? super Object&gt;&gt;();</span>
<span class="fc" id="L1117">                final AtomicReference&lt;Subscriber&lt;? super Object&gt;&gt; ref = new AtomicReference&lt;Subscriber&lt;? super Object&gt;&gt;();</span>

<span class="fc" id="L1119">                TestSubscriber&lt;Flowable&lt;Object&gt;&gt; ts = new Flowable&lt;Object&gt;() {</span>
                    @Override
                    protected void subscribeActual(Subscriber&lt;? super Object&gt; subscriber) {
<span class="fc" id="L1122">                        subscriber.onSubscribe(new BooleanSubscription());</span>
<span class="fc" id="L1123">                        refMain.set(subscriber);</span>
<span class="fc" id="L1124">                    }</span>
                }
<span class="fc" id="L1126">                .window(Functions.justCallable(new Flowable&lt;Object&gt;() {</span>
                    @Override
                    protected void subscribeActual(Subscriber&lt;? super Object&gt; subscriber) {
<span class="fc" id="L1129">                        subscriber.onSubscribe(new BooleanSubscription());</span>
<span class="fc" id="L1130">                        ref.set(subscriber);</span>
<span class="fc" id="L1131">                    }</span>
                }))
<span class="fc" id="L1133">                .test();</span>

<span class="fc" id="L1135">                Runnable r1 = new Runnable() {</span>
                    @Override
                    public void run() {
<span class="fc" id="L1138">                        refMain.get().onComplete();</span>
<span class="fc" id="L1139">                    }</span>
                };
<span class="fc" id="L1141">                Runnable r2 = new Runnable() {</span>
                    @Override
                    public void run() {
<span class="fc" id="L1144">                        ref.get().onError(ex);</span>
<span class="fc" id="L1145">                    }</span>
                };

<span class="fc" id="L1148">                TestHelper.race(r1, r2);</span>

<span class="fc" id="L1150">                ts</span>
<span class="fc" id="L1151">                .assertValueCount(1)</span>
<span class="fc" id="L1152">                .assertTerminated();</span>

<span class="fc bfc" id="L1154" title="All 2 branches covered.">                if (!errors.isEmpty()) {</span>
<span class="fc" id="L1155">                    TestHelper.assertUndeliverable(errors, 0, TestException.class);</span>
                }
            } finally {
<span class="fc" id="L1158">                RxJavaPlugins.reset();</span>
            }
        }
<span class="fc" id="L1161">    }</span>

    @Test
    public void supplierMainNextBoundaryNextRace() {
<span class="fc bfc" id="L1165" title="All 2 branches covered.">        for (int i = 0; i &lt; TestHelper.RACE_LONG_LOOPS; i++) {</span>
<span class="fc" id="L1166">            final AtomicReference&lt;Subscriber&lt;? super Object&gt;&gt; refMain = new AtomicReference&lt;Subscriber&lt;? super Object&gt;&gt;();</span>
<span class="fc" id="L1167">            final AtomicReference&lt;Subscriber&lt;? super Object&gt;&gt; ref = new AtomicReference&lt;Subscriber&lt;? super Object&gt;&gt;();</span>

<span class="fc" id="L1169">            TestSubscriber&lt;Flowable&lt;Object&gt;&gt; ts = new Flowable&lt;Object&gt;() {</span>
                @Override
                protected void subscribeActual(Subscriber&lt;? super Object&gt; subscriber) {
<span class="fc" id="L1172">                    subscriber.onSubscribe(new BooleanSubscription());</span>
<span class="fc" id="L1173">                    refMain.set(subscriber);</span>
<span class="fc" id="L1174">                }</span>
            }
<span class="fc" id="L1176">            .window(Functions.justCallable(new Flowable&lt;Object&gt;() {</span>
                @Override
                protected void subscribeActual(Subscriber&lt;? super Object&gt; subscriber) {
<span class="fc" id="L1179">                    subscriber.onSubscribe(new BooleanSubscription());</span>
<span class="fc" id="L1180">                    ref.set(subscriber);</span>
<span class="fc" id="L1181">                }</span>
            }))
<span class="fc" id="L1183">            .test();</span>

<span class="fc" id="L1185">            Runnable r1 = new Runnable() {</span>
                @Override
                public void run() {
<span class="fc" id="L1188">                    refMain.get().onNext(1);</span>
<span class="fc" id="L1189">                }</span>
            };
<span class="fc" id="L1191">            Runnable r2 = new Runnable() {</span>
                @Override
                public void run() {
<span class="fc" id="L1194">                    ref.get().onNext(1);</span>
<span class="fc" id="L1195">                }</span>
            };

<span class="fc" id="L1198">            TestHelper.race(r1, r2);</span>

<span class="fc" id="L1200">            ts</span>
<span class="fc" id="L1201">            .assertValueCount(2)</span>
<span class="fc" id="L1202">            .assertNotComplete()</span>
<span class="fc" id="L1203">            .assertNoErrors();</span>
        }
<span class="fc" id="L1205">    }</span>

    @Test
    public void supplierTakeOneAnotherBoundary() {
<span class="fc" id="L1209">        final AtomicReference&lt;Subscriber&lt;? super Object&gt;&gt; refMain = new AtomicReference&lt;Subscriber&lt;? super Object&gt;&gt;();</span>
<span class="fc" id="L1210">        final AtomicReference&lt;Subscriber&lt;? super Object&gt;&gt; ref = new AtomicReference&lt;Subscriber&lt;? super Object&gt;&gt;();</span>

<span class="fc" id="L1212">        TestSubscriber&lt;Flowable&lt;Object&gt;&gt; ts = new Flowable&lt;Object&gt;() {</span>
            @Override
            protected void subscribeActual(Subscriber&lt;? super Object&gt; subscriber) {
<span class="fc" id="L1215">                subscriber.onSubscribe(new BooleanSubscription());</span>
<span class="fc" id="L1216">                refMain.set(subscriber);</span>
<span class="fc" id="L1217">            }</span>
        }
<span class="fc" id="L1219">        .window(Functions.justCallable(new Flowable&lt;Object&gt;() {</span>
            @Override
            protected void subscribeActual(Subscriber&lt;? super Object&gt; subscriber) {
<span class="fc" id="L1222">                subscriber.onSubscribe(new BooleanSubscription());</span>
<span class="fc" id="L1223">                ref.set(subscriber);</span>
<span class="fc" id="L1224">            }</span>
        }))
<span class="fc" id="L1226">        .test();</span>

<span class="fc" id="L1228">        ts.assertValueCount(1)</span>
<span class="fc" id="L1229">        .assertNotTerminated()</span>
<span class="fc" id="L1230">        .cancel();</span>

<span class="fc" id="L1232">        ref.get().onNext(1);</span>

<span class="fc" id="L1234">        ts.assertValueCount(1)</span>
<span class="fc" id="L1235">        .assertNotTerminated();</span>
<span class="fc" id="L1236">    }</span>

    @Test
    public void supplierDisposeMainBoundaryCompleteRace() {
<span class="fc bfc" id="L1240" title="All 2 branches covered.">        for (int i = 0; i &lt; TestHelper.RACE_LONG_LOOPS; i++) {</span>
<span class="fc" id="L1241">            final AtomicReference&lt;Subscriber&lt;? super Object&gt;&gt; refMain = new AtomicReference&lt;Subscriber&lt;? super Object&gt;&gt;();</span>
<span class="fc" id="L1242">            final AtomicReference&lt;Subscriber&lt;? super Object&gt;&gt; ref = new AtomicReference&lt;Subscriber&lt;? super Object&gt;&gt;();</span>

<span class="fc" id="L1244">            final TestSubscriber&lt;Flowable&lt;Object&gt;&gt; ts = new Flowable&lt;Object&gt;() {</span>
                 @Override
                 protected void subscribeActual(Subscriber&lt;? super Object&gt; subscriber) {
<span class="fc" id="L1247">                     subscriber.onSubscribe(new BooleanSubscription());</span>
<span class="fc" id="L1248">                     refMain.set(subscriber);</span>
<span class="fc" id="L1249">                 }</span>
             }
<span class="fc" id="L1251">             .window(Functions.justCallable(new Flowable&lt;Object&gt;() {</span>
                 @Override
                 protected void subscribeActual(Subscriber&lt;? super Object&gt; subscriber) {
<span class="fc" id="L1254">                     final AtomicInteger counter = new AtomicInteger();</span>
<span class="fc" id="L1255">                     subscriber.onSubscribe(new Subscription() {</span>

                         @Override
                         public void cancel() {
                             // about a microsecond
<span class="fc bfc" id="L1260" title="All 2 branches covered.">                             for (int i = 0; i &lt; 100; i++) {</span>
<span class="fc" id="L1261">                                 counter.incrementAndGet();</span>
                             }
<span class="fc" id="L1263">                         }</span>

                         @Override
                         public void request(long n) {
<span class="fc" id="L1267">                         }</span>
                      });
<span class="fc" id="L1269">                     ref.set(subscriber);</span>
<span class="fc" id="L1270">                 }</span>
             }))
<span class="fc" id="L1272">             .test();</span>

<span class="fc" id="L1274">             Runnable r1 = new Runnable() {</span>
                 @Override
                 public void run() {
<span class="fc" id="L1277">                     ts.cancel();</span>
<span class="fc" id="L1278">                 }</span>
             };
<span class="fc" id="L1280">             Runnable r2 = new Runnable() {</span>
                 @Override
                 public void run() {
<span class="fc" id="L1283">                     Subscriber&lt;Object&gt; subscriber = ref.get();</span>
<span class="fc" id="L1284">                     subscriber.onNext(1);</span>
<span class="fc" id="L1285">                     subscriber.onComplete();</span>
<span class="fc" id="L1286">                 }</span>
             };

<span class="fc" id="L1289">             TestHelper.race(r1, r2);</span>
        }
<span class="fc" id="L1291">    }</span>

    @Test
    public void supplierDisposeMainBoundaryErrorRace() {
<span class="fc" id="L1295">        final TestException ex = new TestException();</span>

<span class="fc bfc" id="L1297" title="All 2 branches covered.">        for (int i = 0; i &lt; TestHelper.RACE_LONG_LOOPS; i++) {</span>
<span class="fc" id="L1298">            List&lt;Throwable&gt; errors = TestHelper.trackPluginErrors();</span>
            try {
<span class="fc" id="L1300">                final AtomicReference&lt;Subscriber&lt;? super Object&gt;&gt; refMain = new AtomicReference&lt;Subscriber&lt;? super Object&gt;&gt;();</span>
<span class="fc" id="L1301">                final AtomicReference&lt;Subscriber&lt;? super Object&gt;&gt; ref = new AtomicReference&lt;Subscriber&lt;? super Object&gt;&gt;();</span>

<span class="fc" id="L1303">                final TestSubscriber&lt;Flowable&lt;Object&gt;&gt; ts = new Flowable&lt;Object&gt;() {</span>
                    @Override
                    protected void subscribeActual(Subscriber&lt;? super Object&gt; subscriber) {
<span class="fc" id="L1306">                        subscriber.onSubscribe(new BooleanSubscription());</span>
<span class="fc" id="L1307">                        refMain.set(subscriber);</span>
<span class="fc" id="L1308">                    }</span>
                }
<span class="fc" id="L1310">                .window(new Callable&lt;Flowable&lt;Object&gt;&gt;() {</span>
                    int count;
                    @Override
                    public Flowable&lt;Object&gt; call() throws Exception {
<span class="fc bfc" id="L1314" title="All 2 branches covered.">                        if (++count &gt; 1) {</span>
<span class="fc" id="L1315">                            return Flowable.never();</span>
                        }
<span class="fc" id="L1317">                        return (new Flowable&lt;Object&gt;() {</span>
                            @Override
                            protected void subscribeActual(Subscriber&lt;? super Object&gt; subscriber) {
<span class="fc" id="L1320">                                final AtomicInteger counter = new AtomicInteger();</span>
<span class="fc" id="L1321">                                subscriber.onSubscribe(new Subscription() {</span>

                                    @Override
                                    public void cancel() {
                                        // about a microsecond
<span class="fc bfc" id="L1326" title="All 2 branches covered.">                                        for (int i = 0; i &lt; 100; i++) {</span>
<span class="fc" id="L1327">                                            counter.incrementAndGet();</span>
                                        }
<span class="fc" id="L1329">                                    }</span>

                                    @Override
                                    public void request(long n) {
<span class="fc" id="L1333">                                    }</span>
                                });
<span class="fc" id="L1335">                                ref.set(subscriber);</span>
<span class="fc" id="L1336">                            }</span>
                        });
                    }
                })
<span class="fc" id="L1340">                .test();</span>

<span class="fc" id="L1342">                Runnable r1 = new Runnable() {</span>
                    @Override
                    public void run() {
<span class="fc" id="L1345">                        ts.cancel();</span>
<span class="fc" id="L1346">                    }</span>
                };
<span class="fc" id="L1348">                Runnable r2 = new Runnable() {</span>
                    @Override
                    public void run() {
<span class="fc" id="L1351">                        Subscriber&lt;Object&gt; subscriber = ref.get();</span>
<span class="fc" id="L1352">                        subscriber.onNext(1);</span>
<span class="fc" id="L1353">                        subscriber.onError(ex);</span>
<span class="fc" id="L1354">                    }</span>
                };

<span class="fc" id="L1357">                TestHelper.race(r1, r2);</span>

<span class="pc bpc" id="L1359" title="1 of 2 branches missed.">                if (!errors.isEmpty()) {</span>
<span class="fc" id="L1360">                    TestHelper.assertUndeliverable(errors, 0, TestException.class);</span>
                }
            } finally {
<span class="fc" id="L1363">                RxJavaPlugins.reset();</span>
            }
        }
<span class="fc" id="L1366">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>