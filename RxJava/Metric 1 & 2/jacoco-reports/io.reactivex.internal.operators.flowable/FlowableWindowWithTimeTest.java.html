<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FlowableWindowWithTimeTest.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">RxJava_2_x$Unnamed.exec</a> &gt; <a href="index.source.html" class="el_package">io.reactivex.internal.operators.flowable</a> &gt; <span class="el_source">FlowableWindowWithTimeTest.java</span></div><h1>FlowableWindowWithTimeTest.java</h1><pre class="source lang-java linenums">/**
 * Copyright (c) 2016-present, RxJava Contributors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is
 * distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
 * the License for the specific language governing permissions and limitations under the License.
 */

package io.reactivex.internal.operators.flowable;

import static org.junit.Assert.*;

import java.util.*;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.*;

import org.junit.*;
import org.reactivestreams.*;

import io.reactivex.*;
import io.reactivex.exceptions.*;
import io.reactivex.functions.*;
import io.reactivex.internal.functions.Functions;
import io.reactivex.internal.subscriptions.BooleanSubscription;
import io.reactivex.plugins.RxJavaPlugins;
import io.reactivex.processors.*;
import io.reactivex.schedulers.*;
import io.reactivex.subscribers.*;

<span class="fc" id="L35">public class FlowableWindowWithTimeTest {</span>

    private TestScheduler scheduler;
    private Scheduler.Worker innerScheduler;

    @Before
    public void before() {
<span class="fc" id="L42">        scheduler = new TestScheduler();</span>
<span class="fc" id="L43">        innerScheduler = scheduler.createWorker();</span>
<span class="fc" id="L44">    }</span>

    @Test
    public void testTimedAndCount() {
<span class="fc" id="L48">        final List&lt;String&gt; list = new ArrayList&lt;String&gt;();</span>
<span class="fc" id="L49">        final List&lt;List&lt;String&gt;&gt; lists = new ArrayList&lt;List&lt;String&gt;&gt;();</span>

<span class="fc" id="L51">        Flowable&lt;String&gt; source = Flowable.unsafeCreate(new Publisher&lt;String&gt;() {</span>
            @Override
            public void subscribe(Subscriber&lt;? super String&gt; subscriber) {
<span class="fc" id="L54">                subscriber.onSubscribe(new BooleanSubscription());</span>
<span class="fc" id="L55">                push(subscriber, &quot;one&quot;, 10);</span>
<span class="fc" id="L56">                push(subscriber, &quot;two&quot;, 90);</span>
<span class="fc" id="L57">                push(subscriber, &quot;three&quot;, 110);</span>
<span class="fc" id="L58">                push(subscriber, &quot;four&quot;, 190);</span>
<span class="fc" id="L59">                push(subscriber, &quot;five&quot;, 210);</span>
<span class="fc" id="L60">                complete(subscriber, 250);</span>
<span class="fc" id="L61">            }</span>
        });

<span class="fc" id="L64">        Flowable&lt;Flowable&lt;String&gt;&gt; windowed = source.window(100, TimeUnit.MILLISECONDS, scheduler, 2);</span>
<span class="fc" id="L65">        windowed.subscribe(observeWindow(list, lists));</span>

<span class="fc" id="L67">        scheduler.advanceTimeTo(100, TimeUnit.MILLISECONDS);</span>
<span class="fc" id="L68">        assertEquals(1, lists.size());</span>
<span class="fc" id="L69">        assertEquals(lists.get(0), list(&quot;one&quot;, &quot;two&quot;));</span>

<span class="fc" id="L71">        scheduler.advanceTimeTo(200, TimeUnit.MILLISECONDS);</span>
<span class="fc" id="L72">        assertEquals(2, lists.size());</span>
<span class="fc" id="L73">        assertEquals(lists.get(1), list(&quot;three&quot;, &quot;four&quot;));</span>

<span class="fc" id="L75">        scheduler.advanceTimeTo(300, TimeUnit.MILLISECONDS);</span>
<span class="fc" id="L76">        assertEquals(3, lists.size());</span>
<span class="fc" id="L77">        assertEquals(lists.get(2), list(&quot;five&quot;));</span>
<span class="fc" id="L78">    }</span>

    @Test
    public void testTimed() {
<span class="fc" id="L82">        final List&lt;String&gt; list = new ArrayList&lt;String&gt;();</span>
<span class="fc" id="L83">        final List&lt;List&lt;String&gt;&gt; lists = new ArrayList&lt;List&lt;String&gt;&gt;();</span>

<span class="fc" id="L85">        Flowable&lt;String&gt; source = Flowable.unsafeCreate(new Publisher&lt;String&gt;() {</span>
            @Override
            public void subscribe(Subscriber&lt;? super String&gt; subscriber) {
<span class="fc" id="L88">                subscriber.onSubscribe(new BooleanSubscription());</span>
<span class="fc" id="L89">                push(subscriber, &quot;one&quot;, 98);</span>
<span class="fc" id="L90">                push(subscriber, &quot;two&quot;, 99);</span>
<span class="fc" id="L91">                push(subscriber, &quot;three&quot;, 99); // FIXME happens after the window is open</span>
<span class="fc" id="L92">                push(subscriber, &quot;four&quot;, 101);</span>
<span class="fc" id="L93">                push(subscriber, &quot;five&quot;, 102);</span>
<span class="fc" id="L94">                complete(subscriber, 150);</span>
<span class="fc" id="L95">            }</span>
        });

<span class="fc" id="L98">        Flowable&lt;Flowable&lt;String&gt;&gt; windowed = source.window(100, TimeUnit.MILLISECONDS, scheduler);</span>
<span class="fc" id="L99">        windowed.subscribe(observeWindow(list, lists));</span>

<span class="fc" id="L101">        scheduler.advanceTimeTo(101, TimeUnit.MILLISECONDS);</span>
<span class="fc" id="L102">        assertEquals(1, lists.size());</span>
<span class="fc" id="L103">        assertEquals(lists.get(0), list(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;));</span>

<span class="fc" id="L105">        scheduler.advanceTimeTo(201, TimeUnit.MILLISECONDS);</span>
<span class="fc" id="L106">        assertEquals(2, lists.size());</span>
<span class="fc" id="L107">        assertEquals(lists.get(1), list(&quot;four&quot;, &quot;five&quot;));</span>
<span class="fc" id="L108">    }</span>

    private List&lt;String&gt; list(String... args) {
<span class="fc" id="L111">        List&lt;String&gt; list = new ArrayList&lt;String&gt;();</span>
<span class="fc bfc" id="L112" title="All 2 branches covered.">        for (String arg : args) {</span>
<span class="fc" id="L113">            list.add(arg);</span>
        }
<span class="fc" id="L115">        return list;</span>
    }

    private &lt;T&gt; void push(final Subscriber&lt;T&gt; subscriber, final T value, int delay) {
<span class="fc" id="L119">        innerScheduler.schedule(new Runnable() {</span>
            @Override
            public void run() {
<span class="fc" id="L122">                subscriber.onNext(value);</span>
<span class="fc" id="L123">            }</span>
        }, delay, TimeUnit.MILLISECONDS);
<span class="fc" id="L125">    }</span>

    private void complete(final Subscriber&lt;?&gt; subscriber, int delay) {
<span class="fc" id="L128">        innerScheduler.schedule(new Runnable() {</span>
            @Override
            public void run() {
<span class="fc" id="L131">                subscriber.onComplete();</span>
<span class="fc" id="L132">            }</span>
        }, delay, TimeUnit.MILLISECONDS);
<span class="fc" id="L134">    }</span>

    private &lt;T&gt; Consumer&lt;Flowable&lt;T&gt;&gt; observeWindow(final List&lt;T&gt; list, final List&lt;List&lt;T&gt;&gt; lists) {
<span class="fc" id="L137">        return new Consumer&lt;Flowable&lt;T&gt;&gt;() {</span>
            @Override
            public void accept(Flowable&lt;T&gt; stringFlowable) {
<span class="fc" id="L140">                stringFlowable.subscribe(new DefaultSubscriber&lt;T&gt;() {</span>
                    @Override
                    public void onComplete() {
<span class="fc" id="L143">                        lists.add(new ArrayList&lt;T&gt;(list));</span>
<span class="fc" id="L144">                        list.clear();</span>
<span class="fc" id="L145">                    }</span>

                    @Override
                    public void onError(Throwable e) {
<span class="nc" id="L149">                        Assert.fail(e.getMessage());</span>
<span class="nc" id="L150">                    }</span>

                    @Override
                    public void onNext(T args) {
<span class="fc" id="L154">                        list.add(args);</span>
<span class="fc" id="L155">                    }</span>
                });
<span class="fc" id="L157">            }</span>
        };
    }

    @Test
    public void testExactWindowSize() {
<span class="fc" id="L163">        Flowable&lt;Flowable&lt;Integer&gt;&gt; source = Flowable.range(1, 10)</span>
<span class="fc" id="L164">                .window(1, TimeUnit.MINUTES, scheduler, 3);</span>

<span class="fc" id="L166">        final List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</span>
<span class="fc" id="L167">        final List&lt;List&lt;Integer&gt;&gt; lists = new ArrayList&lt;List&lt;Integer&gt;&gt;();</span>

<span class="fc" id="L169">        source.subscribe(observeWindow(list, lists));</span>

<span class="fc" id="L171">        assertEquals(4, lists.size());</span>
<span class="fc" id="L172">        assertEquals(3, lists.get(0).size());</span>
<span class="fc" id="L173">        assertEquals(Arrays.asList(1, 2, 3), lists.get(0));</span>
<span class="fc" id="L174">        assertEquals(3, lists.get(1).size());</span>
<span class="fc" id="L175">        assertEquals(Arrays.asList(4, 5, 6), lists.get(1));</span>
<span class="fc" id="L176">        assertEquals(3, lists.get(2).size());</span>
<span class="fc" id="L177">        assertEquals(Arrays.asList(7, 8, 9), lists.get(2));</span>
<span class="fc" id="L178">        assertEquals(1, lists.get(3).size());</span>
<span class="fc" id="L179">        assertEquals(Arrays.asList(10), lists.get(3));</span>
<span class="fc" id="L180">    }</span>

    @Test
    public void testTakeFlatMapCompletes() {
<span class="fc" id="L184">        TestSubscriber&lt;Integer&gt; ts = new TestSubscriber&lt;Integer&gt;();</span>

<span class="fc" id="L186">        final AtomicInteger wip = new AtomicInteger();</span>

<span class="fc" id="L188">        final int indicator = 999999999;</span>

<span class="fc" id="L190">        FlowableWindowWithSizeTest.hotStream()</span>
<span class="fc" id="L191">        .window(300, TimeUnit.MILLISECONDS)</span>
<span class="fc" id="L192">        .take(10)</span>
<span class="fc" id="L193">        .doOnComplete(new Action() {</span>
            @Override
            public void run() {
<span class="fc" id="L196">                System.out.println(&quot;Main done!&quot;);</span>
<span class="fc" id="L197">            }</span>
        })
<span class="fc" id="L199">        .flatMap(new Function&lt;Flowable&lt;Integer&gt;, Flowable&lt;Integer&gt;&gt;() {</span>
            @Override
            public Flowable&lt;Integer&gt; apply(Flowable&lt;Integer&gt; w) {
<span class="fc" id="L202">                return w.startWith(indicator)</span>
<span class="fc" id="L203">                        .doOnComplete(new Action() {</span>
                            @Override
                            public void run() {
<span class="fc" id="L206">                                System.out.println(&quot;inner done: &quot; + wip.incrementAndGet());</span>
<span class="fc" id="L207">                            }</span>
                        })
                        ;
            }
        })
<span class="fc" id="L212">        .doOnNext(new Consumer&lt;Integer&gt;() {</span>
            @Override
            public void accept(Integer pv) {
<span class="fc" id="L215">                System.out.println(pv);</span>
<span class="fc" id="L216">            }</span>
        })
<span class="fc" id="L218">        .subscribe(ts);</span>

<span class="fc" id="L220">        ts.awaitTerminalEvent(5, TimeUnit.SECONDS);</span>
<span class="fc" id="L221">        ts.assertComplete();</span>
<span class="pc bpc" id="L222" title="1 of 2 branches missed.">        Assert.assertTrue(ts.valueCount() != 0);</span>
<span class="fc" id="L223">    }</span>

    @Test
    public void timespanTimeskipCustomSchedulerBufferSize() {
<span class="fc" id="L227">        Flowable.range(1, 10)</span>
<span class="fc" id="L228">        .window(1, 1, TimeUnit.MINUTES, Schedulers.io(), 2)</span>
<span class="fc" id="L229">        .flatMap(Functions.&lt;Flowable&lt;Integer&gt;&gt;identity())</span>
<span class="fc" id="L230">        .test()</span>
<span class="fc" id="L231">        .awaitDone(5, TimeUnit.SECONDS)</span>
<span class="fc" id="L232">        .assertResult(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);</span>
<span class="fc" id="L233">    }</span>

    @Test
    public void timespanDefaultSchedulerSize() {
<span class="fc" id="L237">        Flowable.range(1, 10)</span>
<span class="fc" id="L238">        .window(1, TimeUnit.MINUTES, 20)</span>
<span class="fc" id="L239">        .flatMap(Functions.&lt;Flowable&lt;Integer&gt;&gt;identity())</span>
<span class="fc" id="L240">        .test()</span>
<span class="fc" id="L241">        .awaitDone(5, TimeUnit.SECONDS)</span>
<span class="fc" id="L242">        .assertResult(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);</span>
<span class="fc" id="L243">    }</span>

    @Test
    public void timespanDefaultSchedulerSizeRestart() {
<span class="fc" id="L247">        Flowable.range(1, 10)</span>
<span class="fc" id="L248">        .window(1, TimeUnit.MINUTES, 20, true)</span>
<span class="fc" id="L249">        .flatMap(Functions.&lt;Flowable&lt;Integer&gt;&gt;identity(), true)</span>
<span class="fc" id="L250">        .test()</span>
<span class="fc" id="L251">        .awaitDone(5, TimeUnit.SECONDS)</span>
<span class="fc" id="L252">        .assertResult(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);</span>
<span class="fc" id="L253">    }</span>

    @Test
    public void invalidSpan() {
        try {
<span class="nc" id="L258">            Flowable.just(1).window(-99, 1, TimeUnit.SECONDS);</span>
<span class="nc" id="L259">            fail(&quot;Should have thrown!&quot;);</span>
<span class="fc" id="L260">        } catch (IllegalArgumentException ex) {</span>
<span class="fc" id="L261">            assertEquals(&quot;timespan &gt; 0 required but it was -99&quot;, ex.getMessage());</span>
<span class="nc" id="L262">        }</span>
<span class="fc" id="L263">    }</span>

    @Test
    public void timespanTimeskipDefaultScheduler() {
<span class="fc" id="L267">        Flowable.just(1)</span>
<span class="fc" id="L268">        .window(1, 1, TimeUnit.MINUTES)</span>
<span class="fc" id="L269">        .flatMap(Functions.&lt;Flowable&lt;Integer&gt;&gt;identity())</span>
<span class="fc" id="L270">        .test()</span>
<span class="fc" id="L271">        .awaitDone(5, TimeUnit.SECONDS)</span>
<span class="fc" id="L272">        .assertResult(1);</span>
<span class="fc" id="L273">    }</span>

    @Test
    public void timespanTimeskipCustomScheduler() {
<span class="fc" id="L277">        Flowable.just(1)</span>
<span class="fc" id="L278">        .window(1, 1, TimeUnit.MINUTES, Schedulers.io())</span>
<span class="fc" id="L279">        .flatMap(Functions.&lt;Flowable&lt;Integer&gt;&gt;identity())</span>
<span class="fc" id="L280">        .test()</span>
<span class="fc" id="L281">        .awaitDone(5, TimeUnit.SECONDS)</span>
<span class="fc" id="L282">        .assertResult(1);</span>
<span class="fc" id="L283">    }</span>

    @Test
    public void timeskipJustOverlap() {
<span class="fc" id="L287">        Flowable.just(1)</span>
<span class="fc" id="L288">        .window(2, 1, TimeUnit.MINUTES, Schedulers.single())</span>
<span class="fc" id="L289">        .flatMap(Functions.&lt;Flowable&lt;Integer&gt;&gt;identity())</span>
<span class="fc" id="L290">        .test()</span>
<span class="fc" id="L291">        .awaitDone(5, TimeUnit.SECONDS)</span>
<span class="fc" id="L292">        .assertResult(1);</span>
<span class="fc" id="L293">    }</span>

    @Test
    public void timeskipJustSkip() {
<span class="fc" id="L297">        Flowable.just(1)</span>
<span class="fc" id="L298">        .window(1, 2, TimeUnit.MINUTES, Schedulers.single())</span>
<span class="fc" id="L299">        .flatMap(Functions.&lt;Flowable&lt;Integer&gt;&gt;identity())</span>
<span class="fc" id="L300">        .test()</span>
<span class="fc" id="L301">        .awaitDone(5, TimeUnit.SECONDS)</span>
<span class="fc" id="L302">        .assertResult(1);</span>
<span class="fc" id="L303">    }</span>

    @Test
    public void timeskipSkipping() {
<span class="fc" id="L307">        TestScheduler scheduler = new TestScheduler();</span>

<span class="fc" id="L309">        PublishProcessor&lt;Integer&gt; pp = PublishProcessor.create();</span>

<span class="fc" id="L311">        TestSubscriber&lt;Integer&gt; ts = pp.window(1, 2, TimeUnit.SECONDS, scheduler)</span>
<span class="fc" id="L312">        .flatMap(Functions.&lt;Flowable&lt;Integer&gt;&gt;identity())</span>
<span class="fc" id="L313">        .test();</span>

<span class="fc" id="L315">        pp.onNext(1);</span>
<span class="fc" id="L316">        pp.onNext(2);</span>

<span class="fc" id="L318">        scheduler.advanceTimeBy(1, TimeUnit.SECONDS);</span>

<span class="fc" id="L320">        pp.onNext(3);</span>
<span class="fc" id="L321">        pp.onNext(4);</span>

<span class="fc" id="L323">        scheduler.advanceTimeBy(1, TimeUnit.SECONDS);</span>

<span class="fc" id="L325">        pp.onNext(5);</span>
<span class="fc" id="L326">        pp.onNext(6);</span>

<span class="fc" id="L328">        scheduler.advanceTimeBy(1, TimeUnit.SECONDS);</span>

<span class="fc" id="L330">        pp.onNext(7);</span>
<span class="fc" id="L331">        pp.onComplete();</span>

<span class="fc" id="L333">        ts.assertResult(1, 2, 5, 6);</span>
<span class="fc" id="L334">    }</span>

    @Test
    public void timeskipOverlapping() {
<span class="fc" id="L338">        TestScheduler scheduler = new TestScheduler();</span>

<span class="fc" id="L340">        PublishProcessor&lt;Integer&gt; pp = PublishProcessor.create();</span>

<span class="fc" id="L342">        TestSubscriber&lt;Integer&gt; ts = pp.window(2, 1, TimeUnit.SECONDS, scheduler)</span>
<span class="fc" id="L343">        .flatMap(Functions.&lt;Flowable&lt;Integer&gt;&gt;identity())</span>
<span class="fc" id="L344">        .test();</span>

<span class="fc" id="L346">        pp.onNext(1);</span>
<span class="fc" id="L347">        pp.onNext(2);</span>

<span class="fc" id="L349">        scheduler.advanceTimeBy(1, TimeUnit.SECONDS);</span>

<span class="fc" id="L351">        pp.onNext(3);</span>
<span class="fc" id="L352">        pp.onNext(4);</span>

<span class="fc" id="L354">        scheduler.advanceTimeBy(1, TimeUnit.SECONDS);</span>

<span class="fc" id="L356">        pp.onNext(5);</span>
<span class="fc" id="L357">        pp.onNext(6);</span>

<span class="fc" id="L359">        scheduler.advanceTimeBy(1, TimeUnit.SECONDS);</span>

<span class="fc" id="L361">        pp.onNext(7);</span>
<span class="fc" id="L362">        pp.onComplete();</span>

<span class="fc" id="L364">        ts.assertResult(1, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7);</span>
<span class="fc" id="L365">    }</span>

    @Test
    public void exactOnError() {
<span class="fc" id="L369">        List&lt;Throwable&gt; errors = TestHelper.trackPluginErrors();</span>
        try {
<span class="fc" id="L371">            TestScheduler scheduler = new TestScheduler();</span>

<span class="fc" id="L373">            PublishProcessor&lt;Integer&gt; pp = PublishProcessor.create();</span>

<span class="fc" id="L375">            TestSubscriber&lt;Integer&gt; ts = pp.window(1, 1, TimeUnit.SECONDS, scheduler)</span>
<span class="fc" id="L376">            .flatMap(Functions.&lt;Flowable&lt;Integer&gt;&gt;identity())</span>
<span class="fc" id="L377">            .test();</span>

<span class="fc" id="L379">            pp.onError(new TestException());</span>

<span class="fc" id="L381">            ts.assertFailure(TestException.class);</span>

<span class="fc" id="L383">            TestHelper.assertUndeliverable(errors, 0, TestException.class);</span>
        } finally {
<span class="fc" id="L385">            RxJavaPlugins.reset();</span>
        }
<span class="fc" id="L387">    }</span>

    @Test
    public void overlappingOnError() {
<span class="fc" id="L391">        List&lt;Throwable&gt; errors = TestHelper.trackPluginErrors();</span>
        try {
<span class="fc" id="L393">            TestScheduler scheduler = new TestScheduler();</span>

<span class="fc" id="L395">            PublishProcessor&lt;Integer&gt; pp = PublishProcessor.create();</span>

<span class="fc" id="L397">            TestSubscriber&lt;Integer&gt; ts = pp.window(2, 1, TimeUnit.SECONDS, scheduler)</span>
<span class="fc" id="L398">            .flatMap(Functions.&lt;Flowable&lt;Integer&gt;&gt;identity())</span>
<span class="fc" id="L399">            .test();</span>

<span class="fc" id="L401">            pp.onError(new TestException());</span>

<span class="fc" id="L403">            ts.assertFailure(TestException.class);</span>

<span class="fc" id="L405">            TestHelper.assertUndeliverable(errors, 0, TestException.class);</span>
        } finally {
<span class="fc" id="L407">            RxJavaPlugins.reset();</span>
        }
<span class="fc" id="L409">    }</span>

    @Test
    public void skipOnError() {
<span class="fc" id="L413">        List&lt;Throwable&gt; errors = TestHelper.trackPluginErrors();</span>
        try {
<span class="fc" id="L415">            TestScheduler scheduler = new TestScheduler();</span>

<span class="fc" id="L417">            PublishProcessor&lt;Integer&gt; pp = PublishProcessor.create();</span>

<span class="fc" id="L419">            TestSubscriber&lt;Integer&gt; ts = pp.window(1, 2, TimeUnit.SECONDS, scheduler)</span>
<span class="fc" id="L420">            .flatMap(Functions.&lt;Flowable&lt;Integer&gt;&gt;identity())</span>
<span class="fc" id="L421">            .test();</span>

<span class="fc" id="L423">            pp.onError(new TestException());</span>

<span class="fc" id="L425">            ts.assertFailure(TestException.class);</span>

<span class="fc" id="L427">            TestHelper.assertUndeliverable(errors, 0, TestException.class);</span>
        } finally {
<span class="fc" id="L429">            RxJavaPlugins.reset();</span>
        }
<span class="fc" id="L431">    }</span>

    @Test
    @SuppressWarnings(&quot;unchecked&quot;)
    public void exactBackpressure() {
<span class="fc" id="L436">        TestScheduler scheduler = new TestScheduler();</span>

<span class="fc" id="L438">        PublishProcessor&lt;Integer&gt; pp = PublishProcessor.create();</span>

<span class="fc" id="L440">        TestSubscriber&lt;Flowable&lt;Integer&gt;&gt; ts = pp.window(1, 1, TimeUnit.SECONDS, scheduler)</span>
<span class="fc" id="L441">        .test(0L);</span>

<span class="fc" id="L443">        scheduler.advanceTimeBy(1, TimeUnit.SECONDS);</span>

<span class="fc" id="L445">        ts.assertFailure(MissingBackpressureException.class);</span>
<span class="fc" id="L446">    }</span>

    @Test
    @SuppressWarnings(&quot;unchecked&quot;)
    public void skipBackpressure() {
<span class="fc" id="L451">        TestScheduler scheduler = new TestScheduler();</span>

<span class="fc" id="L453">        PublishProcessor&lt;Integer&gt; pp = PublishProcessor.create();</span>

<span class="fc" id="L455">        TestSubscriber&lt;Flowable&lt;Integer&gt;&gt; ts = pp.window(1, 2, TimeUnit.SECONDS, scheduler)</span>
<span class="fc" id="L456">        .test(0L);</span>

<span class="fc" id="L458">        scheduler.advanceTimeBy(1, TimeUnit.SECONDS);</span>

<span class="fc" id="L460">        ts.assertFailure(MissingBackpressureException.class);</span>
<span class="fc" id="L461">    }</span>

    @Test
    @SuppressWarnings(&quot;unchecked&quot;)
    public void overlapBackpressure() {
<span class="fc" id="L466">        TestScheduler scheduler = new TestScheduler();</span>

<span class="fc" id="L468">        PublishProcessor&lt;Integer&gt; pp = PublishProcessor.create();</span>

<span class="fc" id="L470">        TestSubscriber&lt;Flowable&lt;Integer&gt;&gt; ts = pp.window(2, 1, TimeUnit.SECONDS, scheduler)</span>
<span class="fc" id="L471">        .test(0L);</span>

<span class="fc" id="L473">        scheduler.advanceTimeBy(1, TimeUnit.SECONDS);</span>

<span class="fc" id="L475">        ts.assertFailure(MissingBackpressureException.class);</span>
<span class="fc" id="L476">    }</span>

    @Test
    public void exactBackpressure2() {
<span class="fc" id="L480">        TestScheduler scheduler = new TestScheduler();</span>

<span class="fc" id="L482">        PublishProcessor&lt;Integer&gt; pp = PublishProcessor.create();</span>

<span class="fc" id="L484">        TestSubscriber&lt;Flowable&lt;Integer&gt;&gt; ts = pp.window(1, 1, TimeUnit.SECONDS, scheduler)</span>
<span class="fc" id="L485">        .test(1L);</span>

<span class="fc" id="L487">        scheduler.advanceTimeBy(2, TimeUnit.SECONDS);</span>

<span class="fc" id="L489">        ts.assertError(MissingBackpressureException.class);</span>
<span class="fc" id="L490">    }</span>

    @Test
    public void skipBackpressure2() {
<span class="fc" id="L494">        TestScheduler scheduler = new TestScheduler();</span>

<span class="fc" id="L496">        PublishProcessor&lt;Integer&gt; pp = PublishProcessor.create();</span>

<span class="fc" id="L498">        TestSubscriber&lt;Flowable&lt;Integer&gt;&gt; ts = pp.window(1, 2, TimeUnit.SECONDS, scheduler)</span>
<span class="fc" id="L499">        .test(1L);</span>

<span class="fc" id="L501">        scheduler.advanceTimeBy(2, TimeUnit.SECONDS);</span>

<span class="fc" id="L503">        ts.assertError(MissingBackpressureException.class);</span>
<span class="fc" id="L504">    }</span>

    @Test
    public void overlapBackpressure2() {
<span class="fc" id="L508">        List&lt;Throwable&gt; errors = TestHelper.trackPluginErrors();</span>
        try {
<span class="fc" id="L510">            TestScheduler scheduler = new TestScheduler();</span>

<span class="fc" id="L512">            PublishProcessor&lt;Integer&gt; pp = PublishProcessor.create();</span>

<span class="fc" id="L514">            TestSubscriber&lt;Flowable&lt;Integer&gt;&gt; ts = pp.window(2, 1, TimeUnit.SECONDS, scheduler)</span>
<span class="fc" id="L515">            .test(1L);</span>

<span class="fc" id="L517">            scheduler.advanceTimeBy(2, TimeUnit.SECONDS);</span>

<span class="fc" id="L519">            ts.assertError(MissingBackpressureException.class);</span>

<span class="fc" id="L521">            TestHelper.assertError(errors, 0, MissingBackpressureException.class);</span>
        } finally {
<span class="fc" id="L523">            RxJavaPlugins.reset();</span>
        }
<span class="fc" id="L525">    }</span>

    @Test
    public void dispose() {
<span class="fc" id="L529">        TestHelper.checkDisposed(Flowable.range(1, 5).window(1, TimeUnit.DAYS, Schedulers.single()).onBackpressureDrop());</span>

<span class="fc" id="L531">        TestHelper.checkDisposed(Flowable.range(1, 5).window(2, 1, TimeUnit.DAYS, Schedulers.single()).onBackpressureDrop());</span>

<span class="fc" id="L533">        TestHelper.checkDisposed(Flowable.range(1, 5).window(1, 2, TimeUnit.DAYS, Schedulers.single()).onBackpressureDrop());</span>

<span class="fc" id="L535">        TestHelper.checkDisposed(Flowable.never()</span>
<span class="fc" id="L536">                .window(1, TimeUnit.DAYS, Schedulers.single(), 2, true).onBackpressureDrop());</span>
<span class="fc" id="L537">    }</span>

    @Test
    public void restartTimer() {
<span class="fc" id="L541">        Flowable.range(1, 5)</span>
<span class="fc" id="L542">        .window(1, TimeUnit.DAYS, Schedulers.single(), 2, true)</span>
<span class="fc" id="L543">        .flatMap(Functions.&lt;Flowable&lt;Integer&gt;&gt;identity())</span>
<span class="fc" id="L544">        .test()</span>
<span class="fc" id="L545">        .assertResult(1, 2, 3, 4, 5);</span>
<span class="fc" id="L546">    }</span>

    @Test
    public void exactBoundaryError() {
<span class="fc" id="L550">        Flowable.error(new TestException())</span>
<span class="fc" id="L551">        .window(1, TimeUnit.DAYS, Schedulers.single(), 2, true)</span>
<span class="fc" id="L552">        .test()</span>
<span class="fc" id="L553">        .assertSubscribed()</span>
<span class="fc" id="L554">        .assertError(TestException.class)</span>
<span class="fc" id="L555">        .assertNotComplete();</span>
<span class="fc" id="L556">    }</span>

    @Test
    public void restartTimerMany() throws Exception {
<span class="fc" id="L560">        final AtomicBoolean cancel1 = new AtomicBoolean();</span>
<span class="fc" id="L561">        Flowable.intervalRange(1, 1000, 1, 1, TimeUnit.MILLISECONDS)</span>
<span class="fc" id="L562">        .doOnCancel(new Action() {</span>
            @Override
            public void run() throws Exception {
<span class="fc" id="L565">                cancel1.set(true);</span>
<span class="fc" id="L566">            }</span>
        })
<span class="fc" id="L568">        .window(1, TimeUnit.MILLISECONDS, Schedulers.single(), 2, true)</span>
<span class="fc" id="L569">        .flatMap(Functions.&lt;Flowable&lt;Long&gt;&gt;identity())</span>
<span class="fc" id="L570">        .take(500)</span>
<span class="fc" id="L571">        .test()</span>
<span class="fc" id="L572">        .awaitDone(5, TimeUnit.SECONDS)</span>
<span class="fc" id="L573">        .assertSubscribed()</span>
<span class="fc" id="L574">        .assertValueCount(500)</span>
<span class="fc" id="L575">        .assertNoErrors()</span>
<span class="fc" id="L576">        .assertComplete();</span>

<span class="fc" id="L578">        int timeout = 20;</span>
<span class="pc bpc" id="L579" title="1 of 4 branches missed.">        while (timeout-- &gt; 0 &amp;&amp; !cancel1.get()) {</span>
<span class="fc" id="L580">            Thread.sleep(100);</span>
        }

<span class="fc" id="L583">        assertTrue(&quot;intervalRange was not cancelled!&quot;, cancel1.get());</span>
<span class="fc" id="L584">    }</span>

    @Test
    public void exactUnboundedReentrant() {
<span class="fc" id="L588">        TestScheduler scheduler = new TestScheduler();</span>

<span class="fc" id="L590">        final FlowableProcessor&lt;Integer&gt; ps = PublishProcessor.&lt;Integer&gt;create();</span>

<span class="fc" id="L592">        TestSubscriber&lt;Integer&gt; ts = new TestSubscriber&lt;Integer&gt;() {</span>
            @Override
            public void onNext(Integer t) {
<span class="fc" id="L595">                super.onNext(t);</span>
<span class="fc bfc" id="L596" title="All 2 branches covered.">                if (t == 1) {</span>
<span class="fc" id="L597">                    ps.onNext(2);</span>
<span class="fc" id="L598">                    ps.onComplete();</span>
                }
<span class="fc" id="L600">            }</span>
        };

<span class="fc" id="L603">        ps.window(1, TimeUnit.MILLISECONDS, scheduler)</span>
<span class="fc" id="L604">        .flatMap(new Function&lt;Flowable&lt;Integer&gt;, Flowable&lt;Integer&gt;&gt;() {</span>
            @Override
            public Flowable&lt;Integer&gt; apply(Flowable&lt;Integer&gt; v) throws Exception {
<span class="fc" id="L607">                return v;</span>
            }
        })
<span class="fc" id="L610">        .subscribe(ts);</span>

<span class="fc" id="L612">        ps.onNext(1);</span>

<span class="fc" id="L614">        ts</span>
<span class="fc" id="L615">        .awaitDone(1, TimeUnit.SECONDS)</span>
<span class="fc" id="L616">        .assertResult(1, 2);</span>
<span class="fc" id="L617">    }</span>

    @Test
    public void exactBoundedReentrant() {
<span class="fc" id="L621">        TestScheduler scheduler = new TestScheduler();</span>

<span class="fc" id="L623">        final FlowableProcessor&lt;Integer&gt; ps = PublishProcessor.&lt;Integer&gt;create();</span>

<span class="fc" id="L625">        TestSubscriber&lt;Integer&gt; ts = new TestSubscriber&lt;Integer&gt;() {</span>
            @Override
            public void onNext(Integer t) {
<span class="fc" id="L628">                super.onNext(t);</span>
<span class="fc bfc" id="L629" title="All 2 branches covered.">                if (t == 1) {</span>
<span class="fc" id="L630">                    ps.onNext(2);</span>
<span class="fc" id="L631">                    ps.onComplete();</span>
                }
<span class="fc" id="L633">            }</span>
        };

<span class="fc" id="L636">        ps.window(1, TimeUnit.MILLISECONDS, scheduler, 10, true)</span>
<span class="fc" id="L637">        .flatMap(new Function&lt;Flowable&lt;Integer&gt;, Flowable&lt;Integer&gt;&gt;() {</span>
            @Override
            public Flowable&lt;Integer&gt; apply(Flowable&lt;Integer&gt; v) throws Exception {
<span class="fc" id="L640">                return v;</span>
            }
        })
<span class="fc" id="L643">        .subscribe(ts);</span>

<span class="fc" id="L645">        ps.onNext(1);</span>

<span class="fc" id="L647">        ts</span>
<span class="fc" id="L648">        .awaitDone(1, TimeUnit.SECONDS)</span>
<span class="fc" id="L649">        .assertResult(1, 2);</span>
<span class="fc" id="L650">    }</span>

    @Test
    public void exactBoundedReentrant2() {
<span class="fc" id="L654">        TestScheduler scheduler = new TestScheduler();</span>

<span class="fc" id="L656">        final FlowableProcessor&lt;Integer&gt; ps = PublishProcessor.&lt;Integer&gt;create();</span>

<span class="fc" id="L658">        TestSubscriber&lt;Integer&gt; ts = new TestSubscriber&lt;Integer&gt;() {</span>
            @Override
            public void onNext(Integer t) {
<span class="fc" id="L661">                super.onNext(t);</span>
<span class="fc bfc" id="L662" title="All 2 branches covered.">                if (t == 1) {</span>
<span class="fc" id="L663">                    ps.onNext(2);</span>
<span class="fc" id="L664">                    ps.onComplete();</span>
                }
<span class="fc" id="L666">            }</span>
        };

<span class="fc" id="L669">        ps.window(1, TimeUnit.MILLISECONDS, scheduler, 2, true)</span>
<span class="fc" id="L670">        .flatMap(new Function&lt;Flowable&lt;Integer&gt;, Flowable&lt;Integer&gt;&gt;() {</span>
            @Override
            public Flowable&lt;Integer&gt; apply(Flowable&lt;Integer&gt; v) throws Exception {
<span class="fc" id="L673">                return v;</span>
            }
        })
<span class="fc" id="L676">        .subscribe(ts);</span>

<span class="fc" id="L678">        ps.onNext(1);</span>

<span class="fc" id="L680">        ts</span>
<span class="fc" id="L681">        .awaitDone(1, TimeUnit.SECONDS)</span>
<span class="fc" id="L682">        .assertResult(1, 2);</span>
<span class="fc" id="L683">    }</span>

    @Test
    public void skipReentrant() {
<span class="fc" id="L687">        TestScheduler scheduler = new TestScheduler();</span>

<span class="fc" id="L689">        final FlowableProcessor&lt;Integer&gt; ps = PublishProcessor.&lt;Integer&gt;create();</span>

<span class="fc" id="L691">        TestSubscriber&lt;Integer&gt; ts = new TestSubscriber&lt;Integer&gt;() {</span>
            @Override
            public void onNext(Integer t) {
<span class="fc" id="L694">                super.onNext(t);</span>
<span class="fc bfc" id="L695" title="All 2 branches covered.">                if (t == 1) {</span>
<span class="fc" id="L696">                    ps.onNext(2);</span>
<span class="fc" id="L697">                    ps.onComplete();</span>
                }
<span class="fc" id="L699">            }</span>
        };

<span class="fc" id="L702">        ps.window(1, 2, TimeUnit.MILLISECONDS, scheduler)</span>
<span class="fc" id="L703">        .flatMap(new Function&lt;Flowable&lt;Integer&gt;, Flowable&lt;Integer&gt;&gt;() {</span>
            @Override
            public Flowable&lt;Integer&gt; apply(Flowable&lt;Integer&gt; v) throws Exception {
<span class="fc" id="L706">                return v;</span>
            }
        })
<span class="fc" id="L709">        .subscribe(ts);</span>

<span class="fc" id="L711">        ps.onNext(1);</span>

<span class="fc" id="L713">        ts</span>
<span class="fc" id="L714">        .awaitDone(1, TimeUnit.SECONDS)</span>
<span class="fc" id="L715">        .assertResult(1, 2);</span>
<span class="fc" id="L716">    }</span>

    @Test
    public void sizeTimeTimeout() {
<span class="fc" id="L720">        TestScheduler scheduler = new TestScheduler();</span>
<span class="fc" id="L721">        PublishProcessor&lt;Integer&gt; pp = PublishProcessor.&lt;Integer&gt;create();</span>

<span class="fc" id="L723">        TestSubscriber&lt;Flowable&lt;Integer&gt;&gt; ts = pp.window(5, TimeUnit.MILLISECONDS, scheduler, 100)</span>
<span class="fc" id="L724">        .test()</span>
<span class="fc" id="L725">        .assertValueCount(1);</span>

<span class="fc" id="L727">        scheduler.advanceTimeBy(5, TimeUnit.MILLISECONDS);</span>

<span class="fc" id="L729">        ts.assertValueCount(2)</span>
<span class="fc" id="L730">        .assertNoErrors()</span>
<span class="fc" id="L731">        .assertNotComplete();</span>

<span class="fc" id="L733">        ts.values().get(0).test().assertResult();</span>
<span class="fc" id="L734">    }</span>

    @Test
    public void periodicWindowCompletion() {
<span class="fc" id="L738">        TestScheduler scheduler = new TestScheduler();</span>
<span class="fc" id="L739">        FlowableProcessor&lt;Integer&gt; ps = PublishProcessor.&lt;Integer&gt;create();</span>

<span class="fc" id="L741">        TestSubscriber&lt;Flowable&lt;Integer&gt;&gt; ts = ps.window(5, TimeUnit.MILLISECONDS, scheduler, Long.MAX_VALUE, false)</span>
<span class="fc" id="L742">        .test();</span>

<span class="fc" id="L744">        scheduler.advanceTimeBy(100, TimeUnit.MILLISECONDS);</span>

<span class="fc" id="L746">        ts.assertValueCount(21)</span>
<span class="fc" id="L747">        .assertNoErrors()</span>
<span class="fc" id="L748">        .assertNotComplete();</span>
<span class="fc" id="L749">    }</span>

    @Test
    public void periodicWindowCompletionRestartTimer() {
<span class="fc" id="L753">        TestScheduler scheduler = new TestScheduler();</span>
<span class="fc" id="L754">        FlowableProcessor&lt;Integer&gt; ps = PublishProcessor.&lt;Integer&gt;create();</span>

<span class="fc" id="L756">        TestSubscriber&lt;Flowable&lt;Integer&gt;&gt; ts = ps.window(5, TimeUnit.MILLISECONDS, scheduler, Long.MAX_VALUE, true)</span>
<span class="fc" id="L757">        .test();</span>

<span class="fc" id="L759">        scheduler.advanceTimeBy(100, TimeUnit.MILLISECONDS);</span>

<span class="fc" id="L761">        ts.assertValueCount(21)</span>
<span class="fc" id="L762">        .assertNoErrors()</span>
<span class="fc" id="L763">        .assertNotComplete();</span>
<span class="fc" id="L764">    }</span>

    @Test
    public void periodicWindowCompletionBounded() {
<span class="fc" id="L768">        TestScheduler scheduler = new TestScheduler();</span>
<span class="fc" id="L769">        FlowableProcessor&lt;Integer&gt; ps = PublishProcessor.&lt;Integer&gt;create();</span>

<span class="fc" id="L771">        TestSubscriber&lt;Flowable&lt;Integer&gt;&gt; ts = ps.window(5, TimeUnit.MILLISECONDS, scheduler, 5, false)</span>
<span class="fc" id="L772">        .test();</span>

<span class="fc" id="L774">        scheduler.advanceTimeBy(100, TimeUnit.MILLISECONDS);</span>

<span class="fc" id="L776">        ts.assertValueCount(21)</span>
<span class="fc" id="L777">        .assertNoErrors()</span>
<span class="fc" id="L778">        .assertNotComplete();</span>
<span class="fc" id="L779">    }</span>

    @Test
    public void periodicWindowCompletionRestartTimerBounded() {
<span class="fc" id="L783">        TestScheduler scheduler = new TestScheduler();</span>
<span class="fc" id="L784">        FlowableProcessor&lt;Integer&gt; ps = PublishProcessor.&lt;Integer&gt;create();</span>

<span class="fc" id="L786">        TestSubscriber&lt;Flowable&lt;Integer&gt;&gt; ts = ps.window(5, TimeUnit.MILLISECONDS, scheduler, 5, true)</span>
<span class="fc" id="L787">        .test();</span>

<span class="fc" id="L789">        scheduler.advanceTimeBy(100, TimeUnit.MILLISECONDS);</span>

<span class="fc" id="L791">        ts.assertValueCount(21)</span>
<span class="fc" id="L792">        .assertNoErrors()</span>
<span class="fc" id="L793">        .assertNotComplete();</span>
<span class="fc" id="L794">    }</span>

    @Test
    public void periodicWindowCompletionRestartTimerBoundedSomeData() {
<span class="fc" id="L798">        TestScheduler scheduler = new TestScheduler();</span>
<span class="fc" id="L799">        FlowableProcessor&lt;Integer&gt; ps = PublishProcessor.&lt;Integer&gt;create();</span>

<span class="fc" id="L801">        TestSubscriber&lt;Flowable&lt;Integer&gt;&gt; ts = ps.window(5, TimeUnit.MILLISECONDS, scheduler, 2, true)</span>
<span class="fc" id="L802">        .test();</span>

<span class="fc" id="L804">        ps.onNext(1);</span>
<span class="fc" id="L805">        ps.onNext(2);</span>

<span class="fc" id="L807">        scheduler.advanceTimeBy(100, TimeUnit.MILLISECONDS);</span>

<span class="fc" id="L809">        ts.assertValueCount(22)</span>
<span class="fc" id="L810">        .assertNoErrors()</span>
<span class="fc" id="L811">        .assertNotComplete();</span>
<span class="fc" id="L812">    }</span>

    @Test
    public void countRestartsOnTimeTick() {
<span class="fc" id="L816">        TestScheduler scheduler = new TestScheduler();</span>
<span class="fc" id="L817">        FlowableProcessor&lt;Integer&gt; ps = PublishProcessor.&lt;Integer&gt;create();</span>

<span class="fc" id="L819">        TestSubscriber&lt;Flowable&lt;Integer&gt;&gt; ts = ps.window(5, TimeUnit.MILLISECONDS, scheduler, 5, true)</span>
<span class="fc" id="L820">        .test();</span>

        // window #1
<span class="fc" id="L823">        ps.onNext(1);</span>
<span class="fc" id="L824">        ps.onNext(2);</span>

<span class="fc" id="L826">        scheduler.advanceTimeBy(5, TimeUnit.MILLISECONDS);</span>

        // window #2
<span class="fc" id="L829">        ps.onNext(3);</span>
<span class="fc" id="L830">        ps.onNext(4);</span>
<span class="fc" id="L831">        ps.onNext(5);</span>
<span class="fc" id="L832">        ps.onNext(6);</span>

<span class="fc" id="L834">        ts.assertValueCount(2)</span>
<span class="fc" id="L835">        .assertNoErrors()</span>
<span class="fc" id="L836">        .assertNotComplete();</span>
<span class="fc" id="L837">    }</span>

    @Test
    public void doubleOnSubscribe() {
<span class="fc" id="L841">        TestHelper.checkDoubleOnSubscribeFlowable(new Function&lt;Flowable&lt;Object&gt;, Publisher&lt;Flowable&lt;Object&gt;&gt;&gt;() {</span>
            @Override
            public Publisher&lt;Flowable&lt;Object&gt;&gt; apply(Flowable&lt;Object&gt; f)
                    throws Exception {
<span class="fc" id="L845">                return f.window(1, TimeUnit.SECONDS, 1).takeLast(0);</span>
            }
        });
<span class="fc" id="L848">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void firstWindowMissingBackpressure() {
<span class="fc" id="L853">        Flowable.never()</span>
<span class="fc" id="L854">        .window(1, TimeUnit.SECONDS, 1)</span>
<span class="fc" id="L855">        .test(0L)</span>
<span class="fc" id="L856">        .assertFailure(MissingBackpressureException.class);</span>
<span class="fc" id="L857">    }</span>

    @Test
    public void nextWindowMissingBackpressure() {
<span class="fc" id="L861">        PublishProcessor&lt;Integer&gt; pp = PublishProcessor.create();</span>

<span class="fc" id="L863">        TestSubscriber&lt;Flowable&lt;Integer&gt;&gt; ts = pp.window(1, TimeUnit.SECONDS, 1)</span>
<span class="fc" id="L864">        .test(1L);</span>

<span class="fc" id="L866">        pp.onNext(1);</span>

<span class="fc" id="L868">        ts.assertValueCount(1)</span>
<span class="fc" id="L869">        .assertError(MissingBackpressureException.class)</span>
<span class="fc" id="L870">        .assertNotComplete();</span>
<span class="fc" id="L871">    }</span>

    @Test
    public void cancelUpfront() {
<span class="fc" id="L875">        Flowable.never()</span>
<span class="fc" id="L876">        .window(1, TimeUnit.SECONDS, 1)</span>
<span class="fc" id="L877">        .test(0L, true)</span>
<span class="fc" id="L878">        .assertEmpty();</span>
<span class="fc" id="L879">    }</span>

    @Test
    public void nextWindowMissingBackpressureDrainOnSize() {
<span class="fc" id="L883">        final PublishProcessor&lt;Integer&gt; pp = PublishProcessor.create();</span>

<span class="fc" id="L885">        TestSubscriber&lt;Flowable&lt;Integer&gt;&gt; ts = pp.window(1, TimeUnit.MINUTES, 1)</span>
<span class="fc" id="L886">        .subscribeWith(new TestSubscriber&lt;Flowable&lt;Integer&gt;&gt;(2) {</span>
            int calls;
            @Override
            public void onNext(Flowable&lt;Integer&gt; t) {
<span class="fc" id="L890">                super.onNext(t);</span>
<span class="fc bfc" id="L891" title="All 2 branches covered.">                if (++calls == 2) {</span>
<span class="fc" id="L892">                    pp.onNext(2);</span>
                }
<span class="fc" id="L894">            }</span>
        });

<span class="fc" id="L897">        pp.onNext(1);</span>

<span class="fc" id="L899">        ts.assertValueCount(2)</span>
<span class="fc" id="L900">        .assertError(MissingBackpressureException.class)</span>
<span class="fc" id="L901">        .assertNotComplete();</span>
<span class="fc" id="L902">    }</span>

    @Test
    public void nextWindowMissingBackpressureDrainOnTime() {
<span class="fc" id="L906">        final PublishProcessor&lt;Integer&gt; pp = PublishProcessor.create();</span>

<span class="fc" id="L908">        final TestScheduler sch = new TestScheduler();</span>

<span class="fc" id="L910">        TestSubscriber&lt;Flowable&lt;Integer&gt;&gt; ts = pp.window(1, TimeUnit.MILLISECONDS, sch, 10)</span>
<span class="fc" id="L911">        .test(1);</span>

<span class="fc" id="L913">        sch.advanceTimeBy(1, TimeUnit.MILLISECONDS);</span>

<span class="fc" id="L915">        ts.assertValueCount(1)</span>
<span class="fc" id="L916">        .assertError(MissingBackpressureException.class)</span>
<span class="fc" id="L917">        .assertNotComplete();</span>
<span class="fc" id="L918">    }</span>
}

</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>