<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ObservableBuffer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">RxJava_2_x$Unnamed.exec</a> &gt; <a href="index.source.html" class="el_package">io.reactivex.internal.operators.observable</a> &gt; <span class="el_source">ObservableBuffer.java</span></div><h1>ObservableBuffer.java</h1><pre class="source lang-java linenums">/**
 * Copyright (c) 2016-present, RxJava Contributors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is
 * distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
 * the License for the specific language governing permissions and limitations under the License.
 */

package io.reactivex.internal.operators.observable;

import io.reactivex.internal.functions.ObjectHelper;
import java.util.*;
import java.util.concurrent.Callable;
import java.util.concurrent.atomic.AtomicBoolean;

import io.reactivex.ObservableSource;
import io.reactivex.Observer;
import io.reactivex.disposables.Disposable;
import io.reactivex.exceptions.Exceptions;
import io.reactivex.internal.disposables.*;

public final class ObservableBuffer&lt;T, U extends Collection&lt;? super T&gt;&gt; extends AbstractObservableWithUpstream&lt;T, U&gt; {
    final int count;
    final int skip;
    final Callable&lt;U&gt; bufferSupplier;

    public ObservableBuffer(ObservableSource&lt;T&gt; source, int count, int skip, Callable&lt;U&gt; bufferSupplier) {
<span class="fc" id="L33">        super(source);</span>
<span class="fc" id="L34">        this.count = count;</span>
<span class="fc" id="L35">        this.skip = skip;</span>
<span class="fc" id="L36">        this.bufferSupplier = bufferSupplier;</span>
<span class="fc" id="L37">    }</span>

    @Override
    protected void subscribeActual(Observer&lt;? super U&gt; t) {
<span class="fc bfc" id="L41" title="All 2 branches covered.">        if (skip == count) {</span>
<span class="fc" id="L42">            BufferExactObserver&lt;T, U&gt; bes = new BufferExactObserver&lt;T, U&gt;(t, count, bufferSupplier);</span>
<span class="fc bfc" id="L43" title="All 2 branches covered.">            if (bes.createBuffer()) {</span>
<span class="fc" id="L44">                source.subscribe(bes);</span>
            }
<span class="fc" id="L46">        } else {</span>
<span class="fc" id="L47">            source.subscribe(new BufferSkipObserver&lt;T, U&gt;(t, count, skip, bufferSupplier));</span>
        }
<span class="fc" id="L49">    }</span>

    static final class BufferExactObserver&lt;T, U extends Collection&lt;? super T&gt;&gt; implements Observer&lt;T&gt;, Disposable {
        final Observer&lt;? super U&gt; downstream;
        final int count;
        final Callable&lt;U&gt; bufferSupplier;
        U buffer;

        int size;

        Disposable upstream;

<span class="fc" id="L61">        BufferExactObserver(Observer&lt;? super U&gt; actual, int count, Callable&lt;U&gt; bufferSupplier) {</span>
<span class="fc" id="L62">            this.downstream = actual;</span>
<span class="fc" id="L63">            this.count = count;</span>
<span class="fc" id="L64">            this.bufferSupplier = bufferSupplier;</span>
<span class="fc" id="L65">        }</span>

        boolean createBuffer() {
            U b;
            try {
<span class="fc" id="L70">                b = ObjectHelper.requireNonNull(bufferSupplier.call(), &quot;Empty buffer supplied&quot;);</span>
<span class="fc" id="L71">            } catch (Throwable t) {</span>
<span class="fc" id="L72">                Exceptions.throwIfFatal(t);</span>
<span class="fc" id="L73">                buffer = null;</span>
<span class="fc bfc" id="L74" title="All 2 branches covered.">                if (upstream == null) {</span>
<span class="fc" id="L75">                    EmptyDisposable.error(t, downstream);</span>
                } else {
<span class="fc" id="L77">                    upstream.dispose();</span>
<span class="fc" id="L78">                    downstream.onError(t);</span>
                }
<span class="fc" id="L80">                return false;</span>
<span class="fc" id="L81">            }</span>

<span class="fc" id="L83">            buffer = b;</span>

<span class="fc" id="L85">            return true;</span>
        }

        @Override
        public void onSubscribe(Disposable d) {
<span class="fc bfc" id="L90" title="All 2 branches covered.">            if (DisposableHelper.validate(this.upstream, d)) {</span>
<span class="fc" id="L91">                this.upstream = d;</span>
<span class="fc" id="L92">                downstream.onSubscribe(this);</span>
            }
<span class="fc" id="L94">        }</span>

        @Override
        public void dispose() {
<span class="fc" id="L98">            upstream.dispose();</span>
<span class="fc" id="L99">        }</span>

        @Override
        public boolean isDisposed() {
<span class="fc" id="L103">            return upstream.isDisposed();</span>
        }

        @Override
        public void onNext(T t) {
<span class="fc" id="L108">            U b = buffer;</span>
<span class="fc bfc" id="L109" title="All 2 branches covered.">            if (b != null) {</span>
<span class="fc" id="L110">                b.add(t);</span>

<span class="fc bfc" id="L112" title="All 2 branches covered.">                if (++size &gt;= count) {</span>
<span class="fc" id="L113">                    downstream.onNext(b);</span>

<span class="fc" id="L115">                    size = 0;</span>
<span class="fc" id="L116">                    createBuffer();</span>
                }
            }
<span class="fc" id="L119">        }</span>

        @Override
        public void onError(Throwable t) {
<span class="fc" id="L123">            buffer = null;</span>
<span class="fc" id="L124">            downstream.onError(t);</span>
<span class="fc" id="L125">        }</span>

        @Override
        public void onComplete() {
<span class="fc" id="L129">            U b = buffer;</span>
<span class="fc bfc" id="L130" title="All 2 branches covered.">            if (b != null) {</span>
<span class="fc" id="L131">                buffer = null;</span>
<span class="fc bfc" id="L132" title="All 2 branches covered.">                if (!b.isEmpty()) {</span>
<span class="fc" id="L133">                    downstream.onNext(b);</span>
                }
<span class="fc" id="L135">                downstream.onComplete();</span>
            }
<span class="fc" id="L137">        }</span>
    }

    static final class BufferSkipObserver&lt;T, U extends Collection&lt;? super T&gt;&gt;
    extends AtomicBoolean implements Observer&lt;T&gt;, Disposable {

        private static final long serialVersionUID = -8223395059921494546L;
        final Observer&lt;? super U&gt; downstream;
        final int count;
        final int skip;
        final Callable&lt;U&gt; bufferSupplier;

        Disposable upstream;

        final ArrayDeque&lt;U&gt; buffers;

        long index;

<span class="fc" id="L155">        BufferSkipObserver(Observer&lt;? super U&gt; actual, int count, int skip, Callable&lt;U&gt; bufferSupplier) {</span>
<span class="fc" id="L156">            this.downstream = actual;</span>
<span class="fc" id="L157">            this.count = count;</span>
<span class="fc" id="L158">            this.skip = skip;</span>
<span class="fc" id="L159">            this.bufferSupplier = bufferSupplier;</span>
<span class="fc" id="L160">            this.buffers = new ArrayDeque&lt;U&gt;();</span>
<span class="fc" id="L161">        }</span>

        @Override
        public void onSubscribe(Disposable d) {
<span class="fc bfc" id="L165" title="All 2 branches covered.">            if (DisposableHelper.validate(this.upstream, d)) {</span>
<span class="fc" id="L166">                this.upstream = d;</span>
<span class="fc" id="L167">                downstream.onSubscribe(this);</span>
            }
<span class="fc" id="L169">        }</span>

        @Override
        public void dispose() {
<span class="fc" id="L173">            upstream.dispose();</span>
<span class="fc" id="L174">        }</span>

        @Override
        public boolean isDisposed() {
<span class="fc" id="L178">            return upstream.isDisposed();</span>
        }

        @Override
        public void onNext(T t) {
<span class="fc bfc" id="L183" title="All 2 branches covered.">            if (index++ % skip == 0) {</span>
                U b;

                try {
<span class="fc" id="L187">                    b = ObjectHelper.requireNonNull(bufferSupplier.call(), &quot;The bufferSupplier returned a null collection. Null values are generally not allowed in 2.x operators and sources.&quot;);</span>
<span class="fc" id="L188">                } catch (Throwable e) {</span>
<span class="fc" id="L189">                    buffers.clear();</span>
<span class="fc" id="L190">                    upstream.dispose();</span>
<span class="fc" id="L191">                    downstream.onError(e);</span>
<span class="fc" id="L192">                    return;</span>
<span class="fc" id="L193">                }</span>

<span class="fc" id="L195">                buffers.offer(b);</span>
            }

<span class="fc" id="L198">            Iterator&lt;U&gt; it = buffers.iterator();</span>
<span class="fc bfc" id="L199" title="All 2 branches covered.">            while (it.hasNext()) {</span>
<span class="fc" id="L200">                U b = it.next();</span>
<span class="fc" id="L201">                b.add(t);</span>
<span class="fc bfc" id="L202" title="All 2 branches covered.">                if (count &lt;= b.size()) {</span>
<span class="fc" id="L203">                    it.remove();</span>

<span class="fc" id="L205">                    downstream.onNext(b);</span>
                }
<span class="fc" id="L207">            }</span>
<span class="fc" id="L208">        }</span>

        @Override
        public void onError(Throwable t) {
<span class="fc" id="L212">            buffers.clear();</span>
<span class="fc" id="L213">            downstream.onError(t);</span>
<span class="fc" id="L214">        }</span>

        @Override
        public void onComplete() {
<span class="fc bfc" id="L218" title="All 2 branches covered.">            while (!buffers.isEmpty()) {</span>
<span class="fc" id="L219">                downstream.onNext(buffers.poll());</span>
            }
<span class="fc" id="L221">            downstream.onComplete();</span>
<span class="fc" id="L222">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>