<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ObservableBufferTimed.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">RxJava_2_x$Unnamed.exec</a> &gt; <a href="index.source.html" class="el_package">io.reactivex.internal.operators.observable</a> &gt; <span class="el_source">ObservableBufferTimed.java</span></div><h1>ObservableBufferTimed.java</h1><pre class="source lang-java linenums">/**
 * Copyright (c) 2016-present, RxJava Contributors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is
 * distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
 * the License for the specific language governing permissions and limitations under the License.
 */

package io.reactivex.internal.operators.observable;

import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicReference;

import io.reactivex.*;
import io.reactivex.Observer;
import io.reactivex.Scheduler.Worker;
import io.reactivex.disposables.Disposable;
import io.reactivex.exceptions.Exceptions;
import io.reactivex.internal.disposables.*;
import io.reactivex.internal.functions.ObjectHelper;
import io.reactivex.internal.observers.QueueDrainObserver;
import io.reactivex.internal.queue.MpscLinkedQueue;
import io.reactivex.internal.util.QueueDrainHelper;
import io.reactivex.observers.SerializedObserver;

public final class ObservableBufferTimed&lt;T, U extends Collection&lt;? super T&gt;&gt;
extends AbstractObservableWithUpstream&lt;T, U&gt; {

    final long timespan;
    final long timeskip;
    final TimeUnit unit;
    final Scheduler scheduler;
    final Callable&lt;U&gt; bufferSupplier;
    final int maxSize;
    final boolean restartTimerOnMaxSize;

    public ObservableBufferTimed(ObservableSource&lt;T&gt; source, long timespan, long timeskip, TimeUnit unit, Scheduler scheduler, Callable&lt;U&gt; bufferSupplier, int maxSize,
                                 boolean restartTimerOnMaxSize) {
<span class="fc" id="L45">        super(source);</span>
<span class="fc" id="L46">        this.timespan = timespan;</span>
<span class="fc" id="L47">        this.timeskip = timeskip;</span>
<span class="fc" id="L48">        this.unit = unit;</span>
<span class="fc" id="L49">        this.scheduler = scheduler;</span>
<span class="fc" id="L50">        this.bufferSupplier = bufferSupplier;</span>
<span class="fc" id="L51">        this.maxSize = maxSize;</span>
<span class="fc" id="L52">        this.restartTimerOnMaxSize = restartTimerOnMaxSize;</span>
<span class="fc" id="L53">    }</span>

    @Override
    protected void subscribeActual(Observer&lt;? super U&gt; t) {
<span class="fc bfc" id="L57" title="All 4 branches covered.">        if (timespan == timeskip &amp;&amp; maxSize == Integer.MAX_VALUE) {</span>
<span class="fc" id="L58">            source.subscribe(new BufferExactUnboundedObserver&lt;T, U&gt;(</span>
                    new SerializedObserver&lt;U&gt;(t),
                    bufferSupplier, timespan, unit, scheduler));
<span class="fc" id="L61">            return;</span>
        }
<span class="fc" id="L63">        Scheduler.Worker w = scheduler.createWorker();</span>

<span class="fc bfc" id="L65" title="All 2 branches covered.">        if (timespan == timeskip) {</span>
<span class="fc" id="L66">            source.subscribe(new BufferExactBoundedObserver&lt;T, U&gt;(</span>
                    new SerializedObserver&lt;U&gt;(t),
                    bufferSupplier,
                    timespan, unit, maxSize, restartTimerOnMaxSize, w
            ));
<span class="fc" id="L71">            return;</span>
        }
        // Can't use maxSize because what to do if a buffer is full but its
        // timespan hasn't been elapsed?
<span class="fc" id="L75">        source.subscribe(new BufferSkipBoundedObserver&lt;T, U&gt;(</span>
                new SerializedObserver&lt;U&gt;(t),
                bufferSupplier, timespan, timeskip, unit, w));

<span class="fc" id="L79">    }</span>

    static final class BufferExactUnboundedObserver&lt;T, U extends Collection&lt;? super T&gt;&gt;
    extends QueueDrainObserver&lt;T, U, U&gt; implements Runnable, Disposable {
        final Callable&lt;U&gt; bufferSupplier;
        final long timespan;
        final TimeUnit unit;
        final Scheduler scheduler;

        Disposable upstream;

        U buffer;

<span class="fc" id="L92">        final AtomicReference&lt;Disposable&gt; timer = new AtomicReference&lt;Disposable&gt;();</span>

        BufferExactUnboundedObserver(
                Observer&lt;? super U&gt; actual, Callable&lt;U&gt; bufferSupplier,
                long timespan, TimeUnit unit, Scheduler scheduler) {
<span class="fc" id="L97">            super(actual, new MpscLinkedQueue&lt;U&gt;());</span>
<span class="fc" id="L98">            this.bufferSupplier = bufferSupplier;</span>
<span class="fc" id="L99">            this.timespan = timespan;</span>
<span class="fc" id="L100">            this.unit = unit;</span>
<span class="fc" id="L101">            this.scheduler = scheduler;</span>
<span class="fc" id="L102">        }</span>

        @Override
        public void onSubscribe(Disposable d) {
<span class="fc bfc" id="L106" title="All 2 branches covered.">            if (DisposableHelper.validate(this.upstream, d)) {</span>
<span class="fc" id="L107">                this.upstream = d;</span>

                U b;

                try {
<span class="fc" id="L112">                    b = ObjectHelper.requireNonNull(bufferSupplier.call(), &quot;The buffer supplied is null&quot;);</span>
<span class="fc" id="L113">                } catch (Throwable e) {</span>
<span class="fc" id="L114">                    Exceptions.throwIfFatal(e);</span>
<span class="fc" id="L115">                    dispose();</span>
<span class="fc" id="L116">                    EmptyDisposable.error(e, downstream);</span>
<span class="fc" id="L117">                    return;</span>
<span class="fc" id="L118">                }</span>

<span class="fc" id="L120">                buffer = b;</span>

<span class="fc" id="L122">                downstream.onSubscribe(this);</span>

<span class="pc bpc" id="L124" title="1 of 2 branches missed.">                if (!cancelled) {</span>
<span class="fc" id="L125">                    Disposable task = scheduler.schedulePeriodicallyDirect(this, timespan, timespan, unit);</span>
<span class="fc bfc" id="L126" title="All 2 branches covered.">                    if (!timer.compareAndSet(null, task)) {</span>
<span class="fc" id="L127">                        task.dispose();</span>
                    }
                }
            }
<span class="fc" id="L131">        }</span>

        @Override
        public void onNext(T t) {
<span class="fc" id="L135">            synchronized (this) {</span>
<span class="fc" id="L136">                U b = buffer;</span>
<span class="fc bfc" id="L137" title="All 2 branches covered.">                if (b == null) {</span>
<span class="fc" id="L138">                    return;</span>
                }
<span class="fc" id="L140">                b.add(t);</span>
<span class="fc" id="L141">            }</span>
<span class="fc" id="L142">        }</span>

        @Override
        public void onError(Throwable t) {
<span class="fc" id="L146">            synchronized (this) {</span>
<span class="fc" id="L147">                buffer = null;</span>
<span class="fc" id="L148">            }</span>
<span class="fc" id="L149">            downstream.onError(t);</span>
<span class="fc" id="L150">            DisposableHelper.dispose(timer);</span>
<span class="fc" id="L151">        }</span>

        @Override
        public void onComplete() {
            U b;
<span class="fc" id="L156">            synchronized (this) {</span>
<span class="fc" id="L157">                b = buffer;</span>
<span class="fc" id="L158">                buffer = null;</span>
<span class="fc" id="L159">            }</span>
<span class="fc bfc" id="L160" title="All 2 branches covered.">            if (b != null) {</span>
<span class="fc" id="L161">                queue.offer(b);</span>
<span class="fc" id="L162">                done = true;</span>
<span class="fc bfc" id="L163" title="All 2 branches covered.">                if (enter()) {</span>
<span class="fc" id="L164">                    QueueDrainHelper.drainLoop(queue, downstream, false, null, this);</span>
                }
            }
<span class="fc" id="L167">            DisposableHelper.dispose(timer);</span>
<span class="fc" id="L168">        }</span>

        @Override
        public void dispose() {
<span class="fc" id="L172">            DisposableHelper.dispose(timer);</span>
<span class="fc" id="L173">            upstream.dispose();</span>
<span class="fc" id="L174">        }</span>

        @Override
        public boolean isDisposed() {
<span class="fc bfc" id="L178" title="All 2 branches covered.">            return timer.get() == DisposableHelper.DISPOSED;</span>
        }

        @Override
        public void run() {
            U next;

            try {
<span class="fc" id="L186">                next = ObjectHelper.requireNonNull(bufferSupplier.call(), &quot;The bufferSupplier returned a null buffer&quot;);</span>
<span class="fc" id="L187">            } catch (Throwable e) {</span>
<span class="fc" id="L188">                Exceptions.throwIfFatal(e);</span>
<span class="fc" id="L189">                downstream.onError(e);</span>
<span class="fc" id="L190">                dispose();</span>
<span class="fc" id="L191">                return;</span>
<span class="fc" id="L192">            }</span>

            U current;

<span class="fc" id="L196">            synchronized (this) {</span>
<span class="fc" id="L197">                current = buffer;</span>
<span class="fc bfc" id="L198" title="All 2 branches covered.">                if (current != null) {</span>
<span class="fc" id="L199">                    buffer = next;</span>
                }
<span class="fc" id="L201">            }</span>

<span class="fc bfc" id="L203" title="All 2 branches covered.">            if (current == null) {</span>
<span class="fc" id="L204">                DisposableHelper.dispose(timer);</span>
<span class="fc" id="L205">                return;</span>
            }

<span class="fc" id="L208">            fastPathEmit(current, false, this);</span>
<span class="fc" id="L209">        }</span>

        @Override
        public void accept(Observer&lt;? super U&gt; a, U v) {
<span class="fc" id="L213">            downstream.onNext(v);</span>
<span class="fc" id="L214">        }</span>
    }

    static final class BufferSkipBoundedObserver&lt;T, U extends Collection&lt;? super T&gt;&gt;
    extends QueueDrainObserver&lt;T, U, U&gt; implements Runnable, Disposable {
        final Callable&lt;U&gt; bufferSupplier;
        final long timespan;
        final long timeskip;
        final TimeUnit unit;
        final Worker w;
        final List&lt;U&gt; buffers;

        Disposable upstream;

        BufferSkipBoundedObserver(Observer&lt;? super U&gt; actual,
                Callable&lt;U&gt; bufferSupplier, long timespan,
                long timeskip, TimeUnit unit, Worker w) {
<span class="fc" id="L231">            super(actual, new MpscLinkedQueue&lt;U&gt;());</span>
<span class="fc" id="L232">            this.bufferSupplier = bufferSupplier;</span>
<span class="fc" id="L233">            this.timespan = timespan;</span>
<span class="fc" id="L234">            this.timeskip = timeskip;</span>
<span class="fc" id="L235">            this.unit = unit;</span>
<span class="fc" id="L236">            this.w = w;</span>
<span class="fc" id="L237">            this.buffers = new LinkedList&lt;U&gt;();</span>
<span class="fc" id="L238">        }</span>

        @Override
        public void onSubscribe(Disposable d) {
<span class="fc bfc" id="L242" title="All 2 branches covered.">            if (DisposableHelper.validate(this.upstream, d)) {</span>
<span class="fc" id="L243">                this.upstream = d;</span>

                final U b; // NOPMD

                try {
<span class="fc" id="L248">                    b = ObjectHelper.requireNonNull(bufferSupplier.call(), &quot;The buffer supplied is null&quot;);</span>
<span class="fc" id="L249">                } catch (Throwable e) {</span>
<span class="fc" id="L250">                    Exceptions.throwIfFatal(e);</span>
<span class="fc" id="L251">                    d.dispose();</span>
<span class="fc" id="L252">                    EmptyDisposable.error(e, downstream);</span>
<span class="fc" id="L253">                    w.dispose();</span>
<span class="fc" id="L254">                    return;</span>
<span class="fc" id="L255">                }</span>

<span class="fc" id="L257">                buffers.add(b);</span>

<span class="fc" id="L259">                downstream.onSubscribe(this);</span>

<span class="fc" id="L261">                w.schedulePeriodically(this, timeskip, timeskip, unit);</span>

<span class="fc" id="L263">                w.schedule(new RemoveFromBufferEmit(b), timespan, unit);</span>
            }
<span class="fc" id="L265">        }</span>

        @Override
        public void onNext(T t) {
<span class="fc" id="L269">            synchronized (this) {</span>
<span class="fc bfc" id="L270" title="All 2 branches covered.">                for (U b : buffers) {</span>
<span class="fc" id="L271">                    b.add(t);</span>
<span class="fc" id="L272">                }</span>
<span class="fc" id="L273">            }</span>
<span class="fc" id="L274">        }</span>

        @Override
        public void onError(Throwable t) {
<span class="fc" id="L278">            done = true;</span>
<span class="fc" id="L279">            clear();</span>
<span class="fc" id="L280">            downstream.onError(t);</span>
<span class="fc" id="L281">            w.dispose();</span>
<span class="fc" id="L282">        }</span>

        @Override
        public void onComplete() {
            List&lt;U&gt; bs;
<span class="fc" id="L287">            synchronized (this) {</span>
<span class="fc" id="L288">                bs = new ArrayList&lt;U&gt;(buffers);</span>
<span class="fc" id="L289">                buffers.clear();</span>
<span class="fc" id="L290">            }</span>

<span class="fc bfc" id="L292" title="All 2 branches covered.">            for (U b : bs) {</span>
<span class="fc" id="L293">                queue.offer(b);</span>
<span class="fc" id="L294">            }</span>
<span class="fc" id="L295">            done = true;</span>
<span class="fc bfc" id="L296" title="All 2 branches covered.">            if (enter()) {</span>
<span class="fc" id="L297">                QueueDrainHelper.drainLoop(queue, downstream, false, w, this);</span>
            }
<span class="fc" id="L299">        }</span>

        @Override
        public void dispose() {
<span class="fc bfc" id="L303" title="All 2 branches covered.">            if (!cancelled) {</span>
<span class="fc" id="L304">                cancelled = true;</span>
<span class="fc" id="L305">                clear();</span>
<span class="fc" id="L306">                upstream.dispose();</span>
<span class="fc" id="L307">                w.dispose();</span>
            }
<span class="fc" id="L309">        }</span>

        @Override
        public boolean isDisposed() {
<span class="fc" id="L313">            return cancelled;</span>
        }

        void clear() {
<span class="fc" id="L317">            synchronized (this) {</span>
<span class="fc" id="L318">                buffers.clear();</span>
<span class="fc" id="L319">            }</span>
<span class="fc" id="L320">        }</span>

        @Override
        public void run() {
<span class="fc bfc" id="L324" title="All 2 branches covered.">            if (cancelled) {</span>
<span class="fc" id="L325">                return;</span>
            }
            final U b; // NOPMD

            try {
<span class="fc" id="L330">                b = ObjectHelper.requireNonNull(bufferSupplier.call(), &quot;The bufferSupplier returned a null buffer&quot;);</span>
<span class="fc" id="L331">            } catch (Throwable e) {</span>
<span class="fc" id="L332">                Exceptions.throwIfFatal(e);</span>
<span class="fc" id="L333">                downstream.onError(e);</span>
<span class="fc" id="L334">                dispose();</span>
<span class="fc" id="L335">                return;</span>
<span class="fc" id="L336">            }</span>

<span class="fc" id="L338">            synchronized (this) {</span>
<span class="fc bfc" id="L339" title="All 2 branches covered.">                if (cancelled) {</span>
<span class="fc" id="L340">                    return;</span>
                }
<span class="fc" id="L342">                buffers.add(b);</span>
<span class="fc" id="L343">            }</span>

<span class="fc" id="L345">            w.schedule(new RemoveFromBuffer(b), timespan, unit);</span>
<span class="fc" id="L346">        }</span>

        @Override
        public void accept(Observer&lt;? super U&gt; a, U v) {
<span class="fc" id="L350">            a.onNext(v);</span>
<span class="fc" id="L351">        }</span>

        final class RemoveFromBuffer implements Runnable {
            private final U b;

<span class="fc" id="L356">            RemoveFromBuffer(U b) {</span>
<span class="fc" id="L357">                this.b = b;</span>
<span class="fc" id="L358">            }</span>

            @Override
            public void run() {
<span class="fc" id="L362">                synchronized (BufferSkipBoundedObserver.this) {</span>
<span class="fc" id="L363">                    buffers.remove(b);</span>
<span class="fc" id="L364">                }</span>

<span class="fc" id="L366">                fastPathOrderedEmit(b, false, w);</span>
<span class="fc" id="L367">            }</span>
        }

        final class RemoveFromBufferEmit implements Runnable {
            private final U buffer;

<span class="fc" id="L373">            RemoveFromBufferEmit(U buffer) {</span>
<span class="fc" id="L374">                this.buffer = buffer;</span>
<span class="fc" id="L375">            }</span>

            @Override
            public void run() {
<span class="fc" id="L379">                synchronized (BufferSkipBoundedObserver.this) {</span>
<span class="fc" id="L380">                    buffers.remove(buffer);</span>
<span class="fc" id="L381">                }</span>

<span class="fc" id="L383">                fastPathOrderedEmit(buffer, false, w);</span>
<span class="fc" id="L384">            }</span>
        }
    }

    static final class BufferExactBoundedObserver&lt;T, U extends Collection&lt;? super T&gt;&gt;
    extends QueueDrainObserver&lt;T, U, U&gt; implements Runnable, Disposable {
        final Callable&lt;U&gt; bufferSupplier;
        final long timespan;
        final TimeUnit unit;
        final int maxSize;
        final boolean restartTimerOnMaxSize;
        final Worker w;

        U buffer;

        Disposable timer;

        Disposable upstream;

        long producerIndex;

        long consumerIndex;

        BufferExactBoundedObserver(
                Observer&lt;? super U&gt; actual,
                Callable&lt;U&gt; bufferSupplier,
                long timespan, TimeUnit unit, int maxSize,
                boolean restartOnMaxSize, Worker w) {
<span class="fc" id="L412">            super(actual, new MpscLinkedQueue&lt;U&gt;());</span>
<span class="fc" id="L413">            this.bufferSupplier = bufferSupplier;</span>
<span class="fc" id="L414">            this.timespan = timespan;</span>
<span class="fc" id="L415">            this.unit = unit;</span>
<span class="fc" id="L416">            this.maxSize = maxSize;</span>
<span class="fc" id="L417">            this.restartTimerOnMaxSize = restartOnMaxSize;</span>
<span class="fc" id="L418">            this.w = w;</span>
<span class="fc" id="L419">        }</span>

        @Override
        public void onSubscribe(Disposable d) {
<span class="fc bfc" id="L423" title="All 2 branches covered.">            if (DisposableHelper.validate(this.upstream, d)) {</span>
<span class="fc" id="L424">                this.upstream = d;</span>

                U b;

                try {
<span class="fc" id="L429">                    b = ObjectHelper.requireNonNull(bufferSupplier.call(), &quot;The buffer supplied is null&quot;);</span>
<span class="fc" id="L430">                } catch (Throwable e) {</span>
<span class="fc" id="L431">                    Exceptions.throwIfFatal(e);</span>
<span class="fc" id="L432">                    d.dispose();</span>
<span class="fc" id="L433">                    EmptyDisposable.error(e, downstream);</span>
<span class="fc" id="L434">                    w.dispose();</span>
<span class="fc" id="L435">                    return;</span>
<span class="fc" id="L436">                }</span>

<span class="fc" id="L438">                buffer = b;</span>

<span class="fc" id="L440">                downstream.onSubscribe(this);</span>

<span class="fc" id="L442">                timer = w.schedulePeriodically(this, timespan, timespan, unit);</span>
            }
<span class="fc" id="L444">        }</span>

        @Override
        public void onNext(T t) {
            U b;
<span class="fc" id="L449">            synchronized (this) {</span>
<span class="fc" id="L450">                b = buffer;</span>
<span class="fc bfc" id="L451" title="All 2 branches covered.">                if (b == null) {</span>
<span class="fc" id="L452">                    return;</span>
                }

<span class="fc" id="L455">                b.add(t);</span>

<span class="fc bfc" id="L457" title="All 2 branches covered.">                if (b.size() &lt; maxSize) {</span>
<span class="fc" id="L458">                    return;</span>
                }
<span class="fc" id="L460">                buffer = null;</span>
<span class="fc" id="L461">                producerIndex++;</span>
<span class="fc" id="L462">            }</span>

<span class="fc bfc" id="L464" title="All 2 branches covered.">            if (restartTimerOnMaxSize) {</span>
<span class="fc" id="L465">                timer.dispose();</span>
            }

<span class="fc" id="L468">            fastPathOrderedEmit(b, false, this);</span>

            try {
<span class="fc" id="L471">                b = ObjectHelper.requireNonNull(bufferSupplier.call(), &quot;The buffer supplied is null&quot;);</span>
<span class="fc" id="L472">            } catch (Throwable e) {</span>
<span class="fc" id="L473">                Exceptions.throwIfFatal(e);</span>
<span class="fc" id="L474">                downstream.onError(e);</span>
<span class="fc" id="L475">                dispose();</span>
<span class="fc" id="L476">                return;</span>
<span class="fc" id="L477">            }</span>

<span class="fc" id="L479">            synchronized (this) {</span>
<span class="fc" id="L480">                buffer = b;</span>
<span class="fc" id="L481">                consumerIndex++;</span>
<span class="fc" id="L482">            }</span>
<span class="fc bfc" id="L483" title="All 2 branches covered.">            if (restartTimerOnMaxSize) {</span>
<span class="fc" id="L484">                timer = w.schedulePeriodically(this, timespan, timespan, unit);</span>
            }
<span class="fc" id="L486">        }</span>

        @Override
        public void onError(Throwable t) {
<span class="fc" id="L490">            synchronized (this) {</span>
<span class="fc" id="L491">                buffer = null;</span>
<span class="fc" id="L492">            }</span>
<span class="fc" id="L493">            downstream.onError(t);</span>
<span class="fc" id="L494">            w.dispose();</span>
<span class="fc" id="L495">        }</span>

        @Override
        public void onComplete() {
<span class="fc" id="L499">            w.dispose();</span>

            U b;
<span class="fc" id="L502">            synchronized (this) {</span>
<span class="fc" id="L503">                b = buffer;</span>
<span class="fc" id="L504">                buffer = null;</span>
<span class="fc" id="L505">            }</span>

<span class="fc" id="L507">            queue.offer(b);</span>
<span class="fc" id="L508">            done = true;</span>
<span class="fc bfc" id="L509" title="All 2 branches covered.">            if (enter()) {</span>
<span class="fc" id="L510">                QueueDrainHelper.drainLoop(queue, downstream, false, this, this);</span>
            }
<span class="fc" id="L512">        }</span>

        @Override
        public void accept(Observer&lt;? super U&gt; a, U v) {
<span class="fc" id="L516">            a.onNext(v);</span>
<span class="fc" id="L517">        }</span>

        @Override
        public void dispose() {
<span class="fc bfc" id="L521" title="All 2 branches covered.">            if (!cancelled) {</span>
<span class="fc" id="L522">                cancelled = true;</span>
<span class="fc" id="L523">                upstream.dispose();</span>
<span class="fc" id="L524">                w.dispose();</span>
<span class="fc" id="L525">                synchronized (this) {</span>
<span class="fc" id="L526">                    buffer = null;</span>
<span class="fc" id="L527">                }</span>
            }
<span class="fc" id="L529">        }</span>

        @Override
        public boolean isDisposed() {
<span class="fc" id="L533">            return cancelled;</span>
        }

        @Override
        public void run() {
            U next;

            try {
<span class="fc" id="L541">                next = ObjectHelper.requireNonNull(bufferSupplier.call(), &quot;The bufferSupplier returned a null buffer&quot;);</span>
<span class="fc" id="L542">            } catch (Throwable e) {</span>
<span class="fc" id="L543">                Exceptions.throwIfFatal(e);</span>
<span class="fc" id="L544">                dispose();</span>
<span class="fc" id="L545">                downstream.onError(e);</span>
<span class="fc" id="L546">                return;</span>
<span class="fc" id="L547">            }</span>

            U current;

<span class="fc" id="L551">            synchronized (this) {</span>
<span class="fc" id="L552">                current = buffer;</span>
<span class="fc bfc" id="L553" title="All 4 branches covered.">                if (current == null || producerIndex != consumerIndex) {</span>
<span class="fc" id="L554">                    return;</span>
                }
<span class="fc" id="L556">                buffer = next;</span>
<span class="fc" id="L557">            }</span>

<span class="fc" id="L559">            fastPathOrderedEmit(current, false, this);</span>
<span class="fc" id="L560">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>