<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ObservableGroupByTest.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">RxJava_2_x$Unnamed.exec</a> &gt; <a href="index.source.html" class="el_package">io.reactivex.internal.operators.observable</a> &gt; <span class="el_source">ObservableGroupByTest.java</span></div><h1>ObservableGroupByTest.java</h1><pre class="source lang-java linenums">/**
 * Copyright (c) 2016-present, RxJava Contributors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is
 * distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
 * the License for the specific language governing permissions and limitations under the License.
 */

package io.reactivex.internal.operators.observable;

import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.*;

import org.junit.Test;

import io.reactivex.*;
import io.reactivex.Observable;
import io.reactivex.Observer;
import io.reactivex.disposables.*;
import io.reactivex.exceptions.TestException;
import io.reactivex.functions.*;
import io.reactivex.internal.functions.Functions;
import io.reactivex.observables.GroupedObservable;
import io.reactivex.observers.*;
import io.reactivex.schedulers.Schedulers;
import io.reactivex.subjects.PublishSubject;

import org.mockito.Mockito;

<span class="fc" id="L39">public class ObservableGroupByTest {</span>

<span class="fc" id="L41">    final Function&lt;String, Integer&gt; length = new Function&lt;String, Integer&gt;() {</span>
        @Override
        public Integer apply(String s) {
<span class="fc" id="L44">            return s.length();</span>
        }
    };

    @Test
    public void testGroupBy() {
<span class="fc" id="L50">        Observable&lt;String&gt; source = Observable.just(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;, &quot;six&quot;);</span>
<span class="fc" id="L51">        Observable&lt;GroupedObservable&lt;Integer, String&gt;&gt; grouped = source.groupBy(length);</span>

<span class="fc" id="L53">        Map&lt;Integer, Collection&lt;String&gt;&gt; map = toMap(grouped);</span>

<span class="fc" id="L55">        assertEquals(3, map.size());</span>
<span class="fc" id="L56">        assertArrayEquals(Arrays.asList(&quot;one&quot;, &quot;two&quot;, &quot;six&quot;).toArray(), map.get(3).toArray());</span>
<span class="fc" id="L57">        assertArrayEquals(Arrays.asList(&quot;four&quot;, &quot;five&quot;).toArray(), map.get(4).toArray());</span>
<span class="fc" id="L58">        assertArrayEquals(Arrays.asList(&quot;three&quot;).toArray(), map.get(5).toArray());</span>
<span class="fc" id="L59">    }</span>

    @Test
    public void testGroupByWithElementSelector() {
<span class="fc" id="L63">        Observable&lt;String&gt; source = Observable.just(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;, &quot;six&quot;);</span>
<span class="fc" id="L64">        Observable&lt;GroupedObservable&lt;Integer, Integer&gt;&gt; grouped = source.groupBy(length, length);</span>

<span class="fc" id="L66">        Map&lt;Integer, Collection&lt;Integer&gt;&gt; map = toMap(grouped);</span>

<span class="fc" id="L68">        assertEquals(3, map.size());</span>
<span class="fc" id="L69">        assertArrayEquals(Arrays.asList(3, 3, 3).toArray(), map.get(3).toArray());</span>
<span class="fc" id="L70">        assertArrayEquals(Arrays.asList(4, 4).toArray(), map.get(4).toArray());</span>
<span class="fc" id="L71">        assertArrayEquals(Arrays.asList(5).toArray(), map.get(5).toArray());</span>
<span class="fc" id="L72">    }</span>

    @Test
    public void testGroupByWithElementSelector2() {
<span class="fc" id="L76">        Observable&lt;String&gt; source = Observable.just(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;, &quot;six&quot;);</span>
<span class="fc" id="L77">        Observable&lt;GroupedObservable&lt;Integer, Integer&gt;&gt; grouped = source.groupBy(length, length);</span>

<span class="fc" id="L79">        Map&lt;Integer, Collection&lt;Integer&gt;&gt; map = toMap(grouped);</span>

<span class="fc" id="L81">        assertEquals(3, map.size());</span>
<span class="fc" id="L82">        assertArrayEquals(Arrays.asList(3, 3, 3).toArray(), map.get(3).toArray());</span>
<span class="fc" id="L83">        assertArrayEquals(Arrays.asList(4, 4).toArray(), map.get(4).toArray());</span>
<span class="fc" id="L84">        assertArrayEquals(Arrays.asList(5).toArray(), map.get(5).toArray());</span>
<span class="fc" id="L85">    }</span>

    @Test
    public void testEmpty() {
<span class="fc" id="L89">        Observable&lt;String&gt; source = Observable.empty();</span>
<span class="fc" id="L90">        Observable&lt;GroupedObservable&lt;Integer, String&gt;&gt; grouped = source.groupBy(length);</span>

<span class="fc" id="L92">        Map&lt;Integer, Collection&lt;String&gt;&gt; map = toMap(grouped);</span>

<span class="fc" id="L94">        assertTrue(map.isEmpty());</span>
<span class="fc" id="L95">    }</span>

    @Test
    public void testError() {
<span class="fc" id="L99">        Observable&lt;String&gt; sourceStrings = Observable.just(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;, &quot;six&quot;);</span>
<span class="fc" id="L100">        Observable&lt;String&gt; errorSource = Observable.error(new RuntimeException(&quot;forced failure&quot;));</span>
<span class="fc" id="L101">        Observable&lt;String&gt; source = Observable.concat(sourceStrings, errorSource);</span>

<span class="fc" id="L103">        Observable&lt;GroupedObservable&lt;Integer, String&gt;&gt; grouped = source.groupBy(length);</span>

<span class="fc" id="L105">        final AtomicInteger groupCounter = new AtomicInteger();</span>
<span class="fc" id="L106">        final AtomicInteger eventCounter = new AtomicInteger();</span>
<span class="fc" id="L107">        final AtomicReference&lt;Throwable&gt; error = new AtomicReference&lt;Throwable&gt;();</span>

<span class="fc" id="L109">        grouped.flatMap(new Function&lt;GroupedObservable&lt;Integer, String&gt;, Observable&lt;String&gt;&gt;() {</span>

            @Override
            public Observable&lt;String&gt; apply(final GroupedObservable&lt;Integer, String&gt; o) {
<span class="fc" id="L113">                groupCounter.incrementAndGet();</span>
<span class="fc" id="L114">                return o.map(new Function&lt;String, String&gt;() {</span>

                    @Override
                    public String apply(String v) {
<span class="fc" id="L118">                        return &quot;Event =&gt; key: &quot; + o.getKey() + &quot; value: &quot; + v;</span>
                    }
                });
            }
<span class="fc" id="L122">        }).subscribe(new DefaultObserver&lt;String&gt;() {</span>

            @Override
            public void onComplete() {

<span class="nc" id="L127">            }</span>

            @Override
            public void onError(Throwable e) {
<span class="fc" id="L131">                e.printStackTrace();</span>
<span class="fc" id="L132">                error.set(e);</span>
<span class="fc" id="L133">            }</span>

            @Override
            public void onNext(String v) {
<span class="fc" id="L137">                eventCounter.incrementAndGet();</span>
<span class="fc" id="L138">                System.out.println(v);</span>

<span class="fc" id="L140">            }</span>
        });

<span class="fc" id="L143">        assertEquals(3, groupCounter.get());</span>
<span class="fc" id="L144">        assertEquals(6, eventCounter.get());</span>
<span class="fc" id="L145">        assertNotNull(error.get());</span>
<span class="fc" id="L146">    }</span>

    private static &lt;K, V&gt; Map&lt;K, Collection&lt;V&gt;&gt; toMap(Observable&lt;GroupedObservable&lt;K, V&gt;&gt; observable) {

<span class="fc" id="L150">        final ConcurrentHashMap&lt;K, Collection&lt;V&gt;&gt; result = new ConcurrentHashMap&lt;K, Collection&lt;V&gt;&gt;();</span>

<span class="fc" id="L152">        observable.blockingForEach(new Consumer&lt;GroupedObservable&lt;K, V&gt;&gt;() {</span>

            @Override
            public void accept(final GroupedObservable&lt;K, V&gt; o) {
<span class="fc" id="L156">                result.put(o.getKey(), new ConcurrentLinkedQueue&lt;V&gt;());</span>
<span class="fc" id="L157">                o.subscribe(new Consumer&lt;V&gt;() {</span>

                    @Override
                    public void accept(V v) {
<span class="fc" id="L161">                        result.get(o.getKey()).add(v);</span>
<span class="fc" id="L162">                    }</span>

                });
<span class="fc" id="L165">            }</span>
        });

<span class="fc" id="L168">        return result;</span>
    }

    /**
     * Assert that only a single subscription to a stream occurs and that all events are received.
     *
     * @throws Throwable some method may throw
     */
    @Test
    public void testGroupedEventStream() throws Throwable {

<span class="fc" id="L179">        final AtomicInteger eventCounter = new AtomicInteger();</span>
<span class="fc" id="L180">        final AtomicInteger subscribeCounter = new AtomicInteger();</span>
<span class="fc" id="L181">        final AtomicInteger groupCounter = new AtomicInteger();</span>
<span class="fc" id="L182">        final CountDownLatch latch = new CountDownLatch(1);</span>
<span class="fc" id="L183">        final int count = 100;</span>
<span class="fc" id="L184">        final int groupCount = 2;</span>

<span class="fc" id="L186">        Observable&lt;Event&gt; es = Observable.unsafeCreate(new ObservableSource&lt;Event&gt;() {</span>

            @Override
            public void subscribe(final Observer&lt;? super Event&gt; observer) {
<span class="fc" id="L190">                observer.onSubscribe(Disposables.empty());</span>
<span class="fc" id="L191">                System.out.println(&quot;*** Subscribing to EventStream ***&quot;);</span>
<span class="fc" id="L192">                subscribeCounter.incrementAndGet();</span>
<span class="fc" id="L193">                new Thread(new Runnable() {</span>

                    @Override
                    public void run() {
<span class="fc bfc" id="L197" title="All 2 branches covered.">                        for (int i = 0; i &lt; count; i++) {</span>
<span class="fc" id="L198">                            Event e = new Event();</span>
<span class="fc" id="L199">                            e.source = i % groupCount;</span>
<span class="fc" id="L200">                            e.message = &quot;Event-&quot; + i;</span>
<span class="fc" id="L201">                            observer.onNext(e);</span>
                        }
<span class="fc" id="L203">                        observer.onComplete();</span>
<span class="fc" id="L204">                    }</span>

<span class="fc" id="L206">                }).start();</span>
<span class="fc" id="L207">            }</span>

        });

<span class="fc" id="L211">        es.groupBy(new Function&lt;Event, Integer&gt;() {</span>

            @Override
            public Integer apply(Event e) {
<span class="fc" id="L215">                return e.source;</span>
            }
<span class="fc" id="L217">        }).flatMap(new Function&lt;GroupedObservable&lt;Integer, Event&gt;, Observable&lt;String&gt;&gt;() {</span>

            @Override
            public Observable&lt;String&gt; apply(GroupedObservable&lt;Integer, Event&gt; eventGroupedObservable) {
<span class="fc" id="L221">                System.out.println(&quot;GroupedObservable Key: &quot; + eventGroupedObservable.getKey());</span>
<span class="fc" id="L222">                groupCounter.incrementAndGet();</span>

<span class="fc" id="L224">                return eventGroupedObservable.map(new Function&lt;Event, String&gt;() {</span>

                    @Override
                    public String apply(Event event) {
<span class="fc" id="L228">                        return &quot;Source: &quot; + event.source + &quot;  Message: &quot; + event.message;</span>
                    }
                });

            }
<span class="fc" id="L233">        }).subscribe(new DefaultObserver&lt;String&gt;() {</span>

            @Override
            public void onComplete() {
<span class="fc" id="L237">                latch.countDown();</span>
<span class="fc" id="L238">            }</span>

            @Override
            public void onError(Throwable e) {
<span class="nc" id="L242">                e.printStackTrace();</span>
<span class="nc" id="L243">                latch.countDown();</span>
<span class="nc" id="L244">            }</span>

            @Override
            public void onNext(String outputMessage) {
<span class="fc" id="L248">                System.out.println(outputMessage);</span>
<span class="fc" id="L249">                eventCounter.incrementAndGet();</span>
<span class="fc" id="L250">            }</span>
        });

<span class="fc" id="L253">        latch.await(5000, TimeUnit.MILLISECONDS);</span>
<span class="fc" id="L254">        assertEquals(1, subscribeCounter.get());</span>
<span class="fc" id="L255">        assertEquals(groupCount, groupCounter.get());</span>
<span class="fc" id="L256">        assertEquals(count, eventCounter.get());</span>

<span class="fc" id="L258">    }</span>

    /*
     * We will only take 1 group with 20 events from it and then unsubscribe.
     */
    @Test
    public void testUnsubscribeOnNestedTakeAndSyncInfiniteStream() throws InterruptedException {
<span class="fc" id="L265">        final AtomicInteger subscribeCounter = new AtomicInteger();</span>
<span class="fc" id="L266">        final AtomicInteger sentEventCounter = new AtomicInteger();</span>
<span class="fc" id="L267">        doTestUnsubscribeOnNestedTakeAndAsyncInfiniteStream(SYNC_INFINITE_OBSERVABLE_OF_EVENT(2, subscribeCounter, sentEventCounter), subscribeCounter);</span>
<span class="fc" id="L268">        Thread.sleep(500);</span>
<span class="fc" id="L269">        assertEquals(39, sentEventCounter.get());</span>
<span class="fc" id="L270">    }</span>

    /*
     * We will only take 1 group with 20 events from it and then unsubscribe.
     */
    @Test
    public void testUnsubscribeOnNestedTakeAndAsyncInfiniteStream() throws InterruptedException {
<span class="fc" id="L277">        final AtomicInteger subscribeCounter = new AtomicInteger();</span>
<span class="fc" id="L278">        final AtomicInteger sentEventCounter = new AtomicInteger();</span>
<span class="fc" id="L279">        doTestUnsubscribeOnNestedTakeAndAsyncInfiniteStream(ASYNC_INFINITE_OBSERVABLE_OF_EVENT(2, subscribeCounter, sentEventCounter), subscribeCounter);</span>
<span class="fc" id="L280">        Thread.sleep(500);</span>
<span class="fc" id="L281">        assertEquals(39, sentEventCounter.get());</span>
<span class="fc" id="L282">    }</span>

    private void doTestUnsubscribeOnNestedTakeAndAsyncInfiniteStream(Observable&lt;Event&gt; es, AtomicInteger subscribeCounter) throws InterruptedException {
<span class="fc" id="L285">        final AtomicInteger eventCounter = new AtomicInteger();</span>
<span class="fc" id="L286">        final AtomicInteger groupCounter = new AtomicInteger();</span>
<span class="fc" id="L287">        final CountDownLatch latch = new CountDownLatch(1);</span>

<span class="fc" id="L289">        es.groupBy(new Function&lt;Event, Integer&gt;() {</span>

            @Override
            public Integer apply(Event e) {
<span class="fc" id="L293">                return e.source;</span>
            }
        })
<span class="fc" id="L296">                .take(1) // we want only the first group</span>
<span class="fc" id="L297">                .flatMap(new Function&lt;GroupedObservable&lt;Integer, Event&gt;, Observable&lt;String&gt;&gt;() {</span>

                    @Override
                    public Observable&lt;String&gt; apply(GroupedObservable&lt;Integer, Event&gt; eventGroupedObservable) {
<span class="fc" id="L301">                        System.out.println(&quot;testUnsubscribe =&gt; GroupedObservable Key: &quot; + eventGroupedObservable.getKey());</span>
<span class="fc" id="L302">                        groupCounter.incrementAndGet();</span>

<span class="fc" id="L304">                        return eventGroupedObservable</span>
<span class="fc" id="L305">                                .take(20) // limit to only 20 events on this group</span>
<span class="fc" id="L306">                                .map(new Function&lt;Event, String&gt;() {</span>

                                    @Override
                                    public String apply(Event event) {
<span class="fc" id="L310">                                        return &quot;testUnsubscribe =&gt; Source: &quot; + event.source + &quot;  Message: &quot; + event.message;</span>
                                    }
                                });

                    }
<span class="fc" id="L315">                }).subscribe(new DefaultObserver&lt;String&gt;() {</span>

                    @Override
                    public void onComplete() {
<span class="fc" id="L319">                        latch.countDown();</span>
<span class="fc" id="L320">                    }</span>

                    @Override
                    public void onError(Throwable e) {
<span class="nc" id="L324">                        e.printStackTrace();</span>
<span class="nc" id="L325">                        latch.countDown();</span>
<span class="nc" id="L326">                    }</span>

                    @Override
                    public void onNext(String outputMessage) {
<span class="fc" id="L330">                        System.out.println(outputMessage);</span>
<span class="fc" id="L331">                        eventCounter.incrementAndGet();</span>
<span class="fc" id="L332">                    }</span>
                });

<span class="pc bpc" id="L335" title="1 of 2 branches missed.">        if (!latch.await(2000, TimeUnit.MILLISECONDS)) {</span>
<span class="nc" id="L336">            fail(&quot;timed out so likely did not unsubscribe correctly&quot;);</span>
        }
<span class="fc" id="L338">        assertEquals(1, subscribeCounter.get());</span>
<span class="fc" id="L339">        assertEquals(1, groupCounter.get());</span>
<span class="fc" id="L340">        assertEquals(20, eventCounter.get());</span>
        // sentEvents will go until 'eventCounter' hits 20 and then unsubscribes
        // which means it will also send (but ignore) the 19/20 events for the other group
        // It will not however send all 100 events.
<span class="fc" id="L344">    }</span>

    @Test
    public void testUnsubscribeViaTakeOnGroupThenMergeAndTake() {
<span class="fc" id="L348">        final AtomicInteger subscribeCounter = new AtomicInteger();</span>
<span class="fc" id="L349">        final AtomicInteger sentEventCounter = new AtomicInteger();</span>
<span class="fc" id="L350">        final AtomicInteger eventCounter = new AtomicInteger();</span>

<span class="fc" id="L352">        SYNC_INFINITE_OBSERVABLE_OF_EVENT(4, subscribeCounter, sentEventCounter)</span>
<span class="fc" id="L353">                .groupBy(new Function&lt;Event, Integer&gt;() {</span>

                    @Override
                    public Integer apply(Event e) {
<span class="fc" id="L357">                        return e.source;</span>
                    }
                })
                // take 2 of the 4 groups
<span class="fc" id="L361">                .take(2)</span>
<span class="fc" id="L362">                .flatMap(new Function&lt;GroupedObservable&lt;Integer, Event&gt;, Observable&lt;String&gt;&gt;() {</span>

                    @Override
                    public Observable&lt;String&gt; apply(GroupedObservable&lt;Integer, Event&gt; eventGroupedObservable) {
<span class="fc" id="L366">                        return eventGroupedObservable</span>
<span class="fc" id="L367">                                .map(new Function&lt;Event, String&gt;() {</span>

                                    @Override
                                    public String apply(Event event) {
<span class="fc" id="L371">                                        return &quot;testUnsubscribe =&gt; Source: &quot; + event.source + &quot;  Message: &quot; + event.message;</span>
                                    }
                                });

                    }
                })
<span class="fc" id="L377">                .take(30).subscribe(new Consumer&lt;String&gt;() {</span>

                    @Override
                    public void accept(String s) {
<span class="fc" id="L381">                        eventCounter.incrementAndGet();</span>
<span class="fc" id="L382">                        System.out.println(&quot;=&gt; &quot; + s);</span>
<span class="fc" id="L383">                    }</span>

                });

<span class="fc" id="L387">        assertEquals(30, eventCounter.get());</span>
        // we should send 28 additional events that are filtered out as they are in the groups we skip
<span class="fc" id="L389">        assertEquals(58, sentEventCounter.get());</span>
<span class="fc" id="L390">    }</span>

    @Test
    public void testUnsubscribeViaTakeOnGroupThenTakeOnInner() {
<span class="fc" id="L394">        final AtomicInteger subscribeCounter = new AtomicInteger();</span>
<span class="fc" id="L395">        final AtomicInteger sentEventCounter = new AtomicInteger();</span>
<span class="fc" id="L396">        final AtomicInteger eventCounter = new AtomicInteger();</span>

<span class="fc" id="L398">        SYNC_INFINITE_OBSERVABLE_OF_EVENT(4, subscribeCounter, sentEventCounter)</span>
<span class="fc" id="L399">                .groupBy(new Function&lt;Event, Integer&gt;() {</span>

                    @Override
                    public Integer apply(Event e) {
<span class="fc" id="L403">                        return e.source;</span>
                    }
                })
                // take 2 of the 4 groups
<span class="fc" id="L407">                .take(2)</span>
<span class="fc" id="L408">                .flatMap(new Function&lt;GroupedObservable&lt;Integer, Event&gt;, Observable&lt;String&gt;&gt;() {</span>

                    @Override
                    public Observable&lt;String&gt; apply(GroupedObservable&lt;Integer, Event&gt; eventGroupedObservable) {
<span class="fc" id="L412">                        int numToTake = 0;</span>
<span class="fc bfc" id="L413" title="All 2 branches covered.">                        if (eventGroupedObservable.getKey() == 1) {</span>
<span class="fc" id="L414">                            numToTake = 10;</span>
<span class="pc bpc" id="L415" title="1 of 2 branches missed.">                        } else if (eventGroupedObservable.getKey() == 2) {</span>
<span class="fc" id="L416">                            numToTake = 5;</span>
                        }
<span class="fc" id="L418">                        return eventGroupedObservable</span>
<span class="fc" id="L419">                                .take(numToTake)</span>
<span class="fc" id="L420">                                .map(new Function&lt;Event, String&gt;() {</span>

                                    @Override
                                    public String apply(Event event) {
<span class="fc" id="L424">                                        return &quot;testUnsubscribe =&gt; Source: &quot; + event.source + &quot;  Message: &quot; + event.message;</span>
                                    }
                                });

                    }
                })
<span class="fc" id="L430">                .subscribe(new Consumer&lt;String&gt;() {</span>

                    @Override
                    public void accept(String s) {
<span class="fc" id="L434">                        eventCounter.incrementAndGet();</span>
<span class="fc" id="L435">                        System.out.println(&quot;=&gt; &quot; + s);</span>
<span class="fc" id="L436">                    }</span>

                });

<span class="fc" id="L440">        assertEquals(15, eventCounter.get());</span>
        // we should send 22 additional events that are filtered out as they are skipped while taking the 15 we want
<span class="fc" id="L442">        assertEquals(37, sentEventCounter.get());</span>
<span class="fc" id="L443">    }</span>

    @Test
    public void testStaggeredCompletion() throws InterruptedException {
<span class="fc" id="L447">        final AtomicInteger eventCounter = new AtomicInteger();</span>
<span class="fc" id="L448">        final CountDownLatch latch = new CountDownLatch(1);</span>
<span class="fc" id="L449">        Observable.range(0, 100)</span>
<span class="fc" id="L450">                .groupBy(new Function&lt;Integer, Integer&gt;() {</span>

                    @Override
                    public Integer apply(Integer i) {
<span class="fc" id="L454">                        return i % 2;</span>
                    }
                })
<span class="fc" id="L457">                .flatMap(new Function&lt;GroupedObservable&lt;Integer, Integer&gt;, Observable&lt;Integer&gt;&gt;() {</span>

                    @Override
                    public Observable&lt;Integer&gt; apply(GroupedObservable&lt;Integer, Integer&gt; group) {
<span class="fc bfc" id="L461" title="All 2 branches covered.">                        if (group.getKey() == 0) {</span>
<span class="fc" id="L462">                            return group.delay(100, TimeUnit.MILLISECONDS).map(new Function&lt;Integer, Integer&gt;() {</span>
                                @Override
                                public Integer apply(Integer t) {
<span class="fc" id="L465">                                    return t * 10;</span>
                                }

                            });
                        } else {
<span class="fc" id="L470">                            return group;</span>
                        }
                    }
                })
<span class="fc" id="L474">                .subscribe(new DefaultObserver&lt;Integer&gt;() {</span>

                    @Override
                    public void onComplete() {
<span class="fc" id="L478">                        System.out.println(&quot;=&gt; onComplete&quot;);</span>
<span class="fc" id="L479">                        latch.countDown();</span>
<span class="fc" id="L480">                    }</span>

                    @Override
                    public void onError(Throwable e) {
<span class="nc" id="L484">                        e.printStackTrace();</span>
<span class="nc" id="L485">                        latch.countDown();</span>
<span class="nc" id="L486">                    }</span>

                    @Override
                    public void onNext(Integer s) {
<span class="fc" id="L490">                        eventCounter.incrementAndGet();</span>
<span class="fc" id="L491">                        System.out.println(&quot;=&gt; &quot; + s);</span>
<span class="fc" id="L492">                    }</span>
                });

<span class="pc bpc" id="L495" title="1 of 2 branches missed.">        if (!latch.await(3000, TimeUnit.MILLISECONDS)) {</span>
<span class="nc" id="L496">            fail(&quot;timed out&quot;);</span>
        }

<span class="fc" id="L499">        assertEquals(100, eventCounter.get());</span>
<span class="fc" id="L500">    }</span>

    @Test(timeout = 1000)
    public void testCompletionIfInnerNotSubscribed() throws InterruptedException {
<span class="fc" id="L504">        final CountDownLatch latch = new CountDownLatch(1);</span>
<span class="fc" id="L505">        final AtomicInteger eventCounter = new AtomicInteger();</span>
<span class="fc" id="L506">        Observable.range(0, 100)</span>
<span class="fc" id="L507">                .groupBy(new Function&lt;Integer, Integer&gt;() {</span>

                    @Override
                    public Integer apply(Integer i) {
<span class="fc" id="L511">                        return i % 2;</span>
                    }
                })
<span class="fc" id="L514">                .subscribe(new DefaultObserver&lt;GroupedObservable&lt;Integer, Integer&gt;&gt;() {</span>

                    @Override
                    public void onComplete() {
<span class="fc" id="L518">                        latch.countDown();</span>
<span class="fc" id="L519">                    }</span>

                    @Override
                    public void onError(Throwable e) {
<span class="nc" id="L523">                        e.printStackTrace();</span>
<span class="nc" id="L524">                        latch.countDown();</span>
<span class="nc" id="L525">                    }</span>

                    @Override
                    public void onNext(GroupedObservable&lt;Integer, Integer&gt; s) {
<span class="fc" id="L529">                        eventCounter.incrementAndGet();</span>
<span class="fc" id="L530">                        System.out.println(&quot;=&gt; &quot; + s);</span>
<span class="fc" id="L531">                    }</span>
                });
<span class="pc bpc" id="L533" title="1 of 2 branches missed.">        if (!latch.await(500, TimeUnit.MILLISECONDS)) {</span>
<span class="nc" id="L534">            fail(&quot;timed out - never got completion&quot;);</span>
        }
<span class="fc" id="L536">        assertEquals(2, eventCounter.get());</span>
<span class="fc" id="L537">    }</span>

    @Test
    public void testIgnoringGroups() {
<span class="fc" id="L541">        final AtomicInteger subscribeCounter = new AtomicInteger();</span>
<span class="fc" id="L542">        final AtomicInteger sentEventCounter = new AtomicInteger();</span>
<span class="fc" id="L543">        final AtomicInteger eventCounter = new AtomicInteger();</span>

<span class="fc" id="L545">        SYNC_INFINITE_OBSERVABLE_OF_EVENT(4, subscribeCounter, sentEventCounter)</span>
<span class="fc" id="L546">                .groupBy(new Function&lt;Event, Integer&gt;() {</span>

                    @Override
                    public Integer apply(Event e) {
<span class="fc" id="L550">                        return e.source;</span>
                    }
                })
<span class="fc" id="L553">                .flatMap(new Function&lt;GroupedObservable&lt;Integer, Event&gt;, Observable&lt;String&gt;&gt;() {</span>

                    @Override
                    public Observable&lt;String&gt; apply(GroupedObservable&lt;Integer, Event&gt; eventGroupedObservable) {
<span class="fc" id="L557">                        Observable&lt;Event&gt; eventStream = eventGroupedObservable;</span>
<span class="fc bfc" id="L558" title="All 2 branches covered.">                        if (eventGroupedObservable.getKey() &gt;= 2) {</span>
                            // filter these
<span class="fc" id="L560">                            eventStream = eventGroupedObservable.filter(new Predicate&lt;Event&gt;() {</span>
                                @Override
                                public boolean test(Event t1) {
<span class="fc" id="L563">                                    return false;</span>
                                }
                            });
                        }

<span class="fc" id="L568">                        return eventStream</span>
<span class="fc" id="L569">                                .map(new Function&lt;Event, String&gt;() {</span>

                                    @Override
                                    public String apply(Event event) {
<span class="fc" id="L573">                                        return &quot;testUnsubscribe =&gt; Source: &quot; + event.source + &quot;  Message: &quot; + event.message;</span>
                                    }
                                });

                    }
                })
<span class="fc" id="L579">                .take(30).subscribe(new Consumer&lt;String&gt;() {</span>

                    @Override
                    public void accept(String s) {
<span class="fc" id="L583">                        eventCounter.incrementAndGet();</span>
<span class="fc" id="L584">                        System.out.println(&quot;=&gt; &quot; + s);</span>
<span class="fc" id="L585">                    }</span>

                });

<span class="fc" id="L589">        assertEquals(30, eventCounter.get());</span>
        // we should send 30 additional events that are filtered out as they are in the groups we skip
<span class="fc" id="L591">        assertEquals(60, sentEventCounter.get());</span>
<span class="fc" id="L592">    }</span>

    @Test
    public void testFirstGroupsCompleteAndParentSlowToThenEmitFinalGroupsAndThenComplete() throws InterruptedException {
<span class="fc" id="L596">        final CountDownLatch first = new CountDownLatch(2); // there are two groups to first complete</span>
<span class="fc" id="L597">        final ArrayList&lt;String&gt; results = new ArrayList&lt;String&gt;();</span>
<span class="fc" id="L598">        Observable.unsafeCreate(new ObservableSource&lt;Integer&gt;() {</span>

            @Override
            public void subscribe(Observer&lt;? super Integer&gt; sub) {
<span class="fc" id="L602">                sub.onSubscribe(Disposables.empty());</span>
<span class="fc" id="L603">                sub.onNext(1);</span>
<span class="fc" id="L604">                sub.onNext(2);</span>
<span class="fc" id="L605">                sub.onNext(1);</span>
<span class="fc" id="L606">                sub.onNext(2);</span>
                try {
<span class="fc" id="L608">                    first.await();</span>
<span class="nc" id="L609">                } catch (InterruptedException e) {</span>
<span class="nc" id="L610">                    sub.onError(e);</span>
<span class="nc" id="L611">                    return;</span>
<span class="fc" id="L612">                }</span>
<span class="fc" id="L613">                sub.onNext(3);</span>
<span class="fc" id="L614">                sub.onNext(3);</span>
<span class="fc" id="L615">                sub.onComplete();</span>
<span class="fc" id="L616">            }</span>

<span class="fc" id="L618">        }).groupBy(new Function&lt;Integer, Integer&gt;() {</span>

            @Override
            public Integer apply(Integer t) {
<span class="fc" id="L622">                return t;</span>
            }

<span class="fc" id="L625">        }).flatMap(new Function&lt;GroupedObservable&lt;Integer, Integer&gt;, Observable&lt;String&gt;&gt;() {</span>

            @Override
            public Observable&lt;String&gt; apply(final GroupedObservable&lt;Integer, Integer&gt; group) {
<span class="fc bfc" id="L629" title="All 2 branches covered.">                if (group.getKey() &lt; 3) {</span>
<span class="fc" id="L630">                    return group.map(new Function&lt;Integer, String&gt;() {</span>

                        @Override
                        public String apply(Integer t1) {
<span class="fc" id="L634">                            return &quot;first groups: &quot; + t1;</span>
                        }

                    })
                            // must take(2) so an onComplete + unsubscribe happens on these first 2 groups
<span class="fc" id="L639">                            .take(2).doOnComplete(new Action() {</span>

                                @Override
                                public void run() {
<span class="fc" id="L643">                                    first.countDown();</span>
<span class="fc" id="L644">                                }</span>

                            });
                } else {
<span class="fc" id="L648">                    return group.map(new Function&lt;Integer, String&gt;() {</span>

                        @Override
                        public String apply(Integer t1) {
<span class="fc" id="L652">                            return &quot;last group: &quot; + t1;</span>
                        }

                    });
                }
            }

<span class="fc" id="L659">        }).blockingForEach(new Consumer&lt;String&gt;() {</span>

            @Override
            public void accept(String s) {
<span class="fc" id="L663">                results.add(s);</span>
<span class="fc" id="L664">            }</span>

        });

<span class="fc" id="L668">        System.out.println(&quot;Results: &quot; + results);</span>
<span class="fc" id="L669">        assertEquals(6, results.size());</span>
<span class="fc" id="L670">    }</span>

    @Test
    public void testFirstGroupsCompleteAndParentSlowToThenEmitFinalGroupsWhichThenSubscribesOnAndDelaysAndThenCompletes() throws InterruptedException {
<span class="fc" id="L674">        System.err.println(&quot;----------------------------------------------------------------------------------------------&quot;);</span>
<span class="fc" id="L675">        final CountDownLatch first = new CountDownLatch(2); // there are two groups to first complete</span>
<span class="fc" id="L676">        final ArrayList&lt;String&gt; results = new ArrayList&lt;String&gt;();</span>
<span class="fc" id="L677">        Observable.unsafeCreate(new ObservableSource&lt;Integer&gt;() {</span>

            @Override
            public void subscribe(Observer&lt;? super Integer&gt; sub) {
<span class="fc" id="L681">                sub.onSubscribe(Disposables.empty());</span>
<span class="fc" id="L682">                sub.onNext(1);</span>
<span class="fc" id="L683">                sub.onNext(2);</span>
<span class="fc" id="L684">                sub.onNext(1);</span>
<span class="fc" id="L685">                sub.onNext(2);</span>
                try {
<span class="fc" id="L687">                    first.await();</span>
<span class="nc" id="L688">                } catch (InterruptedException e) {</span>
<span class="nc" id="L689">                    sub.onError(e);</span>
<span class="nc" id="L690">                    return;</span>
<span class="fc" id="L691">                }</span>
<span class="fc" id="L692">                sub.onNext(3);</span>
<span class="fc" id="L693">                sub.onNext(3);</span>
<span class="fc" id="L694">                sub.onComplete();</span>
<span class="fc" id="L695">            }</span>

<span class="fc" id="L697">        }).groupBy(new Function&lt;Integer, Integer&gt;() {</span>

            @Override
            public Integer apply(Integer t) {
<span class="fc" id="L701">                return t;</span>
            }

<span class="fc" id="L704">        }).flatMap(new Function&lt;GroupedObservable&lt;Integer, Integer&gt;, Observable&lt;String&gt;&gt;() {</span>

            @Override
            public Observable&lt;String&gt; apply(final GroupedObservable&lt;Integer, Integer&gt; group) {
<span class="fc bfc" id="L708" title="All 2 branches covered.">                if (group.getKey() &lt; 3) {</span>
<span class="fc" id="L709">                    return group.map(new Function&lt;Integer, String&gt;() {</span>

                        @Override
                        public String apply(Integer t1) {
<span class="fc" id="L713">                            return &quot;first groups: &quot; + t1;</span>
                        }

                    })
                            // must take(2) so an onComplete + unsubscribe happens on these first 2 groups
<span class="fc" id="L718">                            .take(2).doOnComplete(new Action() {</span>

                                @Override
                                public void run() {
<span class="fc" id="L722">                                    first.countDown();</span>
<span class="fc" id="L723">                                }</span>

                            });
                } else {
<span class="fc" id="L727">                    return group.subscribeOn(Schedulers.newThread()).delay(400, TimeUnit.MILLISECONDS).map(new Function&lt;Integer, String&gt;() {</span>

                        @Override
                        public String apply(Integer t1) {
<span class="fc" id="L731">                            return &quot;last group: &quot; + t1;</span>
                        }

<span class="fc" id="L734">                    }).doOnEach(new Consumer&lt;Notification&lt;String&gt;&gt;() {</span>

                        @Override
                        public void accept(Notification&lt;String&gt; t1) {
<span class="fc" id="L738">                            System.err.println(&quot;subscribeOn notification =&gt; &quot; + t1);</span>
<span class="fc" id="L739">                        }</span>

                    });
                }
            }

<span class="fc" id="L745">        }).doOnEach(new Consumer&lt;Notification&lt;String&gt;&gt;() {</span>

            @Override
            public void accept(Notification&lt;String&gt; t1) {
<span class="fc" id="L749">                System.err.println(&quot;outer notification =&gt; &quot; + t1);</span>
<span class="fc" id="L750">            }</span>

<span class="fc" id="L752">        }).blockingForEach(new Consumer&lt;String&gt;() {</span>

            @Override
            public void accept(String s) {
<span class="fc" id="L756">                results.add(s);</span>
<span class="fc" id="L757">            }</span>

        });

<span class="fc" id="L761">        System.out.println(&quot;Results: &quot; + results);</span>
<span class="fc" id="L762">        assertEquals(6, results.size());</span>
<span class="fc" id="L763">    }</span>

    @Test
    public void testFirstGroupsCompleteAndParentSlowToThenEmitFinalGroupsWhichThenObservesOnAndDelaysAndThenCompletes() throws InterruptedException {
<span class="fc" id="L767">        final CountDownLatch first = new CountDownLatch(2); // there are two groups to first complete</span>
<span class="fc" id="L768">        final ArrayList&lt;String&gt; results = new ArrayList&lt;String&gt;();</span>
<span class="fc" id="L769">        Observable.unsafeCreate(new ObservableSource&lt;Integer&gt;() {</span>

            @Override
            public void subscribe(Observer&lt;? super Integer&gt; sub) {
<span class="fc" id="L773">                sub.onSubscribe(Disposables.empty());</span>
<span class="fc" id="L774">                sub.onNext(1);</span>
<span class="fc" id="L775">                sub.onNext(2);</span>
<span class="fc" id="L776">                sub.onNext(1);</span>
<span class="fc" id="L777">                sub.onNext(2);</span>
                try {
<span class="fc" id="L779">                    first.await();</span>
<span class="nc" id="L780">                } catch (InterruptedException e) {</span>
<span class="nc" id="L781">                    sub.onError(e);</span>
<span class="nc" id="L782">                    return;</span>
<span class="fc" id="L783">                }</span>
<span class="fc" id="L784">                sub.onNext(3);</span>
<span class="fc" id="L785">                sub.onNext(3);</span>
<span class="fc" id="L786">                sub.onComplete();</span>
<span class="fc" id="L787">            }</span>

<span class="fc" id="L789">        }).groupBy(new Function&lt;Integer, Integer&gt;() {</span>

            @Override
            public Integer apply(Integer t) {
<span class="fc" id="L793">                return t;</span>
            }

<span class="fc" id="L796">        }).flatMap(new Function&lt;GroupedObservable&lt;Integer, Integer&gt;, Observable&lt;String&gt;&gt;() {</span>

            @Override
            public Observable&lt;String&gt; apply(final GroupedObservable&lt;Integer, Integer&gt; group) {
<span class="fc bfc" id="L800" title="All 2 branches covered.">                if (group.getKey() &lt; 3) {</span>
<span class="fc" id="L801">                    return group.map(new Function&lt;Integer, String&gt;() {</span>

                        @Override
                        public String apply(Integer t1) {
<span class="fc" id="L805">                            return &quot;first groups: &quot; + t1;</span>
                        }

                    })
                            // must take(2) so an onComplete + unsubscribe happens on these first 2 groups
<span class="fc" id="L810">                            .take(2).doOnComplete(new Action() {</span>

                                @Override
                                public void run() {
<span class="fc" id="L814">                                    first.countDown();</span>
<span class="fc" id="L815">                                }</span>

                            });
                } else {
<span class="fc" id="L819">                    return group.observeOn(Schedulers.newThread()).delay(400, TimeUnit.MILLISECONDS).map(new Function&lt;Integer, String&gt;() {</span>

                        @Override
                        public String apply(Integer t1) {
<span class="fc" id="L823">                            return &quot;last group: &quot; + t1;</span>
                        }

                    });
                }
            }

<span class="fc" id="L830">        }).blockingForEach(new Consumer&lt;String&gt;() {</span>

            @Override
            public void accept(String s) {
<span class="fc" id="L834">                results.add(s);</span>
<span class="fc" id="L835">            }</span>

        });

<span class="fc" id="L839">        System.out.println(&quot;Results: &quot; + results);</span>
<span class="fc" id="L840">        assertEquals(6, results.size());</span>
<span class="fc" id="L841">    }</span>

    @Test
    public void testGroupsWithNestedSubscribeOn() throws InterruptedException {
<span class="fc" id="L845">        final ArrayList&lt;String&gt; results = new ArrayList&lt;String&gt;();</span>
<span class="fc" id="L846">        Observable.unsafeCreate(new ObservableSource&lt;Integer&gt;() {</span>

            @Override
            public void subscribe(Observer&lt;? super Integer&gt; sub) {
<span class="fc" id="L850">                sub.onSubscribe(Disposables.empty());</span>
<span class="fc" id="L851">                sub.onNext(1);</span>
<span class="fc" id="L852">                sub.onNext(2);</span>
<span class="fc" id="L853">                sub.onNext(1);</span>
<span class="fc" id="L854">                sub.onNext(2);</span>
<span class="fc" id="L855">                sub.onComplete();</span>
<span class="fc" id="L856">            }</span>

<span class="fc" id="L858">        }).groupBy(new Function&lt;Integer, Integer&gt;() {</span>

            @Override
            public Integer apply(Integer t) {
<span class="fc" id="L862">                return t;</span>
            }

<span class="fc" id="L865">        }).flatMap(new Function&lt;GroupedObservable&lt;Integer, Integer&gt;, Observable&lt;String&gt;&gt;() {</span>

            @Override
            public Observable&lt;String&gt; apply(final GroupedObservable&lt;Integer, Integer&gt; group) {
<span class="fc" id="L869">                return group.subscribeOn(Schedulers.newThread()).map(new Function&lt;Integer, String&gt;() {</span>

                    @Override
                    public String apply(Integer t1) {
<span class="fc" id="L873">                        System.out.println(&quot;Received: &quot; + t1 + &quot; on group : &quot; + group.getKey());</span>
<span class="fc" id="L874">                        return &quot;first groups: &quot; + t1;</span>
                    }

                });
            }

<span class="fc" id="L880">        }).doOnEach(new Consumer&lt;Notification&lt;String&gt;&gt;() {</span>

            @Override
            public void accept(Notification&lt;String&gt; t1) {
<span class="fc" id="L884">                System.out.println(&quot;notification =&gt; &quot; + t1);</span>
<span class="fc" id="L885">            }</span>

<span class="fc" id="L887">        }).blockingForEach(new Consumer&lt;String&gt;() {</span>

            @Override
            public void accept(String s) {
<span class="fc" id="L891">                results.add(s);</span>
<span class="fc" id="L892">            }</span>

        });

<span class="fc" id="L896">        System.out.println(&quot;Results: &quot; + results);</span>
<span class="fc" id="L897">        assertEquals(4, results.size());</span>
<span class="fc" id="L898">    }</span>

    @Test
    public void testGroupsWithNestedObserveOn() throws InterruptedException {
<span class="fc" id="L902">        final ArrayList&lt;String&gt; results = new ArrayList&lt;String&gt;();</span>
<span class="fc" id="L903">        Observable.unsafeCreate(new ObservableSource&lt;Integer&gt;() {</span>

            @Override
            public void subscribe(Observer&lt;? super Integer&gt; sub) {
<span class="fc" id="L907">                sub.onSubscribe(Disposables.empty());</span>
<span class="fc" id="L908">                sub.onNext(1);</span>
<span class="fc" id="L909">                sub.onNext(2);</span>
<span class="fc" id="L910">                sub.onNext(1);</span>
<span class="fc" id="L911">                sub.onNext(2);</span>
<span class="fc" id="L912">                sub.onComplete();</span>
<span class="fc" id="L913">            }</span>

<span class="fc" id="L915">        }).groupBy(new Function&lt;Integer, Integer&gt;() {</span>

            @Override
            public Integer apply(Integer t) {
<span class="fc" id="L919">                return t;</span>
            }

<span class="fc" id="L922">        }).flatMap(new Function&lt;GroupedObservable&lt;Integer, Integer&gt;, Observable&lt;String&gt;&gt;() {</span>

            @Override
            public Observable&lt;String&gt; apply(final GroupedObservable&lt;Integer, Integer&gt; group) {
<span class="fc" id="L926">                return group.observeOn(Schedulers.newThread()).delay(400, TimeUnit.MILLISECONDS).map(new Function&lt;Integer, String&gt;() {</span>

                    @Override
                    public String apply(Integer t1) {
<span class="fc" id="L930">                        return &quot;first groups: &quot; + t1;</span>
                    }

                });
            }

<span class="fc" id="L936">        }).blockingForEach(new Consumer&lt;String&gt;() {</span>

            @Override
            public void accept(String s) {
<span class="fc" id="L940">                results.add(s);</span>
<span class="fc" id="L941">            }</span>

        });

<span class="fc" id="L945">        System.out.println(&quot;Results: &quot; + results);</span>
<span class="fc" id="L946">        assertEquals(4, results.size());</span>
<span class="fc" id="L947">    }</span>

    private static class Event {
        int source;
        String message;

        @Override
        public String toString() {
<span class="nc" id="L955">            return &quot;Event =&gt; source: &quot; + source + &quot; message: &quot; + message;</span>
        }
    }

    Observable&lt;Event&gt; ASYNC_INFINITE_OBSERVABLE_OF_EVENT(final int numGroups, final AtomicInteger subscribeCounter, final AtomicInteger sentEventCounter) {
<span class="fc" id="L960">        return SYNC_INFINITE_OBSERVABLE_OF_EVENT(numGroups, subscribeCounter, sentEventCounter).subscribeOn(Schedulers.newThread());</span>
    };

    Observable&lt;Event&gt; SYNC_INFINITE_OBSERVABLE_OF_EVENT(final int numGroups, final AtomicInteger subscribeCounter, final AtomicInteger sentEventCounter) {
<span class="fc" id="L964">        return Observable.unsafeCreate(new ObservableSource&lt;Event&gt;() {</span>

            @Override
            public void subscribe(final Observer&lt;? super Event&gt; op) {
<span class="fc" id="L968">                Disposable d = Disposables.empty();</span>
<span class="fc" id="L969">                op.onSubscribe(d);</span>
<span class="fc" id="L970">                subscribeCounter.incrementAndGet();</span>
<span class="fc" id="L971">                int i = 0;</span>
<span class="fc bfc" id="L972" title="All 2 branches covered.">                while (!d.isDisposed()) {</span>
<span class="fc" id="L973">                    i++;</span>
<span class="fc" id="L974">                    Event e = new Event();</span>
<span class="fc" id="L975">                    e.source = i % numGroups;</span>
<span class="fc" id="L976">                    e.message = &quot;Event-&quot; + i;</span>
<span class="fc" id="L977">                    op.onNext(e);</span>
<span class="fc" id="L978">                    sentEventCounter.incrementAndGet();</span>
<span class="fc" id="L979">                }</span>
<span class="fc" id="L980">                op.onComplete();</span>
<span class="fc" id="L981">            }</span>

        });
    };

    @Test
    public void testGroupByOnAsynchronousSourceAcceptsMultipleSubscriptions() throws InterruptedException {

        // choose an asynchronous source
<span class="fc" id="L990">        Observable&lt;Long&gt; source = Observable.interval(10, TimeUnit.MILLISECONDS).take(1);</span>

        // apply groupBy to the source
<span class="fc" id="L993">        Observable&lt;GroupedObservable&lt;Boolean, Long&gt;&gt; stream = source.groupBy(IS_EVEN);</span>

        // create two observers
<span class="fc" id="L996">        Observer&lt;GroupedObservable&lt;Boolean, Long&gt;&gt; o1 = TestHelper.mockObserver();</span>
<span class="fc" id="L997">        Observer&lt;GroupedObservable&lt;Boolean, Long&gt;&gt; o2 = TestHelper.mockObserver();</span>

        // subscribe with the observers
<span class="fc" id="L1000">        stream.subscribe(o1);</span>
<span class="fc" id="L1001">        stream.subscribe(o2);</span>

        // check that subscriptions were successful
<span class="fc" id="L1004">        verify(o1, never()).onError(Mockito.&lt;Throwable&gt; any());</span>
<span class="fc" id="L1005">        verify(o2, never()).onError(Mockito.&lt;Throwable&gt; any());</span>
<span class="fc" id="L1006">    }</span>

<span class="fc" id="L1008">    private static Function&lt;Long, Boolean&gt; IS_EVEN = new Function&lt;Long, Boolean&gt;() {</span>

        @Override
        public Boolean apply(Long n) {
<span class="pc bpc" id="L1012" title="1 of 2 branches missed.">            return n % 2 == 0;</span>
        }
    };

<span class="fc" id="L1016">    private static Function&lt;Integer, Boolean&gt; IS_EVEN2 = new Function&lt;Integer, Boolean&gt;() {</span>

        @Override
        public Boolean apply(Integer n) {
<span class="fc bfc" id="L1020" title="All 2 branches covered.">            return n % 2 == 0;</span>
        }
    };

    @Test
    public void testGroupByBackpressure() throws InterruptedException {

<span class="fc" id="L1027">        TestObserver&lt;String&gt; to = new TestObserver&lt;String&gt;();</span>

<span class="fc" id="L1029">        Observable.range(1, 4000)</span>
<span class="fc" id="L1030">                .groupBy(IS_EVEN2)</span>
<span class="fc" id="L1031">                .flatMap(new Function&lt;GroupedObservable&lt;Boolean, Integer&gt;, Observable&lt;String&gt;&gt;() {</span>

                    @Override
                    public Observable&lt;String&gt; apply(final GroupedObservable&lt;Boolean, Integer&gt; g) {
<span class="fc" id="L1035">                        return g.observeOn(Schedulers.computation()).map(new Function&lt;Integer, String&gt;() {</span>

                            @Override
                            public String apply(Integer l) {
<span class="fc bfc" id="L1039" title="All 2 branches covered.">                                if (g.getKey()) {</span>
                                    try {
<span class="fc" id="L1041">                                        Thread.sleep(1);</span>
<span class="nc" id="L1042">                                    } catch (InterruptedException e) {</span>
<span class="fc" id="L1043">                                    }</span>
<span class="fc" id="L1044">                                    return l + &quot; is even.&quot;;</span>
                                } else {
<span class="fc" id="L1046">                                    return l + &quot; is odd.&quot;;</span>
                                }
                            }

                        });
                    }

<span class="fc" id="L1053">                }).subscribe(to);</span>
<span class="fc" id="L1054">        to.awaitTerminalEvent();</span>
<span class="fc" id="L1055">        to.assertNoErrors();</span>
<span class="fc" id="L1056">    }</span>

    &lt;T, R&gt; Function&lt;T, R&gt; just(final R value) {
<span class="nc" id="L1059">        return new Function&lt;T, R&gt;() {</span>
            @Override
            public R apply(T t1) {
<span class="nc" id="L1062">                return value;</span>
            }
        };
    }

    &lt;T&gt; Function&lt;Integer, T&gt; fail(T dummy) {
<span class="fc" id="L1068">        return new Function&lt;Integer, T&gt;() {</span>
            @Override
            public T apply(Integer t1) {
<span class="fc" id="L1071">                throw new RuntimeException(&quot;Forced failure&quot;);</span>
            }
        };
    }

    &lt;T, R&gt; Function&lt;T, R&gt; fail2(R dummy2) {
<span class="nc" id="L1077">        return new Function&lt;T, R&gt;() {</span>
            @Override
            public R apply(T t1) {
<span class="nc" id="L1080">                throw new RuntimeException(&quot;Forced failure&quot;);</span>
            }
        };
    }

<span class="fc" id="L1085">    Function&lt;Integer, Integer&gt; dbl = new Function&lt;Integer, Integer&gt;() {</span>
        @Override
        public Integer apply(Integer t1) {
<span class="fc" id="L1088">            return t1 * 2;</span>
        }
    };
<span class="fc" id="L1091">    Function&lt;Integer, Integer&gt; identity = new Function&lt;Integer, Integer&gt;() {</span>
        @Override
        public Integer apply(Integer v) {
<span class="fc" id="L1094">            return v;</span>
        }
    };

    @Test
    public void normalBehavior() {
<span class="fc" id="L1100">        Observable&lt;String&gt; source = Observable.fromIterable(Arrays.asList(</span>
                &quot;  foo&quot;,
                &quot; FoO &quot;,
                &quot;baR  &quot;,
                &quot;foO &quot;,
                &quot; Baz   &quot;,
                &quot;  qux &quot;,
                &quot;   bar&quot;,
                &quot; BAR  &quot;,
                &quot;FOO &quot;,
                &quot;baz  &quot;,
                &quot; bAZ &quot;,
                &quot;    fOo    &quot;
                ));

        /*
         * foo FoO foO FOO fOo
         * baR bar BAR
         * Baz baz bAZ
         * qux
         *
         */
<span class="fc" id="L1122">        Function&lt;String, String&gt; keysel = new Function&lt;String, String&gt;() {</span>
            @Override
            public String apply(String t1) {
<span class="fc" id="L1125">                return t1.trim().toLowerCase();</span>
            }
        };
<span class="fc" id="L1128">        Function&lt;String, String&gt; valuesel = new Function&lt;String, String&gt;() {</span>
            @Override
            public String apply(String t1) {
<span class="fc" id="L1131">                return t1 + t1;</span>
            }
        };

<span class="fc" id="L1135">        Observable&lt;String&gt; m = source.groupBy(keysel, valuesel)</span>
<span class="fc" id="L1136">        .flatMap(new Function&lt;GroupedObservable&lt;String, String&gt;, Observable&lt;String&gt;&gt;() {</span>
            @Override
            public Observable&lt;String&gt; apply(final GroupedObservable&lt;String, String&gt; g) {
<span class="fc" id="L1139">                System.out.println(&quot;-----------&gt; NEXT: &quot; + g.getKey());</span>
<span class="fc" id="L1140">                return g.take(2).map(new Function&lt;String, String&gt;() {</span>

                    int count;

                    @Override
                    public String apply(String v) {
<span class="fc" id="L1146">                        System.out.println(v);</span>
<span class="fc" id="L1147">                        return g.getKey() + &quot;-&quot; + count++;</span>
                    }

                });
            }
        });

<span class="fc" id="L1154">        TestObserver&lt;String&gt; to = new TestObserver&lt;String&gt;();</span>
<span class="fc" id="L1155">        m.subscribe(to);</span>
<span class="fc" id="L1156">        to.awaitTerminalEvent();</span>
<span class="fc" id="L1157">        System.out.println(&quot;ts .get &quot; + to.values());</span>
<span class="fc" id="L1158">        to.assertNoErrors();</span>
<span class="fc" id="L1159">        assertEquals(to.values(),</span>
<span class="fc" id="L1160">                Arrays.asList(&quot;foo-0&quot;, &quot;foo-1&quot;, &quot;bar-0&quot;, &quot;foo-0&quot;, &quot;baz-0&quot;, &quot;qux-0&quot;, &quot;bar-1&quot;, &quot;bar-0&quot;, &quot;foo-1&quot;, &quot;baz-1&quot;, &quot;baz-0&quot;, &quot;foo-0&quot;));</span>

<span class="fc" id="L1162">    }</span>

    @Test
    public void keySelectorThrows() {
<span class="fc" id="L1166">        Observable&lt;Integer&gt; source = Observable.just(0, 1, 2, 3, 4, 5, 6);</span>

<span class="fc" id="L1168">        Observable&lt;Integer&gt; m = source.groupBy(fail(0), dbl).flatMap(FLATTEN_INTEGER);</span>

<span class="fc" id="L1170">        TestObserver&lt;Integer&gt; to = new TestObserver&lt;Integer&gt;();</span>
<span class="fc" id="L1171">        m.subscribe(to);</span>
<span class="fc" id="L1172">        to.awaitTerminalEvent();</span>
<span class="fc" id="L1173">        assertEquals(1, to.errorCount());</span>
<span class="fc" id="L1174">        to.assertNoValues();</span>
<span class="fc" id="L1175">    }</span>

    @Test
    public void valueSelectorThrows() {
<span class="fc" id="L1179">        Observable&lt;Integer&gt; source = Observable.just(0, 1, 2, 3, 4, 5, 6);</span>

<span class="fc" id="L1181">        Observable&lt;Integer&gt; m = source.groupBy(identity, fail(0)).flatMap(FLATTEN_INTEGER);</span>
<span class="fc" id="L1182">        TestObserver&lt;Integer&gt; to = new TestObserver&lt;Integer&gt;();</span>
<span class="fc" id="L1183">        m.subscribe(to);</span>
<span class="fc" id="L1184">        to.awaitTerminalEvent();</span>
<span class="fc" id="L1185">        assertEquals(1, to.errorCount());</span>
<span class="fc" id="L1186">        to.assertNoValues();</span>

<span class="fc" id="L1188">    }</span>

    @Test
    public void innerEscapeCompleted() {
<span class="fc" id="L1192">        Observable&lt;Integer&gt; source = Observable.just(0);</span>

<span class="fc" id="L1194">        Observable&lt;Integer&gt; m = source.groupBy(identity, dbl).flatMap(FLATTEN_INTEGER);</span>

<span class="fc" id="L1196">        TestObserver&lt;Object&gt; to = new TestObserver&lt;Object&gt;();</span>
<span class="fc" id="L1197">        m.subscribe(to);</span>
<span class="fc" id="L1198">        to.awaitTerminalEvent();</span>
<span class="fc" id="L1199">        to.assertNoErrors();</span>
<span class="fc" id="L1200">        System.out.println(to.values());</span>
<span class="fc" id="L1201">    }</span>

    /**
     * Assert we get an IllegalStateException if trying to subscribe to an inner GroupedObservable more than once.
     */
    @Test
    public void testExceptionIfSubscribeToChildMoreThanOnce() {
<span class="fc" id="L1208">        Observable&lt;Integer&gt; source = Observable.just(0);</span>

<span class="fc" id="L1210">        final AtomicReference&lt;GroupedObservable&lt;Integer, Integer&gt;&gt; inner = new AtomicReference&lt;GroupedObservable&lt;Integer, Integer&gt;&gt;();</span>

<span class="fc" id="L1212">        Observable&lt;GroupedObservable&lt;Integer, Integer&gt;&gt; m = source.groupBy(identity, dbl);</span>

<span class="fc" id="L1214">        m.subscribe(new Consumer&lt;GroupedObservable&lt;Integer, Integer&gt;&gt;() {</span>
            @Override
            public void accept(GroupedObservable&lt;Integer, Integer&gt; t1) {
<span class="fc" id="L1217">                inner.set(t1);</span>
<span class="fc" id="L1218">            }</span>
        });

<span class="fc" id="L1221">        inner.get().subscribe();</span>

<span class="fc" id="L1223">        Observer&lt;Integer&gt; o2 = TestHelper.mockObserver();</span>

<span class="fc" id="L1225">        inner.get().subscribe(o2);</span>

<span class="fc" id="L1227">        verify(o2, never()).onComplete();</span>
<span class="fc" id="L1228">        verify(o2, never()).onNext(anyInt());</span>
<span class="fc" id="L1229">        verify(o2).onError(any(IllegalStateException.class));</span>
<span class="fc" id="L1230">    }</span>

    @Test
    public void testError2() {
<span class="fc" id="L1234">        Observable&lt;Integer&gt; source = Observable.concat(Observable.just(0),</span>
<span class="fc" id="L1235">                Observable.&lt;Integer&gt; error(new TestException(&quot;Forced failure&quot;)));</span>

<span class="fc" id="L1237">        Observable&lt;Integer&gt; m = source.groupBy(identity, dbl).flatMap(FLATTEN_INTEGER);</span>

<span class="fc" id="L1239">        TestObserver&lt;Object&gt; to = new TestObserver&lt;Object&gt;();</span>
<span class="fc" id="L1240">        m.subscribe(to);</span>
<span class="fc" id="L1241">        to.awaitTerminalEvent();</span>
<span class="fc" id="L1242">        assertEquals(1, to.errorCount());</span>
<span class="fc" id="L1243">        to.assertValueCount(1);</span>
<span class="fc" id="L1244">    }</span>

    @Test
    public void testgroupByBackpressure() throws InterruptedException {
<span class="fc" id="L1248">        TestObserver&lt;String&gt; to = new TestObserver&lt;String&gt;();</span>

<span class="fc" id="L1250">        Observable.range(1, 4000).groupBy(IS_EVEN2).flatMap(new Function&lt;GroupedObservable&lt;Boolean, Integer&gt;, Observable&lt;String&gt;&gt;() {</span>

            @Override
            public Observable&lt;String&gt; apply(final GroupedObservable&lt;Boolean, Integer&gt; g) {
<span class="fc" id="L1254">                return g.doOnComplete(new Action() {</span>

                    @Override
                    public void run() {
<span class="fc" id="L1258">                        System.out.println(&quot;//////////////////// COMPLETED-A&quot;);</span>
<span class="fc" id="L1259">                    }</span>

<span class="fc" id="L1261">                }).observeOn(Schedulers.computation()).map(new Function&lt;Integer, String&gt;() {</span>

                    int c;

                    @Override
                    public String apply(Integer l) {
<span class="fc bfc" id="L1267" title="All 2 branches covered.">                        if (g.getKey()) {</span>
<span class="fc bfc" id="L1268" title="All 2 branches covered.">                            if (c++ &lt; 400) {</span>
                                try {
<span class="fc" id="L1270">                                    Thread.sleep(1);</span>
<span class="nc" id="L1271">                                } catch (InterruptedException e) {</span>
<span class="fc" id="L1272">                                }</span>
                            }
<span class="fc" id="L1274">                            return l + &quot; is even.&quot;;</span>
                        } else {
<span class="fc" id="L1276">                            return l + &quot; is odd.&quot;;</span>
                        }
                    }

<span class="fc" id="L1280">                }).doOnComplete(new Action() {</span>

                    @Override
                    public void run() {
<span class="fc" id="L1284">                        System.out.println(&quot;//////////////////// COMPLETED-B&quot;);</span>
<span class="fc" id="L1285">                    }</span>

                });
            }

<span class="fc" id="L1290">        }).doOnEach(new Consumer&lt;Notification&lt;String&gt;&gt;() {</span>

            @Override
            public void accept(Notification&lt;String&gt; t1) {
<span class="fc" id="L1294">                System.out.println(&quot;NEXT: &quot; + t1);</span>
<span class="fc" id="L1295">            }</span>

<span class="fc" id="L1297">        }).subscribe(to);</span>
<span class="fc" id="L1298">        to.awaitTerminalEvent();</span>
<span class="fc" id="L1299">        to.assertNoErrors();</span>
<span class="fc" id="L1300">    }</span>

    @Test
    public void testgroupByBackpressure2() throws InterruptedException {

<span class="fc" id="L1305">        TestObserver&lt;String&gt; to = new TestObserver&lt;String&gt;();</span>

<span class="fc" id="L1307">        Observable.range(1, 4000).groupBy(IS_EVEN2).flatMap(new Function&lt;GroupedObservable&lt;Boolean, Integer&gt;, Observable&lt;String&gt;&gt;() {</span>

            @Override
            public Observable&lt;String&gt; apply(final GroupedObservable&lt;Boolean, Integer&gt; g) {
<span class="fc" id="L1311">                return g.take(2).observeOn(Schedulers.computation()).map(new Function&lt;Integer, String&gt;() {</span>

                    @Override
                    public String apply(Integer l) {
<span class="fc bfc" id="L1315" title="All 2 branches covered.">                        if (g.getKey()) {</span>
                            try {
<span class="fc" id="L1317">                                Thread.sleep(1);</span>
<span class="nc" id="L1318">                            } catch (InterruptedException e) {</span>
<span class="fc" id="L1319">                            }</span>
<span class="fc" id="L1320">                            return l + &quot; is even.&quot;;</span>
                        } else {
<span class="fc" id="L1322">                            return l + &quot; is odd.&quot;;</span>
                        }
                    }

                });
            }

<span class="fc" id="L1329">        }).subscribe(to);</span>
<span class="fc" id="L1330">        to.awaitTerminalEvent();</span>
<span class="fc" id="L1331">        to.assertNoErrors();</span>
<span class="fc" id="L1332">    }</span>

<span class="fc" id="L1334">    static Function&lt;GroupedObservable&lt;Integer, Integer&gt;, Observable&lt;Integer&gt;&gt; FLATTEN_INTEGER = new Function&lt;GroupedObservable&lt;Integer, Integer&gt;, Observable&lt;Integer&gt;&gt;() {</span>

        @Override
        public Observable&lt;Integer&gt; apply(GroupedObservable&lt;Integer, Integer&gt; t) {
<span class="fc" id="L1338">            return t;</span>
        }

    };

    @Test
    public void testGroupByWithNullKey() {
<span class="fc" id="L1345">        final String[] key = new String[]{&quot;uninitialized&quot;};</span>
<span class="fc" id="L1346">        final List&lt;String&gt; values = new ArrayList&lt;String&gt;();</span>
<span class="fc" id="L1347">        Observable.just(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;).groupBy(new Function&lt;String, String&gt;() {</span>

            @Override
            public String apply(String value) {
<span class="fc" id="L1351">                return null;</span>
            }
<span class="fc" id="L1353">        }).subscribe(new Consumer&lt;GroupedObservable&lt;String, String&gt;&gt;() {</span>

            @Override
            public void accept(GroupedObservable&lt;String, String&gt; groupedObservable) {
<span class="fc" id="L1357">                key[0] = groupedObservable.getKey();</span>
<span class="fc" id="L1358">                groupedObservable.subscribe(new Consumer&lt;String&gt;() {</span>

                    @Override
                    public void accept(String s) {
<span class="fc" id="L1362">                        values.add(s);</span>
<span class="fc" id="L1363">                    }</span>
                });
<span class="fc" id="L1365">            }</span>
        });
<span class="fc" id="L1367">        assertEquals(null, key[0]);</span>
<span class="fc" id="L1368">        assertEquals(Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), values);</span>
<span class="fc" id="L1369">    }</span>

    @Test
    public void testGroupByUnsubscribe() {
<span class="fc" id="L1373">        final Disposable upstream = mock(Disposable.class);</span>
<span class="fc" id="L1374">        Observable&lt;Integer&gt; o = Observable.unsafeCreate(</span>
<span class="fc" id="L1375">                new ObservableSource&lt;Integer&gt;() {</span>
                    @Override
                    public void subscribe(Observer&lt;? super Integer&gt; observer) {
<span class="fc" id="L1378">                        observer.onSubscribe(upstream);</span>
<span class="fc" id="L1379">                    }</span>
                }
        );
<span class="fc" id="L1382">        TestObserver&lt;Object&gt; to = new TestObserver&lt;Object&gt;();</span>

<span class="fc" id="L1384">        o.groupBy(new Function&lt;Integer, Integer&gt;() {</span>

            @Override
            public Integer apply(Integer integer) {
<span class="nc" id="L1388">                return null;</span>
            }
<span class="fc" id="L1390">        }).subscribe(to);</span>

<span class="fc" id="L1392">        to.dispose();</span>

<span class="fc" id="L1394">        verify(upstream).dispose();</span>
<span class="fc" id="L1395">    }</span>

    @Test
    public void testGroupByShouldPropagateError() {
<span class="fc" id="L1399">        final Throwable e = new RuntimeException(&quot;Oops&quot;);</span>
<span class="fc" id="L1400">        final TestObserver&lt;Integer&gt; inner1 = new TestObserver&lt;Integer&gt;();</span>
<span class="fc" id="L1401">        final TestObserver&lt;Integer&gt; inner2 = new TestObserver&lt;Integer&gt;();</span>

<span class="fc" id="L1403">        final TestObserver&lt;GroupedObservable&lt;Integer, Integer&gt;&gt; outer</span>
<span class="fc" id="L1404">                = new TestObserver&lt;GroupedObservable&lt;Integer, Integer&gt;&gt;(new DefaultObserver&lt;GroupedObservable&lt;Integer, Integer&gt;&gt;() {</span>

            @Override
            public void onComplete() {
<span class="nc" id="L1408">            }</span>

            @Override
            public void onError(Throwable e) {
<span class="fc" id="L1412">            }</span>

            @Override
            public void onNext(GroupedObservable&lt;Integer, Integer&gt; o) {
<span class="fc bfc" id="L1416" title="All 2 branches covered.">                if (o.getKey() == 0) {</span>
<span class="fc" id="L1417">                    o.subscribe(inner1);</span>
                } else {
<span class="fc" id="L1419">                    o.subscribe(inner2);</span>
                }
<span class="fc" id="L1421">            }</span>
        });
<span class="fc" id="L1423">        Observable.unsafeCreate(</span>
<span class="fc" id="L1424">                new ObservableSource&lt;Integer&gt;() {</span>
                    @Override
                    public void subscribe(Observer&lt;? super Integer&gt; observer) {
<span class="fc" id="L1427">                        observer.onSubscribe(Disposables.empty());</span>
<span class="fc" id="L1428">                        observer.onNext(0);</span>
<span class="fc" id="L1429">                        observer.onNext(1);</span>
<span class="fc" id="L1430">                        observer.onError(e);</span>
<span class="fc" id="L1431">                    }</span>
                }
<span class="fc" id="L1433">        ).groupBy(new Function&lt;Integer, Integer&gt;() {</span>

            @Override
            public Integer apply(Integer i) {
<span class="fc" id="L1437">                return i % 2;</span>
            }
<span class="fc" id="L1439">        }).subscribe(outer);</span>
<span class="fc" id="L1440">        assertEquals(Arrays.asList(e), outer.errors());</span>
<span class="fc" id="L1441">        assertEquals(Arrays.asList(e), inner1.errors());</span>
<span class="fc" id="L1442">        assertEquals(Arrays.asList(e), inner2.errors());</span>
<span class="fc" id="L1443">    }</span>

    @Test
    public void keySelectorAndDelayError() {
<span class="fc" id="L1447">        Observable.just(1).concatWith(Observable.&lt;Integer&gt;error(new TestException()))</span>
<span class="fc" id="L1448">        .groupBy(Functions.&lt;Integer&gt;identity(), true)</span>
<span class="fc" id="L1449">        .flatMap(new Function&lt;GroupedObservable&lt;Integer, Integer&gt;, ObservableSource&lt;Integer&gt;&gt;() {</span>
            @Override
            public ObservableSource&lt;Integer&gt; apply(GroupedObservable&lt;Integer, Integer&gt; g) throws Exception {
<span class="fc" id="L1452">                return g;</span>
            }
        })
<span class="fc" id="L1455">        .test()</span>
<span class="fc" id="L1456">        .assertFailure(TestException.class, 1);</span>
<span class="fc" id="L1457">    }</span>

    @Test
    public void keyAndValueSelectorAndDelayError() {
<span class="fc" id="L1461">        Observable.just(1).concatWith(Observable.&lt;Integer&gt;error(new TestException()))</span>
<span class="fc" id="L1462">        .groupBy(Functions.&lt;Integer&gt;identity(), Functions.&lt;Integer&gt;identity(), true)</span>
<span class="fc" id="L1463">        .flatMap(new Function&lt;GroupedObservable&lt;Integer, Integer&gt;, ObservableSource&lt;Integer&gt;&gt;() {</span>
            @Override
            public ObservableSource&lt;Integer&gt; apply(GroupedObservable&lt;Integer, Integer&gt; g) throws Exception {
<span class="fc" id="L1466">                return g;</span>
            }
        })
<span class="fc" id="L1469">        .test()</span>
<span class="fc" id="L1470">        .assertFailure(TestException.class, 1);</span>
<span class="fc" id="L1471">    }</span>

    @Test
    public void dispose() {
<span class="fc" id="L1475">        TestHelper.checkDisposed(Observable.just(1).groupBy(Functions.justFunction(1)));</span>

<span class="fc" id="L1477">        Observable.just(1)</span>
<span class="fc" id="L1478">        .groupBy(Functions.justFunction(1))</span>
<span class="fc" id="L1479">        .doOnNext(new Consumer&lt;GroupedObservable&lt;Integer, Integer&gt;&gt;() {</span>
            @Override
            public void accept(GroupedObservable&lt;Integer, Integer&gt; g) throws Exception {
<span class="fc" id="L1482">                TestHelper.checkDisposed(g);</span>
<span class="fc" id="L1483">            }</span>
        })
<span class="fc" id="L1485">        .test();</span>
<span class="fc" id="L1486">    }</span>

    @Test
    public void reentrantComplete() {
<span class="fc" id="L1490">        final PublishSubject&lt;Integer&gt; ps = PublishSubject.create();</span>

<span class="fc" id="L1492">        TestObserver&lt;Integer&gt; to = new TestObserver&lt;Integer&gt;() {</span>
            @Override
            public void onNext(Integer t) {
<span class="fc" id="L1495">                super.onNext(t);</span>
<span class="pc bpc" id="L1496" title="1 of 2 branches missed.">                if (t == 1) {</span>
<span class="fc" id="L1497">                    ps.onComplete();</span>
                }
<span class="fc" id="L1499">            }</span>
        };

<span class="fc" id="L1502">        Observable.merge(ps.groupBy(Functions.justFunction(1)))</span>
<span class="fc" id="L1503">        .subscribe(to);</span>

<span class="fc" id="L1505">        ps.onNext(1);</span>

<span class="fc" id="L1507">        to.assertResult(1);</span>
<span class="fc" id="L1508">    }</span>

    @Test
    public void reentrantCompleteCancel() {
<span class="fc" id="L1512">        final PublishSubject&lt;Integer&gt; ps = PublishSubject.create();</span>

<span class="fc" id="L1514">        TestObserver&lt;Integer&gt; to = new TestObserver&lt;Integer&gt;() {</span>
            @Override
            public void onNext(Integer t) {
<span class="fc" id="L1517">                super.onNext(t);</span>
<span class="pc bpc" id="L1518" title="1 of 2 branches missed.">                if (t == 1) {</span>
<span class="fc" id="L1519">                    ps.onComplete();</span>
<span class="fc" id="L1520">                    dispose();</span>
                }
<span class="fc" id="L1522">            }</span>
        };

<span class="fc" id="L1525">        Observable.merge(ps.groupBy(Functions.justFunction(1)))</span>
<span class="fc" id="L1526">        .subscribe(to);</span>

<span class="fc" id="L1528">        ps.onNext(1);</span>

<span class="fc" id="L1530">        to.assertSubscribed().assertValue(1).assertNoErrors().assertNotComplete();</span>
<span class="fc" id="L1531">    }</span>

    @Test
    public void delayErrorSimpleComplete() {
<span class="fc" id="L1535">        Observable.just(1)</span>
<span class="fc" id="L1536">        .groupBy(Functions.justFunction(1), true)</span>
<span class="fc" id="L1537">        .flatMap(Functions.&lt;Observable&lt;Integer&gt;&gt;identity())</span>
<span class="fc" id="L1538">        .test()</span>
<span class="fc" id="L1539">        .assertResult(1);</span>
<span class="fc" id="L1540">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>