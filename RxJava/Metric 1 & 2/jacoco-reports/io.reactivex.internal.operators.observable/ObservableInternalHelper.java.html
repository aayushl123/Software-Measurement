<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ObservableInternalHelper.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">RxJava_2_x$Unnamed.exec</a> &gt; <a href="index.source.html" class="el_package">io.reactivex.internal.operators.observable</a> &gt; <span class="el_source">ObservableInternalHelper.java</span></div><h1>ObservableInternalHelper.java</h1><pre class="source lang-java linenums">/**
 * Copyright (c) 2016-present, RxJava Contributors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is
 * distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
 * the License for the specific language governing permissions and limitations under the License.
 */
package io.reactivex.internal.operators.observable;

import java.util.List;
import java.util.concurrent.*;

import io.reactivex.*;
import io.reactivex.functions.*;
import io.reactivex.internal.functions.*;
import io.reactivex.observables.ConnectableObservable;

/**
 * Helper utility class to support Observable with inner classes.
 */
public final class ObservableInternalHelper {

<span class="fc" id="L28">    private ObservableInternalHelper() {</span>
<span class="fc" id="L29">        throw new IllegalStateException(&quot;No instances!&quot;);</span>
    }

    static final class SimpleGenerator&lt;T, S&gt; implements BiFunction&lt;S, Emitter&lt;T&gt;, S&gt; {
        final Consumer&lt;Emitter&lt;T&gt;&gt; consumer;

<span class="fc" id="L35">        SimpleGenerator(Consumer&lt;Emitter&lt;T&gt;&gt; consumer) {</span>
<span class="fc" id="L36">            this.consumer = consumer;</span>
<span class="fc" id="L37">        }</span>

        @Override
        public S apply(S t1, Emitter&lt;T&gt; t2) throws Exception {
<span class="fc" id="L41">            consumer.accept(t2);</span>
<span class="fc" id="L42">            return t1;</span>
        }
    }

    public static &lt;T, S&gt; BiFunction&lt;S, Emitter&lt;T&gt;, S&gt; simpleGenerator(Consumer&lt;Emitter&lt;T&gt;&gt; consumer) {
<span class="fc" id="L47">        return new SimpleGenerator&lt;T, S&gt;(consumer);</span>
    }

    static final class SimpleBiGenerator&lt;T, S&gt; implements BiFunction&lt;S, Emitter&lt;T&gt;, S&gt; {
        final BiConsumer&lt;S, Emitter&lt;T&gt;&gt; consumer;

<span class="fc" id="L53">        SimpleBiGenerator(BiConsumer&lt;S, Emitter&lt;T&gt;&gt; consumer) {</span>
<span class="fc" id="L54">            this.consumer = consumer;</span>
<span class="fc" id="L55">        }</span>

        @Override
        public S apply(S t1, Emitter&lt;T&gt; t2) throws Exception {
<span class="fc" id="L59">            consumer.accept(t1, t2);</span>
<span class="fc" id="L60">            return t1;</span>
        }
    }

    public static &lt;T, S&gt; BiFunction&lt;S, Emitter&lt;T&gt;, S&gt; simpleBiGenerator(BiConsumer&lt;S, Emitter&lt;T&gt;&gt; consumer) {
<span class="fc" id="L65">        return new SimpleBiGenerator&lt;T, S&gt;(consumer);</span>
    }

    static final class ItemDelayFunction&lt;T, U&gt; implements Function&lt;T, ObservableSource&lt;T&gt;&gt; {
        final Function&lt;? super T, ? extends ObservableSource&lt;U&gt;&gt; itemDelay;

<span class="fc" id="L71">        ItemDelayFunction(Function&lt;? super T, ? extends ObservableSource&lt;U&gt;&gt; itemDelay) {</span>
<span class="fc" id="L72">            this.itemDelay = itemDelay;</span>
<span class="fc" id="L73">        }</span>

        @Override
        public ObservableSource&lt;T&gt; apply(final T v) throws Exception {
<span class="fc" id="L77">            ObservableSource&lt;U&gt; o = ObjectHelper.requireNonNull(itemDelay.apply(v), &quot;The itemDelay returned a null ObservableSource&quot;);</span>
<span class="fc" id="L78">            return new ObservableTake&lt;U&gt;(o, 1).map(Functions.justFunction(v)).defaultIfEmpty(v);</span>
        }
    }

    public static &lt;T, U&gt; Function&lt;T, ObservableSource&lt;T&gt;&gt; itemDelay(final Function&lt;? super T, ? extends ObservableSource&lt;U&gt;&gt; itemDelay) {
<span class="fc" id="L83">        return new ItemDelayFunction&lt;T, U&gt;(itemDelay);</span>
    }

    static final class ObserverOnNext&lt;T&gt; implements Consumer&lt;T&gt; {
        final Observer&lt;T&gt; observer;

<span class="fc" id="L89">        ObserverOnNext(Observer&lt;T&gt; observer) {</span>
<span class="fc" id="L90">            this.observer = observer;</span>
<span class="fc" id="L91">        }</span>

        @Override
        public void accept(T v) throws Exception {
<span class="fc" id="L95">            observer.onNext(v);</span>
<span class="fc" id="L96">        }</span>
    }

    static final class ObserverOnError&lt;T&gt; implements Consumer&lt;Throwable&gt; {
        final Observer&lt;T&gt; observer;

<span class="fc" id="L102">        ObserverOnError(Observer&lt;T&gt; observer) {</span>
<span class="fc" id="L103">            this.observer = observer;</span>
<span class="fc" id="L104">        }</span>

        @Override
        public void accept(Throwable v) throws Exception {
<span class="fc" id="L108">            observer.onError(v);</span>
<span class="fc" id="L109">        }</span>
    }

    static final class ObserverOnComplete&lt;T&gt; implements Action {
        final Observer&lt;T&gt; observer;

<span class="fc" id="L115">        ObserverOnComplete(Observer&lt;T&gt; observer) {</span>
<span class="fc" id="L116">            this.observer = observer;</span>
<span class="fc" id="L117">        }</span>

        @Override
        public void run() throws Exception {
<span class="fc" id="L121">            observer.onComplete();</span>
<span class="fc" id="L122">        }</span>
    }

    public static &lt;T&gt; Consumer&lt;T&gt; observerOnNext(Observer&lt;T&gt; observer) {
<span class="fc" id="L126">        return new ObserverOnNext&lt;T&gt;(observer);</span>
    }

    public static &lt;T&gt; Consumer&lt;Throwable&gt; observerOnError(Observer&lt;T&gt; observer) {
<span class="fc" id="L130">        return new ObserverOnError&lt;T&gt;(observer);</span>
    }

    public static &lt;T&gt; Action observerOnComplete(Observer&lt;T&gt; observer) {
<span class="fc" id="L134">        return new ObserverOnComplete&lt;T&gt;(observer);</span>
    }

    static final class FlatMapWithCombinerInner&lt;U, R, T&gt; implements Function&lt;U, R&gt; {
        private final BiFunction&lt;? super T, ? super U, ? extends R&gt; combiner;
        private final T t;

<span class="fc" id="L141">        FlatMapWithCombinerInner(BiFunction&lt;? super T, ? super U, ? extends R&gt; combiner, T t) {</span>
<span class="fc" id="L142">            this.combiner = combiner;</span>
<span class="fc" id="L143">            this.t = t;</span>
<span class="fc" id="L144">        }</span>

        @Override
        public R apply(U w) throws Exception {
<span class="fc" id="L148">            return combiner.apply(t, w);</span>
        }
    }

    static final class FlatMapWithCombinerOuter&lt;T, R, U&gt; implements Function&lt;T, ObservableSource&lt;R&gt;&gt; {
        private final BiFunction&lt;? super T, ? super U, ? extends R&gt; combiner;
        private final Function&lt;? super T, ? extends ObservableSource&lt;? extends U&gt;&gt; mapper;

        FlatMapWithCombinerOuter(BiFunction&lt;? super T, ? super U, ? extends R&gt; combiner,
<span class="fc" id="L157">                Function&lt;? super T, ? extends ObservableSource&lt;? extends U&gt;&gt; mapper) {</span>
<span class="fc" id="L158">            this.combiner = combiner;</span>
<span class="fc" id="L159">            this.mapper = mapper;</span>
<span class="fc" id="L160">        }</span>

        @Override
        public ObservableSource&lt;R&gt; apply(final T t) throws Exception {
            @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L165">            ObservableSource&lt;U&gt; u = (ObservableSource&lt;U&gt;)ObjectHelper.requireNonNull(mapper.apply(t), &quot;The mapper returned a null ObservableSource&quot;);</span>
<span class="fc" id="L166">            return new ObservableMap&lt;U, R&gt;(u, new FlatMapWithCombinerInner&lt;U, R, T&gt;(combiner, t));</span>
        }
    }

    public static &lt;T, U, R&gt; Function&lt;T, ObservableSource&lt;R&gt;&gt; flatMapWithCombiner(
            final Function&lt;? super T, ? extends ObservableSource&lt;? extends U&gt;&gt; mapper,
                    final BiFunction&lt;? super T, ? super U, ? extends R&gt; combiner) {
<span class="fc" id="L173">        return new FlatMapWithCombinerOuter&lt;T, R, U&gt;(combiner, mapper);</span>
    }

    static final class FlatMapIntoIterable&lt;T, U&gt; implements Function&lt;T, ObservableSource&lt;U&gt;&gt; {
        private final Function&lt;? super T, ? extends Iterable&lt;? extends U&gt;&gt; mapper;

<span class="fc" id="L179">        FlatMapIntoIterable(Function&lt;? super T, ? extends Iterable&lt;? extends U&gt;&gt; mapper) {</span>
<span class="fc" id="L180">            this.mapper = mapper;</span>
<span class="fc" id="L181">        }</span>

        @Override
        public ObservableSource&lt;U&gt; apply(T t) throws Exception {
<span class="fc" id="L185">            return new ObservableFromIterable&lt;U&gt;(ObjectHelper.requireNonNull(mapper.apply(t), &quot;The mapper returned a null Iterable&quot;));</span>
        }
    }

    public static &lt;T, U&gt; Function&lt;T, ObservableSource&lt;U&gt;&gt; flatMapIntoIterable(final Function&lt;? super T, ? extends Iterable&lt;? extends U&gt;&gt; mapper) {
<span class="fc" id="L190">        return new FlatMapIntoIterable&lt;T, U&gt;(mapper);</span>
    }

<span class="fc" id="L193">    enum MapToInt implements Function&lt;Object, Object&gt; {</span>
<span class="fc" id="L194">        INSTANCE;</span>
        @Override
        public Object apply(Object t) throws Exception {
<span class="fc" id="L197">            return 0;</span>
        }
    }

    public static &lt;T&gt; Callable&lt;ConnectableObservable&lt;T&gt;&gt; replayCallable(final Observable&lt;T&gt; parent) {
<span class="fc" id="L202">        return new ReplayCallable&lt;T&gt;(parent);</span>
    }

    public static &lt;T&gt; Callable&lt;ConnectableObservable&lt;T&gt;&gt; replayCallable(final Observable&lt;T&gt; parent, final int bufferSize) {
<span class="fc" id="L206">        return new BufferedReplayCallable&lt;T&gt;(parent, bufferSize);</span>
    }

    public static &lt;T&gt; Callable&lt;ConnectableObservable&lt;T&gt;&gt; replayCallable(final Observable&lt;T&gt; parent, final int bufferSize, final long time, final TimeUnit unit, final Scheduler scheduler) {
<span class="fc" id="L210">        return new BufferedTimedReplayCallable&lt;T&gt;(parent, bufferSize, time, unit, scheduler);</span>
    }

    public static &lt;T&gt; Callable&lt;ConnectableObservable&lt;T&gt;&gt; replayCallable(final Observable&lt;T&gt; parent, final long time, final TimeUnit unit, final Scheduler scheduler) {
<span class="fc" id="L214">        return new TimedReplayCallable&lt;T&gt;(parent, time, unit, scheduler);</span>
    }

    public static &lt;T, R&gt; Function&lt;Observable&lt;T&gt;, ObservableSource&lt;R&gt;&gt; replayFunction(final Function&lt;? super Observable&lt;T&gt;, ? extends ObservableSource&lt;R&gt;&gt; selector, final Scheduler scheduler) {
<span class="fc" id="L218">        return new ReplayFunction&lt;T, R&gt;(selector, scheduler);</span>
    }

    static final class ZipIterableFunction&lt;T, R&gt;
    implements Function&lt;List&lt;ObservableSource&lt;? extends T&gt;&gt;, ObservableSource&lt;? extends R&gt;&gt; {
        private final Function&lt;? super Object[], ? extends R&gt; zipper;

<span class="fc" id="L225">        ZipIterableFunction(Function&lt;? super Object[], ? extends R&gt; zipper) {</span>
<span class="fc" id="L226">            this.zipper = zipper;</span>
<span class="fc" id="L227">        }</span>

        @Override
        public ObservableSource&lt;? extends R&gt; apply(List&lt;ObservableSource&lt;? extends T&gt;&gt; list) {
<span class="fc" id="L231">            return Observable.zipIterable(list, zipper, false, Observable.bufferSize());</span>
        }
    }

    public static &lt;T, R&gt; Function&lt;List&lt;ObservableSource&lt;? extends T&gt;&gt;, ObservableSource&lt;? extends R&gt;&gt; zipIterable(final Function&lt;? super Object[], ? extends R&gt; zipper) {
<span class="fc" id="L236">        return new ZipIterableFunction&lt;T, R&gt;(zipper);</span>
    }

    static final class ReplayCallable&lt;T&gt; implements Callable&lt;ConnectableObservable&lt;T&gt;&gt; {
        private final Observable&lt;T&gt; parent;

<span class="fc" id="L242">        ReplayCallable(Observable&lt;T&gt; parent) {</span>
<span class="fc" id="L243">            this.parent = parent;</span>
<span class="fc" id="L244">        }</span>

        @Override
        public ConnectableObservable&lt;T&gt; call() {
<span class="fc" id="L248">            return parent.replay();</span>
        }
    }

    static final class BufferedReplayCallable&lt;T&gt; implements Callable&lt;ConnectableObservable&lt;T&gt;&gt; {
        private final Observable&lt;T&gt; parent;
        private final int bufferSize;

<span class="fc" id="L256">        BufferedReplayCallable(Observable&lt;T&gt; parent, int bufferSize) {</span>
<span class="fc" id="L257">            this.parent = parent;</span>
<span class="fc" id="L258">            this.bufferSize = bufferSize;</span>
<span class="fc" id="L259">        }</span>

        @Override
        public ConnectableObservable&lt;T&gt; call() {
<span class="fc" id="L263">            return parent.replay(bufferSize);</span>
        }
    }

    static final class BufferedTimedReplayCallable&lt;T&gt; implements Callable&lt;ConnectableObservable&lt;T&gt;&gt; {
        private final Observable&lt;T&gt; parent;
        private final int bufferSize;
        private final long time;
        private final TimeUnit unit;
        private final Scheduler scheduler;

<span class="fc" id="L274">        BufferedTimedReplayCallable(Observable&lt;T&gt; parent, int bufferSize, long time, TimeUnit unit, Scheduler scheduler) {</span>
<span class="fc" id="L275">            this.parent = parent;</span>
<span class="fc" id="L276">            this.bufferSize = bufferSize;</span>
<span class="fc" id="L277">            this.time = time;</span>
<span class="fc" id="L278">            this.unit = unit;</span>
<span class="fc" id="L279">            this.scheduler = scheduler;</span>
<span class="fc" id="L280">        }</span>

        @Override
        public ConnectableObservable&lt;T&gt; call() {
<span class="fc" id="L284">            return parent.replay(bufferSize, time, unit, scheduler);</span>
        }
    }

    static final class TimedReplayCallable&lt;T&gt; implements Callable&lt;ConnectableObservable&lt;T&gt;&gt; {
        private final Observable&lt;T&gt; parent;
        private final long time;
        private final TimeUnit unit;
        private final Scheduler scheduler;

<span class="fc" id="L294">        TimedReplayCallable(Observable&lt;T&gt; parent, long time, TimeUnit unit, Scheduler scheduler) {</span>
<span class="fc" id="L295">            this.parent = parent;</span>
<span class="fc" id="L296">            this.time = time;</span>
<span class="fc" id="L297">            this.unit = unit;</span>
<span class="fc" id="L298">            this.scheduler = scheduler;</span>
<span class="fc" id="L299">        }</span>

        @Override
        public ConnectableObservable&lt;T&gt; call() {
<span class="fc" id="L303">            return parent.replay(time, unit, scheduler);</span>
        }
    }

    static final class ReplayFunction&lt;T, R&gt; implements Function&lt;Observable&lt;T&gt;, ObservableSource&lt;R&gt;&gt; {
        private final Function&lt;? super Observable&lt;T&gt;, ? extends ObservableSource&lt;R&gt;&gt; selector;
        private final Scheduler scheduler;

<span class="fc" id="L311">        ReplayFunction(Function&lt;? super Observable&lt;T&gt;, ? extends ObservableSource&lt;R&gt;&gt; selector, Scheduler scheduler) {</span>
<span class="fc" id="L312">            this.selector = selector;</span>
<span class="fc" id="L313">            this.scheduler = scheduler;</span>
<span class="fc" id="L314">        }</span>

        @Override
        public ObservableSource&lt;R&gt; apply(Observable&lt;T&gt; t) throws Exception {
<span class="fc" id="L318">            ObservableSource&lt;R&gt; apply = ObjectHelper.requireNonNull(selector.apply(t), &quot;The selector returned a null ObservableSource&quot;);</span>
<span class="fc" id="L319">            return Observable.wrap(apply).observeOn(scheduler);</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>