<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ObservableMergeTest.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">RxJava_2_x$Unnamed.exec</a> &gt; <a href="index.source.html" class="el_package">io.reactivex.internal.operators.observable</a> &gt; <span class="el_source">ObservableMergeTest.java</span></div><h1>ObservableMergeTest.java</h1><pre class="source lang-java linenums">/**
 * Copyright (c) 2016-present, RxJava Contributors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is
 * distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
 * the License for the specific language governing permissions and limitations under the License.
 */

package io.reactivex.internal.operators.observable;

import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.*;

import org.junit.*;

import io.reactivex.*;
import io.reactivex.Observable;
import io.reactivex.Observer;
import io.reactivex.Scheduler.Worker;
import io.reactivex.disposables.*;
import io.reactivex.exceptions.TestException;
import io.reactivex.functions.*;
import io.reactivex.observers.*;
import io.reactivex.plugins.RxJavaPlugins;
import io.reactivex.schedulers.*;

<span class="fc" id="L36">public class ObservableMergeTest {</span>

    Observer&lt;String&gt; stringObserver;

    int count;

    @Before
    public void before() {
<span class="fc" id="L44">        stringObserver = TestHelper.mockObserver();</span>

<span class="fc bfc" id="L46" title="All 2 branches covered.">        for (Thread t : Thread.getAllStackTraces().keySet()) {</span>
<span class="pc bpc" id="L47" title="1 of 2 branches missed.">            if (t.getName().startsWith(&quot;RxNewThread&quot;)) {</span>
<span class="nc" id="L48">                count++;</span>
            }
<span class="fc" id="L50">        }</span>
<span class="fc" id="L51">    }</span>

    @After
    public void after() {
        try {
<span class="fc" id="L56">            Thread.sleep(100);</span>
<span class="nc" id="L57">        } catch (InterruptedException e) {</span>
            // TODO Auto-generated catch block
<span class="nc" id="L59">            e.printStackTrace();</span>
<span class="fc" id="L60">        }</span>
<span class="fc bfc" id="L61" title="All 2 branches covered.">        for (Thread t : Thread.getAllStackTraces().keySet()) {</span>
<span class="pc bpc" id="L62" title="1 of 2 branches missed.">            if (t.getName().startsWith(&quot;RxNewThread&quot;)) {</span>
<span class="nc" id="L63">                --count;</span>
            }
<span class="fc" id="L65">        }</span>
<span class="pc bpc" id="L66" title="1 of 2 branches missed.">        if (count != 0) {</span>
<span class="nc" id="L67">            throw new IllegalStateException(&quot;NewThread leak!&quot;);</span>
        }
<span class="fc" id="L69">    }</span>

    @Test
    public void testMergeObservableOfObservables() {
<span class="fc" id="L73">        final Observable&lt;String&gt; o1 = Observable.unsafeCreate(new TestSynchronousObservable());</span>
<span class="fc" id="L74">        final Observable&lt;String&gt; o2 = Observable.unsafeCreate(new TestSynchronousObservable());</span>

<span class="fc" id="L76">        Observable&lt;Observable&lt;String&gt;&gt; observableOfObservables = Observable.unsafeCreate(new ObservableSource&lt;Observable&lt;String&gt;&gt;() {</span>

            @Override
            public void subscribe(Observer&lt;? super Observable&lt;String&gt;&gt; observer) {
<span class="fc" id="L80">                observer.onSubscribe(Disposables.empty());</span>
                // simulate what would happen in an Observable
<span class="fc" id="L82">                observer.onNext(o1);</span>
<span class="fc" id="L83">                observer.onNext(o2);</span>
<span class="fc" id="L84">                observer.onComplete();</span>
<span class="fc" id="L85">            }</span>

        });
<span class="fc" id="L88">        Observable&lt;String&gt; m = Observable.merge(observableOfObservables);</span>
<span class="fc" id="L89">        m.subscribe(stringObserver);</span>

<span class="fc" id="L91">        verify(stringObserver, never()).onError(any(Throwable.class));</span>
<span class="fc" id="L92">        verify(stringObserver, times(1)).onComplete();</span>
<span class="fc" id="L93">        verify(stringObserver, times(2)).onNext(&quot;hello&quot;);</span>
<span class="fc" id="L94">    }</span>

    @Test
    public void testMergeArray() {
<span class="fc" id="L98">        final Observable&lt;String&gt; o1 = Observable.unsafeCreate(new TestSynchronousObservable());</span>
<span class="fc" id="L99">        final Observable&lt;String&gt; o2 = Observable.unsafeCreate(new TestSynchronousObservable());</span>

<span class="fc" id="L101">        Observable&lt;String&gt; m = Observable.merge(o1, o2);</span>
<span class="fc" id="L102">        m.subscribe(stringObserver);</span>

<span class="fc" id="L104">        verify(stringObserver, never()).onError(any(Throwable.class));</span>
<span class="fc" id="L105">        verify(stringObserver, times(2)).onNext(&quot;hello&quot;);</span>
<span class="fc" id="L106">        verify(stringObserver, times(1)).onComplete();</span>
<span class="fc" id="L107">    }</span>

    @Test
    public void testMergeList() {
<span class="fc" id="L111">        final Observable&lt;String&gt; o1 = Observable.unsafeCreate(new TestSynchronousObservable());</span>
<span class="fc" id="L112">        final Observable&lt;String&gt; o2 = Observable.unsafeCreate(new TestSynchronousObservable());</span>
<span class="fc" id="L113">        List&lt;Observable&lt;String&gt;&gt; listOfObservables = new ArrayList&lt;Observable&lt;String&gt;&gt;();</span>
<span class="fc" id="L114">        listOfObservables.add(o1);</span>
<span class="fc" id="L115">        listOfObservables.add(o2);</span>

<span class="fc" id="L117">        Observable&lt;String&gt; m = Observable.merge(listOfObservables);</span>
<span class="fc" id="L118">        m.subscribe(stringObserver);</span>

<span class="fc" id="L120">        verify(stringObserver, never()).onError(any(Throwable.class));</span>
<span class="fc" id="L121">        verify(stringObserver, times(1)).onComplete();</span>
<span class="fc" id="L122">        verify(stringObserver, times(2)).onNext(&quot;hello&quot;);</span>
<span class="fc" id="L123">    }</span>

    @Test(timeout = 1000)
    public void testUnSubscribeObservableOfObservables() throws InterruptedException {

<span class="fc" id="L128">        final AtomicBoolean unsubscribed = new AtomicBoolean();</span>
<span class="fc" id="L129">        final CountDownLatch latch = new CountDownLatch(1);</span>

<span class="fc" id="L131">        Observable&lt;Observable&lt;Long&gt;&gt; source = Observable.unsafeCreate(new ObservableSource&lt;Observable&lt;Long&gt;&gt;() {</span>

            @Override
            public void subscribe(final Observer&lt;? super Observable&lt;Long&gt;&gt; observer) {
                // verbose on purpose so I can track the inside of it
<span class="fc" id="L136">                final Disposable upstream = Disposables.fromRunnable(new Runnable() {</span>
                    @Override
                    public void run() {
<span class="fc" id="L139">                        System.out.println(&quot;*** unsubscribed&quot;);</span>
<span class="fc" id="L140">                        unsubscribed.set(true);</span>
<span class="fc" id="L141">                    }</span>
                });
<span class="fc" id="L143">                observer.onSubscribe(upstream);</span>

<span class="fc" id="L145">                new Thread(new Runnable() {</span>

                    @Override
                    public void run() {

<span class="fc bfc" id="L150" title="All 2 branches covered.">                        while (!unsubscribed.get()) {</span>
<span class="fc" id="L151">                            observer.onNext(Observable.just(1L, 2L));</span>
                        }
<span class="fc" id="L153">                        System.out.println(&quot;Done looping after unsubscribe: &quot; + unsubscribed.get());</span>
<span class="fc" id="L154">                        observer.onComplete();</span>

                        // mark that the thread is finished
<span class="fc" id="L157">                        latch.countDown();</span>
<span class="fc" id="L158">                    }</span>
<span class="fc" id="L159">                }).start();</span>
<span class="fc" id="L160">            }</span>

        });

<span class="fc" id="L164">        final AtomicInteger count = new AtomicInteger();</span>
<span class="fc" id="L165">        Observable.merge(source).take(6).blockingForEach(new Consumer&lt;Long&gt;() {</span>

            @Override
            public void accept(Long v) {
<span class="fc" id="L169">                System.out.println(&quot;Value: &quot; + v);</span>
<span class="fc" id="L170">                int c = count.incrementAndGet();</span>
<span class="pc bpc" id="L171" title="1 of 2 branches missed.">                if (c &gt; 6) {</span>
<span class="nc" id="L172">                    fail(&quot;Should be only 6&quot;);</span>
                }

<span class="fc" id="L175">            }</span>
        });

<span class="fc" id="L178">        latch.await(1000, TimeUnit.MILLISECONDS);</span>

<span class="fc" id="L180">        System.out.println(&quot;unsubscribed: &quot; + unsubscribed.get());</span>

<span class="fc" id="L182">        assertTrue(unsubscribed.get());</span>

<span class="fc" id="L184">    }</span>

    @Test
    public void testMergeArrayWithThreading() {
<span class="fc" id="L188">        final TestASynchronousObservable o1 = new TestASynchronousObservable();</span>
<span class="fc" id="L189">        final TestASynchronousObservable o2 = new TestASynchronousObservable();</span>

<span class="fc" id="L191">        Observable&lt;String&gt; m = Observable.merge(Observable.unsafeCreate(o1), Observable.unsafeCreate(o2));</span>
<span class="fc" id="L192">        TestObserver&lt;String&gt; to = new TestObserver&lt;String&gt;(stringObserver);</span>
<span class="fc" id="L193">        m.subscribe(to);</span>

<span class="fc" id="L195">        to.awaitTerminalEvent();</span>
<span class="fc" id="L196">        to.assertNoErrors();</span>

<span class="fc" id="L198">        verify(stringObserver, never()).onError(any(Throwable.class));</span>
<span class="fc" id="L199">        verify(stringObserver, times(2)).onNext(&quot;hello&quot;);</span>
<span class="fc" id="L200">        verify(stringObserver, times(1)).onComplete();</span>
<span class="fc" id="L201">    }</span>

    @Test
    public void testSynchronizationOfMultipleSequencesLoop() throws Throwable {
<span class="fc bfc" id="L205" title="All 2 branches covered.">        for (int i = 0; i &lt; 100; i++) {</span>
<span class="fc" id="L206">            System.out.println(&quot;testSynchronizationOfMultipleSequencesLoop &gt; &quot; + i);</span>
<span class="fc" id="L207">            testSynchronizationOfMultipleSequences();</span>
        }
<span class="fc" id="L209">    }</span>

    @Test
    public void testSynchronizationOfMultipleSequences() throws Throwable {
<span class="fc" id="L213">        final TestASynchronousObservable o1 = new TestASynchronousObservable();</span>
<span class="fc" id="L214">        final TestASynchronousObservable o2 = new TestASynchronousObservable();</span>

        // use this latch to cause onNext to wait until we're ready to let it go
<span class="fc" id="L217">        final CountDownLatch endLatch = new CountDownLatch(1);</span>

<span class="fc" id="L219">        final AtomicInteger concurrentCounter = new AtomicInteger();</span>
<span class="fc" id="L220">        final AtomicInteger totalCounter = new AtomicInteger();</span>

<span class="fc" id="L222">        Observable&lt;String&gt; m = Observable.merge(Observable.unsafeCreate(o1), Observable.unsafeCreate(o2));</span>
<span class="fc" id="L223">        m.subscribe(new DefaultObserver&lt;String&gt;() {</span>

            @Override
            public void onComplete() {

<span class="fc" id="L228">            }</span>

            @Override
            public void onError(Throwable e) {
<span class="nc" id="L232">                throw new RuntimeException(&quot;failed&quot;, e);</span>
            }

            @Override
            public void onNext(String v) {
<span class="fc" id="L237">                totalCounter.incrementAndGet();</span>
<span class="fc" id="L238">                concurrentCounter.incrementAndGet();</span>
                try {
                    // avoid deadlocking the main thread
<span class="pc bpc" id="L241" title="1 of 2 branches missed.">                    if (Thread.currentThread().getName().equals(&quot;TestASynchronousObservable&quot;)) {</span>
                        // wait here until we're done asserting
<span class="fc" id="L243">                        endLatch.await();</span>
                    }
<span class="nc" id="L245">                } catch (InterruptedException e) {</span>
<span class="nc" id="L246">                    e.printStackTrace();</span>
<span class="nc" id="L247">                    throw new RuntimeException(&quot;failed&quot;, e);</span>
                } finally {
<span class="fc" id="L249">                    concurrentCounter.decrementAndGet();</span>
                }
<span class="fc" id="L251">            }</span>

        });

        // wait for both observables to send (one should be blocked)
<span class="fc" id="L256">        o1.onNextBeingSent.await();</span>
<span class="fc" id="L257">        o2.onNextBeingSent.await();</span>

        // I can't think of a way to know for sure that both threads have or are trying to send onNext
        // since I can't use a CountDownLatch for &quot;after&quot; onNext since I want to catch during it
        // but I can't know for sure onNext is invoked
        // so I'm unfortunately reverting to using a Thread.sleep to allow the process scheduler time
        // to make sure after o1.onNextBeingSent and o2.onNextBeingSent are hit that the following
        // onNext is invoked.

<span class="fc" id="L266">        int timeout = 20;</span>

<span class="pc bpc" id="L268" title="2 of 4 branches missed.">        while (timeout-- &gt; 0 &amp;&amp; concurrentCounter.get() != 1) {</span>
<span class="nc" id="L269">            Thread.sleep(100);</span>
        }

        try { // in try/finally so threads are released via latch countDown even if assertion fails
<span class="fc" id="L273">            assertEquals(1, concurrentCounter.get());</span>
        } finally {
            // release so it can finish
<span class="fc" id="L276">            endLatch.countDown();</span>
        }

        try {
<span class="fc" id="L280">            o1.t.join();</span>
<span class="fc" id="L281">            o2.t.join();</span>
<span class="nc" id="L282">        } catch (InterruptedException e) {</span>
<span class="nc" id="L283">            throw new RuntimeException(e);</span>
<span class="fc" id="L284">        }</span>

<span class="fc" id="L286">        assertEquals(2, totalCounter.get());</span>
<span class="fc" id="L287">        assertEquals(0, concurrentCounter.get());</span>
<span class="fc" id="L288">    }</span>

    /**
     * Unit test from OperationMergeDelayError backported here to show how these use cases work with normal merge.
     */
    @Test
    public void testError1() {
        // we are using synchronous execution to test this exactly rather than non-deterministic concurrent behavior
<span class="fc" id="L296">        final Observable&lt;String&gt; o1 = Observable.unsafeCreate(new TestErrorObservable(&quot;four&quot;, null, &quot;six&quot;)); // we expect to lose &quot;six&quot;</span>
<span class="fc" id="L297">        final Observable&lt;String&gt; o2 = Observable.unsafeCreate(new TestErrorObservable(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;)); // we expect to lose all of these since o1 is done first and fails</span>

<span class="fc" id="L299">        Observable&lt;String&gt; m = Observable.merge(o1, o2);</span>
<span class="fc" id="L300">        m.subscribe(stringObserver);</span>

<span class="fc" id="L302">        verify(stringObserver, times(1)).onError(any(NullPointerException.class));</span>
<span class="fc" id="L303">        verify(stringObserver, never()).onComplete();</span>
<span class="fc" id="L304">        verify(stringObserver, times(0)).onNext(&quot;one&quot;);</span>
<span class="fc" id="L305">        verify(stringObserver, times(0)).onNext(&quot;two&quot;);</span>
<span class="fc" id="L306">        verify(stringObserver, times(0)).onNext(&quot;three&quot;);</span>
<span class="fc" id="L307">        verify(stringObserver, times(1)).onNext(&quot;four&quot;);</span>
<span class="fc" id="L308">        verify(stringObserver, times(0)).onNext(&quot;five&quot;);</span>
<span class="fc" id="L309">        verify(stringObserver, times(0)).onNext(&quot;six&quot;);</span>
<span class="fc" id="L310">    }</span>

    /**
     * Unit test from OperationMergeDelayError backported here to show how these use cases work with normal merge.
     */
    @Test
    public void testError2() {
        // we are using synchronous execution to test this exactly rather than non-deterministic concurrent behavior
<span class="fc" id="L318">        final Observable&lt;String&gt; o1 = Observable.unsafeCreate(new TestErrorObservable(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;));</span>
<span class="fc" id="L319">        final Observable&lt;String&gt; o2 = Observable.unsafeCreate(new TestErrorObservable(&quot;four&quot;, null, &quot;six&quot;)); // we expect to lose &quot;six&quot;</span>
<span class="fc" id="L320">        final Observable&lt;String&gt; o3 = Observable.unsafeCreate(new TestErrorObservable(&quot;seven&quot;, &quot;eight&quot;, null)); // we expect to lose all of these since o2 is done first and fails</span>
<span class="fc" id="L321">        final Observable&lt;String&gt; o4 = Observable.unsafeCreate(new TestErrorObservable(&quot;nine&quot;)); // we expect to lose all of these since o2 is done first and fails</span>

<span class="fc" id="L323">        Observable&lt;String&gt; m = Observable.merge(o1, o2, o3, o4);</span>
<span class="fc" id="L324">        m.subscribe(stringObserver);</span>

<span class="fc" id="L326">        verify(stringObserver, times(1)).onError(any(NullPointerException.class));</span>
<span class="fc" id="L327">        verify(stringObserver, never()).onComplete();</span>
<span class="fc" id="L328">        verify(stringObserver, times(1)).onNext(&quot;one&quot;);</span>
<span class="fc" id="L329">        verify(stringObserver, times(1)).onNext(&quot;two&quot;);</span>
<span class="fc" id="L330">        verify(stringObserver, times(1)).onNext(&quot;three&quot;);</span>
<span class="fc" id="L331">        verify(stringObserver, times(1)).onNext(&quot;four&quot;);</span>
<span class="fc" id="L332">        verify(stringObserver, times(0)).onNext(&quot;five&quot;);</span>
<span class="fc" id="L333">        verify(stringObserver, times(0)).onNext(&quot;six&quot;);</span>
<span class="fc" id="L334">        verify(stringObserver, times(0)).onNext(&quot;seven&quot;);</span>
<span class="fc" id="L335">        verify(stringObserver, times(0)).onNext(&quot;eight&quot;);</span>
<span class="fc" id="L336">        verify(stringObserver, times(0)).onNext(&quot;nine&quot;);</span>
<span class="fc" id="L337">    }</span>

    @Test
    @Ignore(&quot;Subscribe should not throw&quot;)
    public void testThrownErrorHandling() {
<span class="nc" id="L342">        TestObserver&lt;String&gt; to = new TestObserver&lt;String&gt;();</span>
<span class="nc" id="L343">        Observable&lt;String&gt; o1 = Observable.unsafeCreate(new ObservableSource&lt;String&gt;() {</span>

            @Override
            public void subscribe(Observer&lt;? super String&gt; observer) {
<span class="nc" id="L347">                throw new RuntimeException(&quot;fail&quot;);</span>
            }

        });

<span class="nc" id="L352">        Observable.merge(o1, o1).subscribe(to);</span>
<span class="nc" id="L353">        to.awaitTerminalEvent(1000, TimeUnit.MILLISECONDS);</span>
<span class="nc" id="L354">        to.assertTerminated();</span>
<span class="nc" id="L355">        System.out.println(&quot;Error: &quot; + to.errors());</span>
<span class="nc" id="L356">    }</span>

    private static class TestSynchronousObservable implements ObservableSource&lt;String&gt; {

        @Override
        public void subscribe(Observer&lt;? super String&gt; observer) {
<span class="fc" id="L362">            observer.onSubscribe(Disposables.empty());</span>
<span class="fc" id="L363">            observer.onNext(&quot;hello&quot;);</span>
<span class="fc" id="L364">            observer.onComplete();</span>
<span class="fc" id="L365">        }</span>
    }

<span class="fc" id="L368">    private static class TestASynchronousObservable implements ObservableSource&lt;String&gt; {</span>
        Thread t;
<span class="fc" id="L370">        final CountDownLatch onNextBeingSent = new CountDownLatch(1);</span>

        @Override
        public void subscribe(final Observer&lt;? super String&gt; observer) {
<span class="fc" id="L374">            observer.onSubscribe(Disposables.empty());</span>
<span class="fc" id="L375">            t = new Thread(new Runnable() {</span>

                @Override
                public void run() {
<span class="fc" id="L379">                    onNextBeingSent.countDown();</span>
                    try {
<span class="fc" id="L381">                        observer.onNext(&quot;hello&quot;);</span>
                        // I can't use a countDownLatch to prove we are actually sending 'onNext'
                        // since it will block if synchronized and I'll deadlock
<span class="fc" id="L384">                        observer.onComplete();</span>
<span class="nc" id="L385">                    } catch (Exception e) {</span>
<span class="nc" id="L386">                        observer.onError(e);</span>
<span class="fc" id="L387">                    }</span>
<span class="fc" id="L388">                }</span>

            }, &quot;TestASynchronousObservable&quot;);
<span class="fc" id="L391">            t.start();</span>
<span class="fc" id="L392">        }</span>
    }

    private static class TestErrorObservable implements ObservableSource&lt;String&gt; {

        String[] valuesToReturn;

<span class="fc" id="L399">        TestErrorObservable(String... values) {</span>
<span class="fc" id="L400">            valuesToReturn = values;</span>
<span class="fc" id="L401">        }</span>

        @Override
        public void subscribe(Observer&lt;? super String&gt; observer) {
<span class="fc" id="L405">            observer.onSubscribe(Disposables.empty());</span>
<span class="fc bfc" id="L406" title="All 2 branches covered.">            for (String s : valuesToReturn) {</span>
<span class="fc bfc" id="L407" title="All 2 branches covered.">                if (s == null) {</span>
<span class="fc" id="L408">                    System.out.println(&quot;throwing exception&quot;);</span>
<span class="fc" id="L409">                    observer.onError(new NullPointerException());</span>
                } else {
<span class="fc" id="L411">                    observer.onNext(s);</span>
                }
            }
<span class="fc" id="L414">            observer.onComplete();</span>
<span class="fc" id="L415">        }</span>
    }

    @Test
    public void testUnsubscribeAsObservablesComplete() {
<span class="fc" id="L420">        TestScheduler scheduler1 = new TestScheduler();</span>
<span class="fc" id="L421">        AtomicBoolean os1 = new AtomicBoolean(false);</span>
<span class="fc" id="L422">        Observable&lt;Long&gt; o1 = createObservableOf5IntervalsOf1SecondIncrementsWithSubscriptionHook(scheduler1, os1);</span>

<span class="fc" id="L424">        TestScheduler scheduler2 = new TestScheduler();</span>
<span class="fc" id="L425">        AtomicBoolean os2 = new AtomicBoolean(false);</span>
<span class="fc" id="L426">        Observable&lt;Long&gt; o2 = createObservableOf5IntervalsOf1SecondIncrementsWithSubscriptionHook(scheduler2, os2);</span>

<span class="fc" id="L428">        TestObserver&lt;Long&gt; to = new TestObserver&lt;Long&gt;();</span>
<span class="fc" id="L429">        Observable.merge(o1, o2).subscribe(to);</span>

        // we haven't incremented time so nothing should be received yet
<span class="fc" id="L432">        to.assertNoValues();</span>

<span class="fc" id="L434">        scheduler1.advanceTimeBy(3, TimeUnit.SECONDS);</span>
<span class="fc" id="L435">        scheduler2.advanceTimeBy(2, TimeUnit.SECONDS);</span>

<span class="fc" id="L437">        to.assertValues(0L, 1L, 2L, 0L, 1L);</span>
        // not unsubscribed yet
<span class="fc" id="L439">        assertFalse(os1.get());</span>
<span class="fc" id="L440">        assertFalse(os2.get());</span>

        // advance to the end at which point it should complete
<span class="fc" id="L443">        scheduler1.advanceTimeBy(3, TimeUnit.SECONDS);</span>

<span class="fc" id="L445">        to.assertValues(0L, 1L, 2L, 0L, 1L, 3L, 4L);</span>
<span class="fc" id="L446">        assertTrue(os1.get());</span>
<span class="fc" id="L447">        assertFalse(os2.get());</span>

        // both should be completed now
<span class="fc" id="L450">        scheduler2.advanceTimeBy(3, TimeUnit.SECONDS);</span>

<span class="fc" id="L452">        to.assertValues(0L, 1L, 2L, 0L, 1L, 3L, 4L, 2L, 3L, 4L);</span>
<span class="fc" id="L453">        assertTrue(os1.get());</span>
<span class="fc" id="L454">        assertTrue(os2.get());</span>

<span class="fc" id="L456">        to.assertTerminated();</span>
<span class="fc" id="L457">    }</span>

    @Test
    public void testEarlyUnsubscribe() {
<span class="fc bfc" id="L461" title="All 2 branches covered.">        for (int i = 0; i &lt; 10; i++) {</span>
<span class="fc" id="L462">            TestScheduler scheduler1 = new TestScheduler();</span>
<span class="fc" id="L463">            AtomicBoolean os1 = new AtomicBoolean(false);</span>
<span class="fc" id="L464">            Observable&lt;Long&gt; o1 = createObservableOf5IntervalsOf1SecondIncrementsWithSubscriptionHook(scheduler1, os1);</span>

<span class="fc" id="L466">            TestScheduler scheduler2 = new TestScheduler();</span>
<span class="fc" id="L467">            AtomicBoolean os2 = new AtomicBoolean(false);</span>
<span class="fc" id="L468">            Observable&lt;Long&gt; o2 = createObservableOf5IntervalsOf1SecondIncrementsWithSubscriptionHook(scheduler2, os2);</span>

<span class="fc" id="L470">            TestObserver&lt;Long&gt; to = new TestObserver&lt;Long&gt;();</span>
<span class="fc" id="L471">            Observable.merge(o1, o2).subscribe(to);</span>

            // we haven't incremented time so nothing should be received yet
<span class="fc" id="L474">            to.assertNoValues();</span>

<span class="fc" id="L476">            scheduler1.advanceTimeBy(3, TimeUnit.SECONDS);</span>
<span class="fc" id="L477">            scheduler2.advanceTimeBy(2, TimeUnit.SECONDS);</span>

<span class="fc" id="L479">            to.assertValues(0L, 1L, 2L, 0L, 1L);</span>
            // not unsubscribed yet
<span class="fc" id="L481">            assertFalse(os1.get());</span>
<span class="fc" id="L482">            assertFalse(os2.get());</span>

            // early unsubscribe
<span class="fc" id="L485">            to.dispose();</span>

<span class="fc" id="L487">            assertTrue(os1.get());</span>
<span class="fc" id="L488">            assertTrue(os2.get());</span>

<span class="fc" id="L490">            to.assertValues(0L, 1L, 2L, 0L, 1L);</span>
            // FIXME not happening anymore
//            ts.assertUnsubscribed();
        }
<span class="fc" id="L494">    }</span>

    private Observable&lt;Long&gt; createObservableOf5IntervalsOf1SecondIncrementsWithSubscriptionHook(final Scheduler scheduler, final AtomicBoolean unsubscribed) {
<span class="fc" id="L497">        return Observable.unsafeCreate(new ObservableSource&lt;Long&gt;() {</span>

            @Override
            public void subscribe(final Observer&lt;? super Long&gt; child) {
<span class="fc" id="L501">                Observable.interval(1, TimeUnit.SECONDS, scheduler)</span>
<span class="fc" id="L502">                .take(5)</span>
<span class="fc" id="L503">                .subscribe(new Observer&lt;Long&gt;() {</span>
                    @Override
                    public void onSubscribe(final Disposable d) {
<span class="fc" id="L506">                        child.onSubscribe(Disposables.fromRunnable(new Runnable() {</span>
                            @Override
                            public void run() {
<span class="fc" id="L509">                                unsubscribed.set(true);</span>
<span class="fc" id="L510">                                d.dispose();</span>
<span class="fc" id="L511">                            }</span>
                        }));
<span class="fc" id="L513">                    }</span>

                    @Override
                    public void onNext(Long t) {
<span class="fc" id="L517">                        child.onNext(t);</span>
<span class="fc" id="L518">                    }</span>

                    @Override
                    public void onError(Throwable t) {
<span class="nc" id="L522">                        unsubscribed.set(true);</span>
<span class="nc" id="L523">                        child.onError(t);</span>
<span class="nc" id="L524">                    }</span>

                    @Override
                    public void onComplete() {
<span class="fc" id="L528">                        unsubscribed.set(true);</span>
<span class="fc" id="L529">                        child.onComplete();</span>
<span class="fc" id="L530">                    }</span>

                });
<span class="fc" id="L533">            }</span>
        });
    }

    @Test//(timeout = 10000)
    public void testConcurrency() {
<span class="fc" id="L539">        Observable&lt;Integer&gt; o = Observable.range(1, 10000).subscribeOn(Schedulers.newThread());</span>

<span class="fc bfc" id="L541" title="All 2 branches covered.">        for (int i = 0; i &lt; 10; i++) {</span>
<span class="fc" id="L542">            Observable&lt;Integer&gt; merge = Observable.merge(o, o, o);</span>
<span class="fc" id="L543">            TestObserver&lt;Integer&gt; to = new TestObserver&lt;Integer&gt;();</span>
<span class="fc" id="L544">            merge.subscribe(to);</span>

<span class="fc" id="L546">            to.awaitTerminalEvent(3, TimeUnit.SECONDS);</span>
<span class="fc" id="L547">            to.assertTerminated();</span>
<span class="fc" id="L548">            to.assertNoErrors();</span>
<span class="fc" id="L549">            to.assertComplete();</span>
<span class="fc" id="L550">            List&lt;Integer&gt; onNextEvents = to.values();</span>
<span class="fc" id="L551">            assertEquals(30000, onNextEvents.size());</span>
            //            System.out.println(&quot;onNext: &quot; + onNextEvents.size() + &quot; onComplete: &quot; + ts.getOnCompletedEvents().size());
        }
<span class="fc" id="L554">    }</span>

    @Test
    public void testConcurrencyWithSleeping() {

<span class="fc" id="L559">        Observable&lt;Integer&gt; o = Observable.unsafeCreate(new ObservableSource&lt;Integer&gt;() {</span>

            @Override
            public void subscribe(final Observer&lt;? super Integer&gt; observer) {
<span class="fc" id="L563">                Worker inner = Schedulers.newThread().createWorker();</span>
<span class="fc" id="L564">                final CompositeDisposable as = new CompositeDisposable();</span>
<span class="fc" id="L565">                as.add(Disposables.empty());</span>
<span class="fc" id="L566">                as.add(inner);</span>

<span class="fc" id="L568">                observer.onSubscribe(as);</span>

<span class="fc" id="L570">                inner.schedule(new Runnable() {</span>

                    @Override
                    public void run() {
                        try {
<span class="fc bfc" id="L575" title="All 2 branches covered.">                            for (int i = 0; i &lt; 100; i++) {</span>
<span class="fc" id="L576">                                observer.onNext(1);</span>
                                try {
<span class="fc" id="L578">                                    Thread.sleep(1);</span>
<span class="nc" id="L579">                                } catch (InterruptedException e) {</span>
<span class="nc" id="L580">                                    e.printStackTrace();</span>
<span class="fc" id="L581">                                }</span>
                            }
<span class="nc" id="L583">                        } catch (Exception e) {</span>
<span class="nc" id="L584">                            observer.onError(e);</span>
<span class="fc" id="L585">                        }</span>
<span class="fc" id="L586">                        as.dispose();</span>
<span class="fc" id="L587">                        observer.onComplete();</span>
<span class="fc" id="L588">                    }</span>

                });
<span class="fc" id="L591">            }</span>
        });

<span class="fc bfc" id="L594" title="All 2 branches covered.">        for (int i = 0; i &lt; 10; i++) {</span>
<span class="fc" id="L595">            Observable&lt;Integer&gt; merge = Observable.merge(o, o, o);</span>
<span class="fc" id="L596">            TestObserver&lt;Integer&gt; to = new TestObserver&lt;Integer&gt;();</span>
<span class="fc" id="L597">            merge.subscribe(to);</span>

<span class="fc" id="L599">            to.awaitTerminalEvent();</span>
<span class="fc" id="L600">            to.assertComplete();</span>
<span class="fc" id="L601">            List&lt;Integer&gt; onNextEvents = to.values();</span>
<span class="fc" id="L602">            assertEquals(300, onNextEvents.size());</span>
            //            System.out.println(&quot;onNext: &quot; + onNextEvents.size() + &quot; onComplete: &quot; + ts.getOnCompletedEvents().size());
        }
<span class="fc" id="L605">    }</span>

    @Test
    public void testConcurrencyWithBrokenOnCompleteContract() {
<span class="fc" id="L609">        Observable&lt;Integer&gt; o = Observable.unsafeCreate(new ObservableSource&lt;Integer&gt;() {</span>

            @Override
            public void subscribe(final Observer&lt;? super Integer&gt; observer) {
<span class="fc" id="L613">                Worker inner = Schedulers.newThread().createWorker();</span>
<span class="fc" id="L614">                final CompositeDisposable as = new CompositeDisposable();</span>
<span class="fc" id="L615">                as.add(Disposables.empty());</span>
<span class="fc" id="L616">                as.add(inner);</span>

<span class="fc" id="L618">                observer.onSubscribe(as);</span>

<span class="fc" id="L620">                inner.schedule(new Runnable() {</span>

                    @Override
                    public void run() {
                        try {
<span class="fc bfc" id="L625" title="All 2 branches covered.">                            for (int i = 0; i &lt; 10000; i++) {</span>
<span class="fc" id="L626">                                observer.onNext(i);</span>
                            }
<span class="nc" id="L628">                        } catch (Exception e) {</span>
<span class="nc" id="L629">                            observer.onError(e);</span>
<span class="fc" id="L630">                        }</span>
<span class="fc" id="L631">                        as.dispose();</span>
<span class="fc" id="L632">                        observer.onComplete();</span>
<span class="fc" id="L633">                        observer.onComplete();</span>
<span class="fc" id="L634">                        observer.onComplete();</span>
<span class="fc" id="L635">                    }</span>

                });
<span class="fc" id="L638">            }</span>
        });

<span class="fc bfc" id="L641" title="All 2 branches covered.">        for (int i = 0; i &lt; 10; i++) {</span>
<span class="fc" id="L642">            Observable&lt;Integer&gt; merge = Observable.merge(o, o, o);</span>
<span class="fc" id="L643">            TestObserver&lt;Integer&gt; to = new TestObserver&lt;Integer&gt;();</span>
<span class="fc" id="L644">            merge.subscribe(to);</span>

<span class="fc" id="L646">            to.awaitTerminalEvent();</span>
<span class="fc" id="L647">            to.assertNoErrors();</span>
<span class="fc" id="L648">            to.assertComplete();</span>
<span class="fc" id="L649">            List&lt;Integer&gt; onNextEvents = to.values();</span>
<span class="fc" id="L650">            assertEquals(30000, onNextEvents.size());</span>
            //                System.out.println(&quot;onNext: &quot; + onNextEvents.size() + &quot; onComplete: &quot; + ts.getOnCompletedEvents().size());
        }
<span class="fc" id="L653">    }</span>

    @Test
    public void testBackpressureUpstream() throws InterruptedException {
<span class="fc" id="L657">        final AtomicInteger generated1 = new AtomicInteger();</span>
<span class="fc" id="L658">        Observable&lt;Integer&gt; o1 = createInfiniteObservable(generated1).subscribeOn(Schedulers.computation());</span>
<span class="fc" id="L659">        final AtomicInteger generated2 = new AtomicInteger();</span>
<span class="fc" id="L660">        Observable&lt;Integer&gt; o2 = createInfiniteObservable(generated2).subscribeOn(Schedulers.computation());</span>

<span class="fc" id="L662">        TestObserver&lt;Integer&gt; testObserver = new TestObserver&lt;Integer&gt;() {</span>
            @Override
            public void onNext(Integer t) {
<span class="fc" id="L665">                System.err.println(&quot;TestObserver received =&gt; &quot; + t + &quot;  on thread &quot; + Thread.currentThread());</span>
<span class="fc" id="L666">                super.onNext(t);</span>
<span class="fc" id="L667">            }</span>
        };

<span class="fc" id="L670">        Observable.merge(o1.take(Flowable.bufferSize() * 2), o2.take(Flowable.bufferSize() * 2)).subscribe(testObserver);</span>
<span class="fc" id="L671">        testObserver.awaitTerminalEvent();</span>
<span class="pc bpc" id="L672" title="1 of 2 branches missed.">        if (testObserver.errors().size() &gt; 0) {</span>
<span class="nc" id="L673">            testObserver.errors().get(0).printStackTrace();</span>
        }
<span class="fc" id="L675">        testObserver.assertNoErrors();</span>
<span class="fc" id="L676">        System.err.println(testObserver.values());</span>
<span class="fc" id="L677">        assertEquals(Flowable.bufferSize() * 4, testObserver.values().size());</span>
        // it should be between the take num and requested batch size across the async boundary
<span class="fc" id="L679">        System.out.println(&quot;Generated 1: &quot; + generated1.get());</span>
<span class="fc" id="L680">        System.out.println(&quot;Generated 2: &quot; + generated2.get());</span>
<span class="pc bpc" id="L681" title="1 of 2 branches missed.">        assertTrue(generated1.get() &gt;= Flowable.bufferSize() * 2</span>
<span class="pc bpc" id="L682" title="1 of 2 branches missed.">                &amp;&amp; generated1.get() &lt;= Flowable.bufferSize() * 4);</span>
<span class="fc" id="L683">    }</span>

    @Test
    public void testBackpressureUpstream2InLoop() throws InterruptedException {
<span class="fc bfc" id="L687" title="All 2 branches covered.">        for (int i = 0; i &lt; 1000; i++) {</span>
<span class="fc" id="L688">            System.err.flush();</span>
<span class="fc" id="L689">            System.out.println(&quot;---&quot;);</span>
<span class="fc" id="L690">            System.out.flush();</span>
<span class="fc" id="L691">            testBackpressureUpstream2();</span>
        }
<span class="fc" id="L693">    }</span>

    @Test
    public void testBackpressureUpstream2() throws InterruptedException {
<span class="fc" id="L697">        final AtomicInteger generated1 = new AtomicInteger();</span>
<span class="fc" id="L698">        Observable&lt;Integer&gt; o1 = createInfiniteObservable(generated1).subscribeOn(Schedulers.computation());</span>

<span class="fc" id="L700">        TestObserver&lt;Integer&gt; testObserver = new TestObserver&lt;Integer&gt;() {</span>
            @Override
            public void onNext(Integer t) {
<span class="fc" id="L703">                super.onNext(t);</span>
<span class="fc" id="L704">            }</span>
        };

<span class="fc" id="L707">        Observable.merge(o1.take(Flowable.bufferSize() * 2), Observable.just(-99)).subscribe(testObserver);</span>
<span class="fc" id="L708">        testObserver.awaitTerminalEvent();</span>

<span class="fc" id="L710">        List&lt;Integer&gt; onNextEvents = testObserver.values();</span>

<span class="fc" id="L712">        System.out.println(&quot;Generated 1: &quot; + generated1.get() + &quot; / received: &quot; + onNextEvents.size());</span>
<span class="fc" id="L713">        System.out.println(onNextEvents);</span>

<span class="pc bpc" id="L715" title="1 of 2 branches missed.">        if (testObserver.errors().size() &gt; 0) {</span>
<span class="nc" id="L716">            testObserver.errors().get(0).printStackTrace();</span>
        }
<span class="fc" id="L718">        testObserver.assertNoErrors();</span>
<span class="fc" id="L719">        assertEquals(Flowable.bufferSize() * 2 + 1, onNextEvents.size());</span>
        // it should be between the take num and requested batch size across the async boundary
<span class="pc bpc" id="L721" title="2 of 4 branches missed.">        assertTrue(generated1.get() &gt;= Flowable.bufferSize() * 2 &amp;&amp; generated1.get() &lt;= Flowable.bufferSize() * 3);</span>
<span class="fc" id="L722">    }</span>

    /**
     * This is the same as the upstreams ones, but now adds the downstream as well by using observeOn.
     *
     * This requires merge to also obey the Product.request values coming from it's child Observer.
     * @throws InterruptedException if the test is interrupted
     */
    @Test(timeout = 10000)
    public void testBackpressureDownstreamWithConcurrentStreams() throws InterruptedException {
<span class="fc" id="L732">        final AtomicInteger generated1 = new AtomicInteger();</span>
<span class="fc" id="L733">        Observable&lt;Integer&gt; o1 = createInfiniteObservable(generated1).subscribeOn(Schedulers.computation());</span>
<span class="fc" id="L734">        final AtomicInteger generated2 = new AtomicInteger();</span>
<span class="fc" id="L735">        Observable&lt;Integer&gt; o2 = createInfiniteObservable(generated2).subscribeOn(Schedulers.computation());</span>

<span class="fc" id="L737">        TestObserver&lt;Integer&gt; to = new TestObserver&lt;Integer&gt;() {</span>
            @Override
            public void onNext(Integer t) {
<span class="fc bfc" id="L740" title="All 2 branches covered.">                if (t &lt; 100) {</span>
                    try {
                        // force a slow consumer
<span class="fc" id="L743">                        Thread.sleep(1);</span>
<span class="nc" id="L744">                    } catch (InterruptedException e) {</span>
<span class="nc" id="L745">                        e.printStackTrace();</span>
<span class="fc" id="L746">                    }</span>
                }
                //                System.err.println(&quot;TestObserver received =&gt; &quot; + t + &quot;  on thread &quot; + Thread.currentThread());
<span class="fc" id="L749">                super.onNext(t);</span>
<span class="fc" id="L750">            }</span>
        };

<span class="fc" id="L753">        Observable.merge(o1.take(Flowable.bufferSize() * 2), o2.take(Flowable.bufferSize() * 2)).observeOn(Schedulers.computation()).subscribe(to);</span>
<span class="fc" id="L754">        to.awaitTerminalEvent();</span>
<span class="pc bpc" id="L755" title="1 of 2 branches missed.">        if (to.errors().size() &gt; 0) {</span>
<span class="nc" id="L756">            to.errors().get(0).printStackTrace();</span>
        }
<span class="fc" id="L758">        to.assertNoErrors();</span>
<span class="fc" id="L759">        System.err.println(to.values());</span>
<span class="fc" id="L760">        assertEquals(Flowable.bufferSize() * 4, to.values().size());</span>
        // it should be between the take num and requested batch size across the async boundary
<span class="fc" id="L762">        System.out.println(&quot;Generated 1: &quot; + generated1.get());</span>
<span class="fc" id="L763">        System.out.println(&quot;Generated 2: &quot; + generated2.get());</span>
<span class="pc bpc" id="L764" title="2 of 4 branches missed.">        assertTrue(generated1.get() &gt;= Flowable.bufferSize() * 2 &amp;&amp; generated1.get() &lt;= Flowable.bufferSize() * 4);</span>
<span class="fc" id="L765">    }</span>

    /**
     * Currently there is no solution to this ... we can't exert backpressure on the outer Observable if we
     * can't know if the ones we've received so far are going to emit or not, otherwise we could starve the system.
     *
     * For example, 10,000 Observables are being merged (bad use case to begin with, but ...) and it's only one of them
     * that will ever emit. If backpressure only allowed the first 1,000 to be sent, we would hang and never receive an event.
     *
     * Thus, we must allow all Observables to be sent. The ScalarSynchronousObservable use case is an exception to this since
     * we can grab the value synchronously.
     *
     * @throws InterruptedException if the await is interrupted
     */
    @Test(timeout = 5000)
    public void testBackpressureBothUpstreamAndDownstreamWithRegularObservables() throws InterruptedException {
<span class="fc" id="L781">        final AtomicInteger generated1 = new AtomicInteger();</span>
<span class="fc" id="L782">        Observable&lt;Observable&lt;Integer&gt;&gt; o1 = createInfiniteObservable(generated1).map(new Function&lt;Integer, Observable&lt;Integer&gt;&gt;() {</span>

            @Override
            public Observable&lt;Integer&gt; apply(Integer t1) {
<span class="fc" id="L786">                return Observable.just(1, 2, 3);</span>
            }

        });

<span class="fc" id="L791">        TestObserver&lt;Integer&gt; to = new TestObserver&lt;Integer&gt;() {</span>
            int i;

            @Override
            public void onNext(Integer t) {
<span class="pc bpc" id="L796" title="1 of 2 branches missed.">                if (i++ &lt; 400) {</span>
                    try {
                        // force a slow consumer
<span class="fc" id="L799">                        Thread.sleep(1);</span>
<span class="nc" id="L800">                    } catch (InterruptedException e) {</span>
<span class="nc" id="L801">                        e.printStackTrace();</span>
<span class="fc" id="L802">                    }</span>
                }
                //                System.err.println(&quot;TestObserver received =&gt; &quot; + t + &quot;  on thread &quot; + Thread.currentThread());
<span class="fc" id="L805">                super.onNext(t);</span>
<span class="fc" id="L806">            }</span>
        };

<span class="fc" id="L809">        Observable.merge(o1).observeOn(Schedulers.computation()).take(Flowable.bufferSize() * 2).subscribe(to);</span>
<span class="fc" id="L810">        to.awaitTerminalEvent();</span>
<span class="pc bpc" id="L811" title="1 of 2 branches missed.">        if (to.errors().size() &gt; 0) {</span>
<span class="nc" id="L812">            to.errors().get(0).printStackTrace();</span>
        }
<span class="fc" id="L814">        to.assertNoErrors();</span>
<span class="fc" id="L815">        System.out.println(&quot;Generated 1: &quot; + generated1.get());</span>
<span class="fc" id="L816">        System.err.println(to.values());</span>
<span class="fc" id="L817">        System.out.println(&quot;done1 testBackpressureBothUpstreamAndDownstreamWithRegularObservables &quot;);</span>
<span class="fc" id="L818">        assertEquals(Flowable.bufferSize() * 2, to.values().size());</span>
<span class="fc" id="L819">        System.out.println(&quot;done2 testBackpressureBothUpstreamAndDownstreamWithRegularObservables &quot;);</span>
        // we can't restrict this ... see comment above
        //        assertTrue(generated1.get() &gt;= Observable.bufferSize() &amp;&amp; generated1.get() &lt;= Observable.bufferSize() * 4);
<span class="fc" id="L822">    }</span>

    @Test
    @Ignore(&quot;Null values not permitted&quot;)
    public void mergeWithNullValues() {
<span class="nc" id="L827">        System.out.println(&quot;mergeWithNullValues&quot;);</span>
<span class="nc" id="L828">        TestObserver&lt;String&gt; to = new TestObserver&lt;String&gt;();</span>
<span class="nc" id="L829">        Observable.merge(Observable.just(null, &quot;one&quot;), Observable.just(&quot;two&quot;, null)).subscribe(to);</span>
<span class="nc" id="L830">        to.assertTerminated();</span>
<span class="nc" id="L831">        to.assertNoErrors();</span>
<span class="nc" id="L832">        to.assertValues(null, &quot;one&quot;, &quot;two&quot;, null);</span>
<span class="nc" id="L833">    }</span>

    @Test
    @Ignore(&quot;Null values are no longer permitted&quot;)
    public void mergeWithTerminalEventAfterUnsubscribe() {
<span class="nc" id="L838">        System.out.println(&quot;mergeWithTerminalEventAfterUnsubscribe&quot;);</span>
<span class="nc" id="L839">        TestObserver&lt;String&gt; to = new TestObserver&lt;String&gt;();</span>
<span class="nc" id="L840">        Observable&lt;String&gt; bad = Observable.unsafeCreate(new ObservableSource&lt;String&gt;() {</span>

            @Override
            public void subscribe(Observer&lt;? super String&gt; observer) {
<span class="nc" id="L844">                observer.onNext(&quot;two&quot;);</span>
                // FIXME can't cancel downstream
//                s.unsubscribe();
//                s.onComplete();
<span class="nc" id="L848">            }</span>

        });
<span class="nc" id="L851">        Observable.merge(Observable.just(null, &quot;one&quot;), bad).subscribe(to);</span>
<span class="nc" id="L852">        to.assertNoErrors();</span>
<span class="nc" id="L853">        to.assertValues(null, &quot;one&quot;, &quot;two&quot;);</span>
<span class="nc" id="L854">    }</span>

    @Test
    @Ignore(&quot;Null values are not permitted&quot;)
    public void mergingNullObservable() {
<span class="nc" id="L859">        TestObserver&lt;String&gt; to = new TestObserver&lt;String&gt;();</span>
<span class="nc" id="L860">        Observable.merge(Observable.just(&quot;one&quot;), null).subscribe(to);</span>
<span class="nc" id="L861">        to.assertNoErrors();</span>
<span class="nc" id="L862">        to.assertValue(&quot;one&quot;);</span>
<span class="nc" id="L863">    }</span>

    @Test
    public void merge1AsyncStreamOf1() {
<span class="fc" id="L867">        TestObserver&lt;Integer&gt; to = new TestObserver&lt;Integer&gt;();</span>
<span class="fc" id="L868">        mergeNAsyncStreamsOfN(1, 1).subscribe(to);</span>
<span class="fc" id="L869">        to.awaitTerminalEvent();</span>
<span class="fc" id="L870">        to.assertNoErrors();</span>
<span class="fc" id="L871">        assertEquals(1, to.values().size());</span>
<span class="fc" id="L872">    }</span>

    @Test
    public void merge1AsyncStreamOf1000() {
<span class="fc" id="L876">        TestObserver&lt;Integer&gt; to = new TestObserver&lt;Integer&gt;();</span>
<span class="fc" id="L877">        mergeNAsyncStreamsOfN(1, 1000).subscribe(to);</span>
<span class="fc" id="L878">        to.awaitTerminalEvent();</span>
<span class="fc" id="L879">        to.assertNoErrors();</span>
<span class="fc" id="L880">        assertEquals(1000, to.values().size());</span>
<span class="fc" id="L881">    }</span>

    @Test
    public void merge10AsyncStreamOf1000() {
<span class="fc" id="L885">        TestObserver&lt;Integer&gt; to = new TestObserver&lt;Integer&gt;();</span>
<span class="fc" id="L886">        mergeNAsyncStreamsOfN(10, 1000).subscribe(to);</span>
<span class="fc" id="L887">        to.awaitTerminalEvent();</span>
<span class="fc" id="L888">        to.assertNoErrors();</span>
<span class="fc" id="L889">        assertEquals(10000, to.values().size());</span>
<span class="fc" id="L890">    }</span>

    @Test
    public void merge1000AsyncStreamOf1000() {
<span class="fc" id="L894">        TestObserver&lt;Integer&gt; to = new TestObserver&lt;Integer&gt;();</span>
<span class="fc" id="L895">        mergeNAsyncStreamsOfN(1000, 1000).subscribe(to);</span>
<span class="fc" id="L896">        to.awaitTerminalEvent();</span>
<span class="fc" id="L897">        to.assertNoErrors();</span>
<span class="fc" id="L898">        assertEquals(1000000, to.values().size());</span>
<span class="fc" id="L899">    }</span>

    @Test
    public void merge2000AsyncStreamOf100() {
<span class="fc" id="L903">        TestObserver&lt;Integer&gt; to = new TestObserver&lt;Integer&gt;();</span>
<span class="fc" id="L904">        mergeNAsyncStreamsOfN(2000, 100).subscribe(to);</span>
<span class="fc" id="L905">        to.awaitTerminalEvent();</span>
<span class="fc" id="L906">        to.assertNoErrors();</span>
<span class="fc" id="L907">        assertEquals(200000, to.values().size());</span>
<span class="fc" id="L908">    }</span>

    @Test
    public void merge100AsyncStreamOf1() {
<span class="fc" id="L912">        TestObserver&lt;Integer&gt; to = new TestObserver&lt;Integer&gt;();</span>
<span class="fc" id="L913">        mergeNAsyncStreamsOfN(100, 1).subscribe(to);</span>
<span class="fc" id="L914">        to.awaitTerminalEvent();</span>
<span class="fc" id="L915">        to.assertNoErrors();</span>
<span class="fc" id="L916">        assertEquals(100, to.values().size());</span>
<span class="fc" id="L917">    }</span>

    private Observable&lt;Integer&gt; mergeNAsyncStreamsOfN(final int outerSize, final int innerSize) {
<span class="fc" id="L920">        Observable&lt;Observable&lt;Integer&gt;&gt; os = Observable.range(1, outerSize)</span>
<span class="fc" id="L921">        .map(new Function&lt;Integer, Observable&lt;Integer&gt;&gt;() {</span>

            @Override
            public Observable&lt;Integer&gt; apply(Integer i) {
<span class="fc" id="L925">                return Observable.range(1, innerSize).subscribeOn(Schedulers.computation());</span>
            }

        });
<span class="fc" id="L929">        return Observable.merge(os);</span>
    }

    @Test
    public void merge1SyncStreamOf1() {
<span class="fc" id="L934">        TestObserver&lt;Integer&gt; to = new TestObserver&lt;Integer&gt;();</span>
<span class="fc" id="L935">        mergeNSyncStreamsOfN(1, 1).subscribe(to);</span>
<span class="fc" id="L936">        to.awaitTerminalEvent();</span>
<span class="fc" id="L937">        to.assertNoErrors();</span>
<span class="fc" id="L938">        assertEquals(1, to.values().size());</span>
<span class="fc" id="L939">    }</span>

    @Test
    public void merge1SyncStreamOf1000000() {
<span class="fc" id="L943">        TestObserver&lt;Integer&gt; to = new TestObserver&lt;Integer&gt;();</span>
<span class="fc" id="L944">        mergeNSyncStreamsOfN(1, 1000000).subscribe(to);</span>
<span class="fc" id="L945">        to.awaitTerminalEvent();</span>
<span class="fc" id="L946">        to.assertNoErrors();</span>
<span class="fc" id="L947">        assertEquals(1000000, to.values().size());</span>
<span class="fc" id="L948">    }</span>

    @Test
    public void merge1000SyncStreamOf1000() {
<span class="fc" id="L952">        TestObserver&lt;Integer&gt; to = new TestObserver&lt;Integer&gt;();</span>
<span class="fc" id="L953">        mergeNSyncStreamsOfN(1000, 1000).subscribe(to);</span>
<span class="fc" id="L954">        to.awaitTerminalEvent();</span>
<span class="fc" id="L955">        to.assertNoErrors();</span>
<span class="fc" id="L956">        assertEquals(1000000, to.values().size());</span>
<span class="fc" id="L957">    }</span>

    @Test
    public void merge10000SyncStreamOf10() {
<span class="fc" id="L961">        TestObserver&lt;Integer&gt; to = new TestObserver&lt;Integer&gt;();</span>
<span class="fc" id="L962">        mergeNSyncStreamsOfN(10000, 10).subscribe(to);</span>
<span class="fc" id="L963">        to.awaitTerminalEvent();</span>
<span class="fc" id="L964">        to.assertNoErrors();</span>
<span class="fc" id="L965">        assertEquals(100000, to.values().size());</span>
<span class="fc" id="L966">    }</span>

    @Test
    public void merge1000000SyncStreamOf1() {
<span class="fc" id="L970">        TestObserver&lt;Integer&gt; to = new TestObserver&lt;Integer&gt;();</span>
<span class="fc" id="L971">        mergeNSyncStreamsOfN(1000000, 1).subscribe(to);</span>
<span class="fc" id="L972">        to.awaitTerminalEvent();</span>
<span class="fc" id="L973">        to.assertNoErrors();</span>
<span class="fc" id="L974">        assertEquals(1000000, to.values().size());</span>
<span class="fc" id="L975">    }</span>

    private Observable&lt;Integer&gt; mergeNSyncStreamsOfN(final int outerSize, final int innerSize) {
<span class="fc" id="L978">        Observable&lt;Observable&lt;Integer&gt;&gt; os = Observable.range(1, outerSize)</span>
<span class="fc" id="L979">        .map(new Function&lt;Integer, Observable&lt;Integer&gt;&gt;() {</span>

            @Override
            public Observable&lt;Integer&gt; apply(Integer i) {
<span class="fc" id="L983">                return Observable.range(1, innerSize);</span>
            }

        });
<span class="fc" id="L987">        return Observable.merge(os);</span>
    }

    private Observable&lt;Integer&gt; createInfiniteObservable(final AtomicInteger generated) {
<span class="fc" id="L991">        Observable&lt;Integer&gt; o = Observable.fromIterable(new Iterable&lt;Integer&gt;() {</span>
            @Override
            public Iterator&lt;Integer&gt; iterator() {
<span class="fc" id="L994">                return new Iterator&lt;Integer&gt;() {</span>

                    @Override
                    public void remove() {
<span class="nc" id="L998">                    }</span>

                    @Override
                    public Integer next() {
<span class="fc" id="L1002">                        return generated.getAndIncrement();</span>
                    }

                    @Override
                    public boolean hasNext() {
<span class="fc" id="L1007">                        return true;</span>
                    }
                };
            }
        });
<span class="fc" id="L1012">        return o;</span>
    }

    @Test
    public void mergeManyAsyncSingle() {
<span class="fc" id="L1017">        TestObserver&lt;Integer&gt; to = new TestObserver&lt;Integer&gt;();</span>
<span class="fc" id="L1018">        Observable&lt;Observable&lt;Integer&gt;&gt; os = Observable.range(1, 10000)</span>
<span class="fc" id="L1019">        .map(new Function&lt;Integer, Observable&lt;Integer&gt;&gt;() {</span>

            @Override
            public Observable&lt;Integer&gt; apply(final Integer i) {
<span class="fc" id="L1023">                return Observable.unsafeCreate(new ObservableSource&lt;Integer&gt;() {</span>

                    @Override
                    public void subscribe(Observer&lt;? super Integer&gt; observer) {
<span class="fc" id="L1027">                        observer.onSubscribe(Disposables.empty());</span>
<span class="fc bfc" id="L1028" title="All 2 branches covered.">                        if (i &lt; 500) {</span>
                            try {
<span class="fc" id="L1030">                                Thread.sleep(1);</span>
<span class="nc" id="L1031">                            } catch (InterruptedException e) {</span>
<span class="nc" id="L1032">                                e.printStackTrace();</span>
<span class="fc" id="L1033">                            }</span>
                        }
<span class="fc" id="L1035">                        observer.onNext(i);</span>
<span class="fc" id="L1036">                        observer.onComplete();</span>
<span class="fc" id="L1037">                    }</span>

<span class="fc" id="L1039">                }).subscribeOn(Schedulers.computation()).cache();</span>
            }

        });
<span class="fc" id="L1043">        Observable.merge(os).subscribe(to);</span>
<span class="fc" id="L1044">        to.awaitTerminalEvent();</span>
<span class="fc" id="L1045">        to.assertNoErrors();</span>
<span class="fc" id="L1046">        assertEquals(10000, to.values().size());</span>
<span class="fc" id="L1047">    }</span>

<span class="fc" id="L1049">    Function&lt;Integer, Observable&lt;Integer&gt;&gt; toScalar = new Function&lt;Integer, Observable&lt;Integer&gt;&gt;() {</span>
        @Override
        public Observable&lt;Integer&gt; apply(Integer v) {
<span class="fc" id="L1052">            return Observable.just(v);</span>
        }
    };

<span class="fc" id="L1056">    Function&lt;Integer, Observable&lt;Integer&gt;&gt; toHiddenScalar = new Function&lt;Integer, Observable&lt;Integer&gt;&gt;() {</span>
        @Override
        public Observable&lt;Integer&gt; apply(Integer t) {
<span class="fc" id="L1059">            return Observable.just(t).hide();</span>
        }
    };
    ;

    void runMerge(Function&lt;Integer, Observable&lt;Integer&gt;&gt; func, TestObserver&lt;Integer&gt; to) {
<span class="fc" id="L1065">        List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</span>
<span class="fc bfc" id="L1066" title="All 2 branches covered.">        for (int i = 0; i &lt; 1000; i++) {</span>
<span class="fc" id="L1067">            list.add(i);</span>
        }
<span class="fc" id="L1069">        Observable&lt;Integer&gt; source = Observable.fromIterable(list);</span>
<span class="fc" id="L1070">        source.flatMap(func).subscribe(to);</span>

<span class="pc bpc" id="L1072" title="1 of 2 branches missed.">        if (to.values().size() != 1000) {</span>
<span class="nc" id="L1073">            System.out.println(to.values());</span>
        }

<span class="fc" id="L1076">        to.assertTerminated();</span>
<span class="fc" id="L1077">        to.assertNoErrors();</span>
<span class="fc" id="L1078">        to.assertValueSequence(list);</span>
<span class="fc" id="L1079">    }</span>

    @Test
    public void testFastMergeFullScalar() {
<span class="fc" id="L1083">        runMerge(toScalar, new TestObserver&lt;Integer&gt;());</span>
<span class="fc" id="L1084">    }</span>

    @Test
    public void testFastMergeHiddenScalar() {
<span class="fc" id="L1088">        runMerge(toHiddenScalar, new TestObserver&lt;Integer&gt;());</span>
<span class="fc" id="L1089">    }</span>

    @Test
    public void testSlowMergeFullScalar() {
<span class="fc bfc" id="L1093" title="All 2 branches covered.">        for (final int req : new int[] { 16, 32, 64, 128, 256 }) {</span>
<span class="fc" id="L1094">            TestObserver&lt;Integer&gt; to = new TestObserver&lt;Integer&gt;() {</span>
<span class="fc" id="L1095">                int remaining = req;</span>

                @Override
                public void onNext(Integer t) {
<span class="fc" id="L1099">                    super.onNext(t);</span>
<span class="fc bfc" id="L1100" title="All 2 branches covered.">                    if (--remaining == 0) {</span>
<span class="fc" id="L1101">                        remaining = req;</span>
                    }
<span class="fc" id="L1103">                }</span>
            };
<span class="fc" id="L1105">            runMerge(toScalar, to);</span>
        }
<span class="fc" id="L1107">    }</span>

    @Test
    public void testSlowMergeHiddenScalar() {
<span class="fc bfc" id="L1111" title="All 2 branches covered.">        for (final int req : new int[] { 16, 32, 64, 128, 256 }) {</span>
<span class="fc" id="L1112">            TestObserver&lt;Integer&gt; to = new TestObserver&lt;Integer&gt;() {</span>
<span class="fc" id="L1113">                int remaining = req;</span>
                @Override
                public void onNext(Integer t) {
<span class="fc" id="L1116">                    super.onNext(t);</span>
<span class="fc bfc" id="L1117" title="All 2 branches covered.">                    if (--remaining == 0) {</span>
<span class="fc" id="L1118">                        remaining = req;</span>
                    }
<span class="fc" id="L1120">                }</span>
            };
<span class="fc" id="L1122">            runMerge(toHiddenScalar, to);</span>
        }
<span class="fc" id="L1124">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void mergeArray() {
<span class="fc" id="L1129">        Observable.mergeArray(Observable.just(1), Observable.just(2))</span>
<span class="fc" id="L1130">        .test()</span>
<span class="fc" id="L1131">        .assertResult(1, 2);</span>
<span class="fc" id="L1132">    }</span>

    @Test
    public void mergeErrors() {
<span class="fc" id="L1136">        List&lt;Throwable&gt; errors = TestHelper.trackPluginErrors();</span>
        try {
<span class="fc" id="L1138">            Observable&lt;Integer&gt; source1 = Observable.error(new TestException(&quot;First&quot;));</span>
<span class="fc" id="L1139">            Observable&lt;Integer&gt; source2 = Observable.error(new TestException(&quot;Second&quot;));</span>

<span class="fc" id="L1141">            Observable.merge(source1, source2)</span>
<span class="fc" id="L1142">            .test()</span>
<span class="fc" id="L1143">            .assertFailureAndMessage(TestException.class, &quot;First&quot;);</span>

<span class="fc" id="L1145">            assertTrue(errors.toString(), errors.isEmpty());</span>
        } finally {
<span class="fc" id="L1147">            RxJavaPlugins.reset();</span>
        }
<span class="fc" id="L1149">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>