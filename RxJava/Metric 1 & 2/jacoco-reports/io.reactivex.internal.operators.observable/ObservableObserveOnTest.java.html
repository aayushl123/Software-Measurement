<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ObservableObserveOnTest.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">RxJava_2_x$Unnamed.exec</a> &gt; <a href="index.source.html" class="el_package">io.reactivex.internal.operators.observable</a> &gt; <span class="el_source">ObservableObserveOnTest.java</span></div><h1>ObservableObserveOnTest.java</h1><pre class="source lang-java linenums">/**
 * Copyright (c) 2016-present, RxJava Contributors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is
 * distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
 * the License for the specific language governing permissions and limitations under the License.
 */

package io.reactivex.internal.operators.observable;

import static org.junit.Assert.*;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;

import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.*;

import org.junit.Test;
import org.mockito.InOrder;

import io.reactivex.*;
import io.reactivex.Observable;
import io.reactivex.Observer;
import io.reactivex.annotations.Nullable;
import io.reactivex.disposables.*;
import io.reactivex.exceptions.TestException;
import io.reactivex.functions.*;
import io.reactivex.internal.fuseable.*;
import io.reactivex.internal.operators.flowable.FlowableObserveOnTest.DisposeTrackingScheduler;
import io.reactivex.internal.operators.observable.ObservableObserveOn.ObserveOnObserver;
import io.reactivex.internal.schedulers.ImmediateThinScheduler;
import io.reactivex.observers.*;
import io.reactivex.plugins.RxJavaPlugins;
import io.reactivex.schedulers.*;
import io.reactivex.subjects.*;

<span class="fc" id="L43">public class ObservableObserveOnTest {</span>

    /**
     * This is testing a no-op path since it uses Schedulers.immediate() which will not do scheduling.
     */
    @Test
    public void testObserveOn() {
<span class="fc" id="L50">        Observer&lt;Integer&gt; observer = TestHelper.mockObserver();</span>
<span class="fc" id="L51">        Observable.just(1, 2, 3).observeOn(ImmediateThinScheduler.INSTANCE).subscribe(observer);</span>

<span class="fc" id="L53">        verify(observer, times(1)).onNext(1);</span>
<span class="fc" id="L54">        verify(observer, times(1)).onNext(2);</span>
<span class="fc" id="L55">        verify(observer, times(1)).onNext(3);</span>
<span class="fc" id="L56">        verify(observer, times(1)).onComplete();</span>
<span class="fc" id="L57">    }</span>

    @Test
    public void testOrdering() throws InterruptedException {
//        Observable&lt;String&gt; obs = Observable.just(&quot;one&quot;, null, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;);
        // FIXME null values not allowed
<span class="fc" id="L63">        Observable&lt;String&gt; obs = Observable.just(&quot;one&quot;, &quot;null&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;);</span>

<span class="fc" id="L65">        Observer&lt;String&gt; observer = TestHelper.mockObserver();</span>

<span class="fc" id="L67">        InOrder inOrder = inOrder(observer);</span>
<span class="fc" id="L68">        TestObserver&lt;String&gt; to = new TestObserver&lt;String&gt;(observer);</span>

<span class="fc" id="L70">        obs.observeOn(Schedulers.computation()).subscribe(to);</span>

<span class="fc" id="L72">        to.awaitTerminalEvent(1000, TimeUnit.MILLISECONDS);</span>
<span class="pc bpc" id="L73" title="1 of 2 branches missed.">        if (to.errors().size() &gt; 0) {</span>
<span class="nc bnc" id="L74" title="All 2 branches missed.">            for (Throwable t : to.errors()) {</span>
<span class="nc" id="L75">                t.printStackTrace();</span>
<span class="nc" id="L76">            }</span>
<span class="nc" id="L77">            fail(&quot;failed with exception&quot;);</span>
        }

<span class="fc" id="L80">        inOrder.verify(observer, times(1)).onNext(&quot;one&quot;);</span>
<span class="fc" id="L81">        inOrder.verify(observer, times(1)).onNext(&quot;null&quot;);</span>
<span class="fc" id="L82">        inOrder.verify(observer, times(1)).onNext(&quot;two&quot;);</span>
<span class="fc" id="L83">        inOrder.verify(observer, times(1)).onNext(&quot;three&quot;);</span>
<span class="fc" id="L84">        inOrder.verify(observer, times(1)).onNext(&quot;four&quot;);</span>
<span class="fc" id="L85">        inOrder.verify(observer, times(1)).onComplete();</span>
<span class="fc" id="L86">        inOrder.verifyNoMoreInteractions();</span>
<span class="fc" id="L87">    }</span>

    @Test
    public void testThreadName() throws InterruptedException {
<span class="fc" id="L91">        System.out.println(&quot;Main Thread: &quot; + Thread.currentThread().getName());</span>
        // FIXME null values not allowed
//        Observable&lt;String&gt; obs = Observable.just(&quot;one&quot;, null, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;);
<span class="fc" id="L94">        Observable&lt;String&gt; obs = Observable.just(&quot;one&quot;, &quot;null&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;);</span>

<span class="fc" id="L96">        Observer&lt;String&gt; observer = TestHelper.mockObserver();</span>
<span class="fc" id="L97">        final String parentThreadName = Thread.currentThread().getName();</span>

<span class="fc" id="L99">        final CountDownLatch completedLatch = new CountDownLatch(1);</span>

        // assert subscribe is on main thread
<span class="fc" id="L102">        obs = obs.doOnNext(new Consumer&lt;String&gt;() {</span>

            @Override
            public void accept(String s) {
<span class="fc" id="L106">                String threadName = Thread.currentThread().getName();</span>
<span class="fc" id="L107">                System.out.println(&quot;Source ThreadName: &quot; + threadName + &quot;  Expected =&gt; &quot; + parentThreadName);</span>
<span class="fc" id="L108">                assertEquals(parentThreadName, threadName);</span>
<span class="fc" id="L109">            }</span>

        });

        // assert observe is on new thread
<span class="fc" id="L114">        obs.observeOn(Schedulers.newThread()).doOnNext(new Consumer&lt;String&gt;() {</span>

            @Override
            public void accept(String t1) {
<span class="fc" id="L118">                String threadName = Thread.currentThread().getName();</span>
<span class="fc" id="L119">                boolean correctThreadName = threadName.startsWith(&quot;RxNewThreadScheduler&quot;);</span>
<span class="fc" id="L120">                System.out.println(&quot;ObserveOn ThreadName: &quot; + threadName + &quot;  Correct =&gt; &quot; + correctThreadName);</span>
<span class="fc" id="L121">                assertTrue(correctThreadName);</span>
<span class="fc" id="L122">            }</span>

<span class="fc" id="L124">        }).doAfterTerminate(new Action() {</span>

            @Override
            public void run() {
<span class="fc" id="L128">                completedLatch.countDown();</span>

<span class="fc" id="L130">            }</span>
<span class="fc" id="L131">        }).subscribe(observer);</span>

<span class="pc bpc" id="L133" title="1 of 2 branches missed.">        if (!completedLatch.await(1000, TimeUnit.MILLISECONDS)) {</span>
<span class="nc" id="L134">            fail(&quot;timed out waiting&quot;);</span>
        }

<span class="fc" id="L137">        verify(observer, never()).onError(any(Throwable.class));</span>
<span class="fc" id="L138">        verify(observer, times(5)).onNext(any(String.class));</span>
<span class="fc" id="L139">        verify(observer, times(1)).onComplete();</span>
<span class="fc" id="L140">    }</span>

    @Test
    public void observeOnTheSameSchedulerTwice() {
<span class="fc" id="L144">        Scheduler scheduler = ImmediateThinScheduler.INSTANCE;</span>

<span class="fc" id="L146">        Observable&lt;Integer&gt; o = Observable.just(1, 2, 3);</span>
<span class="fc" id="L147">        Observable&lt;Integer&gt; o2 = o.observeOn(scheduler);</span>

<span class="fc" id="L149">        Observer&lt;Object&gt; observer1 = TestHelper.mockObserver();</span>
<span class="fc" id="L150">        Observer&lt;Object&gt; observer2 = TestHelper.mockObserver();</span>

<span class="fc" id="L152">        InOrder inOrder1 = inOrder(observer1);</span>
<span class="fc" id="L153">        InOrder inOrder2 = inOrder(observer2);</span>

<span class="fc" id="L155">        o2.subscribe(observer1);</span>
<span class="fc" id="L156">        o2.subscribe(observer2);</span>

<span class="fc" id="L158">        inOrder1.verify(observer1, times(1)).onNext(1);</span>
<span class="fc" id="L159">        inOrder1.verify(observer1, times(1)).onNext(2);</span>
<span class="fc" id="L160">        inOrder1.verify(observer1, times(1)).onNext(3);</span>
<span class="fc" id="L161">        inOrder1.verify(observer1, times(1)).onComplete();</span>
<span class="fc" id="L162">        verify(observer1, never()).onError(any(Throwable.class));</span>
<span class="fc" id="L163">        inOrder1.verifyNoMoreInteractions();</span>

<span class="fc" id="L165">        inOrder2.verify(observer2, times(1)).onNext(1);</span>
<span class="fc" id="L166">        inOrder2.verify(observer2, times(1)).onNext(2);</span>
<span class="fc" id="L167">        inOrder2.verify(observer2, times(1)).onNext(3);</span>
<span class="fc" id="L168">        inOrder2.verify(observer2, times(1)).onComplete();</span>
<span class="fc" id="L169">        verify(observer2, never()).onError(any(Throwable.class));</span>
<span class="fc" id="L170">        inOrder2.verifyNoMoreInteractions();</span>
<span class="fc" id="L171">    }</span>

    @Test
    public void observeSameOnMultipleSchedulers() {
<span class="fc" id="L175">        TestScheduler scheduler1 = new TestScheduler();</span>
<span class="fc" id="L176">        TestScheduler scheduler2 = new TestScheduler();</span>

<span class="fc" id="L178">        Observable&lt;Integer&gt; o = Observable.just(1, 2, 3);</span>
<span class="fc" id="L179">        Observable&lt;Integer&gt; o1 = o.observeOn(scheduler1);</span>
<span class="fc" id="L180">        Observable&lt;Integer&gt; o2 = o.observeOn(scheduler2);</span>

<span class="fc" id="L182">        Observer&lt;Object&gt; observer1 = TestHelper.mockObserver();</span>
<span class="fc" id="L183">        Observer&lt;Object&gt; observer2 = TestHelper.mockObserver();</span>

<span class="fc" id="L185">        InOrder inOrder1 = inOrder(observer1);</span>
<span class="fc" id="L186">        InOrder inOrder2 = inOrder(observer2);</span>

<span class="fc" id="L188">        o1.subscribe(observer1);</span>
<span class="fc" id="L189">        o2.subscribe(observer2);</span>

<span class="fc" id="L191">        scheduler1.advanceTimeBy(1, TimeUnit.SECONDS);</span>
<span class="fc" id="L192">        scheduler2.advanceTimeBy(1, TimeUnit.SECONDS);</span>

<span class="fc" id="L194">        inOrder1.verify(observer1, times(1)).onNext(1);</span>
<span class="fc" id="L195">        inOrder1.verify(observer1, times(1)).onNext(2);</span>
<span class="fc" id="L196">        inOrder1.verify(observer1, times(1)).onNext(3);</span>
<span class="fc" id="L197">        inOrder1.verify(observer1, times(1)).onComplete();</span>
<span class="fc" id="L198">        verify(observer1, never()).onError(any(Throwable.class));</span>
<span class="fc" id="L199">        inOrder1.verifyNoMoreInteractions();</span>

<span class="fc" id="L201">        inOrder2.verify(observer2, times(1)).onNext(1);</span>
<span class="fc" id="L202">        inOrder2.verify(observer2, times(1)).onNext(2);</span>
<span class="fc" id="L203">        inOrder2.verify(observer2, times(1)).onNext(3);</span>
<span class="fc" id="L204">        inOrder2.verify(observer2, times(1)).onComplete();</span>
<span class="fc" id="L205">        verify(observer2, never()).onError(any(Throwable.class));</span>
<span class="fc" id="L206">        inOrder2.verifyNoMoreInteractions();</span>
<span class="fc" id="L207">    }</span>

    /**
     * Confirm that running on a NewThreadScheduler uses the same thread for the entire stream.
     */
    @Test
    public void testObserveOnWithNewThreadScheduler() {
<span class="fc" id="L214">        final AtomicInteger count = new AtomicInteger();</span>
<span class="fc" id="L215">        final int _multiple = 99;</span>

<span class="fc" id="L217">        Observable.range(1, 100000).map(new Function&lt;Integer, Integer&gt;() {</span>

            @Override
            public Integer apply(Integer t1) {
<span class="fc" id="L221">                return t1 * _multiple;</span>
            }

<span class="fc" id="L224">        }).observeOn(Schedulers.newThread())</span>
<span class="fc" id="L225">        .blockingForEach(new Consumer&lt;Integer&gt;() {</span>

            @Override
            public void accept(Integer t1) {
<span class="fc" id="L229">                assertEquals(count.incrementAndGet() * _multiple, t1.intValue());</span>
                // FIXME toBlocking methods run on the current thread
<span class="fc" id="L231">                String name = Thread.currentThread().getName();</span>
<span class="fc" id="L232">                assertFalse(&quot;Wrong thread name: &quot; + name, name.startsWith(&quot;Rx&quot;));</span>
<span class="fc" id="L233">            }</span>

        });

<span class="fc" id="L237">    }</span>

    /**
     * Confirm that running on a ThreadPoolScheduler allows multiple threads but is still ordered.
     */
    @Test
    public void testObserveOnWithThreadPoolScheduler() {
<span class="fc" id="L244">        final AtomicInteger count = new AtomicInteger();</span>
<span class="fc" id="L245">        final int _multiple = 99;</span>

<span class="fc" id="L247">        Observable.range(1, 100000).map(new Function&lt;Integer, Integer&gt;() {</span>

            @Override
            public Integer apply(Integer t1) {
<span class="fc" id="L251">                return t1 * _multiple;</span>
            }

<span class="fc" id="L254">        }).observeOn(Schedulers.computation())</span>
<span class="fc" id="L255">        .blockingForEach(new Consumer&lt;Integer&gt;() {</span>

            @Override
            public void accept(Integer t1) {
<span class="fc" id="L259">                assertEquals(count.incrementAndGet() * _multiple, t1.intValue());</span>
                // FIXME toBlocking methods run on the caller's thread
<span class="fc" id="L261">                String name = Thread.currentThread().getName();</span>
<span class="fc" id="L262">                assertFalse(&quot;Wrong thread name: &quot; + name, name.startsWith(&quot;Rx&quot;));</span>
<span class="fc" id="L263">            }</span>

        });
<span class="fc" id="L266">    }</span>

    /**
     * Attempts to confirm that when pauses exist between events, the ScheduledObserver
     * does not lose or reorder any events since the scheduler will not block, but will
     * be re-scheduled when it receives new events after each pause.
     *
     *
     * This is non-deterministic in proving success, but if it ever fails (non-deterministically)
     * it is a sign of potential issues as thread-races and scheduling should not affect output.
     */
    @Test
    public void testObserveOnOrderingConcurrency() {
<span class="fc" id="L279">        final AtomicInteger count = new AtomicInteger();</span>
<span class="fc" id="L280">        final int _multiple = 99;</span>

<span class="fc" id="L282">        Observable.range(1, 10000).map(new Function&lt;Integer, Integer&gt;() {</span>

            @Override
            public Integer apply(Integer t1) {
<span class="fc bfc" id="L286" title="All 2 branches covered.">                if (randomIntFrom0to100() &gt; 98) {</span>
                    try {
<span class="fc" id="L288">                        Thread.sleep(2);</span>
<span class="nc" id="L289">                    } catch (InterruptedException e) {</span>
<span class="nc" id="L290">                        e.printStackTrace();</span>
<span class="fc" id="L291">                    }</span>
                }
<span class="fc" id="L293">                return t1 * _multiple;</span>
            }

<span class="fc" id="L296">        }).observeOn(Schedulers.computation())</span>
<span class="fc" id="L297">        .blockingForEach(new Consumer&lt;Integer&gt;() {</span>

            @Override
            public void accept(Integer t1) {
<span class="fc" id="L301">                assertEquals(count.incrementAndGet() * _multiple, t1.intValue());</span>
//                assertTrue(name.startsWith(&quot;RxComputationThreadPool&quot;));
                // FIXME toBlocking now runs its methods on the caller thread
<span class="fc" id="L304">                String name = Thread.currentThread().getName();</span>
<span class="fc" id="L305">                assertFalse(&quot;Wrong thread name: &quot; + name, name.startsWith(&quot;Rx&quot;));</span>
<span class="fc" id="L306">            }</span>

        });
<span class="fc" id="L309">    }</span>

    @Test
    public void testNonBlockingOuterWhileBlockingOnNext() throws InterruptedException {

<span class="fc" id="L314">        final CountDownLatch completedLatch = new CountDownLatch(1);</span>
<span class="fc" id="L315">        final CountDownLatch nextLatch = new CountDownLatch(1);</span>
<span class="fc" id="L316">        final AtomicLong completeTime = new AtomicLong();</span>
        // use subscribeOn to make async, observeOn to move
<span class="fc" id="L318">        Observable.range(1, 2).subscribeOn(Schedulers.newThread()).observeOn(Schedulers.newThread()).subscribe(new DefaultObserver&lt;Integer&gt;() {</span>

            @Override
            public void onComplete() {
<span class="fc" id="L322">                System.out.println(&quot;onComplete&quot;);</span>
<span class="fc" id="L323">                completeTime.set(System.nanoTime());</span>
<span class="fc" id="L324">                completedLatch.countDown();</span>
<span class="fc" id="L325">            }</span>

            @Override
            public void onError(Throwable e) {

<span class="nc" id="L330">            }</span>

            @Override
            public void onNext(Integer t) {
                // don't let this thing finish yet
                try {
<span class="pc bpc" id="L336" title="1 of 2 branches missed.">                    if (!nextLatch.await(1000, TimeUnit.MILLISECONDS)) {</span>
<span class="nc" id="L337">                        throw new RuntimeException(&quot;it shouldn't have timed out&quot;);</span>
                    }
<span class="nc" id="L339">                } catch (InterruptedException e) {</span>
<span class="nc" id="L340">                    throw new RuntimeException(&quot;it shouldn't have failed&quot;);</span>
<span class="fc" id="L341">                }</span>
<span class="fc" id="L342">            }</span>

        });

<span class="fc" id="L346">        long afterSubscribeTime = System.nanoTime();</span>
<span class="fc" id="L347">        System.out.println(&quot;After subscribe: &quot; + completedLatch.getCount());</span>
<span class="fc" id="L348">        assertEquals(1, completedLatch.getCount());</span>
<span class="fc" id="L349">        nextLatch.countDown();</span>
<span class="fc" id="L350">        completedLatch.await(1000, TimeUnit.MILLISECONDS);</span>
<span class="pc bpc" id="L351" title="1 of 2 branches missed.">        assertTrue(completeTime.get() &gt; afterSubscribeTime);</span>
<span class="fc" id="L352">        System.out.println(&quot;onComplete nanos after subscribe: &quot; + (completeTime.get() - afterSubscribeTime));</span>
<span class="fc" id="L353">    }</span>

    private static int randomIntFrom0to100() {
        // XORShift instead of Math.random http://javamex.com/tutorials/random_numbers/xorshift.shtml
<span class="fc" id="L357">        long x = System.nanoTime();</span>
<span class="fc" id="L358">        x ^= (x &lt;&lt; 21);</span>
<span class="fc" id="L359">        x ^= (x &gt;&gt;&gt; 35);</span>
<span class="fc" id="L360">        x ^= (x &lt;&lt; 4);</span>
<span class="fc" id="L361">        return Math.abs((int) x % 100);</span>
    }

    @Test
    public void testDelayedErrorDeliveryWhenSafeSubscriberUnsubscribes() {
<span class="fc" id="L366">        TestScheduler testScheduler = new TestScheduler();</span>

<span class="fc" id="L368">        Observable&lt;Integer&gt; source = Observable.concat(Observable.&lt;Integer&gt; error(new TestException()), Observable.just(1));</span>

<span class="fc" id="L370">        Observer&lt;Integer&gt; o = TestHelper.mockObserver();</span>
<span class="fc" id="L371">        InOrder inOrder = inOrder(o);</span>

<span class="fc" id="L373">        source.observeOn(testScheduler).subscribe(o);</span>

<span class="fc" id="L375">        inOrder.verify(o, never()).onError(any(TestException.class));</span>

<span class="fc" id="L377">        testScheduler.advanceTimeBy(1, TimeUnit.SECONDS);</span>

<span class="fc" id="L379">        inOrder.verify(o).onError(any(TestException.class));</span>
<span class="fc" id="L380">        inOrder.verify(o, never()).onNext(anyInt());</span>
<span class="fc" id="L381">        inOrder.verify(o, never()).onComplete();</span>
<span class="fc" id="L382">    }</span>

    @Test
    public void testAfterUnsubscribeCalledThenObserverOnNextNeverCalled() {
<span class="fc" id="L386">        final TestScheduler testScheduler = new TestScheduler();</span>

<span class="fc" id="L388">        final Observer&lt;Integer&gt; observer = TestHelper.mockObserver();</span>
<span class="fc" id="L389">        TestObserver&lt;Integer&gt; to = new TestObserver&lt;Integer&gt;(observer);</span>

<span class="fc" id="L391">        Observable.just(1, 2, 3)</span>
<span class="fc" id="L392">                .observeOn(testScheduler)</span>
<span class="fc" id="L393">                .subscribe(to);</span>

<span class="fc" id="L395">        to.dispose();</span>
<span class="fc" id="L396">        testScheduler.advanceTimeBy(1, TimeUnit.SECONDS);</span>

<span class="fc" id="L398">        final InOrder inOrder = inOrder(observer);</span>

<span class="fc" id="L400">        inOrder.verify(observer, never()).onNext(anyInt());</span>
<span class="fc" id="L401">        inOrder.verify(observer, never()).onError(any(Exception.class));</span>
<span class="fc" id="L402">        inOrder.verify(observer, never()).onComplete();</span>
<span class="fc" id="L403">    }</span>

    @Test
    public void testBackpressureWithTakeBefore() {
<span class="fc" id="L407">        final AtomicInteger generated = new AtomicInteger();</span>
<span class="fc" id="L408">        Observable&lt;Integer&gt; o = Observable.fromIterable(new Iterable&lt;Integer&gt;() {</span>
            @Override
            public Iterator&lt;Integer&gt; iterator() {
<span class="fc" id="L411">                return new Iterator&lt;Integer&gt;() {</span>

                    @Override
                    public void remove() {
<span class="nc" id="L415">                    }</span>

                    @Override
                    public Integer next() {
<span class="fc" id="L419">                        return generated.getAndIncrement();</span>
                    }

                    @Override
                    public boolean hasNext() {
<span class="fc" id="L424">                        return true;</span>
                    }
                };
            }
        });

<span class="fc" id="L430">        TestObserver&lt;Integer&gt; to = new TestObserver&lt;Integer&gt;();</span>
<span class="fc" id="L431">        o</span>
<span class="fc" id="L432">                .take(7)</span>
<span class="fc" id="L433">                .observeOn(Schedulers.newThread())</span>
<span class="fc" id="L434">                .subscribe(to);</span>

<span class="fc" id="L436">        to.awaitTerminalEvent();</span>
<span class="fc" id="L437">        to.assertValues(0, 1, 2, 3, 4, 5, 6);</span>
<span class="fc" id="L438">        assertEquals(7, generated.get());</span>
<span class="fc" id="L439">    }</span>

    @Test
    public void testAsyncChild() {
<span class="fc" id="L443">        TestObserver&lt;Integer&gt; to = new TestObserver&lt;Integer&gt;();</span>
<span class="fc" id="L444">        Observable.range(0, 100000).observeOn(Schedulers.newThread()).observeOn(Schedulers.newThread()).subscribe(to);</span>
<span class="fc" id="L445">        to.awaitTerminalEvent();</span>
<span class="fc" id="L446">        to.assertNoErrors();</span>
<span class="fc" id="L447">    }</span>

    @Test
    public void delayError() {
<span class="fc" id="L451">        Observable.range(1, 5).concatWith(Observable.&lt;Integer&gt;error(new TestException()))</span>
<span class="fc" id="L452">        .observeOn(Schedulers.computation(), true)</span>
<span class="fc" id="L453">        .doOnNext(new Consumer&lt;Integer&gt;() {</span>
            @Override
            public void accept(Integer v) throws Exception {
<span class="fc bfc" id="L456" title="All 2 branches covered.">                if (v == 1) {</span>
<span class="fc" id="L457">                    Thread.sleep(100);</span>
                }
<span class="fc" id="L459">            }</span>
        })
<span class="fc" id="L461">        .test()</span>
<span class="fc" id="L462">        .awaitDone(5, TimeUnit.SECONDS)</span>
<span class="fc" id="L463">        .assertFailure(TestException.class, 1, 2, 3, 4, 5);</span>
<span class="fc" id="L464">    }</span>

    @Test
    public void trampolineScheduler() {
<span class="fc" id="L468">        Observable.just(1)</span>
<span class="fc" id="L469">        .observeOn(Schedulers.trampoline())</span>
<span class="fc" id="L470">        .test()</span>
<span class="fc" id="L471">        .assertResult(1);</span>
<span class="fc" id="L472">    }</span>

    @Test
    public void dispose() {
<span class="fc" id="L476">        TestHelper.checkDisposed(PublishSubject.create().observeOn(new TestScheduler()));</span>
<span class="fc" id="L477">    }</span>

    @Test
    public void doubleOnSubscribe() {
<span class="fc" id="L481">        TestHelper.checkDoubleOnSubscribeObservable(new Function&lt;Observable&lt;Object&gt;, ObservableSource&lt;Object&gt;&gt;() {</span>
            @Override
            public ObservableSource&lt;Object&gt; apply(Observable&lt;Object&gt; o) throws Exception {
<span class="fc" id="L484">                return o.observeOn(new TestScheduler());</span>
            }
        });
<span class="fc" id="L487">    }</span>

    @Test
    public void badSource() {
<span class="fc" id="L491">        List&lt;Throwable&gt; errors = TestHelper.trackPluginErrors();</span>
        try {
<span class="fc" id="L493">            TestScheduler scheduler = new TestScheduler();</span>
<span class="fc" id="L494">            TestObserver&lt;Integer&gt; to = new Observable&lt;Integer&gt;() {</span>
                @Override
                protected void subscribeActual(Observer&lt;? super Integer&gt; observer) {
<span class="fc" id="L497">                    observer.onSubscribe(Disposables.empty());</span>
<span class="fc" id="L498">                    observer.onComplete();</span>
<span class="fc" id="L499">                    observer.onNext(1);</span>
<span class="fc" id="L500">                    observer.onError(new TestException());</span>
<span class="fc" id="L501">                    observer.onComplete();</span>
<span class="fc" id="L502">                }</span>
            }
<span class="fc" id="L504">            .observeOn(scheduler)</span>
<span class="fc" id="L505">            .test();</span>

<span class="fc" id="L507">            scheduler.triggerActions();</span>

<span class="fc" id="L509">            to.assertResult();</span>

<span class="fc" id="L511">            TestHelper.assertUndeliverable(errors, 0, TestException.class);</span>
        } finally {
<span class="fc" id="L513">            RxJavaPlugins.reset();</span>
        }
<span class="fc" id="L515">    }</span>

    @Test
    public void inputSyncFused() {
<span class="fc" id="L519">        Observable.range(1, 5)</span>
<span class="fc" id="L520">        .observeOn(Schedulers.single())</span>
<span class="fc" id="L521">        .test()</span>
<span class="fc" id="L522">        .awaitDone(5, TimeUnit.SECONDS)</span>
<span class="fc" id="L523">        .assertResult(1, 2, 3, 4, 5);</span>
<span class="fc" id="L524">    }</span>

    @Test
    public void inputAsyncFused() {
<span class="fc" id="L528">        UnicastSubject&lt;Integer&gt; us = UnicastSubject.create();</span>

<span class="fc" id="L530">        TestObserver&lt;Integer&gt; to = us.observeOn(Schedulers.single()).test();</span>

<span class="fc" id="L532">        TestHelper.emit(us, 1, 2, 3, 4, 5);</span>

<span class="fc" id="L534">        to</span>
<span class="fc" id="L535">        .awaitDone(5, TimeUnit.SECONDS)</span>
<span class="fc" id="L536">        .assertResult(1, 2, 3, 4, 5);</span>
<span class="fc" id="L537">    }</span>

    @Test
    public void inputAsyncFusedError() {
<span class="fc" id="L541">        UnicastSubject&lt;Integer&gt; us = UnicastSubject.create();</span>

<span class="fc" id="L543">        TestObserver&lt;Integer&gt; to = us.observeOn(Schedulers.single()).test();</span>

<span class="fc" id="L545">        us.onError(new TestException());</span>

<span class="fc" id="L547">        to</span>
<span class="fc" id="L548">        .awaitDone(5, TimeUnit.SECONDS)</span>
<span class="fc" id="L549">        .assertFailure(TestException.class);</span>
<span class="fc" id="L550">    }</span>

    @Test
    public void inputAsyncFusedErrorDelayed() {
<span class="fc" id="L554">        UnicastSubject&lt;Integer&gt; us = UnicastSubject.create();</span>

<span class="fc" id="L556">        TestObserver&lt;Integer&gt; to = us.observeOn(Schedulers.single(), true).test();</span>

<span class="fc" id="L558">        us.onError(new TestException());</span>

<span class="fc" id="L560">        to</span>
<span class="fc" id="L561">        .awaitDone(5, TimeUnit.SECONDS)</span>
<span class="fc" id="L562">        .assertFailure(TestException.class);</span>
<span class="fc" id="L563">    }</span>

    @Test
    public void outputFused() {
<span class="fc" id="L567">        TestObserver&lt;Integer&gt; to = ObserverFusion.newTest(QueueFuseable.ANY);</span>

<span class="fc" id="L569">        Observable.range(1, 5).hide()</span>
<span class="fc" id="L570">        .observeOn(Schedulers.single())</span>
<span class="fc" id="L571">        .subscribe(to);</span>

<span class="fc" id="L573">        ObserverFusion.assertFusion(to, QueueFuseable.ASYNC)</span>
<span class="fc" id="L574">        .awaitDone(5, TimeUnit.SECONDS)</span>
<span class="fc" id="L575">        .assertResult(1, 2, 3, 4, 5);</span>
<span class="fc" id="L576">    }</span>

    @Test
    public void outputFusedReject() {
<span class="fc" id="L580">        TestObserver&lt;Integer&gt; to = ObserverFusion.newTest(QueueFuseable.SYNC);</span>

<span class="fc" id="L582">        Observable.range(1, 5).hide()</span>
<span class="fc" id="L583">        .observeOn(Schedulers.single())</span>
<span class="fc" id="L584">        .subscribe(to);</span>

<span class="fc" id="L586">        ObserverFusion.assertFusion(to, QueueFuseable.NONE)</span>
<span class="fc" id="L587">        .awaitDone(5, TimeUnit.SECONDS)</span>
<span class="fc" id="L588">        .assertResult(1, 2, 3, 4, 5);</span>
<span class="fc" id="L589">    }</span>

    @Test
    public void inputOutputAsyncFusedError() {
<span class="fc" id="L593">        TestObserver&lt;Integer&gt; to = ObserverFusion.newTest(QueueFuseable.ANY);</span>

<span class="fc" id="L595">        UnicastSubject&lt;Integer&gt; us = UnicastSubject.create();</span>

<span class="fc" id="L597">        us.observeOn(Schedulers.single())</span>
<span class="fc" id="L598">        .subscribe(to);</span>

<span class="fc" id="L600">        us.onError(new TestException());</span>

<span class="fc" id="L602">        to</span>
<span class="fc" id="L603">        .awaitDone(5, TimeUnit.SECONDS)</span>
<span class="fc" id="L604">        .assertFailure(TestException.class);</span>

<span class="fc" id="L606">        ObserverFusion.assertFusion(to, QueueFuseable.ASYNC)</span>
<span class="fc" id="L607">        .awaitDone(5, TimeUnit.SECONDS)</span>
<span class="fc" id="L608">        .assertFailure(TestException.class);</span>
<span class="fc" id="L609">    }</span>

    @Test
    public void inputOutputAsyncFusedErrorDelayed() {
<span class="fc" id="L613">        TestObserver&lt;Integer&gt; to = ObserverFusion.newTest(QueueFuseable.ANY);</span>

<span class="fc" id="L615">        UnicastSubject&lt;Integer&gt; us = UnicastSubject.create();</span>

<span class="fc" id="L617">        us.observeOn(Schedulers.single(), true)</span>
<span class="fc" id="L618">        .subscribe(to);</span>

<span class="fc" id="L620">        us.onError(new TestException());</span>

<span class="fc" id="L622">        to</span>
<span class="fc" id="L623">        .awaitDone(5, TimeUnit.SECONDS)</span>
<span class="fc" id="L624">        .assertFailure(TestException.class);</span>

<span class="fc" id="L626">        ObserverFusion.assertFusion(to, QueueFuseable.ASYNC)</span>
<span class="fc" id="L627">        .awaitDone(5, TimeUnit.SECONDS)</span>
<span class="fc" id="L628">        .assertFailure(TestException.class);</span>
<span class="fc" id="L629">    }</span>

    @Test
    public void outputFusedCancelReentrant() throws Exception {
<span class="fc" id="L633">        final UnicastSubject&lt;Integer&gt; us = UnicastSubject.create();</span>

<span class="fc" id="L635">        final CountDownLatch cdl = new CountDownLatch(1);</span>

<span class="fc" id="L637">        us.observeOn(Schedulers.single())</span>
<span class="fc" id="L638">        .subscribe(new Observer&lt;Integer&gt;() {</span>
            Disposable upstream;
            int count;
            @Override
            public void onSubscribe(Disposable d) {
<span class="fc" id="L643">                this.upstream = d;</span>
<span class="fc" id="L644">                ((QueueDisposable&lt;?&gt;)d).requestFusion(QueueFuseable.ANY);</span>
<span class="fc" id="L645">            }</span>

            @Override
            public void onNext(Integer value) {
<span class="pc bpc" id="L649" title="1 of 2 branches missed.">                if (++count == 1) {</span>
<span class="fc" id="L650">                    us.onNext(2);</span>
<span class="fc" id="L651">                    upstream.dispose();</span>
<span class="fc" id="L652">                    cdl.countDown();</span>
                }
<span class="fc" id="L654">            }</span>

            @Override
            public void onError(Throwable e) {

<span class="nc" id="L659">            }</span>

            @Override
            public void onComplete() {

<span class="nc" id="L664">            }</span>
        });

<span class="fc" id="L667">        us.onNext(1);</span>

<span class="fc" id="L669">        cdl.await();</span>
<span class="fc" id="L670">    }</span>

    @Test
    public void nonFusedPollThrows() {
<span class="fc" id="L674">        new Observable&lt;Integer&gt;() {</span>
            @Override
            protected void subscribeActual(Observer&lt;? super Integer&gt; observer) {
<span class="fc" id="L677">                observer.onSubscribe(Disposables.empty());</span>

                @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L680">                ObserveOnObserver&lt;Integer&gt; oo = (ObserveOnObserver&lt;Integer&gt;)observer;</span>

<span class="fc" id="L682">                oo.queue = new SimpleQueue&lt;Integer&gt;() {</span>

                    @Override
                    public boolean offer(Integer value) {
<span class="nc" id="L686">                        return false;</span>
                    }

                    @Override
                    public boolean offer(Integer v1, Integer v2) {
<span class="nc" id="L691">                        return false;</span>
                    }

                    @Nullable
                    @Override
                    public Integer poll() throws Exception {
<span class="fc" id="L697">                        throw new TestException();</span>
                    }

                    @Override
                    public boolean isEmpty() {
<span class="fc" id="L702">                        return false;</span>
                    }

                    @Override
                    public void clear() {
<span class="fc" id="L707">                    }</span>
                };

<span class="fc" id="L710">                oo.clear();</span>

<span class="fc" id="L712">                oo.schedule();</span>
<span class="fc" id="L713">            }</span>
        }
<span class="fc" id="L715">        .observeOn(Schedulers.single())</span>
<span class="fc" id="L716">        .test()</span>
<span class="fc" id="L717">        .awaitDone(5, TimeUnit.SECONDS)</span>
<span class="fc" id="L718">        .assertFailure(TestException.class);</span>
<span class="fc" id="L719">    }</span>

    @Test
    public void outputFusedOneSignal() {
<span class="fc" id="L723">        final BehaviorSubject&lt;Integer&gt; bs = BehaviorSubject.createDefault(1);</span>

<span class="fc" id="L725">        bs.observeOn(ImmediateThinScheduler.INSTANCE)</span>
<span class="fc" id="L726">        .concatMap(new Function&lt;Integer, ObservableSource&lt;Integer&gt;&gt;() {</span>
            @Override
            public ObservableSource&lt;Integer&gt; apply(Integer v)
                    throws Exception {
<span class="fc" id="L730">                return Observable.just(v + 1);</span>
            }
        })
<span class="fc" id="L733">        .subscribeWith(new TestObserver&lt;Integer&gt;() {</span>
            @Override
            public void onNext(Integer t) {
<span class="fc" id="L736">                super.onNext(t);</span>
<span class="fc bfc" id="L737" title="All 2 branches covered.">                if (t == 2) {</span>
<span class="fc" id="L738">                    bs.onNext(2);</span>
                }
<span class="fc" id="L740">            }</span>
        })
<span class="fc" id="L742">        .assertValuesOnly(2, 3);</span>
<span class="fc" id="L743">    }</span>

    @Test
    public void workerNotDisposedPrematurelyNormalInNormalOut() {
<span class="fc" id="L747">        DisposeTrackingScheduler s = new DisposeTrackingScheduler();</span>

<span class="fc" id="L749">        Observable.concat(</span>
<span class="fc" id="L750">                Observable.just(1).hide().observeOn(s),</span>
<span class="fc" id="L751">                Observable.just(2)</span>
        )
<span class="fc" id="L753">        .test()</span>
<span class="fc" id="L754">        .assertResult(1, 2);</span>

<span class="fc" id="L756">        assertEquals(1, s.disposedCount.get());</span>
<span class="fc" id="L757">    }</span>

    @Test
    public void workerNotDisposedPrematurelySyncInNormalOut() {
<span class="fc" id="L761">        DisposeTrackingScheduler s = new DisposeTrackingScheduler();</span>

<span class="fc" id="L763">        Observable.concat(</span>
<span class="fc" id="L764">                Observable.just(1).observeOn(s),</span>
<span class="fc" id="L765">                Observable.just(2)</span>
        )
<span class="fc" id="L767">        .test()</span>
<span class="fc" id="L768">        .assertResult(1, 2);</span>

<span class="fc" id="L770">        assertEquals(1, s.disposedCount.get());</span>
<span class="fc" id="L771">    }</span>

    @Test
    public void workerNotDisposedPrematurelyAsyncInNormalOut() {
<span class="fc" id="L775">        DisposeTrackingScheduler s = new DisposeTrackingScheduler();</span>

<span class="fc" id="L777">        UnicastSubject&lt;Integer&gt; up = UnicastSubject.create();</span>
<span class="fc" id="L778">        up.onNext(1);</span>
<span class="fc" id="L779">        up.onComplete();</span>

<span class="fc" id="L781">        Observable.concat(</span>
<span class="fc" id="L782">                up.observeOn(s),</span>
<span class="fc" id="L783">                Observable.just(2)</span>
        )
<span class="fc" id="L785">        .test()</span>
<span class="fc" id="L786">        .assertResult(1, 2);</span>

<span class="fc" id="L788">        assertEquals(1, s.disposedCount.get());</span>
<span class="fc" id="L789">    }</span>

    static final class TestObserverFusedCanceling
            extends TestObserver&lt;Integer&gt; {

        TestObserverFusedCanceling() {
<span class="fc" id="L795">            super();</span>
<span class="fc" id="L796">            initialFusionMode = QueueFuseable.ANY;</span>
<span class="fc" id="L797">        }</span>

        @Override
        public void onComplete() {
<span class="fc" id="L801">            cancel();</span>
<span class="fc" id="L802">            super.onComplete();</span>
<span class="fc" id="L803">        }</span>
    }

    @Test
    public void workerNotDisposedPrematurelyNormalInAsyncOut() {
<span class="fc" id="L808">        DisposeTrackingScheduler s = new DisposeTrackingScheduler();</span>

<span class="fc" id="L810">        TestObserver&lt;Integer&gt; to = new TestObserverFusedCanceling();</span>

<span class="fc" id="L812">        Observable.just(1).hide().observeOn(s).subscribe(to);</span>

<span class="fc" id="L814">        assertEquals(1, s.disposedCount.get());</span>
<span class="fc" id="L815">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>