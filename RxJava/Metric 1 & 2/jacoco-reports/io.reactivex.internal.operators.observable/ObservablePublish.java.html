<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ObservablePublish.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">RxJava_2_x$Unnamed.exec</a> &gt; <a href="index.source.html" class="el_package">io.reactivex.internal.operators.observable</a> &gt; <span class="el_source">ObservablePublish.java</span></div><h1>ObservablePublish.java</h1><pre class="source lang-java linenums">/**
 * Copyright (c) 2016-present, RxJava Contributors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is
 * distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
 * the License for the specific language governing permissions and limitations under the License.
 */

package io.reactivex.internal.operators.observable;

import java.util.concurrent.atomic.*;

import io.reactivex.*;
import io.reactivex.disposables.Disposable;
import io.reactivex.exceptions.Exceptions;
import io.reactivex.functions.Consumer;
import io.reactivex.internal.disposables.DisposableHelper;
import io.reactivex.internal.fuseable.HasUpstreamObservableSource;
import io.reactivex.internal.util.ExceptionHelper;
import io.reactivex.observables.ConnectableObservable;
import io.reactivex.plugins.RxJavaPlugins;

/**
 * A connectable observable which shares an underlying source and dispatches source values to observers in a backpressure-aware
 * manner.
 * @param &lt;T&gt; the value type
 */
public final class ObservablePublish&lt;T&gt; extends ConnectableObservable&lt;T&gt; implements HasUpstreamObservableSource&lt;T&gt; {
    /** The source observable. */
    final ObservableSource&lt;T&gt; source;
    /** Holds the current subscriber that is, will be or just was subscribed to the source observable. */
    final AtomicReference&lt;PublishObserver&lt;T&gt;&gt; current;

    final ObservableSource&lt;T&gt; onSubscribe;

    /**
     * Creates a OperatorPublish instance to publish values of the given source observable.
     * @param &lt;T&gt; the source value type
     * @param source the source observable
     * @return the connectable observable
     */
    public static &lt;T&gt; ConnectableObservable&lt;T&gt; create(ObservableSource&lt;T&gt; source) {
        // the current connection to source needs to be shared between the operator and its onSubscribe call
<span class="fc" id="L49">        final AtomicReference&lt;PublishObserver&lt;T&gt;&gt; curr = new AtomicReference&lt;PublishObserver&lt;T&gt;&gt;();</span>
<span class="fc" id="L50">        ObservableSource&lt;T&gt; onSubscribe = new PublishSource&lt;T&gt;(curr);</span>
<span class="fc" id="L51">        return RxJavaPlugins.onAssembly(new ObservablePublish&lt;T&gt;(onSubscribe, source, curr));</span>
    }

    private ObservablePublish(ObservableSource&lt;T&gt; onSubscribe, ObservableSource&lt;T&gt; source,
<span class="fc" id="L55">                              final AtomicReference&lt;PublishObserver&lt;T&gt;&gt; current) {</span>
<span class="fc" id="L56">        this.onSubscribe = onSubscribe;</span>
<span class="fc" id="L57">        this.source = source;</span>
<span class="fc" id="L58">        this.current = current;</span>
<span class="fc" id="L59">    }</span>

    @Override
    public ObservableSource&lt;T&gt; source() {
<span class="fc" id="L63">        return source;</span>
    }

    @Override
    protected void subscribeActual(Observer&lt;? super T&gt; observer) {
<span class="fc" id="L68">        onSubscribe.subscribe(observer);</span>
<span class="fc" id="L69">    }</span>

    @Override
    public void connect(Consumer&lt;? super Disposable&gt; connection) {
        boolean doConnect;
        PublishObserver&lt;T&gt; ps;
        // we loop because concurrent connect/disconnect and termination may change the state
        for (;;) {
            // retrieve the current subscriber-to-source instance
<span class="fc" id="L78">            ps = current.get();</span>
            // if there is none yet or the current has been disposed
<span class="fc bfc" id="L80" title="All 4 branches covered.">            if (ps == null || ps.isDisposed()) {</span>
                // create a new subscriber-to-source
<span class="fc" id="L82">                PublishObserver&lt;T&gt; u = new PublishObserver&lt;T&gt;(current);</span>
                // try setting it as the current subscriber-to-source
<span class="fc bfc" id="L84" title="All 2 branches covered.">                if (!current.compareAndSet(ps, u)) {</span>
                    // did not work, perhaps a new subscriber arrived
                    // and created a new subscriber-to-source as well, retry
<span class="fc" id="L87">                    continue;</span>
                }
<span class="fc" id="L89">                ps = u;</span>
            }
            // if connect() was called concurrently, only one of them should actually
            // connect to the source
<span class="fc bfc" id="L93" title="All 4 branches covered.">            doConnect = !ps.shouldConnect.get() &amp;&amp; ps.shouldConnect.compareAndSet(false, true);</span>
<span class="fc" id="L94">            break; // NOPMD</span>
        }
        /*
         * Notify the callback that we have a (new) connection which it can dispose
         * but since ps is unique to a connection, multiple calls to connect() will return the
         * same Disposable and even if there was a connect-disconnect-connect pair, the older
         * references won't disconnect the newer connection.
         * Synchronous source consumers have the opportunity to disconnect via dispose on the
         * Disposable as subscribe() may never return in its own.
         *
         * Note however, that asynchronously disconnecting a running source might leave
         * child observers without any terminal event; PublishSubject does not have this
         * issue because the dispose() was always triggered by the child observers
         * themselves.
         */
        try {
<span class="fc" id="L110">            connection.accept(ps);</span>
<span class="fc" id="L111">        } catch (Throwable ex) {</span>
<span class="fc" id="L112">            Exceptions.throwIfFatal(ex);</span>
<span class="fc" id="L113">            throw ExceptionHelper.wrapOrThrow(ex);</span>
<span class="fc" id="L114">        }</span>
<span class="fc bfc" id="L115" title="All 2 branches covered.">        if (doConnect) {</span>
<span class="fc" id="L116">            source.subscribe(ps);</span>
        }
<span class="fc" id="L118">    }</span>

    @SuppressWarnings(&quot;rawtypes&quot;)
    static final class PublishObserver&lt;T&gt;
    implements Observer&lt;T&gt;, Disposable {
        /** Holds onto the current connected PublishObserver. */
        final AtomicReference&lt;PublishObserver&lt;T&gt;&gt; current;

        /** Indicates an empty array of inner observers. */
<span class="fc" id="L127">        static final InnerDisposable[] EMPTY = new InnerDisposable[0];</span>
        /** Indicates a terminated PublishObserver. */
<span class="fc" id="L129">        static final InnerDisposable[] TERMINATED = new InnerDisposable[0];</span>

        /** Tracks the subscribed observers. */
        final AtomicReference&lt;InnerDisposable&lt;T&gt;[]&gt; observers;
        /**
         * Atomically changed from false to true by connect to make sure the
         * connection is only performed by one thread.
         */
        final AtomicBoolean shouldConnect;

<span class="fc" id="L139">        final AtomicReference&lt;Disposable&gt; upstream = new AtomicReference&lt;Disposable&gt;();</span>

        @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L142">        PublishObserver(AtomicReference&lt;PublishObserver&lt;T&gt;&gt; current) {</span>
<span class="fc" id="L143">            this.observers = new AtomicReference&lt;InnerDisposable&lt;T&gt;[]&gt;(EMPTY);</span>
<span class="fc" id="L144">            this.current = current;</span>
<span class="fc" id="L145">            this.shouldConnect = new AtomicBoolean();</span>
<span class="fc" id="L146">        }</span>

        @SuppressWarnings(&quot;unchecked&quot;)
        @Override
        public void dispose() {
<span class="fc" id="L151">            InnerDisposable[] ps = observers.getAndSet(TERMINATED);</span>
<span class="fc bfc" id="L152" title="All 2 branches covered.">            if (ps != TERMINATED) {</span>
<span class="fc" id="L153">                current.compareAndSet(PublishObserver.this, null);</span>

<span class="fc" id="L155">                DisposableHelper.dispose(upstream);</span>
            }
<span class="fc" id="L157">        }</span>

        @Override
        public boolean isDisposed() {
<span class="fc bfc" id="L161" title="All 2 branches covered.">            return observers.get() == TERMINATED;</span>
        }

        @Override
        public void onSubscribe(Disposable d) {
<span class="fc" id="L166">            DisposableHelper.setOnce(this.upstream, d);</span>
<span class="fc" id="L167">        }</span>

        @Override
        public void onNext(T t) {
<span class="fc bfc" id="L171" title="All 2 branches covered.">            for (InnerDisposable&lt;T&gt; inner : observers.get()) {</span>
<span class="fc" id="L172">                inner.child.onNext(t);</span>
            }
<span class="fc" id="L174">        }</span>

        @SuppressWarnings(&quot;unchecked&quot;)
        @Override
        public void onError(Throwable e) {
<span class="fc" id="L179">            current.compareAndSet(this, null);</span>
<span class="fc" id="L180">            InnerDisposable&lt;T&gt;[] a = observers.getAndSet(TERMINATED);</span>
<span class="fc bfc" id="L181" title="All 2 branches covered.">            if (a.length != 0) {</span>
<span class="fc bfc" id="L182" title="All 2 branches covered.">                for (InnerDisposable&lt;T&gt; inner : a) {</span>
<span class="fc" id="L183">                    inner.child.onError(e);</span>
                }
            } else {
<span class="fc" id="L186">                RxJavaPlugins.onError(e);</span>
            }
<span class="fc" id="L188">        }</span>

        @SuppressWarnings(&quot;unchecked&quot;)
        @Override
        public void onComplete() {
<span class="fc" id="L193">            current.compareAndSet(this, null);</span>
<span class="fc bfc" id="L194" title="All 2 branches covered.">            for (InnerDisposable&lt;T&gt; inner : observers.getAndSet(TERMINATED)) {</span>
<span class="fc" id="L195">                inner.child.onComplete();</span>
            }
<span class="fc" id="L197">        }</span>

        /**
         * Atomically try adding a new InnerDisposable to this Observer or return false if this
         * Observer was terminated.
         * @param producer the producer to add
         * @return true if succeeded, false otherwise
         */
        boolean add(InnerDisposable&lt;T&gt; producer) {
            // the state can change so we do a CAS loop to achieve atomicity
            for (;;) {
                // get the current producer array
<span class="fc" id="L209">                InnerDisposable&lt;T&gt;[] c = observers.get();</span>
                // if this subscriber-to-source reached a terminal state by receiving
                // an onError or onComplete, just refuse to add the new producer
<span class="fc bfc" id="L212" title="All 2 branches covered.">                if (c == TERMINATED) {</span>
<span class="fc" id="L213">                    return false;</span>
                }
                // we perform a copy-on-write logic
<span class="fc" id="L216">                int len = c.length;</span>
                @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L218">                InnerDisposable&lt;T&gt;[] u = new InnerDisposable[len + 1];</span>
<span class="fc" id="L219">                System.arraycopy(c, 0, u, 0, len);</span>
<span class="fc" id="L220">                u[len] = producer;</span>
                // try setting the observers array
<span class="fc bfc" id="L222" title="All 2 branches covered.">                if (observers.compareAndSet(c, u)) {</span>
<span class="fc" id="L223">                    return true;</span>
                }
                // if failed, some other operation succeeded (another add, remove or termination)
                // so retry
<span class="fc" id="L227">            }</span>
        }

        /**
         * Atomically removes the given producer from the observers array.
         * @param producer the producer to remove
         */
        @SuppressWarnings(&quot;unchecked&quot;)
        void remove(InnerDisposable&lt;T&gt; producer) {
            // the state can change so we do a CAS loop to achieve atomicity
            for (;;) {
                // let's read the current observers array
<span class="fc" id="L239">                InnerDisposable&lt;T&gt;[] c = observers.get();</span>
                // if it is either empty or terminated, there is nothing to remove so we quit
<span class="fc" id="L241">                int len = c.length;</span>
<span class="pc bpc" id="L242" title="1 of 2 branches missed.">                if (len == 0) {</span>
<span class="nc" id="L243">                    return;</span>
                }
                // let's find the supplied producer in the array
                // although this is O(n), we don't expect too many child observers in general
<span class="fc" id="L247">                int j = -1;</span>
<span class="fc bfc" id="L248" title="All 2 branches covered.">                for (int i = 0; i &lt; len; i++) {</span>
<span class="fc bfc" id="L249" title="All 2 branches covered.">                    if (c[i].equals(producer)) {</span>
<span class="fc" id="L250">                        j = i;</span>
<span class="fc" id="L251">                        break;</span>
                    }
                }
                // we didn't find it so just quit
<span class="fc bfc" id="L255" title="All 2 branches covered.">                if (j &lt; 0) {</span>
<span class="fc" id="L256">                    return;</span>
                }
                // we do copy-on-write logic here
                InnerDisposable&lt;T&gt;[] u;
                // we don't create a new empty array if producer was the single inhabitant
                // but rather reuse an empty array
<span class="fc bfc" id="L262" title="All 2 branches covered.">                if (len == 1) {</span>
<span class="fc" id="L263">                    u = EMPTY;</span>
                } else {
                    // otherwise, create a new array one less in size
<span class="fc" id="L266">                    u = new InnerDisposable[len - 1];</span>
                    // copy elements being before the given producer
<span class="fc" id="L268">                    System.arraycopy(c, 0, u, 0, j);</span>
                    // copy elements being after the given producer
<span class="fc" id="L270">                    System.arraycopy(c, j + 1, u, j, len - j - 1);</span>
                }
                // try setting this new array as
<span class="fc bfc" id="L273" title="All 2 branches covered.">                if (observers.compareAndSet(c, u)) {</span>
<span class="fc" id="L274">                    return;</span>
                }
                // if we failed, it means something else happened
                // (a concurrent add/remove or termination), we need to retry
<span class="fc" id="L278">            }</span>
        }
    }
    /**
     * A Disposable that manages the request and disposed state of a
     * child Observer in thread-safe manner.
     * {@code this} holds the parent PublishObserver or itself if disposed
     * @param &lt;T&gt; the value type
     */
    static final class InnerDisposable&lt;T&gt;
    extends AtomicReference&lt;Object&gt;
    implements Disposable {
        private static final long serialVersionUID = -1100270633763673112L;
        /** The actual child subscriber. */
        final Observer&lt;? super T&gt; child;

<span class="fc" id="L294">        InnerDisposable(Observer&lt;? super T&gt; child) {</span>
<span class="fc" id="L295">            this.child = child;</span>
<span class="fc" id="L296">        }</span>

        @Override
        public boolean isDisposed() {
<span class="fc bfc" id="L300" title="All 2 branches covered.">            return get() == this;</span>
        }

        @SuppressWarnings(&quot;unchecked&quot;)
        @Override
        public void dispose() {
<span class="fc" id="L306">            Object o = getAndSet(this);</span>
<span class="fc bfc" id="L307" title="All 4 branches covered.">            if (o != null &amp;&amp; o != this) {</span>
<span class="fc" id="L308">                ((PublishObserver&lt;T&gt;)o).remove(this);</span>
            }
<span class="fc" id="L310">        }</span>

        void setParent(PublishObserver&lt;T&gt; p) {
<span class="fc bfc" id="L313" title="All 2 branches covered.">            if (!compareAndSet(null, p)) {</span>
<span class="fc" id="L314">                p.remove(this);</span>
            }
<span class="fc" id="L316">        }</span>
    }

    static final class PublishSource&lt;T&gt; implements ObservableSource&lt;T&gt; {
        private final AtomicReference&lt;PublishObserver&lt;T&gt;&gt; curr;

<span class="fc" id="L322">        PublishSource(AtomicReference&lt;PublishObserver&lt;T&gt;&gt; curr) {</span>
<span class="fc" id="L323">            this.curr = curr;</span>
<span class="fc" id="L324">        }</span>

        @Override
        public void subscribe(Observer&lt;? super T&gt; child) {
            // create the backpressure-managing producer for this child
<span class="fc" id="L329">            InnerDisposable&lt;T&gt; inner = new InnerDisposable&lt;T&gt;(child);</span>
<span class="fc" id="L330">            child.onSubscribe(inner);</span>
            // concurrent connection/disconnection may change the state,
            // we loop to be atomic while the child subscribes
            for (;;) {
                // get the current subscriber-to-source
<span class="fc" id="L335">                PublishObserver&lt;T&gt; r = curr.get();</span>
                // if there isn't one or it is disposed
<span class="fc bfc" id="L337" title="All 4 branches covered.">                if (r == null || r.isDisposed()) {</span>
                    // create a new subscriber to source
<span class="fc" id="L339">                    PublishObserver&lt;T&gt; u = new PublishObserver&lt;T&gt;(curr);</span>
                    // let's try setting it as the current subscriber-to-source
<span class="fc bfc" id="L341" title="All 2 branches covered.">                    if (!curr.compareAndSet(r, u)) {</span>
                        // didn't work, maybe someone else did it or the current subscriber
                        // to source has just finished
<span class="fc" id="L344">                        continue;</span>
                    }
                    // we won, let's use it going onwards
<span class="fc" id="L347">                    r = u;</span>
                }

                /*
                 * Try adding it to the current subscriber-to-source, add is atomic in respect
                 * to other adds and the termination of the subscriber-to-source.
                 */
<span class="fc bfc" id="L354" title="All 2 branches covered.">                if (r.add(inner)) {</span>
<span class="fc" id="L355">                    inner.setParent(r);</span>
<span class="fc" id="L356">                    break; // NOPMD</span>
                }
                /*
                 * The current PublishObserver has been terminated, try with a newer one.
                 */
                /*
                 * Note: although technically correct, concurrent disconnects can cause
                 * unexpected behavior such as child observers never receiving anything
                 * (unless connected again). An alternative approach, similar to
                 * PublishSubject would be to immediately terminate such child
                 * observers as well:
                 *
                 * Object term = r.terminalEvent;
                 * if (r.nl.isCompleted(term)) {
                 *     child.onComplete();
                 * } else {
                 *     child.onError(r.nl.getError(term));
                 * }
                 * return;
                 *
                 * The original concurrent behavior was non-deterministic in this regard as well.
                 * Allowing this behavior, however, may introduce another unexpected behavior:
                 * after disconnecting a previous connection, one might not be able to prepare
                 * a new connection right after a previous termination by subscribing new child
                 * observers asynchronously before a connect call.
                 */
<span class="fc" id="L382">            }</span>
<span class="fc" id="L383">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>