<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ObservablePublishTest.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">RxJava_2_x$Unnamed.exec</a> &gt; <a href="index.source.html" class="el_package">io.reactivex.internal.operators.observable</a> &gt; <span class="el_source">ObservablePublishTest.java</span></div><h1>ObservablePublishTest.java</h1><pre class="source lang-java linenums">/**
 * Copyright (c) 2016-present, RxJava Contributors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is
 * distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
 * the License for the specific language governing permissions and limitations under the License.
 */

package io.reactivex.internal.operators.observable;

import static org.junit.Assert.*;

import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.*;

import org.junit.Test;

import io.reactivex.*;
import io.reactivex.Observable;
import io.reactivex.Observer;
import io.reactivex.disposables.*;
import io.reactivex.exceptions.TestException;
import io.reactivex.functions.*;
import io.reactivex.internal.functions.Functions;
import io.reactivex.internal.fuseable.HasUpstreamObservableSource;
import io.reactivex.observables.ConnectableObservable;
import io.reactivex.observers.TestObserver;
import io.reactivex.plugins.RxJavaPlugins;
import io.reactivex.schedulers.*;
import io.reactivex.subjects.PublishSubject;

<span class="fc" id="L38">public class ObservablePublishTest {</span>

    @Test
    public void testPublish() throws InterruptedException {
<span class="fc" id="L42">        final AtomicInteger counter = new AtomicInteger();</span>
<span class="fc" id="L43">        ConnectableObservable&lt;String&gt; o = Observable.unsafeCreate(new ObservableSource&lt;String&gt;() {</span>

            @Override
            public void subscribe(final Observer&lt;? super String&gt; observer) {
<span class="fc" id="L47">                observer.onSubscribe(Disposables.empty());</span>
<span class="fc" id="L48">                new Thread(new Runnable() {</span>

                    @Override
                    public void run() {
<span class="fc" id="L52">                        counter.incrementAndGet();</span>
<span class="fc" id="L53">                        observer.onNext(&quot;one&quot;);</span>
<span class="fc" id="L54">                        observer.onComplete();</span>
<span class="fc" id="L55">                    }</span>
<span class="fc" id="L56">                }).start();</span>
<span class="fc" id="L57">            }</span>
<span class="fc" id="L58">        }).publish();</span>

<span class="fc" id="L60">        final CountDownLatch latch = new CountDownLatch(2);</span>

        // subscribe once
<span class="fc" id="L63">        o.subscribe(new Consumer&lt;String&gt;() {</span>

            @Override
            public void accept(String v) {
<span class="fc" id="L67">                assertEquals(&quot;one&quot;, v);</span>
<span class="fc" id="L68">                latch.countDown();</span>
<span class="fc" id="L69">            }</span>
        });

        // subscribe again
<span class="fc" id="L73">        o.subscribe(new Consumer&lt;String&gt;() {</span>

            @Override
            public void accept(String v) {
<span class="fc" id="L77">                assertEquals(&quot;one&quot;, v);</span>
<span class="fc" id="L78">                latch.countDown();</span>
<span class="fc" id="L79">            }</span>
        });

<span class="fc" id="L82">        Disposable connection = o.connect();</span>
        try {
<span class="pc bpc" id="L84" title="1 of 2 branches missed.">            if (!latch.await(1000, TimeUnit.MILLISECONDS)) {</span>
<span class="nc" id="L85">                fail(&quot;subscriptions did not receive values&quot;);</span>
            }
<span class="fc" id="L87">            assertEquals(1, counter.get());</span>
        } finally {
<span class="fc" id="L89">            connection.dispose();</span>
        }
<span class="fc" id="L91">    }</span>

    @Test
    public void testBackpressureFastSlow() {
<span class="fc" id="L95">        ConnectableObservable&lt;Integer&gt; is = Observable.range(1, Flowable.bufferSize() * 2).publish();</span>
<span class="fc" id="L96">        Observable&lt;Integer&gt; fast = is.observeOn(Schedulers.computation())</span>
<span class="fc" id="L97">        .doOnComplete(new Action() {</span>
            @Override
            public void run() {
<span class="fc" id="L100">                System.out.println(&quot;^^^^^^^^^^^^^ completed FAST&quot;);</span>
<span class="fc" id="L101">            }</span>
        });

<span class="fc" id="L104">        Observable&lt;Integer&gt; slow = is.observeOn(Schedulers.computation()).map(new Function&lt;Integer, Integer&gt;() {</span>
            int c;

            @Override
            public Integer apply(Integer i) {
<span class="fc bfc" id="L109" title="All 2 branches covered.">                if (c == 0) {</span>
                    try {
<span class="fc" id="L111">                        Thread.sleep(500);</span>
<span class="nc" id="L112">                    } catch (InterruptedException e) {</span>
<span class="fc" id="L113">                    }</span>
                }
<span class="fc" id="L115">                c++;</span>
<span class="fc" id="L116">                return i;</span>
            }

<span class="fc" id="L119">        }).doOnComplete(new Action() {</span>

            @Override
            public void run() {
<span class="fc" id="L123">                System.out.println(&quot;^^^^^^^^^^^^^ completed SLOW&quot;);</span>
<span class="fc" id="L124">            }</span>

        });

<span class="fc" id="L128">        TestObserver&lt;Integer&gt; to = new TestObserver&lt;Integer&gt;();</span>
<span class="fc" id="L129">        Observable.merge(fast, slow).subscribe(to);</span>
<span class="fc" id="L130">        is.connect();</span>
<span class="fc" id="L131">        to.awaitTerminalEvent();</span>
<span class="fc" id="L132">        to.assertNoErrors();</span>
<span class="fc" id="L133">        assertEquals(Flowable.bufferSize() * 4, to.valueCount());</span>
<span class="fc" id="L134">    }</span>

    // use case from https://github.com/ReactiveX/RxJava/issues/1732
    @Test
    public void testTakeUntilWithPublishedStreamUsingSelector() {
<span class="fc" id="L139">        final AtomicInteger emitted = new AtomicInteger();</span>
<span class="fc" id="L140">        Observable&lt;Integer&gt; xs = Observable.range(0, Flowable.bufferSize() * 2).doOnNext(new Consumer&lt;Integer&gt;() {</span>

            @Override
            public void accept(Integer t1) {
<span class="fc" id="L144">                emitted.incrementAndGet();</span>
<span class="fc" id="L145">            }</span>

        });
<span class="fc" id="L148">        TestObserver&lt;Integer&gt; to = new TestObserver&lt;Integer&gt;();</span>
<span class="fc" id="L149">        xs.publish(new Function&lt;Observable&lt;Integer&gt;, Observable&lt;Integer&gt;&gt;() {</span>

            @Override
            public Observable&lt;Integer&gt; apply(Observable&lt;Integer&gt; xs) {
<span class="fc" id="L153">                return xs.takeUntil(xs.skipWhile(new Predicate&lt;Integer&gt;() {</span>

                    @Override
                    public boolean test(Integer i) {
<span class="fc bfc" id="L157" title="All 2 branches covered.">                        return i &lt;= 3;</span>
                    }

                }));
            }

<span class="fc" id="L163">        }).subscribe(to);</span>
<span class="fc" id="L164">        to.awaitTerminalEvent();</span>
<span class="fc" id="L165">        to.assertNoErrors();</span>
<span class="fc" id="L166">        to.assertValues(0, 1, 2, 3);</span>
<span class="fc" id="L167">        assertEquals(5, emitted.get());</span>
<span class="fc" id="L168">        System.out.println(to.values());</span>
<span class="fc" id="L169">    }</span>

    // use case from https://github.com/ReactiveX/RxJava/issues/1732
    @Test
    public void testTakeUntilWithPublishedStream() {
<span class="fc" id="L174">        Observable&lt;Integer&gt; xs = Observable.range(0, Flowable.bufferSize() * 2);</span>
<span class="fc" id="L175">        TestObserver&lt;Integer&gt; to = new TestObserver&lt;Integer&gt;();</span>
<span class="fc" id="L176">        ConnectableObservable&lt;Integer&gt; xsp = xs.publish();</span>
<span class="fc" id="L177">        xsp.takeUntil(xsp.skipWhile(new Predicate&lt;Integer&gt;() {</span>

            @Override
            public boolean test(Integer i) {
<span class="fc bfc" id="L181" title="All 2 branches covered.">                return i &lt;= 3;</span>
            }

<span class="fc" id="L184">        })).subscribe(to);</span>
<span class="fc" id="L185">        xsp.connect();</span>
<span class="fc" id="L186">        System.out.println(to.values());</span>
<span class="fc" id="L187">    }</span>

    @Test(timeout = 10000)
    public void testBackpressureTwoConsumers() {
<span class="fc" id="L191">        final AtomicInteger sourceEmission = new AtomicInteger();</span>
<span class="fc" id="L192">        final AtomicBoolean sourceUnsubscribed = new AtomicBoolean();</span>
<span class="fc" id="L193">        final Observable&lt;Integer&gt; source = Observable.range(1, 100)</span>
<span class="fc" id="L194">                .doOnNext(new Consumer&lt;Integer&gt;() {</span>
                    @Override
                    public void accept(Integer t1) {
<span class="fc" id="L197">                        sourceEmission.incrementAndGet();</span>
<span class="fc" id="L198">                    }</span>
                })
<span class="fc" id="L200">                .doOnDispose(new Action() {</span>
                    @Override
                    public void run() {
<span class="fc" id="L203">                        sourceUnsubscribed.set(true);</span>
<span class="fc" id="L204">                    }</span>
<span class="fc" id="L205">                }).share();</span>
        ;

<span class="fc" id="L208">        final AtomicBoolean child1Unsubscribed = new AtomicBoolean();</span>
<span class="fc" id="L209">        final AtomicBoolean child2Unsubscribed = new AtomicBoolean();</span>

<span class="fc" id="L211">        final TestObserver&lt;Integer&gt; to2 = new TestObserver&lt;Integer&gt;();</span>

<span class="fc" id="L213">        final TestObserver&lt;Integer&gt; to1 = new TestObserver&lt;Integer&gt;() {</span>
            @Override
            public void onNext(Integer t) {
<span class="fc bfc" id="L216" title="All 2 branches covered.">                if (valueCount() == 2) {</span>
<span class="fc" id="L217">                    source.doOnDispose(new Action() {</span>
                        @Override
                        public void run() {
<span class="fc" id="L220">                            child2Unsubscribed.set(true);</span>
<span class="fc" id="L221">                        }</span>
<span class="fc" id="L222">                    }).take(5).subscribe(to2);</span>
                }
<span class="fc" id="L224">                super.onNext(t);</span>
<span class="fc" id="L225">            }</span>
        };

<span class="fc" id="L228">        source.doOnDispose(new Action() {</span>
            @Override
            public void run() {
<span class="fc" id="L231">                child1Unsubscribed.set(true);</span>
<span class="fc" id="L232">            }</span>
<span class="fc" id="L233">        }).take(5)</span>
<span class="fc" id="L234">        .subscribe(to1);</span>

<span class="fc" id="L236">        to1.awaitTerminalEvent();</span>
<span class="fc" id="L237">        to2.awaitTerminalEvent();</span>

<span class="fc" id="L239">        to1.assertNoErrors();</span>
<span class="fc" id="L240">        to2.assertNoErrors();</span>

<span class="fc" id="L242">        assertTrue(sourceUnsubscribed.get());</span>
<span class="fc" id="L243">        assertTrue(child1Unsubscribed.get());</span>
<span class="fc" id="L244">        assertTrue(child2Unsubscribed.get());</span>

<span class="fc" id="L246">        to1.assertValues(1, 2, 3, 4, 5);</span>
<span class="fc" id="L247">        to2.assertValues(4, 5, 6, 7, 8);</span>

<span class="fc" id="L249">        assertEquals(8, sourceEmission.get());</span>
<span class="fc" id="L250">    }</span>

    @Test
    public void testConnectWithNoSubscriber() {
<span class="fc" id="L254">        TestScheduler scheduler = new TestScheduler();</span>
<span class="fc" id="L255">        ConnectableObservable&lt;Long&gt; co = Observable.interval(10, 10, TimeUnit.MILLISECONDS, scheduler).take(3).publish();</span>
<span class="fc" id="L256">        co.connect();</span>
        // Emit 0
<span class="fc" id="L258">        scheduler.advanceTimeBy(15, TimeUnit.MILLISECONDS);</span>
<span class="fc" id="L259">        TestObserver&lt;Long&gt; to = new TestObserver&lt;Long&gt;();</span>
<span class="fc" id="L260">        co.subscribe(to);</span>
        // Emit 1 and 2
<span class="fc" id="L262">        scheduler.advanceTimeBy(50, TimeUnit.MILLISECONDS);</span>
<span class="fc" id="L263">        to.assertValues(1L, 2L);</span>
<span class="fc" id="L264">        to.assertNoErrors();</span>
<span class="fc" id="L265">        to.assertTerminated();</span>
<span class="fc" id="L266">    }</span>

    @Test
    public void testSubscribeAfterDisconnectThenConnect() {
<span class="fc" id="L270">        ConnectableObservable&lt;Integer&gt; source = Observable.just(1).publish();</span>

<span class="fc" id="L272">        TestObserver&lt;Integer&gt; to1 = new TestObserver&lt;Integer&gt;();</span>

<span class="fc" id="L274">        source.subscribe(to1);</span>

<span class="fc" id="L276">        Disposable connection = source.connect();</span>

<span class="fc" id="L278">        to1.assertValue(1);</span>
<span class="fc" id="L279">        to1.assertNoErrors();</span>
<span class="fc" id="L280">        to1.assertTerminated();</span>

<span class="fc" id="L282">        TestObserver&lt;Integer&gt; to2 = new TestObserver&lt;Integer&gt;();</span>

<span class="fc" id="L284">        source.subscribe(to2);</span>

<span class="fc" id="L286">        Disposable connection2 = source.connect();</span>

<span class="fc" id="L288">        to2.assertValue(1);</span>
<span class="fc" id="L289">        to2.assertNoErrors();</span>
<span class="fc" id="L290">        to2.assertTerminated();</span>

<span class="fc" id="L292">        System.out.println(connection);</span>
<span class="fc" id="L293">        System.out.println(connection2);</span>
<span class="fc" id="L294">    }</span>

    @Test
    public void testNoSubscriberRetentionOnCompleted() {
<span class="fc" id="L298">        ObservablePublish&lt;Integer&gt; source = (ObservablePublish&lt;Integer&gt;)Observable.just(1).publish();</span>

<span class="fc" id="L300">        TestObserver&lt;Integer&gt; to1 = new TestObserver&lt;Integer&gt;();</span>

<span class="fc" id="L302">        source.subscribe(to1);</span>

<span class="fc" id="L304">        to1.assertNoValues();</span>
<span class="fc" id="L305">        to1.assertNoErrors();</span>
<span class="fc" id="L306">        to1.assertNotComplete();</span>

<span class="fc" id="L308">        source.connect();</span>

<span class="fc" id="L310">        to1.assertValue(1);</span>
<span class="fc" id="L311">        to1.assertNoErrors();</span>
<span class="fc" id="L312">        to1.assertTerminated();</span>

<span class="fc" id="L314">        assertNull(source.current.get());</span>
<span class="fc" id="L315">    }</span>

    @Test
    public void testNonNullConnection() {
<span class="fc" id="L319">        ConnectableObservable&lt;Object&gt; source = Observable.never().publish();</span>

<span class="fc" id="L321">        assertNotNull(source.connect());</span>
<span class="fc" id="L322">        assertNotNull(source.connect());</span>
<span class="fc" id="L323">    }</span>

    @Test
    public void testNoDisconnectSomeoneElse() {
<span class="fc" id="L327">        ConnectableObservable&lt;Object&gt; source = Observable.never().publish();</span>

<span class="fc" id="L329">        Disposable connection1 = source.connect();</span>
<span class="fc" id="L330">        Disposable connection2 = source.connect();</span>

<span class="fc" id="L332">        connection1.dispose();</span>

<span class="fc" id="L334">        Disposable connection3 = source.connect();</span>

<span class="fc" id="L336">        connection2.dispose();</span>

<span class="fc" id="L338">        assertTrue(checkPublishDisposed(connection1));</span>
<span class="fc" id="L339">        assertTrue(checkPublishDisposed(connection2));</span>
<span class="fc" id="L340">        assertFalse(checkPublishDisposed(connection3));</span>
<span class="fc" id="L341">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    static boolean checkPublishDisposed(Disposable d) {
<span class="fc" id="L345">        return ((ObservablePublish.PublishObserver&lt;Object&gt;)d).isDisposed();</span>
    }

    @Test
    public void testConnectIsIdempotent() {
<span class="fc" id="L350">        final AtomicInteger calls = new AtomicInteger();</span>
<span class="fc" id="L351">        Observable&lt;Integer&gt; source = Observable.unsafeCreate(new ObservableSource&lt;Integer&gt;() {</span>
            @Override
            public void subscribe(Observer&lt;? super Integer&gt; t) {
<span class="fc" id="L354">                t.onSubscribe(Disposables.empty());</span>
<span class="fc" id="L355">                calls.getAndIncrement();</span>
<span class="fc" id="L356">            }</span>
        });

<span class="fc" id="L359">        ConnectableObservable&lt;Integer&gt; conn = source.publish();</span>

<span class="fc" id="L361">        assertEquals(0, calls.get());</span>

<span class="fc" id="L363">        conn.connect();</span>
<span class="fc" id="L364">        conn.connect();</span>

<span class="fc" id="L366">        assertEquals(1, calls.get());</span>

<span class="fc" id="L368">        conn.connect().dispose();</span>

<span class="fc" id="L370">        conn.connect();</span>
<span class="fc" id="L371">        conn.connect();</span>

<span class="fc" id="L373">        assertEquals(2, calls.get());</span>
<span class="fc" id="L374">    }</span>

    @Test
    public void testObserveOn() {
<span class="fc" id="L378">        ConnectableObservable&lt;Integer&gt; co = Observable.range(0, 1000).publish();</span>
<span class="fc" id="L379">        Observable&lt;Integer&gt; obs = co.observeOn(Schedulers.computation());</span>
<span class="fc bfc" id="L380" title="All 2 branches covered.">        for (int i = 0; i &lt; 1000; i++) {</span>
<span class="fc bfc" id="L381" title="All 2 branches covered.">            for (int j = 1; j &lt; 6; j++) {</span>
<span class="fc" id="L382">                List&lt;TestObserver&lt;Integer&gt;&gt; tos = new ArrayList&lt;TestObserver&lt;Integer&gt;&gt;();</span>
<span class="fc bfc" id="L383" title="All 2 branches covered.">                for (int k = 1; k &lt; j; k++) {</span>
<span class="fc" id="L384">                    TestObserver&lt;Integer&gt; to = new TestObserver&lt;Integer&gt;();</span>
<span class="fc" id="L385">                    tos.add(to);</span>
<span class="fc" id="L386">                    obs.subscribe(to);</span>
                }

<span class="fc" id="L389">                Disposable connection = co.connect();</span>

<span class="fc bfc" id="L391" title="All 2 branches covered.">                for (TestObserver&lt;Integer&gt; to : tos) {</span>
<span class="fc" id="L392">                    to.awaitTerminalEvent(2, TimeUnit.SECONDS);</span>
<span class="fc" id="L393">                    to.assertTerminated();</span>
<span class="fc" id="L394">                    to.assertNoErrors();</span>
<span class="fc" id="L395">                    assertEquals(1000, to.valueCount());</span>
<span class="fc" id="L396">                }</span>
<span class="fc" id="L397">                connection.dispose();</span>
            }
        }
<span class="fc" id="L400">    }</span>

    @Test
    public void preNextConnect() {
<span class="fc bfc" id="L404" title="All 2 branches covered.">        for (int i = 0; i &lt; TestHelper.RACE_DEFAULT_LOOPS; i++) {</span>

<span class="fc" id="L406">            final ConnectableObservable&lt;Integer&gt; co = Observable.&lt;Integer&gt;empty().publish();</span>

<span class="fc" id="L408">            co.connect();</span>

<span class="fc" id="L410">            Runnable r1 = new Runnable() {</span>
                @Override
                public void run() {
<span class="fc" id="L413">                    co.test();</span>
<span class="fc" id="L414">                }</span>
            };

<span class="fc" id="L417">            TestHelper.race(r1, r1);</span>
        }
<span class="fc" id="L419">    }</span>

    @Test
    public void connectRace() {
<span class="fc bfc" id="L423" title="All 2 branches covered.">        for (int i = 0; i &lt; TestHelper.RACE_DEFAULT_LOOPS; i++) {</span>

<span class="fc" id="L425">            final ConnectableObservable&lt;Integer&gt; co = Observable.&lt;Integer&gt;empty().publish();</span>

<span class="fc" id="L427">            Runnable r1 = new Runnable() {</span>
                @Override
                public void run() {
<span class="fc" id="L430">                    co.connect();</span>
<span class="fc" id="L431">                }</span>
            };

<span class="fc" id="L434">            TestHelper.race(r1, r1);</span>
        }
<span class="fc" id="L436">    }</span>

    @Test
    public void selectorCrash() {
<span class="fc" id="L440">        Observable.just(1).publish(new Function&lt;Observable&lt;Integer&gt;, ObservableSource&lt;Object&gt;&gt;() {</span>
            @Override
            public ObservableSource&lt;Object&gt; apply(Observable&lt;Integer&gt; v) throws Exception {
<span class="fc" id="L443">                throw new TestException();</span>
            }
        })
<span class="fc" id="L446">        .test()</span>
<span class="fc" id="L447">        .assertFailure(TestException.class);</span>
<span class="fc" id="L448">    }</span>

    @Test
    public void source() {
<span class="fc" id="L452">        Observable&lt;Integer&gt; o = Observable.never();</span>

<span class="fc" id="L454">        assertSame(o, (((HasUpstreamObservableSource&lt;?&gt;)o.publish()).source()));</span>
<span class="fc" id="L455">    }</span>

    @Test
    public void connectThrows() {
<span class="fc" id="L459">        ConnectableObservable&lt;Integer&gt; co = Observable.&lt;Integer&gt;empty().publish();</span>
        try {
<span class="pc" id="L461">            co.connect(new Consumer&lt;Disposable&gt;() {</span>
                @Override
                public void accept(Disposable d) throws Exception {
<span class="fc" id="L464">                    throw new TestException();</span>
                }
            });
<span class="fc" id="L467">        } catch (TestException ex) {</span>
            // expected
<span class="nc" id="L469">        }</span>
<span class="fc" id="L470">    }</span>

    @Test
    public void addRemoveRace() {
<span class="fc bfc" id="L474" title="All 2 branches covered.">        for (int i = 0; i &lt; TestHelper.RACE_DEFAULT_LOOPS; i++) {</span>

<span class="fc" id="L476">            final ConnectableObservable&lt;Integer&gt; co = Observable.&lt;Integer&gt;empty().publish();</span>

<span class="fc" id="L478">            final TestObserver&lt;Integer&gt; to = co.test();</span>

<span class="fc" id="L480">            final TestObserver&lt;Integer&gt; to2 = new TestObserver&lt;Integer&gt;();</span>

<span class="fc" id="L482">            Runnable r1 = new Runnable() {</span>
                @Override
                public void run() {
<span class="fc" id="L485">                    co.subscribe(to2);</span>
<span class="fc" id="L486">                }</span>
            };

<span class="fc" id="L489">            Runnable r2 = new Runnable() {</span>
                @Override
                public void run() {
<span class="fc" id="L492">                    to.cancel();</span>
<span class="fc" id="L493">                }</span>
            };

<span class="fc" id="L496">            TestHelper.race(r1, r2);</span>
        }
<span class="fc" id="L498">    }</span>

    @Test
    public void disposeOnArrival() {
<span class="fc" id="L502">        ConnectableObservable&lt;Integer&gt; co = Observable.&lt;Integer&gt;empty().publish();</span>

<span class="fc" id="L504">        co.test(true).assertEmpty();</span>
<span class="fc" id="L505">    }</span>

    @Test
    public void dispose() {
<span class="fc" id="L509">        TestHelper.checkDisposed(Observable.never().publish());</span>

<span class="fc" id="L511">        TestHelper.checkDisposed(Observable.never().publish(Functions.&lt;Observable&lt;Object&gt;&gt;identity()));</span>
<span class="fc" id="L512">    }</span>

    @Test
    public void empty() {
<span class="fc" id="L516">        ConnectableObservable&lt;Integer&gt; co = Observable.&lt;Integer&gt;empty().publish();</span>

<span class="fc" id="L518">        co.connect();</span>
<span class="fc" id="L519">    }</span>

    @Test
    public void take() {
<span class="fc" id="L523">        ConnectableObservable&lt;Integer&gt; co = Observable.range(1, 2).publish();</span>

<span class="fc" id="L525">        TestObserver&lt;Integer&gt; to = co.take(1).test();</span>

<span class="fc" id="L527">        co.connect();</span>

<span class="fc" id="L529">        to.assertResult(1);</span>
<span class="fc" id="L530">    }</span>

    @Test
    public void just() {
<span class="fc" id="L534">        final PublishSubject&lt;Integer&gt; ps = PublishSubject.create();</span>

<span class="fc" id="L536">        ConnectableObservable&lt;Integer&gt; co = ps.publish();</span>

<span class="fc" id="L538">        TestObserver&lt;Integer&gt; to = new TestObserver&lt;Integer&gt;() {</span>
            @Override
            public void onNext(Integer t) {
<span class="fc" id="L541">                super.onNext(t);</span>
<span class="fc" id="L542">                ps.onComplete();</span>
<span class="fc" id="L543">            }</span>
        };

<span class="fc" id="L546">        co.subscribe(to);</span>
<span class="fc" id="L547">        co.connect();</span>

<span class="fc" id="L549">        ps.onNext(1);</span>

<span class="fc" id="L551">        to.assertResult(1);</span>
<span class="fc" id="L552">    }</span>

    @Test
    public void nextCancelRace() {
<span class="fc bfc" id="L556" title="All 2 branches covered.">        for (int i = 0; i &lt; TestHelper.RACE_DEFAULT_LOOPS; i++) {</span>

<span class="fc" id="L558">            final PublishSubject&lt;Integer&gt; ps = PublishSubject.create();</span>

<span class="fc" id="L560">            final ConnectableObservable&lt;Integer&gt; co = ps.publish();</span>

<span class="fc" id="L562">            final TestObserver&lt;Integer&gt; to = co.test();</span>

<span class="fc" id="L564">            Runnable r1 = new Runnable() {</span>
                @Override
                public void run() {
<span class="fc" id="L567">                    ps.onNext(1);</span>
<span class="fc" id="L568">                }</span>
            };

<span class="fc" id="L571">            Runnable r2 = new Runnable() {</span>
                @Override
                public void run() {
<span class="fc" id="L574">                    to.cancel();</span>
<span class="fc" id="L575">                }</span>
            };

<span class="fc" id="L578">            TestHelper.race(r1, r2);</span>
        }
<span class="fc" id="L580">    }</span>

    @Test
    public void badSource() {
<span class="fc" id="L584">        List&lt;Throwable&gt; errors = TestHelper.trackPluginErrors();</span>
        try {
<span class="fc" id="L586">            new Observable&lt;Integer&gt;() {</span>
                @Override
                protected void subscribeActual(Observer&lt;? super Integer&gt; observer) {
<span class="fc" id="L589">                    observer.onSubscribe(Disposables.empty());</span>
<span class="fc" id="L590">                    observer.onNext(1);</span>
<span class="fc" id="L591">                    observer.onComplete();</span>
<span class="fc" id="L592">                    observer.onNext(2);</span>
<span class="fc" id="L593">                    observer.onError(new TestException());</span>
<span class="fc" id="L594">                    observer.onComplete();</span>
<span class="fc" id="L595">                }</span>
            }
<span class="fc" id="L597">            .publish()</span>
<span class="fc" id="L598">            .autoConnect()</span>
<span class="fc" id="L599">            .test()</span>
<span class="fc" id="L600">            .assertResult(1);</span>

<span class="fc" id="L602">            TestHelper.assertUndeliverable(errors, 0, TestException.class);</span>
        } finally {
<span class="fc" id="L604">            RxJavaPlugins.reset();</span>
        }
<span class="fc" id="L606">    }</span>

    @Test
    public void noErrorLoss() {
<span class="fc" id="L610">        List&lt;Throwable&gt; errors = TestHelper.trackPluginErrors();</span>
        try {
<span class="fc" id="L612">            ConnectableObservable&lt;Object&gt; co = Observable.error(new TestException()).publish();</span>

<span class="fc" id="L614">            co.connect();</span>

<span class="fc" id="L616">            TestHelper.assertUndeliverable(errors, 0, TestException.class);</span>
        } finally {
<span class="fc" id="L618">            RxJavaPlugins.reset();</span>
        }
<span class="fc" id="L620">    }</span>

    @Test
    public void subscribeDisconnectRace() {
<span class="fc bfc" id="L624" title="All 2 branches covered.">        for (int i = 0; i &lt; TestHelper.RACE_DEFAULT_LOOPS; i++) {</span>

<span class="fc" id="L626">            final PublishSubject&lt;Integer&gt; ps = PublishSubject.create();</span>

<span class="fc" id="L628">            final ConnectableObservable&lt;Integer&gt; co = ps.publish();</span>

<span class="fc" id="L630">            final Disposable d = co.connect();</span>
<span class="fc" id="L631">            final TestObserver&lt;Integer&gt; to = new TestObserver&lt;Integer&gt;();</span>

<span class="fc" id="L633">            Runnable r1 = new Runnable() {</span>
                @Override
                public void run() {
<span class="fc" id="L636">                    d.dispose();</span>
<span class="fc" id="L637">                }</span>
            };

<span class="fc" id="L640">            Runnable r2 = new Runnable() {</span>
                @Override
                public void run() {
<span class="fc" id="L643">                    co.subscribe(to);</span>
<span class="fc" id="L644">                }</span>
            };

<span class="fc" id="L647">            TestHelper.race(r1, r2);</span>
        }
<span class="fc" id="L649">    }</span>

    @Test
    public void selectorDisconnectsIndependentSource() {
<span class="fc" id="L653">        PublishSubject&lt;Integer&gt; ps = PublishSubject.create();</span>

<span class="fc" id="L655">        ps.publish(new Function&lt;Observable&lt;Integer&gt;, ObservableSource&lt;Integer&gt;&gt;() {</span>
            @Override
            public ObservableSource&lt;Integer&gt; apply(Observable&lt;Integer&gt; v) throws Exception {
<span class="fc" id="L658">                return Observable.range(1, 2);</span>
            }
        })
<span class="fc" id="L661">        .test()</span>
<span class="fc" id="L662">        .assertResult(1, 2);</span>

<span class="fc" id="L664">        assertFalse(ps.hasObservers());</span>
<span class="fc" id="L665">    }</span>

    @Test(timeout = 5000)
    public void selectorLatecommer() {
<span class="fc" id="L669">        Observable.range(1, 5)</span>
<span class="fc" id="L670">        .publish(new Function&lt;Observable&lt;Integer&gt;, ObservableSource&lt;Integer&gt;&gt;() {</span>
            @Override
            public ObservableSource&lt;Integer&gt; apply(Observable&lt;Integer&gt; v) throws Exception {
<span class="fc" id="L673">                return v.concatWith(v);</span>
            }
        })
<span class="fc" id="L676">        .test()</span>
<span class="fc" id="L677">        .assertResult(1, 2, 3, 4, 5);</span>
<span class="fc" id="L678">    }</span>

    @Test
    public void mainError() {
<span class="fc" id="L682">        Observable.error(new TestException())</span>
<span class="fc" id="L683">        .publish(Functions.&lt;Observable&lt;Object&gt;&gt;identity())</span>
<span class="fc" id="L684">        .test()</span>
<span class="fc" id="L685">        .assertFailure(TestException.class);</span>
<span class="fc" id="L686">    }</span>

    @Test
    public void selectorInnerError() {
<span class="fc" id="L690">        PublishSubject&lt;Integer&gt; ps = PublishSubject.create();</span>

<span class="fc" id="L692">        ps.publish(new Function&lt;Observable&lt;Integer&gt;, ObservableSource&lt;Integer&gt;&gt;() {</span>
            @Override
            public ObservableSource&lt;Integer&gt; apply(Observable&lt;Integer&gt; v) throws Exception {
<span class="fc" id="L695">                return Observable.error(new TestException());</span>
            }
        })
<span class="fc" id="L698">        .test()</span>
<span class="fc" id="L699">        .assertFailure(TestException.class);</span>

<span class="fc" id="L701">        assertFalse(ps.hasObservers());</span>
<span class="fc" id="L702">    }</span>

    @Test
    public void delayedUpstreamOnSubscribe() {
<span class="fc" id="L706">        final Observer&lt;?&gt;[] sub = { null };</span>

<span class="fc" id="L708">        new Observable&lt;Integer&gt;() {</span>
            @Override
            protected void subscribeActual(Observer&lt;? super Integer&gt; observer) {
<span class="fc" id="L711">                sub[0] = observer;</span>
<span class="fc" id="L712">            }</span>
        }
<span class="fc" id="L714">        .publish()</span>
<span class="fc" id="L715">        .connect()</span>
<span class="fc" id="L716">        .dispose();</span>

<span class="fc" id="L718">        Disposable bs = Disposables.empty();</span>

<span class="fc" id="L720">        sub[0].onSubscribe(bs);</span>

<span class="fc" id="L722">        assertTrue(bs.isDisposed());</span>
<span class="fc" id="L723">    }</span>

    @Test
    public void doubleOnSubscribe() {
<span class="fc" id="L727">        TestHelper.checkDoubleOnSubscribeObservable(new Function&lt;Observable&lt;Object&gt;, ObservableSource&lt;Object&gt;&gt;() {</span>
            @Override
            public ObservableSource&lt;Object&gt; apply(final Observable&lt;Object&gt; o)
                    throws Exception {
<span class="fc" id="L731">                return Observable.&lt;Integer&gt;never().publish(new Function&lt;Observable&lt;Integer&gt;, ObservableSource&lt;Object&gt;&gt;() {</span>
                    @Override
                    public ObservableSource&lt;Object&gt; apply(Observable&lt;Integer&gt; v)
                            throws Exception {
<span class="fc" id="L735">                        return o;</span>
                    }
                });
            }
        }
        );
<span class="fc" id="L741">    }</span>

    @Test
    public void disposedUpfront() {
<span class="fc" id="L745">        ConnectableObservable&lt;Integer&gt; co = Observable.just(1)</span>
<span class="fc" id="L746">                .concatWith(Observable.&lt;Integer&gt;never())</span>
<span class="fc" id="L747">                .publish();</span>

<span class="fc" id="L749">        TestObserver&lt;Integer&gt; to1 = co.test();</span>

<span class="fc" id="L751">        TestObserver&lt;Integer&gt; to2 = co.test(true);</span>

<span class="fc" id="L753">        co.connect();</span>

<span class="fc" id="L755">        to1.assertValuesOnly(1);</span>

<span class="fc" id="L757">        to2.assertEmpty();</span>

<span class="fc" id="L759">        ((ObservablePublish&lt;Integer&gt;)co).current.get().remove(null);</span>
<span class="fc" id="L760">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>