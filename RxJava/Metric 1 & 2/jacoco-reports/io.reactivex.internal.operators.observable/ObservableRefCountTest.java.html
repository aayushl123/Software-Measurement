<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ObservableRefCountTest.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">RxJava_2_x$Unnamed.exec</a> &gt; <a href="index.source.html" class="el_package">io.reactivex.internal.operators.observable</a> &gt; <span class="el_source">ObservableRefCountTest.java</span></div><h1>ObservableRefCountTest.java</h1><pre class="source lang-java linenums">/**
 * Copyright (c) 2016-present, RxJava Contributors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is
 * distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
 * the License for the specific language governing permissions and limitations under the License.
 */

package io.reactivex.internal.operators.observable;

import static org.junit.Assert.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

import java.io.IOException;
import java.lang.management.ManagementFactory;
import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.*;

import org.junit.Test;
import org.mockito.InOrder;

import io.reactivex.*;
import io.reactivex.Observable;
import io.reactivex.Observer;
import io.reactivex.disposables.*;
import io.reactivex.exceptions.*;
import io.reactivex.functions.*;
import io.reactivex.internal.functions.Functions;
import io.reactivex.internal.operators.observable.ObservableRefCount.RefConnection;
import io.reactivex.internal.util.ExceptionHelper;
import io.reactivex.observables.ConnectableObservable;
import io.reactivex.observers.TestObserver;
import io.reactivex.plugins.RxJavaPlugins;
import io.reactivex.schedulers.*;
import io.reactivex.subjects.*;

<span class="fc" id="L44">public class ObservableRefCountTest {</span>

    @Test
    public void testRefCountAsync() {
<span class="fc" id="L48">        final AtomicInteger subscribeCount = new AtomicInteger();</span>
<span class="fc" id="L49">        final AtomicInteger nextCount = new AtomicInteger();</span>
<span class="fc" id="L50">        Observable&lt;Long&gt; r = Observable.interval(0, 25, TimeUnit.MILLISECONDS)</span>
<span class="fc" id="L51">                .doOnSubscribe(new Consumer&lt;Disposable&gt;() {</span>
                    @Override
                    public void accept(Disposable d) {
<span class="fc" id="L54">                        subscribeCount.incrementAndGet();</span>
<span class="fc" id="L55">                    }</span>
                })
<span class="fc" id="L57">                .doOnNext(new Consumer&lt;Long&gt;() {</span>
                    @Override
                    public void accept(Long l) {
<span class="fc" id="L60">                        nextCount.incrementAndGet();</span>
<span class="fc" id="L61">                    }</span>
                })
<span class="fc" id="L63">                .publish().refCount();</span>

<span class="fc" id="L65">        final AtomicInteger receivedCount = new AtomicInteger();</span>
<span class="fc" id="L66">        Disposable d1 = r.subscribe(new Consumer&lt;Long&gt;() {</span>
            @Override
            public void accept(Long l) {
<span class="fc" id="L69">                receivedCount.incrementAndGet();</span>
<span class="fc" id="L70">            }</span>
        });

<span class="fc" id="L73">        Disposable d2 = r.subscribe();</span>

        // give time to emit
        try {
<span class="fc" id="L77">            Thread.sleep(260);</span>
<span class="nc" id="L78">        } catch (InterruptedException e) {</span>
<span class="fc" id="L79">        }</span>

        // now unsubscribe
<span class="fc" id="L82">        d2.dispose(); // unsubscribe s2 first as we're counting in 1 and there can be a race between unsubscribe and one Observer getting a value but not the other</span>
<span class="fc" id="L83">        d1.dispose();</span>

<span class="fc" id="L85">        System.out.println(&quot;onNext: &quot; + nextCount.get());</span>

        // should emit once for both subscribers
<span class="fc" id="L88">        assertEquals(nextCount.get(), receivedCount.get());</span>
        // only 1 subscribe
<span class="fc" id="L90">        assertEquals(1, subscribeCount.get());</span>
<span class="fc" id="L91">    }</span>

    @Test
    public void testRefCountSynchronous() {
<span class="fc" id="L95">        final AtomicInteger subscribeCount = new AtomicInteger();</span>
<span class="fc" id="L96">        final AtomicInteger nextCount = new AtomicInteger();</span>
<span class="fc" id="L97">        Observable&lt;Integer&gt; r = Observable.just(1, 2, 3, 4, 5, 6, 7, 8, 9)</span>
<span class="fc" id="L98">                .doOnSubscribe(new Consumer&lt;Disposable&gt;() {</span>
                    @Override
                    public void accept(Disposable d) {
<span class="fc" id="L101">                        subscribeCount.incrementAndGet();</span>
<span class="fc" id="L102">                    }</span>
                })
<span class="fc" id="L104">                .doOnNext(new Consumer&lt;Integer&gt;() {</span>
                    @Override
                    public void accept(Integer l) {
<span class="fc" id="L107">                        nextCount.incrementAndGet();</span>
<span class="fc" id="L108">                    }</span>
                })
<span class="fc" id="L110">                .publish().refCount();</span>

<span class="fc" id="L112">        final AtomicInteger receivedCount = new AtomicInteger();</span>
<span class="fc" id="L113">        Disposable d1 = r.subscribe(new Consumer&lt;Integer&gt;() {</span>
            @Override
            public void accept(Integer l) {
<span class="fc" id="L116">                receivedCount.incrementAndGet();</span>
<span class="fc" id="L117">            }</span>
        });

<span class="fc" id="L120">        Disposable d2 = r.subscribe();</span>

        // give time to emit
        try {
<span class="fc" id="L124">            Thread.sleep(50);</span>
<span class="nc" id="L125">        } catch (InterruptedException e) {</span>
<span class="fc" id="L126">        }</span>

        // now unsubscribe
<span class="fc" id="L129">        d2.dispose(); // unsubscribe s2 first as we're counting in 1 and there can be a race between unsubscribe and one Observer getting a value but not the other</span>
<span class="fc" id="L130">        d1.dispose();</span>

<span class="fc" id="L132">        System.out.println(&quot;onNext Count: &quot; + nextCount.get());</span>

        // it will emit twice because it is synchronous
<span class="fc" id="L135">        assertEquals(nextCount.get(), receivedCount.get() * 2);</span>
        // it will subscribe twice because it is synchronous
<span class="fc" id="L137">        assertEquals(2, subscribeCount.get());</span>
<span class="fc" id="L138">    }</span>

    @Test
    public void testRefCountSynchronousTake() {
<span class="fc" id="L142">        final AtomicInteger nextCount = new AtomicInteger();</span>
<span class="fc" id="L143">        Observable&lt;Integer&gt; r = Observable.just(1, 2, 3, 4, 5, 6, 7, 8, 9)</span>
<span class="fc" id="L144">                .doOnNext(new Consumer&lt;Integer&gt;() {</span>
                    @Override
                    public void accept(Integer l) {
<span class="fc" id="L147">                            System.out.println(&quot;onNext --------&gt; &quot; + l);</span>
<span class="fc" id="L148">                            nextCount.incrementAndGet();</span>
<span class="fc" id="L149">                    }</span>
                })
<span class="fc" id="L151">                .take(4)</span>
<span class="fc" id="L152">                .publish().refCount();</span>

<span class="fc" id="L154">        final AtomicInteger receivedCount = new AtomicInteger();</span>
<span class="fc" id="L155">        r.subscribe(new Consumer&lt;Integer&gt;() {</span>
            @Override
            public void accept(Integer l) {
<span class="fc" id="L158">                receivedCount.incrementAndGet();</span>
<span class="fc" id="L159">            }</span>
        });

<span class="fc" id="L162">        System.out.println(&quot;onNext: &quot; + nextCount.get());</span>

<span class="fc" id="L164">        assertEquals(4, receivedCount.get());</span>
<span class="fc" id="L165">        assertEquals(4, receivedCount.get());</span>
<span class="fc" id="L166">    }</span>

    @Test
    public void testRepeat() {
<span class="fc" id="L170">        final AtomicInteger subscribeCount = new AtomicInteger();</span>
<span class="fc" id="L171">        final AtomicInteger unsubscribeCount = new AtomicInteger();</span>
<span class="fc" id="L172">        Observable&lt;Long&gt; r = Observable.interval(0, 1, TimeUnit.MILLISECONDS)</span>
<span class="fc" id="L173">                .doOnSubscribe(new Consumer&lt;Disposable&gt;() {</span>
                    @Override
                    public void accept(Disposable d) {
<span class="fc" id="L176">                            System.out.println(&quot;******************************* Subscribe received&quot;);</span>
                            // when we are subscribed
<span class="fc" id="L178">                            subscribeCount.incrementAndGet();</span>
<span class="fc" id="L179">                    }</span>
                })
<span class="fc" id="L181">                .doOnDispose(new Action() {</span>
                    @Override
                    public void run() {
<span class="fc" id="L184">                            System.out.println(&quot;******************************* Unsubscribe received&quot;);</span>
                            // when we are unsubscribed
<span class="fc" id="L186">                            unsubscribeCount.incrementAndGet();</span>
<span class="fc" id="L187">                    }</span>
                })
<span class="fc" id="L189">                .publish().refCount();</span>

<span class="fc bfc" id="L191" title="All 2 branches covered.">        for (int i = 0; i &lt; 10; i++) {</span>
<span class="fc" id="L192">            TestObserver&lt;Long&gt; to1 = new TestObserver&lt;Long&gt;();</span>
<span class="fc" id="L193">            TestObserver&lt;Long&gt; to2 = new TestObserver&lt;Long&gt;();</span>
<span class="fc" id="L194">            r.subscribe(to1);</span>
<span class="fc" id="L195">            r.subscribe(to2);</span>
            try {
<span class="fc" id="L197">                Thread.sleep(50);</span>
<span class="nc" id="L198">            } catch (InterruptedException e) {</span>
<span class="fc" id="L199">            }</span>
<span class="fc" id="L200">            to1.dispose();</span>
<span class="fc" id="L201">            to2.dispose();</span>
<span class="fc" id="L202">            to1.assertNoErrors();</span>
<span class="fc" id="L203">            to2.assertNoErrors();</span>
<span class="pc bpc" id="L204" title="1 of 2 branches missed.">            assertTrue(to1.valueCount() &gt; 0);</span>
<span class="pc bpc" id="L205" title="1 of 2 branches missed.">            assertTrue(to2.valueCount() &gt; 0);</span>
        }

<span class="fc" id="L208">        assertEquals(10, subscribeCount.get());</span>
<span class="fc" id="L209">        assertEquals(10, unsubscribeCount.get());</span>
<span class="fc" id="L210">    }</span>

    @Test
    public void testConnectUnsubscribe() throws InterruptedException {
<span class="fc" id="L214">        final CountDownLatch unsubscribeLatch = new CountDownLatch(1);</span>
<span class="fc" id="L215">        final CountDownLatch subscribeLatch = new CountDownLatch(1);</span>

<span class="fc" id="L217">        Observable&lt;Long&gt; o = synchronousInterval()</span>
<span class="fc" id="L218">                .doOnSubscribe(new Consumer&lt;Disposable&gt;() {</span>
                    @Override
                    public void accept(Disposable d) {
<span class="fc" id="L221">                            System.out.println(&quot;******************************* Subscribe received&quot;);</span>
                            // when we are subscribed
<span class="fc" id="L223">                            subscribeLatch.countDown();</span>
<span class="fc" id="L224">                    }</span>
                })
<span class="fc" id="L226">                .doOnDispose(new Action() {</span>
                    @Override
                    public void run() {
<span class="fc" id="L229">                            System.out.println(&quot;******************************* Unsubscribe received&quot;);</span>
                            // when we are unsubscribed
<span class="fc" id="L231">                            unsubscribeLatch.countDown();</span>
<span class="fc" id="L232">                    }</span>
                });

<span class="fc" id="L235">        TestObserver&lt;Long&gt; observer = new TestObserver&lt;Long&gt;();</span>
<span class="fc" id="L236">        o.publish().refCount().subscribeOn(Schedulers.newThread()).subscribe(observer);</span>
<span class="fc" id="L237">        System.out.println(&quot;send unsubscribe&quot;);</span>
        // wait until connected
<span class="fc" id="L239">        subscribeLatch.await();</span>
        // now unsubscribe
<span class="fc" id="L241">        observer.dispose();</span>
<span class="fc" id="L242">        System.out.println(&quot;DONE sending unsubscribe ... now waiting&quot;);</span>
<span class="pc bpc" id="L243" title="1 of 2 branches missed.">        if (!unsubscribeLatch.await(3000, TimeUnit.MILLISECONDS)) {</span>
<span class="nc" id="L244">            System.out.println(&quot;Errors: &quot; + observer.errors());</span>
<span class="nc bnc" id="L245" title="All 2 branches missed.">            if (observer.errors().size() &gt; 0) {</span>
<span class="nc" id="L246">                observer.errors().get(0).printStackTrace();</span>
            }
<span class="nc" id="L248">            fail(&quot;timed out waiting for unsubscribe&quot;);</span>
        }
<span class="fc" id="L250">        observer.assertNoErrors();</span>
<span class="fc" id="L251">    }</span>

    @Test
    public void testConnectUnsubscribeRaceConditionLoop() throws InterruptedException {
<span class="fc bfc" id="L255" title="All 2 branches covered.">        for (int i = 0; i &lt; 100; i++) {</span>
<span class="fc" id="L256">            testConnectUnsubscribeRaceCondition();</span>
        }
<span class="fc" id="L258">    }</span>

    @Test
    public void testConnectUnsubscribeRaceCondition() throws InterruptedException {
<span class="fc" id="L262">        final AtomicInteger subUnsubCount = new AtomicInteger();</span>
<span class="fc" id="L263">        Observable&lt;Long&gt; o = synchronousInterval()</span>
<span class="fc" id="L264">                .doOnDispose(new Action() {</span>
                    @Override
                    public void run() {
<span class="fc" id="L267">                            System.out.println(&quot;******************************* Unsubscribe received&quot;);</span>
                            // when we are unsubscribed
<span class="fc" id="L269">                            subUnsubCount.decrementAndGet();</span>
<span class="fc" id="L270">                    }</span>
                })
<span class="fc" id="L272">                .doOnSubscribe(new Consumer&lt;Disposable&gt;() {</span>
                    @Override
                    public void accept(Disposable d) {
<span class="fc" id="L275">                            System.out.println(&quot;******************************* SUBSCRIBE received&quot;);</span>
<span class="fc" id="L276">                            subUnsubCount.incrementAndGet();</span>
<span class="fc" id="L277">                    }</span>
                });

<span class="fc" id="L280">        TestObserver&lt;Long&gt; observer = new TestObserver&lt;Long&gt;();</span>

<span class="fc" id="L282">        o.publish().refCount().subscribeOn(Schedulers.computation()).subscribe(observer);</span>
<span class="fc" id="L283">        System.out.println(&quot;send unsubscribe&quot;);</span>
        // now immediately unsubscribe while subscribeOn is racing to subscribe
<span class="fc" id="L285">        observer.dispose();</span>

        // this generally will mean it won't even subscribe as it is already unsubscribed by the time connect() gets scheduled
        // give time to the counter to update
<span class="fc" id="L289">        Thread.sleep(10);</span>

        // make sure we wait a bit in case the counter is still nonzero
<span class="fc" id="L292">        int counter = 200;</span>
<span class="pc bpc" id="L293" title="3 of 4 branches missed.">        while (subUnsubCount.get() != 0 &amp;&amp; counter-- != 0) {</span>
<span class="nc" id="L294">            Thread.sleep(10);</span>
        }
        // either we subscribed and then unsubscribed, or we didn't ever even subscribe
<span class="fc" id="L297">        assertEquals(0, subUnsubCount.get());</span>

<span class="fc" id="L299">        System.out.println(&quot;DONE sending unsubscribe ... now waiting&quot;);</span>
<span class="fc" id="L300">        System.out.println(&quot;Errors: &quot; + observer.errors());</span>
<span class="pc bpc" id="L301" title="1 of 2 branches missed.">        if (observer.errors().size() &gt; 0) {</span>
<span class="nc" id="L302">            observer.errors().get(0).printStackTrace();</span>
        }
<span class="fc" id="L304">        observer.assertNoErrors();</span>
<span class="fc" id="L305">    }</span>

    private Observable&lt;Long&gt; synchronousInterval() {
<span class="fc" id="L308">        return Observable.unsafeCreate(new ObservableSource&lt;Long&gt;() {</span>
            @Override
            public void subscribe(Observer&lt;? super Long&gt; observer) {
<span class="fc" id="L311">                final AtomicBoolean cancel = new AtomicBoolean();</span>
<span class="fc" id="L312">                observer.onSubscribe(Disposables.fromRunnable(new Runnable() {</span>
                    @Override
                    public void run() {
<span class="fc" id="L315">                        cancel.set(true);</span>
<span class="fc" id="L316">                    }</span>
                }));
                for (;;) {
<span class="fc bfc" id="L319" title="All 2 branches covered.">                    if (cancel.get()) {</span>
<span class="fc" id="L320">                        break;</span>
                    }
                    try {
<span class="nc" id="L323">                        Thread.sleep(100);</span>
<span class="fc" id="L324">                    } catch (InterruptedException e) {</span>
<span class="nc" id="L325">                    }</span>
<span class="fc" id="L326">                    observer.onNext(1L);</span>
                }
<span class="fc" id="L328">            }</span>
        });
    }

    @Test
    public void onlyFirstShouldSubscribeAndLastUnsubscribe() {
<span class="fc" id="L334">        final AtomicInteger subscriptionCount = new AtomicInteger();</span>
<span class="fc" id="L335">        final AtomicInteger unsubscriptionCount = new AtomicInteger();</span>
<span class="fc" id="L336">        Observable&lt;Integer&gt; o = Observable.unsafeCreate(new ObservableSource&lt;Integer&gt;() {</span>
            @Override
            public void subscribe(Observer&lt;? super Integer&gt; observer) {
<span class="fc" id="L339">                subscriptionCount.incrementAndGet();</span>
<span class="fc" id="L340">                observer.onSubscribe(Disposables.fromRunnable(new Runnable() {</span>
                    @Override
                    public void run() {
<span class="fc" id="L343">                            unsubscriptionCount.incrementAndGet();</span>
<span class="fc" id="L344">                    }</span>
                }));
<span class="fc" id="L346">            }</span>
        });
<span class="fc" id="L348">        Observable&lt;Integer&gt; refCounted = o.publish().refCount();</span>

<span class="fc" id="L350">        Disposable first = refCounted.subscribe();</span>
<span class="fc" id="L351">        assertEquals(1, subscriptionCount.get());</span>

<span class="fc" id="L353">        Disposable second = refCounted.subscribe();</span>
<span class="fc" id="L354">        assertEquals(1, subscriptionCount.get());</span>

<span class="fc" id="L356">        first.dispose();</span>
<span class="fc" id="L357">        assertEquals(0, unsubscriptionCount.get());</span>

<span class="fc" id="L359">        second.dispose();</span>
<span class="fc" id="L360">        assertEquals(1, unsubscriptionCount.get());</span>
<span class="fc" id="L361">    }</span>

    @Test
    public void testRefCount() {
<span class="fc" id="L365">        TestScheduler s = new TestScheduler();</span>
<span class="fc" id="L366">        Observable&lt;Long&gt; interval = Observable.interval(100, TimeUnit.MILLISECONDS, s).publish().refCount();</span>

        // subscribe list1
<span class="fc" id="L369">        final List&lt;Long&gt; list1 = new ArrayList&lt;Long&gt;();</span>
<span class="fc" id="L370">        Disposable d1 = interval.subscribe(new Consumer&lt;Long&gt;() {</span>
            @Override
            public void accept(Long t1) {
<span class="fc" id="L373">                list1.add(t1);</span>
<span class="fc" id="L374">            }</span>
        });

<span class="fc" id="L377">        s.advanceTimeBy(200, TimeUnit.MILLISECONDS);</span>

<span class="fc" id="L379">        assertEquals(2, list1.size());</span>
<span class="fc" id="L380">        assertEquals(0L, list1.get(0).longValue());</span>
<span class="fc" id="L381">        assertEquals(1L, list1.get(1).longValue());</span>

        // subscribe list2
<span class="fc" id="L384">        final List&lt;Long&gt; list2 = new ArrayList&lt;Long&gt;();</span>
<span class="fc" id="L385">        Disposable d2 = interval.subscribe(new Consumer&lt;Long&gt;() {</span>
            @Override
            public void accept(Long t1) {
<span class="fc" id="L388">                list2.add(t1);</span>
<span class="fc" id="L389">            }</span>
        });

<span class="fc" id="L392">        s.advanceTimeBy(300, TimeUnit.MILLISECONDS);</span>

        // list 1 should have 5 items
<span class="fc" id="L395">        assertEquals(5, list1.size());</span>
<span class="fc" id="L396">        assertEquals(2L, list1.get(2).longValue());</span>
<span class="fc" id="L397">        assertEquals(3L, list1.get(3).longValue());</span>
<span class="fc" id="L398">        assertEquals(4L, list1.get(4).longValue());</span>

        // list 2 should only have 3 items
<span class="fc" id="L401">        assertEquals(3, list2.size());</span>
<span class="fc" id="L402">        assertEquals(2L, list2.get(0).longValue());</span>
<span class="fc" id="L403">        assertEquals(3L, list2.get(1).longValue());</span>
<span class="fc" id="L404">        assertEquals(4L, list2.get(2).longValue());</span>

        // unsubscribe list1
<span class="fc" id="L407">        d1.dispose();</span>

        // advance further
<span class="fc" id="L410">        s.advanceTimeBy(300, TimeUnit.MILLISECONDS);</span>

        // list 1 should still have 5 items
<span class="fc" id="L413">        assertEquals(5, list1.size());</span>

        // list 2 should have 6 items
<span class="fc" id="L416">        assertEquals(6, list2.size());</span>
<span class="fc" id="L417">        assertEquals(5L, list2.get(3).longValue());</span>
<span class="fc" id="L418">        assertEquals(6L, list2.get(4).longValue());</span>
<span class="fc" id="L419">        assertEquals(7L, list2.get(5).longValue());</span>

        // unsubscribe list2
<span class="fc" id="L422">        d2.dispose();</span>

        // advance further
<span class="fc" id="L425">        s.advanceTimeBy(1000, TimeUnit.MILLISECONDS);</span>

        // subscribing a new one should start over because the source should have been unsubscribed
        // subscribe list3
<span class="fc" id="L429">        final List&lt;Long&gt; list3 = new ArrayList&lt;Long&gt;();</span>
<span class="fc" id="L430">        interval.subscribe(new Consumer&lt;Long&gt;() {</span>
            @Override
            public void accept(Long t1) {
<span class="fc" id="L433">                list3.add(t1);</span>
<span class="fc" id="L434">            }</span>
        });

<span class="fc" id="L437">        s.advanceTimeBy(200, TimeUnit.MILLISECONDS);</span>

<span class="fc" id="L439">        assertEquals(2, list3.size());</span>
<span class="fc" id="L440">        assertEquals(0L, list3.get(0).longValue());</span>
<span class="fc" id="L441">        assertEquals(1L, list3.get(1).longValue());</span>

<span class="fc" id="L443">    }</span>

    @Test
    public void testAlreadyUnsubscribedClient() {
<span class="fc" id="L447">        Observer&lt;Integer&gt; done = DisposingObserver.INSTANCE;</span>

<span class="fc" id="L449">        Observer&lt;Integer&gt; o = TestHelper.mockObserver();</span>

<span class="fc" id="L451">        Observable&lt;Integer&gt; result = Observable.just(1).publish().refCount();</span>

<span class="fc" id="L453">        result.subscribe(done);</span>

<span class="fc" id="L455">        result.subscribe(o);</span>

<span class="fc" id="L457">        verify(o).onNext(1);</span>
<span class="fc" id="L458">        verify(o).onComplete();</span>
<span class="fc" id="L459">        verify(o, never()).onError(any(Throwable.class));</span>
<span class="fc" id="L460">    }</span>

    @Test
    public void testAlreadyUnsubscribedInterleavesWithClient() {
<span class="fc" id="L464">        ReplaySubject&lt;Integer&gt; source = ReplaySubject.create();</span>

<span class="fc" id="L466">        Observer&lt;Integer&gt; done = DisposingObserver.INSTANCE;</span>

<span class="fc" id="L468">        Observer&lt;Integer&gt; o = TestHelper.mockObserver();</span>
<span class="fc" id="L469">        InOrder inOrder = inOrder(o);</span>

<span class="fc" id="L471">        Observable&lt;Integer&gt; result = source.publish().refCount();</span>

<span class="fc" id="L473">        result.subscribe(o);</span>

<span class="fc" id="L475">        source.onNext(1);</span>

<span class="fc" id="L477">        result.subscribe(done);</span>

<span class="fc" id="L479">        source.onNext(2);</span>
<span class="fc" id="L480">        source.onComplete();</span>

<span class="fc" id="L482">        inOrder.verify(o).onNext(1);</span>
<span class="fc" id="L483">        inOrder.verify(o).onNext(2);</span>
<span class="fc" id="L484">        inOrder.verify(o).onComplete();</span>
<span class="fc" id="L485">        verify(o, never()).onError(any(Throwable.class));</span>
<span class="fc" id="L486">    }</span>

    @Test
    public void testConnectDisconnectConnectAndSubjectState() {
<span class="fc" id="L490">        Observable&lt;Integer&gt; o1 = Observable.just(10);</span>
<span class="fc" id="L491">        Observable&lt;Integer&gt; o2 = Observable.just(20);</span>
<span class="fc" id="L492">        Observable&lt;Integer&gt; combined = Observable.combineLatest(o1, o2, new BiFunction&lt;Integer, Integer, Integer&gt;() {</span>
            @Override
            public Integer apply(Integer t1, Integer t2) {
<span class="fc" id="L495">                return t1 + t2;</span>
            }
        })
<span class="fc" id="L498">        .publish().refCount();</span>

<span class="fc" id="L500">        TestObserver&lt;Integer&gt; to1 = new TestObserver&lt;Integer&gt;();</span>
<span class="fc" id="L501">        TestObserver&lt;Integer&gt; to2 = new TestObserver&lt;Integer&gt;();</span>

<span class="fc" id="L503">        combined.subscribe(to1);</span>
<span class="fc" id="L504">        combined.subscribe(to2);</span>

<span class="fc" id="L506">        to1.assertTerminated();</span>
<span class="fc" id="L507">        to1.assertNoErrors();</span>
<span class="fc" id="L508">        to1.assertValue(30);</span>

<span class="fc" id="L510">        to2.assertTerminated();</span>
<span class="fc" id="L511">        to2.assertNoErrors();</span>
<span class="fc" id="L512">        to2.assertValue(30);</span>
<span class="fc" id="L513">    }</span>

    @Test(timeout = 10000)
    public void testUpstreamErrorAllowsRetry() throws InterruptedException {
<span class="fc" id="L517">        final AtomicInteger intervalSubscribed = new AtomicInteger();</span>
<span class="fc" id="L518">        Observable&lt;String&gt; interval =</span>
<span class="fc" id="L519">                Observable.interval(200, TimeUnit.MILLISECONDS)</span>
<span class="fc" id="L520">                        .doOnSubscribe(new Consumer&lt;Disposable&gt;() {</span>
                            @Override
                            public void accept(Disposable d) {
<span class="fc" id="L523">                                            System.out.println(&quot;Subscribing to interval &quot; + intervalSubscribed.incrementAndGet());</span>
<span class="fc" id="L524">                                    }</span>
                        }
                         )
<span class="fc" id="L527">                        .flatMap(new Function&lt;Long, Observable&lt;String&gt;&gt;() {</span>
                            @Override
                            public Observable&lt;String&gt; apply(Long t1) {
<span class="fc" id="L530">                                    return Observable.defer(new Callable&lt;Observable&lt;String&gt;&gt;() {</span>
                                        @Override
                                        public Observable&lt;String&gt; call() {
<span class="fc" id="L533">                                                return Observable.&lt;String&gt;error(new Exception(&quot;Some exception&quot;));</span>
                                        }
                                    });
                            }
                        })
<span class="fc" id="L538">                        .onErrorResumeNext(new Function&lt;Throwable, Observable&lt;String&gt;&gt;() {</span>
                            @Override
                            public Observable&lt;String&gt; apply(Throwable t1) {
<span class="fc" id="L541">                                    return Observable.&lt;String&gt;error(t1);</span>
                            }
                        })
<span class="fc" id="L544">                        .publish()</span>
<span class="fc" id="L545">                        .refCount();</span>

<span class="fc" id="L547">        interval</span>
<span class="fc" id="L548">                .doOnError(new Consumer&lt;Throwable&gt;() {</span>
                    @Override
                    public void accept(Throwable t1) {
<span class="fc" id="L551">                            System.out.println(&quot;Observer 1 onError: &quot; + t1);</span>
<span class="fc" id="L552">                    }</span>
                })
<span class="fc" id="L554">                .retry(5)</span>
<span class="fc" id="L555">                .subscribe(new Consumer&lt;String&gt;() {</span>
                    @Override
                    public void accept(String t1) {
<span class="nc" id="L558">                            System.out.println(&quot;Observer 1: &quot; + t1);</span>
<span class="nc" id="L559">                    }</span>
                });
<span class="fc" id="L561">        Thread.sleep(100);</span>
<span class="fc" id="L562">        interval</span>
<span class="fc" id="L563">        .doOnError(new Consumer&lt;Throwable&gt;() {</span>
            @Override
            public void accept(Throwable t1) {
<span class="fc" id="L566">                    System.out.println(&quot;Observer 2 onError: &quot; + t1);</span>
<span class="fc" id="L567">            }</span>
        })
<span class="fc" id="L569">        .retry(5)</span>
<span class="fc" id="L570">                .subscribe(new Consumer&lt;String&gt;() {</span>
                    @Override
                    public void accept(String t1) {
<span class="nc" id="L573">                            System.out.println(&quot;Observer 2: &quot; + t1);</span>
<span class="nc" id="L574">                    }</span>
                });

<span class="fc" id="L577">        Thread.sleep(1300);</span>

<span class="fc" id="L579">        System.out.println(intervalSubscribed.get());</span>
<span class="fc" id="L580">        assertEquals(6, intervalSubscribed.get());</span>
<span class="fc" id="L581">    }</span>

<span class="fc" id="L583">    private enum DisposingObserver implements Observer&lt;Integer&gt; {</span>
<span class="fc" id="L584">        INSTANCE;</span>

        @Override
        public void onSubscribe(Disposable d) {
<span class="fc" id="L588">            d.dispose();</span>
<span class="fc" id="L589">        }</span>

        @Override
        public void onNext(Integer t) {
<span class="nc" id="L593">        }</span>

        @Override
        public void onError(Throwable t) {
<span class="nc" id="L597">        }</span>

        @Override
        public void onComplete() {
<span class="nc" id="L601">        }</span>
    }

    @Test
    public void disposed() {
<span class="fc" id="L606">        TestHelper.checkDisposed(Observable.just(1).publish().refCount());</span>
<span class="fc" id="L607">    }</span>

    @Test
    public void noOpConnect() {
<span class="fc" id="L611">        final int[] calls = { 0 };</span>
<span class="fc" id="L612">        Observable&lt;Integer&gt; o = new ConnectableObservable&lt;Integer&gt;() {</span>
            @Override
            public void connect(Consumer&lt;? super Disposable&gt; connection) {
<span class="fc" id="L615">                calls[0]++;</span>
<span class="fc" id="L616">            }</span>

            @Override
            protected void subscribeActual(Observer&lt;? super Integer&gt; observer) {
<span class="fc" id="L620">                observer.onSubscribe(Disposables.disposed());</span>
<span class="fc" id="L621">            }</span>
<span class="fc" id="L622">        }.refCount();</span>

<span class="fc" id="L624">        o.test();</span>
<span class="fc" id="L625">        o.test();</span>

<span class="fc" id="L627">        assertEquals(1, calls[0]);</span>
<span class="fc" id="L628">    }</span>
    Observable&lt;Object&gt; source;

    @Test
    public void replayNoLeak() throws Exception {
<span class="fc" id="L633">        System.gc();</span>
<span class="fc" id="L634">        Thread.sleep(100);</span>

<span class="fc" id="L636">        long start = ManagementFactory.getMemoryMXBean().getHeapMemoryUsage().getUsed();</span>

<span class="fc" id="L638">        source = Observable.fromCallable(new Callable&lt;Object&gt;() {</span>
            @Override
            public Object call() throws Exception {
<span class="fc" id="L641">                return new byte[100 * 1000 * 1000];</span>
            }
        })
<span class="fc" id="L644">        .replay(1)</span>
<span class="fc" id="L645">        .refCount();</span>

<span class="fc" id="L647">        source.subscribe();</span>

<span class="fc" id="L649">        System.gc();</span>
<span class="fc" id="L650">        Thread.sleep(100);</span>

<span class="fc" id="L652">        long after = ManagementFactory.getMemoryMXBean().getHeapMemoryUsage().getUsed();</span>

<span class="fc" id="L654">        source = null;</span>
<span class="pc bpc" id="L655" title="1 of 2 branches missed.">        assertTrue(String.format(&quot;%,3d -&gt; %,3d%n&quot;, start, after), start + 20 * 1000 * 1000 &gt; after);</span>
<span class="fc" id="L656">    }</span>

    @Test
    public void replayNoLeak2() throws Exception {
<span class="fc" id="L660">        System.gc();</span>
<span class="fc" id="L661">        Thread.sleep(100);</span>

<span class="fc" id="L663">        long start = ManagementFactory.getMemoryMXBean().getHeapMemoryUsage().getUsed();</span>

<span class="fc" id="L665">        source = Observable.fromCallable(new Callable&lt;Object&gt;() {</span>
            @Override
            public Object call() throws Exception {
<span class="fc" id="L668">                return new byte[100 * 1000 * 1000];</span>
            }
<span class="fc" id="L670">        }).concatWith(Observable.never())</span>
<span class="fc" id="L671">        .replay(1)</span>
<span class="fc" id="L672">        .refCount();</span>

<span class="fc" id="L674">        Disposable d1 = source.subscribe();</span>
<span class="fc" id="L675">        Disposable d2 = source.subscribe();</span>

<span class="fc" id="L677">        d1.dispose();</span>
<span class="fc" id="L678">        d2.dispose();</span>

<span class="fc" id="L680">        d1 = null;</span>
<span class="fc" id="L681">        d2 = null;</span>

<span class="fc" id="L683">        System.gc();</span>
<span class="fc" id="L684">        Thread.sleep(100);</span>

<span class="fc" id="L686">        long after = ManagementFactory.getMemoryMXBean().getHeapMemoryUsage().getUsed();</span>

<span class="fc" id="L688">        source = null;</span>
<span class="pc bpc" id="L689" title="1 of 2 branches missed.">        assertTrue(String.format(&quot;%,3d -&gt; %,3d%n&quot;, start, after), start + 20 * 1000 * 1000 &gt; after);</span>
<span class="fc" id="L690">    }</span>

    static final class ExceptionData extends Exception {
        private static final long serialVersionUID = -6763898015338136119L;

        public final Object data;

<span class="fc" id="L697">        ExceptionData(Object data) {</span>
<span class="fc" id="L698">            this.data = data;</span>
<span class="fc" id="L699">        }</span>
    }

    @Test
    public void publishNoLeak() throws Exception {
<span class="fc" id="L704">        System.gc();</span>
<span class="fc" id="L705">        Thread.sleep(100);</span>

<span class="fc" id="L707">        long start = ManagementFactory.getMemoryMXBean().getHeapMemoryUsage().getUsed();</span>

<span class="fc" id="L709">        source = Observable.fromCallable(new Callable&lt;Object&gt;() {</span>
            @Override
            public Object call() throws Exception {
<span class="fc" id="L712">                throw new ExceptionData(new byte[100 * 1000 * 1000]);</span>
            }
        })
<span class="fc" id="L715">        .publish()</span>
<span class="fc" id="L716">        .refCount();</span>

<span class="fc" id="L718">        source.subscribe(Functions.emptyConsumer(), Functions.emptyConsumer());</span>

<span class="fc" id="L720">        System.gc();</span>
<span class="fc" id="L721">        Thread.sleep(100);</span>

<span class="fc" id="L723">        long after = ManagementFactory.getMemoryMXBean().getHeapMemoryUsage().getUsed();</span>

<span class="fc" id="L725">        source = null;</span>
<span class="pc bpc" id="L726" title="1 of 2 branches missed.">        assertTrue(String.format(&quot;%,3d -&gt; %,3d%n&quot;, start, after), start + 20 * 1000 * 1000 &gt; after);</span>
<span class="fc" id="L727">    }</span>

    @Test
    public void publishNoLeak2() throws Exception {
<span class="fc" id="L731">        System.gc();</span>
<span class="fc" id="L732">        Thread.sleep(100);</span>

<span class="fc" id="L734">        long start = ManagementFactory.getMemoryMXBean().getHeapMemoryUsage().getUsed();</span>

<span class="fc" id="L736">        source = Observable.fromCallable(new Callable&lt;Object&gt;() {</span>
            @Override
            public Object call() throws Exception {
<span class="fc" id="L739">                return new byte[100 * 1000 * 1000];</span>
            }
<span class="fc" id="L741">        }).concatWith(Observable.never())</span>
<span class="fc" id="L742">        .publish()</span>
<span class="fc" id="L743">        .refCount();</span>

<span class="fc" id="L745">        Disposable d1 = source.test();</span>
<span class="fc" id="L746">        Disposable d2 = source.test();</span>

<span class="fc" id="L748">        d1.dispose();</span>
<span class="fc" id="L749">        d2.dispose();</span>

<span class="fc" id="L751">        d1 = null;</span>
<span class="fc" id="L752">        d2 = null;</span>

<span class="fc" id="L754">        System.gc();</span>
<span class="fc" id="L755">        Thread.sleep(100);</span>

<span class="fc" id="L757">        long after = ManagementFactory.getMemoryMXBean().getHeapMemoryUsage().getUsed();</span>

<span class="fc" id="L759">        source = null;</span>
<span class="pc bpc" id="L760" title="1 of 2 branches missed.">        assertTrue(String.format(&quot;%,3d -&gt; %,3d%n&quot;, start, after), start + 20 * 1000 * 1000 &gt; after);</span>
<span class="fc" id="L761">    }</span>

    @Test
    public void replayIsUnsubscribed() {
<span class="fc" id="L765">        ConnectableObservable&lt;Integer&gt; co = Observable.just(1).concatWith(Observable.&lt;Integer&gt;never())</span>
<span class="fc" id="L766">        .replay();</span>

<span class="pc bpc" id="L768" title="1 of 2 branches missed.">        if (co instanceof Disposable) {</span>
<span class="nc" id="L769">            assertTrue(((Disposable)co).isDisposed());</span>

<span class="nc" id="L771">            Disposable connection = co.connect();</span>

<span class="nc" id="L773">            assertFalse(((Disposable)co).isDisposed());</span>

<span class="nc" id="L775">            connection.dispose();</span>

<span class="nc" id="L777">            assertTrue(((Disposable)co).isDisposed());</span>
        }
<span class="fc" id="L779">    }</span>

<span class="fc" id="L781">    static final class BadObservableSubscribe extends ConnectableObservable&lt;Object&gt; {</span>

        @Override
        public void connect(Consumer&lt;? super Disposable&gt; connection) {
            try {
<span class="nc" id="L786">                connection.accept(Disposables.empty());</span>
<span class="nc" id="L787">            } catch (Throwable ex) {</span>
<span class="nc" id="L788">                throw ExceptionHelper.wrapOrThrow(ex);</span>
<span class="nc" id="L789">            }</span>
<span class="nc" id="L790">        }</span>

        @Override
        protected void subscribeActual(Observer&lt;? super Object&gt; observer) {
<span class="fc" id="L794">            throw new TestException(&quot;subscribeActual&quot;);</span>
        }
    }

<span class="fc" id="L798">    static final class BadObservableDispose extends ConnectableObservable&lt;Object&gt; implements Disposable {</span>

        @Override
        public void dispose() {
<span class="fc" id="L802">            throw new TestException(&quot;dispose&quot;);</span>
        }

        @Override
        public boolean isDisposed() {
<span class="nc" id="L807">            return false;</span>
        }

        @Override
        public void connect(Consumer&lt;? super Disposable&gt; connection) {
            try {
<span class="fc" id="L813">                connection.accept(Disposables.empty());</span>
<span class="nc" id="L814">            } catch (Throwable ex) {</span>
<span class="nc" id="L815">                throw ExceptionHelper.wrapOrThrow(ex);</span>
<span class="fc" id="L816">            }</span>
<span class="fc" id="L817">        }</span>

        @Override
        protected void subscribeActual(Observer&lt;? super Object&gt; observer) {
<span class="fc" id="L821">            observer.onSubscribe(Disposables.empty());</span>
<span class="fc" id="L822">        }</span>
    }

<span class="fc" id="L825">    static final class BadObservableConnect extends ConnectableObservable&lt;Object&gt; {</span>

        @Override
        public void connect(Consumer&lt;? super Disposable&gt; connection) {
<span class="fc" id="L829">            throw new TestException(&quot;connect&quot;);</span>
        }

        @Override
        protected void subscribeActual(Observer&lt;? super Object&gt; observer) {
<span class="fc" id="L834">            observer.onSubscribe(Disposables.empty());</span>
<span class="fc" id="L835">        }</span>
    }

    @Test
    public void badSourceSubscribe() {
<span class="fc" id="L840">        BadObservableSubscribe bo = new BadObservableSubscribe();</span>

        try {
<span class="fc" id="L843">            bo.refCount()</span>
<span class="nc" id="L844">            .test();</span>
<span class="nc" id="L845">            fail(&quot;Should have thrown&quot;);</span>
<span class="fc" id="L846">        } catch (NullPointerException ex) {</span>
<span class="fc" id="L847">            assertTrue(ex.getCause() instanceof TestException);</span>
<span class="nc" id="L848">        }</span>
<span class="fc" id="L849">    }</span>

    @Test
    public void badSourceDispose() {
<span class="fc" id="L853">        BadObservableDispose bo = new BadObservableDispose();</span>

        try {
<span class="fc" id="L856">            bo.refCount()</span>
<span class="fc" id="L857">            .test()</span>
<span class="nc" id="L858">            .cancel();</span>
<span class="nc" id="L859">            fail(&quot;Should have thrown&quot;);</span>
<span class="fc" id="L860">        } catch (TestException expected) {</span>
<span class="nc" id="L861">        }</span>
<span class="fc" id="L862">    }</span>

    @Test
    public void badSourceConnect() {
<span class="fc" id="L866">        BadObservableConnect bo = new BadObservableConnect();</span>

        try {
<span class="fc" id="L869">            bo.refCount()</span>
<span class="nc" id="L870">            .test();</span>
<span class="nc" id="L871">            fail(&quot;Should have thrown&quot;);</span>
<span class="fc" id="L872">        } catch (NullPointerException ex) {</span>
<span class="fc" id="L873">            assertTrue(ex.getCause() instanceof TestException);</span>
<span class="nc" id="L874">        }</span>
<span class="fc" id="L875">    }</span>

<span class="fc" id="L877">    static final class BadObservableSubscribe2 extends ConnectableObservable&lt;Object&gt; {</span>

        int count;

        @Override
        public void connect(Consumer&lt;? super Disposable&gt; connection) {
            try {
<span class="fc" id="L884">                connection.accept(Disposables.empty());</span>
<span class="nc" id="L885">            } catch (Throwable ex) {</span>
<span class="nc" id="L886">                throw ExceptionHelper.wrapOrThrow(ex);</span>
<span class="fc" id="L887">            }</span>
<span class="fc" id="L888">        }</span>

        @Override
        protected void subscribeActual(Observer&lt;? super Object&gt; observer) {
<span class="fc bfc" id="L892" title="All 2 branches covered.">            if (++count == 1) {</span>
<span class="fc" id="L893">                observer.onSubscribe(Disposables.empty());</span>
            } else {
<span class="fc" id="L895">                throw new TestException(&quot;subscribeActual&quot;);</span>
            }
<span class="fc" id="L897">        }</span>
    }

    @Test
    public void badSourceSubscribe2() {
<span class="fc" id="L902">        BadObservableSubscribe2 bo = new BadObservableSubscribe2();</span>

<span class="fc" id="L904">        Observable&lt;Object&gt; o = bo.refCount();</span>
<span class="fc" id="L905">        o.test();</span>
        try {
<span class="nc" id="L907">            o.test();</span>
<span class="nc" id="L908">            fail(&quot;Should have thrown&quot;);</span>
<span class="fc" id="L909">        } catch (NullPointerException ex) {</span>
<span class="fc" id="L910">            assertTrue(ex.getCause() instanceof TestException);</span>
<span class="nc" id="L911">        }</span>
<span class="fc" id="L912">    }</span>

<span class="fc" id="L914">    static final class BadObservableConnect2 extends ConnectableObservable&lt;Object&gt;</span>
    implements Disposable {

        @Override
        public void connect(Consumer&lt;? super Disposable&gt; connection) {
            try {
<span class="nc" id="L920">                connection.accept(Disposables.empty());</span>
<span class="nc" id="L921">            } catch (Throwable ex) {</span>
<span class="nc" id="L922">                throw ExceptionHelper.wrapOrThrow(ex);</span>
<span class="nc" id="L923">            }</span>
<span class="nc" id="L924">        }</span>

        @Override
        protected void subscribeActual(Observer&lt;? super Object&gt; observer) {
<span class="fc" id="L928">            observer.onSubscribe(Disposables.empty());</span>
<span class="nc" id="L929">            observer.onComplete();</span>
<span class="nc" id="L930">        }</span>

        @Override
        public void dispose() {
<span class="fc" id="L934">            throw new TestException(&quot;dispose&quot;);</span>
        }

        @Override
        public boolean isDisposed() {
<span class="nc" id="L939">            return false;</span>
        }
    }

    @Test
    public void badSourceCompleteDisconnect() {
<span class="fc" id="L945">        BadObservableConnect2 bo = new BadObservableConnect2();</span>

        try {
<span class="fc" id="L948">            bo.refCount()</span>
<span class="nc" id="L949">            .test();</span>
<span class="nc" id="L950">            fail(&quot;Should have thrown&quot;);</span>
<span class="fc" id="L951">        } catch (NullPointerException ex) {</span>
<span class="fc" id="L952">            assertTrue(ex.getCause() instanceof TestException);</span>
<span class="nc" id="L953">        }</span>
<span class="fc" id="L954">    }</span>

    @Test(timeout = 7500)
    public void blockingSourceAsnycCancel() throws Exception {
<span class="fc" id="L958">        BehaviorSubject&lt;Integer&gt; bs = BehaviorSubject.createDefault(1);</span>

<span class="fc" id="L960">        Observable&lt;Integer&gt; o = bs</span>
<span class="fc" id="L961">        .replay(1)</span>
<span class="fc" id="L962">        .refCount();</span>

<span class="fc" id="L964">        o.subscribe();</span>

<span class="fc" id="L966">        final AtomicBoolean interrupted = new AtomicBoolean();</span>

<span class="fc" id="L968">        o.switchMap(new Function&lt;Integer, ObservableSource&lt;? extends Object&gt;&gt;() {</span>
            @Override
            public ObservableSource&lt;? extends Object&gt; apply(Integer v) throws Exception {
<span class="fc" id="L971">                return Observable.create(new ObservableOnSubscribe&lt;Object&gt;() {</span>
                    @Override
                    public void subscribe(ObservableEmitter&lt;Object&gt; emitter) throws Exception {
<span class="fc bfc" id="L974" title="All 2 branches covered.">                        while (!emitter.isDisposed()) {</span>
<span class="fc" id="L975">                            Thread.sleep(100);</span>
                        }
<span class="fc" id="L977">                        interrupted.set(true);</span>
<span class="fc" id="L978">                    }</span>
                });
            }
        })
<span class="fc" id="L982">        .take(500, TimeUnit.MILLISECONDS)</span>
<span class="fc" id="L983">        .test()</span>
<span class="fc" id="L984">        .awaitDone(5, TimeUnit.SECONDS)</span>
<span class="fc" id="L985">        .assertResult();</span>

<span class="fc" id="L987">        assertTrue(interrupted.get());</span>
<span class="fc" id="L988">    }</span>

    @Test
    public void byCount() {
<span class="fc" id="L992">        final int[] subscriptions = { 0 };</span>

<span class="fc" id="L994">        Observable&lt;Integer&gt; source = Observable.range(1, 5)</span>
<span class="fc" id="L995">        .doOnSubscribe(new Consumer&lt;Disposable&gt;() {</span>
            @Override
            public void accept(Disposable d) throws Exception {
<span class="fc" id="L998">                subscriptions[0]++;</span>
<span class="fc" id="L999">            }</span>
        })
<span class="fc" id="L1001">        .publish()</span>
<span class="fc" id="L1002">        .refCount(2);</span>

<span class="fc bfc" id="L1004" title="All 2 branches covered.">        for (int i = 0; i &lt; 3; i++) {</span>
<span class="fc" id="L1005">            TestObserver&lt;Integer&gt; to1 = source.test();</span>

<span class="fc" id="L1007">            to1.assertEmpty();</span>

<span class="fc" id="L1009">            TestObserver&lt;Integer&gt; to2 = source.test();</span>

<span class="fc" id="L1011">            to1.assertResult(1, 2, 3, 4, 5);</span>
<span class="fc" id="L1012">            to2.assertResult(1, 2, 3, 4, 5);</span>
        }

<span class="fc" id="L1015">        assertEquals(3, subscriptions[0]);</span>
<span class="fc" id="L1016">    }</span>

    @Test
    public void resubscribeBeforeTimeout() throws Exception {
<span class="fc" id="L1020">        final int[] subscriptions = { 0 };</span>

<span class="fc" id="L1022">        PublishSubject&lt;Integer&gt; ps = PublishSubject.create();</span>

<span class="fc" id="L1024">        Observable&lt;Integer&gt; source = ps</span>
<span class="fc" id="L1025">        .doOnSubscribe(new Consumer&lt;Disposable&gt;() {</span>
            @Override
            public void accept(Disposable d) throws Exception {
<span class="fc" id="L1028">                subscriptions[0]++;</span>
<span class="fc" id="L1029">            }</span>
        })
<span class="fc" id="L1031">        .publish()</span>
<span class="fc" id="L1032">        .refCount(500, TimeUnit.MILLISECONDS);</span>

<span class="fc" id="L1034">        TestObserver&lt;Integer&gt; to1 = source.test();</span>

<span class="fc" id="L1036">        assertEquals(1, subscriptions[0]);</span>

<span class="fc" id="L1038">        to1.cancel();</span>

<span class="fc" id="L1040">        Thread.sleep(100);</span>

<span class="fc" id="L1042">        to1 = source.test();</span>

<span class="fc" id="L1044">        assertEquals(1, subscriptions[0]);</span>

<span class="fc" id="L1046">        Thread.sleep(500);</span>

<span class="fc" id="L1048">        assertEquals(1, subscriptions[0]);</span>

<span class="fc" id="L1050">        ps.onNext(1);</span>
<span class="fc" id="L1051">        ps.onNext(2);</span>
<span class="fc" id="L1052">        ps.onNext(3);</span>
<span class="fc" id="L1053">        ps.onNext(4);</span>
<span class="fc" id="L1054">        ps.onNext(5);</span>
<span class="fc" id="L1055">        ps.onComplete();</span>

<span class="fc" id="L1057">        to1</span>
<span class="fc" id="L1058">        .assertResult(1, 2, 3, 4, 5);</span>
<span class="fc" id="L1059">    }</span>

    @Test
    public void letitTimeout() throws Exception {
<span class="fc" id="L1063">        final int[] subscriptions = { 0 };</span>

<span class="fc" id="L1065">        PublishSubject&lt;Integer&gt; ps = PublishSubject.create();</span>

<span class="fc" id="L1067">        Observable&lt;Integer&gt; source = ps</span>
<span class="fc" id="L1068">        .doOnSubscribe(new Consumer&lt;Disposable&gt;() {</span>
            @Override
            public void accept(Disposable d) throws Exception {
<span class="fc" id="L1071">                subscriptions[0]++;</span>
<span class="fc" id="L1072">            }</span>
        })
<span class="fc" id="L1074">        .publish()</span>
<span class="fc" id="L1075">        .refCount(1, 100, TimeUnit.MILLISECONDS);</span>

<span class="fc" id="L1077">        TestObserver&lt;Integer&gt; to1 = source.test();</span>

<span class="fc" id="L1079">        assertEquals(1, subscriptions[0]);</span>

<span class="fc" id="L1081">        to1.cancel();</span>

<span class="fc" id="L1083">        assertTrue(ps.hasObservers());</span>

<span class="fc" id="L1085">        Thread.sleep(200);</span>

<span class="fc" id="L1087">        assertFalse(ps.hasObservers());</span>
<span class="fc" id="L1088">    }</span>

    @Test
    public void error() {
<span class="fc" id="L1092">        Observable.&lt;Integer&gt;error(new IOException())</span>
<span class="fc" id="L1093">        .publish()</span>
<span class="fc" id="L1094">        .refCount(500, TimeUnit.MILLISECONDS)</span>
<span class="fc" id="L1095">        .test()</span>
<span class="fc" id="L1096">        .assertFailure(IOException.class);</span>
<span class="fc" id="L1097">    }</span>

    @Test
    public void comeAndGo() {
<span class="fc" id="L1101">        PublishSubject&lt;Integer&gt; ps = PublishSubject.create();</span>

<span class="fc" id="L1103">        Observable&lt;Integer&gt; source = ps</span>
<span class="fc" id="L1104">        .publish()</span>
<span class="fc" id="L1105">        .refCount(1);</span>

<span class="fc" id="L1107">        TestObserver&lt;Integer&gt; to1 = source.test();</span>

<span class="fc" id="L1109">        assertTrue(ps.hasObservers());</span>

<span class="fc bfc" id="L1111" title="All 2 branches covered.">        for (int i = 0; i &lt; 3; i++) {</span>
<span class="fc" id="L1112">            TestObserver&lt;Integer&gt; to2 = source.test();</span>
<span class="fc" id="L1113">            to1.cancel();</span>
<span class="fc" id="L1114">            to1 = to2;</span>
        }

<span class="fc" id="L1117">        to1.cancel();</span>

<span class="fc" id="L1119">        assertFalse(ps.hasObservers());</span>
<span class="fc" id="L1120">    }</span>

    @Test
    public void unsubscribeSubscribeRace() {
<span class="fc bfc" id="L1124" title="All 2 branches covered.">        for (int i = 0; i &lt; 1000; i++) {</span>

<span class="fc" id="L1126">            final Observable&lt;Integer&gt; source = Observable.range(1, 5)</span>
<span class="fc" id="L1127">                    .replay()</span>
<span class="fc" id="L1128">                    .refCount(1)</span>
                    ;

<span class="fc" id="L1131">            final TestObserver&lt;Integer&gt; to1 = source.test();</span>

<span class="fc" id="L1133">            final TestObserver&lt;Integer&gt; to2 = new TestObserver&lt;Integer&gt;();</span>

<span class="fc" id="L1135">            Runnable r1 = new Runnable() {</span>
                @Override
                public void run() {
<span class="fc" id="L1138">                    to1.cancel();</span>
<span class="fc" id="L1139">                }</span>
            };

<span class="fc" id="L1142">            Runnable r2 = new Runnable() {</span>
                @Override
                public void run() {
<span class="fc" id="L1145">                    source.subscribe(to2);</span>
<span class="fc" id="L1146">                }</span>
            };

<span class="fc" id="L1149">            TestHelper.race(r1, r2, Schedulers.single());</span>

<span class="fc" id="L1151">            to2</span>
<span class="fc" id="L1152">            .withTag(&quot;Round: &quot; + i)</span>
<span class="fc" id="L1153">            .assertResult(1, 2, 3, 4, 5);</span>
        }
<span class="fc" id="L1155">    }</span>

<span class="fc" id="L1157">    static final class BadObservableDoubleOnX extends ConnectableObservable&lt;Object&gt;</span>
    implements Disposable {

        @Override
        public void connect(Consumer&lt;? super Disposable&gt; connection) {
            try {
<span class="fc" id="L1163">                connection.accept(Disposables.empty());</span>
<span class="nc" id="L1164">            } catch (Throwable ex) {</span>
<span class="nc" id="L1165">                throw ExceptionHelper.wrapOrThrow(ex);</span>
<span class="fc" id="L1166">            }</span>
<span class="fc" id="L1167">        }</span>

        @Override
        protected void subscribeActual(Observer&lt;? super Object&gt; observer) {
<span class="fc" id="L1171">            observer.onSubscribe(Disposables.empty());</span>
<span class="fc" id="L1172">            observer.onSubscribe(Disposables.empty());</span>
<span class="fc" id="L1173">            observer.onComplete();</span>
<span class="fc" id="L1174">            observer.onComplete();</span>
<span class="fc" id="L1175">            observer.onError(new TestException());</span>
<span class="fc" id="L1176">        }</span>

        @Override
        public void dispose() {
<span class="fc" id="L1180">        }</span>

        @Override
        public boolean isDisposed() {
<span class="nc" id="L1184">            return false;</span>
        }
    }

    @Test
    public void doubleOnX() {
<span class="fc" id="L1190">        List&lt;Throwable&gt; errors = TestHelper.trackPluginErrors();</span>
        try {
<span class="fc" id="L1192">            new BadObservableDoubleOnX()</span>
<span class="fc" id="L1193">            .refCount()</span>
<span class="fc" id="L1194">            .test()</span>
<span class="fc" id="L1195">            .assertResult();</span>

<span class="fc" id="L1197">            TestHelper.assertError(errors, 0, ProtocolViolationException.class);</span>
<span class="fc" id="L1198">            TestHelper.assertUndeliverable(errors, 1, TestException.class);</span>
        } finally {
<span class="fc" id="L1200">            RxJavaPlugins.reset();</span>
        }
<span class="fc" id="L1202">    }</span>

    @Test
    public void doubleOnXCount() {
<span class="fc" id="L1206">        List&lt;Throwable&gt; errors = TestHelper.trackPluginErrors();</span>
        try {
<span class="fc" id="L1208">            new BadObservableDoubleOnX()</span>
<span class="fc" id="L1209">            .refCount(1)</span>
<span class="fc" id="L1210">            .test()</span>
<span class="fc" id="L1211">            .assertResult();</span>

<span class="fc" id="L1213">            TestHelper.assertError(errors, 0, ProtocolViolationException.class);</span>
<span class="fc" id="L1214">            TestHelper.assertUndeliverable(errors, 1, TestException.class);</span>
        } finally {
<span class="fc" id="L1216">            RxJavaPlugins.reset();</span>
        }
<span class="fc" id="L1218">    }</span>

    @Test
    public void doubleOnXTime() {
<span class="fc" id="L1222">        List&lt;Throwable&gt; errors = TestHelper.trackPluginErrors();</span>
        try {
<span class="fc" id="L1224">            new BadObservableDoubleOnX()</span>
<span class="fc" id="L1225">            .refCount(5, TimeUnit.SECONDS, Schedulers.single())</span>
<span class="fc" id="L1226">            .test()</span>
<span class="fc" id="L1227">            .assertResult();</span>

<span class="fc" id="L1229">            TestHelper.assertError(errors, 0, ProtocolViolationException.class);</span>
<span class="fc" id="L1230">            TestHelper.assertUndeliverable(errors, 1, TestException.class);</span>
        } finally {
<span class="fc" id="L1232">            RxJavaPlugins.reset();</span>
        }
<span class="fc" id="L1234">    }</span>

    @Test
    public void cancelTerminateStateExclusion() {
<span class="fc" id="L1238">        ObservableRefCount&lt;Object&gt; o = (ObservableRefCount&lt;Object&gt;)PublishSubject.create()</span>
<span class="fc" id="L1239">        .publish()</span>
<span class="fc" id="L1240">        .refCount();</span>

<span class="fc" id="L1242">        o.cancel(null);</span>

<span class="fc" id="L1244">        o.cancel(new RefConnection(o));</span>

<span class="fc" id="L1246">        RefConnection rc = new RefConnection(o);</span>
<span class="fc" id="L1247">        o.connection = null;</span>
<span class="fc" id="L1248">        rc.subscriberCount = 0;</span>
<span class="fc" id="L1249">        o.timeout(rc);</span>

<span class="fc" id="L1251">        rc.subscriberCount = 1;</span>
<span class="fc" id="L1252">        o.timeout(rc);</span>

<span class="fc" id="L1254">        o.connection = rc;</span>
<span class="fc" id="L1255">        o.timeout(rc);</span>

<span class="fc" id="L1257">        rc.subscriberCount = 0;</span>
<span class="fc" id="L1258">        o.timeout(rc);</span>

        // -------------------

<span class="fc" id="L1262">        rc.subscriberCount = 2;</span>
<span class="fc" id="L1263">        rc.connected = false;</span>
<span class="fc" id="L1264">        o.connection = rc;</span>
<span class="fc" id="L1265">        o.cancel(rc);</span>

<span class="fc" id="L1267">        rc.subscriberCount = 1;</span>
<span class="fc" id="L1268">        rc.connected = false;</span>
<span class="fc" id="L1269">        o.connection = rc;</span>
<span class="fc" id="L1270">        o.cancel(rc);</span>

<span class="fc" id="L1272">        rc.subscriberCount = 2;</span>
<span class="fc" id="L1273">        rc.connected = true;</span>
<span class="fc" id="L1274">        o.connection = rc;</span>
<span class="fc" id="L1275">        o.cancel(rc);</span>

<span class="fc" id="L1277">        rc.subscriberCount = 1;</span>
<span class="fc" id="L1278">        rc.connected = true;</span>
<span class="fc" id="L1279">        o.connection = rc;</span>
<span class="fc" id="L1280">        o.cancel(rc);</span>

<span class="fc" id="L1282">        o.connection = rc;</span>
<span class="fc" id="L1283">        o.cancel(new RefConnection(o));</span>
<span class="fc" id="L1284">    }</span>

    @Test
    public void replayRefCountShallBeThreadSafe() {
<span class="fc bfc" id="L1288" title="All 2 branches covered.">        for (int i = 0; i &lt; TestHelper.RACE_LONG_LOOPS; i++) {</span>
<span class="fc" id="L1289">            Observable&lt;Integer&gt; observable = Observable.just(1).replay(1).refCount();</span>

<span class="fc" id="L1291">            TestObserver&lt;Integer&gt; observer1 = observable</span>
<span class="fc" id="L1292">                    .subscribeOn(Schedulers.io())</span>
<span class="fc" id="L1293">                    .test();</span>

<span class="fc" id="L1295">            TestObserver&lt;Integer&gt; observer2 = observable</span>
<span class="fc" id="L1296">                    .subscribeOn(Schedulers.io())</span>
<span class="fc" id="L1297">                    .test();</span>

<span class="fc" id="L1299">            observer1</span>
<span class="fc" id="L1300">            .withTag(&quot;&quot; + i)</span>
<span class="fc" id="L1301">            .awaitDone(5, TimeUnit.SECONDS)</span>
<span class="fc" id="L1302">            .assertResult(1);</span>

<span class="fc" id="L1304">            observer2</span>
<span class="fc" id="L1305">            .withTag(&quot;&quot; + i)</span>
<span class="fc" id="L1306">            .awaitDone(5, TimeUnit.SECONDS)</span>
<span class="fc" id="L1307">            .assertResult(1);</span>
        }
<span class="fc" id="L1309">    }</span>

<span class="fc" id="L1311">    static final class TestConnectableObservable&lt;T&gt; extends ConnectableObservable&lt;T&gt;</span>
    implements Disposable {

        volatile boolean disposed;

        @Override
        public void dispose() {
<span class="fc" id="L1318">            disposed = true;</span>
<span class="fc" id="L1319">        }</span>

        @Override
        public boolean isDisposed() {
<span class="fc" id="L1323">            return disposed;</span>
        }

        @Override
        public void connect(Consumer&lt;? super Disposable&gt; connection) {
            // not relevant
<span class="nc" id="L1329">        }</span>

        @Override
        protected void subscribeActual(Observer&lt;? super T&gt; observer) {
            // not relevant
<span class="nc" id="L1334">        }</span>
    }

    @Test
    public void timeoutDisposesSource() {
<span class="fc" id="L1339">        ObservableRefCount&lt;Object&gt; o = (ObservableRefCount&lt;Object&gt;)new TestConnectableObservable&lt;Object&gt;().refCount();</span>

<span class="fc" id="L1341">        RefConnection rc = new RefConnection(o);</span>
<span class="fc" id="L1342">        o.connection = rc;</span>

<span class="fc" id="L1344">        o.timeout(rc);</span>

<span class="fc" id="L1346">        assertTrue(((Disposable)o.source).isDisposed());</span>
<span class="fc" id="L1347">    }</span>

    @Test
    public void disconnectBeforeConnect() {
<span class="fc" id="L1351">        BehaviorSubject&lt;Integer&gt; subject = BehaviorSubject.create();</span>

<span class="fc" id="L1353">        Observable&lt;Integer&gt; observable = subject</span>
<span class="fc" id="L1354">                .replay(1)</span>
<span class="fc" id="L1355">                .refCount();</span>

<span class="fc" id="L1357">        observable.takeUntil(Observable.just(1)).test();</span>

<span class="fc" id="L1359">        subject.onNext(2);</span>

<span class="fc" id="L1361">        observable.take(1).test().assertResult(2);</span>
<span class="fc" id="L1362">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>