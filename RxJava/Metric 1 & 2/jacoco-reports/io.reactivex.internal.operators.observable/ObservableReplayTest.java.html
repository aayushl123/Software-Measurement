<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ObservableReplayTest.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">RxJava_2_x$Unnamed.exec</a> &gt; <a href="index.source.html" class="el_package">io.reactivex.internal.operators.observable</a> &gt; <span class="el_source">ObservableReplayTest.java</span></div><h1>ObservableReplayTest.java</h1><pre class="source lang-java linenums">/**
 * Copyright (c) 2016-present, RxJava Contributors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is
 * distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
 * the License for the specific language governing permissions and limitations under the License.
 */

package io.reactivex.internal.operators.observable;

import static org.junit.Assert.*;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;

import java.lang.management.*;
import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.*;

import org.junit.*;
import org.mockito.InOrder;

import io.reactivex.*;
import io.reactivex.Observable;
import io.reactivex.Observer;
import io.reactivex.Scheduler.Worker;
import io.reactivex.annotations.NonNull;
import io.reactivex.disposables.*;
import io.reactivex.exceptions.TestException;
import io.reactivex.functions.*;
import io.reactivex.internal.functions.Functions;
import io.reactivex.internal.fuseable.HasUpstreamObservableSource;
import io.reactivex.internal.operators.observable.ObservableReplay.*;
import io.reactivex.observables.ConnectableObservable;
import io.reactivex.observers.TestObserver;
import io.reactivex.plugins.RxJavaPlugins;
import io.reactivex.schedulers.*;
import io.reactivex.subjects.PublishSubject;

<span class="fc" id="L45">public class ObservableReplayTest {</span>
    @Test
    public void testBufferedReplay() {
<span class="fc" id="L48">        PublishSubject&lt;Integer&gt; source = PublishSubject.create();</span>

<span class="fc" id="L50">        ConnectableObservable&lt;Integer&gt; co = source.replay(3);</span>
<span class="fc" id="L51">        co.connect();</span>

        {
<span class="fc" id="L54">            Observer&lt;Object&gt; observer1 = TestHelper.mockObserver();</span>
<span class="fc" id="L55">            InOrder inOrder = inOrder(observer1);</span>

<span class="fc" id="L57">            co.subscribe(observer1);</span>

<span class="fc" id="L59">            source.onNext(1);</span>
<span class="fc" id="L60">            source.onNext(2);</span>
<span class="fc" id="L61">            source.onNext(3);</span>

<span class="fc" id="L63">            inOrder.verify(observer1, times(1)).onNext(1);</span>
<span class="fc" id="L64">            inOrder.verify(observer1, times(1)).onNext(2);</span>
<span class="fc" id="L65">            inOrder.verify(observer1, times(1)).onNext(3);</span>

<span class="fc" id="L67">            source.onNext(4);</span>
<span class="fc" id="L68">            source.onComplete();</span>
<span class="fc" id="L69">            inOrder.verify(observer1, times(1)).onNext(4);</span>
<span class="fc" id="L70">            inOrder.verify(observer1, times(1)).onComplete();</span>
<span class="fc" id="L71">            inOrder.verifyNoMoreInteractions();</span>
<span class="fc" id="L72">            verify(observer1, never()).onError(any(Throwable.class));</span>

        }

        {
<span class="fc" id="L77">            Observer&lt;Object&gt; observer1 = TestHelper.mockObserver();</span>
<span class="fc" id="L78">            InOrder inOrder = inOrder(observer1);</span>

<span class="fc" id="L80">            co.subscribe(observer1);</span>

<span class="fc" id="L82">            inOrder.verify(observer1, times(1)).onNext(2);</span>
<span class="fc" id="L83">            inOrder.verify(observer1, times(1)).onNext(3);</span>
<span class="fc" id="L84">            inOrder.verify(observer1, times(1)).onNext(4);</span>
<span class="fc" id="L85">            inOrder.verify(observer1, times(1)).onComplete();</span>
<span class="fc" id="L86">            inOrder.verifyNoMoreInteractions();</span>
<span class="fc" id="L87">            verify(observer1, never()).onError(any(Throwable.class));</span>
        }
<span class="fc" id="L89">    }</span>

    @Test
    public void testBufferedWindowReplay() {
<span class="fc" id="L93">        PublishSubject&lt;Integer&gt; source = PublishSubject.create();</span>
<span class="fc" id="L94">        TestScheduler scheduler = new TestScheduler();</span>
<span class="fc" id="L95">        ConnectableObservable&lt;Integer&gt; co = source.replay(3, 100, TimeUnit.MILLISECONDS, scheduler);</span>
<span class="fc" id="L96">        co.connect();</span>

        {
<span class="fc" id="L99">            Observer&lt;Object&gt; observer1 = TestHelper.mockObserver();</span>
<span class="fc" id="L100">            InOrder inOrder = inOrder(observer1);</span>

<span class="fc" id="L102">            co.subscribe(observer1);</span>

<span class="fc" id="L104">            source.onNext(1);</span>
<span class="fc" id="L105">            scheduler.advanceTimeBy(10, TimeUnit.MILLISECONDS);</span>
<span class="fc" id="L106">            source.onNext(2);</span>
<span class="fc" id="L107">            scheduler.advanceTimeBy(10, TimeUnit.MILLISECONDS);</span>
<span class="fc" id="L108">            source.onNext(3);</span>
<span class="fc" id="L109">            scheduler.advanceTimeBy(10, TimeUnit.MILLISECONDS);</span>

<span class="fc" id="L111">            inOrder.verify(observer1, times(1)).onNext(1);</span>
<span class="fc" id="L112">            inOrder.verify(observer1, times(1)).onNext(2);</span>
<span class="fc" id="L113">            inOrder.verify(observer1, times(1)).onNext(3);</span>

<span class="fc" id="L115">            source.onNext(4);</span>
<span class="fc" id="L116">            source.onNext(5);</span>
<span class="fc" id="L117">            scheduler.advanceTimeBy(90, TimeUnit.MILLISECONDS);</span>

<span class="fc" id="L119">            inOrder.verify(observer1, times(1)).onNext(4);</span>

<span class="fc" id="L121">            inOrder.verify(observer1, times(1)).onNext(5);</span>

<span class="fc" id="L123">            inOrder.verifyNoMoreInteractions();</span>
<span class="fc" id="L124">            verify(observer1, never()).onError(any(Throwable.class));</span>

        }

        {
<span class="fc" id="L129">            Observer&lt;Object&gt; observer1 = TestHelper.mockObserver();</span>
<span class="fc" id="L130">            InOrder inOrder = inOrder(observer1);</span>

<span class="fc" id="L132">            co.subscribe(observer1);</span>

<span class="fc" id="L134">            inOrder.verify(observer1, times(1)).onNext(4);</span>
<span class="fc" id="L135">            inOrder.verify(observer1, times(1)).onNext(5);</span>
<span class="fc" id="L136">            inOrder.verifyNoMoreInteractions();</span>
<span class="fc" id="L137">            verify(observer1, never()).onError(any(Throwable.class));</span>
        }
<span class="fc" id="L139">    }</span>

    @Test
    public void testWindowedReplay() {
<span class="fc" id="L143">        TestScheduler scheduler = new TestScheduler();</span>

<span class="fc" id="L145">        PublishSubject&lt;Integer&gt; source = PublishSubject.create();</span>

<span class="fc" id="L147">        ConnectableObservable&lt;Integer&gt; co = source.replay(100, TimeUnit.MILLISECONDS, scheduler);</span>
<span class="fc" id="L148">        co.connect();</span>

        {
<span class="fc" id="L151">            Observer&lt;Object&gt; observer1 = TestHelper.mockObserver();</span>
<span class="fc" id="L152">            InOrder inOrder = inOrder(observer1);</span>

<span class="fc" id="L154">            co.subscribe(observer1);</span>

<span class="fc" id="L156">            source.onNext(1);</span>
<span class="fc" id="L157">            scheduler.advanceTimeBy(60, TimeUnit.MILLISECONDS);</span>
<span class="fc" id="L158">            source.onNext(2);</span>
<span class="fc" id="L159">            scheduler.advanceTimeBy(60, TimeUnit.MILLISECONDS);</span>
<span class="fc" id="L160">            source.onNext(3);</span>
<span class="fc" id="L161">            scheduler.advanceTimeBy(60, TimeUnit.MILLISECONDS);</span>
<span class="fc" id="L162">            source.onComplete();</span>
<span class="fc" id="L163">            scheduler.advanceTimeBy(60, TimeUnit.MILLISECONDS);</span>

<span class="fc" id="L165">            inOrder.verify(observer1, times(1)).onNext(1);</span>
<span class="fc" id="L166">            inOrder.verify(observer1, times(1)).onNext(2);</span>
<span class="fc" id="L167">            inOrder.verify(observer1, times(1)).onNext(3);</span>

<span class="fc" id="L169">            inOrder.verify(observer1, times(1)).onComplete();</span>
<span class="fc" id="L170">            inOrder.verifyNoMoreInteractions();</span>
<span class="fc" id="L171">            verify(observer1, never()).onError(any(Throwable.class));</span>

        }
        {
<span class="fc" id="L175">            Observer&lt;Object&gt; observer1 = TestHelper.mockObserver();</span>
<span class="fc" id="L176">            InOrder inOrder = inOrder(observer1);</span>

<span class="fc" id="L178">            co.subscribe(observer1);</span>
<span class="fc" id="L179">            inOrder.verify(observer1, never()).onNext(3);</span>

<span class="fc" id="L181">            inOrder.verify(observer1, times(1)).onComplete();</span>
<span class="fc" id="L182">            inOrder.verifyNoMoreInteractions();</span>
<span class="fc" id="L183">            verify(observer1, never()).onError(any(Throwable.class));</span>
        }
<span class="fc" id="L185">    }</span>

    @Test
    public void testReplaySelector() {
<span class="fc" id="L189">        final Function&lt;Integer, Integer&gt; dbl = new Function&lt;Integer, Integer&gt;() {</span>

            @Override
            public Integer apply(Integer t1) {
<span class="fc" id="L193">                return t1 * 2;</span>
            }

        };

<span class="fc" id="L198">        Function&lt;Observable&lt;Integer&gt;, Observable&lt;Integer&gt;&gt; selector = new Function&lt;Observable&lt;Integer&gt;, Observable&lt;Integer&gt;&gt;() {</span>

            @Override
            public Observable&lt;Integer&gt; apply(Observable&lt;Integer&gt; t1) {
<span class="fc" id="L202">                return t1.map(dbl);</span>
            }

        };

<span class="fc" id="L207">        PublishSubject&lt;Integer&gt; source = PublishSubject.create();</span>

<span class="fc" id="L209">        Observable&lt;Integer&gt; co = source.replay(selector);</span>

        {
<span class="fc" id="L212">            Observer&lt;Object&gt; observer1 = TestHelper.mockObserver();</span>
<span class="fc" id="L213">            InOrder inOrder = inOrder(observer1);</span>

<span class="fc" id="L215">            co.subscribe(observer1);</span>

<span class="fc" id="L217">            source.onNext(1);</span>
<span class="fc" id="L218">            source.onNext(2);</span>
<span class="fc" id="L219">            source.onNext(3);</span>

<span class="fc" id="L221">            inOrder.verify(observer1, times(1)).onNext(2);</span>
<span class="fc" id="L222">            inOrder.verify(observer1, times(1)).onNext(4);</span>
<span class="fc" id="L223">            inOrder.verify(observer1, times(1)).onNext(6);</span>

<span class="fc" id="L225">            source.onNext(4);</span>
<span class="fc" id="L226">            source.onComplete();</span>
<span class="fc" id="L227">            inOrder.verify(observer1, times(1)).onNext(8);</span>
<span class="fc" id="L228">            inOrder.verify(observer1, times(1)).onComplete();</span>
<span class="fc" id="L229">            inOrder.verifyNoMoreInteractions();</span>
<span class="fc" id="L230">            verify(observer1, never()).onError(any(Throwable.class));</span>

        }

        {
<span class="fc" id="L235">            Observer&lt;Object&gt; observer1 = TestHelper.mockObserver();</span>
<span class="fc" id="L236">            InOrder inOrder = inOrder(observer1);</span>

<span class="fc" id="L238">            co.subscribe(observer1);</span>

<span class="fc" id="L240">            inOrder.verify(observer1, times(1)).onComplete();</span>
<span class="fc" id="L241">            inOrder.verifyNoMoreInteractions();</span>
<span class="fc" id="L242">            verify(observer1, never()).onError(any(Throwable.class));</span>

        }

<span class="fc" id="L246">    }</span>

    @Test
    public void testBufferedReplaySelector() {

<span class="fc" id="L251">        final Function&lt;Integer, Integer&gt; dbl = new Function&lt;Integer, Integer&gt;() {</span>

            @Override
            public Integer apply(Integer t1) {
<span class="fc" id="L255">                return t1 * 2;</span>
            }

        };

<span class="fc" id="L260">        Function&lt;Observable&lt;Integer&gt;, Observable&lt;Integer&gt;&gt; selector = new Function&lt;Observable&lt;Integer&gt;, Observable&lt;Integer&gt;&gt;() {</span>

            @Override
            public Observable&lt;Integer&gt; apply(Observable&lt;Integer&gt; t1) {
<span class="fc" id="L264">                return t1.map(dbl);</span>
            }

        };

<span class="fc" id="L269">        PublishSubject&lt;Integer&gt; source = PublishSubject.create();</span>

<span class="fc" id="L271">        Observable&lt;Integer&gt; co = source.replay(selector, 3);</span>

        {
<span class="fc" id="L274">            Observer&lt;Object&gt; observer1 = TestHelper.mockObserver();</span>
<span class="fc" id="L275">            InOrder inOrder = inOrder(observer1);</span>

<span class="fc" id="L277">            co.subscribe(observer1);</span>

<span class="fc" id="L279">            source.onNext(1);</span>
<span class="fc" id="L280">            source.onNext(2);</span>
<span class="fc" id="L281">            source.onNext(3);</span>

<span class="fc" id="L283">            inOrder.verify(observer1, times(1)).onNext(2);</span>
<span class="fc" id="L284">            inOrder.verify(observer1, times(1)).onNext(4);</span>
<span class="fc" id="L285">            inOrder.verify(observer1, times(1)).onNext(6);</span>

<span class="fc" id="L287">            source.onNext(4);</span>
<span class="fc" id="L288">            source.onComplete();</span>
<span class="fc" id="L289">            inOrder.verify(observer1, times(1)).onNext(8);</span>
<span class="fc" id="L290">            inOrder.verify(observer1, times(1)).onComplete();</span>
<span class="fc" id="L291">            inOrder.verifyNoMoreInteractions();</span>
<span class="fc" id="L292">            verify(observer1, never()).onError(any(Throwable.class));</span>

        }

        {
<span class="fc" id="L297">            Observer&lt;Object&gt; observer1 = TestHelper.mockObserver();</span>
<span class="fc" id="L298">            InOrder inOrder = inOrder(observer1);</span>

<span class="fc" id="L300">            co.subscribe(observer1);</span>

<span class="fc" id="L302">            inOrder.verify(observer1, times(1)).onComplete();</span>
<span class="fc" id="L303">            inOrder.verifyNoMoreInteractions();</span>
<span class="fc" id="L304">            verify(observer1, never()).onError(any(Throwable.class));</span>
        }
<span class="fc" id="L306">    }</span>

    @Test
    public void testWindowedReplaySelector() {

<span class="fc" id="L311">        final Function&lt;Integer, Integer&gt; dbl = new Function&lt;Integer, Integer&gt;() {</span>

            @Override
            public Integer apply(Integer t1) {
<span class="fc" id="L315">                return t1 * 2;</span>
            }

        };

<span class="fc" id="L320">        Function&lt;Observable&lt;Integer&gt;, Observable&lt;Integer&gt;&gt; selector = new Function&lt;Observable&lt;Integer&gt;, Observable&lt;Integer&gt;&gt;() {</span>

            @Override
            public Observable&lt;Integer&gt; apply(Observable&lt;Integer&gt; t1) {
<span class="fc" id="L324">                return t1.map(dbl);</span>
            }

        };

<span class="fc" id="L329">        TestScheduler scheduler = new TestScheduler();</span>

<span class="fc" id="L331">        PublishSubject&lt;Integer&gt; source = PublishSubject.create();</span>

<span class="fc" id="L333">        Observable&lt;Integer&gt; co = source.replay(selector, 100, TimeUnit.MILLISECONDS, scheduler);</span>

        {
<span class="fc" id="L336">            Observer&lt;Object&gt; observer1 = TestHelper.mockObserver();</span>
<span class="fc" id="L337">            InOrder inOrder = inOrder(observer1);</span>

<span class="fc" id="L339">            co.subscribe(observer1);</span>

<span class="fc" id="L341">            source.onNext(1);</span>
<span class="fc" id="L342">            scheduler.advanceTimeBy(60, TimeUnit.MILLISECONDS);</span>
<span class="fc" id="L343">            source.onNext(2);</span>
<span class="fc" id="L344">            scheduler.advanceTimeBy(60, TimeUnit.MILLISECONDS);</span>
<span class="fc" id="L345">            source.onNext(3);</span>
<span class="fc" id="L346">            scheduler.advanceTimeBy(60, TimeUnit.MILLISECONDS);</span>
<span class="fc" id="L347">            source.onComplete();</span>
<span class="fc" id="L348">            scheduler.advanceTimeBy(60, TimeUnit.MILLISECONDS);</span>

<span class="fc" id="L350">            inOrder.verify(observer1, times(1)).onNext(2);</span>
<span class="fc" id="L351">            inOrder.verify(observer1, times(1)).onNext(4);</span>
<span class="fc" id="L352">            inOrder.verify(observer1, times(1)).onNext(6);</span>

<span class="fc" id="L354">            inOrder.verify(observer1, times(1)).onComplete();</span>
<span class="fc" id="L355">            inOrder.verifyNoMoreInteractions();</span>
<span class="fc" id="L356">            verify(observer1, never()).onError(any(Throwable.class));</span>

        }
        {
<span class="fc" id="L360">            Observer&lt;Object&gt; observer1 = TestHelper.mockObserver();</span>
<span class="fc" id="L361">            InOrder inOrder = inOrder(observer1);</span>

<span class="fc" id="L363">            co.subscribe(observer1);</span>

<span class="fc" id="L365">            inOrder.verify(observer1, times(1)).onComplete();</span>
<span class="fc" id="L366">            inOrder.verifyNoMoreInteractions();</span>
<span class="fc" id="L367">            verify(observer1, never()).onError(any(Throwable.class));</span>
        }
<span class="fc" id="L369">    }</span>

    @Test
    public void testBufferedReplayError() {
<span class="fc" id="L373">        PublishSubject&lt;Integer&gt; source = PublishSubject.create();</span>

<span class="fc" id="L375">        ConnectableObservable&lt;Integer&gt; co = source.replay(3);</span>
<span class="fc" id="L376">        co.connect();</span>

        {
<span class="fc" id="L379">            Observer&lt;Object&gt; observer1 = TestHelper.mockObserver();</span>
<span class="fc" id="L380">            InOrder inOrder = inOrder(observer1);</span>

<span class="fc" id="L382">            co.subscribe(observer1);</span>

<span class="fc" id="L384">            source.onNext(1);</span>
<span class="fc" id="L385">            source.onNext(2);</span>
<span class="fc" id="L386">            source.onNext(3);</span>

<span class="fc" id="L388">            inOrder.verify(observer1, times(1)).onNext(1);</span>
<span class="fc" id="L389">            inOrder.verify(observer1, times(1)).onNext(2);</span>
<span class="fc" id="L390">            inOrder.verify(observer1, times(1)).onNext(3);</span>

<span class="fc" id="L392">            source.onNext(4);</span>
<span class="fc" id="L393">            source.onError(new RuntimeException(&quot;Forced failure&quot;));</span>

<span class="fc" id="L395">            inOrder.verify(observer1, times(1)).onNext(4);</span>
<span class="fc" id="L396">            inOrder.verify(observer1, times(1)).onError(any(RuntimeException.class));</span>
<span class="fc" id="L397">            inOrder.verifyNoMoreInteractions();</span>
<span class="fc" id="L398">            verify(observer1, never()).onComplete();</span>

        }

        {
<span class="fc" id="L403">            Observer&lt;Object&gt; observer1 = TestHelper.mockObserver();</span>
<span class="fc" id="L404">            InOrder inOrder = inOrder(observer1);</span>

<span class="fc" id="L406">            co.subscribe(observer1);</span>

<span class="fc" id="L408">            inOrder.verify(observer1, times(1)).onNext(2);</span>
<span class="fc" id="L409">            inOrder.verify(observer1, times(1)).onNext(3);</span>
<span class="fc" id="L410">            inOrder.verify(observer1, times(1)).onNext(4);</span>
<span class="fc" id="L411">            inOrder.verify(observer1, times(1)).onError(any(RuntimeException.class));</span>
<span class="fc" id="L412">            inOrder.verifyNoMoreInteractions();</span>
<span class="fc" id="L413">            verify(observer1, never()).onComplete();</span>
        }
<span class="fc" id="L415">    }</span>

    @Test
    public void testWindowedReplayError() {
<span class="fc" id="L419">        TestScheduler scheduler = new TestScheduler();</span>

<span class="fc" id="L421">        PublishSubject&lt;Integer&gt; source = PublishSubject.create();</span>

<span class="fc" id="L423">        ConnectableObservable&lt;Integer&gt; co = source.replay(100, TimeUnit.MILLISECONDS, scheduler);</span>
<span class="fc" id="L424">        co.connect();</span>

        {
<span class="fc" id="L427">            Observer&lt;Object&gt; observer1 = TestHelper.mockObserver();</span>
<span class="fc" id="L428">            InOrder inOrder = inOrder(observer1);</span>

<span class="fc" id="L430">            co.subscribe(observer1);</span>

<span class="fc" id="L432">            source.onNext(1);</span>
<span class="fc" id="L433">            scheduler.advanceTimeBy(60, TimeUnit.MILLISECONDS);</span>
<span class="fc" id="L434">            source.onNext(2);</span>
<span class="fc" id="L435">            scheduler.advanceTimeBy(60, TimeUnit.MILLISECONDS);</span>
<span class="fc" id="L436">            source.onNext(3);</span>
<span class="fc" id="L437">            scheduler.advanceTimeBy(60, TimeUnit.MILLISECONDS);</span>
<span class="fc" id="L438">            source.onError(new RuntimeException(&quot;Forced failure&quot;));</span>
<span class="fc" id="L439">            scheduler.advanceTimeBy(60, TimeUnit.MILLISECONDS);</span>

<span class="fc" id="L441">            inOrder.verify(observer1, times(1)).onNext(1);</span>
<span class="fc" id="L442">            inOrder.verify(observer1, times(1)).onNext(2);</span>
<span class="fc" id="L443">            inOrder.verify(observer1, times(1)).onNext(3);</span>

<span class="fc" id="L445">            inOrder.verify(observer1, times(1)).onError(any(RuntimeException.class));</span>
<span class="fc" id="L446">            inOrder.verifyNoMoreInteractions();</span>
<span class="fc" id="L447">            verify(observer1, never()).onComplete();</span>

        }
        {
<span class="fc" id="L451">            Observer&lt;Object&gt; observer1 = TestHelper.mockObserver();</span>
<span class="fc" id="L452">            InOrder inOrder = inOrder(observer1);</span>

<span class="fc" id="L454">            co.subscribe(observer1);</span>
<span class="fc" id="L455">            inOrder.verify(observer1, never()).onNext(3);</span>

<span class="fc" id="L457">            inOrder.verify(observer1, times(1)).onError(any(RuntimeException.class));</span>
<span class="fc" id="L458">            inOrder.verifyNoMoreInteractions();</span>
<span class="fc" id="L459">            verify(observer1, never()).onComplete();</span>
        }
<span class="fc" id="L461">    }</span>

    @Test
    public void testSynchronousDisconnect() {
<span class="fc" id="L465">        final AtomicInteger effectCounter = new AtomicInteger();</span>
<span class="fc" id="L466">        Observable&lt;Integer&gt; source = Observable.just(1, 2, 3, 4)</span>
<span class="fc" id="L467">        .doOnNext(new Consumer&lt;Integer&gt;() {</span>
            @Override
            public void accept(Integer v) {
<span class="fc" id="L470">                effectCounter.incrementAndGet();</span>
<span class="fc" id="L471">                System.out.println(&quot;Sideeffect #&quot; + v);</span>
<span class="fc" id="L472">            }</span>
        });

<span class="fc" id="L475">        Observable&lt;Integer&gt; result = source.replay(</span>
<span class="fc" id="L476">        new Function&lt;Observable&lt;Integer&gt;, Observable&lt;Integer&gt;&gt;() {</span>
            @Override
            public Observable&lt;Integer&gt; apply(Observable&lt;Integer&gt; o) {
<span class="fc" id="L479">                return o.take(2);</span>
            }
        });

<span class="fc bfc" id="L483" title="All 2 branches covered.">        for (int i = 1; i &lt; 3; i++) {</span>
<span class="fc" id="L484">            effectCounter.set(0);</span>
<span class="fc" id="L485">            System.out.printf(&quot;- %d -%n&quot;, i);</span>
<span class="fc" id="L486">            result.subscribe(new Consumer&lt;Integer&gt;() {</span>

                @Override
                public void accept(Integer t1) {
<span class="fc" id="L490">                    System.out.println(t1);</span>
<span class="fc" id="L491">                }</span>

<span class="fc" id="L493">            }, new Consumer&lt;Throwable&gt;() {</span>

                @Override
                public void accept(Throwable t1) {
<span class="nc" id="L497">                    t1.printStackTrace();</span>
<span class="nc" id="L498">                }</span>
            },
<span class="fc" id="L500">            new Action() {</span>
                @Override
                public void run() {
<span class="fc" id="L503">                    System.out.println(&quot;Done&quot;);</span>
<span class="fc" id="L504">                }</span>
            });
<span class="fc" id="L506">            assertEquals(2, effectCounter.get());</span>
        }
<span class="fc" id="L508">    }</span>

    /*
     * test the basic expectation of OperatorMulticast via replay
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void testIssue2191_UnsubscribeSource() throws Exception {
        // setup mocks
<span class="fc" id="L517">        Consumer&lt;Integer&gt; sourceNext = mock(Consumer.class);</span>
<span class="fc" id="L518">        Action sourceCompleted = mock(Action.class);</span>
<span class="fc" id="L519">        Action sourceUnsubscribed = mock(Action.class);</span>
<span class="fc" id="L520">        Observer&lt;Integer&gt; spiedSubscriberBeforeConnect = TestHelper.mockObserver();</span>
<span class="fc" id="L521">        Observer&lt;Integer&gt; spiedSubscriberAfterConnect = TestHelper.mockObserver();</span>

        // Observable under test
<span class="fc" id="L524">        Observable&lt;Integer&gt; source = Observable.just(1, 2);</span>

<span class="fc" id="L526">        ConnectableObservable&lt;Integer&gt; replay = source</span>
<span class="fc" id="L527">                .doOnNext(sourceNext)</span>
<span class="fc" id="L528">                .doOnDispose(sourceUnsubscribed)</span>
<span class="fc" id="L529">                .doOnComplete(sourceCompleted)</span>
<span class="fc" id="L530">                .replay();</span>

<span class="fc" id="L532">        replay.subscribe(spiedSubscriberBeforeConnect);</span>
<span class="fc" id="L533">        replay.subscribe(spiedSubscriberBeforeConnect);</span>
<span class="fc" id="L534">        replay.connect();</span>
<span class="fc" id="L535">        replay.subscribe(spiedSubscriberAfterConnect);</span>
<span class="fc" id="L536">        replay.subscribe(spiedSubscriberAfterConnect);</span>

<span class="fc" id="L538">        verify(spiedSubscriberBeforeConnect, times(2)).onSubscribe((Disposable)any());</span>
<span class="fc" id="L539">        verify(spiedSubscriberAfterConnect, times(2)).onSubscribe((Disposable)any());</span>

        // verify interactions
<span class="fc" id="L542">        verify(sourceNext, times(1)).accept(1);</span>
<span class="fc" id="L543">        verify(sourceNext, times(1)).accept(2);</span>
<span class="fc" id="L544">        verify(sourceCompleted, times(1)).run();</span>
<span class="fc" id="L545">        verifyObserverMock(spiedSubscriberBeforeConnect, 2, 4);</span>
<span class="fc" id="L546">        verifyObserverMock(spiedSubscriberAfterConnect, 2, 4);</span>

//        verify(sourceUnsubscribed, times(1)).run();

<span class="fc" id="L550">        verifyNoMoreInteractions(sourceNext);</span>
<span class="fc" id="L551">        verifyNoMoreInteractions(sourceCompleted);</span>
<span class="fc" id="L552">        verifyNoMoreInteractions(sourceUnsubscribed);</span>
<span class="fc" id="L553">        verifyNoMoreInteractions(spiedSubscriberBeforeConnect);</span>
<span class="fc" id="L554">        verifyNoMoreInteractions(spiedSubscriberAfterConnect);</span>

<span class="fc" id="L556">    }</span>

    /**
     * Specifically test interaction with a Scheduler with subscribeOn.
     *
     * @throws Exception functional interfaces are declared with throws Exception
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void testIssue2191_SchedulerUnsubscribe() throws Exception {
        // setup mocks
<span class="fc" id="L567">        Consumer&lt;Integer&gt; sourceNext = mock(Consumer.class);</span>
<span class="fc" id="L568">        Action sourceCompleted = mock(Action.class);</span>
<span class="fc" id="L569">        Action sourceUnsubscribed = mock(Action.class);</span>
<span class="fc" id="L570">        final TestScheduler mockScheduler = new TestScheduler();</span>

<span class="fc" id="L572">        Observer&lt;Integer&gt; mockObserverBeforeConnect = TestHelper.mockObserver();</span>
<span class="fc" id="L573">        Observer&lt;Integer&gt; mockObserverAfterConnect = TestHelper.mockObserver();</span>

        // Observable under test
<span class="fc" id="L576">        ConnectableObservable&lt;Integer&gt; replay = Observable.just(1, 2, 3)</span>
<span class="fc" id="L577">                .doOnNext(sourceNext)</span>
<span class="fc" id="L578">                .doOnDispose(sourceUnsubscribed)</span>
<span class="fc" id="L579">                .doOnComplete(sourceCompleted)</span>
<span class="fc" id="L580">                .subscribeOn(mockScheduler).replay();</span>

<span class="fc" id="L582">        replay.subscribe(mockObserverBeforeConnect);</span>
<span class="fc" id="L583">        replay.connect();</span>
<span class="fc" id="L584">        replay.subscribe(mockObserverAfterConnect);</span>

<span class="fc" id="L586">        verify(mockObserverBeforeConnect).onSubscribe((Disposable)any());</span>
<span class="fc" id="L587">        verify(mockObserverAfterConnect).onSubscribe((Disposable)any());</span>

<span class="fc" id="L589">        mockScheduler.advanceTimeBy(1, TimeUnit.SECONDS);</span>

        // verify interactions
<span class="fc" id="L592">        verify(sourceNext, times(1)).accept(1);</span>
<span class="fc" id="L593">        verify(sourceNext, times(1)).accept(2);</span>
<span class="fc" id="L594">        verify(sourceNext, times(1)).accept(3);</span>
<span class="fc" id="L595">        verify(sourceCompleted, times(1)).run();</span>
<span class="fc" id="L596">        verifyObserverMock(mockObserverBeforeConnect, 1, 3);</span>
<span class="fc" id="L597">        verifyObserverMock(mockObserverAfterConnect, 1, 3);</span>

        // FIXME not supported
//        verify(spiedWorker, times(1)).isUnsubscribed();
        // FIXME publish calls cancel too
//        verify(sourceUnsubscribed, times(1)).run();

<span class="fc" id="L604">        verifyNoMoreInteractions(sourceNext);</span>
<span class="fc" id="L605">        verifyNoMoreInteractions(sourceCompleted);</span>
<span class="fc" id="L606">        verifyNoMoreInteractions(sourceUnsubscribed);</span>
<span class="fc" id="L607">        verifyNoMoreInteractions(mockObserverBeforeConnect);</span>
<span class="fc" id="L608">        verifyNoMoreInteractions(mockObserverAfterConnect);</span>
<span class="fc" id="L609">    }</span>

    /**
     * Specifically test interaction with a Scheduler with subscribeOn.
     *
     * @throws Exception functional interfaces are declared with throws Exception
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void testIssue2191_SchedulerUnsubscribeOnError() throws Exception {
        // setup mocks
<span class="fc" id="L620">        Consumer&lt;Integer&gt; sourceNext = mock(Consumer.class);</span>
<span class="fc" id="L621">        Action sourceCompleted = mock(Action.class);</span>
<span class="fc" id="L622">        Consumer&lt;Throwable&gt; sourceError = mock(Consumer.class);</span>
<span class="fc" id="L623">        Action sourceUnsubscribed = mock(Action.class);</span>
<span class="fc" id="L624">        final TestScheduler mockScheduler = new TestScheduler();</span>
<span class="fc" id="L625">        Observer&lt;Integer&gt; mockObserverBeforeConnect = TestHelper.mockObserver();</span>
<span class="fc" id="L626">        Observer&lt;Integer&gt; mockObserverAfterConnect = TestHelper.mockObserver();</span>

        // Observable under test
<span class="fc" id="L629">        Function&lt;Integer, Integer&gt; mockFunc = mock(Function.class);</span>
<span class="fc" id="L630">        IllegalArgumentException illegalArgumentException = new IllegalArgumentException();</span>
<span class="fc" id="L631">        when(mockFunc.apply(1)).thenReturn(1);</span>
<span class="fc" id="L632">        when(mockFunc.apply(2)).thenThrow(illegalArgumentException);</span>
<span class="fc" id="L633">        ConnectableObservable&lt;Integer&gt; replay = Observable.just(1, 2, 3).map(mockFunc)</span>
<span class="fc" id="L634">                .doOnNext(sourceNext)</span>
<span class="fc" id="L635">                .doOnDispose(sourceUnsubscribed)</span>
<span class="fc" id="L636">                .doOnComplete(sourceCompleted)</span>
<span class="fc" id="L637">                .doOnError(sourceError)</span>
<span class="fc" id="L638">                .subscribeOn(mockScheduler).replay();</span>

<span class="fc" id="L640">        replay.subscribe(mockObserverBeforeConnect);</span>
<span class="fc" id="L641">        replay.connect();</span>
<span class="fc" id="L642">        replay.subscribe(mockObserverAfterConnect);</span>

<span class="fc" id="L644">        verify(mockObserverBeforeConnect).onSubscribe((Disposable)any());</span>
<span class="fc" id="L645">        verify(mockObserverAfterConnect).onSubscribe((Disposable)any());</span>

<span class="fc" id="L647">        mockScheduler.advanceTimeBy(1, TimeUnit.SECONDS);</span>
        // verify interactions
<span class="fc" id="L649">        verify(sourceNext, times(1)).accept(1);</span>
<span class="fc" id="L650">        verify(sourceError, times(1)).accept(illegalArgumentException);</span>
<span class="fc" id="L651">        verifyObserver(mockObserverBeforeConnect, 1, 1, illegalArgumentException);</span>
<span class="fc" id="L652">        verifyObserver(mockObserverAfterConnect, 1, 1, illegalArgumentException);</span>

        // FIXME no longer supported
//        verify(spiedWorker, times(1)).isUnsubscribed();
        // FIXME publish also calls cancel
//        verify(sourceUnsubscribed, times(1)).run();

<span class="fc" id="L659">        verifyNoMoreInteractions(sourceNext);</span>
<span class="fc" id="L660">        verifyNoMoreInteractions(sourceCompleted);</span>
<span class="fc" id="L661">        verifyNoMoreInteractions(sourceError);</span>
<span class="fc" id="L662">        verifyNoMoreInteractions(sourceUnsubscribed);</span>
<span class="fc" id="L663">        verifyNoMoreInteractions(mockObserverBeforeConnect);</span>
<span class="fc" id="L664">        verifyNoMoreInteractions(mockObserverAfterConnect);</span>
<span class="fc" id="L665">    }</span>

    private static void verifyObserverMock(Observer&lt;Integer&gt; mock, int numSubscriptions, int numItemsExpected) {
<span class="fc" id="L668">        verify(mock, times(numItemsExpected)).onNext((Integer) notNull());</span>
<span class="fc" id="L669">        verify(mock, times(numSubscriptions)).onComplete();</span>
<span class="fc" id="L670">        verifyNoMoreInteractions(mock);</span>
<span class="fc" id="L671">    }</span>

    private static void verifyObserver(Observer&lt;Integer&gt; mock, int numSubscriptions, int numItemsExpected, Throwable error) {
<span class="fc" id="L674">        verify(mock, times(numItemsExpected)).onNext((Integer) notNull());</span>
<span class="fc" id="L675">        verify(mock, times(numSubscriptions)).onError(error);</span>
<span class="fc" id="L676">        verifyNoMoreInteractions(mock);</span>
<span class="fc" id="L677">    }</span>

    public static Worker workerSpy(final Disposable mockDisposable) {
<span class="nc" id="L680">        return spy(new InprocessWorker(mockDisposable));</span>
    }

    static class InprocessWorker extends Worker {
        private final Disposable mockDisposable;
        public boolean unsubscribed;

<span class="nc" id="L687">        InprocessWorker(Disposable mockDisposable) {</span>
<span class="nc" id="L688">            this.mockDisposable = mockDisposable;</span>
<span class="nc" id="L689">        }</span>

        @NonNull
        @Override
        public Disposable schedule(@NonNull Runnable action) {
<span class="nc" id="L694">            action.run();</span>
<span class="nc" id="L695">            return mockDisposable; // this subscription is returned but discarded</span>
        }

        @NonNull
        @Override
        public Disposable schedule(@NonNull Runnable action, long delayTime, @NonNull TimeUnit unit) {
<span class="nc" id="L701">            action.run();</span>
<span class="nc" id="L702">            return mockDisposable;</span>
        }

        @Override
        public void dispose() {
<span class="nc" id="L707">            unsubscribed = true;</span>
<span class="nc" id="L708">        }</span>

        @Override
        public boolean isDisposed() {
<span class="nc" id="L712">            return unsubscribed;</span>
        }
    }

    @Test
    public void testBoundedReplayBuffer() {
<span class="fc" id="L718">        BoundedReplayBuffer&lt;Integer&gt; buf = new BoundedReplayBuffer&lt;Integer&gt;() {</span>
            private static final long serialVersionUID = -5182053207244406872L;

            @Override
            void truncate() {
<span class="nc" id="L723">            }</span>
        };
<span class="fc" id="L725">        buf.addLast(new Node(1));</span>
<span class="fc" id="L726">        buf.addLast(new Node(2));</span>
<span class="fc" id="L727">        buf.addLast(new Node(3));</span>
<span class="fc" id="L728">        buf.addLast(new Node(4));</span>
<span class="fc" id="L729">        buf.addLast(new Node(5));</span>

<span class="fc" id="L731">        List&lt;Integer&gt; values = new ArrayList&lt;Integer&gt;();</span>
<span class="fc" id="L732">        buf.collect(values);</span>

<span class="fc" id="L734">        Assert.assertEquals(Arrays.asList(1, 2, 3, 4, 5), values);</span>

<span class="fc" id="L736">        buf.removeSome(2);</span>
<span class="fc" id="L737">        buf.removeFirst();</span>
<span class="fc" id="L738">        buf.removeSome(2);</span>

<span class="fc" id="L740">        values.clear();</span>
<span class="fc" id="L741">        buf.collect(values);</span>
<span class="fc" id="L742">        Assert.assertTrue(values.isEmpty());</span>

<span class="fc" id="L744">        buf.addLast(new Node(5));</span>
<span class="fc" id="L745">        buf.addLast(new Node(6));</span>
<span class="fc" id="L746">        buf.collect(values);</span>

<span class="fc" id="L748">        Assert.assertEquals(Arrays.asList(5, 6), values);</span>

<span class="fc" id="L750">    }</span>

    @Test
    public void testTimedAndSizedTruncation() {
<span class="fc" id="L754">        TestScheduler test = new TestScheduler();</span>
<span class="fc" id="L755">        SizeAndTimeBoundReplayBuffer&lt;Integer&gt; buf = new SizeAndTimeBoundReplayBuffer&lt;Integer&gt;(2, 2000, TimeUnit.MILLISECONDS, test);</span>
<span class="fc" id="L756">        List&lt;Integer&gt; values = new ArrayList&lt;Integer&gt;();</span>

<span class="fc" id="L758">        buf.next(1);</span>
<span class="fc" id="L759">        test.advanceTimeBy(1, TimeUnit.SECONDS);</span>
<span class="fc" id="L760">        buf.next(2);</span>
<span class="fc" id="L761">        test.advanceTimeBy(1, TimeUnit.SECONDS);</span>
<span class="fc" id="L762">        buf.collect(values);</span>
<span class="fc" id="L763">        Assert.assertEquals(Arrays.asList(2), values);</span>

<span class="fc" id="L765">        buf.next(3);</span>
<span class="fc" id="L766">        buf.next(4);</span>
<span class="fc" id="L767">        values.clear();</span>
<span class="fc" id="L768">        buf.collect(values);</span>
<span class="fc" id="L769">        Assert.assertEquals(Arrays.asList(3, 4), values);</span>

<span class="fc" id="L771">        test.advanceTimeBy(2, TimeUnit.SECONDS);</span>
<span class="fc" id="L772">        buf.next(5);</span>

<span class="fc" id="L774">        values.clear();</span>
<span class="fc" id="L775">        buf.collect(values);</span>
<span class="fc" id="L776">        Assert.assertEquals(Arrays.asList(5), values);</span>
<span class="fc" id="L777">        Assert.assertFalse(buf.hasCompleted());</span>

<span class="fc" id="L779">        test.advanceTimeBy(2, TimeUnit.SECONDS);</span>
<span class="fc" id="L780">        buf.complete();</span>

<span class="fc" id="L782">        values.clear();</span>
<span class="fc" id="L783">        buf.collect(values);</span>
<span class="fc" id="L784">        Assert.assertTrue(values.isEmpty());</span>

<span class="fc" id="L786">        Assert.assertEquals(1, buf.size);</span>
<span class="fc" id="L787">        Assert.assertTrue(buf.hasCompleted());</span>
<span class="fc" id="L788">        Assert.assertFalse(buf.hasError());</span>
<span class="fc" id="L789">    }</span>

    @Test
    public void testTimedAndSizedTruncationError() {
<span class="fc" id="L793">        TestScheduler test = new TestScheduler();</span>
<span class="fc" id="L794">        SizeAndTimeBoundReplayBuffer&lt;Integer&gt; buf = new SizeAndTimeBoundReplayBuffer&lt;Integer&gt;(2, 2000, TimeUnit.MILLISECONDS, test);</span>

<span class="fc" id="L796">        Assert.assertFalse(buf.hasCompleted());</span>
<span class="fc" id="L797">        Assert.assertFalse(buf.hasError());</span>

<span class="fc" id="L799">        List&lt;Integer&gt; values = new ArrayList&lt;Integer&gt;();</span>

<span class="fc" id="L801">        buf.next(1);</span>
<span class="fc" id="L802">        test.advanceTimeBy(1, TimeUnit.SECONDS);</span>
<span class="fc" id="L803">        buf.next(2);</span>
<span class="fc" id="L804">        test.advanceTimeBy(1, TimeUnit.SECONDS);</span>
<span class="fc" id="L805">        buf.collect(values);</span>
<span class="fc" id="L806">        Assert.assertEquals(Arrays.asList(2), values);</span>

<span class="fc" id="L808">        buf.next(3);</span>
<span class="fc" id="L809">        buf.next(4);</span>
<span class="fc" id="L810">        values.clear();</span>
<span class="fc" id="L811">        buf.collect(values);</span>
<span class="fc" id="L812">        Assert.assertEquals(Arrays.asList(3, 4), values);</span>

<span class="fc" id="L814">        test.advanceTimeBy(2, TimeUnit.SECONDS);</span>
<span class="fc" id="L815">        buf.next(5);</span>

<span class="fc" id="L817">        values.clear();</span>
<span class="fc" id="L818">        buf.collect(values);</span>
<span class="fc" id="L819">        Assert.assertEquals(Arrays.asList(5), values);</span>
<span class="fc" id="L820">        Assert.assertFalse(buf.hasCompleted());</span>
<span class="fc" id="L821">        Assert.assertFalse(buf.hasError());</span>

<span class="fc" id="L823">        test.advanceTimeBy(2, TimeUnit.SECONDS);</span>
<span class="fc" id="L824">        buf.error(new TestException());</span>

<span class="fc" id="L826">        values.clear();</span>
<span class="fc" id="L827">        buf.collect(values);</span>
<span class="fc" id="L828">        Assert.assertTrue(values.isEmpty());</span>

<span class="fc" id="L830">        Assert.assertEquals(1, buf.size);</span>
<span class="fc" id="L831">        Assert.assertFalse(buf.hasCompleted());</span>
<span class="fc" id="L832">        Assert.assertTrue(buf.hasError());</span>
<span class="fc" id="L833">    }</span>

    @Test
    public void testSizedTruncation() {
<span class="fc" id="L837">        SizeBoundReplayBuffer&lt;Integer&gt; buf = new SizeBoundReplayBuffer&lt;Integer&gt;(2);</span>
<span class="fc" id="L838">        List&lt;Integer&gt; values = new ArrayList&lt;Integer&gt;();</span>

<span class="fc" id="L840">        buf.next(1);</span>
<span class="fc" id="L841">        buf.next(2);</span>
<span class="fc" id="L842">        buf.collect(values);</span>
<span class="fc" id="L843">        Assert.assertEquals(Arrays.asList(1, 2), values);</span>

<span class="fc" id="L845">        buf.next(3);</span>
<span class="fc" id="L846">        buf.next(4);</span>
<span class="fc" id="L847">        values.clear();</span>
<span class="fc" id="L848">        buf.collect(values);</span>
<span class="fc" id="L849">        Assert.assertEquals(Arrays.asList(3, 4), values);</span>

<span class="fc" id="L851">        buf.next(5);</span>

<span class="fc" id="L853">        values.clear();</span>
<span class="fc" id="L854">        buf.collect(values);</span>
<span class="fc" id="L855">        Assert.assertEquals(Arrays.asList(4, 5), values);</span>
<span class="fc" id="L856">        Assert.assertFalse(buf.hasCompleted());</span>

<span class="fc" id="L858">        buf.complete();</span>

<span class="fc" id="L860">        values.clear();</span>
<span class="fc" id="L861">        buf.collect(values);</span>
<span class="fc" id="L862">        Assert.assertEquals(Arrays.asList(4, 5), values);</span>

<span class="fc" id="L864">        Assert.assertEquals(3, buf.size);</span>
<span class="fc" id="L865">        Assert.assertTrue(buf.hasCompleted());</span>
<span class="fc" id="L866">        Assert.assertFalse(buf.hasError());</span>
<span class="fc" id="L867">    }</span>

    @Test
    public void testColdReplayNoBackpressure() {
<span class="fc" id="L871">        Observable&lt;Integer&gt; source = Observable.range(0, 1000).replay().autoConnect();</span>

<span class="fc" id="L873">        TestObserver&lt;Integer&gt; to = new TestObserver&lt;Integer&gt;();</span>

<span class="fc" id="L875">        source.subscribe(to);</span>

<span class="fc" id="L877">        to.assertNoErrors();</span>
<span class="fc" id="L878">        to.assertTerminated();</span>
<span class="fc" id="L879">        List&lt;Integer&gt; onNextEvents = to.values();</span>
<span class="fc" id="L880">        assertEquals(1000, onNextEvents.size());</span>

<span class="fc bfc" id="L882" title="All 2 branches covered.">        for (int i = 0; i &lt; 1000; i++) {</span>
<span class="fc" id="L883">            assertEquals((Integer)i, onNextEvents.get(i));</span>
        }
<span class="fc" id="L885">    }</span>

    @Test
    public void testCache() throws InterruptedException {
<span class="fc" id="L889">        final AtomicInteger counter = new AtomicInteger();</span>
<span class="fc" id="L890">        Observable&lt;String&gt; o = Observable.unsafeCreate(new ObservableSource&lt;String&gt;() {</span>

            @Override
            public void subscribe(final Observer&lt;? super String&gt; observer) {
<span class="fc" id="L894">                observer.onSubscribe(Disposables.empty());</span>
<span class="fc" id="L895">                new Thread(new Runnable() {</span>

                    @Override
                    public void run() {
<span class="fc" id="L899">                        counter.incrementAndGet();</span>
<span class="fc" id="L900">                        System.out.println(&quot;published Observable being executed&quot;);</span>
<span class="fc" id="L901">                        observer.onNext(&quot;one&quot;);</span>
<span class="fc" id="L902">                        observer.onComplete();</span>
<span class="fc" id="L903">                    }</span>
<span class="fc" id="L904">                }).start();</span>
<span class="fc" id="L905">            }</span>
<span class="fc" id="L906">        }).replay().autoConnect();</span>

        // we then expect the following 2 subscriptions to get that same value
<span class="fc" id="L909">        final CountDownLatch latch = new CountDownLatch(2);</span>

        // subscribe once
<span class="fc" id="L912">        o.subscribe(new Consumer&lt;String&gt;() {</span>

            @Override
            public void accept(String v) {
<span class="fc" id="L916">                assertEquals(&quot;one&quot;, v);</span>
<span class="fc" id="L917">                System.out.println(&quot;v: &quot; + v);</span>
<span class="fc" id="L918">                latch.countDown();</span>
<span class="fc" id="L919">            }</span>
        });

        // subscribe again
<span class="fc" id="L923">        o.subscribe(new Consumer&lt;String&gt;() {</span>

            @Override
            public void accept(String v) {
<span class="fc" id="L927">                assertEquals(&quot;one&quot;, v);</span>
<span class="fc" id="L928">                System.out.println(&quot;v: &quot; + v);</span>
<span class="fc" id="L929">                latch.countDown();</span>
<span class="fc" id="L930">            }</span>
        });

<span class="pc bpc" id="L933" title="1 of 2 branches missed.">        if (!latch.await(1000, TimeUnit.MILLISECONDS)) {</span>
<span class="nc" id="L934">            fail(&quot;subscriptions did not receive values&quot;);</span>
        }
<span class="fc" id="L936">        assertEquals(1, counter.get());</span>
<span class="fc" id="L937">    }</span>

    @Test
    public void testUnsubscribeSource() throws Exception {
<span class="fc" id="L941">        Action unsubscribe = mock(Action.class);</span>
<span class="fc" id="L942">        Observable&lt;Integer&gt; o = Observable.just(1).doOnDispose(unsubscribe).replay().autoConnect();</span>
<span class="fc" id="L943">        o.subscribe();</span>
<span class="fc" id="L944">        o.subscribe();</span>
<span class="fc" id="L945">        o.subscribe();</span>
<span class="fc" id="L946">        verify(unsubscribe, never()).run();</span>
<span class="fc" id="L947">    }</span>

    @Test
    public void testTake() {
<span class="fc" id="L951">        TestObserver&lt;Integer&gt; to = new TestObserver&lt;Integer&gt;();</span>

<span class="fc" id="L953">        Observable&lt;Integer&gt; cached = Observable.range(1, 100).replay().autoConnect();</span>
<span class="fc" id="L954">        cached.take(10).subscribe(to);</span>

<span class="fc" id="L956">        to.assertNoErrors();</span>
<span class="fc" id="L957">        to.assertTerminated();</span>
<span class="fc" id="L958">        to.assertValues(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);</span>
        // FIXME no longer assertable
//        ts.assertUnsubscribed();
<span class="fc" id="L961">    }</span>

    @Test
    public void testAsync() {
<span class="fc" id="L965">        Observable&lt;Integer&gt; source = Observable.range(1, 10000);</span>
<span class="fc bfc" id="L966" title="All 2 branches covered.">        for (int i = 0; i &lt; 100; i++) {</span>
<span class="fc" id="L967">            TestObserver&lt;Integer&gt; to1 = new TestObserver&lt;Integer&gt;();</span>

<span class="fc" id="L969">            Observable&lt;Integer&gt; cached = source.replay().autoConnect();</span>

<span class="fc" id="L971">            cached.observeOn(Schedulers.computation()).subscribe(to1);</span>

<span class="fc" id="L973">            to1.awaitTerminalEvent(2, TimeUnit.SECONDS);</span>
<span class="fc" id="L974">            to1.assertNoErrors();</span>
<span class="fc" id="L975">            to1.assertTerminated();</span>
<span class="fc" id="L976">            assertEquals(10000, to1.values().size());</span>

<span class="fc" id="L978">            TestObserver&lt;Integer&gt; to2 = new TestObserver&lt;Integer&gt;();</span>
<span class="fc" id="L979">            cached.observeOn(Schedulers.computation()).subscribe(to2);</span>

<span class="fc" id="L981">            to2.awaitTerminalEvent(2, TimeUnit.SECONDS);</span>
<span class="fc" id="L982">            to2.assertNoErrors();</span>
<span class="fc" id="L983">            to2.assertTerminated();</span>
<span class="fc" id="L984">            assertEquals(10000, to2.values().size());</span>
        }
<span class="fc" id="L986">    }</span>

    @Test
    public void testAsyncComeAndGo() {
<span class="fc" id="L990">        Observable&lt;Long&gt; source = Observable.interval(1, 1, TimeUnit.MILLISECONDS)</span>
<span class="fc" id="L991">                .take(1000)</span>
<span class="fc" id="L992">                .subscribeOn(Schedulers.io());</span>
<span class="fc" id="L993">        Observable&lt;Long&gt; cached = source.replay().autoConnect();</span>

<span class="fc" id="L995">        Observable&lt;Long&gt; output = cached.observeOn(Schedulers.computation());</span>

<span class="fc" id="L997">        List&lt;TestObserver&lt;Long&gt;&gt; list = new ArrayList&lt;TestObserver&lt;Long&gt;&gt;(100);</span>
<span class="fc bfc" id="L998" title="All 2 branches covered.">        for (int i = 0; i &lt; 100; i++) {</span>
<span class="fc" id="L999">            TestObserver&lt;Long&gt; to = new TestObserver&lt;Long&gt;();</span>
<span class="fc" id="L1000">            list.add(to);</span>
<span class="fc" id="L1001">            output.skip(i * 10).take(10).subscribe(to);</span>
        }

<span class="fc" id="L1004">        List&lt;Long&gt; expected = new ArrayList&lt;Long&gt;();</span>
<span class="fc bfc" id="L1005" title="All 2 branches covered.">        for (int i = 0; i &lt; 10; i++) {</span>
<span class="fc" id="L1006">            expected.add((long)(i - 10));</span>
        }
<span class="fc" id="L1008">        int j = 0;</span>
<span class="fc bfc" id="L1009" title="All 2 branches covered.">        for (TestObserver&lt;Long&gt; to : list) {</span>
<span class="fc" id="L1010">            to.awaitTerminalEvent(3, TimeUnit.SECONDS);</span>
<span class="fc" id="L1011">            to.assertNoErrors();</span>
<span class="fc" id="L1012">            to.assertTerminated();</span>

<span class="fc bfc" id="L1014" title="All 2 branches covered.">            for (int i = j * 10; i &lt; j * 10 + 10; i++) {</span>
<span class="fc" id="L1015">                expected.set(i - j * 10, (long)i);</span>
            }

<span class="fc" id="L1018">            to.assertValueSequence(expected);</span>

<span class="fc" id="L1020">            j++;</span>
<span class="fc" id="L1021">        }</span>
<span class="fc" id="L1022">    }</span>

    @Test
    public void testNoMissingBackpressureException() {
<span class="fc" id="L1026">        final int m = 4 * 1000 * 1000;</span>
<span class="fc" id="L1027">        Observable&lt;Integer&gt; firehose = Observable.unsafeCreate(new ObservableSource&lt;Integer&gt;() {</span>
            @Override
            public void subscribe(Observer&lt;? super Integer&gt; t) {
<span class="fc" id="L1030">                t.onSubscribe(Disposables.empty());</span>
<span class="fc bfc" id="L1031" title="All 2 branches covered.">                for (int i = 0; i &lt; m; i++) {</span>
<span class="fc" id="L1032">                    t.onNext(i);</span>
                }
<span class="fc" id="L1034">                t.onComplete();</span>
<span class="fc" id="L1035">            }</span>
        });

<span class="fc" id="L1038">        TestObserver&lt;Integer&gt; to = new TestObserver&lt;Integer&gt;();</span>
<span class="fc" id="L1039">        firehose.replay().autoConnect().observeOn(Schedulers.computation()).takeLast(100).subscribe(to);</span>

<span class="fc" id="L1041">        to.awaitTerminalEvent(3, TimeUnit.SECONDS);</span>
<span class="fc" id="L1042">        to.assertNoErrors();</span>
<span class="fc" id="L1043">        to.assertTerminated();</span>

<span class="fc" id="L1045">        assertEquals(100, to.values().size());</span>
<span class="fc" id="L1046">    }</span>

    @Test
    public void testValuesAndThenError() {
<span class="fc" id="L1050">        Observable&lt;Integer&gt; source = Observable.range(1, 10)</span>
<span class="fc" id="L1051">                .concatWith(Observable.&lt;Integer&gt;error(new TestException()))</span>
<span class="fc" id="L1052">                .replay().autoConnect();</span>

<span class="fc" id="L1054">        TestObserver&lt;Integer&gt; to = new TestObserver&lt;Integer&gt;();</span>
<span class="fc" id="L1055">        source.subscribe(to);</span>

<span class="fc" id="L1057">        to.assertValues(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);</span>
<span class="fc" id="L1058">        to.assertNotComplete();</span>
<span class="fc" id="L1059">        Assert.assertEquals(1, to.errors().size());</span>

<span class="fc" id="L1061">        TestObserver&lt;Integer&gt; to2 = new TestObserver&lt;Integer&gt;();</span>
<span class="fc" id="L1062">        source.subscribe(to2);</span>

<span class="fc" id="L1064">        to2.assertValues(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);</span>
<span class="fc" id="L1065">        to2.assertNotComplete();</span>
<span class="fc" id="L1066">        Assert.assertEquals(1, to2.errors().size());</span>
<span class="fc" id="L1067">    }</span>

    @Test
    @Ignore(&quot;onNext should not throw&quot;)
    public void unsafeChildThrows() {
<span class="nc" id="L1072">        final AtomicInteger count = new AtomicInteger();</span>

<span class="nc" id="L1074">        Observable&lt;Integer&gt; source = Observable.range(1, 100)</span>
<span class="nc" id="L1075">        .doOnNext(new Consumer&lt;Integer&gt;() {</span>
            @Override
            public void accept(Integer t) {
<span class="nc" id="L1078">                count.getAndIncrement();</span>
<span class="nc" id="L1079">            }</span>
        })
<span class="nc" id="L1081">        .replay().autoConnect();</span>

<span class="nc" id="L1083">        TestObserver&lt;Integer&gt; to = new TestObserver&lt;Integer&gt;() {</span>
            @Override
            public void onNext(Integer t) {
<span class="nc" id="L1086">                throw new TestException();</span>
            }
        };

<span class="nc" id="L1090">        source.subscribe(to);</span>

<span class="nc" id="L1092">        Assert.assertEquals(100, count.get());</span>

<span class="nc" id="L1094">        to.assertNoValues();</span>
<span class="nc" id="L1095">        to.assertNotComplete();</span>
<span class="nc" id="L1096">        to.assertError(TestException.class);</span>
<span class="nc" id="L1097">    }</span>

    @Test
    public void replayScheduler() {

<span class="fc" id="L1102">        Observable.just(1).replay(Schedulers.computation())</span>
<span class="fc" id="L1103">        .autoConnect()</span>
<span class="fc" id="L1104">        .test()</span>
<span class="fc" id="L1105">        .awaitDone(5, TimeUnit.SECONDS)</span>
<span class="fc" id="L1106">        .assertResult(1);</span>
<span class="fc" id="L1107">    }</span>

    @Test
    public void replayTime() {
<span class="fc" id="L1111">        Observable.just(1).replay(1, TimeUnit.MINUTES)</span>
<span class="fc" id="L1112">        .autoConnect()</span>
<span class="fc" id="L1113">        .test()</span>
<span class="fc" id="L1114">        .awaitDone(5, TimeUnit.SECONDS)</span>
<span class="fc" id="L1115">        .assertResult(1);</span>
<span class="fc" id="L1116">    }</span>

    @Test
    public void replaySizeScheduler() {

<span class="fc" id="L1121">        Observable.just(1).replay(1, Schedulers.computation())</span>
<span class="fc" id="L1122">        .autoConnect()</span>
<span class="fc" id="L1123">        .test()</span>
<span class="fc" id="L1124">        .awaitDone(5, TimeUnit.SECONDS)</span>
<span class="fc" id="L1125">        .assertResult(1);</span>
<span class="fc" id="L1126">    }</span>

    @Test
    public void replaySizeAndTime() {
<span class="fc" id="L1130">        Observable.just(1).replay(1, 1, TimeUnit.MILLISECONDS)</span>
<span class="fc" id="L1131">        .autoConnect()</span>
<span class="fc" id="L1132">        .test()</span>
<span class="fc" id="L1133">        .awaitDone(5, TimeUnit.SECONDS)</span>
<span class="fc" id="L1134">        .assertResult(1);</span>
<span class="fc" id="L1135">    }</span>

    @Test
    public void replaySelectorSizeScheduler() {
<span class="fc" id="L1139">        Observable.just(1).replay(Functions.&lt;Observable&lt;Integer&gt;&gt;identity(), 1, Schedulers.io())</span>
<span class="fc" id="L1140">        .test()</span>
<span class="fc" id="L1141">        .awaitDone(5, TimeUnit.SECONDS)</span>
<span class="fc" id="L1142">        .assertResult(1);</span>
<span class="fc" id="L1143">    }</span>

    @Test
    public void replaySelectorScheduler() {
<span class="fc" id="L1147">        Observable.just(1).replay(Functions.&lt;Observable&lt;Integer&gt;&gt;identity(), Schedulers.io())</span>
<span class="fc" id="L1148">        .test()</span>
<span class="fc" id="L1149">        .awaitDone(5, TimeUnit.SECONDS)</span>
<span class="fc" id="L1150">        .assertResult(1);</span>
<span class="fc" id="L1151">    }</span>

    @Test
    public void replaySelectorTime() {
<span class="fc" id="L1155">        Observable.just(1).replay(Functions.&lt;Observable&lt;Integer&gt;&gt;identity(), 1, TimeUnit.MINUTES)</span>
<span class="fc" id="L1156">        .test()</span>
<span class="fc" id="L1157">        .awaitDone(5, TimeUnit.SECONDS)</span>
<span class="fc" id="L1158">        .assertResult(1);</span>
<span class="fc" id="L1159">    }</span>

    @Test
    public void replayMaxInt() {
<span class="fc" id="L1163">        Observable.range(1, 2)</span>
<span class="fc" id="L1164">        .replay(Integer.MAX_VALUE)</span>
<span class="fc" id="L1165">        .autoConnect()</span>
<span class="fc" id="L1166">        .test()</span>
<span class="fc" id="L1167">        .assertResult(1, 2);</span>
<span class="fc" id="L1168">    }</span>

    @Test
    public void source() {
<span class="fc" id="L1172">        Observable&lt;Integer&gt; source = Observable.range(1, 3);</span>

<span class="fc" id="L1174">        assertSame(source, (((HasUpstreamObservableSource&lt;?&gt;)source.replay())).source());</span>
<span class="fc" id="L1175">    }</span>

    @Test
    public void connectRace() {
<span class="fc bfc" id="L1179" title="All 2 branches covered.">        for (int i = 0; i &lt; TestHelper.RACE_DEFAULT_LOOPS; i++) {</span>
<span class="fc" id="L1180">            final ConnectableObservable&lt;Integer&gt; co = Observable.range(1, 3).replay();</span>

<span class="fc" id="L1182">            Runnable r = new Runnable() {</span>
                @Override
                public void run() {
<span class="fc" id="L1185">                    co.connect();</span>
<span class="fc" id="L1186">                }</span>
            };

<span class="fc" id="L1189">            TestHelper.race(r, r);</span>
        }
<span class="fc" id="L1191">    }</span>

    @Test
    public void subscribeRace() {
<span class="fc bfc" id="L1195" title="All 2 branches covered.">        for (int i = 0; i &lt; TestHelper.RACE_DEFAULT_LOOPS; i++) {</span>
<span class="fc" id="L1196">            final ConnectableObservable&lt;Integer&gt; co = Observable.range(1, 3).replay();</span>

<span class="fc" id="L1198">            final TestObserver&lt;Integer&gt; to1 = new TestObserver&lt;Integer&gt;();</span>
<span class="fc" id="L1199">            final TestObserver&lt;Integer&gt; to2 = new TestObserver&lt;Integer&gt;();</span>

<span class="fc" id="L1201">            Runnable r1 = new Runnable() {</span>
                @Override
                public void run() {
<span class="fc" id="L1204">                    co.subscribe(to1);</span>
<span class="fc" id="L1205">                }</span>
            };

<span class="fc" id="L1208">            Runnable r2 = new Runnable() {</span>
                @Override
                public void run() {
<span class="fc" id="L1211">                    co.subscribe(to2);</span>
<span class="fc" id="L1212">                }</span>
            };

<span class="fc" id="L1215">            TestHelper.race(r1, r2);</span>
        }
<span class="fc" id="L1217">    }</span>

    @Test
    public void addRemoveRace() {
<span class="fc bfc" id="L1221" title="All 2 branches covered.">        for (int i = 0; i &lt; TestHelper.RACE_DEFAULT_LOOPS; i++) {</span>
<span class="fc" id="L1222">            final ConnectableObservable&lt;Integer&gt; co = Observable.range(1, 3).replay();</span>

<span class="fc" id="L1224">            final TestObserver&lt;Integer&gt; to1 = new TestObserver&lt;Integer&gt;();</span>
<span class="fc" id="L1225">            final TestObserver&lt;Integer&gt; to2 = new TestObserver&lt;Integer&gt;();</span>

<span class="fc" id="L1227">            co.subscribe(to1);</span>

<span class="fc" id="L1229">            Runnable r1 = new Runnable() {</span>
                @Override
                public void run() {
<span class="fc" id="L1232">                    to1.cancel();</span>
<span class="fc" id="L1233">                }</span>
            };

<span class="fc" id="L1236">            Runnable r2 = new Runnable() {</span>
                @Override
                public void run() {
<span class="fc" id="L1239">                    co.subscribe(to2);</span>
<span class="fc" id="L1240">                }</span>
            };

<span class="fc" id="L1243">            TestHelper.race(r1, r2);</span>
        }
<span class="fc" id="L1245">    }</span>

    @Test
    public void cancelOnArrival() {
<span class="fc" id="L1249">        Observable.range(1, 2)</span>
<span class="fc" id="L1250">        .replay(Integer.MAX_VALUE)</span>
<span class="fc" id="L1251">        .autoConnect()</span>
<span class="fc" id="L1252">        .test(true)</span>
<span class="fc" id="L1253">        .assertEmpty();</span>
<span class="fc" id="L1254">    }</span>

    @Test
    public void cancelOnArrival2() {
<span class="fc" id="L1258">        ConnectableObservable&lt;Integer&gt; co = PublishSubject.&lt;Integer&gt;create()</span>
<span class="fc" id="L1259">        .replay(Integer.MAX_VALUE);</span>

<span class="fc" id="L1261">        co.test();</span>

<span class="fc" id="L1263">        co</span>
<span class="fc" id="L1264">        .autoConnect()</span>
<span class="fc" id="L1265">        .test(true)</span>
<span class="fc" id="L1266">        .assertEmpty();</span>
<span class="fc" id="L1267">    }</span>

    @Test
    public void connectConsumerThrows() {
<span class="fc" id="L1271">        ConnectableObservable&lt;Integer&gt; co = Observable.range(1, 2)</span>
<span class="fc" id="L1272">        .replay();</span>

        try {
<span class="pc" id="L1275">            co.connect(new Consumer&lt;Disposable&gt;() {</span>
                @Override
                public void accept(Disposable t) throws Exception {
<span class="fc" id="L1278">                    throw new TestException();</span>
                }
            });
<span class="nc" id="L1281">            fail(&quot;Should have thrown&quot;);</span>
<span class="fc" id="L1282">        } catch (TestException ex) {</span>
            // expected
<span class="nc" id="L1284">        }</span>

<span class="fc" id="L1286">        co.test().assertEmpty().cancel();</span>

<span class="fc" id="L1288">        co.connect();</span>

<span class="fc" id="L1290">        co.test().assertResult(1, 2);</span>
<span class="fc" id="L1291">    }</span>

    @Test
    public void badSource() {
<span class="fc" id="L1295">        List&lt;Throwable&gt; errors = TestHelper.trackPluginErrors();</span>
        try {
<span class="fc" id="L1297">            new Observable&lt;Integer&gt;() {</span>
                @Override
                protected void subscribeActual(Observer&lt;? super Integer&gt; observer) {
<span class="fc" id="L1300">                    observer.onSubscribe(Disposables.empty());</span>
<span class="fc" id="L1301">                    observer.onError(new TestException(&quot;First&quot;));</span>
<span class="fc" id="L1302">                    observer.onNext(1);</span>
<span class="fc" id="L1303">                    observer.onError(new TestException(&quot;Second&quot;));</span>
<span class="fc" id="L1304">                    observer.onComplete();</span>
<span class="fc" id="L1305">                }</span>
<span class="fc" id="L1306">            }.replay()</span>
<span class="fc" id="L1307">            .autoConnect()</span>
<span class="fc" id="L1308">            .test()</span>
<span class="fc" id="L1309">            .assertFailureAndMessage(TestException.class, &quot;First&quot;);</span>

<span class="fc" id="L1311">            TestHelper.assertUndeliverable(errors, 0, TestException.class, &quot;Second&quot;);</span>
        } finally {
<span class="fc" id="L1313">            RxJavaPlugins.reset();</span>
        }
<span class="fc" id="L1315">    }</span>

    @Test
    public void subscribeOnNextRace() {
<span class="fc bfc" id="L1319" title="All 2 branches covered.">        for (int i = 0; i &lt; TestHelper.RACE_DEFAULT_LOOPS; i++) {</span>
<span class="fc" id="L1320">            final PublishSubject&lt;Integer&gt; ps = PublishSubject.create();</span>

<span class="fc" id="L1322">            final ConnectableObservable&lt;Integer&gt; co = ps.replay();</span>

<span class="fc" id="L1324">            final TestObserver&lt;Integer&gt; to1 = new TestObserver&lt;Integer&gt;();</span>

<span class="fc" id="L1326">            Runnable r1 = new Runnable() {</span>
                @Override
                public void run() {
<span class="fc" id="L1329">                    co.subscribe(to1);</span>
<span class="fc" id="L1330">                }</span>
            };

<span class="fc" id="L1333">            Runnable r2 = new Runnable() {</span>
                @Override
                public void run() {
<span class="fc bfc" id="L1336" title="All 2 branches covered.">                    for (int j = 0; j &lt; 1000; j++) {</span>
<span class="fc" id="L1337">                        ps.onNext(j);</span>
                    }
<span class="fc" id="L1339">                }</span>
            };

<span class="fc" id="L1342">            TestHelper.race(r1, r2);</span>
        }
<span class="fc" id="L1344">    }</span>

    @Test
    public void unsubscribeOnNextRace() {
<span class="fc bfc" id="L1348" title="All 2 branches covered.">        for (int i = 0; i &lt; TestHelper.RACE_DEFAULT_LOOPS; i++) {</span>
<span class="fc" id="L1349">            final PublishSubject&lt;Integer&gt; ps = PublishSubject.create();</span>

<span class="fc" id="L1351">            final ConnectableObservable&lt;Integer&gt; co = ps.replay();</span>

<span class="fc" id="L1353">            final TestObserver&lt;Integer&gt; to1 = new TestObserver&lt;Integer&gt;();</span>

<span class="fc" id="L1355">            co.subscribe(to1);</span>

<span class="fc" id="L1357">            Runnable r1 = new Runnable() {</span>
                @Override
                public void run() {
<span class="fc" id="L1360">                    to1.dispose();</span>
<span class="fc" id="L1361">                }</span>
            };

<span class="fc" id="L1364">            Runnable r2 = new Runnable() {</span>
                @Override
                public void run() {
<span class="fc bfc" id="L1367" title="All 2 branches covered.">                    for (int j = 0; j &lt; 1000; j++) {</span>
<span class="fc" id="L1368">                        ps.onNext(j);</span>
                    }
<span class="fc" id="L1370">                }</span>
            };

<span class="fc" id="L1373">            TestHelper.race(r1, r2);</span>
        }
<span class="fc" id="L1375">    }</span>

    @Test
    public void unsubscribeReplayRace() {
<span class="fc bfc" id="L1379" title="All 2 branches covered.">        for (int i = 0; i &lt; TestHelper.RACE_DEFAULT_LOOPS; i++) {</span>
<span class="fc" id="L1380">            final ConnectableObservable&lt;Integer&gt; co = Observable.range(1, 1000).replay();</span>

<span class="fc" id="L1382">            final TestObserver&lt;Integer&gt; to1 = new TestObserver&lt;Integer&gt;();</span>

<span class="fc" id="L1384">            co.connect();</span>

<span class="fc" id="L1386">            Runnable r1 = new Runnable() {</span>
                @Override
                public void run() {
<span class="fc" id="L1389">                    co.subscribe(to1);</span>
<span class="fc" id="L1390">                }</span>
            };

<span class="fc" id="L1393">            Runnable r2 = new Runnable() {</span>
                @Override
                public void run() {
<span class="fc" id="L1396">                    to1.dispose();</span>
<span class="fc" id="L1397">                }</span>
            };

<span class="fc" id="L1400">            TestHelper.race(r1, r2);</span>
        }
<span class="fc" id="L1402">    }</span>

    @Test
    public void reentrantOnNext() {
<span class="fc" id="L1406">        final PublishSubject&lt;Integer&gt; ps = PublishSubject.create();</span>

<span class="fc" id="L1408">        TestObserver&lt;Integer&gt; to = new TestObserver&lt;Integer&gt;() {</span>
            @Override
            public void onNext(Integer t) {
<span class="fc bfc" id="L1411" title="All 2 branches covered.">                if (t == 1) {</span>
<span class="fc" id="L1412">                    ps.onNext(2);</span>
<span class="fc" id="L1413">                    ps.onComplete();</span>
                }
<span class="fc" id="L1415">                super.onNext(t);</span>
<span class="fc" id="L1416">            }</span>
        };

<span class="fc" id="L1419">        ps.replay().autoConnect().subscribe(to);</span>

<span class="fc" id="L1421">        ps.onNext(1);</span>

<span class="fc" id="L1423">        to.assertResult(1, 2);</span>
<span class="fc" id="L1424">    }</span>

    @Test
    public void reentrantOnNextBound() {
<span class="fc" id="L1428">        final PublishSubject&lt;Integer&gt; ps = PublishSubject.create();</span>

<span class="fc" id="L1430">        TestObserver&lt;Integer&gt; to = new TestObserver&lt;Integer&gt;() {</span>
            @Override
            public void onNext(Integer t) {
<span class="fc bfc" id="L1433" title="All 2 branches covered.">                if (t == 1) {</span>
<span class="fc" id="L1434">                    ps.onNext(2);</span>
<span class="fc" id="L1435">                    ps.onComplete();</span>
                }
<span class="fc" id="L1437">                super.onNext(t);</span>
<span class="fc" id="L1438">            }</span>
        };

<span class="fc" id="L1441">        ps.replay(10).autoConnect().subscribe(to);</span>

<span class="fc" id="L1443">        ps.onNext(1);</span>

<span class="fc" id="L1445">        to.assertResult(1, 2);</span>
<span class="fc" id="L1446">    }</span>

    @Test
    public void reentrantOnNextCancel() {
<span class="fc" id="L1450">        final PublishSubject&lt;Integer&gt; ps = PublishSubject.create();</span>

<span class="fc" id="L1452">        TestObserver&lt;Integer&gt; to = new TestObserver&lt;Integer&gt;() {</span>
            @Override
            public void onNext(Integer t) {
<span class="pc bpc" id="L1455" title="1 of 2 branches missed.">                if (t == 1) {</span>
<span class="fc" id="L1456">                    ps.onNext(2);</span>
<span class="fc" id="L1457">                    cancel();</span>
                }
<span class="fc" id="L1459">                super.onNext(t);</span>
<span class="fc" id="L1460">            }</span>
        };

<span class="fc" id="L1463">        ps.replay().autoConnect().subscribe(to);</span>

<span class="fc" id="L1465">        ps.onNext(1);</span>

<span class="fc" id="L1467">        to.assertValues(1);</span>
<span class="fc" id="L1468">    }</span>

    @Test
    public void reentrantOnNextCancelBounded() {
<span class="fc" id="L1472">        final PublishSubject&lt;Integer&gt; ps = PublishSubject.create();</span>

<span class="fc" id="L1474">        TestObserver&lt;Integer&gt; to = new TestObserver&lt;Integer&gt;() {</span>
            @Override
            public void onNext(Integer t) {
<span class="pc bpc" id="L1477" title="1 of 2 branches missed.">                if (t == 1) {</span>
<span class="fc" id="L1478">                    ps.onNext(2);</span>
<span class="fc" id="L1479">                    cancel();</span>
                }
<span class="fc" id="L1481">                super.onNext(t);</span>
<span class="fc" id="L1482">            }</span>
        };

<span class="fc" id="L1485">        ps.replay(10).autoConnect().subscribe(to);</span>

<span class="fc" id="L1487">        ps.onNext(1);</span>

<span class="fc" id="L1489">        to.assertValues(1);</span>
<span class="fc" id="L1490">    }</span>

    @Test
    public void delayedUpstreamOnSubscribe() {
<span class="fc" id="L1494">        final Observer&lt;?&gt;[] sub = { null };</span>

<span class="fc" id="L1496">        new Observable&lt;Integer&gt;() {</span>
            @Override
            protected void subscribeActual(Observer&lt;? super Integer&gt; observer) {
<span class="fc" id="L1499">                sub[0] = observer;</span>
<span class="fc" id="L1500">            }</span>
        }
<span class="fc" id="L1502">        .replay()</span>
<span class="fc" id="L1503">        .connect()</span>
<span class="fc" id="L1504">        .dispose();</span>

<span class="fc" id="L1506">        Disposable bs = Disposables.empty();</span>

<span class="fc" id="L1508">        sub[0].onSubscribe(bs);</span>

<span class="fc" id="L1510">        assertTrue(bs.isDisposed());</span>
<span class="fc" id="L1511">    }</span>

    @Test
    public void timedNoOutdatedData() {
<span class="fc" id="L1515">        TestScheduler scheduler = new TestScheduler();</span>

<span class="fc" id="L1517">        Observable&lt;Integer&gt; source = Observable.just(1)</span>
<span class="fc" id="L1518">                .replay(2, TimeUnit.SECONDS, scheduler)</span>
<span class="fc" id="L1519">                .autoConnect();</span>

<span class="fc" id="L1521">        source.test().assertResult(1);</span>

<span class="fc" id="L1523">        source.test().assertResult(1);</span>

<span class="fc" id="L1525">        scheduler.advanceTimeBy(3, TimeUnit.SECONDS);</span>

<span class="fc" id="L1527">        source.test().assertResult();</span>
<span class="fc" id="L1528">    }</span>

    @Test
    public void replaySelectorReturnsNullScheduled() {
<span class="fc" id="L1532">        Observable.just(1)</span>
<span class="fc" id="L1533">        .replay(new Function&lt;Observable&lt;Integer&gt;, Observable&lt;Object&gt;&gt;() {</span>
            @Override
            public Observable&lt;Object&gt; apply(Observable&lt;Integer&gt; v) throws Exception {
<span class="fc" id="L1536">                return null;</span>
            }
<span class="fc" id="L1538">        }, Schedulers.trampoline())</span>
<span class="fc" id="L1539">        .test()</span>
<span class="fc" id="L1540">        .assertFailureAndMessage(NullPointerException.class, &quot;The selector returned a null ObservableSource&quot;);</span>
<span class="fc" id="L1541">    }</span>

    @Test
    public void replaySelectorReturnsNull() {
<span class="fc" id="L1545">        Observable.just(1)</span>
<span class="fc" id="L1546">        .replay(new Function&lt;Observable&lt;Integer&gt;, Observable&lt;Object&gt;&gt;() {</span>
            @Override
            public Observable&lt;Object&gt; apply(Observable&lt;Integer&gt; v) throws Exception {
<span class="fc" id="L1549">                return null;</span>
            }
        })
<span class="fc" id="L1552">        .test()</span>
<span class="fc" id="L1553">        .assertFailureAndMessage(NullPointerException.class, &quot;The selector returned a null ObservableSource&quot;);</span>
<span class="fc" id="L1554">    }</span>

    @Test
    public void replaySelectorConnectableReturnsNull() {
<span class="fc" id="L1558">        ObservableReplay.multicastSelector(Functions.justCallable((ConnectableObservable&lt;Integer&gt;)null), Functions.justFunction(Observable.just(1)))</span>
<span class="fc" id="L1559">        .test()</span>
<span class="fc" id="L1560">        .assertFailureAndMessage(NullPointerException.class, &quot;The connectableFactory returned a null ConnectableObservable&quot;);</span>
<span class="fc" id="L1561">    }</span>

    @Test
    public void noHeadRetentionCompleteSize() {
<span class="fc" id="L1565">        PublishSubject&lt;Integer&gt; source = PublishSubject.create();</span>

<span class="fc" id="L1567">        ObservableReplay&lt;Integer&gt; co = (ObservableReplay&lt;Integer&gt;)source</span>
<span class="fc" id="L1568">                .replay(1);</span>

<span class="fc" id="L1570">        co.connect();</span>

<span class="fc" id="L1572">        BoundedReplayBuffer&lt;Integer&gt; buf = (BoundedReplayBuffer&lt;Integer&gt;)(co.current.get().buffer);</span>

<span class="fc" id="L1574">        source.onNext(1);</span>
<span class="fc" id="L1575">        source.onNext(2);</span>
<span class="fc" id="L1576">        source.onComplete();</span>

<span class="fc" id="L1578">        assertNull(buf.get().value);</span>

<span class="fc" id="L1580">        Object o = buf.get();</span>

<span class="fc" id="L1582">        buf.trimHead();</span>

<span class="fc" id="L1584">        assertSame(o, buf.get());</span>
<span class="fc" id="L1585">    }</span>

    @Test
    public void noHeadRetentionErrorSize() {
<span class="fc" id="L1589">        PublishSubject&lt;Integer&gt; source = PublishSubject.create();</span>

<span class="fc" id="L1591">        ObservableReplay&lt;Integer&gt; co = (ObservableReplay&lt;Integer&gt;)source</span>
<span class="fc" id="L1592">                .replay(1);</span>

<span class="fc" id="L1594">        co.connect();</span>

<span class="fc" id="L1596">        BoundedReplayBuffer&lt;Integer&gt; buf = (BoundedReplayBuffer&lt;Integer&gt;)(co.current.get().buffer);</span>

<span class="fc" id="L1598">        source.onNext(1);</span>
<span class="fc" id="L1599">        source.onNext(2);</span>
<span class="fc" id="L1600">        source.onError(new TestException());</span>

<span class="fc" id="L1602">        assertNull(buf.get().value);</span>

<span class="fc" id="L1604">        Object o = buf.get();</span>

<span class="fc" id="L1606">        buf.trimHead();</span>

<span class="fc" id="L1608">        assertSame(o, buf.get());</span>
<span class="fc" id="L1609">    }</span>

    @Test
    public void noHeadRetentionSize() {
<span class="fc" id="L1613">        PublishSubject&lt;Integer&gt; source = PublishSubject.create();</span>

<span class="fc" id="L1615">        ObservableReplay&lt;Integer&gt; co = (ObservableReplay&lt;Integer&gt;)source</span>
<span class="fc" id="L1616">                .replay(1);</span>

<span class="fc" id="L1618">        co.connect();</span>

<span class="fc" id="L1620">        BoundedReplayBuffer&lt;Integer&gt; buf = (BoundedReplayBuffer&lt;Integer&gt;)(co.current.get().buffer);</span>

<span class="fc" id="L1622">        source.onNext(1);</span>
<span class="fc" id="L1623">        source.onNext(2);</span>

<span class="fc" id="L1625">        assertNotNull(buf.get().value);</span>

<span class="fc" id="L1627">        buf.trimHead();</span>

<span class="fc" id="L1629">        assertNull(buf.get().value);</span>

<span class="fc" id="L1631">        Object o = buf.get();</span>

<span class="fc" id="L1633">        buf.trimHead();</span>

<span class="fc" id="L1635">        assertSame(o, buf.get());</span>
<span class="fc" id="L1636">    }</span>

    @Test
    public void noHeadRetentionCompleteTime() {
<span class="fc" id="L1640">        PublishSubject&lt;Integer&gt; source = PublishSubject.create();</span>

<span class="fc" id="L1642">        ObservableReplay&lt;Integer&gt; co = (ObservableReplay&lt;Integer&gt;)source</span>
<span class="fc" id="L1643">                .replay(1, TimeUnit.MINUTES, Schedulers.computation());</span>

<span class="fc" id="L1645">        co.connect();</span>

<span class="fc" id="L1647">        BoundedReplayBuffer&lt;Integer&gt; buf = (BoundedReplayBuffer&lt;Integer&gt;)(co.current.get().buffer);</span>

<span class="fc" id="L1649">        source.onNext(1);</span>
<span class="fc" id="L1650">        source.onNext(2);</span>
<span class="fc" id="L1651">        source.onComplete();</span>

<span class="fc" id="L1653">        assertNull(buf.get().value);</span>

<span class="fc" id="L1655">        Object o = buf.get();</span>

<span class="fc" id="L1657">        buf.trimHead();</span>

<span class="fc" id="L1659">        assertSame(o, buf.get());</span>
<span class="fc" id="L1660">    }</span>

    @Test
    public void noHeadRetentionErrorTime() {
<span class="fc" id="L1664">        PublishSubject&lt;Integer&gt; source = PublishSubject.create();</span>

<span class="fc" id="L1666">        ObservableReplay&lt;Integer&gt; co = (ObservableReplay&lt;Integer&gt;)source</span>
<span class="fc" id="L1667">                .replay(1, TimeUnit.MINUTES, Schedulers.computation());</span>

<span class="fc" id="L1669">        co.connect();</span>

<span class="fc" id="L1671">        BoundedReplayBuffer&lt;Integer&gt; buf = (BoundedReplayBuffer&lt;Integer&gt;)(co.current.get().buffer);</span>

<span class="fc" id="L1673">        source.onNext(1);</span>
<span class="fc" id="L1674">        source.onNext(2);</span>
<span class="fc" id="L1675">        source.onError(new TestException());</span>

<span class="fc" id="L1677">        assertNull(buf.get().value);</span>

<span class="fc" id="L1679">        Object o = buf.get();</span>

<span class="fc" id="L1681">        buf.trimHead();</span>

<span class="fc" id="L1683">        assertSame(o, buf.get());</span>
<span class="fc" id="L1684">    }</span>

    @Test
    public void noHeadRetentionTime() {
<span class="fc" id="L1688">        TestScheduler sch = new TestScheduler();</span>

<span class="fc" id="L1690">        PublishSubject&lt;Integer&gt; source = PublishSubject.create();</span>

<span class="fc" id="L1692">        ObservableReplay&lt;Integer&gt; co = (ObservableReplay&lt;Integer&gt;)source</span>
<span class="fc" id="L1693">                .replay(1, TimeUnit.MILLISECONDS, sch);</span>

<span class="fc" id="L1695">        co.connect();</span>

<span class="fc" id="L1697">        BoundedReplayBuffer&lt;Integer&gt; buf = (BoundedReplayBuffer&lt;Integer&gt;)(co.current.get().buffer);</span>

<span class="fc" id="L1699">        source.onNext(1);</span>

<span class="fc" id="L1701">        sch.advanceTimeBy(2, TimeUnit.MILLISECONDS);</span>

<span class="fc" id="L1703">        source.onNext(2);</span>

<span class="fc" id="L1705">        assertNotNull(buf.get().value);</span>

<span class="fc" id="L1707">        buf.trimHead();</span>

<span class="fc" id="L1709">        assertNull(buf.get().value);</span>

<span class="fc" id="L1711">        Object o = buf.get();</span>

<span class="fc" id="L1713">        buf.trimHead();</span>

<span class="fc" id="L1715">        assertSame(o, buf.get());</span>
<span class="fc" id="L1716">    }</span>

    @Test
    public void noBoundedRetentionViaThreadLocal() throws Exception {
<span class="fc" id="L1720">        Observable&lt;byte[]&gt; source = Observable.range(1, 200)</span>
<span class="fc" id="L1721">        .map(new Function&lt;Integer, byte[]&gt;() {</span>
            @Override
            public byte[] apply(Integer v) throws Exception {
<span class="fc" id="L1724">                return new byte[1024 * 1024];</span>
            }
        })
<span class="fc" id="L1727">        .replay(new Function&lt;Observable&lt;byte[]&gt;, Observable&lt;byte[]&gt;&gt;() {</span>
            @Override
            public Observable&lt;byte[]&gt; apply(final Observable&lt;byte[]&gt; o) throws Exception {
<span class="fc" id="L1730">                return o.take(1)</span>
<span class="fc" id="L1731">                .concatMap(new Function&lt;byte[], Observable&lt;byte[]&gt;&gt;() {</span>
                    @Override
                    public Observable&lt;byte[]&gt; apply(byte[] v) throws Exception {
<span class="fc" id="L1734">                        return o;</span>
                    }
                });
            }
        }, 1)
<span class="fc" id="L1739">        .takeLast(1)</span>
        ;

<span class="fc" id="L1742">        System.out.println(&quot;Bounded Replay Leak check: Wait before GC&quot;);</span>
<span class="fc" id="L1743">        Thread.sleep(1000);</span>

<span class="fc" id="L1745">        System.out.println(&quot;Bounded Replay Leak check: GC&quot;);</span>
<span class="fc" id="L1746">        System.gc();</span>

<span class="fc" id="L1748">        Thread.sleep(500);</span>

<span class="fc" id="L1750">        final MemoryMXBean memoryMXBean = ManagementFactory.getMemoryMXBean();</span>
<span class="fc" id="L1751">        MemoryUsage memHeap = memoryMXBean.getHeapMemoryUsage();</span>
<span class="fc" id="L1752">        long initial = memHeap.getUsed();</span>

<span class="fc" id="L1754">        System.out.printf(&quot;Bounded Replay Leak check: Starting: %.3f MB%n&quot;, initial / 1024.0 / 1024.0);</span>

<span class="fc" id="L1756">        final AtomicLong after = new AtomicLong();</span>

<span class="fc" id="L1758">        source.subscribe(new Consumer&lt;byte[]&gt;() {</span>
            @Override
            public void accept(byte[] v) throws Exception {
<span class="fc" id="L1761">                System.out.println(&quot;Bounded Replay Leak check: Wait before GC 2&quot;);</span>
<span class="fc" id="L1762">                Thread.sleep(1000);</span>

<span class="fc" id="L1764">                System.out.println(&quot;Bounded Replay Leak check:  GC 2&quot;);</span>
<span class="fc" id="L1765">                System.gc();</span>

<span class="fc" id="L1767">                Thread.sleep(500);</span>

<span class="fc" id="L1769">                after.set(memoryMXBean.getHeapMemoryUsage().getUsed());</span>
<span class="fc" id="L1770">            }</span>
        });

<span class="fc" id="L1773">        System.out.printf(&quot;Bounded Replay Leak check: After: %.3f MB%n&quot;, after.get() / 1024.0 / 1024.0);</span>

<span class="pc bpc" id="L1775" title="1 of 2 branches missed.">        if (initial + 100 * 1024 * 1024 &lt; after.get()) {</span>
<span class="nc" id="L1776">            Assert.fail(&quot;Bounded Replay Leak check: Memory leak detected: &quot; + (initial / 1024.0 / 1024.0)</span>
<span class="nc" id="L1777">                    + &quot; -&gt; &quot; + after.get() / 1024.0 / 1024.0);</span>
        }
<span class="fc" id="L1779">    }}</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>