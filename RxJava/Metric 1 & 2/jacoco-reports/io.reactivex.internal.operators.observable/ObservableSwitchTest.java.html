<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ObservableSwitchTest.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">RxJava_2_x$Unnamed.exec</a> &gt; <a href="index.source.html" class="el_package">io.reactivex.internal.operators.observable</a> &gt; <span class="el_source">ObservableSwitchTest.java</span></div><h1>ObservableSwitchTest.java</h1><pre class="source lang-java linenums">/**
 * Copyright (c) 2016-present, RxJava Contributors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is
 * distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
 * the License for the specific language governing permissions and limitations under the License.
 */

package io.reactivex.internal.operators.observable;

import static org.junit.Assert.*;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;

import java.util.List;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.*;

import org.junit.*;
import org.mockito.InOrder;

import io.reactivex.*;
import io.reactivex.disposables.*;
import io.reactivex.exceptions.*;
import io.reactivex.functions.*;
import io.reactivex.internal.functions.Functions;
import io.reactivex.internal.schedulers.ImmediateThinScheduler;
import io.reactivex.internal.util.ExceptionHelper;
import io.reactivex.observers.TestObserver;
import io.reactivex.plugins.RxJavaPlugins;
import io.reactivex.schedulers.*;
import io.reactivex.subjects.*;

<span class="fc" id="L39">public class ObservableSwitchTest {</span>

    private TestScheduler scheduler;
    private Scheduler.Worker innerScheduler;
    private Observer&lt;String&gt; observer;

    @Before
    public void before() {
<span class="fc" id="L47">        scheduler = new TestScheduler();</span>
<span class="fc" id="L48">        innerScheduler = scheduler.createWorker();</span>
<span class="fc" id="L49">        observer = TestHelper.mockObserver();</span>
<span class="fc" id="L50">    }</span>

    @Test
    public void testSwitchWhenOuterCompleteBeforeInner() {
<span class="fc" id="L54">        Observable&lt;Observable&lt;String&gt;&gt; source = Observable.unsafeCreate(new ObservableSource&lt;Observable&lt;String&gt;&gt;() {</span>
            @Override
            public void subscribe(Observer&lt;? super Observable&lt;String&gt;&gt; outerObserver) {
<span class="fc" id="L57">                outerObserver.onSubscribe(Disposables.empty());</span>
<span class="fc" id="L58">                publishNext(outerObserver, 50, Observable.unsafeCreate(new ObservableSource&lt;String&gt;() {</span>
                    @Override
                    public void subscribe(Observer&lt;? super String&gt; innerObserver) {
<span class="fc" id="L61">                        innerObserver.onSubscribe(Disposables.empty());</span>
<span class="fc" id="L62">                        publishNext(innerObserver, 70, &quot;one&quot;);</span>
<span class="fc" id="L63">                        publishNext(innerObserver, 100, &quot;two&quot;);</span>
<span class="fc" id="L64">                        publishCompleted(innerObserver, 200);</span>
<span class="fc" id="L65">                    }</span>
                }));
<span class="fc" id="L67">                publishCompleted(outerObserver, 60);</span>
<span class="fc" id="L68">            }</span>
        });

<span class="fc" id="L71">        Observable&lt;String&gt; sampled = Observable.switchOnNext(source);</span>
<span class="fc" id="L72">        sampled.subscribe(observer);</span>

<span class="fc" id="L74">        InOrder inOrder = inOrder(observer);</span>

<span class="fc" id="L76">        scheduler.advanceTimeTo(350, TimeUnit.MILLISECONDS);</span>
<span class="fc" id="L77">        inOrder.verify(observer, times(2)).onNext(anyString());</span>
<span class="fc" id="L78">        inOrder.verify(observer, times(1)).onComplete();</span>
<span class="fc" id="L79">    }</span>

    @Test
    public void testSwitchWhenInnerCompleteBeforeOuter() {
<span class="fc" id="L83">        Observable&lt;Observable&lt;String&gt;&gt; source = Observable.unsafeCreate(new ObservableSource&lt;Observable&lt;String&gt;&gt;() {</span>
            @Override
            public void subscribe(Observer&lt;? super Observable&lt;String&gt;&gt; outerObserver) {
<span class="fc" id="L86">                outerObserver.onSubscribe(Disposables.empty());</span>
<span class="fc" id="L87">                publishNext(outerObserver, 10, Observable.unsafeCreate(new ObservableSource&lt;String&gt;() {</span>
                    @Override
                    public void subscribe(Observer&lt;? super String&gt; innerObserver) {
<span class="fc" id="L90">                        innerObserver.onSubscribe(Disposables.empty());</span>
<span class="fc" id="L91">                        publishNext(innerObserver, 0, &quot;one&quot;);</span>
<span class="fc" id="L92">                        publishNext(innerObserver, 10, &quot;two&quot;);</span>
<span class="fc" id="L93">                        publishCompleted(innerObserver, 20);</span>
<span class="fc" id="L94">                    }</span>
                }));

<span class="fc" id="L97">                publishNext(outerObserver, 100, Observable.unsafeCreate(new ObservableSource&lt;String&gt;() {</span>
                    @Override
                    public void subscribe(Observer&lt;? super String&gt; innerObserver) {
<span class="fc" id="L100">                        innerObserver.onSubscribe(Disposables.empty());</span>
<span class="fc" id="L101">                        publishNext(innerObserver, 0, &quot;three&quot;);</span>
<span class="fc" id="L102">                        publishNext(innerObserver, 10, &quot;four&quot;);</span>
<span class="fc" id="L103">                        publishCompleted(innerObserver, 20);</span>
<span class="fc" id="L104">                    }</span>
                }));
<span class="fc" id="L106">                publishCompleted(outerObserver, 200);</span>
<span class="fc" id="L107">            }</span>
        });

<span class="fc" id="L110">        Observable&lt;String&gt; sampled = Observable.switchOnNext(source);</span>
<span class="fc" id="L111">        sampled.subscribe(observer);</span>

<span class="fc" id="L113">        InOrder inOrder = inOrder(observer);</span>

<span class="fc" id="L115">        scheduler.advanceTimeTo(150, TimeUnit.MILLISECONDS);</span>
<span class="fc" id="L116">        inOrder.verify(observer, never()).onComplete();</span>
<span class="fc" id="L117">        inOrder.verify(observer, times(1)).onNext(&quot;one&quot;);</span>
<span class="fc" id="L118">        inOrder.verify(observer, times(1)).onNext(&quot;two&quot;);</span>
<span class="fc" id="L119">        inOrder.verify(observer, times(1)).onNext(&quot;three&quot;);</span>
<span class="fc" id="L120">        inOrder.verify(observer, times(1)).onNext(&quot;four&quot;);</span>

<span class="fc" id="L122">        scheduler.advanceTimeTo(250, TimeUnit.MILLISECONDS);</span>
<span class="fc" id="L123">        inOrder.verify(observer, never()).onNext(anyString());</span>
<span class="fc" id="L124">        inOrder.verify(observer, times(1)).onComplete();</span>
<span class="fc" id="L125">    }</span>

    @Test
    public void testSwitchWithComplete() {
<span class="fc" id="L129">        Observable&lt;Observable&lt;String&gt;&gt; source = Observable.unsafeCreate(new ObservableSource&lt;Observable&lt;String&gt;&gt;() {</span>
            @Override
            public void subscribe(Observer&lt;? super Observable&lt;String&gt;&gt; outerObserver) {
<span class="fc" id="L132">                outerObserver.onSubscribe(Disposables.empty());</span>
<span class="fc" id="L133">                publishNext(outerObserver, 50, Observable.unsafeCreate(new ObservableSource&lt;String&gt;() {</span>
                    @Override
                    public void subscribe(final Observer&lt;? super String&gt; innerObserver) {
<span class="fc" id="L136">                        innerObserver.onSubscribe(Disposables.empty());</span>
<span class="fc" id="L137">                        publishNext(innerObserver, 60, &quot;one&quot;);</span>
<span class="fc" id="L138">                        publishNext(innerObserver, 100, &quot;two&quot;);</span>
<span class="fc" id="L139">                    }</span>
                }));

<span class="fc" id="L142">                publishNext(outerObserver, 200, Observable.unsafeCreate(new ObservableSource&lt;String&gt;() {</span>
                    @Override
                    public void subscribe(final Observer&lt;? super String&gt; innerObserver) {
<span class="fc" id="L145">                        innerObserver.onSubscribe(Disposables.empty());</span>
<span class="fc" id="L146">                        publishNext(innerObserver, 0, &quot;three&quot;);</span>
<span class="fc" id="L147">                        publishNext(innerObserver, 100, &quot;four&quot;);</span>
<span class="fc" id="L148">                    }</span>
                }));

<span class="fc" id="L151">                publishCompleted(outerObserver, 250);</span>
<span class="fc" id="L152">            }</span>
        });

<span class="fc" id="L155">        Observable&lt;String&gt; sampled = Observable.switchOnNext(source);</span>
<span class="fc" id="L156">        sampled.subscribe(observer);</span>

<span class="fc" id="L158">        InOrder inOrder = inOrder(observer);</span>

<span class="fc" id="L160">        scheduler.advanceTimeTo(90, TimeUnit.MILLISECONDS);</span>
<span class="fc" id="L161">        inOrder.verify(observer, never()).onNext(anyString());</span>
<span class="fc" id="L162">        verify(observer, never()).onComplete();</span>
<span class="fc" id="L163">        verify(observer, never()).onError(any(Throwable.class));</span>

<span class="fc" id="L165">        scheduler.advanceTimeTo(125, TimeUnit.MILLISECONDS);</span>
<span class="fc" id="L166">        inOrder.verify(observer, times(1)).onNext(&quot;one&quot;);</span>
<span class="fc" id="L167">        verify(observer, never()).onComplete();</span>
<span class="fc" id="L168">        verify(observer, never()).onError(any(Throwable.class));</span>

<span class="fc" id="L170">        scheduler.advanceTimeTo(175, TimeUnit.MILLISECONDS);</span>
<span class="fc" id="L171">        inOrder.verify(observer, times(1)).onNext(&quot;two&quot;);</span>
<span class="fc" id="L172">        verify(observer, never()).onComplete();</span>
<span class="fc" id="L173">        verify(observer, never()).onError(any(Throwable.class));</span>

<span class="fc" id="L175">        scheduler.advanceTimeTo(225, TimeUnit.MILLISECONDS);</span>
<span class="fc" id="L176">        inOrder.verify(observer, times(1)).onNext(&quot;three&quot;);</span>
<span class="fc" id="L177">        verify(observer, never()).onComplete();</span>
<span class="fc" id="L178">        verify(observer, never()).onError(any(Throwable.class));</span>

<span class="fc" id="L180">        scheduler.advanceTimeTo(350, TimeUnit.MILLISECONDS);</span>
<span class="fc" id="L181">        inOrder.verify(observer, times(1)).onNext(&quot;four&quot;);</span>
<span class="fc" id="L182">        verify(observer, never()).onComplete();</span>
<span class="fc" id="L183">        verify(observer, never()).onError(any(Throwable.class));</span>
<span class="fc" id="L184">    }</span>

    @Test
    public void testSwitchWithError() {
<span class="fc" id="L188">        Observable&lt;Observable&lt;String&gt;&gt; source = Observable.unsafeCreate(new ObservableSource&lt;Observable&lt;String&gt;&gt;() {</span>
            @Override
            public void subscribe(Observer&lt;? super Observable&lt;String&gt;&gt; outerObserver) {
<span class="fc" id="L191">                outerObserver.onSubscribe(Disposables.empty());</span>
<span class="fc" id="L192">                publishNext(outerObserver, 50, Observable.unsafeCreate(new ObservableSource&lt;String&gt;() {</span>
                    @Override
                    public void subscribe(final Observer&lt;? super String&gt; innerObserver) {
<span class="fc" id="L195">                        innerObserver.onSubscribe(Disposables.empty());</span>
<span class="fc" id="L196">                        publishNext(innerObserver, 50, &quot;one&quot;);</span>
<span class="fc" id="L197">                        publishNext(innerObserver, 100, &quot;two&quot;);</span>
<span class="fc" id="L198">                    }</span>
                }));

<span class="fc" id="L201">                publishNext(outerObserver, 200, Observable.unsafeCreate(new ObservableSource&lt;String&gt;() {</span>
                    @Override
                    public void subscribe(Observer&lt;? super String&gt; innerObserver) {
<span class="fc" id="L204">                        innerObserver.onSubscribe(Disposables.empty());</span>
<span class="fc" id="L205">                        publishNext(innerObserver, 0, &quot;three&quot;);</span>
<span class="fc" id="L206">                        publishNext(innerObserver, 100, &quot;four&quot;);</span>
<span class="fc" id="L207">                    }</span>
                }));

<span class="fc" id="L210">                publishError(outerObserver, 250, new TestException());</span>
<span class="fc" id="L211">            }</span>
        });

<span class="fc" id="L214">        Observable&lt;String&gt; sampled = Observable.switchOnNext(source);</span>
<span class="fc" id="L215">        sampled.subscribe(observer);</span>

<span class="fc" id="L217">        InOrder inOrder = inOrder(observer);</span>

<span class="fc" id="L219">        scheduler.advanceTimeTo(90, TimeUnit.MILLISECONDS);</span>
<span class="fc" id="L220">        inOrder.verify(observer, never()).onNext(anyString());</span>
<span class="fc" id="L221">        verify(observer, never()).onComplete();</span>
<span class="fc" id="L222">        verify(observer, never()).onError(any(Throwable.class));</span>

<span class="fc" id="L224">        scheduler.advanceTimeTo(125, TimeUnit.MILLISECONDS);</span>
<span class="fc" id="L225">        inOrder.verify(observer, times(1)).onNext(&quot;one&quot;);</span>
<span class="fc" id="L226">        verify(observer, never()).onComplete();</span>
<span class="fc" id="L227">        verify(observer, never()).onError(any(Throwable.class));</span>

<span class="fc" id="L229">        scheduler.advanceTimeTo(175, TimeUnit.MILLISECONDS);</span>
<span class="fc" id="L230">        inOrder.verify(observer, times(1)).onNext(&quot;two&quot;);</span>
<span class="fc" id="L231">        verify(observer, never()).onComplete();</span>
<span class="fc" id="L232">        verify(observer, never()).onError(any(Throwable.class));</span>

<span class="fc" id="L234">        scheduler.advanceTimeTo(225, TimeUnit.MILLISECONDS);</span>
<span class="fc" id="L235">        inOrder.verify(observer, times(1)).onNext(&quot;three&quot;);</span>
<span class="fc" id="L236">        verify(observer, never()).onComplete();</span>
<span class="fc" id="L237">        verify(observer, never()).onError(any(Throwable.class));</span>

<span class="fc" id="L239">        scheduler.advanceTimeTo(350, TimeUnit.MILLISECONDS);</span>
<span class="fc" id="L240">        inOrder.verify(observer, never()).onNext(anyString());</span>
<span class="fc" id="L241">        verify(observer, never()).onComplete();</span>
<span class="fc" id="L242">        verify(observer, times(1)).onError(any(TestException.class));</span>
<span class="fc" id="L243">    }</span>

    @Test
    public void testSwitchWithSubsequenceComplete() {
<span class="fc" id="L247">        Observable&lt;Observable&lt;String&gt;&gt; source = Observable.unsafeCreate(new ObservableSource&lt;Observable&lt;String&gt;&gt;() {</span>
            @Override
            public void subscribe(Observer&lt;? super Observable&lt;String&gt;&gt; outerObserver) {
<span class="fc" id="L250">                outerObserver.onSubscribe(Disposables.empty());</span>
<span class="fc" id="L251">                publishNext(outerObserver, 50, Observable.unsafeCreate(new ObservableSource&lt;String&gt;() {</span>
                    @Override
                    public void subscribe(Observer&lt;? super String&gt; innerObserver) {
<span class="fc" id="L254">                        innerObserver.onSubscribe(Disposables.empty());</span>
<span class="fc" id="L255">                        publishNext(innerObserver, 50, &quot;one&quot;);</span>
<span class="fc" id="L256">                        publishNext(innerObserver, 100, &quot;two&quot;);</span>
<span class="fc" id="L257">                    }</span>
                }));

<span class="fc" id="L260">                publishNext(outerObserver, 130, Observable.unsafeCreate(new ObservableSource&lt;String&gt;() {</span>
                    @Override
                    public void subscribe(Observer&lt;? super String&gt; innerObserver) {
<span class="fc" id="L263">                        innerObserver.onSubscribe(Disposables.empty());</span>
<span class="fc" id="L264">                        publishCompleted(innerObserver, 0);</span>
<span class="fc" id="L265">                    }</span>
                }));

<span class="fc" id="L268">                publishNext(outerObserver, 150, Observable.unsafeCreate(new ObservableSource&lt;String&gt;() {</span>
                    @Override
                    public void subscribe(Observer&lt;? super String&gt; innerObserver) {
<span class="fc" id="L271">                        innerObserver.onSubscribe(Disposables.empty());</span>
<span class="fc" id="L272">                        publishNext(innerObserver, 50, &quot;three&quot;);</span>
<span class="fc" id="L273">                    }</span>
                }));
<span class="fc" id="L275">            }</span>
        });

<span class="fc" id="L278">        Observable&lt;String&gt; sampled = Observable.switchOnNext(source);</span>
<span class="fc" id="L279">        sampled.subscribe(observer);</span>

<span class="fc" id="L281">        InOrder inOrder = inOrder(observer);</span>

<span class="fc" id="L283">        scheduler.advanceTimeTo(90, TimeUnit.MILLISECONDS);</span>
<span class="fc" id="L284">        inOrder.verify(observer, never()).onNext(anyString());</span>
<span class="fc" id="L285">        verify(observer, never()).onComplete();</span>
<span class="fc" id="L286">        verify(observer, never()).onError(any(Throwable.class));</span>

<span class="fc" id="L288">        scheduler.advanceTimeTo(125, TimeUnit.MILLISECONDS);</span>
<span class="fc" id="L289">        inOrder.verify(observer, times(1)).onNext(&quot;one&quot;);</span>
<span class="fc" id="L290">        verify(observer, never()).onComplete();</span>
<span class="fc" id="L291">        verify(observer, never()).onError(any(Throwable.class));</span>

<span class="fc" id="L293">        scheduler.advanceTimeTo(250, TimeUnit.MILLISECONDS);</span>
<span class="fc" id="L294">        inOrder.verify(observer, times(1)).onNext(&quot;three&quot;);</span>
<span class="fc" id="L295">        verify(observer, never()).onComplete();</span>
<span class="fc" id="L296">        verify(observer, never()).onError(any(Throwable.class));</span>
<span class="fc" id="L297">    }</span>

    @Test
    public void testSwitchWithSubsequenceError() {
<span class="fc" id="L301">        Observable&lt;Observable&lt;String&gt;&gt; source = Observable.unsafeCreate(new ObservableSource&lt;Observable&lt;String&gt;&gt;() {</span>
            @Override
            public void subscribe(Observer&lt;? super Observable&lt;String&gt;&gt; observer) {
<span class="fc" id="L304">                observer.onSubscribe(Disposables.empty());</span>
<span class="fc" id="L305">                publishNext(observer, 50, Observable.unsafeCreate(new ObservableSource&lt;String&gt;() {</span>
                    @Override
                    public void subscribe(Observer&lt;? super String&gt; observer) {
<span class="fc" id="L308">                        observer.onSubscribe(Disposables.empty());</span>
<span class="fc" id="L309">                        publishNext(observer, 50, &quot;one&quot;);</span>
<span class="fc" id="L310">                        publishNext(observer, 100, &quot;two&quot;);</span>
<span class="fc" id="L311">                    }</span>
                }));

<span class="fc" id="L314">                publishNext(observer, 130, Observable.unsafeCreate(new ObservableSource&lt;String&gt;() {</span>
                    @Override
                    public void subscribe(Observer&lt;? super String&gt; observer) {
<span class="fc" id="L317">                        observer.onSubscribe(Disposables.empty());</span>
<span class="fc" id="L318">                        publishError(observer, 0, new TestException());</span>
<span class="fc" id="L319">                    }</span>
                }));

<span class="fc" id="L322">                publishNext(observer, 150, Observable.unsafeCreate(new ObservableSource&lt;String&gt;() {</span>
                    @Override
                    public void subscribe(Observer&lt;? super String&gt; observer) {
<span class="fc" id="L325">                        observer.onSubscribe(Disposables.empty());</span>
<span class="fc" id="L326">                        publishNext(observer, 50, &quot;three&quot;);</span>
<span class="fc" id="L327">                    }</span>
                }));

<span class="fc" id="L330">            }</span>
        });

<span class="fc" id="L333">        Observable&lt;String&gt; sampled = Observable.switchOnNext(source);</span>
<span class="fc" id="L334">        sampled.subscribe(observer);</span>

<span class="fc" id="L336">        InOrder inOrder = inOrder(observer);</span>

<span class="fc" id="L338">        scheduler.advanceTimeTo(90, TimeUnit.MILLISECONDS);</span>
<span class="fc" id="L339">        inOrder.verify(observer, never()).onNext(anyString());</span>
<span class="fc" id="L340">        verify(observer, never()).onComplete();</span>
<span class="fc" id="L341">        verify(observer, never()).onError(any(Throwable.class));</span>

<span class="fc" id="L343">        scheduler.advanceTimeTo(125, TimeUnit.MILLISECONDS);</span>
<span class="fc" id="L344">        inOrder.verify(observer, times(1)).onNext(&quot;one&quot;);</span>
<span class="fc" id="L345">        verify(observer, never()).onComplete();</span>
<span class="fc" id="L346">        verify(observer, never()).onError(any(Throwable.class));</span>

<span class="fc" id="L348">        scheduler.advanceTimeTo(250, TimeUnit.MILLISECONDS);</span>
<span class="fc" id="L349">        inOrder.verify(observer, never()).onNext(&quot;three&quot;);</span>
<span class="fc" id="L350">        verify(observer, never()).onComplete();</span>
<span class="fc" id="L351">        verify(observer, times(1)).onError(any(TestException.class));</span>
<span class="fc" id="L352">    }</span>

    private &lt;T&gt; void publishCompleted(final Observer&lt;T&gt; observer, long delay) {
<span class="fc" id="L355">        innerScheduler.schedule(new Runnable() {</span>
            @Override
            public void run() {
<span class="fc" id="L358">                observer.onComplete();</span>
<span class="fc" id="L359">            }</span>
        }, delay, TimeUnit.MILLISECONDS);
<span class="fc" id="L361">    }</span>

    private &lt;T&gt; void publishError(final Observer&lt;T&gt; observer, long delay, final Throwable error) {
<span class="fc" id="L364">        innerScheduler.schedule(new Runnable() {</span>
            @Override
            public void run() {
<span class="fc" id="L367">                observer.onError(error);</span>
<span class="fc" id="L368">            }</span>
        }, delay, TimeUnit.MILLISECONDS);
<span class="fc" id="L370">    }</span>

    private &lt;T&gt; void publishNext(final Observer&lt;T&gt; observer, long delay, final T value) {
<span class="fc" id="L373">        innerScheduler.schedule(new Runnable() {</span>
            @Override
            public void run() {
<span class="fc" id="L376">                observer.onNext(value);</span>
<span class="fc" id="L377">            }</span>
        }, delay, TimeUnit.MILLISECONDS);
<span class="fc" id="L379">    }</span>

    @Test
    public void testSwitchIssue737() {
        // https://github.com/ReactiveX/RxJava/issues/737
<span class="fc" id="L384">        Observable&lt;Observable&lt;String&gt;&gt; source = Observable.unsafeCreate(new ObservableSource&lt;Observable&lt;String&gt;&gt;() {</span>
            @Override
            public void subscribe(Observer&lt;? super Observable&lt;String&gt;&gt; outerObserver) {
<span class="fc" id="L387">                outerObserver.onSubscribe(Disposables.empty());</span>
<span class="fc" id="L388">                publishNext(outerObserver, 0, Observable.unsafeCreate(new ObservableSource&lt;String&gt;() {</span>
                    @Override
                    public void subscribe(Observer&lt;? super String&gt; innerObserver) {
<span class="fc" id="L391">                        innerObserver.onSubscribe(Disposables.empty());</span>
<span class="fc" id="L392">                        publishNext(innerObserver, 10, &quot;1-one&quot;);</span>
<span class="fc" id="L393">                        publishNext(innerObserver, 20, &quot;1-two&quot;);</span>
                        // The following events will be ignored
<span class="fc" id="L395">                        publishNext(innerObserver, 30, &quot;1-three&quot;);</span>
<span class="fc" id="L396">                        publishCompleted(innerObserver, 40);</span>
<span class="fc" id="L397">                    }</span>
                }));
<span class="fc" id="L399">                publishNext(outerObserver, 25, Observable.unsafeCreate(new ObservableSource&lt;String&gt;() {</span>
                    @Override
                    public void subscribe(Observer&lt;? super String&gt; innerObserver) {
<span class="fc" id="L402">                        innerObserver.onSubscribe(Disposables.empty());</span>
<span class="fc" id="L403">                        publishNext(innerObserver, 10, &quot;2-one&quot;);</span>
<span class="fc" id="L404">                        publishNext(innerObserver, 20, &quot;2-two&quot;);</span>
<span class="fc" id="L405">                        publishNext(innerObserver, 30, &quot;2-three&quot;);</span>
<span class="fc" id="L406">                        publishCompleted(innerObserver, 40);</span>
<span class="fc" id="L407">                    }</span>
                }));
<span class="fc" id="L409">                publishCompleted(outerObserver, 30);</span>
<span class="fc" id="L410">            }</span>
        });

<span class="fc" id="L413">        Observable&lt;String&gt; sampled = Observable.switchOnNext(source);</span>
<span class="fc" id="L414">        sampled.subscribe(observer);</span>

<span class="fc" id="L416">        scheduler.advanceTimeTo(1000, TimeUnit.MILLISECONDS);</span>

<span class="fc" id="L418">        InOrder inOrder = inOrder(observer);</span>
<span class="fc" id="L419">        inOrder.verify(observer, times(1)).onNext(&quot;1-one&quot;);</span>
<span class="fc" id="L420">        inOrder.verify(observer, times(1)).onNext(&quot;1-two&quot;);</span>
<span class="fc" id="L421">        inOrder.verify(observer, times(1)).onNext(&quot;2-one&quot;);</span>
<span class="fc" id="L422">        inOrder.verify(observer, times(1)).onNext(&quot;2-two&quot;);</span>
<span class="fc" id="L423">        inOrder.verify(observer, times(1)).onNext(&quot;2-three&quot;);</span>
<span class="fc" id="L424">        inOrder.verify(observer, times(1)).onComplete();</span>
<span class="fc" id="L425">        inOrder.verifyNoMoreInteractions();</span>
<span class="fc" id="L426">    }</span>

    @Test
    public void testUnsubscribe() {
<span class="fc" id="L430">        final AtomicBoolean isUnsubscribed = new AtomicBoolean();</span>
<span class="fc" id="L431">        Observable.switchOnNext(</span>
<span class="fc" id="L432">                Observable.unsafeCreate(new ObservableSource&lt;Observable&lt;Integer&gt;&gt;() {</span>
                    @Override
                    public void subscribe(final Observer&lt;? super Observable&lt;Integer&gt;&gt; observer) {
<span class="fc" id="L435">                        Disposable bs = Disposables.empty();</span>
<span class="fc" id="L436">                        observer.onSubscribe(bs);</span>
<span class="fc" id="L437">                        observer.onNext(Observable.just(1));</span>
<span class="fc" id="L438">                        isUnsubscribed.set(bs.isDisposed());</span>
<span class="fc" id="L439">                    }</span>
                })
<span class="fc" id="L441">        ).take(1).subscribe();</span>
<span class="fc" id="L442">        assertTrue(&quot;Switch doesn't propagate 'unsubscribe'&quot;, isUnsubscribed.get());</span>
<span class="fc" id="L443">    }</span>
    /** The upstream producer hijacked the switch producer stopping the requests aimed at the inner observables. */
    @Test
    public void testIssue2654() {
<span class="fc" id="L447">        Observable&lt;String&gt; oneItem = Observable.just(&quot;Hello&quot;).mergeWith(Observable.&lt;String&gt;never());</span>

<span class="fc" id="L449">        Observable&lt;String&gt; src = oneItem.switchMap(new Function&lt;String, Observable&lt;String&gt;&gt;() {</span>
            @Override
            public Observable&lt;String&gt; apply(final String s) {
<span class="fc" id="L452">                return Observable.just(s)</span>
<span class="fc" id="L453">                        .mergeWith(Observable.interval(10, TimeUnit.MILLISECONDS)</span>
<span class="fc" id="L454">                        .map(new Function&lt;Long, String&gt;() {</span>
                            @Override
                            public String apply(Long i) {
<span class="fc" id="L457">                                return s + &quot; &quot; + i;</span>
                            }
<span class="fc" id="L459">                        })).take(250);</span>
            }
        })
<span class="fc" id="L462">        .share()</span>
        ;

<span class="fc" id="L465">        TestObserver&lt;String&gt; to = new TestObserver&lt;String&gt;() {</span>
            @Override
            public void onNext(String t) {
<span class="fc" id="L468">                super.onNext(t);</span>
<span class="fc bfc" id="L469" title="All 2 branches covered.">                if (valueCount() == 250) {</span>
<span class="fc" id="L470">                    onComplete();</span>
<span class="fc" id="L471">                    dispose();</span>
                }
<span class="fc" id="L473">            }</span>
        };
<span class="fc" id="L475">        src.subscribe(to);</span>

<span class="fc" id="L477">        to.awaitTerminalEvent(10, TimeUnit.SECONDS);</span>

<span class="fc" id="L479">        System.out.println(&quot;&gt; testIssue2654: &quot; + to.valueCount());</span>

<span class="fc" id="L481">        to.assertTerminated();</span>
<span class="fc" id="L482">        to.assertNoErrors();</span>

<span class="fc" id="L484">        Assert.assertEquals(250, to.valueCount());</span>
<span class="fc" id="L485">    }</span>

    @Test
    public void delayErrors() {
<span class="fc" id="L489">        PublishSubject&lt;ObservableSource&lt;Integer&gt;&gt; source = PublishSubject.create();</span>

<span class="fc" id="L491">        TestObserver&lt;Integer&gt; to = source.switchMapDelayError(Functions.&lt;ObservableSource&lt;Integer&gt;&gt;identity())</span>
<span class="fc" id="L492">        .test();</span>

<span class="fc" id="L494">        to.assertNoValues()</span>
<span class="fc" id="L495">        .assertNoErrors()</span>
<span class="fc" id="L496">        .assertNotComplete();</span>

<span class="fc" id="L498">        source.onNext(Observable.just(1));</span>

<span class="fc" id="L500">        source.onNext(Observable.&lt;Integer&gt;error(new TestException(&quot;Forced failure 1&quot;)));</span>

<span class="fc" id="L502">        source.onNext(Observable.just(2, 3, 4));</span>

<span class="fc" id="L504">        source.onNext(Observable.&lt;Integer&gt;error(new TestException(&quot;Forced failure 2&quot;)));</span>

<span class="fc" id="L506">        source.onNext(Observable.just(5));</span>

<span class="fc" id="L508">        source.onError(new TestException(&quot;Forced failure 3&quot;));</span>

<span class="fc" id="L510">        to.assertValues(1, 2, 3, 4, 5)</span>
<span class="fc" id="L511">        .assertNotComplete()</span>
<span class="fc" id="L512">        .assertError(CompositeException.class);</span>

<span class="fc" id="L514">        List&lt;Throwable&gt; errors = ExceptionHelper.flatten(to.errors().get(0));</span>

<span class="fc" id="L516">        TestHelper.assertError(errors, 0, TestException.class, &quot;Forced failure 1&quot;);</span>
<span class="fc" id="L517">        TestHelper.assertError(errors, 1, TestException.class, &quot;Forced failure 2&quot;);</span>
<span class="fc" id="L518">        TestHelper.assertError(errors, 2, TestException.class, &quot;Forced failure 3&quot;);</span>
<span class="fc" id="L519">    }</span>

    @Test
    public void switchOnNextDelayError() {
<span class="fc" id="L523">        PublishSubject&lt;Observable&lt;Integer&gt;&gt; ps = PublishSubject.create();</span>

<span class="fc" id="L525">        TestObserver&lt;Integer&gt; to = Observable.switchOnNextDelayError(ps).test();</span>

<span class="fc" id="L527">        ps.onNext(Observable.just(1));</span>
<span class="fc" id="L528">        ps.onNext(Observable.range(2, 4));</span>
<span class="fc" id="L529">        ps.onComplete();</span>

<span class="fc" id="L531">        to.assertResult(1, 2, 3, 4, 5);</span>
<span class="fc" id="L532">    }</span>

    @Test
    public void switchOnNextDelayErrorWithError() {
<span class="fc" id="L536">        PublishSubject&lt;Observable&lt;Integer&gt;&gt; ps = PublishSubject.create();</span>

<span class="fc" id="L538">        TestObserver&lt;Integer&gt; to = Observable.switchOnNextDelayError(ps).test();</span>

<span class="fc" id="L540">        ps.onNext(Observable.just(1));</span>
<span class="fc" id="L541">        ps.onNext(Observable.&lt;Integer&gt;error(new TestException()));</span>
<span class="fc" id="L542">        ps.onNext(Observable.range(2, 4));</span>
<span class="fc" id="L543">        ps.onComplete();</span>

<span class="fc" id="L545">        to.assertFailure(TestException.class, 1, 2, 3, 4, 5);</span>
<span class="fc" id="L546">    }</span>

    @Test
    public void switchOnNextDelayErrorBufferSize() {
<span class="fc" id="L550">        PublishSubject&lt;Observable&lt;Integer&gt;&gt; ps = PublishSubject.create();</span>

<span class="fc" id="L552">        TestObserver&lt;Integer&gt; to = Observable.switchOnNextDelayError(ps, 2).test();</span>

<span class="fc" id="L554">        ps.onNext(Observable.just(1));</span>
<span class="fc" id="L555">        ps.onNext(Observable.range(2, 4));</span>
<span class="fc" id="L556">        ps.onComplete();</span>

<span class="fc" id="L558">        to.assertResult(1, 2, 3, 4, 5);</span>
<span class="fc" id="L559">    }</span>

    @Test
    public void switchMapDelayErrorEmptySource() {
<span class="fc" id="L563">        assertSame(Observable.empty(), Observable.&lt;Object&gt;empty()</span>
<span class="fc" id="L564">                .switchMapDelayError(new Function&lt;Object, ObservableSource&lt;Integer&gt;&gt;() {</span>
                    @Override
                    public ObservableSource&lt;Integer&gt; apply(Object v) throws Exception {
<span class="nc" id="L567">                        return Observable.just(1);</span>
                    }
                }, 16));
<span class="fc" id="L570">    }</span>

    @Test
    public void switchMapDelayErrorJustSource() {
<span class="fc" id="L574">        Observable.just(0)</span>
<span class="fc" id="L575">        .switchMapDelayError(new Function&lt;Object, ObservableSource&lt;Integer&gt;&gt;() {</span>
            @Override
            public ObservableSource&lt;Integer&gt; apply(Object v) throws Exception {
<span class="fc" id="L578">                return Observable.just(1);</span>
            }
        }, 16)
<span class="fc" id="L581">        .test()</span>
<span class="fc" id="L582">        .assertResult(1);</span>
<span class="fc" id="L583">    }</span>

    @Test
    public void switchMapErrorEmptySource() {
<span class="fc" id="L587">        assertSame(Observable.empty(), Observable.&lt;Object&gt;empty()</span>
<span class="fc" id="L588">                .switchMap(new Function&lt;Object, ObservableSource&lt;Integer&gt;&gt;() {</span>
                    @Override
                    public ObservableSource&lt;Integer&gt; apply(Object v) throws Exception {
<span class="nc" id="L591">                        return Observable.just(1);</span>
                    }
                }, 16));
<span class="fc" id="L594">    }</span>

    @Test
    public void switchMapJustSource() {
<span class="fc" id="L598">        Observable.just(0)</span>
<span class="fc" id="L599">        .switchMap(new Function&lt;Object, ObservableSource&lt;Integer&gt;&gt;() {</span>
            @Override
            public ObservableSource&lt;Integer&gt; apply(Object v) throws Exception {
<span class="fc" id="L602">                return Observable.just(1);</span>
            }
        }, 16)
<span class="fc" id="L605">        .test()</span>
<span class="fc" id="L606">        .assertResult(1);</span>

<span class="fc" id="L608">    }</span>

    @Test
    public void switchMapInnerCancelled() {
<span class="fc" id="L612">        PublishSubject&lt;Integer&gt; ps = PublishSubject.create();</span>

<span class="fc" id="L614">        TestObserver&lt;Integer&gt; to = Observable.just(1)</span>
<span class="fc" id="L615">                .switchMap(Functions.justFunction(ps))</span>
<span class="fc" id="L616">                .test();</span>

<span class="fc" id="L618">        assertTrue(ps.hasObservers());</span>

<span class="fc" id="L620">        to.cancel();</span>

<span class="fc" id="L622">        assertFalse(ps.hasObservers());</span>
<span class="fc" id="L623">    }</span>

    @Test
    public void switchMapSingleJustSource() {
<span class="fc" id="L627">        Observable.just(0)</span>
<span class="fc" id="L628">        .switchMapSingle(new Function&lt;Object, SingleSource&lt;Integer&gt;&gt;() {</span>
            @Override
            public SingleSource&lt;Integer&gt; apply(Object v) throws Exception {
<span class="fc" id="L631">                return Single.just(1);</span>
            }
        })
<span class="fc" id="L634">        .test()</span>
<span class="fc" id="L635">        .assertResult(1);</span>
<span class="fc" id="L636">    }</span>

    @Test
    public void switchMapSingleMapperReturnsNull() {
<span class="fc" id="L640">        Observable.just(0)</span>
<span class="fc" id="L641">        .switchMapSingle(new Function&lt;Object, SingleSource&lt;Integer&gt;&gt;() {</span>
            @Override
            public SingleSource&lt;Integer&gt; apply(Object v) throws Exception {
<span class="fc" id="L644">                return null;</span>
            }
        })
<span class="fc" id="L647">        .test()</span>
<span class="fc" id="L648">        .assertError(NullPointerException.class);</span>
<span class="fc" id="L649">    }</span>

    @Test(expected = NullPointerException.class)
    public void switchMapSingleMapperIsNull() {
<span class="fc" id="L653">        Observable.just(0)</span>
<span class="nc" id="L654">        .switchMapSingle(null);</span>
<span class="nc" id="L655">    }</span>

    @Test
    public void switchMapSingleFunctionDoesntReturnSingle() {
<span class="fc" id="L659">        Observable.just(0)</span>
<span class="fc" id="L660">        .switchMapSingle(new Function&lt;Object, SingleSource&lt;Integer&gt;&gt;() {</span>
            @Override
            public SingleSource&lt;Integer&gt; apply(Object v) throws Exception {
<span class="fc" id="L663">                return new SingleSource&lt;Integer&gt;() {</span>
                    @Override
                    public void subscribe(SingleObserver&lt;? super Integer&gt; observer) {
<span class="fc" id="L666">                        observer.onSubscribe(Disposables.empty());</span>
<span class="fc" id="L667">                        observer.onSuccess(1);</span>
<span class="fc" id="L668">                    }</span>
                };
            }
        })
<span class="fc" id="L672">        .test()</span>
<span class="fc" id="L673">        .assertResult(1);</span>
<span class="fc" id="L674">    }</span>

    @Test
    public void switchMapSingleDelayErrorJustSource() {
<span class="fc" id="L678">        final AtomicBoolean completed = new AtomicBoolean();</span>
<span class="fc" id="L679">        Observable.just(0, 1)</span>
<span class="fc" id="L680">        .switchMapSingleDelayError(new Function&lt;Integer, SingleSource&lt;Integer&gt;&gt;() {</span>
            @Override
            public SingleSource&lt;Integer&gt; apply(Integer v) throws Exception {
<span class="fc bfc" id="L683" title="All 2 branches covered.">                if (v == 0) {</span>
<span class="fc" id="L684">                    return Single.error(new RuntimeException());</span>
                } else {
<span class="fc" id="L686">                    return Single.just(1).doOnSuccess(new Consumer&lt;Integer&gt;() {</span>

                        @Override
                        public void accept(Integer n) throws Exception {
<span class="fc" id="L690">                            completed.set(true);</span>
<span class="fc" id="L691">                        }});</span>
                }
            }
        })
<span class="fc" id="L695">        .test()</span>
<span class="fc" id="L696">        .assertValue(1)</span>
<span class="fc" id="L697">        .assertError(RuntimeException.class);</span>
<span class="fc" id="L698">        assertTrue(completed.get());</span>
<span class="fc" id="L699">    }</span>

    @Test
    public void scalarMap() {
<span class="fc" id="L703">        Observable.switchOnNext(Observable.just(Observable.just(1)))</span>
<span class="fc" id="L704">        .test()</span>
<span class="fc" id="L705">        .assertResult(1);</span>
<span class="fc" id="L706">    }</span>

    @Test
    public void scalarMapDelayError() {
<span class="fc" id="L710">        Observable.switchOnNextDelayError(Observable.just(Observable.just(1)))</span>
<span class="fc" id="L711">        .test()</span>
<span class="fc" id="L712">        .assertResult(1);</span>
<span class="fc" id="L713">    }</span>

    @Test
    public void dispose() {
<span class="fc" id="L717">        TestHelper.checkDisposed(Observable.switchOnNext(</span>
<span class="fc" id="L718">                Observable.just(Observable.just(1)).hide()));</span>
<span class="fc" id="L719">    }</span>

    @Test
    public void nextSourceErrorRace() {
<span class="fc bfc" id="L723" title="All 2 branches covered.">        for (int i = 0; i &lt; TestHelper.RACE_DEFAULT_LOOPS; i++) {</span>
<span class="fc" id="L724">            List&lt;Throwable&gt; errors = TestHelper.trackPluginErrors();</span>
            try {

<span class="fc" id="L727">                final PublishSubject&lt;Integer&gt; ps1 = PublishSubject.create();</span>
<span class="fc" id="L728">                final PublishSubject&lt;Integer&gt; ps2 = PublishSubject.create();</span>

<span class="fc" id="L730">                ps1.switchMap(new Function&lt;Integer, ObservableSource&lt;Integer&gt;&gt;() {</span>
                    @Override
                    public ObservableSource&lt;Integer&gt; apply(Integer v) throws Exception {
<span class="pc bpc" id="L733" title="1 of 2 branches missed.">                        if (v == 1) {</span>
<span class="nc" id="L734">                            return ps2;</span>
                        }
<span class="fc" id="L736">                        return Observable.never();</span>
                    }
                })
<span class="fc" id="L739">                .test();</span>

<span class="fc" id="L741">                Runnable r1 = new Runnable() {</span>
                    @Override
                    public void run() {
<span class="fc" id="L744">                        ps1.onNext(2);</span>
<span class="fc" id="L745">                    }</span>
                };

<span class="fc" id="L748">                final TestException ex = new TestException();</span>

<span class="fc" id="L750">                Runnable r2 = new Runnable() {</span>
                    @Override
                    public void run() {
<span class="fc" id="L753">                        ps2.onError(ex);</span>
<span class="fc" id="L754">                    }</span>
                };

<span class="fc" id="L757">                TestHelper.race(r1, r2);</span>

<span class="pc bpc" id="L759" title="1 of 2 branches missed.">                for (Throwable e : errors) {</span>
<span class="nc" id="L760">                    assertTrue(e.toString(), e instanceof TestException);</span>
<span class="nc" id="L761">                }</span>
            } finally {
<span class="fc" id="L763">                RxJavaPlugins.reset();</span>
            }
        }
<span class="fc" id="L766">    }</span>

    @Test
    public void outerInnerErrorRace() {
<span class="fc bfc" id="L770" title="All 2 branches covered.">        for (int i = 0; i &lt; TestHelper.RACE_LONG_LOOPS; i++) {</span>
<span class="fc" id="L771">            List&lt;Throwable&gt; errors = TestHelper.trackPluginErrors();</span>
            try {

<span class="fc" id="L774">                final PublishSubject&lt;Integer&gt; ps1 = PublishSubject.create();</span>
<span class="fc" id="L775">                final PublishSubject&lt;Integer&gt; ps2 = PublishSubject.create();</span>

<span class="fc" id="L777">                ps1.switchMap(new Function&lt;Integer, ObservableSource&lt;Integer&gt;&gt;() {</span>
                    @Override
                    public ObservableSource&lt;Integer&gt; apply(Integer v) throws Exception {
<span class="pc bpc" id="L780" title="1 of 2 branches missed.">                        if (v == 1) {</span>
<span class="fc" id="L781">                            return ps2;</span>
                        }
<span class="nc" id="L783">                        return Observable.never();</span>
                    }
                })
<span class="fc" id="L786">                .test();</span>

<span class="fc" id="L788">                ps1.onNext(1);</span>

<span class="fc" id="L790">                final TestException ex1 = new TestException();</span>

<span class="fc" id="L792">                Runnable r1 = new Runnable() {</span>
                    @Override
                    public void run() {
<span class="fc" id="L795">                        ps1.onError(ex1);</span>
<span class="fc" id="L796">                    }</span>
                };

<span class="fc" id="L799">                final TestException ex2 = new TestException();</span>

<span class="fc" id="L801">                Runnable r2 = new Runnable() {</span>
                    @Override
                    public void run() {
<span class="fc" id="L804">                        ps2.onError(ex2);</span>
<span class="fc" id="L805">                    }</span>
                };

<span class="fc" id="L808">                TestHelper.race(r1, r2);</span>

<span class="fc bfc" id="L810" title="All 2 branches covered.">                for (Throwable e : errors) {</span>
<span class="fc" id="L811">                    assertTrue(e.getCause().toString(), e.getCause() instanceof TestException);</span>
<span class="fc" id="L812">                }</span>
            } finally {
<span class="fc" id="L814">                RxJavaPlugins.reset();</span>
            }
        }
<span class="fc" id="L817">    }</span>

    @Test
    public void nextCancelRace() {
<span class="fc bfc" id="L821" title="All 2 branches covered.">        for (int i = 0; i &lt; TestHelper.RACE_DEFAULT_LOOPS; i++) {</span>
<span class="fc" id="L822">            final PublishSubject&lt;Integer&gt; ps1 = PublishSubject.create();</span>

<span class="fc" id="L824">            final TestObserver&lt;Integer&gt; to = ps1.switchMap(new Function&lt;Integer, ObservableSource&lt;Integer&gt;&gt;() {</span>
                @Override
                public ObservableSource&lt;Integer&gt; apply(Integer v) throws Exception {
<span class="fc" id="L827">                    return Observable.never();</span>
                }
            })
<span class="fc" id="L830">            .test();</span>

<span class="fc" id="L832">            Runnable r1 = new Runnable() {</span>
                @Override
                public void run() {
<span class="fc" id="L835">                    ps1.onNext(2);</span>
<span class="fc" id="L836">                }</span>
            };

<span class="fc" id="L839">            Runnable r2 = new Runnable() {</span>
                @Override
                public void run() {
<span class="fc" id="L842">                    to.cancel();</span>
<span class="fc" id="L843">                }</span>
            };

<span class="fc" id="L846">            TestHelper.race(r1, r2);</span>
        }
<span class="fc" id="L848">    }</span>

    @Test
    public void mapperThrows() {
<span class="fc" id="L852">        Observable.just(1).hide()</span>
<span class="fc" id="L853">        .switchMap(new Function&lt;Integer, ObservableSource&lt;Object&gt;&gt;() {</span>
            @Override
            public ObservableSource&lt;Object&gt; apply(Integer v) throws Exception {
<span class="fc" id="L856">                throw new TestException();</span>
            }
        })
<span class="fc" id="L859">        .test()</span>
<span class="fc" id="L860">        .assertFailure(TestException.class);</span>
<span class="fc" id="L861">    }</span>

    @Test
    public void badMainSource() {
<span class="fc" id="L865">        List&lt;Throwable&gt; errors = TestHelper.trackPluginErrors();</span>
        try {
<span class="fc" id="L867">            new Observable&lt;Integer&gt;() {</span>
                @Override
                protected void subscribeActual(Observer&lt;? super Integer&gt; observer) {
<span class="fc" id="L870">                    observer.onSubscribe(Disposables.empty());</span>
<span class="fc" id="L871">                    observer.onComplete();</span>
<span class="fc" id="L872">                    observer.onError(new TestException());</span>
<span class="fc" id="L873">                    observer.onComplete();</span>
<span class="fc" id="L874">                }</span>
            }
<span class="fc" id="L876">            .switchMap(Functions.justFunction(Observable.never()))</span>
<span class="fc" id="L877">            .test()</span>
<span class="fc" id="L878">            .assertResult();</span>

<span class="fc" id="L880">            TestHelper.assertUndeliverable(errors, 0, TestException.class);</span>
        } finally {
<span class="fc" id="L882">            RxJavaPlugins.reset();</span>
        }
<span class="fc" id="L884">    }</span>

    @Test
    public void emptyInner() {
<span class="fc" id="L888">        Observable.range(1, 5)</span>
<span class="fc" id="L889">        .switchMap(Functions.justFunction(Observable.empty()))</span>
<span class="fc" id="L890">        .test()</span>
<span class="fc" id="L891">        .assertResult();</span>
<span class="fc" id="L892">    }</span>

    @Test
    public void justInner() {
<span class="fc" id="L896">        Observable.range(1, 5)</span>
<span class="fc" id="L897">        .switchMap(Functions.justFunction(Observable.just(1)))</span>
<span class="fc" id="L898">        .test()</span>
<span class="fc" id="L899">        .assertResult(1, 1, 1, 1, 1);</span>
<span class="fc" id="L900">    }</span>

    @Test
    public void badInnerSource() {
<span class="fc" id="L904">        List&lt;Throwable&gt; errors = TestHelper.trackPluginErrors();</span>
        try {
<span class="fc" id="L906">            Observable.just(1).hide()</span>
<span class="fc" id="L907">            .switchMap(Functions.justFunction(new Observable&lt;Integer&gt;() {</span>
                @Override
                protected void subscribeActual(Observer&lt;? super Integer&gt; observer) {
<span class="fc" id="L910">                    observer.onSubscribe(Disposables.empty());</span>
<span class="fc" id="L911">                    observer.onError(new TestException());</span>
<span class="fc" id="L912">                    observer.onComplete();</span>
<span class="fc" id="L913">                    observer.onError(new TestException());</span>
<span class="fc" id="L914">                    observer.onComplete();</span>
<span class="fc" id="L915">                }</span>
            }))
<span class="fc" id="L917">            .test()</span>
<span class="fc" id="L918">            .assertFailure(TestException.class);</span>

<span class="fc" id="L920">            TestHelper.assertUndeliverable(errors, 0, TestException.class);</span>
        } finally {
<span class="fc" id="L922">            RxJavaPlugins.reset();</span>
        }
<span class="fc" id="L924">    }</span>

    @Test
    public void innerCompletesReentrant() {
<span class="fc" id="L928">        final PublishSubject&lt;Integer&gt; ps = PublishSubject.create();</span>

<span class="fc" id="L930">        TestObserver&lt;Integer&gt; to = new TestObserver&lt;Integer&gt;() {</span>
            @Override
            public void onNext(Integer t) {
<span class="fc" id="L933">                super.onNext(t);</span>
<span class="fc" id="L934">                ps.onComplete();</span>
<span class="fc" id="L935">            }</span>
        };

<span class="fc" id="L938">        Observable.just(1).hide()</span>
<span class="fc" id="L939">        .switchMap(Functions.justFunction(ps))</span>
<span class="fc" id="L940">        .subscribe(to);</span>

<span class="fc" id="L942">        ps.onNext(1);</span>

<span class="fc" id="L944">        to.assertResult(1);</span>
<span class="fc" id="L945">    }</span>

    @Test
    public void innerErrorsReentrant() {
<span class="fc" id="L949">        final PublishSubject&lt;Integer&gt; ps = PublishSubject.create();</span>

<span class="fc" id="L951">        TestObserver&lt;Integer&gt; to = new TestObserver&lt;Integer&gt;() {</span>
            @Override
            public void onNext(Integer t) {
<span class="fc" id="L954">                super.onNext(t);</span>
<span class="fc" id="L955">                ps.onError(new TestException());</span>
<span class="fc" id="L956">            }</span>
        };

<span class="fc" id="L959">        Observable.just(1).hide()</span>
<span class="fc" id="L960">        .switchMap(Functions.justFunction(ps))</span>
<span class="fc" id="L961">        .subscribe(to);</span>

<span class="fc" id="L963">        ps.onNext(1);</span>

<span class="fc" id="L965">        to.assertFailure(TestException.class, 1);</span>
<span class="fc" id="L966">    }</span>

    @Test
    public void innerDisposedOnMainError() {
<span class="fc" id="L970">        final PublishSubject&lt;Integer&gt; main = PublishSubject.create();</span>
<span class="fc" id="L971">        final PublishSubject&lt;Integer&gt; inner = PublishSubject.create();</span>

<span class="fc" id="L973">        TestObserver&lt;Integer&gt; to = main.switchMap(Functions.justFunction(inner))</span>
<span class="fc" id="L974">        .test();</span>

<span class="fc" id="L976">        assertTrue(main.hasObservers());</span>

<span class="fc" id="L978">        main.onNext(1);</span>

<span class="fc" id="L980">        assertTrue(inner.hasObservers());</span>

<span class="fc" id="L982">        main.onError(new TestException());</span>

<span class="fc" id="L984">        assertFalse(inner.hasObservers());</span>

<span class="fc" id="L986">        to.assertFailure(TestException.class);</span>
<span class="fc" id="L987">    }</span>

    @Test
    public void outerInnerErrorRaceIgnoreDispose() {
<span class="fc bfc" id="L991" title="All 2 branches covered.">        for (int i = 0; i &lt; TestHelper.RACE_LONG_LOOPS; i++) {</span>
<span class="fc" id="L992">            List&lt;Throwable&gt; errors = TestHelper.trackPluginErrors();</span>
            try {

<span class="fc" id="L995">                final AtomicReference&lt;Observer&lt;? super Integer&gt;&gt; obs1 = new AtomicReference&lt;Observer&lt;? super Integer&gt;&gt;();</span>
<span class="fc" id="L996">                final Observable&lt;Integer&gt; ps1 = new Observable&lt;Integer&gt;() {</span>
                    @Override
                    protected void subscribeActual(
                            Observer&lt;? super Integer&gt; observer) {
<span class="fc" id="L1000">                        obs1.set(observer);</span>
<span class="fc" id="L1001">                    }</span>
                };
<span class="fc" id="L1003">                final AtomicReference&lt;Observer&lt;? super Integer&gt;&gt; obs2 = new AtomicReference&lt;Observer&lt;? super Integer&gt;&gt;();</span>
<span class="fc" id="L1004">                final Observable&lt;Integer&gt; ps2 = new Observable&lt;Integer&gt;() {</span>
                    @Override
                    protected void subscribeActual(
                            Observer&lt;? super Integer&gt; observer) {
<span class="fc" id="L1008">                        obs2.set(observer);</span>
<span class="fc" id="L1009">                    }</span>
                };

<span class="fc" id="L1012">                ps1.switchMap(new Function&lt;Integer, ObservableSource&lt;Integer&gt;&gt;() {</span>
                    @Override
                    public ObservableSource&lt;Integer&gt; apply(Integer v) throws Exception {
<span class="pc bpc" id="L1015" title="1 of 2 branches missed.">                        if (v == 1) {</span>
<span class="fc" id="L1016">                            return ps2;</span>
                        }
<span class="nc" id="L1018">                        return Observable.never();</span>
                    }
                })
<span class="fc" id="L1021">                .test();</span>

<span class="fc" id="L1023">                obs1.get().onSubscribe(Disposables.empty());</span>
<span class="fc" id="L1024">                obs1.get().onNext(1);</span>

<span class="fc" id="L1026">                obs2.get().onSubscribe(Disposables.empty());</span>

<span class="fc" id="L1028">                final TestException ex1 = new TestException();</span>

<span class="fc" id="L1030">                Runnable r1 = new Runnable() {</span>
                    @Override
                    public void run() {
<span class="fc" id="L1033">                        obs1.get().onError(ex1);</span>
<span class="fc" id="L1034">                    }</span>
                };

<span class="fc" id="L1037">                final TestException ex2 = new TestException();</span>

<span class="fc" id="L1039">                Runnable r2 = new Runnable() {</span>
                    @Override
                    public void run() {
<span class="fc" id="L1042">                        obs2.get().onError(ex2);</span>
<span class="fc" id="L1043">                    }</span>
                };

<span class="fc" id="L1046">                TestHelper.race(r1, r2);</span>

<span class="fc bfc" id="L1048" title="All 2 branches covered.">                for (Throwable e : errors) {</span>
<span class="fc" id="L1049">                    assertTrue(e.toString(), e.getCause() instanceof TestException);</span>
<span class="fc" id="L1050">                }</span>
            } finally {
<span class="fc" id="L1052">                RxJavaPlugins.reset();</span>
            }
        }
<span class="fc" id="L1055">    }</span>

    @Test
    public void asyncFused() {
<span class="fc" id="L1059">        Observable.just(1).hide()</span>
<span class="fc" id="L1060">        .switchMap(Functions.justFunction(</span>
<span class="fc" id="L1061">                Observable.range(1, 5)</span>
<span class="fc" id="L1062">                .observeOn(ImmediateThinScheduler.INSTANCE)</span>
        ))
<span class="fc" id="L1064">        .test()</span>
<span class="fc" id="L1065">        .assertResult(1, 2, 3, 4, 5);</span>
<span class="fc" id="L1066">    }</span>

    @Test
    public void syncFusedMaybe() {
<span class="fc" id="L1070">        Observable.range(1, 5).hide()</span>
<span class="fc" id="L1071">        .switchMap(Functions.justFunction(</span>
<span class="fc" id="L1072">                Maybe.just(1).toObservable()</span>
        ))
<span class="fc" id="L1074">        .test()</span>
<span class="fc" id="L1075">        .assertResult(1, 1, 1, 1, 1);</span>
<span class="fc" id="L1076">    }</span>

    @Test
    public void syncFusedSingle() {
<span class="fc" id="L1080">        Observable.range(1, 5).hide()</span>
<span class="fc" id="L1081">        .switchMap(Functions.justFunction(</span>
<span class="fc" id="L1082">                Single.just(1).toObservable()</span>
        ))
<span class="fc" id="L1084">        .test()</span>
<span class="fc" id="L1085">        .assertResult(1, 1, 1, 1, 1);</span>
<span class="fc" id="L1086">    }</span>

    @Test
    public void syncFusedCompletable() {
<span class="fc" id="L1090">        Observable.range(1, 5).hide()</span>
<span class="fc" id="L1091">        .switchMap(Functions.justFunction(</span>
<span class="fc" id="L1092">                Completable.complete().toObservable()</span>
        ))
<span class="fc" id="L1094">        .test()</span>
<span class="fc" id="L1095">        .assertResult();</span>
<span class="fc" id="L1096">    }</span>

    @Test
    public void asyncFusedRejecting() {
<span class="fc" id="L1100">        Observable.just(1).hide()</span>
<span class="fc" id="L1101">        .switchMap(Functions.justFunction(</span>
<span class="fc" id="L1102">                TestHelper.rejectObservableFusion()</span>
        ))
<span class="fc" id="L1104">        .test()</span>
<span class="fc" id="L1105">        .assertEmpty();</span>
<span class="fc" id="L1106">    }</span>

    @Test
    public void asyncFusedPollCrash() {
<span class="fc" id="L1110">        PublishSubject&lt;Integer&gt; ps = PublishSubject.create();</span>

<span class="fc" id="L1112">        TestObserver&lt;Integer&gt; to = ps</span>
<span class="fc" id="L1113">        .switchMap(Functions.justFunction(</span>
<span class="fc" id="L1114">                Observable.range(1, 5)</span>
<span class="fc" id="L1115">                .observeOn(ImmediateThinScheduler.INSTANCE)</span>
<span class="fc" id="L1116">                .map(new Function&lt;Integer, Integer&gt;() {</span>
                    @Override
                    public Integer apply(Integer v) throws Exception {
<span class="fc" id="L1119">                        throw new TestException();</span>
                    }
                })
<span class="fc" id="L1122">                .compose(TestHelper.&lt;Integer&gt;observableStripBoundary())</span>
        ))
<span class="fc" id="L1124">        .test();</span>

<span class="fc" id="L1126">        to.assertEmpty();</span>

<span class="fc" id="L1128">        ps.onNext(1);</span>

<span class="fc" id="L1130">        to</span>
<span class="fc" id="L1131">        .assertFailure(TestException.class);</span>

<span class="fc" id="L1133">        assertFalse(ps.hasObservers());</span>
<span class="fc" id="L1134">    }</span>

    @Test
    public void asyncFusedPollCrashDelayError() {
<span class="fc" id="L1138">        PublishSubject&lt;Integer&gt; ps = PublishSubject.create();</span>

<span class="fc" id="L1140">        TestObserver&lt;Integer&gt; to = ps</span>
<span class="fc" id="L1141">        .switchMapDelayError(Functions.justFunction(</span>
<span class="fc" id="L1142">                Observable.range(1, 5)</span>
<span class="fc" id="L1143">                .observeOn(ImmediateThinScheduler.INSTANCE)</span>
<span class="fc" id="L1144">                .map(new Function&lt;Integer, Integer&gt;() {</span>
                    @Override
                    public Integer apply(Integer v) throws Exception {
<span class="fc" id="L1147">                        throw new TestException();</span>
                    }
                })
<span class="fc" id="L1150">                .compose(TestHelper.&lt;Integer&gt;observableStripBoundary())</span>
        ))
<span class="fc" id="L1152">        .test();</span>

<span class="fc" id="L1154">        to.assertEmpty();</span>

<span class="fc" id="L1156">        ps.onNext(1);</span>

<span class="fc" id="L1158">        assertTrue(ps.hasObservers());</span>

<span class="fc" id="L1160">        to.assertEmpty();</span>

<span class="fc" id="L1162">        ps.onComplete();</span>

<span class="fc" id="L1164">        to</span>
<span class="fc" id="L1165">        .assertFailure(TestException.class);</span>

<span class="fc" id="L1167">        assertFalse(ps.hasObservers());</span>
<span class="fc" id="L1168">    }</span>

    @Test
    public void fusedBoundary() {
<span class="fc" id="L1172">        String thread = Thread.currentThread().getName();</span>

<span class="fc" id="L1174">        Observable.range(1, 10000)</span>
<span class="fc" id="L1175">        .switchMap(new Function&lt;Integer, ObservableSource&lt;? extends Object&gt;&gt;() {</span>
            @Override
            public ObservableSource&lt;? extends Object&gt; apply(Integer v)
                    throws Exception {
<span class="fc" id="L1179">                return Observable.just(2).hide()</span>
<span class="fc" id="L1180">                .observeOn(Schedulers.single())</span>
<span class="fc" id="L1181">                .map(new Function&lt;Integer, Object&gt;() {</span>
                    @Override
                    public Object apply(Integer w) throws Exception {
<span class="fc" id="L1184">                        return Thread.currentThread().getName();</span>
                    }
                });
            }
        })
<span class="fc" id="L1189">        .test()</span>
<span class="fc" id="L1190">        .awaitDone(5, TimeUnit.SECONDS)</span>
<span class="fc" id="L1191">        .assertNever(thread)</span>
<span class="fc" id="L1192">        .assertNoErrors()</span>
<span class="fc" id="L1193">        .assertComplete();</span>
<span class="fc" id="L1194">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>