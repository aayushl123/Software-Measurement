<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ObservableWindowTimed.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">RxJava_2_x$Unnamed.exec</a> &gt; <a href="index.source.html" class="el_package">io.reactivex.internal.operators.observable</a> &gt; <span class="el_source">ObservableWindowTimed.java</span></div><h1>ObservableWindowTimed.java</h1><pre class="source lang-java linenums">/**
 * Copyright (c) 2016-present, RxJava Contributors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is
 * distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
 * the License for the specific language governing permissions and limitations under the License.
 */

package io.reactivex.internal.operators.observable;

import java.util.*;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicReference;

import io.reactivex.*;
import io.reactivex.Observable;
import io.reactivex.Observer;
import io.reactivex.Scheduler.Worker;
import io.reactivex.disposables.Disposable;
import io.reactivex.internal.disposables.DisposableHelper;
import io.reactivex.internal.observers.QueueDrainObserver;
import io.reactivex.internal.queue.MpscLinkedQueue;
import io.reactivex.internal.util.NotificationLite;
import io.reactivex.observers.SerializedObserver;
import io.reactivex.subjects.UnicastSubject;

public final class ObservableWindowTimed&lt;T&gt; extends AbstractObservableWithUpstream&lt;T, Observable&lt;T&gt;&gt; {
    final long timespan;
    final long timeskip;
    final TimeUnit unit;
    final Scheduler scheduler;
    final long maxSize;
    final int bufferSize;
    final boolean restartTimerOnMaxSize;

    public ObservableWindowTimed(
            ObservableSource&lt;T&gt; source,
            long timespan, long timeskip, TimeUnit unit, Scheduler scheduler, long maxSize,
            int bufferSize, boolean restartTimerOnMaxSize) {
<span class="fc" id="L45">        super(source);</span>
<span class="fc" id="L46">        this.timespan = timespan;</span>
<span class="fc" id="L47">        this.timeskip = timeskip;</span>
<span class="fc" id="L48">        this.unit = unit;</span>
<span class="fc" id="L49">        this.scheduler = scheduler;</span>
<span class="fc" id="L50">        this.maxSize = maxSize;</span>
<span class="fc" id="L51">        this.bufferSize = bufferSize;</span>
<span class="fc" id="L52">        this.restartTimerOnMaxSize = restartTimerOnMaxSize;</span>
<span class="fc" id="L53">    }</span>

    @Override
    public void subscribeActual(Observer&lt;? super Observable&lt;T&gt;&gt; t) {
<span class="fc" id="L57">        SerializedObserver&lt;Observable&lt;T&gt;&gt; actual = new SerializedObserver&lt;Observable&lt;T&gt;&gt;(t);</span>

<span class="fc bfc" id="L59" title="All 2 branches covered.">        if (timespan == timeskip) {</span>
<span class="fc bfc" id="L60" title="All 2 branches covered.">            if (maxSize == Long.MAX_VALUE) {</span>
<span class="fc" id="L61">                source.subscribe(new WindowExactUnboundedObserver&lt;T&gt;(</span>
                        actual,
                        timespan, unit, scheduler, bufferSize));
<span class="fc" id="L64">                return;</span>
            }
<span class="fc" id="L66">            source.subscribe(new WindowExactBoundedObserver&lt;T&gt;(</span>
                        actual,
                        timespan, unit, scheduler,
                        bufferSize, maxSize, restartTimerOnMaxSize));
<span class="fc" id="L70">            return;</span>
        }
<span class="fc" id="L72">        source.subscribe(new WindowSkipObserver&lt;T&gt;(actual,</span>
<span class="fc" id="L73">                timespan, timeskip, unit, scheduler.createWorker(), bufferSize));</span>
<span class="fc" id="L74">    }</span>

    static final class WindowExactUnboundedObserver&lt;T&gt;
            extends QueueDrainObserver&lt;T, Object, Observable&lt;T&gt;&gt;
            implements Observer&lt;T&gt;, Disposable, Runnable {
        final long timespan;
        final TimeUnit unit;
        final Scheduler scheduler;
        final int bufferSize;

        Disposable upstream;

        UnicastSubject&lt;T&gt; window;

<span class="fc" id="L88">        final AtomicReference&lt;Disposable&gt; timer = new AtomicReference&lt;Disposable&gt;();</span>

<span class="fc" id="L90">        static final Object NEXT = new Object();</span>

        volatile boolean terminated;

        WindowExactUnboundedObserver(Observer&lt;? super Observable&lt;T&gt;&gt; actual, long timespan, TimeUnit unit,
                Scheduler scheduler, int bufferSize) {
<span class="fc" id="L96">            super(actual, new MpscLinkedQueue&lt;Object&gt;());</span>
<span class="fc" id="L97">            this.timespan = timespan;</span>
<span class="fc" id="L98">            this.unit = unit;</span>
<span class="fc" id="L99">            this.scheduler = scheduler;</span>
<span class="fc" id="L100">            this.bufferSize = bufferSize;</span>
<span class="fc" id="L101">        }</span>

        @Override
        public void onSubscribe(Disposable d) {
<span class="pc bpc" id="L105" title="1 of 2 branches missed.">            if (DisposableHelper.validate(this.upstream, d)) {</span>
<span class="fc" id="L106">                this.upstream = d;</span>

<span class="fc" id="L108">                window = UnicastSubject.&lt;T&gt;create(bufferSize);</span>

<span class="fc" id="L110">                Observer&lt;? super Observable&lt;T&gt;&gt; a = downstream;</span>
<span class="fc" id="L111">                a.onSubscribe(this);</span>

<span class="fc" id="L113">                a.onNext(window);</span>

<span class="fc bfc" id="L115" title="All 2 branches covered.">                if (!cancelled) {</span>
<span class="fc" id="L116">                    Disposable task = scheduler.schedulePeriodicallyDirect(this, timespan, timespan, unit);</span>
<span class="fc" id="L117">                    DisposableHelper.replace(timer, task);</span>
                }
            }
<span class="fc" id="L120">        }</span>

        @Override
        public void onNext(T t) {
<span class="pc bpc" id="L124" title="1 of 2 branches missed.">            if (terminated) {</span>
<span class="nc" id="L125">                return;</span>
            }
<span class="fc bfc" id="L127" title="All 2 branches covered.">            if (fastEnter()) {</span>
<span class="fc" id="L128">                window.onNext(t);</span>
<span class="fc bfc" id="L129" title="All 2 branches covered.">                if (leave(-1) == 0) {</span>
<span class="fc" id="L130">                    return;</span>
                }
            } else {
<span class="fc" id="L133">                queue.offer(NotificationLite.next(t));</span>
<span class="pc bpc" id="L134" title="1 of 2 branches missed.">                if (!enter()) {</span>
<span class="fc" id="L135">                    return;</span>
                }
            }
<span class="fc" id="L138">            drainLoop();</span>
<span class="fc" id="L139">        }</span>

        @Override
        public void onError(Throwable t) {
<span class="fc" id="L143">            error = t;</span>
<span class="fc" id="L144">            done = true;</span>
<span class="pc bpc" id="L145" title="1 of 2 branches missed.">            if (enter()) {</span>
<span class="fc" id="L146">                drainLoop();</span>
            }

<span class="fc" id="L149">            disposeTimer();</span>
<span class="fc" id="L150">            downstream.onError(t);</span>
<span class="fc" id="L151">        }</span>

        @Override
        public void onComplete() {
<span class="fc" id="L155">            done = true;</span>
<span class="fc bfc" id="L156" title="All 2 branches covered.">            if (enter()) {</span>
<span class="fc" id="L157">                drainLoop();</span>
            }

<span class="fc" id="L160">            disposeTimer();</span>
<span class="fc" id="L161">            downstream.onComplete();</span>
<span class="fc" id="L162">        }</span>

        @Override
        public void dispose() {
<span class="fc" id="L166">            cancelled = true;</span>
<span class="fc" id="L167">        }</span>

        @Override
        public boolean isDisposed() {
<span class="fc" id="L171">            return cancelled;</span>
        }

        void disposeTimer() {
<span class="fc" id="L175">            DisposableHelper.dispose(timer);</span>
<span class="fc" id="L176">        }</span>

        @Override
        public void run() {
<span class="fc bfc" id="L180" title="All 2 branches covered.">            if (cancelled) {</span>
<span class="fc" id="L181">                terminated = true;</span>
<span class="fc" id="L182">                disposeTimer();</span>
            }
<span class="fc" id="L184">            queue.offer(NEXT);</span>
<span class="pc bpc" id="L185" title="1 of 2 branches missed.">            if (enter()) {</span>
<span class="fc" id="L186">                drainLoop();</span>
            }
<span class="fc" id="L188">        }</span>

        void drainLoop() {

<span class="fc" id="L192">            final MpscLinkedQueue&lt;Object&gt; q = (MpscLinkedQueue&lt;Object&gt;)queue;</span>
<span class="fc" id="L193">            final Observer&lt;? super Observable&lt;T&gt;&gt; a = downstream;</span>
<span class="fc" id="L194">            UnicastSubject&lt;T&gt; w = window;</span>

<span class="fc" id="L196">            int missed = 1;</span>
            for (;;) {

                for (;;) {
<span class="fc" id="L200">                    boolean term = terminated; // NOPMD</span>

<span class="fc" id="L202">                    boolean d = done;</span>

<span class="fc" id="L204">                    Object o = q.poll();</span>

<span class="pc bpc" id="L206" title="1 of 6 branches missed.">                    if (d &amp;&amp; (o == null || o == NEXT)) {</span>
<span class="fc" id="L207">                        window = null;</span>
<span class="fc" id="L208">                        q.clear();</span>
<span class="fc" id="L209">                        disposeTimer();</span>
<span class="fc" id="L210">                        Throwable err = error;</span>
<span class="fc bfc" id="L211" title="All 2 branches covered.">                        if (err != null) {</span>
<span class="fc" id="L212">                            w.onError(err);</span>
                        } else {
<span class="fc" id="L214">                            w.onComplete();</span>
                        }
<span class="fc" id="L216">                        return;</span>
                    }

<span class="fc bfc" id="L219" title="All 2 branches covered.">                    if (o == null) {</span>
<span class="fc" id="L220">                        break;</span>
                    }

<span class="fc bfc" id="L223" title="All 2 branches covered.">                    if (o == NEXT) {</span>
<span class="fc" id="L224">                        w.onComplete();</span>
<span class="fc bfc" id="L225" title="All 2 branches covered.">                        if (!term) {</span>
<span class="fc" id="L226">                            w = UnicastSubject.create(bufferSize);</span>
<span class="fc" id="L227">                            window = w;</span>

<span class="fc" id="L229">                            a.onNext(w);</span>
                        } else {
<span class="fc" id="L231">                            upstream.dispose();</span>
                        }
<span class="fc" id="L233">                        continue;</span>
                    }

<span class="fc" id="L236">                    w.onNext(NotificationLite.&lt;T&gt;getValue(o));</span>
<span class="fc" id="L237">                }</span>

<span class="fc" id="L239">                missed = leave(-missed);</span>
<span class="fc bfc" id="L240" title="All 2 branches covered.">                if (missed == 0) {</span>
<span class="fc" id="L241">                    break;</span>
                }
            }
<span class="fc" id="L244">        }</span>
    }

    static final class WindowExactBoundedObserver&lt;T&gt;
    extends QueueDrainObserver&lt;T, Object, Observable&lt;T&gt;&gt;
    implements Disposable {
        final long timespan;
        final TimeUnit unit;
        final Scheduler scheduler;
        final int bufferSize;
        final boolean restartTimerOnMaxSize;
        final long maxSize;

        final Scheduler.Worker worker;

        long count;

        long producerIndex;

        Disposable upstream;

        UnicastSubject&lt;T&gt; window;

        volatile boolean terminated;

<span class="fc" id="L269">        final AtomicReference&lt;Disposable&gt; timer = new AtomicReference&lt;Disposable&gt;();</span>

        WindowExactBoundedObserver(
                Observer&lt;? super Observable&lt;T&gt;&gt; actual,
                long timespan, TimeUnit unit, Scheduler scheduler,
                int bufferSize, long maxSize, boolean restartTimerOnMaxSize) {
<span class="fc" id="L275">            super(actual, new MpscLinkedQueue&lt;Object&gt;());</span>
<span class="fc" id="L276">            this.timespan = timespan;</span>
<span class="fc" id="L277">            this.unit = unit;</span>
<span class="fc" id="L278">            this.scheduler = scheduler;</span>
<span class="fc" id="L279">            this.bufferSize = bufferSize;</span>
<span class="fc" id="L280">            this.maxSize = maxSize;</span>
<span class="fc" id="L281">            this.restartTimerOnMaxSize = restartTimerOnMaxSize;</span>
<span class="fc bfc" id="L282" title="All 2 branches covered.">            if (restartTimerOnMaxSize) {</span>
<span class="fc" id="L283">                worker = scheduler.createWorker();</span>
            } else {
<span class="fc" id="L285">                worker = null;</span>
            }
<span class="fc" id="L287">        }</span>

        @Override
        public void onSubscribe(Disposable d) {
<span class="pc bpc" id="L291" title="1 of 2 branches missed.">            if (DisposableHelper.validate(this.upstream, d)) {</span>
<span class="fc" id="L292">                this.upstream = d;</span>

<span class="fc" id="L294">                Observer&lt;? super Observable&lt;T&gt;&gt; a = downstream;</span>

<span class="fc" id="L296">                a.onSubscribe(this);</span>

<span class="fc bfc" id="L298" title="All 2 branches covered.">                if (cancelled) {</span>
<span class="fc" id="L299">                    return;</span>
                }

<span class="fc" id="L302">                UnicastSubject&lt;T&gt; w = UnicastSubject.create(bufferSize);</span>
<span class="fc" id="L303">                window = w;</span>

<span class="fc" id="L305">                a.onNext(w);</span>

                Disposable task;
<span class="fc" id="L308">                ConsumerIndexHolder consumerIndexHolder = new ConsumerIndexHolder(producerIndex, this);</span>
<span class="fc bfc" id="L309" title="All 2 branches covered.">                if (restartTimerOnMaxSize) {</span>
<span class="fc" id="L310">                    task = worker.schedulePeriodically(consumerIndexHolder, timespan, timespan, unit);</span>
                } else {
<span class="fc" id="L312">                    task = scheduler.schedulePeriodicallyDirect(consumerIndexHolder, timespan, timespan, unit);</span>
                }

<span class="fc" id="L315">                DisposableHelper.replace(timer, task);</span>
            }
<span class="fc" id="L317">        }</span>

        @Override
        public void onNext(T t) {
<span class="pc bpc" id="L321" title="1 of 2 branches missed.">            if (terminated) {</span>
<span class="nc" id="L322">                return;</span>
            }

<span class="fc bfc" id="L325" title="All 2 branches covered.">            if (fastEnter()) {</span>
<span class="fc" id="L326">                UnicastSubject&lt;T&gt; w = window;</span>
<span class="fc" id="L327">                w.onNext(t);</span>

<span class="fc" id="L329">                long c = count + 1;</span>

<span class="fc bfc" id="L331" title="All 2 branches covered.">                if (c &gt;= maxSize) {</span>
<span class="fc" id="L332">                    producerIndex++;</span>
<span class="fc" id="L333">                    count = 0;</span>

<span class="fc" id="L335">                    w.onComplete();</span>

<span class="fc" id="L337">                    w = UnicastSubject.create(bufferSize);</span>
<span class="fc" id="L338">                    window = w;</span>
<span class="fc" id="L339">                    downstream.onNext(w);</span>
<span class="fc bfc" id="L340" title="All 2 branches covered.">                    if (restartTimerOnMaxSize) {</span>
<span class="fc" id="L341">                        Disposable tm = timer.get();</span>
<span class="fc" id="L342">                        tm.dispose();</span>
<span class="fc" id="L343">                        Disposable task = worker.schedulePeriodically(</span>
                                new ConsumerIndexHolder(producerIndex, this), timespan, timespan, unit);

<span class="fc" id="L346">                        DisposableHelper.replace(timer, task);</span>
<span class="fc" id="L347">                    }</span>
                } else {
<span class="fc" id="L349">                    count = c;</span>
                }

<span class="fc bfc" id="L352" title="All 2 branches covered.">                if (leave(-1) == 0) {</span>
<span class="fc" id="L353">                    return;</span>
                }
<span class="fc" id="L355">            } else {</span>
<span class="fc" id="L356">                queue.offer(NotificationLite.next(t));</span>
<span class="fc bfc" id="L357" title="All 2 branches covered.">                if (!enter()) {</span>
<span class="fc" id="L358">                    return;</span>
                }
            }
<span class="fc" id="L361">            drainLoop();</span>
<span class="fc" id="L362">        }</span>

        @Override
        public void onError(Throwable t) {
<span class="fc" id="L366">            error = t;</span>
<span class="fc" id="L367">            done = true;</span>
<span class="pc bpc" id="L368" title="1 of 2 branches missed.">            if (enter()) {</span>
<span class="fc" id="L369">                drainLoop();</span>
            }

<span class="fc" id="L372">            downstream.onError(t);</span>
<span class="fc" id="L373">            disposeTimer();</span>
<span class="fc" id="L374">        }</span>

        @Override
        public void onComplete() {
<span class="fc" id="L378">            done = true;</span>
<span class="fc bfc" id="L379" title="All 2 branches covered.">            if (enter()) {</span>
<span class="fc" id="L380">                drainLoop();</span>
            }

<span class="fc" id="L383">            downstream.onComplete();</span>
<span class="fc" id="L384">            disposeTimer();</span>
<span class="fc" id="L385">        }</span>

        @Override
        public void dispose() {
<span class="fc" id="L389">            cancelled = true;</span>
<span class="fc" id="L390">        }</span>

        @Override
        public boolean isDisposed() {
<span class="fc" id="L394">            return cancelled;</span>
        }

        void disposeTimer() {
<span class="fc" id="L398">            DisposableHelper.dispose(timer);</span>
<span class="fc" id="L399">            Worker w = worker;</span>
<span class="fc bfc" id="L400" title="All 2 branches covered.">            if (w != null) {</span>
<span class="fc" id="L401">                w.dispose();</span>
            }
<span class="fc" id="L403">        }</span>

        void drainLoop() {
<span class="fc" id="L406">            final MpscLinkedQueue&lt;Object&gt; q = (MpscLinkedQueue&lt;Object&gt;)queue;</span>
<span class="fc" id="L407">            final Observer&lt;? super Observable&lt;T&gt;&gt; a = downstream;</span>
<span class="fc" id="L408">            UnicastSubject&lt;T&gt; w = window;</span>

<span class="fc" id="L410">            int missed = 1;</span>
            for (;;) {

                for (;;) {
<span class="fc bfc" id="L414" title="All 2 branches covered.">                    if (terminated) {</span>
<span class="fc" id="L415">                        upstream.dispose();</span>
<span class="fc" id="L416">                        q.clear();</span>
<span class="fc" id="L417">                        disposeTimer();</span>
<span class="fc" id="L418">                        return;</span>
                    }

<span class="fc" id="L421">                    boolean d = done;</span>

<span class="fc" id="L423">                    Object o = q.poll();</span>

<span class="fc bfc" id="L425" title="All 2 branches covered.">                    boolean empty = o == null;</span>
<span class="fc" id="L426">                    boolean isHolder = o instanceof ConsumerIndexHolder;</span>

<span class="pc bpc" id="L428" title="1 of 6 branches missed.">                    if (d &amp;&amp; (empty || isHolder)) {</span>
<span class="fc" id="L429">                        window = null;</span>
<span class="fc" id="L430">                        q.clear();</span>
<span class="fc" id="L431">                        disposeTimer();</span>
<span class="fc" id="L432">                        Throwable err = error;</span>
<span class="fc bfc" id="L433" title="All 2 branches covered.">                        if (err != null) {</span>
<span class="fc" id="L434">                            w.onError(err);</span>
                        } else {
<span class="fc" id="L436">                            w.onComplete();</span>
                        }
<span class="fc" id="L438">                        return;</span>
                    }

<span class="fc bfc" id="L441" title="All 2 branches covered.">                    if (empty) {</span>
<span class="fc" id="L442">                        break;</span>
                    }

<span class="fc bfc" id="L445" title="All 2 branches covered.">                    if (isHolder) {</span>
<span class="fc" id="L446">                        ConsumerIndexHolder consumerIndexHolder = (ConsumerIndexHolder) o;</span>
<span class="fc bfc" id="L447" title="All 4 branches covered.">                        if (restartTimerOnMaxSize || producerIndex == consumerIndexHolder.index) {</span>
<span class="fc" id="L448">                            w.onComplete();</span>
<span class="fc" id="L449">                            count = 0;</span>
<span class="fc" id="L450">                            w = UnicastSubject.create(bufferSize);</span>
<span class="fc" id="L451">                            window = w;</span>

<span class="fc" id="L453">                            a.onNext(w);</span>
                        }
                        continue;
                    }

<span class="fc" id="L458">                    w.onNext(NotificationLite.&lt;T&gt;getValue(o));</span>
<span class="fc" id="L459">                    long c = count + 1;</span>

<span class="fc bfc" id="L461" title="All 2 branches covered.">                    if (c &gt;= maxSize) {</span>
<span class="fc" id="L462">                        producerIndex++;</span>
<span class="fc" id="L463">                        count = 0;</span>

<span class="fc" id="L465">                        w.onComplete();</span>

<span class="fc" id="L467">                        w = UnicastSubject.create(bufferSize);</span>
<span class="fc" id="L468">                        window = w;</span>
<span class="fc" id="L469">                        downstream.onNext(w);</span>

<span class="pc bpc" id="L471" title="1 of 2 branches missed.">                        if (restartTimerOnMaxSize) {</span>
<span class="fc" id="L472">                            Disposable tm = timer.get();</span>
<span class="fc" id="L473">                            tm.dispose();</span>

<span class="fc" id="L475">                            Disposable task = worker.schedulePeriodically(</span>
                                    new ConsumerIndexHolder(producerIndex, this), timespan, timespan, unit);
<span class="pc bpc" id="L477" title="1 of 2 branches missed.">                            if (!timer.compareAndSet(tm, task)) {</span>
<span class="nc" id="L478">                                task.dispose();</span>
                            }
<span class="fc" id="L480">                        }</span>

                    } else {
<span class="fc" id="L483">                        count = c;</span>
                    }
<span class="fc" id="L485">                }</span>

<span class="fc" id="L487">                missed = leave(-missed);</span>
<span class="fc bfc" id="L488" title="All 2 branches covered.">                if (missed == 0) {</span>
<span class="fc" id="L489">                    break;</span>
                }
            }
<span class="fc" id="L492">        }</span>

        static final class ConsumerIndexHolder implements Runnable {
            final long index;
            final WindowExactBoundedObserver&lt;?&gt; parent;
<span class="fc" id="L497">            ConsumerIndexHolder(long index, WindowExactBoundedObserver&lt;?&gt; parent) {</span>
<span class="fc" id="L498">                this.index = index;</span>
<span class="fc" id="L499">                this.parent = parent;</span>
<span class="fc" id="L500">            }</span>

            @Override
            public void run() {
<span class="fc" id="L504">                WindowExactBoundedObserver&lt;?&gt; p = parent;</span>

<span class="fc bfc" id="L506" title="All 2 branches covered.">                if (!p.cancelled) {</span>
<span class="fc" id="L507">                    p.queue.offer(this);</span>
                } else {
<span class="fc" id="L509">                    p.terminated = true;</span>
<span class="fc" id="L510">                    p.disposeTimer();</span>
                }
<span class="fc bfc" id="L512" title="All 2 branches covered.">                if (p.enter()) {</span>
<span class="fc" id="L513">                    p.drainLoop();</span>
                }
<span class="fc" id="L515">            }</span>
        }
    }

    static final class WindowSkipObserver&lt;T&gt;
    extends QueueDrainObserver&lt;T, Object, Observable&lt;T&gt;&gt;
    implements Disposable, Runnable {
        final long timespan;
        final long timeskip;
        final TimeUnit unit;
        final Scheduler.Worker worker;
        final int bufferSize;

        final List&lt;UnicastSubject&lt;T&gt;&gt; windows;

        Disposable upstream;

        volatile boolean terminated;

        WindowSkipObserver(Observer&lt;? super Observable&lt;T&gt;&gt; actual,
                long timespan, long timeskip, TimeUnit unit,
                Worker worker, int bufferSize) {
<span class="fc" id="L537">            super(actual, new MpscLinkedQueue&lt;Object&gt;());</span>
<span class="fc" id="L538">            this.timespan = timespan;</span>
<span class="fc" id="L539">            this.timeskip = timeskip;</span>
<span class="fc" id="L540">            this.unit = unit;</span>
<span class="fc" id="L541">            this.worker = worker;</span>
<span class="fc" id="L542">            this.bufferSize = bufferSize;</span>
<span class="fc" id="L543">            this.windows = new LinkedList&lt;UnicastSubject&lt;T&gt;&gt;();</span>
<span class="fc" id="L544">        }</span>

        @Override
        public void onSubscribe(Disposable d) {
<span class="pc bpc" id="L548" title="1 of 2 branches missed.">            if (DisposableHelper.validate(this.upstream, d)) {</span>
<span class="fc" id="L549">                this.upstream = d;</span>

<span class="fc" id="L551">                downstream.onSubscribe(this);</span>

<span class="fc bfc" id="L553" title="All 2 branches covered.">                if (cancelled) {</span>
<span class="fc" id="L554">                    return;</span>
                }

<span class="fc" id="L557">                final UnicastSubject&lt;T&gt; w = UnicastSubject.create(bufferSize);</span>
<span class="fc" id="L558">                windows.add(w);</span>

<span class="fc" id="L560">                downstream.onNext(w);</span>
<span class="fc" id="L561">                worker.schedule(new CompletionTask(w), timespan, unit);</span>

<span class="fc" id="L563">                worker.schedulePeriodically(this, timeskip, timeskip, unit);</span>
            }

<span class="fc" id="L566">        }</span>

        @Override
        public void onNext(T t) {
<span class="fc bfc" id="L570" title="All 2 branches covered.">            if (fastEnter()) {</span>
<span class="fc bfc" id="L571" title="All 2 branches covered.">                for (UnicastSubject&lt;T&gt; w : windows) {</span>
<span class="fc" id="L572">                    w.onNext(t);</span>
<span class="fc" id="L573">                }</span>
<span class="fc bfc" id="L574" title="All 2 branches covered.">                if (leave(-1) == 0) {</span>
<span class="fc" id="L575">                    return;</span>
                }
            } else {
<span class="fc" id="L578">                queue.offer(t);</span>
<span class="pc bpc" id="L579" title="1 of 2 branches missed.">                if (!enter()) {</span>
<span class="fc" id="L580">                    return;</span>
                }
            }
<span class="fc" id="L583">            drainLoop();</span>
<span class="fc" id="L584">        }</span>

        @Override
        public void onError(Throwable t) {
<span class="fc" id="L588">            error = t;</span>
<span class="fc" id="L589">            done = true;</span>
<span class="pc bpc" id="L590" title="1 of 2 branches missed.">            if (enter()) {</span>
<span class="fc" id="L591">                drainLoop();</span>
            }

<span class="fc" id="L594">            downstream.onError(t);</span>
<span class="fc" id="L595">            disposeWorker();</span>
<span class="fc" id="L596">        }</span>

        @Override
        public void onComplete() {
<span class="fc" id="L600">            done = true;</span>
<span class="fc bfc" id="L601" title="All 2 branches covered.">            if (enter()) {</span>
<span class="fc" id="L602">                drainLoop();</span>
            }

<span class="fc" id="L605">            downstream.onComplete();</span>
<span class="fc" id="L606">            disposeWorker();</span>
<span class="fc" id="L607">        }</span>

        @Override
        public void dispose() {
<span class="fc" id="L611">            cancelled = true;</span>
<span class="fc" id="L612">        }</span>

        @Override
        public boolean isDisposed() {
<span class="fc" id="L616">            return cancelled;</span>
        }

        void disposeWorker() {
<span class="fc" id="L620">            worker.dispose();</span>
<span class="fc" id="L621">        }</span>

        void complete(UnicastSubject&lt;T&gt; w) {
<span class="fc" id="L624">            queue.offer(new SubjectWork&lt;T&gt;(w, false));</span>
<span class="pc bpc" id="L625" title="1 of 2 branches missed.">            if (enter()) {</span>
<span class="fc" id="L626">                drainLoop();</span>
            }
<span class="fc" id="L628">        }</span>

        @SuppressWarnings(&quot;unchecked&quot;)
        void drainLoop() {
<span class="fc" id="L632">            final MpscLinkedQueue&lt;Object&gt; q = (MpscLinkedQueue&lt;Object&gt;)queue;</span>
<span class="fc" id="L633">            final Observer&lt;? super Observable&lt;T&gt;&gt; a = downstream;</span>
<span class="fc" id="L634">            final List&lt;UnicastSubject&lt;T&gt;&gt; ws = windows;</span>

<span class="fc" id="L636">            int missed = 1;</span>

            for (;;) {

                for (;;) {
<span class="pc bpc" id="L641" title="1 of 2 branches missed.">                    if (terminated) {</span>
<span class="nc" id="L642">                        upstream.dispose();</span>
<span class="nc" id="L643">                        disposeWorker();</span>
<span class="nc" id="L644">                        q.clear();</span>
<span class="nc" id="L645">                        ws.clear();</span>
<span class="nc" id="L646">                        return;</span>
                    }

<span class="fc" id="L649">                    boolean d = done;</span>

<span class="fc" id="L651">                    Object v = q.poll();</span>

<span class="fc bfc" id="L653" title="All 2 branches covered.">                    boolean empty = v == null;</span>
<span class="fc" id="L654">                    boolean sw = v instanceof SubjectWork;</span>

<span class="pc bpc" id="L656" title="1 of 6 branches missed.">                    if (d &amp;&amp; (empty || sw)) {</span>
<span class="fc" id="L657">                        q.clear();</span>
<span class="fc" id="L658">                        Throwable e = error;</span>
<span class="fc bfc" id="L659" title="All 2 branches covered.">                        if (e != null) {</span>
<span class="fc bfc" id="L660" title="All 2 branches covered.">                            for (UnicastSubject&lt;T&gt; w : ws) {</span>
<span class="fc" id="L661">                                w.onError(e);</span>
<span class="fc" id="L662">                            }</span>
                        } else {
<span class="fc bfc" id="L664" title="All 2 branches covered.">                            for (UnicastSubject&lt;T&gt; w : ws) {</span>
<span class="fc" id="L665">                                w.onComplete();</span>
<span class="fc" id="L666">                            }</span>
                        }
<span class="fc" id="L668">                        disposeWorker();</span>
<span class="fc" id="L669">                        ws.clear();</span>
<span class="fc" id="L670">                        return;</span>
                    }

<span class="fc bfc" id="L673" title="All 2 branches covered.">                    if (empty) {</span>
<span class="fc" id="L674">                        break;</span>
                    }

<span class="fc bfc" id="L677" title="All 2 branches covered.">                    if (sw) {</span>
<span class="fc" id="L678">                        SubjectWork&lt;T&gt; work = (SubjectWork&lt;T&gt;)v;</span>

<span class="fc bfc" id="L680" title="All 2 branches covered.">                        if (work.open) {</span>
<span class="pc bpc" id="L681" title="1 of 2 branches missed.">                            if (cancelled) {</span>
<span class="nc" id="L682">                                continue;</span>
                            }

<span class="fc" id="L685">                            final UnicastSubject&lt;T&gt; w = UnicastSubject.create(bufferSize);</span>
<span class="fc" id="L686">                            ws.add(w);</span>
<span class="fc" id="L687">                            a.onNext(w);</span>

<span class="fc" id="L689">                            worker.schedule(new CompletionTask(w), timespan, unit);</span>
<span class="fc" id="L690">                        } else {</span>
<span class="fc" id="L691">                            ws.remove(work.w);</span>
<span class="fc" id="L692">                            work.w.onComplete();</span>
<span class="pc bpc" id="L693" title="1 of 4 branches missed.">                            if (ws.isEmpty() &amp;&amp; cancelled) {</span>
<span class="nc" id="L694">                                terminated = true;</span>
                            }
                        }
<span class="fc" id="L697">                    } else {</span>
<span class="fc bfc" id="L698" title="All 2 branches covered.">                        for (UnicastSubject&lt;T&gt; w : ws) {</span>
<span class="fc" id="L699">                            w.onNext((T)v);</span>
<span class="fc" id="L700">                        }</span>
                    }
<span class="fc" id="L702">                }</span>

<span class="fc" id="L704">                missed = leave(-missed);</span>
<span class="pc bpc" id="L705" title="1 of 2 branches missed.">                if (missed == 0) {</span>
<span class="fc" id="L706">                    break;</span>
                }
            }
<span class="fc" id="L709">        }</span>

        @Override
        public void run() {

<span class="fc" id="L714">            UnicastSubject&lt;T&gt; w = UnicastSubject.create(bufferSize);</span>

<span class="fc" id="L716">            SubjectWork&lt;T&gt; sw = new SubjectWork&lt;T&gt;(w, true);</span>
<span class="pc bpc" id="L717" title="1 of 2 branches missed.">            if (!cancelled) {</span>
<span class="fc" id="L718">                queue.offer(sw);</span>
            }
<span class="pc bpc" id="L720" title="1 of 2 branches missed.">            if (enter()) {</span>
<span class="fc" id="L721">                drainLoop();</span>
            }
<span class="fc" id="L723">        }</span>

        static final class SubjectWork&lt;T&gt; {
            final UnicastSubject&lt;T&gt; w;
            final boolean open;
<span class="fc" id="L728">            SubjectWork(UnicastSubject&lt;T&gt; w, boolean open) {</span>
<span class="fc" id="L729">                this.w = w;</span>
<span class="fc" id="L730">                this.open = open;</span>
<span class="fc" id="L731">            }</span>
        }

        final class CompletionTask implements Runnable {
            private final UnicastSubject&lt;T&gt; w;

<span class="fc" id="L737">            CompletionTask(UnicastSubject&lt;T&gt; w) {</span>
<span class="fc" id="L738">                this.w = w;</span>
<span class="fc" id="L739">            }</span>

            @Override
            public void run() {
<span class="fc" id="L743">                complete(w);</span>
<span class="fc" id="L744">            }</span>
        }
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>