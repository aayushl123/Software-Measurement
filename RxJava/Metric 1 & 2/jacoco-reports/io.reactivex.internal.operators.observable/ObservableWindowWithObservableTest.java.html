<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ObservableWindowWithObservableTest.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">RxJava_2_x$Unnamed.exec</a> &gt; <a href="index.source.html" class="el_package">io.reactivex.internal.operators.observable</a> &gt; <span class="el_source">ObservableWindowWithObservableTest.java</span></div><h1>ObservableWindowWithObservableTest.java</h1><pre class="source lang-java linenums">/**
 * Copyright (c) 2016-present, RxJava Contributors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is
 * distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
 * the License for the specific language governing permissions and limitations under the License.
 */

package io.reactivex.internal.operators.observable;

import static org.junit.Assert.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.*;

import org.junit.Test;

import io.reactivex.*;
import io.reactivex.Observable;
import io.reactivex.Observer;
import io.reactivex.disposables.*;
import io.reactivex.exceptions.*;
import io.reactivex.functions.Function;
import io.reactivex.internal.functions.Functions;
import io.reactivex.observers.*;
import io.reactivex.plugins.RxJavaPlugins;
import io.reactivex.subjects.*;

<span class="fc" id="L37">public class ObservableWindowWithObservableTest {</span>

    @Test
    public void testWindowViaObservableNormal1() {
<span class="fc" id="L41">        PublishSubject&lt;Integer&gt; source = PublishSubject.create();</span>
<span class="fc" id="L42">        PublishSubject&lt;Integer&gt; boundary = PublishSubject.create();</span>

<span class="fc" id="L44">        final Observer&lt;Object&gt; o = TestHelper.mockObserver();</span>

<span class="fc" id="L46">        final List&lt;Observer&lt;Object&gt;&gt; values = new ArrayList&lt;Observer&lt;Object&gt;&gt;();</span>

<span class="fc" id="L48">        Observer&lt;Observable&lt;Integer&gt;&gt; wo = new DefaultObserver&lt;Observable&lt;Integer&gt;&gt;() {</span>
            @Override
            public void onNext(Observable&lt;Integer&gt; args) {
<span class="fc" id="L51">                final Observer&lt;Object&gt; mo = TestHelper.mockObserver();</span>
<span class="fc" id="L52">                values.add(mo);</span>

<span class="fc" id="L54">                args.subscribe(mo);</span>
<span class="fc" id="L55">            }</span>

            @Override
            public void onError(Throwable e) {
<span class="nc" id="L59">                o.onError(e);</span>
<span class="nc" id="L60">            }</span>

            @Override
            public void onComplete() {
<span class="fc" id="L64">                o.onComplete();</span>
<span class="fc" id="L65">            }</span>
        };

<span class="fc" id="L68">        source.window(boundary).subscribe(wo);</span>

<span class="fc" id="L70">        int n = 30;</span>
<span class="fc bfc" id="L71" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L72">            source.onNext(i);</span>
<span class="fc bfc" id="L73" title="All 4 branches covered.">            if (i % 3 == 2 &amp;&amp; i &lt; n - 1) {</span>
<span class="fc" id="L74">                boundary.onNext(i / 3);</span>
            }
        }
<span class="fc" id="L77">        source.onComplete();</span>

<span class="fc" id="L79">        verify(o, never()).onError(any(Throwable.class));</span>

<span class="fc" id="L81">        assertEquals(n / 3, values.size());</span>

<span class="fc" id="L83">        int j = 0;</span>
<span class="fc bfc" id="L84" title="All 2 branches covered.">        for (Observer&lt;Object&gt; mo : values) {</span>
<span class="fc" id="L85">            verify(mo, never()).onError(any(Throwable.class));</span>
<span class="fc bfc" id="L86" title="All 2 branches covered.">            for (int i = 0; i &lt; 3; i++) {</span>
<span class="fc" id="L87">                verify(mo).onNext(j + i);</span>
            }
<span class="fc" id="L89">            verify(mo).onComplete();</span>
<span class="fc" id="L90">            j += 3;</span>
<span class="fc" id="L91">        }</span>

<span class="fc" id="L93">        verify(o).onComplete();</span>
<span class="fc" id="L94">    }</span>

    @Test
    public void testWindowViaObservableBoundaryCompletes() {
<span class="fc" id="L98">        PublishSubject&lt;Integer&gt; source = PublishSubject.create();</span>
<span class="fc" id="L99">        PublishSubject&lt;Integer&gt; boundary = PublishSubject.create();</span>

<span class="fc" id="L101">        final Observer&lt;Object&gt; o = TestHelper.mockObserver();</span>

<span class="fc" id="L103">        final List&lt;Observer&lt;Object&gt;&gt; values = new ArrayList&lt;Observer&lt;Object&gt;&gt;();</span>

<span class="fc" id="L105">        Observer&lt;Observable&lt;Integer&gt;&gt; wo = new DefaultObserver&lt;Observable&lt;Integer&gt;&gt;() {</span>
            @Override
            public void onNext(Observable&lt;Integer&gt; args) {
<span class="fc" id="L108">                final Observer&lt;Object&gt; mo = TestHelper.mockObserver();</span>
<span class="fc" id="L109">                values.add(mo);</span>

<span class="fc" id="L111">                args.subscribe(mo);</span>
<span class="fc" id="L112">            }</span>

            @Override
            public void onError(Throwable e) {
<span class="nc" id="L116">                o.onError(e);</span>
<span class="nc" id="L117">            }</span>

            @Override
            public void onComplete() {
<span class="fc" id="L121">                o.onComplete();</span>
<span class="fc" id="L122">            }</span>
        };

<span class="fc" id="L125">        source.window(boundary).subscribe(wo);</span>

<span class="fc" id="L127">        int n = 30;</span>
<span class="fc bfc" id="L128" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L129">            source.onNext(i);</span>
<span class="fc bfc" id="L130" title="All 4 branches covered.">            if (i % 3 == 2 &amp;&amp; i &lt; n - 1) {</span>
<span class="fc" id="L131">                boundary.onNext(i / 3);</span>
            }
        }
<span class="fc" id="L134">        boundary.onComplete();</span>

<span class="fc" id="L136">        assertEquals(n / 3, values.size());</span>

<span class="fc" id="L138">        int j = 0;</span>
<span class="fc bfc" id="L139" title="All 2 branches covered.">        for (Observer&lt;Object&gt; mo : values) {</span>
<span class="fc bfc" id="L140" title="All 2 branches covered.">            for (int i = 0; i &lt; 3; i++) {</span>
<span class="fc" id="L141">                verify(mo).onNext(j + i);</span>
            }
<span class="fc" id="L143">            verify(mo).onComplete();</span>
<span class="fc" id="L144">            verify(mo, never()).onError(any(Throwable.class));</span>
<span class="fc" id="L145">            j += 3;</span>
<span class="fc" id="L146">        }</span>

<span class="fc" id="L148">        verify(o).onComplete();</span>
<span class="fc" id="L149">        verify(o, never()).onError(any(Throwable.class));</span>
<span class="fc" id="L150">    }</span>

    @Test
    public void testWindowViaObservableBoundaryThrows() {
<span class="fc" id="L154">        PublishSubject&lt;Integer&gt; source = PublishSubject.create();</span>
<span class="fc" id="L155">        PublishSubject&lt;Integer&gt; boundary = PublishSubject.create();</span>

<span class="fc" id="L157">        final Observer&lt;Object&gt; o = TestHelper.mockObserver();</span>

<span class="fc" id="L159">        final List&lt;Observer&lt;Object&gt;&gt; values = new ArrayList&lt;Observer&lt;Object&gt;&gt;();</span>

<span class="fc" id="L161">        Observer&lt;Observable&lt;Integer&gt;&gt; wo = new DefaultObserver&lt;Observable&lt;Integer&gt;&gt;() {</span>
            @Override
            public void onNext(Observable&lt;Integer&gt; args) {
<span class="fc" id="L164">                final Observer&lt;Object&gt; mo = TestHelper.mockObserver();</span>
<span class="fc" id="L165">                values.add(mo);</span>

<span class="fc" id="L167">                args.subscribe(mo);</span>
<span class="fc" id="L168">            }</span>

            @Override
            public void onError(Throwable e) {
<span class="fc" id="L172">                o.onError(e);</span>
<span class="fc" id="L173">            }</span>

            @Override
            public void onComplete() {
<span class="nc" id="L177">                o.onComplete();</span>
<span class="nc" id="L178">            }</span>
        };

<span class="fc" id="L181">        source.window(boundary).subscribe(wo);</span>

<span class="fc" id="L183">        source.onNext(0);</span>
<span class="fc" id="L184">        source.onNext(1);</span>
<span class="fc" id="L185">        source.onNext(2);</span>

<span class="fc" id="L187">        boundary.onError(new TestException());</span>

<span class="fc" id="L189">        assertEquals(1, values.size());</span>

<span class="fc" id="L191">        Observer&lt;Object&gt; mo = values.get(0);</span>

<span class="fc" id="L193">        verify(mo).onNext(0);</span>
<span class="fc" id="L194">        verify(mo).onNext(1);</span>
<span class="fc" id="L195">        verify(mo).onNext(2);</span>
<span class="fc" id="L196">        verify(mo).onError(any(TestException.class));</span>

<span class="fc" id="L198">        verify(o, never()).onComplete();</span>
<span class="fc" id="L199">        verify(o).onError(any(TestException.class));</span>
<span class="fc" id="L200">    }</span>

    @Test
    public void testWindowViaObservableSourceThrows() {
<span class="fc" id="L204">        PublishSubject&lt;Integer&gt; source = PublishSubject.create();</span>
<span class="fc" id="L205">        PublishSubject&lt;Integer&gt; boundary = PublishSubject.create();</span>

<span class="fc" id="L207">        final Observer&lt;Object&gt; o = TestHelper.mockObserver();</span>

<span class="fc" id="L209">        final List&lt;Observer&lt;Object&gt;&gt; values = new ArrayList&lt;Observer&lt;Object&gt;&gt;();</span>

<span class="fc" id="L211">        Observer&lt;Observable&lt;Integer&gt;&gt; wo = new DefaultObserver&lt;Observable&lt;Integer&gt;&gt;() {</span>
            @Override
            public void onNext(Observable&lt;Integer&gt; args) {
<span class="fc" id="L214">                final Observer&lt;Object&gt; mo = TestHelper.mockObserver();</span>
<span class="fc" id="L215">                values.add(mo);</span>

<span class="fc" id="L217">                args.subscribe(mo);</span>
<span class="fc" id="L218">            }</span>

            @Override
            public void onError(Throwable e) {
<span class="fc" id="L222">                o.onError(e);</span>
<span class="fc" id="L223">            }</span>

            @Override
            public void onComplete() {
<span class="nc" id="L227">                o.onComplete();</span>
<span class="nc" id="L228">            }</span>
        };

<span class="fc" id="L231">        source.window(boundary).subscribe(wo);</span>

<span class="fc" id="L233">        source.onNext(0);</span>
<span class="fc" id="L234">        source.onNext(1);</span>
<span class="fc" id="L235">        source.onNext(2);</span>

<span class="fc" id="L237">        source.onError(new TestException());</span>

<span class="fc" id="L239">        assertEquals(1, values.size());</span>

<span class="fc" id="L241">        Observer&lt;Object&gt; mo = values.get(0);</span>

<span class="fc" id="L243">        verify(mo).onNext(0);</span>
<span class="fc" id="L244">        verify(mo).onNext(1);</span>
<span class="fc" id="L245">        verify(mo).onNext(2);</span>
<span class="fc" id="L246">        verify(mo).onError(any(TestException.class));</span>

<span class="fc" id="L248">        verify(o, never()).onComplete();</span>
<span class="fc" id="L249">        verify(o).onError(any(TestException.class));</span>
<span class="fc" id="L250">    }</span>

    @Test
    public void testWindowNoDuplication() {
<span class="fc" id="L254">        final PublishSubject&lt;Integer&gt; source = PublishSubject.create();</span>
<span class="fc" id="L255">        final TestObserver&lt;Integer&gt; tow = new TestObserver&lt;Integer&gt;() {</span>
            boolean once;
            @Override
            public void onNext(Integer t) {
<span class="fc bfc" id="L259" title="All 2 branches covered.">                if (!once) {</span>
<span class="fc" id="L260">                    once = true;</span>
<span class="fc" id="L261">                    source.onNext(2);</span>
                }
<span class="fc" id="L263">                super.onNext(t);</span>
<span class="fc" id="L264">            }</span>
        };
<span class="fc" id="L266">        TestObserver&lt;Observable&lt;Integer&gt;&gt; to = new TestObserver&lt;Observable&lt;Integer&gt;&gt;() {</span>
            @Override
            public void onNext(Observable&lt;Integer&gt; t) {
<span class="fc" id="L269">                t.subscribe(tow);</span>
<span class="fc" id="L270">                super.onNext(t);</span>
<span class="fc" id="L271">            }</span>
        };
<span class="fc" id="L273">        source.window(new Callable&lt;Observable&lt;Object&gt;&gt;() {</span>
            @Override
            public Observable&lt;Object&gt; call() {
<span class="fc" id="L276">                return Observable.never();</span>
            }
<span class="fc" id="L278">        }).subscribe(to);</span>

<span class="fc" id="L280">        source.onNext(1);</span>
<span class="fc" id="L281">        source.onComplete();</span>

<span class="fc" id="L283">        to.assertValueCount(1);</span>
<span class="fc" id="L284">        tow.assertValues(1, 2);</span>
<span class="fc" id="L285">    }</span>

    @Test
    public void testWindowViaObservableNoUnsubscribe() {
<span class="fc" id="L289">        Observable&lt;Integer&gt; source = Observable.range(1, 10);</span>
<span class="fc" id="L290">        Callable&lt;Observable&lt;String&gt;&gt; boundary = new Callable&lt;Observable&lt;String&gt;&gt;() {</span>
            @Override
            public Observable&lt;String&gt; call() {
<span class="fc" id="L293">                return Observable.empty();</span>
            }
        };

<span class="fc" id="L297">        TestObserver&lt;Observable&lt;Integer&gt;&gt; to = new TestObserver&lt;Observable&lt;Integer&gt;&gt;();</span>
<span class="fc" id="L298">        source.window(boundary).subscribe(to);</span>

        // 2.0.2 - not anymore
        // assertTrue(&quot;Not cancelled!&quot;, ts.isCancelled());
<span class="fc" id="L302">        to.assertComplete();</span>
<span class="fc" id="L303">    }</span>

    @Test
    public void testBoundaryUnsubscribedOnMainCompletion() {
<span class="fc" id="L307">        PublishSubject&lt;Integer&gt; source = PublishSubject.create();</span>
<span class="fc" id="L308">        final PublishSubject&lt;Integer&gt; boundary = PublishSubject.create();</span>
<span class="fc" id="L309">        Callable&lt;Observable&lt;Integer&gt;&gt; boundaryFunc = new Callable&lt;Observable&lt;Integer&gt;&gt;() {</span>
            @Override
            public Observable&lt;Integer&gt; call() {
<span class="fc" id="L312">                return boundary;</span>
            }
        };

<span class="fc" id="L316">        TestObserver&lt;Observable&lt;Integer&gt;&gt; to = new TestObserver&lt;Observable&lt;Integer&gt;&gt;();</span>
<span class="fc" id="L317">        source.window(boundaryFunc).subscribe(to);</span>

<span class="fc" id="L319">        assertTrue(source.hasObservers());</span>
<span class="fc" id="L320">        assertTrue(boundary.hasObservers());</span>

<span class="fc" id="L322">        source.onComplete();</span>

<span class="fc" id="L324">        assertFalse(source.hasObservers());</span>
<span class="fc" id="L325">        assertFalse(boundary.hasObservers());</span>

<span class="fc" id="L327">        to.assertComplete();</span>
<span class="fc" id="L328">        to.assertNoErrors();</span>
<span class="fc" id="L329">        to.assertValueCount(1);</span>
<span class="fc" id="L330">    }</span>

    @Test
    public void testMainUnsubscribedOnBoundaryCompletion() {
<span class="fc" id="L334">        PublishSubject&lt;Integer&gt; source = PublishSubject.create();</span>
<span class="fc" id="L335">        final PublishSubject&lt;Integer&gt; boundary = PublishSubject.create();</span>
<span class="fc" id="L336">        Callable&lt;Observable&lt;Integer&gt;&gt; boundaryFunc = new Callable&lt;Observable&lt;Integer&gt;&gt;() {</span>
            @Override
            public Observable&lt;Integer&gt; call() {
<span class="fc" id="L339">                return boundary;</span>
            }
        };

<span class="fc" id="L343">        TestObserver&lt;Observable&lt;Integer&gt;&gt; to = new TestObserver&lt;Observable&lt;Integer&gt;&gt;();</span>
<span class="fc" id="L344">        source.window(boundaryFunc).subscribe(to);</span>

<span class="fc" id="L346">        assertTrue(source.hasObservers());</span>
<span class="fc" id="L347">        assertTrue(boundary.hasObservers());</span>

<span class="fc" id="L349">        boundary.onComplete();</span>

<span class="fc" id="L351">        assertFalse(source.hasObservers());</span>
<span class="fc" id="L352">        assertFalse(boundary.hasObservers());</span>

<span class="fc" id="L354">        to.assertComplete();</span>
<span class="fc" id="L355">        to.assertNoErrors();</span>
<span class="fc" id="L356">        to.assertValueCount(1);</span>
<span class="fc" id="L357">    }</span>

    @Test
    public void testChildUnsubscribed() {
<span class="fc" id="L361">        PublishSubject&lt;Integer&gt; source = PublishSubject.create();</span>
<span class="fc" id="L362">        final PublishSubject&lt;Integer&gt; boundary = PublishSubject.create();</span>
<span class="fc" id="L363">        Callable&lt;Observable&lt;Integer&gt;&gt; boundaryFunc = new Callable&lt;Observable&lt;Integer&gt;&gt;() {</span>
            @Override
            public Observable&lt;Integer&gt; call() {
<span class="fc" id="L366">                return boundary;</span>
            }
        };

<span class="fc" id="L370">        TestObserver&lt;Observable&lt;Integer&gt;&gt; to = new TestObserver&lt;Observable&lt;Integer&gt;&gt;();</span>
<span class="fc" id="L371">        source.window(boundaryFunc).subscribe(to);</span>

<span class="fc" id="L373">        assertTrue(source.hasObservers());</span>
<span class="fc" id="L374">        assertTrue(boundary.hasObservers());</span>

<span class="fc" id="L376">        to.dispose();</span>

<span class="fc" id="L378">        assertTrue(source.hasObservers());</span>

<span class="fc" id="L380">        assertFalse(boundary.hasObservers());</span>

<span class="fc" id="L382">        to.values().get(0).test(true);</span>

<span class="fc" id="L384">        assertFalse(source.hasObservers());</span>

<span class="fc" id="L386">        to.assertNotComplete();</span>
<span class="fc" id="L387">        to.assertNoErrors();</span>
<span class="fc" id="L388">        to.assertValueCount(1);</span>
<span class="fc" id="L389">    }</span>

    @Test
    public void newBoundaryCalledAfterWindowClosed() {
<span class="fc" id="L393">        final AtomicInteger calls = new AtomicInteger();</span>
<span class="fc" id="L394">        PublishSubject&lt;Integer&gt; source = PublishSubject.create();</span>
<span class="fc" id="L395">        final PublishSubject&lt;Integer&gt; boundary = PublishSubject.create();</span>
<span class="fc" id="L396">        Callable&lt;Observable&lt;Integer&gt;&gt; boundaryFunc = new Callable&lt;Observable&lt;Integer&gt;&gt;() {</span>
            @Override
            public Observable&lt;Integer&gt; call() {
<span class="fc" id="L399">                calls.getAndIncrement();</span>
<span class="fc" id="L400">                return boundary;</span>
            }
        };

<span class="fc" id="L404">        TestObserver&lt;Observable&lt;Integer&gt;&gt; to = new TestObserver&lt;Observable&lt;Integer&gt;&gt;();</span>
<span class="fc" id="L405">        source.window(boundaryFunc).subscribe(to);</span>

<span class="fc" id="L407">        source.onNext(1);</span>
<span class="fc" id="L408">        boundary.onNext(1);</span>
<span class="fc" id="L409">        assertTrue(boundary.hasObservers());</span>

<span class="fc" id="L411">        source.onNext(2);</span>
<span class="fc" id="L412">        boundary.onNext(2);</span>
<span class="fc" id="L413">        assertTrue(boundary.hasObservers());</span>

<span class="fc" id="L415">        source.onNext(3);</span>
<span class="fc" id="L416">        boundary.onNext(3);</span>
<span class="fc" id="L417">        assertTrue(boundary.hasObservers());</span>

<span class="fc" id="L419">        source.onNext(4);</span>
<span class="fc" id="L420">        source.onComplete();</span>

<span class="fc" id="L422">        to.assertNoErrors();</span>
<span class="fc" id="L423">        to.assertValueCount(4);</span>
<span class="fc" id="L424">        to.assertComplete();</span>

<span class="fc" id="L426">        assertFalse(source.hasObservers());</span>
<span class="fc" id="L427">        assertFalse(boundary.hasObservers());</span>
<span class="fc" id="L428">    }</span>

    @Test
    public void boundaryDispose() {
<span class="fc" id="L432">        TestHelper.checkDisposed(Observable.never().window(Observable.never()));</span>
<span class="fc" id="L433">    }</span>

    @Test
    public void boundaryDispose2() {
<span class="fc" id="L437">        TestHelper.checkDisposed(Observable.never().window(Functions.justCallable(Observable.never())));</span>
<span class="fc" id="L438">    }</span>

    @Test
    public void boundaryOnError() {
<span class="fc" id="L442">        TestObserver&lt;Object&gt; to = Observable.error(new TestException())</span>
<span class="fc" id="L443">        .window(Observable.never())</span>
<span class="fc" id="L444">        .flatMap(Functions.&lt;Observable&lt;Object&gt;&gt;identity(), true)</span>
<span class="fc" id="L445">        .test()</span>
<span class="fc" id="L446">        .assertFailure(CompositeException.class);</span>

<span class="fc" id="L448">        List&lt;Throwable&gt; errors = TestHelper.compositeList(to.errors().get(0));</span>

<span class="fc" id="L450">        TestHelper.assertError(errors, 0, TestException.class);</span>
<span class="fc" id="L451">    }</span>

    @Test
    public void mainError() {
<span class="fc" id="L455">        Observable.error(new TestException())</span>
<span class="fc" id="L456">        .window(Functions.justCallable(Observable.never()))</span>
<span class="fc" id="L457">        .test()</span>
<span class="fc" id="L458">        .assertError(TestException.class);</span>
<span class="fc" id="L459">    }</span>

    @Test
    public void innerBadSource() {
<span class="fc" id="L463">        TestHelper.checkBadSourceObservable(new Function&lt;Observable&lt;Integer&gt;, Object&gt;() {</span>
            @Override
            public Object apply(Observable&lt;Integer&gt; o) throws Exception {
<span class="fc" id="L466">                return Observable.just(1).window(o).flatMap(new Function&lt;Observable&lt;Integer&gt;, ObservableSource&lt;Integer&gt;&gt;() {</span>
                    @Override
                    public ObservableSource&lt;Integer&gt; apply(Observable&lt;Integer&gt; v) throws Exception {
<span class="fc" id="L469">                        return v;</span>
                    }
                });
            }
<span class="fc" id="L473">        }, false, 1, 1, (Object[])null);</span>

<span class="fc" id="L475">        TestHelper.checkBadSourceObservable(new Function&lt;Observable&lt;Integer&gt;, Object&gt;() {</span>
            @Override
            public Object apply(Observable&lt;Integer&gt; o) throws Exception {
<span class="fc" id="L478">                return Observable.just(1).window(Functions.justCallable(o)).flatMap(new Function&lt;Observable&lt;Integer&gt;, ObservableSource&lt;Integer&gt;&gt;() {</span>
                    @Override
                    public ObservableSource&lt;Integer&gt; apply(Observable&lt;Integer&gt; v) throws Exception {
<span class="fc" id="L481">                        return v;</span>
                    }
                });
            }
<span class="fc" id="L485">        }, false, 1, 1, (Object[])null);</span>
<span class="fc" id="L486">    }</span>

    @Test
    public void reentrant() {
<span class="fc" id="L490">        final Subject&lt;Integer&gt; ps = PublishSubject.&lt;Integer&gt;create();</span>

<span class="fc" id="L492">        TestObserver&lt;Integer&gt; to = new TestObserver&lt;Integer&gt;() {</span>
            @Override
            public void onNext(Integer t) {
<span class="fc" id="L495">                super.onNext(t);</span>
<span class="fc bfc" id="L496" title="All 2 branches covered.">                if (t == 1) {</span>
<span class="fc" id="L497">                    ps.onNext(2);</span>
<span class="fc" id="L498">                    ps.onComplete();</span>
                }
<span class="fc" id="L500">            }</span>
        };

<span class="fc" id="L503">        ps.window(BehaviorSubject.createDefault(1))</span>
<span class="fc" id="L504">        .flatMap(new Function&lt;Observable&lt;Integer&gt;, ObservableSource&lt;Integer&gt;&gt;() {</span>
            @Override
            public ObservableSource&lt;Integer&gt; apply(Observable&lt;Integer&gt; v) throws Exception {
<span class="fc" id="L507">                return v;</span>
            }
        })
<span class="fc" id="L510">        .subscribe(to);</span>

<span class="fc" id="L512">        ps.onNext(1);</span>

<span class="fc" id="L514">        to</span>
<span class="fc" id="L515">        .awaitDone(1, TimeUnit.SECONDS)</span>
<span class="fc" id="L516">        .assertResult(1, 2);</span>
<span class="fc" id="L517">    }</span>

    @Test
    public void reentrantCallable() {
<span class="fc" id="L521">        final Subject&lt;Integer&gt; ps = PublishSubject.&lt;Integer&gt;create();</span>

<span class="fc" id="L523">        TestObserver&lt;Integer&gt; to = new TestObserver&lt;Integer&gt;() {</span>
            @Override
            public void onNext(Integer t) {
<span class="fc" id="L526">                super.onNext(t);</span>
<span class="fc bfc" id="L527" title="All 2 branches covered.">                if (t == 1) {</span>
<span class="fc" id="L528">                    ps.onNext(2);</span>
<span class="fc" id="L529">                    ps.onComplete();</span>
                }
<span class="fc" id="L531">            }</span>
        };

<span class="fc" id="L534">        ps.window(new Callable&lt;Observable&lt;Integer&gt;&gt;() {</span>
            boolean once;
            @Override
            public Observable&lt;Integer&gt; call() throws Exception {
<span class="fc bfc" id="L538" title="All 2 branches covered.">                if (!once) {</span>
<span class="fc" id="L539">                    once = true;</span>
<span class="fc" id="L540">                    return BehaviorSubject.createDefault(1);</span>
                }
<span class="fc" id="L542">                return Observable.never();</span>
            }
        })
<span class="fc" id="L545">        .flatMap(new Function&lt;Observable&lt;Integer&gt;, ObservableSource&lt;Integer&gt;&gt;() {</span>
            @Override
            public ObservableSource&lt;Integer&gt; apply(Observable&lt;Integer&gt; v) throws Exception {
<span class="fc" id="L548">                return v;</span>
            }
        })
<span class="fc" id="L551">        .subscribe(to);</span>

<span class="fc" id="L553">        ps.onNext(1);</span>

<span class="fc" id="L555">        to</span>
<span class="fc" id="L556">        .awaitDone(1, TimeUnit.SECONDS)</span>
<span class="fc" id="L557">        .assertResult(1, 2);</span>
<span class="fc" id="L558">    }</span>

    @Test
    public void badSource() {
<span class="fc" id="L562">        TestHelper.checkBadSourceObservable(new Function&lt;Observable&lt;Object&gt;, Object&gt;() {</span>
            @Override
            public Object apply(Observable&lt;Object&gt; o) throws Exception {
<span class="fc" id="L565">                return o.window(Observable.never()).flatMap(new Function&lt;Observable&lt;Object&gt;, ObservableSource&lt;Object&gt;&gt;() {</span>
                    @Override
                    public ObservableSource&lt;Object&gt; apply(Observable&lt;Object&gt; v) throws Exception {
<span class="fc" id="L568">                        return v;</span>
                    }
                });
            }
<span class="fc" id="L572">        }, false, 1, 1, 1);</span>
<span class="fc" id="L573">    }</span>

    @Test
    public void badSourceCallable() {
<span class="fc" id="L577">        TestHelper.checkBadSourceObservable(new Function&lt;Observable&lt;Object&gt;, Object&gt;() {</span>
            @Override
            public Object apply(Observable&lt;Object&gt; o) throws Exception {
<span class="fc" id="L580">                return o.window(Functions.justCallable(Observable.never())).flatMap(new Function&lt;Observable&lt;Object&gt;, ObservableSource&lt;Object&gt;&gt;() {</span>
                    @Override
                    public ObservableSource&lt;Object&gt; apply(Observable&lt;Object&gt; v) throws Exception {
<span class="fc" id="L583">                        return v;</span>
                    }
                });
            }
<span class="fc" id="L587">        }, false, 1, 1, 1);</span>
<span class="fc" id="L588">    }</span>

    @Test
    public void boundaryError() {
<span class="fc" id="L592">        BehaviorSubject.createDefault(1)</span>
<span class="fc" id="L593">        .window(Functions.justCallable(Observable.error(new TestException())))</span>
<span class="fc" id="L594">        .test()</span>
<span class="fc" id="L595">        .assertValueCount(1)</span>
<span class="fc" id="L596">        .assertNotComplete()</span>
<span class="fc" id="L597">        .assertError(TestException.class);</span>
<span class="fc" id="L598">    }</span>

    @Test
    public void boundaryCallableCrashOnCall2() {
<span class="fc" id="L602">        BehaviorSubject.createDefault(1)</span>
<span class="fc" id="L603">        .window(new Callable&lt;Observable&lt;Integer&gt;&gt;() {</span>
            int calls;
            @Override
            public Observable&lt;Integer&gt; call() throws Exception {
<span class="fc bfc" id="L607" title="All 2 branches covered.">                if (++calls == 2) {</span>
<span class="fc" id="L608">                    throw new TestException();</span>
                }
<span class="fc" id="L610">                return Observable.just(1);</span>
            }
        })
<span class="fc" id="L613">        .test()</span>
<span class="fc" id="L614">        .assertError(TestException.class)</span>
<span class="fc" id="L615">        .assertNotComplete();</span>
<span class="fc" id="L616">    }</span>

    @Test
    public void oneWindow() {
<span class="fc" id="L620">        PublishSubject&lt;Integer&gt; ps = PublishSubject.create();</span>

<span class="fc" id="L622">        TestObserver&lt;Observable&lt;Integer&gt;&gt; to = BehaviorSubject.createDefault(1)</span>
<span class="fc" id="L623">        .window(Functions.justCallable(ps))</span>
<span class="fc" id="L624">        .take(1)</span>
<span class="fc" id="L625">        .test();</span>

<span class="fc" id="L627">        ps.onNext(1);</span>

<span class="fc" id="L629">        to</span>
<span class="fc" id="L630">        .assertValueCount(1)</span>
<span class="fc" id="L631">        .assertNoErrors()</span>
<span class="fc" id="L632">        .assertComplete();</span>
<span class="fc" id="L633">    }</span>

    @Test
    public void boundaryDirectDoubleOnSubscribe() {
<span class="fc" id="L637">        TestHelper.checkDoubleOnSubscribeObservable(new Function&lt;Observable&lt;Object&gt;, Observable&lt;Observable&lt;Object&gt;&gt;&gt;() {</span>
            @Override
            public Observable&lt;Observable&lt;Object&gt;&gt; apply(Observable&lt;Object&gt; f)
                    throws Exception {
<span class="fc" id="L641">                return f.window(Observable.never()).takeLast(1);</span>
            }
        });
<span class="fc" id="L644">    }</span>

    @Test
    public void upstreamDisposedWhenOutputsDisposed() {
<span class="fc" id="L648">        PublishSubject&lt;Integer&gt; source = PublishSubject.create();</span>
<span class="fc" id="L649">        PublishSubject&lt;Integer&gt; boundary = PublishSubject.create();</span>

<span class="fc" id="L651">        TestObserver&lt;Integer&gt; to = source.window(boundary)</span>
<span class="fc" id="L652">        .take(1)</span>
<span class="fc" id="L653">        .flatMap(new Function&lt;Observable&lt;Integer&gt;, ObservableSource&lt;Integer&gt;&gt;() {</span>
            @Override
            public ObservableSource&lt;Integer&gt; apply(
                    Observable&lt;Integer&gt; w) throws Exception {
<span class="fc" id="L657">                return w.take(1);</span>
            }
        })
<span class="fc" id="L660">        .test();</span>

<span class="fc" id="L662">        source.onNext(1);</span>

<span class="fc" id="L664">        assertFalse(&quot;source not disposed&quot;, source.hasObservers());</span>
<span class="fc" id="L665">        assertFalse(&quot;boundary not disposed&quot;, boundary.hasObservers());</span>

<span class="fc" id="L667">        to.assertResult(1);</span>
<span class="fc" id="L668">    }</span>

    @Test
    public void mainAndBoundaryBothError() {
<span class="fc" id="L672">        List&lt;Throwable&gt; errors = TestHelper.trackPluginErrors();</span>
        try {
<span class="fc" id="L674">            final AtomicReference&lt;Observer&lt;? super Object&gt;&gt; ref = new AtomicReference&lt;Observer&lt;? super Object&gt;&gt;();</span>

<span class="fc" id="L676">            TestObserver&lt;Observable&lt;Object&gt;&gt; to = Observable.error(new TestException(&quot;main&quot;))</span>
<span class="fc" id="L677">            .window(new Observable&lt;Object&gt;() {</span>
                @Override
                protected void subscribeActual(Observer&lt;? super Object&gt; observer) {
<span class="fc" id="L680">                    observer.onSubscribe(Disposables.empty());</span>
<span class="fc" id="L681">                    ref.set(observer);</span>
<span class="fc" id="L682">                }</span>
            })
<span class="fc" id="L684">            .test();</span>

<span class="fc" id="L686">            to</span>
<span class="fc" id="L687">            .assertValueCount(1)</span>
<span class="fc" id="L688">            .assertError(TestException.class)</span>
<span class="fc" id="L689">            .assertErrorMessage(&quot;main&quot;)</span>
<span class="fc" id="L690">            .assertNotComplete();</span>

<span class="fc" id="L692">            ref.get().onError(new TestException(&quot;inner&quot;));</span>

<span class="fc" id="L694">            TestHelper.assertUndeliverable(errors, 0, TestException.class, &quot;inner&quot;);</span>
        } finally {
<span class="fc" id="L696">            RxJavaPlugins.reset();</span>
        }
<span class="fc" id="L698">    }</span>

    @Test
    public void mainCompleteBoundaryErrorRace() {
<span class="fc" id="L702">        final TestException ex = new TestException();</span>

<span class="fc bfc" id="L704" title="All 2 branches covered.">        for (int i = 0; i &lt; TestHelper.RACE_LONG_LOOPS; i++) {</span>
<span class="fc" id="L705">            List&lt;Throwable&gt; errors = TestHelper.trackPluginErrors();</span>
            try {
<span class="fc" id="L707">                final AtomicReference&lt;Observer&lt;? super Object&gt;&gt; refMain = new AtomicReference&lt;Observer&lt;? super Object&gt;&gt;();</span>
<span class="fc" id="L708">                final AtomicReference&lt;Observer&lt;? super Object&gt;&gt; ref = new AtomicReference&lt;Observer&lt;? super Object&gt;&gt;();</span>

<span class="fc" id="L710">                TestObserver&lt;Observable&lt;Object&gt;&gt; to = new Observable&lt;Object&gt;() {</span>
                    @Override
                    protected void subscribeActual(Observer&lt;? super Object&gt; observer) {
<span class="fc" id="L713">                        observer.onSubscribe(Disposables.empty());</span>
<span class="fc" id="L714">                        refMain.set(observer);</span>
<span class="fc" id="L715">                    }</span>
                }
<span class="fc" id="L717">                .window(new Observable&lt;Object&gt;() {</span>
                    @Override
                    protected void subscribeActual(Observer&lt;? super Object&gt; observer) {
<span class="fc" id="L720">                        observer.onSubscribe(Disposables.empty());</span>
<span class="fc" id="L721">                        ref.set(observer);</span>
<span class="fc" id="L722">                    }</span>
                })
<span class="fc" id="L724">                .test();</span>

<span class="fc" id="L726">                Runnable r1 = new Runnable() {</span>
                    @Override
                    public void run() {
<span class="fc" id="L729">                        refMain.get().onComplete();</span>
<span class="fc" id="L730">                    }</span>
                };
<span class="fc" id="L732">                Runnable r2 = new Runnable() {</span>
                    @Override
                    public void run() {
<span class="fc" id="L735">                        ref.get().onError(ex);</span>
<span class="fc" id="L736">                    }</span>
                };

<span class="fc" id="L739">                TestHelper.race(r1, r2);</span>

<span class="fc" id="L741">                to</span>
<span class="fc" id="L742">                .assertValueCount(1)</span>
<span class="fc" id="L743">                .assertTerminated();</span>

<span class="fc bfc" id="L745" title="All 2 branches covered.">                if (!errors.isEmpty()) {</span>
<span class="fc" id="L746">                    TestHelper.assertUndeliverable(errors, 0, TestException.class);</span>
                }
            } finally {
<span class="fc" id="L749">                RxJavaPlugins.reset();</span>
            }
        }
<span class="fc" id="L752">    }</span>

    @Test
    public void mainNextBoundaryNextRace() {
<span class="fc bfc" id="L756" title="All 2 branches covered.">        for (int i = 0; i &lt; TestHelper.RACE_LONG_LOOPS; i++) {</span>
<span class="fc" id="L757">            final AtomicReference&lt;Observer&lt;? super Object&gt;&gt; refMain = new AtomicReference&lt;Observer&lt;? super Object&gt;&gt;();</span>
<span class="fc" id="L758">            final AtomicReference&lt;Observer&lt;? super Object&gt;&gt; ref = new AtomicReference&lt;Observer&lt;? super Object&gt;&gt;();</span>

<span class="fc" id="L760">            TestObserver&lt;Observable&lt;Object&gt;&gt; to = new Observable&lt;Object&gt;() {</span>
                @Override
                protected void subscribeActual(Observer&lt;? super Object&gt; observer) {
<span class="fc" id="L763">                    observer.onSubscribe(Disposables.empty());</span>
<span class="fc" id="L764">                    refMain.set(observer);</span>
<span class="fc" id="L765">                }</span>
            }
<span class="fc" id="L767">            .window(new Observable&lt;Object&gt;() {</span>
                @Override
                protected void subscribeActual(Observer&lt;? super Object&gt; observer) {
<span class="fc" id="L770">                    observer.onSubscribe(Disposables.empty());</span>
<span class="fc" id="L771">                    ref.set(observer);</span>
<span class="fc" id="L772">                }</span>
            })
<span class="fc" id="L774">            .test();</span>

<span class="fc" id="L776">            Runnable r1 = new Runnable() {</span>
                @Override
                public void run() {
<span class="fc" id="L779">                    refMain.get().onNext(1);</span>
<span class="fc" id="L780">                }</span>
            };
<span class="fc" id="L782">            Runnable r2 = new Runnable() {</span>
                @Override
                public void run() {
<span class="fc" id="L785">                    ref.get().onNext(1);</span>
<span class="fc" id="L786">                }</span>
            };

<span class="fc" id="L789">            TestHelper.race(r1, r2);</span>

<span class="fc" id="L791">            to</span>
<span class="fc" id="L792">            .assertValueCount(2)</span>
<span class="fc" id="L793">            .assertNotComplete()</span>
<span class="fc" id="L794">            .assertNoErrors();</span>
        }
<span class="fc" id="L796">    }</span>

    @Test
    public void takeOneAnotherBoundary() {
<span class="fc" id="L800">        final AtomicReference&lt;Observer&lt;? super Object&gt;&gt; refMain = new AtomicReference&lt;Observer&lt;? super Object&gt;&gt;();</span>
<span class="fc" id="L801">        final AtomicReference&lt;Observer&lt;? super Object&gt;&gt; ref = new AtomicReference&lt;Observer&lt;? super Object&gt;&gt;();</span>

<span class="fc" id="L803">        TestObserver&lt;Observable&lt;Object&gt;&gt; to = new Observable&lt;Object&gt;() {</span>
            @Override
            protected void subscribeActual(Observer&lt;? super Object&gt; observer) {
<span class="fc" id="L806">                observer.onSubscribe(Disposables.empty());</span>
<span class="fc" id="L807">                refMain.set(observer);</span>
<span class="fc" id="L808">            }</span>
        }
<span class="fc" id="L810">        .window(new Observable&lt;Object&gt;() {</span>
            @Override
            protected void subscribeActual(Observer&lt;? super Object&gt; observer) {
<span class="fc" id="L813">                observer.onSubscribe(Disposables.empty());</span>
<span class="fc" id="L814">                ref.set(observer);</span>
<span class="fc" id="L815">            }</span>
        })
<span class="fc" id="L817">        .test();</span>

<span class="fc" id="L819">        to.assertValueCount(1)</span>
<span class="fc" id="L820">        .assertNotTerminated()</span>
<span class="fc" id="L821">        .cancel();</span>

<span class="fc" id="L823">        ref.get().onNext(1);</span>

<span class="fc" id="L825">        to.assertValueCount(1)</span>
<span class="fc" id="L826">        .assertNotTerminated();</span>
<span class="fc" id="L827">    }</span>

    @Test
    public void disposeMainBoundaryCompleteRace() {
<span class="fc bfc" id="L831" title="All 2 branches covered.">        for (int i = 0; i &lt; TestHelper.RACE_LONG_LOOPS; i++) {</span>
<span class="fc" id="L832">            final AtomicReference&lt;Observer&lt;? super Object&gt;&gt; refMain = new AtomicReference&lt;Observer&lt;? super Object&gt;&gt;();</span>
<span class="fc" id="L833">            final AtomicReference&lt;Observer&lt;? super Object&gt;&gt; ref = new AtomicReference&lt;Observer&lt;? super Object&gt;&gt;();</span>

<span class="fc" id="L835">            final TestObserver&lt;Observable&lt;Object&gt;&gt; to = new Observable&lt;Object&gt;() {</span>
                 @Override
                 protected void subscribeActual(Observer&lt;? super Object&gt; observer) {
<span class="fc" id="L838">                     observer.onSubscribe(Disposables.empty());</span>
<span class="fc" id="L839">                     refMain.set(observer);</span>
<span class="fc" id="L840">                 }</span>
             }
<span class="fc" id="L842">             .window(new Observable&lt;Object&gt;() {</span>
                 @Override
                 protected void subscribeActual(Observer&lt;? super Object&gt; observer) {
<span class="fc" id="L845">                     final AtomicInteger counter = new AtomicInteger();</span>
<span class="fc" id="L846">                     observer.onSubscribe(new Disposable() {</span>

                         @Override
                         public void dispose() {
                             // about a microsecond
<span class="fc bfc" id="L851" title="All 2 branches covered.">                             for (int i = 0; i &lt; 100; i++) {</span>
<span class="fc" id="L852">                                 counter.incrementAndGet();</span>
                             }
<span class="fc" id="L854">                         }</span>

                         @Override
                         public boolean isDisposed() {
<span class="nc" id="L858">                             return false;</span>
                         }
                      });
<span class="fc" id="L861">                     ref.set(observer);</span>
<span class="fc" id="L862">                 }</span>
             })
<span class="fc" id="L864">             .test();</span>

<span class="fc" id="L866">             Runnable r1 = new Runnable() {</span>
                 @Override
                 public void run() {
<span class="fc" id="L869">                     to.cancel();</span>
<span class="fc" id="L870">                 }</span>
             };
<span class="fc" id="L872">             Runnable r2 = new Runnable() {</span>
                 @Override
                 public void run() {
<span class="fc" id="L875">                     Observer&lt;Object&gt; o = ref.get();</span>
<span class="fc" id="L876">                     o.onNext(1);</span>
<span class="fc" id="L877">                     o.onComplete();</span>
<span class="fc" id="L878">                 }</span>
             };

<span class="fc" id="L881">             TestHelper.race(r1, r2);</span>
        }
<span class="fc" id="L883">    }</span>

    @Test
    public void disposeMainBoundaryErrorRace() {
<span class="fc" id="L887">        final TestException ex = new TestException();</span>

<span class="fc bfc" id="L889" title="All 2 branches covered.">        for (int i = 0; i &lt; TestHelper.RACE_LONG_LOOPS; i++) {</span>
<span class="fc" id="L890">           final AtomicReference&lt;Observer&lt;? super Object&gt;&gt; refMain = new AtomicReference&lt;Observer&lt;? super Object&gt;&gt;();</span>
<span class="fc" id="L891">           final AtomicReference&lt;Observer&lt;? super Object&gt;&gt; ref = new AtomicReference&lt;Observer&lt;? super Object&gt;&gt;();</span>

<span class="fc" id="L893">           final TestObserver&lt;Observable&lt;Object&gt;&gt; to = new Observable&lt;Object&gt;() {</span>
               @Override
               protected void subscribeActual(Observer&lt;? super Object&gt; observer) {
<span class="fc" id="L896">                   observer.onSubscribe(Disposables.empty());</span>
<span class="fc" id="L897">                   refMain.set(observer);</span>
<span class="fc" id="L898">               }</span>
           }
<span class="fc" id="L900">           .window(new Observable&lt;Object&gt;() {</span>
               @Override
               protected void subscribeActual(Observer&lt;? super Object&gt; observer) {
<span class="fc" id="L903">                   final AtomicInteger counter = new AtomicInteger();</span>
<span class="fc" id="L904">                   observer.onSubscribe(new Disposable() {</span>

                       @Override
                       public void dispose() {
                           // about a microsecond
<span class="fc bfc" id="L909" title="All 2 branches covered.">                           for (int i = 0; i &lt; 100; i++) {</span>
<span class="fc" id="L910">                               counter.incrementAndGet();</span>
                           }
<span class="fc" id="L912">                       }</span>

                       @Override
                       public boolean isDisposed() {
<span class="nc" id="L916">                           return false;</span>
                       }
                    });
<span class="fc" id="L919">                   ref.set(observer);</span>
<span class="fc" id="L920">               }</span>
           })
<span class="fc" id="L922">           .test();</span>

<span class="fc" id="L924">            Runnable r1 = new Runnable() {</span>
                @Override
                public void run() {
<span class="fc" id="L927">                    to.cancel();</span>
<span class="fc" id="L928">                }</span>
            };
<span class="fc" id="L930">            Runnable r2 = new Runnable() {</span>
                @Override
                public void run() {
<span class="fc" id="L933">                    Observer&lt;Object&gt; o = ref.get();</span>
<span class="fc" id="L934">                    o.onNext(1);</span>
<span class="fc" id="L935">                    o.onError(ex);</span>
<span class="fc" id="L936">                }</span>
            };

<span class="fc" id="L939">            TestHelper.race(r1, r2);</span>
        }
<span class="fc" id="L941">    }</span>

    @Test
    public void boundarySupplierDoubleOnSubscribe() {
<span class="fc" id="L945">        TestHelper.checkDoubleOnSubscribeObservable(new Function&lt;Observable&lt;Object&gt;, Observable&lt;Observable&lt;Object&gt;&gt;&gt;() {</span>
            @Override
            public Observable&lt;Observable&lt;Object&gt;&gt; apply(Observable&lt;Object&gt; f)
                    throws Exception {
<span class="fc" id="L949">                return f.window(Functions.justCallable(Observable.never())).takeLast(1);</span>
            }
        });
<span class="fc" id="L952">    }</span>

    @Test
    public void selectorUpstreamDisposedWhenOutputsDisposed() {
<span class="fc" id="L956">        PublishSubject&lt;Integer&gt; source = PublishSubject.create();</span>
<span class="fc" id="L957">        PublishSubject&lt;Integer&gt; boundary = PublishSubject.create();</span>

<span class="fc" id="L959">        TestObserver&lt;Integer&gt; to = source.window(Functions.justCallable(boundary))</span>
<span class="fc" id="L960">        .take(1)</span>
<span class="fc" id="L961">        .flatMap(new Function&lt;Observable&lt;Integer&gt;, ObservableSource&lt;Integer&gt;&gt;() {</span>
            @Override
            public ObservableSource&lt;Integer&gt; apply(
                    Observable&lt;Integer&gt; w) throws Exception {
<span class="fc" id="L965">                return w.take(1);</span>
            }
        })
<span class="fc" id="L968">        .test();</span>

<span class="fc" id="L970">        source.onNext(1);</span>

<span class="fc" id="L972">        assertFalse(&quot;source not disposed&quot;, source.hasObservers());</span>
<span class="fc" id="L973">        assertFalse(&quot;boundary not disposed&quot;, boundary.hasObservers());</span>

<span class="fc" id="L975">        to.assertResult(1);</span>
<span class="fc" id="L976">    }</span>

    @Test
    public void supplierMainAndBoundaryBothError() {
<span class="fc" id="L980">        List&lt;Throwable&gt; errors = TestHelper.trackPluginErrors();</span>
        try {
<span class="fc" id="L982">            final AtomicReference&lt;Observer&lt;? super Object&gt;&gt; ref = new AtomicReference&lt;Observer&lt;? super Object&gt;&gt;();</span>

<span class="fc" id="L984">            TestObserver&lt;Observable&lt;Object&gt;&gt; to = Observable.error(new TestException(&quot;main&quot;))</span>
<span class="fc" id="L985">            .window(Functions.justCallable(new Observable&lt;Object&gt;() {</span>
                @Override
                protected void subscribeActual(Observer&lt;? super Object&gt; observer) {
<span class="fc" id="L988">                    observer.onSubscribe(Disposables.empty());</span>
<span class="fc" id="L989">                    ref.set(observer);</span>
<span class="fc" id="L990">                }</span>
            }))
<span class="fc" id="L992">            .test();</span>

<span class="fc" id="L994">            to</span>
<span class="fc" id="L995">            .assertValueCount(1)</span>
<span class="fc" id="L996">            .assertError(TestException.class)</span>
<span class="fc" id="L997">            .assertErrorMessage(&quot;main&quot;)</span>
<span class="fc" id="L998">            .assertNotComplete();</span>

<span class="fc" id="L1000">            ref.get().onError(new TestException(&quot;inner&quot;));</span>

<span class="fc" id="L1002">            TestHelper.assertUndeliverable(errors, 0, TestException.class, &quot;inner&quot;);</span>
        } finally {
<span class="fc" id="L1004">            RxJavaPlugins.reset();</span>
        }
<span class="fc" id="L1006">    }</span>

    @Test
    public void supplierMainCompleteBoundaryErrorRace() {
<span class="fc" id="L1010">        final TestException ex = new TestException();</span>

<span class="fc bfc" id="L1012" title="All 2 branches covered.">        for (int i = 0; i &lt; TestHelper.RACE_LONG_LOOPS; i++) {</span>
<span class="fc" id="L1013">            List&lt;Throwable&gt; errors = TestHelper.trackPluginErrors();</span>
            try {
<span class="fc" id="L1015">                final AtomicReference&lt;Observer&lt;? super Object&gt;&gt; refMain = new AtomicReference&lt;Observer&lt;? super Object&gt;&gt;();</span>
<span class="fc" id="L1016">                final AtomicReference&lt;Observer&lt;? super Object&gt;&gt; ref = new AtomicReference&lt;Observer&lt;? super Object&gt;&gt;();</span>

<span class="fc" id="L1018">                TestObserver&lt;Observable&lt;Object&gt;&gt; to = new Observable&lt;Object&gt;() {</span>
                    @Override
                    protected void subscribeActual(Observer&lt;? super Object&gt; observer) {
<span class="fc" id="L1021">                        observer.onSubscribe(Disposables.empty());</span>
<span class="fc" id="L1022">                        refMain.set(observer);</span>
<span class="fc" id="L1023">                    }</span>
                }
<span class="fc" id="L1025">                .window(Functions.justCallable(new Observable&lt;Object&gt;() {</span>
                    @Override
                    protected void subscribeActual(Observer&lt;? super Object&gt; observer) {
<span class="fc" id="L1028">                        observer.onSubscribe(Disposables.empty());</span>
<span class="fc" id="L1029">                        ref.set(observer);</span>
<span class="fc" id="L1030">                    }</span>
                }))
<span class="fc" id="L1032">                .test();</span>

<span class="fc" id="L1034">                Runnable r1 = new Runnable() {</span>
                    @Override
                    public void run() {
<span class="fc" id="L1037">                        refMain.get().onComplete();</span>
<span class="fc" id="L1038">                    }</span>
                };
<span class="fc" id="L1040">                Runnable r2 = new Runnable() {</span>
                    @Override
                    public void run() {
<span class="fc" id="L1043">                        ref.get().onError(ex);</span>
<span class="fc" id="L1044">                    }</span>
                };

<span class="fc" id="L1047">                TestHelper.race(r1, r2);</span>

<span class="fc" id="L1049">                to</span>
<span class="fc" id="L1050">                .assertValueCount(1)</span>
<span class="fc" id="L1051">                .assertTerminated();</span>

<span class="fc bfc" id="L1053" title="All 2 branches covered.">                if (!errors.isEmpty()) {</span>
<span class="fc" id="L1054">                    TestHelper.assertUndeliverable(errors, 0, TestException.class);</span>
                }
            } finally {
<span class="fc" id="L1057">                RxJavaPlugins.reset();</span>
            }
        }
<span class="fc" id="L1060">    }</span>

    @Test
    public void supplierMainNextBoundaryNextRace() {
<span class="fc bfc" id="L1064" title="All 2 branches covered.">        for (int i = 0; i &lt; TestHelper.RACE_LONG_LOOPS; i++) {</span>
<span class="fc" id="L1065">            final AtomicReference&lt;Observer&lt;? super Object&gt;&gt; refMain = new AtomicReference&lt;Observer&lt;? super Object&gt;&gt;();</span>
<span class="fc" id="L1066">            final AtomicReference&lt;Observer&lt;? super Object&gt;&gt; ref = new AtomicReference&lt;Observer&lt;? super Object&gt;&gt;();</span>

<span class="fc" id="L1068">            TestObserver&lt;Observable&lt;Object&gt;&gt; to = new Observable&lt;Object&gt;() {</span>
                @Override
                protected void subscribeActual(Observer&lt;? super Object&gt; observer) {
<span class="fc" id="L1071">                    observer.onSubscribe(Disposables.empty());</span>
<span class="fc" id="L1072">                    refMain.set(observer);</span>
<span class="fc" id="L1073">                }</span>
            }
<span class="fc" id="L1075">            .window(Functions.justCallable(new Observable&lt;Object&gt;() {</span>
                @Override
                protected void subscribeActual(Observer&lt;? super Object&gt; observer) {
<span class="fc" id="L1078">                    observer.onSubscribe(Disposables.empty());</span>
<span class="fc" id="L1079">                    ref.set(observer);</span>
<span class="fc" id="L1080">                }</span>
            }))
<span class="fc" id="L1082">            .test();</span>

<span class="fc" id="L1084">            Runnable r1 = new Runnable() {</span>
                @Override
                public void run() {
<span class="fc" id="L1087">                    refMain.get().onNext(1);</span>
<span class="fc" id="L1088">                }</span>
            };
<span class="fc" id="L1090">            Runnable r2 = new Runnable() {</span>
                @Override
                public void run() {
<span class="fc" id="L1093">                    ref.get().onNext(1);</span>
<span class="fc" id="L1094">                }</span>
            };

<span class="fc" id="L1097">            TestHelper.race(r1, r2);</span>

<span class="fc" id="L1099">            to</span>
<span class="fc" id="L1100">            .assertValueCount(2)</span>
<span class="fc" id="L1101">            .assertNotComplete()</span>
<span class="fc" id="L1102">            .assertNoErrors();</span>
        }
<span class="fc" id="L1104">    }</span>

    @Test
    public void supplierTakeOneAnotherBoundary() {
<span class="fc" id="L1108">        final AtomicReference&lt;Observer&lt;? super Object&gt;&gt; refMain = new AtomicReference&lt;Observer&lt;? super Object&gt;&gt;();</span>
<span class="fc" id="L1109">        final AtomicReference&lt;Observer&lt;? super Object&gt;&gt; ref = new AtomicReference&lt;Observer&lt;? super Object&gt;&gt;();</span>

<span class="fc" id="L1111">        TestObserver&lt;Observable&lt;Object&gt;&gt; to = new Observable&lt;Object&gt;() {</span>
            @Override
            protected void subscribeActual(Observer&lt;? super Object&gt; observer) {
<span class="fc" id="L1114">                observer.onSubscribe(Disposables.empty());</span>
<span class="fc" id="L1115">                refMain.set(observer);</span>
<span class="fc" id="L1116">            }</span>
        }
<span class="fc" id="L1118">        .window(Functions.justCallable(new Observable&lt;Object&gt;() {</span>
            @Override
            protected void subscribeActual(Observer&lt;? super Object&gt; observer) {
<span class="fc" id="L1121">                observer.onSubscribe(Disposables.empty());</span>
<span class="fc" id="L1122">                ref.set(observer);</span>
<span class="fc" id="L1123">            }</span>
        }))
<span class="fc" id="L1125">        .test();</span>

<span class="fc" id="L1127">        to.assertValueCount(1)</span>
<span class="fc" id="L1128">        .assertNotTerminated()</span>
<span class="fc" id="L1129">        .cancel();</span>

<span class="fc" id="L1131">        ref.get().onNext(1);</span>

<span class="fc" id="L1133">        to.assertValueCount(1)</span>
<span class="fc" id="L1134">        .assertNotTerminated();</span>
<span class="fc" id="L1135">    }</span>

    @Test
    public void supplierDisposeMainBoundaryCompleteRace() {
<span class="fc bfc" id="L1139" title="All 2 branches covered.">        for (int i = 0; i &lt; TestHelper.RACE_LONG_LOOPS; i++) {</span>
<span class="fc" id="L1140">            final AtomicReference&lt;Observer&lt;? super Object&gt;&gt; refMain = new AtomicReference&lt;Observer&lt;? super Object&gt;&gt;();</span>
<span class="fc" id="L1141">            final AtomicReference&lt;Observer&lt;? super Object&gt;&gt; ref = new AtomicReference&lt;Observer&lt;? super Object&gt;&gt;();</span>

<span class="fc" id="L1143">            final TestObserver&lt;Observable&lt;Object&gt;&gt; to = new Observable&lt;Object&gt;() {</span>
                 @Override
                 protected void subscribeActual(Observer&lt;? super Object&gt; observer) {
<span class="fc" id="L1146">                     observer.onSubscribe(Disposables.empty());</span>
<span class="fc" id="L1147">                     refMain.set(observer);</span>
<span class="fc" id="L1148">                 }</span>
             }
<span class="fc" id="L1150">             .window(Functions.justCallable(new Observable&lt;Object&gt;() {</span>
                 @Override
                 protected void subscribeActual(Observer&lt;? super Object&gt; observer) {
<span class="fc" id="L1153">                     final AtomicInteger counter = new AtomicInteger();</span>
<span class="fc" id="L1154">                     observer.onSubscribe(new Disposable() {</span>

                         @Override
                         public void dispose() {
                             // about a microsecond
<span class="fc bfc" id="L1159" title="All 2 branches covered.">                             for (int i = 0; i &lt; 100; i++) {</span>
<span class="fc" id="L1160">                                 counter.incrementAndGet();</span>
                             }
<span class="fc" id="L1162">                         }</span>

                         @Override
                         public boolean isDisposed() {
<span class="nc" id="L1166">                             return false;</span>
                         }
                      });
<span class="fc" id="L1169">                     ref.set(observer);</span>
<span class="fc" id="L1170">                 }</span>
             }))
<span class="fc" id="L1172">             .test();</span>

<span class="fc" id="L1174">             Runnable r1 = new Runnable() {</span>
                 @Override
                 public void run() {
<span class="fc" id="L1177">                     to.cancel();</span>
<span class="fc" id="L1178">                 }</span>
             };
<span class="fc" id="L1180">             Runnable r2 = new Runnable() {</span>
                 @Override
                 public void run() {
<span class="fc" id="L1183">                     Observer&lt;Object&gt; o = ref.get();</span>
<span class="fc" id="L1184">                     o.onNext(1);</span>
<span class="fc" id="L1185">                     o.onComplete();</span>
<span class="fc" id="L1186">                 }</span>
             };

<span class="fc" id="L1189">             TestHelper.race(r1, r2);</span>
        }
<span class="fc" id="L1191">    }</span>

    @Test
    public void supplierDisposeMainBoundaryErrorRace() {
<span class="fc" id="L1195">        final TestException ex = new TestException();</span>

<span class="fc bfc" id="L1197" title="All 2 branches covered.">        for (int i = 0; i &lt; TestHelper.RACE_LONG_LOOPS; i++) {</span>
<span class="fc" id="L1198">            List&lt;Throwable&gt; errors = TestHelper.trackPluginErrors();</span>
            try {
<span class="fc" id="L1200">                final AtomicReference&lt;Observer&lt;? super Object&gt;&gt; refMain = new AtomicReference&lt;Observer&lt;? super Object&gt;&gt;();</span>
<span class="fc" id="L1201">                final AtomicReference&lt;Observer&lt;? super Object&gt;&gt; ref = new AtomicReference&lt;Observer&lt;? super Object&gt;&gt;();</span>

<span class="fc" id="L1203">                final TestObserver&lt;Observable&lt;Object&gt;&gt; to = new Observable&lt;Object&gt;() {</span>
                    @Override
                    protected void subscribeActual(Observer&lt;? super Object&gt; observer) {
<span class="fc" id="L1206">                        observer.onSubscribe(Disposables.empty());</span>
<span class="fc" id="L1207">                        refMain.set(observer);</span>
<span class="fc" id="L1208">                    }</span>
                }
<span class="fc" id="L1210">                .window(new Callable&lt;ObservableSource&lt;Object&gt;&gt;() {</span>
                    int count;
                    @Override
                    public ObservableSource&lt;Object&gt; call() throws Exception {
<span class="fc bfc" id="L1214" title="All 2 branches covered.">                        if (++count &gt; 1) {</span>
<span class="fc" id="L1215">                            return Observable.never();</span>
                        }
<span class="fc" id="L1217">                        return (new Observable&lt;Object&gt;() {</span>
                            @Override
                            protected void subscribeActual(Observer&lt;? super Object&gt; observer) {
<span class="fc" id="L1220">                                final AtomicInteger counter = new AtomicInteger();</span>
<span class="fc" id="L1221">                                observer.onSubscribe(new Disposable() {</span>

                                    @Override
                                    public void dispose() {
                                        // about a microsecond
<span class="fc bfc" id="L1226" title="All 2 branches covered.">                                        for (int i = 0; i &lt; 100; i++) {</span>
<span class="fc" id="L1227">                                            counter.incrementAndGet();</span>
                                        }
<span class="fc" id="L1229">                                    }</span>

                                    @Override
                                    public boolean isDisposed() {
<span class="nc" id="L1233">                                        return false;</span>
                                    }
                                });
<span class="fc" id="L1236">                                ref.set(observer);</span>
<span class="fc" id="L1237">                            }</span>
                        });
                    }
                })
<span class="fc" id="L1241">                .test();</span>

<span class="fc" id="L1243">                Runnable r1 = new Runnable() {</span>
                    @Override
                    public void run() {
<span class="fc" id="L1246">                        to.cancel();</span>
<span class="fc" id="L1247">                    }</span>
                };
<span class="fc" id="L1249">                Runnable r2 = new Runnable() {</span>
                    @Override
                    public void run() {
<span class="fc" id="L1252">                        Observer&lt;Object&gt; o = ref.get();</span>
<span class="fc" id="L1253">                        o.onNext(1);</span>
<span class="fc" id="L1254">                        o.onError(ex);</span>
<span class="fc" id="L1255">                    }</span>
                };

<span class="fc" id="L1258">                TestHelper.race(r1, r2);</span>

<span class="pc bpc" id="L1260" title="1 of 2 branches missed.">                if (!errors.isEmpty()) {</span>
<span class="fc" id="L1261">                    TestHelper.assertUndeliverable(errors, 0, TestException.class);</span>
                }
            } finally {
<span class="fc" id="L1264">                RxJavaPlugins.reset();</span>
            }
        }
<span class="fc" id="L1267">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>