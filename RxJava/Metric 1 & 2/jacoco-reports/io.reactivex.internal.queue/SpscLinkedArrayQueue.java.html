<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SpscLinkedArrayQueue.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">RxJava_2_x$Unnamed.exec</a> &gt; <a href="index.source.html" class="el_package">io.reactivex.internal.queue</a> &gt; <span class="el_source">SpscLinkedArrayQueue.java</span></div><h1>SpscLinkedArrayQueue.java</h1><pre class="source lang-java linenums">/**
 * Copyright (c) 2016-present, RxJava Contributors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is
 * distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
 * the License for the specific language governing permissions and limitations under the License.
 */

/*
 * The code was inspired by the similarly named JCTools class:
 * https://github.com/JCTools/JCTools/blob/master/jctools-core/src/main/java/org/jctools/queues/atomic
 */

package io.reactivex.internal.queue;

import java.util.concurrent.atomic.*;

import io.reactivex.annotations.Nullable;
import io.reactivex.internal.fuseable.SimplePlainQueue;
import io.reactivex.internal.util.Pow2;

/**
 * A single-producer single-consumer array-backed queue which can allocate new arrays in case the consumer is slower
 * than the producer.
 * @param &lt;T&gt; the contained value type
 */
public final class SpscLinkedArrayQueue&lt;T&gt; implements SimplePlainQueue&lt;T&gt; {
<span class="fc" id="L33">    static final int MAX_LOOK_AHEAD_STEP = Integer.getInteger(&quot;jctools.spsc.max.lookahead.step&quot;, 4096);</span>
<span class="fc" id="L34">    final AtomicLong producerIndex = new AtomicLong();</span>

    int producerLookAheadStep;
    long producerLookAhead;

    final int producerMask;

    AtomicReferenceArray&lt;Object&gt; producerBuffer;
    final int consumerMask;
    AtomicReferenceArray&lt;Object&gt; consumerBuffer;
<span class="fc" id="L44">    final AtomicLong consumerIndex = new AtomicLong();</span>

<span class="fc" id="L46">    private static final Object HAS_NEXT = new Object();</span>

<span class="fc" id="L48">    public SpscLinkedArrayQueue(final int bufferSize) {</span>
<span class="fc" id="L49">        int p2capacity = Pow2.roundToPowerOfTwo(Math.max(8, bufferSize));</span>
<span class="fc" id="L50">        int mask = p2capacity - 1;</span>
<span class="fc" id="L51">        AtomicReferenceArray&lt;Object&gt; buffer = new AtomicReferenceArray&lt;Object&gt;(p2capacity + 1);</span>
<span class="fc" id="L52">        producerBuffer = buffer;</span>
<span class="fc" id="L53">        producerMask = mask;</span>
<span class="fc" id="L54">        adjustLookAheadStep(p2capacity);</span>
<span class="fc" id="L55">        consumerBuffer = buffer;</span>
<span class="fc" id="L56">        consumerMask = mask;</span>
<span class="fc" id="L57">        producerLookAhead = mask - 1; // we know it's all empty to start with</span>
<span class="fc" id="L58">        soProducerIndex(0L);</span>
<span class="fc" id="L59">    }</span>

    /**
     * {@inheritDoc}
     * &lt;p&gt;
     * This implementation is correct for single producer thread use only.
     */
    @Override
    public boolean offer(final T e) {
<span class="fc bfc" id="L68" title="All 2 branches covered.">        if (null == e) {</span>
<span class="fc" id="L69">            throw new NullPointerException(&quot;Null is not a valid element&quot;);</span>
        }
        // local load of field to avoid repeated loads after volatile reads
<span class="fc" id="L72">        final AtomicReferenceArray&lt;Object&gt; buffer = producerBuffer;</span>
<span class="fc" id="L73">        final long index = lpProducerIndex();</span>
<span class="fc" id="L74">        final int mask = producerMask;</span>
<span class="fc" id="L75">        final int offset = calcWrappedOffset(index, mask);</span>
<span class="fc bfc" id="L76" title="All 2 branches covered.">        if (index &lt; producerLookAhead) {</span>
<span class="fc" id="L77">            return writeToQueue(buffer, e, index, offset);</span>
        } else {
<span class="fc" id="L79">            final int lookAheadStep = producerLookAheadStep;</span>
            // go around the buffer or resize if full (unless we hit max capacity)
<span class="fc" id="L81">            int lookAheadElementOffset = calcWrappedOffset(index + lookAheadStep, mask);</span>
<span class="fc bfc" id="L82" title="All 2 branches covered.">            if (null == lvElement(buffer, lookAheadElementOffset)) { // LoadLoad</span>
<span class="fc" id="L83">                producerLookAhead = index + lookAheadStep - 1; // joy, there's plenty of room</span>
<span class="fc" id="L84">                return writeToQueue(buffer, e, index, offset);</span>
<span class="fc bfc" id="L85" title="All 2 branches covered.">            } else if (null == lvElement(buffer, calcWrappedOffset(index + 1, mask))) { // buffer is not full</span>
<span class="fc" id="L86">                return writeToQueue(buffer, e, index, offset);</span>
            } else {
<span class="fc" id="L88">                resize(buffer, index, offset, e, mask); // add a buffer and link old to new</span>
<span class="fc" id="L89">                return true;</span>
            }
        }
    }

    private boolean writeToQueue(final AtomicReferenceArray&lt;Object&gt; buffer, final T e, final long index, final int offset) {
<span class="fc" id="L95">        soElement(buffer, offset, e); // StoreStore</span>
<span class="fc" id="L96">        soProducerIndex(index + 1); // this ensures atomic write of long on 32bit platforms</span>
<span class="fc" id="L97">        return true;</span>
    }

    private void resize(final AtomicReferenceArray&lt;Object&gt; oldBuffer, final long currIndex, final int offset, final T e,
            final long mask) {
<span class="fc" id="L102">        final int capacity = oldBuffer.length();</span>
<span class="fc" id="L103">        final AtomicReferenceArray&lt;Object&gt; newBuffer = new AtomicReferenceArray&lt;Object&gt;(capacity);</span>
<span class="fc" id="L104">        producerBuffer = newBuffer;</span>
<span class="fc" id="L105">        producerLookAhead = currIndex + mask - 1;</span>
<span class="fc" id="L106">        soElement(newBuffer, offset, e); // StoreStore</span>
<span class="fc" id="L107">        soNext(oldBuffer, newBuffer);</span>
<span class="fc" id="L108">        soElement(oldBuffer, offset, HAS_NEXT); // new buffer is visible after element is</span>
                                                                 // inserted
<span class="fc" id="L110">        soProducerIndex(currIndex + 1); // this ensures correctness on 32bit platforms</span>
<span class="fc" id="L111">    }</span>

    private void soNext(AtomicReferenceArray&lt;Object&gt; curr, AtomicReferenceArray&lt;Object&gt; next) {
<span class="fc" id="L114">        soElement(curr, calcDirectOffset(curr.length() - 1), next);</span>
<span class="fc" id="L115">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    private AtomicReferenceArray&lt;Object&gt; lvNextBufferAndUnlink(AtomicReferenceArray&lt;Object&gt; curr, int nextIndex) {
<span class="fc" id="L119">        int nextOffset = calcDirectOffset(nextIndex);</span>
<span class="fc" id="L120">        AtomicReferenceArray&lt;Object&gt; nextBuffer = (AtomicReferenceArray&lt;Object&gt;)lvElement(curr, nextOffset);</span>
<span class="fc" id="L121">        soElement(curr, nextOffset, null); // Avoid GC nepotism</span>
<span class="fc" id="L122">        return nextBuffer;</span>
    }
    /**
     * {@inheritDoc}
     * &lt;p&gt;
     * This implementation is correct for single consumer thread use only.
     */
    @Nullable
    @SuppressWarnings(&quot;unchecked&quot;)
    @Override
    public T poll() {
        // local load of field to avoid repeated loads after volatile reads
<span class="fc" id="L134">        final AtomicReferenceArray&lt;Object&gt; buffer = consumerBuffer;</span>
<span class="fc" id="L135">        final long index = lpConsumerIndex();</span>
<span class="fc" id="L136">        final int mask = consumerMask;</span>
<span class="fc" id="L137">        final int offset = calcWrappedOffset(index, mask);</span>
<span class="fc" id="L138">        final Object e = lvElement(buffer, offset); // LoadLoad</span>
<span class="fc bfc" id="L139" title="All 2 branches covered.">        boolean isNextBuffer = e == HAS_NEXT;</span>
<span class="fc bfc" id="L140" title="All 4 branches covered.">        if (null != e &amp;&amp; !isNextBuffer) {</span>
<span class="fc" id="L141">            soElement(buffer, offset, null); // StoreStore</span>
<span class="fc" id="L142">            soConsumerIndex(index + 1); // this ensures correctness on 32bit platforms</span>
<span class="fc" id="L143">            return (T) e;</span>
<span class="fc bfc" id="L144" title="All 2 branches covered.">        } else if (isNextBuffer) {</span>
<span class="fc" id="L145">            return newBufferPoll(lvNextBufferAndUnlink(buffer, mask + 1), index, mask);</span>
        }

<span class="fc" id="L148">        return null;</span>
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    private T newBufferPoll(AtomicReferenceArray&lt;Object&gt; nextBuffer, final long index, final int mask) {
<span class="fc" id="L153">        consumerBuffer = nextBuffer;</span>
<span class="fc" id="L154">        final int offsetInNew = calcWrappedOffset(index, mask);</span>
<span class="fc" id="L155">        final T n = (T) lvElement(nextBuffer, offsetInNew); // LoadLoad</span>
<span class="pc bpc" id="L156" title="1 of 2 branches missed.">        if (null != n) {</span>
<span class="fc" id="L157">            soElement(nextBuffer, offsetInNew, null); // StoreStore</span>
<span class="fc" id="L158">            soConsumerIndex(index + 1); // this ensures correctness on 32bit platforms</span>
        }
<span class="fc" id="L160">        return n;</span>
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    public T peek() {
<span class="fc" id="L165">        final AtomicReferenceArray&lt;Object&gt; buffer = consumerBuffer;</span>
<span class="fc" id="L166">        final long index = lpConsumerIndex();</span>
<span class="fc" id="L167">        final int mask = consumerMask;</span>
<span class="fc" id="L168">        final int offset = calcWrappedOffset(index, mask);</span>
<span class="fc" id="L169">        final Object e = lvElement(buffer, offset); // LoadLoad</span>
<span class="fc bfc" id="L170" title="All 2 branches covered.">        if (e == HAS_NEXT) {</span>
<span class="fc" id="L171">            return newBufferPeek(lvNextBufferAndUnlink(buffer, mask + 1), index, mask);</span>
        }

<span class="fc" id="L174">        return (T) e;</span>
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    private T newBufferPeek(AtomicReferenceArray&lt;Object&gt; nextBuffer, final long index, final int mask) {
<span class="fc" id="L179">        consumerBuffer = nextBuffer;</span>
<span class="fc" id="L180">        final int offsetInNew = calcWrappedOffset(index, mask);</span>
<span class="fc" id="L181">        return (T) lvElement(nextBuffer, offsetInNew); // LoadLoad</span>
    }

    @Override
    public void clear() {
<span class="fc bfc" id="L186" title="All 4 branches covered.">        while (poll() != null || !isEmpty()) { } // NOPMD</span>
<span class="fc" id="L187">    }</span>

    public int size() {
        /*
         * It is possible for a thread to be interrupted or reschedule between the read of the producer and
         * consumer indices, therefore protection is required to ensure size is within valid range. In the
         * event of concurrent polls/offers to this method the size is OVER estimated as we read consumer
         * index BEFORE the producer index.
         */
<span class="fc" id="L196">        long after = lvConsumerIndex();</span>
        while (true) {
<span class="fc" id="L198">            final long before = after;</span>
<span class="fc" id="L199">            final long currentProducerIndex = lvProducerIndex();</span>
<span class="fc" id="L200">            after = lvConsumerIndex();</span>
<span class="pc bpc" id="L201" title="1 of 2 branches missed.">            if (before == after) {</span>
<span class="fc" id="L202">                return (int) (currentProducerIndex - after);</span>
            }
<span class="nc" id="L204">        }</span>
    }

    @Override
    public boolean isEmpty() {
<span class="fc bfc" id="L209" title="All 2 branches covered.">        return lvProducerIndex() == lvConsumerIndex();</span>
    }

    private void adjustLookAheadStep(int capacity) {
<span class="fc" id="L213">        producerLookAheadStep = Math.min(capacity / 4, MAX_LOOK_AHEAD_STEP);</span>
<span class="fc" id="L214">    }</span>

    private long lvProducerIndex() {
<span class="fc" id="L217">        return producerIndex.get();</span>
    }

    private long lvConsumerIndex() {
<span class="fc" id="L221">        return consumerIndex.get();</span>
    }

    private long lpProducerIndex() {
<span class="fc" id="L225">        return producerIndex.get();</span>
    }

    private long lpConsumerIndex() {
<span class="fc" id="L229">        return consumerIndex.get();</span>
    }

    private void soProducerIndex(long v) {
<span class="fc" id="L233">        producerIndex.lazySet(v);</span>
<span class="fc" id="L234">    }</span>

    private void soConsumerIndex(long v) {
<span class="fc" id="L237">        consumerIndex.lazySet(v);</span>
<span class="fc" id="L238">    }</span>

    private static int calcWrappedOffset(long index, int mask) {
<span class="fc" id="L241">        return calcDirectOffset((int)index &amp; mask);</span>
    }
    private static int calcDirectOffset(int index) {
<span class="fc" id="L244">        return index;</span>
    }
    private static void soElement(AtomicReferenceArray&lt;Object&gt; buffer, int offset, Object e) {
<span class="fc" id="L247">        buffer.lazySet(offset, e);</span>
<span class="fc" id="L248">    }</span>

    private static &lt;E&gt; Object lvElement(AtomicReferenceArray&lt;Object&gt; buffer, int offset) {
<span class="fc" id="L251">        return buffer.get(offset);</span>
    }

    /**
     * Offer two elements at the same time.
     * &lt;p&gt;Don't use the regular offer() with this at all!
     * @param first the first value, not null
     * @param second the second value, not null
     * @return true if the queue accepted the two new values
     */
    @Override
    public boolean offer(T first, T second) {
<span class="fc" id="L263">        final AtomicReferenceArray&lt;Object&gt; buffer = producerBuffer;</span>
<span class="fc" id="L264">        final long p = lvProducerIndex();</span>
<span class="fc" id="L265">        final int m = producerMask;</span>

<span class="fc" id="L267">        int pi = calcWrappedOffset(p + 2, m);</span>

<span class="fc bfc" id="L269" title="All 2 branches covered.">        if (null == lvElement(buffer, pi)) {</span>
<span class="fc" id="L270">            pi = calcWrappedOffset(p, m);</span>
<span class="fc" id="L271">            soElement(buffer, pi + 1, second);</span>
<span class="fc" id="L272">            soElement(buffer, pi, first);</span>
<span class="fc" id="L273">            soProducerIndex(p + 2);</span>
        } else {
<span class="fc" id="L275">            final int capacity = buffer.length();</span>
<span class="fc" id="L276">            final AtomicReferenceArray&lt;Object&gt; newBuffer = new AtomicReferenceArray&lt;Object&gt;(capacity);</span>
<span class="fc" id="L277">            producerBuffer = newBuffer;</span>

<span class="fc" id="L279">            pi = calcWrappedOffset(p, m);</span>
<span class="fc" id="L280">            soElement(newBuffer, pi + 1, second); // StoreStore</span>
<span class="fc" id="L281">            soElement(newBuffer, pi, first);</span>
<span class="fc" id="L282">            soNext(buffer, newBuffer);</span>

<span class="fc" id="L284">            soElement(buffer, pi, HAS_NEXT); // new buffer is visible after element is</span>

<span class="fc" id="L286">            soProducerIndex(p + 2); // this ensures correctness on 32bit platforms</span>
        }

<span class="fc" id="L289">        return true;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>