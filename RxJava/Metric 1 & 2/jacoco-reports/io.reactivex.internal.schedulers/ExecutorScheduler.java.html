<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ExecutorScheduler.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">RxJava_2_x$Unnamed.exec</a> &gt; <a href="index.source.html" class="el_package">io.reactivex.internal.schedulers</a> &gt; <span class="el_source">ExecutorScheduler.java</span></div><h1>ExecutorScheduler.java</h1><pre class="source lang-java linenums">/**
 * Copyright (c) 2016-present, RxJava Contributors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is
 * distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
 * the License for the specific language governing permissions and limitations under the License.
 */

package io.reactivex.internal.schedulers;

import java.util.concurrent.*;
import java.util.concurrent.atomic.*;

import io.reactivex.Scheduler;
import io.reactivex.annotations.NonNull;
import io.reactivex.disposables.*;
import io.reactivex.internal.disposables.*;
import io.reactivex.internal.functions.Functions;
import io.reactivex.internal.queue.MpscLinkedQueue;
import io.reactivex.internal.schedulers.ExecutorScheduler.ExecutorWorker.*;
import io.reactivex.plugins.RxJavaPlugins;
import io.reactivex.schedulers.*;

/**
 * Wraps an Executor and provides the Scheduler API over it.
 */
public final class ExecutorScheduler extends Scheduler {

    final boolean interruptibleWorker;

    @NonNull
    final Executor executor;

<span class="fc" id="L39">    static final Scheduler HELPER = Schedulers.single();</span>

<span class="fc" id="L41">    public ExecutorScheduler(@NonNull Executor executor, boolean interruptibleWorker) {</span>
<span class="fc" id="L42">        this.executor = executor;</span>
<span class="fc" id="L43">        this.interruptibleWorker = interruptibleWorker;</span>
<span class="fc" id="L44">    }</span>

    @NonNull
    @Override
    public Worker createWorker() {
<span class="fc" id="L49">        return new ExecutorWorker(executor, interruptibleWorker);</span>
    }

    @NonNull
    @Override
    public Disposable scheduleDirect(@NonNull Runnable run) {
<span class="fc" id="L55">        Runnable decoratedRun = RxJavaPlugins.onSchedule(run);</span>
        try {
<span class="fc bfc" id="L57" title="All 2 branches covered.">            if (executor instanceof ExecutorService) {</span>
<span class="fc" id="L58">                ScheduledDirectTask task = new ScheduledDirectTask(decoratedRun);</span>
<span class="fc" id="L59">                Future&lt;?&gt; f = ((ExecutorService)executor).submit(task);</span>
<span class="fc" id="L60">                task.setFuture(f);</span>
<span class="fc" id="L61">                return task;</span>
            }

<span class="fc bfc" id="L64" title="All 2 branches covered.">            if (interruptibleWorker) {</span>
<span class="fc" id="L65">                InterruptibleRunnable interruptibleTask = new InterruptibleRunnable(decoratedRun, null);</span>
<span class="fc" id="L66">                executor.execute(interruptibleTask);</span>
<span class="fc" id="L67">                return interruptibleTask;</span>
            } else {
<span class="fc" id="L69">                BooleanRunnable br = new BooleanRunnable(decoratedRun);</span>
<span class="fc" id="L70">                executor.execute(br);</span>
<span class="fc" id="L71">                return br;</span>
            }
<span class="fc" id="L73">        } catch (RejectedExecutionException ex) {</span>
<span class="fc" id="L74">            RxJavaPlugins.onError(ex);</span>
<span class="fc" id="L75">            return EmptyDisposable.INSTANCE;</span>
        }
    }

    @NonNull
    @Override
    public Disposable scheduleDirect(@NonNull Runnable run, final long delay, final TimeUnit unit) {
<span class="fc" id="L82">        final Runnable decoratedRun = RxJavaPlugins.onSchedule(run);</span>
<span class="fc bfc" id="L83" title="All 2 branches covered.">        if (executor instanceof ScheduledExecutorService) {</span>
            try {
<span class="fc" id="L85">                ScheduledDirectTask task = new ScheduledDirectTask(decoratedRun);</span>
<span class="fc" id="L86">                Future&lt;?&gt; f = ((ScheduledExecutorService)executor).schedule(task, delay, unit);</span>
<span class="fc" id="L87">                task.setFuture(f);</span>
<span class="fc" id="L88">                return task;</span>
<span class="fc" id="L89">            } catch (RejectedExecutionException ex) {</span>
<span class="fc" id="L90">                RxJavaPlugins.onError(ex);</span>
<span class="fc" id="L91">                return EmptyDisposable.INSTANCE;</span>
            }
        }

<span class="fc" id="L95">        final DelayedRunnable dr = new DelayedRunnable(decoratedRun);</span>

<span class="fc" id="L97">        Disposable delayed = HELPER.scheduleDirect(new DelayedDispose(dr), delay, unit);</span>

<span class="fc" id="L99">        dr.timed.replace(delayed);</span>

<span class="fc" id="L101">        return dr;</span>
    }

    @NonNull
    @Override
    public Disposable schedulePeriodicallyDirect(@NonNull Runnable run, long initialDelay, long period, TimeUnit unit) {
<span class="fc bfc" id="L107" title="All 2 branches covered.">        if (executor instanceof ScheduledExecutorService) {</span>
<span class="fc" id="L108">            Runnable decoratedRun = RxJavaPlugins.onSchedule(run);</span>
            try {
<span class="fc" id="L110">                ScheduledDirectPeriodicTask task = new ScheduledDirectPeriodicTask(decoratedRun);</span>
<span class="fc" id="L111">                Future&lt;?&gt; f = ((ScheduledExecutorService)executor).scheduleAtFixedRate(task, initialDelay, period, unit);</span>
<span class="fc" id="L112">                task.setFuture(f);</span>
<span class="fc" id="L113">                return task;</span>
<span class="fc" id="L114">            } catch (RejectedExecutionException ex) {</span>
<span class="fc" id="L115">                RxJavaPlugins.onError(ex);</span>
<span class="fc" id="L116">                return EmptyDisposable.INSTANCE;</span>
            }
        }
<span class="fc" id="L119">        return super.schedulePeriodicallyDirect(run, initialDelay, period, unit);</span>
    }
    /* public: test support. */
    public static final class ExecutorWorker extends Scheduler.Worker implements Runnable {

        final boolean interruptibleWorker;

        final Executor executor;

        final MpscLinkedQueue&lt;Runnable&gt; queue;

        volatile boolean disposed;

<span class="fc" id="L132">        final AtomicInteger wip = new AtomicInteger();</span>

<span class="fc" id="L134">        final CompositeDisposable tasks = new CompositeDisposable();</span>

<span class="fc" id="L136">        public ExecutorWorker(Executor executor, boolean interruptibleWorker) {</span>
<span class="fc" id="L137">            this.executor = executor;</span>
<span class="fc" id="L138">            this.queue = new MpscLinkedQueue&lt;Runnable&gt;();</span>
<span class="fc" id="L139">            this.interruptibleWorker = interruptibleWorker;</span>
<span class="fc" id="L140">        }</span>

        @NonNull
        @Override
        public Disposable schedule(@NonNull Runnable run) {
<span class="fc bfc" id="L145" title="All 2 branches covered.">            if (disposed) {</span>
<span class="fc" id="L146">                return EmptyDisposable.INSTANCE;</span>
            }

<span class="fc" id="L149">            Runnable decoratedRun = RxJavaPlugins.onSchedule(run);</span>

            Runnable task;
            Disposable disposable;

<span class="fc bfc" id="L154" title="All 2 branches covered.">            if (interruptibleWorker) {</span>
<span class="fc" id="L155">                InterruptibleRunnable interruptibleTask = new InterruptibleRunnable(decoratedRun, tasks);</span>
<span class="fc" id="L156">                tasks.add(interruptibleTask);</span>

<span class="fc" id="L158">                task = interruptibleTask;</span>
<span class="fc" id="L159">                disposable = interruptibleTask;</span>
<span class="fc" id="L160">            } else {</span>
<span class="fc" id="L161">                BooleanRunnable runnableTask = new BooleanRunnable(decoratedRun);</span>

<span class="fc" id="L163">                task = runnableTask;</span>
<span class="fc" id="L164">                disposable = runnableTask;</span>
            }

<span class="fc" id="L167">            queue.offer(task);</span>

<span class="fc bfc" id="L169" title="All 2 branches covered.">            if (wip.getAndIncrement() == 0) {</span>
                try {
<span class="fc" id="L171">                    executor.execute(this);</span>
<span class="fc" id="L172">                } catch (RejectedExecutionException ex) {</span>
<span class="fc" id="L173">                    disposed = true;</span>
<span class="fc" id="L174">                    queue.clear();</span>
<span class="fc" id="L175">                    RxJavaPlugins.onError(ex);</span>
<span class="fc" id="L176">                    return EmptyDisposable.INSTANCE;</span>
<span class="fc" id="L177">                }</span>
            }

<span class="fc" id="L180">            return disposable;</span>
        }

        @NonNull
        @Override
        public Disposable schedule(@NonNull Runnable run, long delay, @NonNull TimeUnit unit) {
<span class="fc bfc" id="L186" title="All 2 branches covered.">            if (delay &lt;= 0) {</span>
<span class="fc" id="L187">                return schedule(run);</span>
            }
<span class="fc bfc" id="L189" title="All 2 branches covered.">            if (disposed) {</span>
<span class="fc" id="L190">                return EmptyDisposable.INSTANCE;</span>
            }

<span class="fc" id="L193">            SequentialDisposable first = new SequentialDisposable();</span>

<span class="fc" id="L195">            final SequentialDisposable mar = new SequentialDisposable(first);</span>

<span class="fc" id="L197">            final Runnable decoratedRun = RxJavaPlugins.onSchedule(run);</span>

<span class="fc" id="L199">            ScheduledRunnable sr = new ScheduledRunnable(new SequentialDispose(mar, decoratedRun), tasks);</span>
<span class="fc" id="L200">            tasks.add(sr);</span>

<span class="fc bfc" id="L202" title="All 2 branches covered.">            if (executor instanceof ScheduledExecutorService) {</span>
                try {
<span class="fc" id="L204">                    Future&lt;?&gt; f = ((ScheduledExecutorService)executor).schedule((Callable&lt;Object&gt;)sr, delay, unit);</span>
<span class="fc" id="L205">                    sr.setFuture(f);</span>
<span class="fc" id="L206">                } catch (RejectedExecutionException ex) {</span>
<span class="fc" id="L207">                    disposed = true;</span>
<span class="fc" id="L208">                    RxJavaPlugins.onError(ex);</span>
<span class="fc" id="L209">                    return EmptyDisposable.INSTANCE;</span>
<span class="fc" id="L210">                }</span>
            } else {
<span class="fc" id="L212">                final Disposable d = HELPER.scheduleDirect(sr, delay, unit);</span>
<span class="fc" id="L213">                sr.setFuture(new DisposeOnCancel(d));</span>
            }

<span class="fc" id="L216">            first.replace(sr);</span>

<span class="fc" id="L218">            return mar;</span>
        }

        @Override
        public void dispose() {
<span class="fc bfc" id="L223" title="All 2 branches covered.">            if (!disposed) {</span>
<span class="fc" id="L224">                disposed = true;</span>
<span class="fc" id="L225">                tasks.dispose();</span>
<span class="fc bfc" id="L226" title="All 2 branches covered.">                if (wip.getAndIncrement() == 0) {</span>
<span class="fc" id="L227">                    queue.clear();</span>
                }
            }
<span class="fc" id="L230">        }</span>

        @Override
        public boolean isDisposed() {
<span class="fc" id="L234">            return disposed;</span>
        }

        @Override
        public void run() {
<span class="fc" id="L239">            int missed = 1;</span>
<span class="fc" id="L240">            final MpscLinkedQueue&lt;Runnable&gt; q = queue;</span>
            for (;;) {

<span class="fc bfc" id="L243" title="All 2 branches covered.">                if (disposed) {</span>
<span class="fc" id="L244">                    q.clear();</span>
<span class="fc" id="L245">                    return;</span>
                }

                for (;;) {
<span class="fc" id="L249">                    Runnable run = q.poll();</span>
<span class="fc bfc" id="L250" title="All 2 branches covered.">                    if (run == null) {</span>
<span class="fc" id="L251">                        break;</span>
                    }
<span class="fc" id="L253">                    run.run();</span>

<span class="fc bfc" id="L255" title="All 2 branches covered.">                    if (disposed) {</span>
<span class="fc" id="L256">                        q.clear();</span>
<span class="fc" id="L257">                        return;</span>
                    }
<span class="fc" id="L259">                }</span>

<span class="fc bfc" id="L261" title="All 2 branches covered.">                if (disposed) {</span>
<span class="fc" id="L262">                    q.clear();</span>
<span class="fc" id="L263">                    return;</span>
                }

<span class="fc" id="L266">                missed = wip.addAndGet(-missed);</span>
<span class="fc bfc" id="L267" title="All 2 branches covered.">                if (missed == 0) {</span>
<span class="fc" id="L268">                    break;</span>
                }
            }
<span class="fc" id="L271">        }</span>

        static final class BooleanRunnable extends AtomicBoolean implements Runnable, Disposable {

            private static final long serialVersionUID = -2421395018820541164L;

            final Runnable actual;
<span class="fc" id="L278">            BooleanRunnable(Runnable actual) {</span>
<span class="fc" id="L279">                this.actual = actual;</span>
<span class="fc" id="L280">            }</span>

            @Override
            public void run() {
<span class="fc bfc" id="L284" title="All 2 branches covered.">                if (get()) {</span>
<span class="fc" id="L285">                    return;</span>
                }
                try {
<span class="fc" id="L288">                    actual.run();</span>
                } finally {
<span class="fc" id="L290">                    lazySet(true);</span>
                }
<span class="fc" id="L292">            }</span>

            @Override
            public void dispose() {
<span class="fc" id="L296">                lazySet(true);</span>
<span class="fc" id="L297">            }</span>

            @Override
            public boolean isDisposed() {
<span class="fc" id="L301">                return get();</span>
            }
        }

        final class SequentialDispose implements Runnable {
            private final SequentialDisposable mar;
            private final Runnable decoratedRun;

<span class="fc" id="L309">            SequentialDispose(SequentialDisposable mar, Runnable decoratedRun) {</span>
<span class="fc" id="L310">                this.mar = mar;</span>
<span class="fc" id="L311">                this.decoratedRun = decoratedRun;</span>
<span class="fc" id="L312">            }</span>

            @Override
            public void run() {
<span class="fc" id="L316">                mar.replace(schedule(decoratedRun));</span>
<span class="fc" id="L317">            }</span>
        }

        /**
         * Wrapper for a {@link Runnable} with additional logic for handling interruption on
         * a shared thread, similar to how Java Executors do it.
         */
        static final class InterruptibleRunnable extends AtomicInteger implements Runnable, Disposable {

            private static final long serialVersionUID = -3603436687413320876L;

            final Runnable run;

            final DisposableContainer tasks;

            volatile Thread thread;

            static final int READY = 0;

            static final int RUNNING = 1;

            static final int FINISHED = 2;

            static final int INTERRUPTING = 3;

            static final int INTERRUPTED = 4;

<span class="fc" id="L344">            InterruptibleRunnable(Runnable run, DisposableContainer tasks) {</span>
<span class="fc" id="L345">                this.run = run;</span>
<span class="fc" id="L346">                this.tasks = tasks;</span>
<span class="fc" id="L347">            }</span>

            @Override
            public void run() {
<span class="fc bfc" id="L351" title="All 2 branches covered.">                if (get() == READY) {</span>
<span class="fc" id="L352">                    thread = Thread.currentThread();</span>
<span class="pc bpc" id="L353" title="1 of 2 branches missed.">                    if (compareAndSet(READY, RUNNING)) {</span>
                        try {
<span class="fc" id="L355">                            run.run();</span>
                        } finally {
<span class="fc" id="L357">                            thread = null;</span>
<span class="fc bfc" id="L358" title="All 2 branches covered.">                            if (compareAndSet(RUNNING, FINISHED)) {</span>
<span class="fc" id="L359">                                cleanup();</span>
                            } else {
<span class="fc bfc" id="L361" title="All 2 branches covered.">                                while (get() == INTERRUPTING) {</span>
<span class="fc" id="L362">                                    Thread.yield();</span>
                                }
<span class="fc" id="L364">                                Thread.interrupted();</span>
                            }
                        }
                    } else {
<span class="nc" id="L368">                        thread = null;</span>
                    }
                }
<span class="fc" id="L371">            }</span>

            @Override
            public void dispose() {
                for (;;) {
<span class="fc" id="L376">                    int state = get();</span>
<span class="fc bfc" id="L377" title="All 2 branches covered.">                    if (state &gt;= FINISHED) {</span>
<span class="fc" id="L378">                        break;</span>
<span class="fc bfc" id="L379" title="All 2 branches covered.">                    } else if (state == READY) {</span>
<span class="pc bpc" id="L380" title="1 of 2 branches missed.">                        if (compareAndSet(READY, INTERRUPTED)) {</span>
<span class="fc" id="L381">                            cleanup();</span>
<span class="fc" id="L382">                            break;</span>
                        }
                    } else {
<span class="fc bfc" id="L385" title="All 2 branches covered.">                        if (compareAndSet(RUNNING, INTERRUPTING)) {</span>
<span class="fc" id="L386">                            Thread t = thread;</span>
<span class="pc bpc" id="L387" title="1 of 2 branches missed.">                            if (t != null) {</span>
<span class="fc" id="L388">                                t.interrupt();</span>
<span class="fc" id="L389">                                thread = null;</span>
                            }
<span class="fc" id="L391">                            set(INTERRUPTED);</span>
<span class="fc" id="L392">                            cleanup();</span>
<span class="fc" id="L393">                            break;</span>
                        }
                    }
<span class="fc" id="L396">                }</span>
<span class="fc" id="L397">            }</span>

            void cleanup() {
<span class="fc bfc" id="L400" title="All 2 branches covered.">                if (tasks != null) {</span>
<span class="fc" id="L401">                    tasks.delete(this);</span>
                }
<span class="fc" id="L403">            }</span>

            @Override
            public boolean isDisposed() {
<span class="fc bfc" id="L407" title="All 2 branches covered.">                return get() &gt;= FINISHED;</span>
            }
        }
    }

    static final class DelayedRunnable extends AtomicReference&lt;Runnable&gt;
            implements Runnable, Disposable, SchedulerRunnableIntrospection {

        private static final long serialVersionUID = -4101336210206799084L;

        final SequentialDisposable timed;

        final SequentialDisposable direct;

        DelayedRunnable(Runnable run) {
<span class="fc" id="L422">            super(run);</span>
<span class="fc" id="L423">            this.timed = new SequentialDisposable();</span>
<span class="fc" id="L424">            this.direct = new SequentialDisposable();</span>
<span class="fc" id="L425">        }</span>

        @Override
        public void run() {
<span class="fc" id="L429">            Runnable r = get();</span>
<span class="fc bfc" id="L430" title="All 2 branches covered.">            if (r != null) {</span>
                try {
<span class="fc" id="L432">                    r.run();</span>
                } finally {
<span class="fc" id="L434">                    lazySet(null);</span>
<span class="fc" id="L435">                    timed.lazySet(DisposableHelper.DISPOSED);</span>
<span class="fc" id="L436">                    direct.lazySet(DisposableHelper.DISPOSED);</span>
                }
            }
<span class="fc" id="L439">        }</span>

        @Override
        public boolean isDisposed() {
<span class="fc bfc" id="L443" title="All 2 branches covered.">            return get() == null;</span>
        }

        @Override
        public void dispose() {
<span class="fc bfc" id="L448" title="All 2 branches covered.">            if (getAndSet(null) != null) {</span>
<span class="fc" id="L449">                timed.dispose();</span>
<span class="fc" id="L450">                direct.dispose();</span>
            }
<span class="fc" id="L452">        }</span>

        @Override
        public Runnable getWrappedRunnable() {
<span class="fc" id="L456">            Runnable r = get();</span>
<span class="fc bfc" id="L457" title="All 2 branches covered.">            return r != null ? r : Functions.EMPTY_RUNNABLE;</span>
        }
    }

    final class DelayedDispose implements Runnable {
        private final DelayedRunnable dr;

<span class="fc" id="L464">        DelayedDispose(DelayedRunnable dr) {</span>
<span class="fc" id="L465">            this.dr = dr;</span>
<span class="fc" id="L466">        }</span>

        @Override
        public void run() {
<span class="fc" id="L470">            dr.direct.replace(scheduleDirect(dr));</span>
<span class="fc" id="L471">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>