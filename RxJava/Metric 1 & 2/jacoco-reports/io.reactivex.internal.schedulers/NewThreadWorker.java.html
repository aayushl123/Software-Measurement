<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>NewThreadWorker.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">RxJava_2_x$Unnamed.exec</a> &gt; <a href="index.source.html" class="el_package">io.reactivex.internal.schedulers</a> &gt; <span class="el_source">NewThreadWorker.java</span></div><h1>NewThreadWorker.java</h1><pre class="source lang-java linenums">/**
 * Copyright (c) 2016-present, RxJava Contributors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is
 * distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
 * the License for the specific language governing permissions and limitations under the License.
 */

package io.reactivex.internal.schedulers;

import java.util.concurrent.*;

import io.reactivex.Scheduler;
import io.reactivex.annotations.NonNull;
import io.reactivex.annotations.Nullable;
import io.reactivex.disposables.*;
import io.reactivex.internal.disposables.*;
import io.reactivex.plugins.RxJavaPlugins;

/**
 * Base class that manages a single-threaded ScheduledExecutorService as a
 * worker but doesn't perform task-tracking operations.
 *
 */
public class NewThreadWorker extends Scheduler.Worker implements Disposable {
    private final ScheduledExecutorService executor;

    volatile boolean disposed;

<span class="fc" id="L35">    public NewThreadWorker(ThreadFactory threadFactory) {</span>
<span class="fc" id="L36">        executor = SchedulerPoolFactory.create(threadFactory);</span>
<span class="fc" id="L37">    }</span>

    @NonNull
    @Override
    public Disposable schedule(@NonNull final Runnable run) {
<span class="fc" id="L42">        return schedule(run, 0, null);</span>
    }

    @NonNull
    @Override
    public Disposable schedule(@NonNull final Runnable action, long delayTime, @NonNull TimeUnit unit) {
<span class="fc bfc" id="L48" title="All 2 branches covered.">        if (disposed) {</span>
<span class="fc" id="L49">            return EmptyDisposable.INSTANCE;</span>
        }
<span class="fc" id="L51">        return scheduleActual(action, delayTime, unit, null);</span>
    }

    /**
     * Schedules the given runnable on the underlying executor directly and
     * returns its future wrapped into a Disposable.
     * @param run the Runnable to execute in a delayed fashion
     * @param delayTime the delay amount
     * @param unit the delay time unit
     * @return the ScheduledRunnable instance
     */
    public Disposable scheduleDirect(final Runnable run, long delayTime, TimeUnit unit) {
<span class="fc" id="L63">        ScheduledDirectTask task = new ScheduledDirectTask(RxJavaPlugins.onSchedule(run));</span>
        try {
            Future&lt;?&gt; f;
<span class="fc bfc" id="L66" title="All 2 branches covered.">            if (delayTime &lt;= 0L) {</span>
<span class="fc" id="L67">                f = executor.submit(task);</span>
            } else {
<span class="fc" id="L69">                f = executor.schedule(task, delayTime, unit);</span>
            }
<span class="fc" id="L71">            task.setFuture(f);</span>
<span class="fc" id="L72">            return task;</span>
<span class="fc" id="L73">        } catch (RejectedExecutionException ex) {</span>
<span class="fc" id="L74">            RxJavaPlugins.onError(ex);</span>
<span class="fc" id="L75">            return EmptyDisposable.INSTANCE;</span>
        }
    }

    /**
     * Schedules the given runnable periodically on the underlying executor directly
     * and returns its future wrapped into a Disposable.
     * @param run the Runnable to execute in a periodic fashion
     * @param initialDelay the initial delay amount
     * @param period the repeat period amount
     * @param unit the time unit for both the initialDelay and period
     * @return the ScheduledRunnable instance
     */
    public Disposable schedulePeriodicallyDirect(Runnable run, long initialDelay, long period, TimeUnit unit) {
<span class="fc" id="L89">        final Runnable decoratedRun = RxJavaPlugins.onSchedule(run);</span>
<span class="fc bfc" id="L90" title="All 2 branches covered.">        if (period &lt;= 0L) {</span>

<span class="fc" id="L92">            InstantPeriodicTask periodicWrapper = new InstantPeriodicTask(decoratedRun, executor);</span>
            try {
                Future&lt;?&gt; f;
<span class="fc bfc" id="L95" title="All 2 branches covered.">                if (initialDelay &lt;= 0L) {</span>
<span class="fc" id="L96">                    f = executor.submit(periodicWrapper);</span>
                } else {
<span class="fc" id="L98">                    f = executor.schedule(periodicWrapper, initialDelay, unit);</span>
                }
<span class="fc" id="L100">                periodicWrapper.setFirst(f);</span>
<span class="nc" id="L101">            } catch (RejectedExecutionException ex) {</span>
<span class="nc" id="L102">                RxJavaPlugins.onError(ex);</span>
<span class="nc" id="L103">                return EmptyDisposable.INSTANCE;</span>
<span class="fc" id="L104">            }</span>

<span class="fc" id="L106">            return periodicWrapper;</span>
        }
<span class="fc" id="L108">        ScheduledDirectPeriodicTask task = new ScheduledDirectPeriodicTask(decoratedRun);</span>
        try {
<span class="fc" id="L110">            Future&lt;?&gt; f = executor.scheduleAtFixedRate(task, initialDelay, period, unit);</span>
<span class="fc" id="L111">            task.setFuture(f);</span>
<span class="fc" id="L112">            return task;</span>
<span class="fc" id="L113">        } catch (RejectedExecutionException ex) {</span>
<span class="fc" id="L114">            RxJavaPlugins.onError(ex);</span>
<span class="fc" id="L115">            return EmptyDisposable.INSTANCE;</span>
        }
    }

    /**
     * Wraps the given runnable into a ScheduledRunnable and schedules it
     * on the underlying ScheduledExecutorService.
     * &lt;p&gt;If the schedule has been rejected, the ScheduledRunnable.wasScheduled will return
     * false.
     * @param run the runnable instance
     * @param delayTime the time to delay the execution
     * @param unit the time unit
     * @param parent the optional tracker parent to add the created ScheduledRunnable instance to before it gets scheduled
     * @return the ScheduledRunnable instance
     */
    @NonNull
    public ScheduledRunnable scheduleActual(final Runnable run, long delayTime, @NonNull TimeUnit unit, @Nullable DisposableContainer parent) {
<span class="fc" id="L132">        Runnable decoratedRun = RxJavaPlugins.onSchedule(run);</span>

<span class="fc" id="L134">        ScheduledRunnable sr = new ScheduledRunnable(decoratedRun, parent);</span>

<span class="fc bfc" id="L136" title="All 2 branches covered.">        if (parent != null) {</span>
<span class="fc bfc" id="L137" title="All 2 branches covered.">            if (!parent.add(sr)) {</span>
<span class="fc" id="L138">                return sr;</span>
            }
        }

        Future&lt;?&gt; f;
        try {
<span class="fc bfc" id="L144" title="All 2 branches covered.">            if (delayTime &lt;= 0) {</span>
<span class="fc" id="L145">                f = executor.submit((Callable&lt;Object&gt;)sr);</span>
            } else {
<span class="fc" id="L147">                f = executor.schedule((Callable&lt;Object&gt;)sr, delayTime, unit);</span>
            }
<span class="fc" id="L149">            sr.setFuture(f);</span>
<span class="fc" id="L150">        } catch (RejectedExecutionException ex) {</span>
<span class="fc bfc" id="L151" title="All 2 branches covered.">            if (parent != null) {</span>
<span class="fc" id="L152">                parent.remove(sr);</span>
            }
<span class="fc" id="L154">            RxJavaPlugins.onError(ex);</span>
<span class="fc" id="L155">        }</span>

<span class="fc" id="L157">        return sr;</span>
    }

    @Override
    public void dispose() {
<span class="fc bfc" id="L162" title="All 2 branches covered.">        if (!disposed) {</span>
<span class="fc" id="L163">            disposed = true;</span>
<span class="fc" id="L164">            executor.shutdownNow();</span>
        }
<span class="fc" id="L166">    }</span>

    /**
     * Shuts down the underlying executor in a non-interrupting fashion.
     */
    public void shutdown() {
<span class="fc bfc" id="L172" title="All 2 branches covered.">        if (!disposed) {</span>
<span class="fc" id="L173">            disposed = true;</span>
<span class="fc" id="L174">            executor.shutdown();</span>
        }
<span class="fc" id="L176">    }</span>

    @Override
    public boolean isDisposed() {
<span class="fc" id="L180">        return disposed;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>