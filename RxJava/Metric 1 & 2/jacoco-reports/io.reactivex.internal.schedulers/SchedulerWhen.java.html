<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SchedulerWhen.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">RxJava_2_x$Unnamed.exec</a> &gt; <a href="index.source.html" class="el_package">io.reactivex.internal.schedulers</a> &gt; <span class="el_source">SchedulerWhen.java</span></div><h1>SchedulerWhen.java</h1><pre class="source lang-java linenums">/**
 * Copyright (c) 2016-present, RxJava Contributors.
 * 
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.reactivex.internal.schedulers;

import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicReference;

import io.reactivex.Completable;
import io.reactivex.CompletableObserver;
import io.reactivex.Flowable;
import io.reactivex.Observable;
import io.reactivex.Scheduler;
import io.reactivex.annotations.NonNull;
import io.reactivex.disposables.Disposable;
import io.reactivex.disposables.Disposables;
import io.reactivex.functions.Function;
import io.reactivex.internal.util.ExceptionHelper;
import io.reactivex.processors.FlowableProcessor;
import io.reactivex.processors.UnicastProcessor;

/**
 * Allows the use of operators for controlling the timing around when actions
 * scheduled on workers are actually done. This makes it possible to layer
 * additional behavior on this {@link Scheduler}. The only parameter is a
 * function that flattens an {@link Observable} of {@link Observable} of
 * {@link Completable}s into just one {@link Completable}. There must be a chain
 * of operators connecting the returned value to the source {@link Observable}
 * otherwise any work scheduled on the returned {@link Scheduler} will not be
 * executed.
 * &lt;p&gt;
 * When {@link Scheduler#createWorker()} is invoked a {@link Observable} of
 * {@link Completable}s is onNext'd to the combinator to be flattened. If the
 * inner {@link Observable} is not immediately subscribed to an calls to
 * {@link Worker#schedule} are buffered. Once the {@link Observable} is
 * subscribed to actions are then onNext'd as {@link Completable}s.
 * &lt;p&gt;
 * Finally the actions scheduled on the parent {@link Scheduler} when the inner
 * most {@link Completable}s are subscribed to.
 * &lt;p&gt;
 * When the {@link io.reactivex.Scheduler.Worker Worker} is unsubscribed the {@link Completable} emits an
 * onComplete and triggers any behavior in the flattening operator. The
 * {@link Observable} and all {@link Completable}s give to the flattening
 * function never onError.
 * &lt;p&gt;
 * Limit the amount concurrency two at a time without creating a new fix size
 * thread pool:
 * 
 * &lt;pre&gt;
 * Scheduler limitScheduler = Schedulers.computation().when(workers -&gt; {
 *  // use merge max concurrent to limit the number of concurrent
 *  // callbacks two at a time
 *  return Completable.merge(Observable.merge(workers), 2);
 * });
 * &lt;/pre&gt;
 * &lt;p&gt;
 * This is a slightly different way to limit the concurrency but it has some
 * interesting benefits and drawbacks to the method above. It works by limited
 * the number of concurrent {@link io.reactivex.Scheduler.Worker Worker}s rather than individual actions.
 * Generally each {@link Observable} uses its own {@link io.reactivex.Scheduler.Worker Worker}. This means
 * that this will essentially limit the number of concurrent subscribes. The
 * danger comes from using operators like
 * {@link Flowable#zip(org.reactivestreams.Publisher, org.reactivestreams.Publisher, io.reactivex.functions.BiFunction)} where
 * subscribing to the first {@link Observable} could deadlock the subscription
 * to the second.
 * 
 * &lt;pre&gt;
 * Scheduler limitScheduler = Schedulers.computation().when(workers -&gt; {
 *  // use merge max concurrent to limit the number of concurrent
 *  // Observables two at a time
 *  return Completable.merge(Observable.merge(workers, 2));
 * });
 * &lt;/pre&gt;
 * 
 * Slowing down the rate to no more than than 1 a second. This suffers from the
 * same problem as the one above I could find an {@link Observable} operator
 * that limits the rate without dropping the values (aka leaky bucket
 * algorithm).
 * 
 * &lt;pre&gt;
 * Scheduler slowScheduler = Schedulers.computation().when(workers -&gt; {
 *  // use concatenate to make each worker happen one at a time.
 *  return Completable.concat(workers.map(actions -&gt; {
 *      // delay the starting of the next worker by 1 second.
 *      return Completable.merge(actions.delaySubscription(1, TimeUnit.SECONDS));
 *  }));
 * });
 * &lt;/pre&gt;
 * &lt;p&gt;History 2.0.1 - experimental
 * @since 2.1
 */
public class SchedulerWhen extends Scheduler implements Disposable {
    private final Scheduler actualScheduler;
    private final FlowableProcessor&lt;Flowable&lt;Completable&gt;&gt; workerProcessor;
    private Disposable disposable;

<span class="fc" id="L110">    public SchedulerWhen(Function&lt;Flowable&lt;Flowable&lt;Completable&gt;&gt;, Completable&gt; combine, Scheduler actualScheduler) {</span>
<span class="fc" id="L111">        this.actualScheduler = actualScheduler;</span>
        // workers are converted into completables and put in this queue.
<span class="fc" id="L113">        this.workerProcessor = UnicastProcessor.&lt;Flowable&lt;Completable&gt;&gt;create().toSerialized();</span>
        // send it to a custom combinator to pick the order and rate at which
        // workers are processed.
        try {
<span class="fc" id="L117">            disposable = combine.apply(workerProcessor).subscribe();</span>
<span class="fc" id="L118">        } catch (Throwable e) {</span>
<span class="fc" id="L119">            throw ExceptionHelper.wrapOrThrow(e);</span>
<span class="fc" id="L120">        }</span>
<span class="fc" id="L121">    }</span>

    @Override
    public void dispose() {
<span class="fc" id="L125">        disposable.dispose();</span>
<span class="fc" id="L126">    }</span>

    @Override
    public boolean isDisposed() {
<span class="fc" id="L130">        return disposable.isDisposed();</span>
    }

    @NonNull
    @Override
    public Worker createWorker() {
<span class="fc" id="L136">        final Worker actualWorker = actualScheduler.createWorker();</span>
        // a queue for the actions submitted while worker is waiting to get to
        // the subscribe to off the workerQueue.
<span class="fc" id="L139">        final FlowableProcessor&lt;ScheduledAction&gt; actionProcessor = UnicastProcessor.&lt;ScheduledAction&gt;create().toSerialized();</span>
        // convert the work of scheduling all the actions into a completable
<span class="fc" id="L141">        Flowable&lt;Completable&gt; actions = actionProcessor.map(new CreateWorkerFunction(actualWorker));</span>

        // a worker that queues the action to the actionQueue subject.
<span class="fc" id="L144">        Worker worker = new QueueWorker(actionProcessor, actualWorker);</span>

        // enqueue the completable that process actions put in reply subject
<span class="fc" id="L147">        workerProcessor.onNext(actions);</span>

        // return the worker that adds actions to the reply subject
<span class="fc" id="L150">        return worker;</span>
    }

<span class="fc" id="L153">    static final Disposable SUBSCRIBED = new SubscribedDisposable();</span>

<span class="fc" id="L155">    static final Disposable DISPOSED = Disposables.disposed();</span>

    @SuppressWarnings(&quot;serial&quot;)
    abstract static class ScheduledAction extends AtomicReference&lt;Disposable&gt; implements Disposable {
        ScheduledAction() {
<span class="fc" id="L160">            super(SUBSCRIBED);</span>
<span class="fc" id="L161">        }</span>

        void call(Worker actualWorker, CompletableObserver actionCompletable) {
<span class="fc" id="L164">            Disposable oldState = get();</span>
            // either SUBSCRIBED or UNSUBSCRIBED
<span class="fc bfc" id="L166" title="All 2 branches covered.">            if (oldState == DISPOSED) {</span>
                // no need to schedule return
<span class="fc" id="L168">                return;</span>
            }
<span class="fc bfc" id="L170" title="All 2 branches covered.">            if (oldState != SUBSCRIBED) {</span>
                // has already been scheduled return
                // should not be able to get here but handle it anyway by not
                // rescheduling.
<span class="fc" id="L174">                return;</span>
            }

<span class="fc" id="L177">            Disposable newState = callActual(actualWorker, actionCompletable);</span>

<span class="fc bfc" id="L179" title="All 2 branches covered.">            if (!compareAndSet(SUBSCRIBED, newState)) {</span>
                // set would only fail if the new current state is some other
                // subscription from a concurrent call to this method.
                // Unsubscribe from the action just scheduled because it lost
                // the race.
<span class="fc" id="L184">                newState.dispose();</span>
            }
<span class="fc" id="L186">        }</span>

        protected abstract Disposable callActual(Worker actualWorker, CompletableObserver actionCompletable);

        @Override
        public boolean isDisposed() {
<span class="fc" id="L192">            return get().isDisposed();</span>
        }

        @Override
        public void dispose() {
            Disposable oldState;
            // no matter what the current state is the new state is going to be
<span class="fc" id="L199">            Disposable newState = DISPOSED;</span>
            do {
<span class="fc" id="L201">                oldState = get();</span>
<span class="fc bfc" id="L202" title="All 2 branches covered.">                if (oldState == DISPOSED) {</span>
                    // the action has already been unsubscribed
<span class="fc" id="L204">                    return;</span>
                }
<span class="fc bfc" id="L206" title="All 2 branches covered.">            } while (!compareAndSet(oldState, newState));</span>

<span class="pc bpc" id="L208" title="1 of 2 branches missed.">            if (oldState != SUBSCRIBED) {</span>
                // the action was scheduled. stop it.
<span class="nc" id="L210">                oldState.dispose();</span>
            }
<span class="fc" id="L212">        }</span>
    }

    @SuppressWarnings(&quot;serial&quot;)
    static class ImmediateAction extends ScheduledAction {
        private final Runnable action;

<span class="fc" id="L219">        ImmediateAction(Runnable action) {</span>
<span class="fc" id="L220">            this.action = action;</span>
<span class="fc" id="L221">        }</span>

        @Override
        protected Disposable callActual(Worker actualWorker, CompletableObserver actionCompletable) {
<span class="fc" id="L225">            return actualWorker.schedule(new OnCompletedAction(action, actionCompletable));</span>
        }
    }

    @SuppressWarnings(&quot;serial&quot;)
    static class DelayedAction extends ScheduledAction {
        private final Runnable action;
        private final long delayTime;
        private final TimeUnit unit;

<span class="fc" id="L235">        DelayedAction(Runnable action, long delayTime, TimeUnit unit) {</span>
<span class="fc" id="L236">            this.action = action;</span>
<span class="fc" id="L237">            this.delayTime = delayTime;</span>
<span class="fc" id="L238">            this.unit = unit;</span>
<span class="fc" id="L239">        }</span>

        @Override
        protected Disposable callActual(Worker actualWorker, CompletableObserver actionCompletable) {
<span class="fc" id="L243">            return actualWorker.schedule(new OnCompletedAction(action, actionCompletable), delayTime, unit);</span>
        }
    }

    static class OnCompletedAction implements Runnable {
        final CompletableObserver actionCompletable;
        final Runnable action;

<span class="fc" id="L251">        OnCompletedAction(Runnable action, CompletableObserver actionCompletable) {</span>
<span class="fc" id="L252">            this.action = action;</span>
<span class="fc" id="L253">            this.actionCompletable = actionCompletable;</span>
<span class="fc" id="L254">        }</span>

        @Override
        public void run() {
            try {
<span class="fc" id="L259">                action.run();</span>
            } finally {
<span class="fc" id="L261">                actionCompletable.onComplete();</span>
            }
<span class="fc" id="L263">        }</span>
    }

    static final class CreateWorkerFunction implements Function&lt;ScheduledAction, Completable&gt; {
        final Worker actualWorker;

<span class="fc" id="L269">        CreateWorkerFunction(Worker actualWorker) {</span>
<span class="fc" id="L270">            this.actualWorker = actualWorker;</span>
<span class="fc" id="L271">        }</span>

        @Override
        public Completable apply(final ScheduledAction action) {
<span class="fc" id="L275">            return new WorkerCompletable(action);</span>
        }

        final class WorkerCompletable extends Completable {
            final ScheduledAction action;

<span class="fc" id="L281">            WorkerCompletable(ScheduledAction action) {</span>
<span class="fc" id="L282">                this.action = action;</span>
<span class="fc" id="L283">            }</span>

            @Override
            protected void subscribeActual(CompletableObserver actionCompletable) {
<span class="fc" id="L287">                actionCompletable.onSubscribe(action);</span>
<span class="fc" id="L288">                action.call(actualWorker, actionCompletable);</span>
<span class="fc" id="L289">            }</span>
        }
    }

    static final class QueueWorker extends Worker {
        private final AtomicBoolean unsubscribed;
        private final FlowableProcessor&lt;ScheduledAction&gt; actionProcessor;
        private final Worker actualWorker;

<span class="fc" id="L298">        QueueWorker(FlowableProcessor&lt;ScheduledAction&gt; actionProcessor, Worker actualWorker) {</span>
<span class="fc" id="L299">            this.actionProcessor = actionProcessor;</span>
<span class="fc" id="L300">            this.actualWorker = actualWorker;</span>
<span class="fc" id="L301">            unsubscribed = new AtomicBoolean();</span>
<span class="fc" id="L302">        }</span>

        @Override
        public void dispose() {
            // complete the actionQueue when worker is unsubscribed to make
            // room for the next worker in the workerQueue.
<span class="fc bfc" id="L308" title="All 2 branches covered.">            if (unsubscribed.compareAndSet(false, true)) {</span>
<span class="fc" id="L309">                actionProcessor.onComplete();</span>
<span class="fc" id="L310">                actualWorker.dispose();</span>
            }
<span class="fc" id="L312">        }</span>

        @Override
        public boolean isDisposed() {
<span class="fc" id="L316">            return unsubscribed.get();</span>
        }

        @NonNull
        @Override
        public Disposable schedule(@NonNull final Runnable action, final long delayTime, @NonNull final TimeUnit unit) {
            // send a scheduled action to the actionQueue
<span class="fc" id="L323">            DelayedAction delayedAction = new DelayedAction(action, delayTime, unit);</span>
<span class="fc" id="L324">            actionProcessor.onNext(delayedAction);</span>
<span class="fc" id="L325">            return delayedAction;</span>
        }

        @NonNull
        @Override
        public Disposable schedule(@NonNull final Runnable action) {
            // send a scheduled action to the actionQueue
<span class="fc" id="L332">            ImmediateAction immediateAction = new ImmediateAction(action);</span>
<span class="fc" id="L333">            actionProcessor.onNext(immediateAction);</span>
<span class="fc" id="L334">            return immediateAction;</span>
        }
    }

<span class="fc" id="L338">    static final class SubscribedDisposable implements Disposable {</span>
        @Override
        public void dispose() {
<span class="fc" id="L341">        }</span>

        @Override
        public boolean isDisposed() {
<span class="fc" id="L345">            return false;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>