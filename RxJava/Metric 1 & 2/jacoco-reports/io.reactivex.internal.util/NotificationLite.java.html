<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>NotificationLite.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">RxJava_2_x$Unnamed.exec</a> &gt; <a href="index.source.html" class="el_package">io.reactivex.internal.util</a> &gt; <span class="el_source">NotificationLite.java</span></div><h1>NotificationLite.java</h1><pre class="source lang-java linenums">/**
 * Copyright (c) 2016-present, RxJava Contributors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is
 * distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
 * the License for the specific language governing permissions and limitations under the License.
 */
package io.reactivex.internal.util;

import java.io.Serializable;

import org.reactivestreams.*;

import io.reactivex.Observer;
import io.reactivex.disposables.Disposable;
import io.reactivex.internal.functions.ObjectHelper;

/**
 * Lightweight notification handling utility class.
 */
<span class="fc" id="L26">public enum NotificationLite {</span>
<span class="fc" id="L27">    COMPLETE</span>
    ;

    /**
     * Wraps a Throwable.
     */
    static final class ErrorNotification implements Serializable {

        private static final long serialVersionUID = -8759979445933046293L;
        final Throwable e;
<span class="fc" id="L37">        ErrorNotification(Throwable e) {</span>
<span class="fc" id="L38">            this.e = e;</span>
<span class="fc" id="L39">        }</span>

        @Override
        public String toString() {
<span class="fc" id="L43">            return &quot;NotificationLite.Error[&quot; + e + &quot;]&quot;;</span>
        }

        @Override
        public int hashCode() {
<span class="fc" id="L48">            return e.hashCode();</span>
        }

        @Override
        public boolean equals(Object obj) {
<span class="fc bfc" id="L53" title="All 2 branches covered.">            if (obj instanceof ErrorNotification) {</span>
<span class="fc" id="L54">                ErrorNotification n = (ErrorNotification) obj;</span>
<span class="fc" id="L55">                return ObjectHelper.equals(e, n.e);</span>
            }
<span class="fc" id="L57">            return false;</span>
        }
    }

    /**
     * Wraps a Subscription.
     */
    static final class SubscriptionNotification implements Serializable {

        private static final long serialVersionUID = -1322257508628817540L;
        final Subscription upstream;
<span class="fc" id="L68">        SubscriptionNotification(Subscription s) {</span>
<span class="fc" id="L69">            this.upstream = s;</span>
<span class="fc" id="L70">        }</span>

        @Override
        public String toString() {
<span class="fc" id="L74">            return &quot;NotificationLite.Subscription[&quot; + upstream + &quot;]&quot;;</span>
        }
    }

    /**
     * Wraps a Disposable.
     */
    static final class DisposableNotification implements Serializable {

        private static final long serialVersionUID = -7482590109178395495L;
        final Disposable upstream;

<span class="fc" id="L86">        DisposableNotification(Disposable d) {</span>
<span class="fc" id="L87">            this.upstream = d;</span>
<span class="fc" id="L88">        }</span>

        @Override
        public String toString() {
<span class="fc" id="L92">            return &quot;NotificationLite.Disposable[&quot; + upstream + &quot;]&quot;;</span>
        }
    }

    /**
     * Converts a value into a notification value.
     * @param &lt;T&gt; the actual value type
     * @param value the value to convert
     * @return the notification representing the value
     */
    public static &lt;T&gt; Object next(T value) {
<span class="fc" id="L103">        return value;</span>
    }

    /**
     * Returns a complete notification.
     * @return a complete notification
     */
    public static Object complete() {
<span class="fc" id="L111">        return COMPLETE;</span>
    }

    /**
     * Converts a Throwable into a notification value.
     * @param e the Throwable to convert
     * @return the notification representing the Throwable
     */
    public static Object error(Throwable e) {
<span class="fc" id="L120">        return new ErrorNotification(e);</span>
    }

    /**
     * Converts a Subscription into a notification value.
     * @param s the Subscription to convert
     * @return the notification representing the Subscription
     */
    public static Object subscription(Subscription s) {
<span class="fc" id="L129">        return new SubscriptionNotification(s);</span>
    }

    /**
     * Converts a Disposable into a notification value.
     * @param d the disposable to convert
     * @return the notification representing the Disposable
     */
    public static Object disposable(Disposable d) {
<span class="fc" id="L138">        return new DisposableNotification(d);</span>
    }

    /**
     * Checks if the given object represents a complete notification.
     * @param o the object to check
     * @return true if the object represents a complete notification
     */
    public static boolean isComplete(Object o) {
<span class="fc bfc" id="L147" title="All 2 branches covered.">        return o == COMPLETE;</span>
    }

    /**
     * Checks if the given object represents a error notification.
     * @param o the object to check
     * @return true if the object represents a error notification
     */
    public static boolean isError(Object o) {
<span class="fc" id="L156">        return o instanceof ErrorNotification;</span>
    }

    /**
     * Checks if the given object represents a subscription notification.
     * @param o the object to check
     * @return true if the object represents a subscription notification
     */
    public static boolean isSubscription(Object o) {
<span class="fc" id="L165">        return o instanceof SubscriptionNotification;</span>
    }

    public static boolean isDisposable(Object o) {
<span class="fc" id="L169">        return o instanceof DisposableNotification;</span>
    }

    /**
     * Extracts the value from the notification object.
     * @param &lt;T&gt; the expected value type when unwrapped
     * @param o the notification object
     * @return the extracted value
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; T getValue(Object o) {
<span class="fc" id="L180">        return (T)o;</span>
    }

    /**
     * Extracts the Throwable from the notification object.
     * @param o the notification object
     * @return the extracted Throwable
     */
    public static Throwable getError(Object o) {
<span class="fc" id="L189">        return ((ErrorNotification)o).e;</span>
    }

    /**
     * Extracts the Subscription from the notification object.
     * @param o the notification object
     * @return the extracted Subscription
     */
    public static Subscription getSubscription(Object o) {
<span class="fc" id="L198">        return ((SubscriptionNotification)o).upstream;</span>
    }

    public static Disposable getDisposable(Object o) {
<span class="fc" id="L202">        return ((DisposableNotification)o).upstream;</span>
    }

    /**
     * Calls the appropriate Subscriber method based on the type of the notification.
     * &lt;p&gt;Does not check for a subscription notification, see {@link #acceptFull(Object, Subscriber)}.
     * @param &lt;T&gt; the expected value type when unwrapped
     * @param o the notification object
     * @param s the subscriber to call methods on
     * @return true if the notification was a terminal event (i.e., complete or error)
     * @see #acceptFull(Object, Subscriber)
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; boolean accept(Object o, Subscriber&lt;? super T&gt; s) {
<span class="fc bfc" id="L216" title="All 2 branches covered.">        if (o == COMPLETE) {</span>
<span class="fc" id="L217">            s.onComplete();</span>
<span class="fc" id="L218">            return true;</span>
        } else
<span class="fc bfc" id="L220" title="All 2 branches covered.">        if (o instanceof ErrorNotification) {</span>
<span class="fc" id="L221">            s.onError(((ErrorNotification)o).e);</span>
<span class="fc" id="L222">            return true;</span>
        }
<span class="fc" id="L224">        s.onNext((T)o);</span>
<span class="fc" id="L225">        return false;</span>
    }

    /**
     * Calls the appropriate Observer method based on the type of the notification.
     * &lt;p&gt;Does not check for a subscription notification.
     * @param &lt;T&gt; the expected value type when unwrapped
     * @param o the notification object
     * @param observer the Observer to call methods on
     * @return true if the notification was a terminal event (i.e., complete or error)
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; boolean accept(Object o, Observer&lt;? super T&gt; observer) {
<span class="fc bfc" id="L238" title="All 2 branches covered.">        if (o == COMPLETE) {</span>
<span class="fc" id="L239">            observer.onComplete();</span>
<span class="fc" id="L240">            return true;</span>
        } else
<span class="fc bfc" id="L242" title="All 2 branches covered.">        if (o instanceof ErrorNotification) {</span>
<span class="fc" id="L243">            observer.onError(((ErrorNotification)o).e);</span>
<span class="fc" id="L244">            return true;</span>
        }
<span class="fc" id="L246">        observer.onNext((T)o);</span>
<span class="fc" id="L247">        return false;</span>
    }

    /**
     * Calls the appropriate Subscriber method based on the type of the notification.
     * @param &lt;T&gt; the expected value type when unwrapped
     * @param o the notification object
     * @param s the subscriber to call methods on
     * @return true if the notification was a terminal event (i.e., complete or error)
     * @see #accept(Object, Subscriber)
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; boolean acceptFull(Object o, Subscriber&lt;? super T&gt; s) {
<span class="fc bfc" id="L260" title="All 2 branches covered.">        if (o == COMPLETE) {</span>
<span class="fc" id="L261">            s.onComplete();</span>
<span class="fc" id="L262">            return true;</span>
        } else
<span class="fc bfc" id="L264" title="All 2 branches covered.">        if (o instanceof ErrorNotification) {</span>
<span class="fc" id="L265">            s.onError(((ErrorNotification)o).e);</span>
<span class="fc" id="L266">            return true;</span>
        } else
<span class="fc bfc" id="L268" title="All 2 branches covered.">        if (o instanceof SubscriptionNotification) {</span>
<span class="fc" id="L269">            s.onSubscribe(((SubscriptionNotification)o).upstream);</span>
<span class="fc" id="L270">            return false;</span>
        }
<span class="fc" id="L272">        s.onNext((T)o);</span>
<span class="fc" id="L273">        return false;</span>
    }

    /**
     * Calls the appropriate Observer method based on the type of the notification.
     * @param &lt;T&gt; the expected value type when unwrapped
     * @param o the notification object
     * @param observer the subscriber to call methods on
     * @return true if the notification was a terminal event (i.e., complete or error)
     * @see #accept(Object, Observer)
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; boolean acceptFull(Object o, Observer&lt;? super T&gt; observer) {
<span class="fc bfc" id="L286" title="All 2 branches covered.">        if (o == COMPLETE) {</span>
<span class="fc" id="L287">            observer.onComplete();</span>
<span class="fc" id="L288">            return true;</span>
        } else
<span class="fc bfc" id="L290" title="All 2 branches covered.">        if (o instanceof ErrorNotification) {</span>
<span class="fc" id="L291">            observer.onError(((ErrorNotification)o).e);</span>
<span class="fc" id="L292">            return true;</span>
        } else
<span class="fc bfc" id="L294" title="All 2 branches covered.">        if (o instanceof DisposableNotification) {</span>
<span class="fc" id="L295">            observer.onSubscribe(((DisposableNotification)o).upstream);</span>
<span class="fc" id="L296">            return false;</span>
        }
<span class="fc" id="L298">        observer.onNext((T)o);</span>
<span class="fc" id="L299">        return false;</span>
    }

    @Override
    public String toString() {
<span class="fc" id="L304">        return &quot;NotificationLite.Complete&quot;;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>