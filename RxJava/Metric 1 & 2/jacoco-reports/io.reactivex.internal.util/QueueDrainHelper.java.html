<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>QueueDrainHelper.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">RxJava_2_x$Unnamed.exec</a> &gt; <a href="index.source.html" class="el_package">io.reactivex.internal.util</a> &gt; <span class="el_source">QueueDrainHelper.java</span></div><h1>QueueDrainHelper.java</h1><pre class="source lang-java linenums">/**
 * Copyright (c) 2016-present, RxJava Contributors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is
 * distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
 * the License for the specific language governing permissions and limitations under the License.
 */
package io.reactivex.internal.util;

import java.util.Queue;
import java.util.concurrent.atomic.AtomicLong;

import org.reactivestreams.*;

import io.reactivex.Observer;
import io.reactivex.disposables.Disposable;
import io.reactivex.exceptions.*;
import io.reactivex.functions.BooleanSupplier;
import io.reactivex.internal.fuseable.*;
import io.reactivex.internal.queue.*;

/**
 * Utility class to help with the queue-drain serialization idiom.
 */
public final class QueueDrainHelper {
    /** Utility class. */
<span class="fc" id="L32">    private QueueDrainHelper() {</span>
<span class="fc" id="L33">        throw new IllegalStateException(&quot;No instances!&quot;);</span>
    }

    /**
     * Drain the queue but give up with an error if there aren't enough requests.
     * @param &lt;T&gt; the queue value type
     * @param &lt;U&gt; the emission value type
     * @param q the queue
     * @param a the subscriber
     * @param delayError true if errors should be delayed after all normal items
     * @param dispose the disposable to call when termination happens and cleanup is necessary
     * @param qd the QueueDrain instance that gives status information to the drain logic
     */
    public static &lt;T, U&gt; void drainMaxLoop(SimplePlainQueue&lt;T&gt; q, Subscriber&lt;? super U&gt; a, boolean delayError,
            Disposable dispose, QueueDrain&lt;T, U&gt; qd) {
<span class="fc" id="L48">        int missed = 1;</span>

        for (;;) {
            for (;;) {
<span class="fc" id="L52">                boolean d = qd.done();</span>

<span class="fc" id="L54">                T v = q.poll();</span>

<span class="fc bfc" id="L56" title="All 2 branches covered.">                boolean empty = v == null;</span>

<span class="fc bfc" id="L58" title="All 2 branches covered.">                if (checkTerminated(d, empty, a, delayError, q, qd)) {</span>
<span class="fc bfc" id="L59" title="All 2 branches covered.">                    if (dispose != null) {</span>
<span class="fc" id="L60">                        dispose.dispose();</span>
                    }
<span class="fc" id="L62">                    return;</span>
                }

<span class="fc bfc" id="L65" title="All 2 branches covered.">                if (empty) {</span>
<span class="fc" id="L66">                    break;</span>
                }

<span class="fc" id="L69">                long r = qd.requested();</span>
<span class="fc bfc" id="L70" title="All 2 branches covered.">                if (r != 0L) {</span>
<span class="fc bfc" id="L71" title="All 2 branches covered.">                    if (qd.accept(a, v)) {</span>
<span class="fc bfc" id="L72" title="All 2 branches covered.">                        if (r != Long.MAX_VALUE) {</span>
<span class="fc" id="L73">                            qd.produced(1);</span>
                        }
                    }
                } else {
<span class="fc" id="L77">                    q.clear();</span>
<span class="fc bfc" id="L78" title="All 2 branches covered.">                    if (dispose != null) {</span>
<span class="fc" id="L79">                        dispose.dispose();</span>
                    }
<span class="fc" id="L81">                    a.onError(new MissingBackpressureException(&quot;Could not emit value due to lack of requests.&quot;));</span>
<span class="fc" id="L82">                    return;</span>
                }
<span class="fc" id="L84">            }</span>

<span class="fc" id="L86">            missed = qd.leave(-missed);</span>
<span class="fc bfc" id="L87" title="All 2 branches covered.">            if (missed == 0) {</span>
<span class="fc" id="L88">                break;</span>
            }
        }
<span class="fc" id="L91">    }</span>

    public static &lt;T, U&gt; boolean checkTerminated(boolean d, boolean empty,
            Subscriber&lt;?&gt; s, boolean delayError, SimpleQueue&lt;?&gt; q, QueueDrain&lt;T, U&gt; qd) {
<span class="fc bfc" id="L95" title="All 2 branches covered.">        if (qd.cancelled()) {</span>
<span class="fc" id="L96">            q.clear();</span>
<span class="fc" id="L97">            return true;</span>
        }

<span class="fc bfc" id="L100" title="All 2 branches covered.">        if (d) {</span>
<span class="fc bfc" id="L101" title="All 2 branches covered.">            if (delayError) {</span>
<span class="fc bfc" id="L102" title="All 2 branches covered.">                if (empty) {</span>
<span class="fc" id="L103">                    Throwable err = qd.error();</span>
<span class="fc bfc" id="L104" title="All 2 branches covered.">                    if (err != null) {</span>
<span class="fc" id="L105">                        s.onError(err);</span>
                    } else {
<span class="fc" id="L107">                        s.onComplete();</span>
                    }
<span class="fc" id="L109">                    return true;</span>
                }
            } else {
<span class="fc" id="L112">                Throwable err = qd.error();</span>
<span class="fc bfc" id="L113" title="All 2 branches covered.">                if (err != null) {</span>
<span class="fc" id="L114">                    q.clear();</span>
<span class="fc" id="L115">                    s.onError(err);</span>
<span class="fc" id="L116">                    return true;</span>
                } else
<span class="fc bfc" id="L118" title="All 2 branches covered.">                if (empty) {</span>
<span class="fc" id="L119">                    s.onComplete();</span>
<span class="fc" id="L120">                    return true;</span>
                }
            }
        }

<span class="fc" id="L125">        return false;</span>
    }

    public static &lt;T, U&gt; void drainLoop(SimplePlainQueue&lt;T&gt; q, Observer&lt;? super U&gt; a, boolean delayError, Disposable dispose, ObservableQueueDrain&lt;T, U&gt; qd) {

<span class="fc" id="L130">        int missed = 1;</span>

        for (;;) {
<span class="fc bfc" id="L133" title="All 2 branches covered.">            if (checkTerminated(qd.done(), q.isEmpty(), a, delayError, q, dispose, qd)) {</span>
<span class="fc" id="L134">                return;</span>
            }

            for (;;) {
<span class="fc" id="L138">                boolean d = qd.done();</span>
<span class="fc" id="L139">                T v = q.poll();</span>
<span class="fc bfc" id="L140" title="All 2 branches covered.">                boolean empty = v == null;</span>

<span class="fc bfc" id="L142" title="All 2 branches covered.">                if (checkTerminated(d, empty, a, delayError, q, dispose, qd)) {</span>
<span class="fc" id="L143">                    return;</span>
                }

<span class="fc bfc" id="L146" title="All 2 branches covered.">                if (empty) {</span>
<span class="fc" id="L147">                    break;</span>
                }

<span class="fc" id="L150">                qd.accept(a, v);</span>
<span class="fc" id="L151">            }</span>

<span class="fc" id="L153">            missed = qd.leave(-missed);</span>
<span class="fc bfc" id="L154" title="All 2 branches covered.">            if (missed == 0) {</span>
<span class="fc" id="L155">                break;</span>
            }
        }
<span class="fc" id="L158">    }</span>

    public static &lt;T, U&gt; boolean checkTerminated(boolean d, boolean empty,
            Observer&lt;?&gt; observer, boolean delayError, SimpleQueue&lt;?&gt; q, Disposable disposable, ObservableQueueDrain&lt;T, U&gt; qd) {
<span class="fc bfc" id="L162" title="All 2 branches covered.">        if (qd.cancelled()) {</span>
<span class="fc" id="L163">            q.clear();</span>
<span class="fc" id="L164">            disposable.dispose();</span>
<span class="fc" id="L165">            return true;</span>
        }

<span class="fc bfc" id="L168" title="All 2 branches covered.">        if (d) {</span>
<span class="fc bfc" id="L169" title="All 2 branches covered.">            if (delayError) {</span>
<span class="fc bfc" id="L170" title="All 2 branches covered.">                if (empty) {</span>
<span class="fc bfc" id="L171" title="All 2 branches covered.">                    if (disposable != null) {</span>
<span class="fc" id="L172">                        disposable.dispose();</span>
                    }
<span class="fc" id="L174">                    Throwable err = qd.error();</span>
<span class="fc bfc" id="L175" title="All 2 branches covered.">                    if (err != null) {</span>
<span class="fc" id="L176">                        observer.onError(err);</span>
                    } else {
<span class="fc" id="L178">                        observer.onComplete();</span>
                    }
<span class="fc" id="L180">                    return true;</span>
                }
            } else {
<span class="fc" id="L183">                Throwable err = qd.error();</span>
<span class="fc bfc" id="L184" title="All 2 branches covered.">                if (err != null) {</span>
<span class="fc" id="L185">                    q.clear();</span>
<span class="fc bfc" id="L186" title="All 2 branches covered.">                    if (disposable != null) {</span>
<span class="fc" id="L187">                        disposable.dispose();</span>
                    }
<span class="fc" id="L189">                    observer.onError(err);</span>
<span class="fc" id="L190">                    return true;</span>
                } else
<span class="fc bfc" id="L192" title="All 2 branches covered.">                if (empty) {</span>
<span class="fc bfc" id="L193" title="All 2 branches covered.">                    if (disposable != null) {</span>
<span class="fc" id="L194">                        disposable.dispose();</span>
                    }
<span class="fc" id="L196">                    observer.onComplete();</span>
<span class="fc" id="L197">                    return true;</span>
                }
            }
        }

<span class="fc" id="L202">        return false;</span>
    }

    /**
     * Creates a queue: spsc-array if capacityHint is positive and
     * spsc-linked-array if capacityHint is negative; in both cases, the
     * capacity is the absolute value of prefetch.
     * @param &lt;T&gt; the value type of the queue
     * @param capacityHint the capacity hint, negative value will create an array-based SPSC queue
     * @return the queue instance
     */
    public static &lt;T&gt; SimpleQueue&lt;T&gt; createQueue(int capacityHint) {
<span class="fc bfc" id="L214" title="All 2 branches covered.">        if (capacityHint &lt; 0) {</span>
<span class="fc" id="L215">            return new SpscLinkedArrayQueue&lt;T&gt;(-capacityHint);</span>
        }
<span class="fc" id="L217">        return new SpscArrayQueue&lt;T&gt;(capacityHint);</span>
    }

    /**
     * Requests Long.MAX_VALUE if prefetch is negative or the exact
     * amount if prefetch is positive.
     * @param s the Subscription to request from
     * @param prefetch the prefetch value
     */
    public static void request(Subscription s, int prefetch) {
<span class="fc bfc" id="L227" title="All 2 branches covered.">        s.request(prefetch &lt; 0 ? Long.MAX_VALUE : prefetch);</span>
<span class="fc" id="L228">    }</span>

    static final long COMPLETED_MASK = 0x8000000000000000L;
    static final long REQUESTED_MASK = 0x7FFFFFFFFFFFFFFFL;

    /**
     * Accumulates requests (not validated) and handles the completed mode draining of the queue based on the requests.
     *
     * &lt;p&gt;
     * Post-completion backpressure handles the case when a source produces values based on
     * requests when it is active but more values are available even after its completion.
     * In this case, the onComplete() can't just emit the contents of the queue but has to
     * coordinate with the requested amounts. This requires two distinct modes: active and
     * completed. In active mode, requests flow through and the queue is not accessed but
     * in completed mode, requests no-longer reach the upstream but help in draining the queue.
     *
     * @param &lt;T&gt; the value type emitted
     * @param n the request amount, positive (not validated)
     * @param actual the target Subscriber to send events to
     * @param queue the queue to drain if in the post-complete state
     * @param state holds the request amount and the post-completed flag
     * @param isCancelled a supplier that returns true if the drain has been cancelled
     * @return true if the state indicates a completion state.
     */
    public static &lt;T&gt; boolean postCompleteRequest(long n,
                                                  Subscriber&lt;? super T&gt; actual,
                                                  Queue&lt;T&gt; queue,
                                                  AtomicLong state,
                                                  BooleanSupplier isCancelled) {
        for (; ; ) {
<span class="fc" id="L258">            long r = state.get();</span>

            // extract the current request amount
<span class="fc" id="L261">            long r0 = r &amp; REQUESTED_MASK;</span>

            // preserve COMPLETED_MASK and calculate new requested amount
<span class="fc" id="L264">            long u = (r &amp; COMPLETED_MASK) | BackpressureHelper.addCap(r0, n);</span>

<span class="fc bfc" id="L266" title="All 2 branches covered.">            if (state.compareAndSet(r, u)) {</span>
                // (complete, 0) -&gt; (complete, n) transition then replay
<span class="fc bfc" id="L268" title="All 2 branches covered.">                if (r == COMPLETED_MASK) {</span>

<span class="fc" id="L270">                    postCompleteDrain(n | COMPLETED_MASK, actual, queue, state, isCancelled);</span>

<span class="fc" id="L272">                    return true;</span>
                }
                // (active, r) -&gt; (active, r + n) transition then continue with requesting from upstream
<span class="fc" id="L275">                return false;</span>
            }
<span class="fc" id="L277">        }</span>

    }

    static boolean isCancelled(BooleanSupplier cancelled) {
        try {
<span class="fc" id="L283">            return cancelled.getAsBoolean();</span>
<span class="fc" id="L284">        } catch (Throwable ex) {</span>
<span class="fc" id="L285">            Exceptions.throwIfFatal(ex);</span>
<span class="fc" id="L286">            return true;</span>
        }
    }

    /**
     * Drains the queue based on the outstanding requests in post-completed mode (only!).
     *
     * @param n the current request amount
     * @param actual the target Subscriber to send events to
     * @param queue the queue to drain if in the post-complete state
     * @param state holds the request amount and the post-completed flag
     * @param isCancelled a supplier that returns true if the drain has been cancelled
     * @return true if the queue was completely drained or the drain process was cancelled
     */
    static &lt;T&gt; boolean postCompleteDrain(long n,
                                         Subscriber&lt;? super T&gt; actual,
                                         Queue&lt;T&gt; queue,
                                         AtomicLong state,
                                         BooleanSupplier isCancelled) {

// TODO enable fast-path
//        if (n == -1 || n == Long.MAX_VALUE) {
//            for (;;) {
//                if (isCancelled.getAsBoolean()) {
//                    break;
//                }
//
//                T v = queue.poll();
//
//                if (v == null) {
//                    actual.onComplete();
//                    break;
//                }
//
//                actual.onNext(v);
//            }
//
//            return true;
//        }

<span class="fc" id="L326">        long e = n &amp; COMPLETED_MASK;</span>

        for (; ; ) {

<span class="fc bfc" id="L330" title="All 2 branches covered.">            while (e != n) {</span>
<span class="fc bfc" id="L331" title="All 2 branches covered.">                if (isCancelled(isCancelled)) {</span>
<span class="fc" id="L332">                    return true;</span>
                }

<span class="fc" id="L335">                T t = queue.poll();</span>

<span class="fc bfc" id="L337" title="All 2 branches covered.">                if (t == null) {</span>
<span class="fc" id="L338">                    actual.onComplete();</span>
<span class="fc" id="L339">                    return true;</span>
                }

<span class="fc" id="L342">                actual.onNext(t);</span>
<span class="fc" id="L343">                e++;</span>
<span class="fc" id="L344">            }</span>

<span class="fc bfc" id="L346" title="All 2 branches covered.">            if (isCancelled(isCancelled)) {</span>
<span class="fc" id="L347">                return true;</span>
            }

<span class="fc bfc" id="L350" title="All 2 branches covered.">            if (queue.isEmpty()) {</span>
<span class="fc" id="L351">                actual.onComplete();</span>
<span class="fc" id="L352">                return true;</span>
            }

<span class="fc" id="L355">            n = state.get();</span>

<span class="fc bfc" id="L357" title="All 2 branches covered.">            if (n == e) {</span>

<span class="fc" id="L359">                n = state.addAndGet(-(e &amp; REQUESTED_MASK));</span>

<span class="fc bfc" id="L361" title="All 2 branches covered.">                if ((n &amp; REQUESTED_MASK) == 0L) {</span>
<span class="fc" id="L362">                    return false;</span>
                }

<span class="fc" id="L365">                e = n &amp; COMPLETED_MASK;</span>
            }
        }

    }

    /**
     * Signals the completion of the main sequence and switches to post-completion replay mode.
     *
     * &lt;p&gt;
     * Don't modify the queue after calling this method!
     *
     * &lt;p&gt;
     * Post-completion backpressure handles the case when a source produces values based on
     * requests when it is active but more values are available even after its completion.
     * In this case, the onComplete() can't just emit the contents of the queue but has to
     * coordinate with the requested amounts. This requires two distinct modes: active and
     * completed. In active mode, requests flow through and the queue is not accessed but
     * in completed mode, requests no-longer reach the upstream but help in draining the queue.
     * &lt;p&gt;
     * The algorithm utilizes the most significant bit (bit 63) of a long value (AtomicLong) since
     * request amount only goes up to Long.MAX_VALUE (bits 0-62) and negative values aren't
     * allowed.
     *
     * @param &lt;T&gt; the value type emitted
     * @param actual the target Subscriber to send events to
     * @param queue the queue to drain if in the post-complete state
     * @param state holds the request amount and the post-completed flag
     * @param isCancelled a supplier that returns true if the drain has been cancelled
     */
    public static &lt;T&gt; void postComplete(Subscriber&lt;? super T&gt; actual,
                                        Queue&lt;T&gt; queue,
                                        AtomicLong state,
                                        BooleanSupplier isCancelled) {

<span class="fc bfc" id="L400" title="All 2 branches covered.">        if (queue.isEmpty()) {</span>
<span class="fc" id="L401">            actual.onComplete();</span>
<span class="fc" id="L402">            return;</span>
        }

<span class="fc bfc" id="L405" title="All 2 branches covered.">        if (postCompleteDrain(state.get(), actual, queue, state, isCancelled)) {</span>
<span class="fc" id="L406">            return;</span>
        }

        for (; ; ) {
<span class="fc" id="L410">            long r = state.get();</span>

<span class="fc bfc" id="L412" title="All 2 branches covered.">            if ((r &amp; COMPLETED_MASK) != 0L) {</span>
<span class="fc" id="L413">                return;</span>
            }

<span class="fc" id="L416">            long u = r | COMPLETED_MASK;</span>
            // (active, r) -&gt; (complete, r) transition
<span class="fc bfc" id="L418" title="All 2 branches covered.">            if (state.compareAndSet(r, u)) {</span>
                // if the requested amount was non-zero, drain the queue
<span class="fc bfc" id="L420" title="All 2 branches covered.">                if (r != 0L) {</span>
<span class="fc" id="L421">                    postCompleteDrain(u, actual, queue, state, isCancelled);</span>
                }

<span class="fc" id="L424">                return;</span>
            }
<span class="fc" id="L426">        }</span>

    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>