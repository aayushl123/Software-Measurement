<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ObservableTest.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">RxJava_2_x$Unnamed.exec</a> &gt; <a href="index.source.html" class="el_package">io.reactivex.observable</a> &gt; <span class="el_source">ObservableTest.java</span></div><h1>ObservableTest.java</h1><pre class="source lang-java linenums">/**
 * Copyright (c) 2016-present, RxJava Contributors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is
 * distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
 * the License for the specific language governing permissions and limitations under the License.
 */

package io.reactivex.observable;

import static org.junit.Assert.*;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;

import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.*;

import org.junit.*;
import org.mockito.InOrder;

import io.reactivex.*;
import io.reactivex.Observable;
import io.reactivex.Observer;
import io.reactivex.disposables.*;
import io.reactivex.functions.*;
import io.reactivex.internal.functions.Functions;
import io.reactivex.observables.ConnectableObservable;
import io.reactivex.observers.*;
import io.reactivex.schedulers.*;
import io.reactivex.subjects.*;

<span class="fc" id="L38">public class ObservableTest {</span>

    Observer&lt;Number&gt; w;
    SingleObserver&lt;Number&gt; wo;
    MaybeObserver&lt;Number&gt; wm;

<span class="fc" id="L44">    private static final Predicate&lt;Integer&gt; IS_EVEN = new Predicate&lt;Integer&gt;() {</span>
        @Override
        public boolean test(Integer v) {
<span class="fc bfc" id="L47" title="All 2 branches covered.">            return v % 2 == 0;</span>
        }
    };

    @Before
    public void before() {
<span class="fc" id="L53">        w = TestHelper.mockObserver();</span>
<span class="fc" id="L54">        wo = TestHelper.mockSingleObserver();</span>
<span class="fc" id="L55">        wm = TestHelper.mockMaybeObserver();</span>
<span class="fc" id="L56">    }</span>

    @Test
    public void fromArray() {
<span class="fc" id="L60">        String[] items = new String[] { &quot;one&quot;, &quot;two&quot;, &quot;three&quot; };</span>
<span class="fc" id="L61">        assertEquals((Long)3L, Observable.fromArray(items).count().blockingGet());</span>
<span class="fc" id="L62">        assertEquals(&quot;two&quot;, Observable.fromArray(items).skip(1).take(1).blockingSingle());</span>
<span class="fc" id="L63">        assertEquals(&quot;three&quot;, Observable.fromArray(items).takeLast(1).blockingSingle());</span>
<span class="fc" id="L64">    }</span>

    @Test
    public void fromIterable() {
<span class="fc" id="L68">        ArrayList&lt;String&gt; items = new ArrayList&lt;String&gt;();</span>
<span class="fc" id="L69">        items.add(&quot;one&quot;);</span>
<span class="fc" id="L70">        items.add(&quot;two&quot;);</span>
<span class="fc" id="L71">        items.add(&quot;three&quot;);</span>

<span class="fc" id="L73">        assertEquals((Long)3L, Observable.fromIterable(items).count().blockingGet());</span>
<span class="fc" id="L74">        assertEquals(&quot;two&quot;, Observable.fromIterable(items).skip(1).take(1).blockingSingle());</span>
<span class="fc" id="L75">        assertEquals(&quot;three&quot;, Observable.fromIterable(items).takeLast(1).blockingSingle());</span>
<span class="fc" id="L76">    }</span>

    @Test
    public void fromArityArgs3() {
<span class="fc" id="L80">        Observable&lt;String&gt; items = Observable.just(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;);</span>

<span class="fc" id="L82">        assertEquals((Long)3L, items.count().blockingGet());</span>
<span class="fc" id="L83">        assertEquals(&quot;two&quot;, items.skip(1).take(1).blockingSingle());</span>
<span class="fc" id="L84">        assertEquals(&quot;three&quot;, items.takeLast(1).blockingSingle());</span>
<span class="fc" id="L85">    }</span>

    @Test
    public void fromArityArgs1() {
<span class="fc" id="L89">        Observable&lt;String&gt; items = Observable.just(&quot;one&quot;);</span>

<span class="fc" id="L91">        assertEquals((Long)1L, items.count().blockingGet());</span>
<span class="fc" id="L92">        assertEquals(&quot;one&quot;, items.takeLast(1).blockingSingle());</span>
<span class="fc" id="L93">    }</span>

    @Test
    public void testCreate() {

<span class="fc" id="L98">        Observable&lt;String&gt; o = Observable.just(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;);</span>

<span class="fc" id="L100">        Observer&lt;String&gt; observer = TestHelper.mockObserver();</span>

<span class="fc" id="L102">        o.subscribe(observer);</span>

<span class="fc" id="L104">        verify(observer, times(1)).onNext(&quot;one&quot;);</span>
<span class="fc" id="L105">        verify(observer, times(1)).onNext(&quot;two&quot;);</span>
<span class="fc" id="L106">        verify(observer, times(1)).onNext(&quot;three&quot;);</span>
<span class="fc" id="L107">        verify(observer, never()).onError(any(Throwable.class));</span>
<span class="fc" id="L108">        verify(observer, times(1)).onComplete();</span>
<span class="fc" id="L109">    }</span>

    @Test
    public void testCountAFewItemsObservable() {
<span class="fc" id="L113">        Observable&lt;String&gt; o = Observable.just(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;);</span>

<span class="fc" id="L115">        o.count().toObservable().subscribe(w);</span>

        // we should be called only once
<span class="fc" id="L118">        verify(w, times(1)).onNext(anyLong());</span>
<span class="fc" id="L119">        verify(w).onNext(4L);</span>
<span class="fc" id="L120">        verify(w, never()).onError(any(Throwable.class));</span>
<span class="fc" id="L121">        verify(w, times(1)).onComplete();</span>
<span class="fc" id="L122">    }</span>

    @Test
    public void testCountZeroItemsObservable() {
<span class="fc" id="L126">        Observable&lt;String&gt; o = Observable.empty();</span>
<span class="fc" id="L127">        o.count().toObservable().subscribe(w);</span>
        // we should be called only once
<span class="fc" id="L129">        verify(w, times(1)).onNext(anyLong());</span>
<span class="fc" id="L130">        verify(w).onNext(0L);</span>
<span class="fc" id="L131">        verify(w, never()).onError(any(Throwable.class));</span>
<span class="fc" id="L132">        verify(w, times(1)).onComplete();</span>
<span class="fc" id="L133">    }</span>

    @Test
    public void testCountErrorObservable() {
<span class="fc" id="L137">        Observable&lt;String&gt; o = Observable.error(new Callable&lt;Throwable&gt;() {</span>
            @Override
            public Throwable call() {
<span class="fc" id="L140">                return new RuntimeException();</span>
            }
        });

<span class="fc" id="L144">        o.count().toObservable().subscribe(w);</span>
<span class="fc" id="L145">        verify(w, never()).onNext(anyInt());</span>
<span class="fc" id="L146">        verify(w, never()).onComplete();</span>
<span class="fc" id="L147">        verify(w, times(1)).onError(any(RuntimeException.class));</span>
<span class="fc" id="L148">    }</span>

    @Test
    public void testCountAFewItems() {
<span class="fc" id="L152">        Observable&lt;String&gt; o = Observable.just(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;);</span>

<span class="fc" id="L154">        o.count().subscribe(wo);</span>

        // we should be called only once
<span class="fc" id="L157">        verify(wo, times(1)).onSuccess(anyLong());</span>
<span class="fc" id="L158">        verify(wo).onSuccess(4L);</span>
<span class="fc" id="L159">        verify(wo, never()).onError(any(Throwable.class));</span>
<span class="fc" id="L160">    }</span>

    @Test
    public void testCountZeroItems() {
<span class="fc" id="L164">        Observable&lt;String&gt; o = Observable.empty();</span>
<span class="fc" id="L165">        o.count().subscribe(wo);</span>
        // we should be called only once
<span class="fc" id="L167">        verify(wo, times(1)).onSuccess(anyLong());</span>
<span class="fc" id="L168">        verify(wo).onSuccess(0L);</span>
<span class="fc" id="L169">        verify(wo, never()).onError(any(Throwable.class));</span>
<span class="fc" id="L170">    }</span>

    @Test
    public void testCountError() {
<span class="fc" id="L174">        Observable&lt;String&gt; o = Observable.error(new Callable&lt;Throwable&gt;() {</span>
            @Override
            public Throwable call() {
<span class="fc" id="L177">                return new RuntimeException();</span>
            }
        });

<span class="fc" id="L181">        o.count().subscribe(wo);</span>
<span class="fc" id="L182">        verify(wo, never()).onSuccess(anyInt());</span>
<span class="fc" id="L183">        verify(wo, times(1)).onError(any(RuntimeException.class));</span>
<span class="fc" id="L184">    }</span>

    @Test
    public void testTakeFirstWithPredicateOfSome() {
<span class="fc" id="L188">        Observable&lt;Integer&gt; o = Observable.just(1, 3, 5, 4, 6, 3);</span>
<span class="fc" id="L189">        o.filter(IS_EVEN).take(1).subscribe(w);</span>
<span class="fc" id="L190">        verify(w, times(1)).onNext(anyInt());</span>
<span class="fc" id="L191">        verify(w).onNext(4);</span>
<span class="fc" id="L192">        verify(w, times(1)).onComplete();</span>
<span class="fc" id="L193">        verify(w, never()).onError(any(Throwable.class));</span>
<span class="fc" id="L194">    }</span>

    @Test
    public void testTakeFirstWithPredicateOfNoneMatchingThePredicate() {
<span class="fc" id="L198">        Observable&lt;Integer&gt; o = Observable.just(1, 3, 5, 7, 9, 7, 5, 3, 1);</span>
<span class="fc" id="L199">        o.filter(IS_EVEN).take(1).subscribe(w);</span>
<span class="fc" id="L200">        verify(w, never()).onNext(anyInt());</span>
<span class="fc" id="L201">        verify(w, times(1)).onComplete();</span>
<span class="fc" id="L202">        verify(w, never()).onError(any(Throwable.class));</span>
<span class="fc" id="L203">    }</span>

    @Test
    public void testTakeFirstOfSome() {
<span class="fc" id="L207">        Observable&lt;Integer&gt; o = Observable.just(1, 2, 3);</span>
<span class="fc" id="L208">        o.take(1).subscribe(w);</span>
<span class="fc" id="L209">        verify(w, times(1)).onNext(anyInt());</span>
<span class="fc" id="L210">        verify(w).onNext(1);</span>
<span class="fc" id="L211">        verify(w, times(1)).onComplete();</span>
<span class="fc" id="L212">        verify(w, never()).onError(any(Throwable.class));</span>
<span class="fc" id="L213">    }</span>

    @Test
    public void testTakeFirstOfNone() {
<span class="fc" id="L217">        Observable&lt;Integer&gt; o = Observable.empty();</span>
<span class="fc" id="L218">        o.take(1).subscribe(w);</span>
<span class="fc" id="L219">        verify(w, never()).onNext(anyInt());</span>
<span class="fc" id="L220">        verify(w, times(1)).onComplete();</span>
<span class="fc" id="L221">        verify(w, never()).onError(any(Throwable.class));</span>
<span class="fc" id="L222">    }</span>

    @Test
    public void testFirstOfNone() {
<span class="fc" id="L226">        Observable&lt;Integer&gt; o = Observable.empty();</span>
<span class="fc" id="L227">        o.firstElement().subscribe(wm);</span>
<span class="fc" id="L228">        verify(wm, never()).onSuccess(anyInt());</span>
<span class="fc" id="L229">        verify(wm).onComplete();</span>
<span class="fc" id="L230">        verify(wm, never()).onError(any(Throwable.class));</span>
<span class="fc" id="L231">    }</span>

    @Test
    public void testFirstWithPredicateOfNoneMatchingThePredicate() {
<span class="fc" id="L235">        Observable&lt;Integer&gt; o = Observable.just(1, 3, 5, 7, 9, 7, 5, 3, 1);</span>
<span class="fc" id="L236">        o.filter(IS_EVEN).firstElement().subscribe(wm);</span>
<span class="fc" id="L237">        verify(wm, never()).onSuccess(anyInt());</span>
<span class="fc" id="L238">        verify(wm).onComplete();</span>
<span class="fc" id="L239">        verify(wm, never()).onError(any(Throwable.class));</span>
<span class="fc" id="L240">    }</span>

    @Test
    public void testReduce() {
<span class="fc" id="L244">        Observable&lt;Integer&gt; o = Observable.just(1, 2, 3, 4);</span>
<span class="fc" id="L245">        o.reduce(new BiFunction&lt;Integer, Integer, Integer&gt;() {</span>
            @Override
            public Integer apply(Integer t1, Integer t2) {
<span class="fc" id="L248">                return t1 + t2;</span>
            }
        })
<span class="fc" id="L251">        .subscribe(wm);</span>
        // we should be called only once
<span class="fc" id="L253">        verify(wm, times(1)).onSuccess(anyInt());</span>
<span class="fc" id="L254">        verify(wm).onSuccess(10);</span>
<span class="fc" id="L255">        verify(wm, never()).onError(any(Throwable.class));</span>
<span class="fc" id="L256">        verify(wm, never()).onComplete();</span>
<span class="fc" id="L257">    }</span>

    @Test
    public void testReduceObservable() {
<span class="fc" id="L261">        Observable&lt;Integer&gt; o = Observable.just(1, 2, 3, 4);</span>
<span class="fc" id="L262">        o.reduce(new BiFunction&lt;Integer, Integer, Integer&gt;() {</span>
            @Override
            public Integer apply(Integer t1, Integer t2) {
<span class="fc" id="L265">                return t1 + t2;</span>
            }
        })
<span class="fc" id="L268">        .toObservable()</span>
<span class="fc" id="L269">        .subscribe(w);</span>
        // we should be called only once
<span class="fc" id="L271">        verify(w, times(1)).onNext(anyInt());</span>
<span class="fc" id="L272">        verify(w).onNext(10);</span>
<span class="fc" id="L273">        verify(w, never()).onError(any(Throwable.class));</span>
<span class="fc" id="L274">        verify(w).onComplete();</span>
<span class="fc" id="L275">    }</span>

    @Test
    public void testReduceWithEmptyObservable() {
<span class="fc" id="L279">        Observable&lt;Integer&gt; o = Observable.range(1, 0);</span>
<span class="fc" id="L280">        o.reduce(new BiFunction&lt;Integer, Integer, Integer&gt;() {</span>
            @Override
            public Integer apply(Integer t1, Integer t2) {
<span class="nc" id="L283">                return t1 + t2;</span>
            }
        })
<span class="fc" id="L286">        .toObservable()</span>
<span class="fc" id="L287">        .test()</span>
<span class="fc" id="L288">        .assertResult();</span>
<span class="fc" id="L289">    }</span>

    /**
     * A reduce on an empty Observable and a seed should just pass the seed through.
     *
     * This is confirmed at https://github.com/ReactiveX/RxJava/issues/423#issuecomment-27642456
     */
    @Test
    public void testReduceWithEmptyObservableAndSeed() {
<span class="fc" id="L298">        Observable&lt;Integer&gt; o = Observable.range(1, 0);</span>
<span class="fc" id="L299">        int value = o.reduce(1, new BiFunction&lt;Integer, Integer, Integer&gt;() {</span>
            @Override
            public Integer apply(Integer t1, Integer t2) {
<span class="nc" id="L302">                return t1 + t2;</span>
            }
        })
<span class="fc" id="L305">        .blockingGet();</span>

<span class="fc" id="L307">        assertEquals(1, value);</span>
<span class="fc" id="L308">    }</span>

    @Test
    public void testReduceWithInitialValue() {
<span class="fc" id="L312">        Observable&lt;Integer&gt; o = Observable.just(1, 2, 3, 4);</span>
<span class="fc" id="L313">        o.reduce(50, new BiFunction&lt;Integer, Integer, Integer&gt;() {</span>
            @Override
            public Integer apply(Integer t1, Integer t2) {
<span class="fc" id="L316">                return t1 + t2;</span>
            }
        })
<span class="fc" id="L319">        .subscribe(wo);</span>
        // we should be called only once
<span class="fc" id="L321">        verify(wo, times(1)).onSuccess(anyInt());</span>
<span class="fc" id="L322">        verify(wo).onSuccess(60);</span>
<span class="fc" id="L323">        verify(wo, never()).onError(any(Throwable.class));</span>
<span class="fc" id="L324">    }</span>

    @Test
    public void testReduceWithInitialValueObservable() {
<span class="fc" id="L328">        Observable&lt;Integer&gt; o = Observable.just(1, 2, 3, 4);</span>
<span class="fc" id="L329">        o.reduce(50, new BiFunction&lt;Integer, Integer, Integer&gt;() {</span>
            @Override
            public Integer apply(Integer t1, Integer t2) {
<span class="fc" id="L332">                return t1 + t2;</span>
            }
        })
<span class="fc" id="L335">        .toObservable()</span>
<span class="fc" id="L336">        .subscribe(w);</span>
        // we should be called only once
<span class="fc" id="L338">        verify(w, times(1)).onNext(anyInt());</span>
<span class="fc" id="L339">        verify(w).onNext(60);</span>
<span class="fc" id="L340">    }</span>

    @Ignore(&quot;Throwing is not allowed from the unsafeCreate?!&quot;)
    @Test // FIXME throwing is not allowed from the create?!
    public void testOnSubscribeFails() {
<span class="nc" id="L345">        Observer&lt;String&gt; observer = TestHelper.mockObserver();</span>

<span class="nc" id="L347">        final RuntimeException re = new RuntimeException(&quot;bad impl&quot;);</span>
<span class="nc" id="L348">        Observable&lt;String&gt; o = Observable.unsafeCreate(new ObservableSource&lt;String&gt;() {</span>
            @Override
<span class="nc" id="L350">            public void subscribe(Observer&lt;? super String&gt; observer) { throw re; }</span>
        });

<span class="nc" id="L353">        o.subscribe(observer);</span>
<span class="nc" id="L354">        verify(observer, times(0)).onNext(anyString());</span>
<span class="nc" id="L355">        verify(observer, times(0)).onComplete();</span>
<span class="nc" id="L356">        verify(observer, times(1)).onError(re);</span>
<span class="nc" id="L357">    }</span>

    @Test
    public void testMaterializeDematerializeChaining() {
<span class="fc" id="L361">        Observable&lt;Integer&gt; obs = Observable.just(1);</span>
<span class="fc" id="L362">        Observable&lt;Integer&gt; chained = obs.materialize()</span>
<span class="fc" id="L363">                .dematerialize(Functions.&lt;Notification&lt;Integer&gt;&gt;identity());</span>

<span class="fc" id="L365">        Observer&lt;Integer&gt; observer = TestHelper.mockObserver();</span>

<span class="fc" id="L367">        chained.subscribe(observer);</span>

<span class="fc" id="L369">        verify(observer, times(1)).onNext(1);</span>
<span class="fc" id="L370">        verify(observer, times(1)).onComplete();</span>
<span class="fc" id="L371">        verify(observer, times(0)).onError(any(Throwable.class));</span>
<span class="fc" id="L372">    }</span>

    /**
     * The error from the user provided Observer is not handled by the subscribe method try/catch.
     *
     * It is handled by the AtomicObserver that wraps the provided Observer.
     *
     * Result: Passes (if AtomicObserver functionality exists)
     * @throws InterruptedException if the test is interrupted
     */
    @Test
    public void testCustomObservableWithErrorInObserverAsynchronous() throws InterruptedException {
<span class="fc" id="L384">        final CountDownLatch latch = new CountDownLatch(1);</span>
<span class="fc" id="L385">        final AtomicInteger count = new AtomicInteger();</span>
<span class="fc" id="L386">        final AtomicReference&lt;Throwable&gt; error = new AtomicReference&lt;Throwable&gt;();</span>

        // FIXME custom built???
<span class="fc" id="L389">        Observable.just(&quot;1&quot;, &quot;2&quot;, &quot;three&quot;, &quot;4&quot;)</span>
<span class="fc" id="L390">        .subscribeOn(Schedulers.newThread())</span>
<span class="fc" id="L391">        .safeSubscribe(new DefaultObserver&lt;String&gt;() {</span>
            @Override
            public void onComplete() {
<span class="nc" id="L394">                System.out.println(&quot;completed&quot;);</span>
<span class="nc" id="L395">                latch.countDown();</span>
<span class="nc" id="L396">            }</span>

            @Override
            public void onError(Throwable e) {
<span class="fc" id="L400">                error.set(e);</span>
<span class="fc" id="L401">                System.out.println(&quot;error&quot;);</span>
<span class="fc" id="L402">                e.printStackTrace();</span>
<span class="fc" id="L403">                latch.countDown();</span>
<span class="fc" id="L404">            }</span>

            @Override
            public void onNext(String v) {
<span class="fc" id="L408">                int num = Integer.parseInt(v);</span>
<span class="fc" id="L409">                System.out.println(num);</span>
                // doSomething(num);
<span class="fc" id="L411">                count.incrementAndGet();</span>
<span class="fc" id="L412">            }</span>

        });

        // wait for async sequence to complete
<span class="fc" id="L417">        latch.await();</span>

<span class="fc" id="L419">        assertEquals(2, count.get());</span>
<span class="fc" id="L420">        assertNotNull(error.get());</span>
<span class="pc bpc" id="L421" title="1 of 2 branches missed.">        if (!(error.get() instanceof NumberFormatException)) {</span>
<span class="nc" id="L422">            fail(&quot;It should be a NumberFormatException&quot;);</span>
        }
<span class="fc" id="L424">    }</span>

    /**
     * The error from the user provided Observer is handled by the subscribe try/catch because this is synchronous.
     *
     * Result: Passes
     */
    @Test
    public void testCustomObservableWithErrorInObserverSynchronous() {
<span class="fc" id="L433">        final AtomicInteger count = new AtomicInteger();</span>
<span class="fc" id="L434">        final AtomicReference&lt;Throwable&gt; error = new AtomicReference&lt;Throwable&gt;();</span>

        // FIXME custom built???
<span class="fc" id="L437">        Observable.just(&quot;1&quot;, &quot;2&quot;, &quot;three&quot;, &quot;4&quot;)</span>
<span class="fc" id="L438">        .safeSubscribe(new DefaultObserver&lt;String&gt;() {</span>

            @Override
            public void onComplete() {
<span class="nc" id="L442">                System.out.println(&quot;completed&quot;);</span>
<span class="nc" id="L443">            }</span>

            @Override
            public void onError(Throwable e) {
<span class="fc" id="L447">                error.set(e);</span>
<span class="fc" id="L448">                System.out.println(&quot;error&quot;);</span>
<span class="fc" id="L449">                e.printStackTrace();</span>
<span class="fc" id="L450">            }</span>

            @Override
            public void onNext(String v) {
<span class="fc" id="L454">                int num = Integer.parseInt(v);</span>
<span class="fc" id="L455">                System.out.println(num);</span>
                // doSomething(num);
<span class="fc" id="L457">                count.incrementAndGet();</span>
<span class="fc" id="L458">            }</span>

        });
<span class="fc" id="L461">        assertEquals(2, count.get());</span>
<span class="fc" id="L462">        assertNotNull(error.get());</span>
<span class="pc bpc" id="L463" title="1 of 2 branches missed.">        if (!(error.get() instanceof NumberFormatException)) {</span>
<span class="nc" id="L464">            fail(&quot;It should be a NumberFormatException&quot;);</span>
        }
<span class="fc" id="L466">    }</span>

    /**
     * The error from the user provided Observable is handled by the subscribe try/catch because this is synchronous.
     *
     *
     * Result: Passes
     */
    @Test
    public void testCustomObservableWithErrorInObservableSynchronous() {
<span class="fc" id="L476">        final AtomicInteger count = new AtomicInteger();</span>
<span class="fc" id="L477">        final AtomicReference&lt;Throwable&gt; error = new AtomicReference&lt;Throwable&gt;();</span>
        // FIXME custom built???
<span class="fc" id="L479">        Observable.just(&quot;1&quot;, &quot;2&quot;).concatWith(Observable.&lt;String&gt;error(new Callable&lt;Throwable&gt;() {</span>
            @Override
            public Throwable call() {
<span class="fc" id="L482">                return new NumberFormatException();</span>
            }
        }))
<span class="fc" id="L485">        .subscribe(new DefaultObserver&lt;String&gt;() {</span>

            @Override
            public void onComplete() {
<span class="nc" id="L489">                System.out.println(&quot;completed&quot;);</span>
<span class="nc" id="L490">            }</span>

            @Override
            public void onError(Throwable e) {
<span class="fc" id="L494">                error.set(e);</span>
<span class="fc" id="L495">                System.out.println(&quot;error&quot;);</span>
<span class="fc" id="L496">                e.printStackTrace();</span>
<span class="fc" id="L497">            }</span>

            @Override
            public void onNext(String v) {
<span class="fc" id="L501">                System.out.println(v);</span>
<span class="fc" id="L502">                count.incrementAndGet();</span>
<span class="fc" id="L503">            }</span>

        });
<span class="fc" id="L506">        assertEquals(2, count.get());</span>
<span class="fc" id="L507">        assertNotNull(error.get());</span>
<span class="pc bpc" id="L508" title="1 of 2 branches missed.">        if (!(error.get() instanceof NumberFormatException)) {</span>
<span class="nc" id="L509">            fail(&quot;It should be a NumberFormatException&quot;);</span>
        }
<span class="fc" id="L511">    }</span>

    @Test
    public void testPublishLast() throws InterruptedException {
<span class="fc" id="L515">        final AtomicInteger count = new AtomicInteger();</span>
<span class="fc" id="L516">        ConnectableObservable&lt;String&gt; connectable = Observable.&lt;String&gt;unsafeCreate(new ObservableSource&lt;String&gt;() {</span>
            @Override
            public void subscribe(final Observer&lt;? super String&gt; observer) {
<span class="fc" id="L519">                observer.onSubscribe(Disposables.empty());</span>
<span class="fc" id="L520">                count.incrementAndGet();</span>
<span class="fc" id="L521">                new Thread(new Runnable() {</span>
                    @Override
                    public void run() {
<span class="fc" id="L524">                        observer.onNext(&quot;first&quot;);</span>
<span class="fc" id="L525">                        observer.onNext(&quot;last&quot;);</span>
<span class="fc" id="L526">                        observer.onComplete();</span>
<span class="fc" id="L527">                    }</span>
<span class="fc" id="L528">                }).start();</span>
<span class="fc" id="L529">            }</span>
<span class="fc" id="L530">        }).takeLast(1).publish();</span>

        // subscribe once
<span class="fc" id="L533">        final CountDownLatch latch = new CountDownLatch(1);</span>
<span class="fc" id="L534">        connectable.subscribe(new Consumer&lt;String&gt;() {</span>
            @Override
            public void accept(String value) {
<span class="fc" id="L537">                assertEquals(&quot;last&quot;, value);</span>
<span class="fc" id="L538">                latch.countDown();</span>
<span class="fc" id="L539">            }</span>
        });

        // subscribe twice
<span class="fc" id="L543">        connectable.subscribe();</span>

<span class="fc" id="L545">        Disposable subscription = connectable.connect();</span>
<span class="fc" id="L546">        assertTrue(latch.await(1000, TimeUnit.MILLISECONDS));</span>
<span class="fc" id="L547">        assertEquals(1, count.get());</span>
<span class="fc" id="L548">        subscription.dispose();</span>
<span class="fc" id="L549">    }</span>

    @Test
    public void testReplay() throws InterruptedException {
<span class="fc" id="L553">        final AtomicInteger counter = new AtomicInteger();</span>
<span class="fc" id="L554">        ConnectableObservable&lt;String&gt; o = Observable.&lt;String&gt;unsafeCreate(new ObservableSource&lt;String&gt;() {</span>
            @Override
            public void subscribe(final Observer&lt;? super String&gt; observer) {
<span class="fc" id="L557">                    observer.onSubscribe(Disposables.empty());</span>
<span class="fc" id="L558">                    new Thread(new Runnable() {</span>

                        @Override
                        public void run() {
<span class="fc" id="L562">                            counter.incrementAndGet();</span>
<span class="fc" id="L563">                            observer.onNext(&quot;one&quot;);</span>
<span class="fc" id="L564">                            observer.onComplete();</span>
<span class="fc" id="L565">                        }</span>
<span class="fc" id="L566">                    }).start();</span>
<span class="fc" id="L567">            }</span>
<span class="fc" id="L568">        }).replay();</span>

        // we connect immediately and it will emit the value
<span class="fc" id="L571">        Disposable connection = o.connect();</span>
        try {

            // we then expect the following 2 subscriptions to get that same value
<span class="fc" id="L575">            final CountDownLatch latch = new CountDownLatch(2);</span>

            // subscribe once
<span class="fc" id="L578">            o.subscribe(new Consumer&lt;String&gt;() {</span>
                @Override
                public void accept(String v) {
<span class="fc" id="L581">                    assertEquals(&quot;one&quot;, v);</span>
<span class="fc" id="L582">                    latch.countDown();</span>
<span class="fc" id="L583">                }</span>
            });

            // subscribe again
<span class="fc" id="L587">            o.subscribe(new Consumer&lt;String&gt;() {</span>
                @Override
                public void accept(String v) {
<span class="fc" id="L590">                    assertEquals(&quot;one&quot;, v);</span>
<span class="fc" id="L591">                    latch.countDown();</span>
<span class="fc" id="L592">                }</span>
            });

<span class="pc bpc" id="L595" title="1 of 2 branches missed.">            if (!latch.await(1000, TimeUnit.MILLISECONDS)) {</span>
<span class="nc" id="L596">                fail(&quot;subscriptions did not receive values&quot;);</span>
            }
<span class="fc" id="L598">            assertEquals(1, counter.get());</span>
        } finally {
<span class="fc" id="L600">            connection.dispose();</span>
        }
<span class="fc" id="L602">    }</span>

    @Test
    public void testCache() throws InterruptedException {
<span class="fc" id="L606">        final AtomicInteger counter = new AtomicInteger();</span>
<span class="fc" id="L607">        Observable&lt;String&gt; o = Observable.&lt;String&gt;unsafeCreate(new ObservableSource&lt;String&gt;() {</span>
            @Override
            public void subscribe(final Observer&lt;? super String&gt; observer) {
<span class="fc" id="L610">                    observer.onSubscribe(Disposables.empty());</span>
<span class="fc" id="L611">                    new Thread(new Runnable() {</span>
                        @Override
                        public void run() {
<span class="fc" id="L614">                            counter.incrementAndGet();</span>
<span class="fc" id="L615">                            observer.onNext(&quot;one&quot;);</span>
<span class="fc" id="L616">                            observer.onComplete();</span>
<span class="fc" id="L617">                        }</span>
<span class="fc" id="L618">                    }).start();</span>
<span class="fc" id="L619">            }</span>
<span class="fc" id="L620">        }).cache();</span>

        // we then expect the following 2 subscriptions to get that same value
<span class="fc" id="L623">        final CountDownLatch latch = new CountDownLatch(2);</span>

        // subscribe once
<span class="fc" id="L626">        o.subscribe(new Consumer&lt;String&gt;() {</span>
            @Override
            public void accept(String v) {
<span class="fc" id="L629">                assertEquals(&quot;one&quot;, v);</span>
<span class="fc" id="L630">                latch.countDown();</span>
<span class="fc" id="L631">            }</span>
        });

        // subscribe again
<span class="fc" id="L635">        o.subscribe(new Consumer&lt;String&gt;() {</span>
            @Override
            public void accept(String v) {
<span class="fc" id="L638">                assertEquals(&quot;one&quot;, v);</span>
<span class="fc" id="L639">                latch.countDown();</span>
<span class="fc" id="L640">            }</span>
        });

<span class="pc bpc" id="L643" title="1 of 2 branches missed.">        if (!latch.await(1000, TimeUnit.MILLISECONDS)) {</span>
<span class="nc" id="L644">            fail(&quot;subscriptions did not receive values&quot;);</span>
        }
<span class="fc" id="L646">        assertEquals(1, counter.get());</span>
<span class="fc" id="L647">    }</span>

    @Test
    public void testCacheWithCapacity() throws InterruptedException {
<span class="fc" id="L651">        final AtomicInteger counter = new AtomicInteger();</span>
<span class="fc" id="L652">        Observable&lt;String&gt; o = Observable.&lt;String&gt;unsafeCreate(new ObservableSource&lt;String&gt;() {</span>
            @Override
            public void subscribe(final Observer&lt;? super String&gt; observer) {
<span class="fc" id="L655">                observer.onSubscribe(Disposables.empty());</span>
<span class="fc" id="L656">                new Thread(new Runnable() {</span>
                    @Override
                    public void run() {
<span class="fc" id="L659">                        counter.incrementAndGet();</span>
<span class="fc" id="L660">                        observer.onNext(&quot;one&quot;);</span>
<span class="fc" id="L661">                        observer.onComplete();</span>
<span class="fc" id="L662">                    }</span>
<span class="fc" id="L663">                }).start();</span>
<span class="fc" id="L664">            }</span>
<span class="fc" id="L665">        }).cacheWithInitialCapacity(1);</span>

        // we then expect the following 2 subscriptions to get that same value
<span class="fc" id="L668">        final CountDownLatch latch = new CountDownLatch(2);</span>

        // subscribe once
<span class="fc" id="L671">        o.subscribe(new Consumer&lt;String&gt;() {</span>
            @Override
            public void accept(String v) {
<span class="fc" id="L674">                assertEquals(&quot;one&quot;, v);</span>
<span class="fc" id="L675">                latch.countDown();</span>
<span class="fc" id="L676">            }</span>
        });

        // subscribe again
<span class="fc" id="L680">        o.subscribe(new Consumer&lt;String&gt;() {</span>
            @Override
            public void accept(String v) {
<span class="fc" id="L683">                assertEquals(&quot;one&quot;, v);</span>
<span class="fc" id="L684">                latch.countDown();</span>
<span class="fc" id="L685">            }</span>
        });

<span class="pc bpc" id="L688" title="1 of 2 branches missed.">        if (!latch.await(1000, TimeUnit.MILLISECONDS)) {</span>
<span class="nc" id="L689">            fail(&quot;subscriptions did not receive values&quot;);</span>
        }
<span class="fc" id="L691">        assertEquals(1, counter.get());</span>
<span class="fc" id="L692">    }</span>

    /**
     * https://github.com/ReactiveX/RxJava/issues/198
     *
     * Rx Design Guidelines 5.2
     *
     * &quot;when calling the Subscribe method that only has an onNext argument, the OnError behavior will be
     * to rethrow the exception on the thread that the message comes out from the Observable.
     * The OnCompleted behavior in this case is to do nothing.&quot;
     */
    @Test
    @Ignore(&quot;Subscribers can't throw&quot;)
    public void testErrorThrownWithoutErrorHandlerSynchronous() {
        try {
<span class="nc" id="L707">            Observable.error(new RuntimeException(&quot;failure&quot;))</span>
<span class="nc" id="L708">            .subscribe();</span>
<span class="nc" id="L709">            fail(&quot;expected exception&quot;);</span>
<span class="nc" id="L710">        } catch (Throwable e) {</span>
<span class="nc" id="L711">            assertEquals(&quot;failure&quot;, e.getMessage());</span>
<span class="nc" id="L712">        }</span>
<span class="nc" id="L713">    }</span>

    /**
     * https://github.com/ReactiveX/RxJava/issues/198
     *
     * Rx Design Guidelines 5.2
     *
     * &quot;when calling the Subscribe method that only has an onNext argument, the OnError behavior will be
     * to rethrow the exception on the thread that the message comes out from the Observable.
     * The OnCompleted behavior in this case is to do nothing.&quot;
     *
     * @throws InterruptedException if the await is interrupted
     */
    @Test
    @Ignore(&quot;Subscribers can't throw&quot;)
    public void testErrorThrownWithoutErrorHandlerAsynchronous() throws InterruptedException {
<span class="nc" id="L729">        final CountDownLatch latch = new CountDownLatch(1);</span>
<span class="nc" id="L730">        final AtomicReference&lt;Throwable&gt; exception = new AtomicReference&lt;Throwable&gt;();</span>
<span class="nc" id="L731">        Observable.unsafeCreate(new ObservableSource&lt;Object&gt;() {</span>
            @Override
            public void subscribe(final Observer&lt;? super Object&gt; observer) {
<span class="nc" id="L734">                new Thread(new Runnable() {</span>
                    @Override
                    public void run() {
                        try {
<span class="nc" id="L738">                            observer.onError(new Error(&quot;failure&quot;));</span>
<span class="nc" id="L739">                        } catch (Throwable e) {</span>
                            // without an onError handler it has to just throw on whatever thread invokes it
<span class="nc" id="L741">                            exception.set(e);</span>
<span class="nc" id="L742">                        }</span>
<span class="nc" id="L743">                        latch.countDown();</span>
<span class="nc" id="L744">                    }</span>
<span class="nc" id="L745">                }).start();</span>
<span class="nc" id="L746">            }</span>
<span class="nc" id="L747">        }).subscribe();</span>
        // wait for exception
<span class="nc" id="L749">        latch.await(3000, TimeUnit.MILLISECONDS);</span>
<span class="nc" id="L750">        assertNotNull(exception.get());</span>
<span class="nc" id="L751">        assertEquals(&quot;failure&quot;, exception.get().getMessage());</span>
<span class="nc" id="L752">    }</span>

    @Test
    public void testTakeWithErrorInObserver() {
<span class="fc" id="L756">        final AtomicInteger count = new AtomicInteger();</span>
<span class="fc" id="L757">        final AtomicReference&lt;Throwable&gt; error = new AtomicReference&lt;Throwable&gt;();</span>
<span class="fc" id="L758">        Observable.just(&quot;1&quot;, &quot;2&quot;, &quot;three&quot;, &quot;4&quot;).take(3)</span>
<span class="fc" id="L759">        .safeSubscribe(new DefaultObserver&lt;String&gt;() {</span>

            @Override
            public void onComplete() {
<span class="nc" id="L763">                System.out.println(&quot;completed&quot;);</span>
<span class="nc" id="L764">            }</span>

            @Override
            public void onError(Throwable e) {
<span class="fc" id="L768">                error.set(e);</span>
<span class="fc" id="L769">                System.out.println(&quot;error&quot;);</span>
<span class="fc" id="L770">                e.printStackTrace();</span>
<span class="fc" id="L771">            }</span>

            @Override
            public void onNext(String v) {
<span class="fc" id="L775">                int num = Integer.parseInt(v);</span>
<span class="fc" id="L776">                System.out.println(num);</span>
                // doSomething(num);
<span class="fc" id="L778">                count.incrementAndGet();</span>
<span class="fc" id="L779">            }</span>

        });
<span class="fc" id="L782">        assertEquals(2, count.get());</span>
<span class="fc" id="L783">        assertNotNull(error.get());</span>
<span class="pc bpc" id="L784" title="1 of 2 branches missed.">        if (!(error.get() instanceof NumberFormatException)) {</span>
<span class="nc" id="L785">            fail(&quot;It should be a NumberFormatException&quot;);</span>
        }
<span class="fc" id="L787">    }</span>

    @Test
    public void testOfType() {
<span class="fc" id="L791">        Observable&lt;String&gt; o = Observable.just(1, &quot;abc&quot;, false, 2L).ofType(String.class);</span>

<span class="fc" id="L793">        Observer&lt;Object&gt; observer = TestHelper.mockObserver();</span>

<span class="fc" id="L795">        o.subscribe(observer);</span>

<span class="fc" id="L797">        verify(observer, never()).onNext(1);</span>
<span class="fc" id="L798">        verify(observer, times(1)).onNext(&quot;abc&quot;);</span>
<span class="fc" id="L799">        verify(observer, never()).onNext(false);</span>
<span class="fc" id="L800">        verify(observer, never()).onNext(2L);</span>
<span class="fc" id="L801">        verify(observer, never()).onError(</span>
<span class="fc" id="L802">                any(Throwable.class));</span>
<span class="fc" id="L803">        verify(observer, times(1)).onComplete();</span>
<span class="fc" id="L804">    }</span>

    @Test
    public void testOfTypeWithPolymorphism() {
<span class="fc" id="L808">        ArrayList&lt;Integer&gt; l1 = new ArrayList&lt;Integer&gt;();</span>
<span class="fc" id="L809">        l1.add(1);</span>
<span class="fc" id="L810">        LinkedList&lt;Integer&gt; l2 = new LinkedList&lt;Integer&gt;();</span>
<span class="fc" id="L811">        l2.add(2);</span>

        @SuppressWarnings(&quot;rawtypes&quot;)
<span class="fc" id="L814">        Observable&lt;List&gt; o = Observable.&lt;Object&gt; just(l1, l2, &quot;123&quot;).ofType(List.class);</span>

<span class="fc" id="L816">        Observer&lt;Object&gt; observer = TestHelper.mockObserver();</span>

<span class="fc" id="L818">        o.subscribe(observer);</span>

<span class="fc" id="L820">        verify(observer, times(1)).onNext(l1);</span>
<span class="fc" id="L821">        verify(observer, times(1)).onNext(l2);</span>
<span class="fc" id="L822">        verify(observer, never()).onNext(&quot;123&quot;);</span>
<span class="fc" id="L823">        verify(observer, never()).onError(</span>
<span class="fc" id="L824">                any(Throwable.class));</span>
<span class="fc" id="L825">        verify(observer, times(1)).onComplete();</span>
<span class="fc" id="L826">    }</span>

    @Test
    public void testContainsObservable() {
<span class="fc" id="L830">        Observable&lt;Boolean&gt; o = Observable.just(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;).contains(&quot;b&quot;).toObservable();</span>

<span class="fc" id="L832">        Observer&lt;Boolean&gt; observer = TestHelper.mockObserver();</span>

<span class="fc" id="L834">        o.subscribe(observer);</span>

<span class="fc" id="L836">        verify(observer, times(1)).onNext(true);</span>
<span class="fc" id="L837">        verify(observer, never()).onNext(false);</span>
<span class="fc" id="L838">        verify(observer, never()).onError(</span>
<span class="fc" id="L839">                any(Throwable.class));</span>
<span class="fc" id="L840">        verify(observer, times(1)).onComplete();</span>
<span class="fc" id="L841">    }</span>

    @Test
    public void testContainsWithInexistenceObservable() {
<span class="fc" id="L845">        Observable&lt;Boolean&gt; o = Observable.just(&quot;a&quot;, &quot;b&quot;).contains(&quot;c&quot;).toObservable();</span>

<span class="fc" id="L847">        Observer&lt;Object&gt; observer = TestHelper.mockObserver();</span>

<span class="fc" id="L849">        o.subscribe(observer);</span>

<span class="fc" id="L851">        verify(observer, times(1)).onNext(false);</span>
<span class="fc" id="L852">        verify(observer, never()).onNext(true);</span>
<span class="fc" id="L853">        verify(observer, never()).onError(</span>
<span class="fc" id="L854">                any(Throwable.class));</span>
<span class="fc" id="L855">        verify(observer, times(1)).onComplete();</span>
<span class="fc" id="L856">    }</span>

    @Test
    @Ignore(&quot;null values are not allowed&quot;)
    public void testContainsWithNullObservable() {
<span class="nc" id="L861">        Observable&lt;Boolean&gt; o = Observable.just(&quot;a&quot;, &quot;b&quot;, null).contains(null).toObservable();</span>

<span class="nc" id="L863">        Observer&lt;Object&gt; observer = TestHelper.mockObserver();</span>

<span class="nc" id="L865">        o.subscribe(observer);</span>

<span class="nc" id="L867">        verify(observer, times(1)).onNext(true);</span>
<span class="nc" id="L868">        verify(observer, never()).onNext(false);</span>
<span class="nc" id="L869">        verify(observer, never()).onError(</span>
<span class="nc" id="L870">                any(Throwable.class));</span>
<span class="nc" id="L871">        verify(observer, times(1)).onComplete();</span>
<span class="nc" id="L872">    }</span>

    @Test
    public void testContainsWithEmptyObservableObservable() {
<span class="fc" id="L876">        Observable&lt;Boolean&gt; o = Observable.&lt;String&gt; empty().contains(&quot;a&quot;).toObservable();</span>

<span class="fc" id="L878">        Observer&lt;Object&gt; observer = TestHelper.mockObserver();</span>

<span class="fc" id="L880">        o.subscribe(observer);</span>

<span class="fc" id="L882">        verify(observer, times(1)).onNext(false);</span>
<span class="fc" id="L883">        verify(observer, never()).onNext(true);</span>
<span class="fc" id="L884">        verify(observer, never()).onError(</span>
<span class="fc" id="L885">                any(Throwable.class));</span>
<span class="fc" id="L886">        verify(observer, times(1)).onComplete();</span>
<span class="fc" id="L887">    }</span>

    @Test
    public void testContains() {
<span class="fc" id="L891">        Single&lt;Boolean&gt; o = Observable.just(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;).contains(&quot;b&quot;); // FIXME nulls not allowed, changed to &quot;c&quot;</span>

<span class="fc" id="L893">        SingleObserver&lt;Boolean&gt; observer = TestHelper.mockSingleObserver();</span>

<span class="fc" id="L895">        o.subscribe(observer);</span>

<span class="fc" id="L897">        verify(observer, times(1)).onSuccess(true);</span>
<span class="fc" id="L898">        verify(observer, never()).onSuccess(false);</span>
<span class="fc" id="L899">        verify(observer, never()).onError(</span>
<span class="fc" id="L900">                any(Throwable.class));</span>
<span class="fc" id="L901">    }</span>

    @Test
    public void testContainsWithInexistence() {
<span class="fc" id="L905">        Single&lt;Boolean&gt; o = Observable.just(&quot;a&quot;, &quot;b&quot;).contains(&quot;c&quot;); // FIXME null values are not allowed, removed</span>

<span class="fc" id="L907">        SingleObserver&lt;Object&gt; observer = TestHelper.mockSingleObserver();</span>

<span class="fc" id="L909">        o.subscribe(observer);</span>

<span class="fc" id="L911">        verify(observer, times(1)).onSuccess(false);</span>
<span class="fc" id="L912">        verify(observer, never()).onSuccess(true);</span>
<span class="fc" id="L913">        verify(observer, never()).onError(</span>
<span class="fc" id="L914">                any(Throwable.class));</span>
<span class="fc" id="L915">    }</span>

    @Test
    @Ignore(&quot;null values are not allowed&quot;)
    public void testContainsWithNull() {
<span class="nc" id="L920">        Single&lt;Boolean&gt; o = Observable.just(&quot;a&quot;, &quot;b&quot;, null).contains(null);</span>

<span class="nc" id="L922">        SingleObserver&lt;Object&gt; observer = TestHelper.mockSingleObserver();</span>

<span class="nc" id="L924">        o.subscribe(observer);</span>

<span class="nc" id="L926">        verify(observer, times(1)).onSuccess(true);</span>
<span class="nc" id="L927">        verify(observer, never()).onSuccess(false);</span>
<span class="nc" id="L928">        verify(observer, never()).onError(</span>
<span class="nc" id="L929">                any(Throwable.class));</span>
<span class="nc" id="L930">    }</span>

    @Test
    public void testContainsWithEmptyObservable() {
<span class="fc" id="L934">        Single&lt;Boolean&gt; o = Observable.&lt;String&gt; empty().contains(&quot;a&quot;);</span>

<span class="fc" id="L936">        SingleObserver&lt;Object&gt; observer = TestHelper.mockSingleObserver();</span>

<span class="fc" id="L938">        o.subscribe(observer);</span>

<span class="fc" id="L940">        verify(observer, times(1)).onSuccess(false);</span>
<span class="fc" id="L941">        verify(observer, never()).onSuccess(true);</span>
<span class="fc" id="L942">        verify(observer, never()).onError(</span>
<span class="fc" id="L943">                any(Throwable.class));</span>
<span class="fc" id="L944">    }</span>

    @Test
    public void testIgnoreElements() {
<span class="fc" id="L948">        Completable o = Observable.just(1, 2, 3).ignoreElements();</span>

<span class="fc" id="L950">        CompletableObserver observer = TestHelper.mockCompletableObserver();</span>

<span class="fc" id="L952">        o.subscribe(observer);</span>

<span class="fc" id="L954">        verify(observer, never()).onError(any(Throwable.class));</span>
<span class="fc" id="L955">        verify(observer, times(1)).onComplete();</span>
<span class="fc" id="L956">    }</span>

    @Test
    public void testIgnoreElementsObservable() {
<span class="fc" id="L960">        Observable&lt;Integer&gt; o = Observable.just(1, 2, 3).ignoreElements().toObservable();</span>

<span class="fc" id="L962">        Observer&lt;Object&gt; observer = TestHelper.mockObserver();</span>

<span class="fc" id="L964">        o.subscribe(observer);</span>

<span class="fc" id="L966">        verify(observer, never()).onNext(any(Integer.class));</span>
<span class="fc" id="L967">        verify(observer, never()).onError(any(Throwable.class));</span>
<span class="fc" id="L968">        verify(observer, times(1)).onComplete();</span>
<span class="fc" id="L969">    }</span>

    @Test
    public void testJustWithScheduler() {
<span class="fc" id="L973">        TestScheduler scheduler = new TestScheduler();</span>
<span class="fc" id="L974">        Observable&lt;Integer&gt; o = Observable.fromArray(1, 2).subscribeOn(scheduler);</span>

<span class="fc" id="L976">        Observer&lt;Integer&gt; observer = TestHelper.mockObserver();</span>

<span class="fc" id="L978">        o.subscribe(observer);</span>

<span class="fc" id="L980">        scheduler.advanceTimeBy(1, TimeUnit.MILLISECONDS);</span>

<span class="fc" id="L982">        InOrder inOrder = inOrder(observer);</span>
<span class="fc" id="L983">        inOrder.verify(observer, times(1)).onNext(1);</span>
<span class="fc" id="L984">        inOrder.verify(observer, times(1)).onNext(2);</span>
<span class="fc" id="L985">        inOrder.verify(observer, times(1)).onComplete();</span>
<span class="fc" id="L986">        inOrder.verifyNoMoreInteractions();</span>
<span class="fc" id="L987">    }</span>

    @Test
    public void testStartWithWithScheduler() {
<span class="fc" id="L991">        TestScheduler scheduler = new TestScheduler();</span>
<span class="fc" id="L992">        Observable&lt;Integer&gt; o = Observable.just(3, 4).startWith(Arrays.asList(1, 2)).subscribeOn(scheduler);</span>

<span class="fc" id="L994">        Observer&lt;Integer&gt; observer = TestHelper.mockObserver();</span>

<span class="fc" id="L996">        o.subscribe(observer);</span>

<span class="fc" id="L998">        scheduler.advanceTimeBy(1, TimeUnit.MILLISECONDS);</span>

<span class="fc" id="L1000">        InOrder inOrder = inOrder(observer);</span>
<span class="fc" id="L1001">        inOrder.verify(observer, times(1)).onNext(1);</span>
<span class="fc" id="L1002">        inOrder.verify(observer, times(1)).onNext(2);</span>
<span class="fc" id="L1003">        inOrder.verify(observer, times(1)).onNext(3);</span>
<span class="fc" id="L1004">        inOrder.verify(observer, times(1)).onNext(4);</span>
<span class="fc" id="L1005">        inOrder.verify(observer, times(1)).onComplete();</span>
<span class="fc" id="L1006">        inOrder.verifyNoMoreInteractions();</span>
<span class="fc" id="L1007">    }</span>

    @Test
    public void testRangeWithScheduler() {
<span class="fc" id="L1011">        TestScheduler scheduler = new TestScheduler();</span>
<span class="fc" id="L1012">        Observable&lt;Integer&gt; o = Observable.range(3, 4).subscribeOn(scheduler);</span>

<span class="fc" id="L1014">        Observer&lt;Integer&gt; observer = TestHelper.mockObserver();</span>

<span class="fc" id="L1016">        o.subscribe(observer);</span>

<span class="fc" id="L1018">        scheduler.advanceTimeBy(1, TimeUnit.MILLISECONDS);</span>

<span class="fc" id="L1020">        InOrder inOrder = inOrder(observer);</span>
<span class="fc" id="L1021">        inOrder.verify(observer, times(1)).onNext(3);</span>
<span class="fc" id="L1022">        inOrder.verify(observer, times(1)).onNext(4);</span>
<span class="fc" id="L1023">        inOrder.verify(observer, times(1)).onNext(5);</span>
<span class="fc" id="L1024">        inOrder.verify(observer, times(1)).onNext(6);</span>
<span class="fc" id="L1025">        inOrder.verify(observer, times(1)).onComplete();</span>
<span class="fc" id="L1026">        inOrder.verifyNoMoreInteractions();</span>
<span class="fc" id="L1027">    }</span>

    @Test
    public void testMergeWith() {
<span class="fc" id="L1031">        TestObserver&lt;Integer&gt; to = new TestObserver&lt;Integer&gt;();</span>
<span class="fc" id="L1032">        Observable.just(1).mergeWith(Observable.just(2)).subscribe(to);</span>
<span class="fc" id="L1033">        to.assertValues(1, 2);</span>
<span class="fc" id="L1034">    }</span>

    @Test
    public void testConcatWith() {
<span class="fc" id="L1038">        TestObserver&lt;Integer&gt; to = new TestObserver&lt;Integer&gt;();</span>
<span class="fc" id="L1039">        Observable.just(1).concatWith(Observable.just(2)).subscribe(to);</span>
<span class="fc" id="L1040">        to.assertValues(1, 2);</span>
<span class="fc" id="L1041">    }</span>

    @Test
    public void testAmbWith() {
<span class="fc" id="L1045">        TestObserver&lt;Integer&gt; to = new TestObserver&lt;Integer&gt;();</span>
<span class="fc" id="L1046">        Observable.just(1).ambWith(Observable.just(2)).subscribe(to);</span>
<span class="fc" id="L1047">        to.assertValue(1);</span>
<span class="fc" id="L1048">    }</span>

    @Test
    public void testTakeWhileToList() {
<span class="fc" id="L1052">        final int expectedCount = 3;</span>
<span class="fc" id="L1053">        final AtomicInteger count = new AtomicInteger();</span>
<span class="fc bfc" id="L1054" title="All 2 branches covered.">        for (int i = 0; i &lt; expectedCount; i++) {</span>
<span class="fc" id="L1055">            Observable</span>
<span class="fc" id="L1056">                    .just(Boolean.TRUE, Boolean.FALSE)</span>
<span class="fc" id="L1057">                    .takeWhile(new Predicate&lt;Boolean&gt;() {</span>
                        @Override
                        public boolean test(Boolean v) {
<span class="fc" id="L1060">                            return v;</span>
                        }
                    })
<span class="fc" id="L1063">                    .toList()</span>
<span class="fc" id="L1064">                    .doOnSuccess(new Consumer&lt;List&lt;Boolean&gt;&gt;() {</span>
                        @Override
                        public void accept(List&lt;Boolean&gt; booleans) {
<span class="fc" id="L1067">                            count.incrementAndGet();</span>
<span class="fc" id="L1068">                        }</span>
                    })
<span class="fc" id="L1070">                    .subscribe();</span>
        }
<span class="fc" id="L1072">        assertEquals(expectedCount, count.get());</span>
<span class="fc" id="L1073">    }</span>

    @Test
    public void testCompose() {
<span class="fc" id="L1077">        TestObserver&lt;String&gt; to = new TestObserver&lt;String&gt;();</span>
<span class="fc" id="L1078">        Observable.just(1, 2, 3).compose(new ObservableTransformer&lt;Integer, String&gt;() {</span>
            @Override
            public Observable&lt;String&gt; apply(Observable&lt;Integer&gt; t1) {
<span class="fc" id="L1081">                return t1.map(new Function&lt;Integer, String&gt;() {</span>
                    @Override
                    public String apply(Integer v) {
<span class="fc" id="L1084">                        return String.valueOf(v);</span>
                    }
                });
            }
        })
<span class="fc" id="L1089">        .subscribe(to);</span>
<span class="fc" id="L1090">        to.assertTerminated();</span>
<span class="fc" id="L1091">        to.assertNoErrors();</span>
<span class="fc" id="L1092">        to.assertValues(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;);</span>
<span class="fc" id="L1093">    }</span>

    @Test
    public void testErrorThrownIssue1685() {
<span class="fc" id="L1097">        Subject&lt;Object&gt; subject = ReplaySubject.create();</span>

<span class="fc" id="L1099">        Observable.error(new RuntimeException(&quot;oops&quot;))</span>
<span class="fc" id="L1100">            .materialize()</span>
<span class="fc" id="L1101">            .delay(1, TimeUnit.SECONDS)</span>
<span class="fc" id="L1102">            .dematerialize(Functions.&lt;Notification&lt;Object&gt;&gt;identity())</span>
<span class="fc" id="L1103">            .subscribe(subject);</span>

<span class="fc" id="L1105">        subject.subscribe();</span>
<span class="fc" id="L1106">        subject.materialize().blockingFirst();</span>

<span class="fc" id="L1108">        System.out.println(&quot;Done&quot;);</span>
<span class="fc" id="L1109">    }</span>

    @Test
    public void testEmptyIdentity() {
<span class="fc" id="L1113">        assertEquals(Observable.empty(), Observable.empty());</span>
<span class="fc" id="L1114">    }</span>

    @Test
    public void testEmptyIsEmpty() {
<span class="fc" id="L1118">        Observable.&lt;Integer&gt;empty().subscribe(w);</span>

<span class="fc" id="L1120">        verify(w).onComplete();</span>
<span class="fc" id="L1121">        verify(w, never()).onNext(any(Integer.class));</span>
<span class="fc" id="L1122">        verify(w, never()).onError(any(Throwable.class));</span>
<span class="fc" id="L1123">    }</span>

// FIXME this test doesn't make sense
//    @Test // cf. https://github.com/ReactiveX/RxJava/issues/2599
//    public void testSubscribingSubscriberAsObserverMaintainsSubscriptionChain() {
//        TestObserver&lt;Object&gt; observer = new TestObserver&lt;T&gt;();
//        Subscription subscription = Observable.just(&quot;event&quot;).subscribe((Observer&lt;Object&gt;) observer);
//        subscription.unsubscribe();
//
//        subscriber.assertUnsubscribed();
//    }

// FIXME subscribers can't throw
//    @Test(expected=OnErrorNotImplementedException.class)
//    public void testForEachWithError() {
//        Observable.error(new Exception(&quot;boo&quot;))
//        //
//        .forEach(new Action1&lt;Object&gt;() {
//            @Override
//            public void call(Object t) {
//                //do nothing
//            }});
//    }

    @Test(expected = NullPointerException.class)
    public void testForEachWithNull() {
<span class="fc" id="L1149">        Observable.error(new Exception(&quot;boo&quot;))</span>
        //
<span class="nc" id="L1151">        .forEach(null);</span>
<span class="nc" id="L1152">    }</span>

    @Test
    public void testExtend() {
<span class="fc" id="L1156">        final TestObserver&lt;Object&gt; to = new TestObserver&lt;Object&gt;();</span>
<span class="fc" id="L1157">        final Object value = new Object();</span>
<span class="fc" id="L1158">        Object returned = Observable.just(value).to(new Function&lt;Observable&lt;Object&gt;, Object&gt;() {</span>
            @Override
            public Object apply(Observable&lt;Object&gt; onSubscribe) {
<span class="fc" id="L1161">                    onSubscribe.subscribe(to);</span>
<span class="fc" id="L1162">                    to.assertNoErrors();</span>
<span class="fc" id="L1163">                    to.assertComplete();</span>
<span class="fc" id="L1164">                    to.assertValue(value);</span>
<span class="fc" id="L1165">                    return to.values().get(0);</span>
                }
        });
<span class="fc" id="L1168">        assertSame(returned, value);</span>
<span class="fc" id="L1169">    }</span>

    @Test
    public void testAsExtend() {
<span class="fc" id="L1173">        final TestObserver&lt;Object&gt; to = new TestObserver&lt;Object&gt;();</span>
<span class="fc" id="L1174">        final Object value = new Object();</span>
<span class="fc" id="L1175">        Object returned = Observable.just(value).as(new ObservableConverter&lt;Object, Object&gt;() {</span>
            @Override
            public Object apply(Observable&lt;Object&gt; onSubscribe) {
<span class="fc" id="L1178">                onSubscribe.subscribe(to);</span>
<span class="fc" id="L1179">                to.assertNoErrors();</span>
<span class="fc" id="L1180">                to.assertComplete();</span>
<span class="fc" id="L1181">                to.assertValue(value);</span>
<span class="fc" id="L1182">                return to.values().get(0);</span>
            }
        });
<span class="fc" id="L1185">        assertSame(returned, value);</span>
<span class="fc" id="L1186">    }</span>

    @Test
    public void as() {
<span class="fc" id="L1190">        Observable.just(1).as(new ObservableConverter&lt;Integer, Flowable&lt;Integer&gt;&gt;() {</span>
            @Override
            public Flowable&lt;Integer&gt; apply(Observable&lt;Integer&gt; v) {
<span class="fc" id="L1193">                return v.toFlowable(BackpressureStrategy.MISSING);</span>
            }
        })
<span class="fc" id="L1196">        .test()</span>
<span class="fc" id="L1197">        .assertResult(1);</span>
<span class="fc" id="L1198">    }</span>

    @Test
    public void testFlatMap() {
<span class="fc" id="L1202">        List&lt;Integer&gt; list = Observable.range(1, 5).flatMap(new Function&lt;Integer, Observable&lt;Integer&gt;&gt;() {</span>
            @Override
            public Observable&lt;Integer&gt; apply(Integer v) {
<span class="fc" id="L1205">                return Observable.range(v, 2);</span>
            }
<span class="fc" id="L1207">        }).toList().blockingGet();</span>

<span class="fc" id="L1209">        Assert.assertEquals(Arrays.asList(1, 2, 2, 3, 3, 4, 4, 5, 5, 6), list);</span>
<span class="fc" id="L1210">    }</span>

    @Test
    public void singleDefault() {
<span class="fc" id="L1214">        Observable.just(1).single(100).test().assertResult(1);</span>

<span class="fc" id="L1216">        Observable.empty().single(100).test().assertResult(100);</span>
<span class="fc" id="L1217">    }</span>

    @Test
    public void singleDefaultObservable() {
<span class="fc" id="L1221">        Observable.just(1).single(100).toObservable().test().assertResult(1);</span>

<span class="fc" id="L1223">        Observable.empty().single(100).toObservable().test().assertResult(100);</span>
<span class="fc" id="L1224">    }</span>

    @Test
    public void zipIterableObject() {
        @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L1229">        final List&lt;Observable&lt;Integer&gt;&gt; observables = Arrays.asList(Observable.just(1, 2, 3), Observable.just(1, 2, 3));</span>
<span class="fc" id="L1230">        Observable.zip(observables, new Function&lt;Object[], Object&gt;() {</span>
            @Override
            public Object apply(Object[] o) throws Exception {
<span class="fc" id="L1233">                int sum = 0;</span>
<span class="fc bfc" id="L1234" title="All 2 branches covered.">                for (Object i : o) {</span>
<span class="fc" id="L1235">                    sum += (Integer) i;</span>
                }
<span class="fc" id="L1237">                return sum;</span>
            }
<span class="fc" id="L1239">        }).test().assertResult(2, 4, 6);</span>
<span class="fc" id="L1240">    }</span>

    @Test
    public void combineLatestObject() {
        @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L1245">        final List&lt;Observable&lt;Integer&gt;&gt; observables = Arrays.asList(Observable.just(1, 2, 3), Observable.just(1, 2, 3));</span>
<span class="fc" id="L1246">        Observable.combineLatest(observables, new Function&lt;Object[], Object&gt;() {</span>
            @Override
            public Object apply(final Object[] o) throws Exception {
<span class="fc" id="L1249">                int sum = 1;</span>
<span class="fc bfc" id="L1250" title="All 2 branches covered.">                for (Object i : o) {</span>
<span class="fc" id="L1251">                    sum *= (Integer) i;</span>
                }
<span class="fc" id="L1253">                return sum;</span>
            }
<span class="fc" id="L1255">        }).test().assertResult(3, 6, 9);</span>
<span class="fc" id="L1256">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>