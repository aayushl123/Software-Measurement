<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BaseTestConsumer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">RxJava_2_x$Unnamed.exec</a> &gt; <a href="index.source.html" class="el_package">io.reactivex.observers</a> &gt; <span class="el_source">BaseTestConsumer.java</span></div><h1>BaseTestConsumer.java</h1><pre class="source lang-java linenums">/**
 * Copyright (c) 2016-present, RxJava Contributors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is
 * distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
 * the License for the specific language governing permissions and limitations under the License.
 */

package io.reactivex.observers;

import java.util.*;
import java.util.concurrent.*;

import io.reactivex.Notification;
import io.reactivex.disposables.Disposable;
import io.reactivex.exceptions.CompositeException;
import io.reactivex.functions.Predicate;
import io.reactivex.internal.functions.*;
import io.reactivex.internal.util.*;

/**
 * Base class with shared infrastructure to support TestSubscriber and TestObserver.
 * @param &lt;T&gt; the value type consumed
 * @param &lt;U&gt; the subclass of this BaseTestConsumer
 */
public abstract class BaseTestConsumer&lt;T, U extends BaseTestConsumer&lt;T, U&gt;&gt; implements Disposable {
    /** The latch that indicates an onError or onComplete has been called. */
    protected final CountDownLatch done;
    /** The list of values received. */
    protected final List&lt;T&gt; values;
    /** The list of errors received. */
    protected final List&lt;Throwable&gt; errors;
    /** The number of completions. */
    protected long completions;
    /** The last thread seen by the observer. */
    protected Thread lastThread;

    protected boolean checkSubscriptionOnce;

    protected int initialFusionMode;

    protected int establishedFusionMode;

    /**
     * The optional tag associated with this test consumer.
     * @since 2.0.7
     */
    protected CharSequence tag;

    /**
     * Indicates that one of the awaitX method has timed out.
     * @since 2.0.7
     */
    protected boolean timeout;

<span class="fc" id="L61">    public BaseTestConsumer() {</span>
<span class="fc" id="L62">        this.values = new VolatileSizeArrayList&lt;T&gt;();</span>
<span class="fc" id="L63">        this.errors = new VolatileSizeArrayList&lt;Throwable&gt;();</span>
<span class="fc" id="L64">        this.done = new CountDownLatch(1);</span>
<span class="fc" id="L65">    }</span>

    /**
     * Returns the last thread which called the onXXX methods of this TestObserver/TestSubscriber.
     * @return the last thread which called the onXXX methods
     */
    public final Thread lastThread() {
<span class="fc" id="L72">        return lastThread;</span>
    }

    /**
     * Returns a shared list of received onNext values.
     * &lt;p&gt;
     * Note that accessing the items via certain methods of the {@link List}
     * interface while the upstream is still actively emitting
     * more items may result in a {@code ConcurrentModificationException}.
     * &lt;p&gt;
     * The {@link List#size()} method will return the number of items
     * already received by this TestObserver/TestSubscriber in a thread-safe
     * manner that can be read via {@link List#get(int)}) method
     * (index range of 0 to {@code List.size() - 1}).
     * &lt;p&gt;
     * A view of the returned List can be created via {@link List#subList(int, int)}
     * by using the bounds 0 (inclusive) to {@link List#size()} (exclusive) which,
     * when accessed in a read-only fashion, should be also thread-safe and not throw any
     * {@code ConcurrentModificationException}.
     * @return a list of received onNext values
     */
    public final List&lt;T&gt; values() {
<span class="fc" id="L94">        return values;</span>
    }

    /**
     * Returns a shared list of received onError exceptions.
     * &lt;p&gt;
     * Note that accessing the errors via certain methods of the {@link List}
     * interface while the upstream is still actively emitting
     * more items or errors may result in a {@code ConcurrentModificationException}.
     * &lt;p&gt;
     * The {@link List#size()} method will return the number of errors
     * already received by this TestObserver/TestSubscriber in a thread-safe
     * manner that can be read via {@link List#get(int)}) method
     * (index range of 0 to {@code List.size() - 1}).
     * &lt;p&gt;
     * A view of the returned List can be created via {@link List#subList(int, int)}
     * by using the bounds 0 (inclusive) to {@link List#size()} (exclusive) which,
     * when accessed in a read-only fashion, should be also thread-safe and not throw any
     * {@code ConcurrentModificationException}.
     * @return a list of received events onError exceptions
     */
    public final List&lt;Throwable&gt; errors() {
<span class="fc" id="L116">        return errors;</span>
    }

    /**
     * Returns the number of times onComplete was called.
     * @return the number of times onComplete was called
     */
    public final long completions() {
<span class="fc" id="L124">        return completions;</span>
    }

    /**
     * Returns true if TestObserver/TestSubscriber received any onError or onComplete events.
     * @return true if TestObserver/TestSubscriber received any onError or onComplete events
     */
    public final boolean isTerminated() {
<span class="fc bfc" id="L132" title="All 2 branches covered.">        return done.getCount() == 0;</span>
    }

    /**
     * Returns the number of onNext values received.
     * @return the number of onNext values received
     */
    public final int valueCount() {
<span class="fc" id="L140">        return values.size();</span>
    }

    /**
     * Returns the number of onError exceptions received.
     * @return the number of onError exceptions received
     */
    public final int errorCount() {
<span class="fc" id="L148">        return errors.size();</span>
    }

    /**
     * Fail with the given message and add the sequence of errors as suppressed ones.
     * &lt;p&gt;Note this is deliberately the only fail method. Most of the times an assertion
     * would fail but it is possible it was due to an exception somewhere. This construct
     * will capture those potential errors and report it along with the original failure.
     *
     * @param message the message to use
     * @return AssertionError the prepared AssertionError instance
     */
    protected final AssertionError fail(String message) {
<span class="fc" id="L161">        StringBuilder b = new StringBuilder(64 + message.length());</span>
<span class="fc" id="L162">        b.append(message);</span>

<span class="fc" id="L164">        b.append(&quot; (&quot;)</span>
<span class="fc" id="L165">        .append(&quot;latch = &quot;).append(done.getCount()).append(&quot;, &quot;)</span>
<span class="fc" id="L166">        .append(&quot;values = &quot;).append(values.size()).append(&quot;, &quot;)</span>
<span class="fc" id="L167">        .append(&quot;errors = &quot;).append(errors.size()).append(&quot;, &quot;)</span>
<span class="fc" id="L168">        .append(&quot;completions = &quot;).append(completions)</span>
        ;

<span class="fc bfc" id="L171" title="All 2 branches covered.">        if (timeout) {</span>
<span class="fc" id="L172">            b.append(&quot;, timeout!&quot;);</span>
        }

<span class="fc bfc" id="L175" title="All 2 branches covered.">        if (isDisposed()) {</span>
<span class="fc" id="L176">            b.append(&quot;, disposed!&quot;);</span>
        }

<span class="fc" id="L179">        CharSequence tag = this.tag;</span>
<span class="fc bfc" id="L180" title="All 2 branches covered.">        if (tag != null) {</span>
<span class="fc" id="L181">            b.append(&quot;, tag = &quot;)</span>
<span class="fc" id="L182">            .append(tag);</span>
        }

<span class="fc" id="L185">        b</span>
<span class="fc" id="L186">        .append(')')</span>
        ;

<span class="fc" id="L189">        AssertionError ae = new AssertionError(b.toString());</span>
<span class="fc bfc" id="L190" title="All 2 branches covered.">        if (!errors.isEmpty()) {</span>
<span class="fc bfc" id="L191" title="All 2 branches covered.">            if (errors.size() == 1) {</span>
<span class="fc" id="L192">                ae.initCause(errors.get(0));</span>
            } else {
<span class="fc" id="L194">                CompositeException ce = new CompositeException(errors);</span>
<span class="fc" id="L195">                ae.initCause(ce);</span>
            }
        }
<span class="fc" id="L198">        return ae;</span>
    }

    /**
     * Awaits until this TestObserver/TestSubscriber receives an onError or onComplete events.
     * @return this
     * @throws InterruptedException if the current thread is interrupted while waiting
     * @see #awaitTerminalEvent()
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public final U await() throws InterruptedException {
<span class="fc bfc" id="L209" title="All 2 branches covered.">        if (done.getCount() == 0) {</span>
<span class="fc" id="L210">            return (U)this;</span>
        }

<span class="fc" id="L213">        done.await();</span>
<span class="fc" id="L214">        return (U)this;</span>
    }

    /**
     * Awaits the specified amount of time or until this TestObserver/TestSubscriber
     * receives an onError or onComplete events, whichever happens first.
     * @param time the waiting time
     * @param unit the time unit of the waiting time
     * @return true if the TestObserver/TestSubscriber terminated, false if timeout happened
     * @throws InterruptedException if the current thread is interrupted while waiting
     * @see #awaitTerminalEvent(long, TimeUnit)
     */
    public final boolean await(long time, TimeUnit unit) throws InterruptedException {
<span class="fc bfc" id="L227" title="All 4 branches covered.">        boolean d = done.getCount() == 0 || (done.await(time, unit));</span>
<span class="fc bfc" id="L228" title="All 2 branches covered.">        timeout = !d;</span>
<span class="fc" id="L229">        return d;</span>
    }

    // assertion methods

    /**
     * Assert that this TestObserver/TestSubscriber received exactly one onComplete event.
     * @return this
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public final U assertComplete() {
<span class="fc" id="L240">        long c = completions;</span>
<span class="fc bfc" id="L241" title="All 2 branches covered.">        if (c == 0) {</span>
<span class="fc" id="L242">            throw fail(&quot;Not completed&quot;);</span>
        } else
<span class="fc bfc" id="L244" title="All 2 branches covered.">        if (c &gt; 1) {</span>
<span class="fc" id="L245">            throw fail(&quot;Multiple completions: &quot; + c);</span>
        }
<span class="fc" id="L247">        return (U)this;</span>
    }

    /**
     * Assert that this TestObserver/TestSubscriber has not received any onComplete event.
     * @return this
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public final U assertNotComplete() {
<span class="fc" id="L256">        long c = completions;</span>
<span class="fc bfc" id="L257" title="All 2 branches covered.">        if (c == 1) {</span>
<span class="fc" id="L258">            throw fail(&quot;Completed!&quot;);</span>
        } else
<span class="fc bfc" id="L260" title="All 2 branches covered.">        if (c &gt; 1) {</span>
<span class="fc" id="L261">            throw fail(&quot;Multiple completions: &quot; + c);</span>
        }
<span class="fc" id="L263">        return (U)this;</span>
    }

    /**
     * Assert that this TestObserver/TestSubscriber has not received any onError event.
     * @return this
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public final U assertNoErrors() {
<span class="fc" id="L272">        int s = errors.size();</span>
<span class="fc bfc" id="L273" title="All 2 branches covered.">        if (s != 0) {</span>
<span class="fc" id="L274">            throw fail(&quot;Error(s) present: &quot; + errors);</span>
        }
<span class="fc" id="L276">        return (U)this;</span>
    }

    /**
     * Assert that this TestObserver/TestSubscriber received exactly the specified onError event value.
     *
     * &lt;p&gt;The comparison is performed via Objects.equals(); since most exceptions don't
     * implement equals(), this assertion may fail. Use the {@link #assertError(Class)}
     * overload to test against the class of an error instead of an instance of an error
     * or {@link #assertError(Predicate)} to test with different condition.
     * @param error the error to check
     * @return this
     * @see #assertError(Class)
     * @see #assertError(Predicate)
     */
    public final U assertError(Throwable error) {
<span class="fc" id="L292">        return assertError(Functions.equalsWith(error));</span>
    }

    /**
     * Asserts that this TestObserver/TestSubscriber received exactly one onError event which is an
     * instance of the specified errorClass class.
     * @param errorClass the error class to expect
     * @return this
     */
    @SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot;, &quot;cast&quot; })
    public final U assertError(Class&lt;? extends Throwable&gt; errorClass) {
<span class="fc" id="L303">        return (U)assertError((Predicate)Functions.isInstanceOf(errorClass));</span>
    }

    /**
     * Asserts that this TestObserver/TestSubscriber received exactly one onError event for which
     * the provided predicate returns true.
     * @param errorPredicate
     *            the predicate that receives the error Throwable
     *            and should return true for expected errors.
     * @return this
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public final U assertError(Predicate&lt;Throwable&gt; errorPredicate) {
<span class="fc" id="L316">        int s = errors.size();</span>
<span class="fc bfc" id="L317" title="All 2 branches covered.">        if (s == 0) {</span>
<span class="fc" id="L318">            throw fail(&quot;No errors&quot;);</span>
        }

<span class="fc" id="L321">        boolean found = false;</span>

<span class="fc bfc" id="L323" title="All 2 branches covered.">        for (Throwable e : errors) {</span>
            try {
<span class="fc bfc" id="L325" title="All 2 branches covered.">                if (errorPredicate.test(e)) {</span>
<span class="fc" id="L326">                    found = true;</span>
<span class="fc" id="L327">                    break;</span>
                }
<span class="fc" id="L329">            } catch (Exception ex) {</span>
<span class="fc" id="L330">                throw ExceptionHelper.wrapOrThrow(ex);</span>
<span class="fc" id="L331">            }</span>
<span class="fc" id="L332">        }</span>

<span class="fc bfc" id="L334" title="All 2 branches covered.">        if (found) {</span>
<span class="fc bfc" id="L335" title="All 2 branches covered.">            if (s != 1) {</span>
<span class="fc" id="L336">                throw fail(&quot;Error present but other errors as well&quot;);</span>
            }
        } else {
<span class="fc" id="L339">            throw fail(&quot;Error not present&quot;);</span>
        }
<span class="fc" id="L341">        return (U)this;</span>
    }

    /**
     * Assert that this TestObserver/TestSubscriber received exactly one onNext value which is equal to
     * the given value with respect to Objects.equals.
     * @param value the value to expect
     * @return this
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public final U assertValue(T value) {
<span class="fc" id="L352">        int s = values.size();</span>
<span class="fc bfc" id="L353" title="All 2 branches covered.">        if (s != 1) {</span>
<span class="fc" id="L354">            throw fail(&quot;expected: &quot; + valueAndClass(value) + &quot; but was: &quot; + values);</span>
        }
<span class="fc" id="L356">        T v = values.get(0);</span>
<span class="fc bfc" id="L357" title="All 2 branches covered.">        if (!ObjectHelper.equals(value, v)) {</span>
<span class="fc" id="L358">            throw fail(&quot;expected: &quot; + valueAndClass(value) + &quot; but was: &quot; + valueAndClass(v));</span>
        }
<span class="fc" id="L360">        return (U)this;</span>
    }

    /**
     * Assert that this TestObserver/TestSubscriber did not receive an onNext value which is equal to
     * the given value with respect to null-safe Object.equals.
     *
     * &lt;p&gt;History: 2.0.5 - experimental
     * @param value the value to expect not being received
     * @return this
     * @since 2.1
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public final U assertNever(T value) {
<span class="fc" id="L374">        int s = values.size();</span>

<span class="fc bfc" id="L376" title="All 2 branches covered.">        for (int i = 0; i &lt; s; i++) {</span>
<span class="fc" id="L377">            T v = this.values.get(i);</span>
<span class="fc bfc" id="L378" title="All 2 branches covered.">            if (ObjectHelper.equals(v, value)) {</span>
<span class="fc" id="L379">                throw fail(&quot;Value at position &quot; + i + &quot; is equal to &quot; + valueAndClass(value) + &quot;; Expected them to be different&quot;);</span>
            }
        }
<span class="fc" id="L382">        return (U) this;</span>
    }

    /**
     * Asserts that this TestObserver/TestSubscriber received exactly one onNext value for which
     * the provided predicate returns true.
     * @param valuePredicate
     *            the predicate that receives the onNext value
     *            and should return true for the expected value.
     * @return this
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public final U assertValue(Predicate&lt;T&gt; valuePredicate) {
<span class="fc" id="L395">        assertValueAt(0, valuePredicate);</span>

<span class="fc bfc" id="L397" title="All 2 branches covered.">        if (values.size() &gt; 1) {</span>
<span class="fc" id="L398">            throw fail(&quot;Value present but other values as well&quot;);</span>
        }

<span class="fc" id="L401">        return (U)this;</span>
    }

    /**
     * Asserts that this TestObserver/TestSubscriber did not receive any onNext value for which
     * the provided predicate returns true.
     *
     * &lt;p&gt;History: 2.0.5 - experimental
     * @param valuePredicate the predicate that receives the onNext value
     *                       and should return true for the expected value.
     * @return this
     * @since 2.1
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public final U assertNever(Predicate&lt;? super T&gt; valuePredicate) {
<span class="fc" id="L416">        int s = values.size();</span>

<span class="fc bfc" id="L418" title="All 2 branches covered.">        for (int i = 0; i &lt; s; i++) {</span>
<span class="fc" id="L419">            T v = this.values.get(i);</span>
            try {
<span class="fc bfc" id="L421" title="All 2 branches covered.">                if (valuePredicate.test(v)) {</span>
<span class="fc" id="L422">                    throw fail(&quot;Value at position &quot; + i + &quot; matches predicate &quot; + valuePredicate.toString() + &quot;, which was not expected.&quot;);</span>
                }
<span class="fc" id="L424">            } catch (Exception ex) {</span>
<span class="fc" id="L425">                throw ExceptionHelper.wrapOrThrow(ex);</span>
<span class="fc" id="L426">            }</span>
        }
<span class="fc" id="L428">        return (U)this;</span>
    }

    /**
     * Asserts that this TestObserver/TestSubscriber received an onNext value at the given index
     * which is equal to the given value with respect to null-safe Object.equals.
     * &lt;p&gt;History: 2.1.3 - experimental
     * @param index the position to assert on
     * @param value the value to expect
     * @return this
     * @since 2.2
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public final U assertValueAt(int index, T value) {
<span class="fc" id="L442">        int s = values.size();</span>
<span class="fc bfc" id="L443" title="All 2 branches covered.">        if (s == 0) {</span>
<span class="fc" id="L444">            throw fail(&quot;No values&quot;);</span>
        }

<span class="fc bfc" id="L447" title="All 2 branches covered.">        if (index &gt;= s) {</span>
<span class="fc" id="L448">            throw fail(&quot;Invalid index: &quot; + index);</span>
        }

<span class="fc" id="L451">        T v = values.get(index);</span>
<span class="fc bfc" id="L452" title="All 2 branches covered.">        if (!ObjectHelper.equals(value, v)) {</span>
<span class="fc" id="L453">            throw fail(&quot;expected: &quot; + valueAndClass(value) + &quot; but was: &quot; + valueAndClass(v));</span>
        }
<span class="fc" id="L455">        return (U)this;</span>
    }

    /**
     * Asserts that this TestObserver/TestSubscriber received an onNext value at the given index
     * for the provided predicate returns true.
     * @param index the position to assert on
     * @param valuePredicate
     *            the predicate that receives the onNext value
     *            and should return true for the expected value.
     * @return this
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public final U assertValueAt(int index, Predicate&lt;T&gt; valuePredicate) {
<span class="fc" id="L469">        int s = values.size();</span>
<span class="fc bfc" id="L470" title="All 2 branches covered.">        if (s == 0) {</span>
<span class="fc" id="L471">            throw fail(&quot;No values&quot;);</span>
        }

<span class="fc bfc" id="L474" title="All 2 branches covered.">        if (index &gt;= values.size()) {</span>
<span class="fc" id="L475">            throw fail(&quot;Invalid index: &quot; + index);</span>
        }

<span class="fc" id="L478">        boolean found = false;</span>

        try {
<span class="fc bfc" id="L481" title="All 2 branches covered.">            if (valuePredicate.test(values.get(index))) {</span>
<span class="fc" id="L482">                found = true;</span>
            }
<span class="fc" id="L484">        } catch (Exception ex) {</span>
<span class="fc" id="L485">            throw ExceptionHelper.wrapOrThrow(ex);</span>
<span class="fc" id="L486">        }</span>

<span class="fc bfc" id="L488" title="All 2 branches covered.">        if (!found) {</span>
<span class="fc" id="L489">            throw fail(&quot;Value not present&quot;);</span>
        }
<span class="fc" id="L491">        return (U)this;</span>
    }

    /**
     * Appends the class name to a non-null value.
     * @param o the object
     * @return the string representation
     */
    public static String valueAndClass(Object o) {
<span class="fc bfc" id="L500" title="All 2 branches covered.">        if (o != null) {</span>
<span class="fc" id="L501">            return o + &quot; (class: &quot; + o.getClass().getSimpleName() + &quot;)&quot;;</span>
        }
<span class="fc" id="L503">        return &quot;null&quot;;</span>
    }

    /**
     * Assert that this TestObserver/TestSubscriber received the specified number onNext events.
     * @param count the expected number of onNext events
     * @return this
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public final U assertValueCount(int count) {
<span class="fc" id="L513">        int s = values.size();</span>
<span class="fc bfc" id="L514" title="All 2 branches covered.">        if (s != count) {</span>
<span class="fc" id="L515">            throw fail(&quot;Value counts differ; expected: &quot; + count + &quot; but was: &quot; + s);</span>
        }
<span class="fc" id="L517">        return (U)this;</span>
    }

    /**
     * Assert that this TestObserver/TestSubscriber has not received any onNext events.
     * @return this
     */
    public final U assertNoValues() {
<span class="fc" id="L525">        return assertValueCount(0);</span>
    }

    /**
     * Assert that the TestObserver/TestSubscriber received only the specified values in the specified order.
     * @param values the values expected
     * @return this
     * @see #assertValueSet(Collection)
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public final U assertValues(T... values) {
<span class="fc" id="L536">        int s = this.values.size();</span>
<span class="fc bfc" id="L537" title="All 2 branches covered.">        if (s != values.length) {</span>
<span class="fc" id="L538">            throw fail(&quot;Value count differs; expected: &quot; + values.length + &quot; &quot; + Arrays.toString(values)</span>
            + &quot; but was: &quot; + s + &quot; &quot; + this.values);
        }
<span class="fc bfc" id="L541" title="All 2 branches covered.">        for (int i = 0; i &lt; s; i++) {</span>
<span class="fc" id="L542">            T v = this.values.get(i);</span>
<span class="fc" id="L543">            T u = values[i];</span>
<span class="fc bfc" id="L544" title="All 2 branches covered.">            if (!ObjectHelper.equals(u, v)) {</span>
<span class="fc" id="L545">                throw fail(&quot;Values at position &quot; + i + &quot; differ; expected: &quot; + valueAndClass(u) + &quot; but was: &quot; + valueAndClass(v));</span>
            }
        }
<span class="fc" id="L548">        return (U)this;</span>
    }

    /**
     * Assert that the TestObserver/TestSubscriber received only the specified values in the specified order without terminating.
     * &lt;p&gt;History: 2.1.4 - experimental
     * @param values the values expected
     * @return this
     * @since 2.2
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public final U assertValuesOnly(T... values) {
<span class="fc" id="L560">        return assertSubscribed()</span>
<span class="fc" id="L561">                .assertValues(values)</span>
<span class="fc" id="L562">                .assertNoErrors()</span>
<span class="fc" id="L563">                .assertNotComplete();</span>
    }

    /**
     * Assert that the TestObserver/TestSubscriber received only items that are in the specified
     * collection as well, irrespective of the order they were received.
     * &lt;p&gt;
     * This helps asserting when the order of the values is not guaranteed, i.e., when merging
     * asynchronous streams.
     * &lt;p&gt;
     * To ensure that only the expected items have been received, no more and no less, in any order,
     * apply {@link #assertValueCount(int)} with {@code expected.size()}.
     *
     * @param expected the collection of values expected in any order
     * @return this
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public final U assertValueSet(Collection&lt;? extends T&gt; expected) {
<span class="fc bfc" id="L581" title="All 2 branches covered.">        if (expected.isEmpty()) {</span>
<span class="fc" id="L582">            assertNoValues();</span>
<span class="fc" id="L583">            return (U)this;</span>
        }
<span class="fc bfc" id="L585" title="All 2 branches covered.">        for (T v : this.values) {</span>
<span class="fc bfc" id="L586" title="All 2 branches covered.">            if (!expected.contains(v)) {</span>
<span class="fc" id="L587">                throw fail(&quot;Value not in the expected collection: &quot; + valueAndClass(v));</span>
            }
<span class="fc" id="L589">        }</span>
<span class="fc" id="L590">        return (U)this;</span>
    }

    /**
     * Assert that the TestObserver/TestSubscriber received only the specified values in any order without terminating.
     * &lt;p&gt;History: 2.1.14 - experimental
     * @param expected the collection of values expected in any order
     * @return this
     * @since 2.2
     */
    public final U assertValueSetOnly(Collection&lt;? extends T&gt; expected) {
<span class="fc" id="L601">        return assertSubscribed()</span>
<span class="fc" id="L602">                .assertValueSet(expected)</span>
<span class="fc" id="L603">                .assertNoErrors()</span>
<span class="fc" id="L604">                .assertNotComplete();</span>
    }

    /**
     * Assert that the TestObserver/TestSubscriber received only the specified sequence of values in the same order.
     * @param sequence the sequence of expected values in order
     * @return this
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public final U assertValueSequence(Iterable&lt;? extends T&gt; sequence) {
<span class="fc" id="L614">        int i = 0;</span>
<span class="fc" id="L615">        Iterator&lt;T&gt; actualIterator = values.iterator();</span>
<span class="fc" id="L616">        Iterator&lt;? extends T&gt; expectedIterator = sequence.iterator();</span>
        boolean actualNext;
        boolean expectedNext;
        for (;;) {
<span class="fc" id="L620">            expectedNext = expectedIterator.hasNext();</span>
<span class="fc" id="L621">            actualNext = actualIterator.hasNext();</span>

<span class="fc bfc" id="L623" title="All 4 branches covered.">            if (!actualNext || !expectedNext) {</span>
<span class="fc" id="L624">                break;</span>
            }

<span class="fc" id="L627">            T u = expectedIterator.next();</span>
<span class="fc" id="L628">            T v = actualIterator.next();</span>

<span class="fc bfc" id="L630" title="All 2 branches covered.">            if (!ObjectHelper.equals(u, v)) {</span>
<span class="fc" id="L631">                throw fail(&quot;Values at position &quot; + i + &quot; differ; expected: &quot; + valueAndClass(u) + &quot; but was: &quot; + valueAndClass(v));</span>
            }
<span class="fc" id="L633">            i++;</span>
<span class="fc" id="L634">        }</span>

<span class="fc bfc" id="L636" title="All 2 branches covered.">        if (actualNext) {</span>
<span class="fc" id="L637">            throw fail(&quot;More values received than expected (&quot; + i + &quot;)&quot;);</span>
        }
<span class="fc bfc" id="L639" title="All 2 branches covered.">        if (expectedNext) {</span>
<span class="fc" id="L640">            throw fail(&quot;Fewer values received than expected (&quot; + i + &quot;)&quot;);</span>
        }
<span class="fc" id="L642">        return (U)this;</span>
    }

    /**
     * Assert that the TestObserver/TestSubscriber received only the specified values in the specified order without terminating.
     * &lt;p&gt;History: 2.1.14 - experimental
     * @param sequence the sequence of expected values in order
     * @return this
     * @since 2.2
     */
    public final U assertValueSequenceOnly(Iterable&lt;? extends T&gt; sequence) {
<span class="fc" id="L653">        return assertSubscribed()</span>
<span class="fc" id="L654">                .assertValueSequence(sequence)</span>
<span class="fc" id="L655">                .assertNoErrors()</span>
<span class="fc" id="L656">                .assertNotComplete();</span>
    }

    /**
     * Assert that the TestObserver/TestSubscriber terminated (i.e., the terminal latch reached zero).
     * @return this
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public final U assertTerminated() {
<span class="fc bfc" id="L665" title="All 2 branches covered.">        if (done.getCount() != 0) {</span>
<span class="fc" id="L666">            throw fail(&quot;Subscriber still running!&quot;);</span>
        }
<span class="fc" id="L668">        long c = completions;</span>
<span class="fc bfc" id="L669" title="All 2 branches covered.">        if (c &gt; 1) {</span>
<span class="fc" id="L670">            throw fail(&quot;Terminated with multiple completions: &quot; + c);</span>
        }
<span class="fc" id="L672">        int s = errors.size();</span>
<span class="fc bfc" id="L673" title="All 2 branches covered.">        if (s &gt; 1) {</span>
<span class="fc" id="L674">            throw fail(&quot;Terminated with multiple errors: &quot; + s);</span>
        }

<span class="fc bfc" id="L677" title="All 4 branches covered.">        if (c != 0 &amp;&amp; s != 0) {</span>
<span class="fc" id="L678">            throw fail(&quot;Terminated with multiple completions and errors: &quot; + c);</span>
        }
<span class="fc" id="L680">        return (U)this;</span>
    }

    /**
     * Assert that the TestObserver/TestSubscriber has not terminated (i.e., the terminal latch is still non-zero).
     * @return this
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public final U assertNotTerminated() {
<span class="fc bfc" id="L689" title="All 2 branches covered.">        if (done.getCount() == 0) {</span>
<span class="fc" id="L690">            throw fail(&quot;Subscriber terminated!&quot;);</span>
        }
<span class="fc" id="L692">        return (U)this;</span>
    }

    /**
     * Waits until the any terminal event has been received by this TestObserver/TestSubscriber
     * or returns false if the wait has been interrupted.
     * @return true if the TestObserver/TestSubscriber terminated, false if the wait has been interrupted
     */
    public final boolean awaitTerminalEvent() {
        try {
<span class="fc" id="L702">            await();</span>
<span class="fc" id="L703">            return true;</span>
<span class="fc" id="L704">        } catch (InterruptedException ex) {</span>
<span class="fc" id="L705">            Thread.currentThread().interrupt();</span>
<span class="fc" id="L706">            return false;</span>
        }
    }

    /**
     * Awaits the specified amount of time or until this TestObserver/TestSubscriber
     * receives an onError or onComplete events, whichever happens first.
     * @param duration the waiting time
     * @param unit the time unit of the waiting time
     * @return true if the TestObserver/TestSubscriber terminated, false if timeout or interrupt happened
     */
    public final boolean awaitTerminalEvent(long duration, TimeUnit unit) {
        try {
<span class="fc" id="L719">            return await(duration, unit);</span>
<span class="fc" id="L720">        } catch (InterruptedException ex) {</span>
<span class="fc" id="L721">            Thread.currentThread().interrupt();</span>
<span class="fc" id="L722">            return false;</span>
        }
    }

    /**
     * Assert that there is a single error and it has the given message.
     * @param message the message expected
     * @return this
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public final U assertErrorMessage(String message) {
<span class="fc" id="L733">        int s = errors.size();</span>
<span class="fc bfc" id="L734" title="All 2 branches covered.">        if (s == 0) {</span>
<span class="fc" id="L735">            throw fail(&quot;No errors&quot;);</span>
        } else
<span class="fc bfc" id="L737" title="All 2 branches covered.">        if (s == 1) {</span>
<span class="fc" id="L738">            Throwable e = errors.get(0);</span>
<span class="fc" id="L739">            String errorMessage = e.getMessage();</span>
<span class="fc bfc" id="L740" title="All 2 branches covered.">            if (!ObjectHelper.equals(message, errorMessage)) {</span>
<span class="fc" id="L741">                throw fail(&quot;Error message differs; exptected: &quot; + message + &quot; but was: &quot; + errorMessage);</span>
            }
<span class="fc" id="L743">        } else {</span>
<span class="fc" id="L744">            throw fail(&quot;Multiple errors&quot;);</span>
        }
<span class="fc" id="L746">        return (U)this;</span>
    }

    /**
     * Returns a list of 3 other lists: the first inner list contains the plain
     * values received; the second list contains the potential errors
     * and the final list contains the potential completions as Notifications.
     *
     * @return a list of (values, errors, completion-notifications)
     */
    @SuppressWarnings({ &quot;rawtypes&quot;, &quot;unchecked&quot; })
    public final List&lt;List&lt;Object&gt;&gt; getEvents() {
<span class="fc" id="L758">        List&lt;List&lt;Object&gt;&gt; result = new ArrayList&lt;List&lt;Object&gt;&gt;();</span>

<span class="fc" id="L760">        result.add((List)values());</span>

<span class="fc" id="L762">        result.add((List)errors());</span>

<span class="fc" id="L764">        List&lt;Object&gt; completeList = new ArrayList&lt;Object&gt;();</span>
<span class="fc bfc" id="L765" title="All 2 branches covered.">        for (long i = 0; i &lt; completions; i++) {</span>
<span class="fc" id="L766">            completeList.add(Notification.createOnComplete());</span>
        }
<span class="fc" id="L768">        result.add(completeList);</span>

<span class="fc" id="L770">        return result;</span>
    }

    /**
     * Assert that the onSubscribe method was called exactly once.
     * @return this
     */
    public abstract U assertSubscribed();

    /**
     * Assert that the onSubscribe method hasn't been called at all.
     * @return this
     */
    public abstract U assertNotSubscribed();

    /**
     * Assert that the upstream signalled the specified values in order and
     * completed normally.
     * @param values the expected values, asserted in order
     * @return this
     * @see #assertFailure(Class, Object...)
     * @see #assertFailure(Predicate, Object...)
     * @see #assertFailureAndMessage(Class, String, Object...)
     */
    public final U assertResult(T... values) {
<span class="fc" id="L795">        return assertSubscribed()</span>
<span class="fc" id="L796">                .assertValues(values)</span>
<span class="fc" id="L797">                .assertNoErrors()</span>
<span class="fc" id="L798">                .assertComplete();</span>
    }

    /**
     * Assert that the upstream signalled the specified values in order
     * and then failed with a specific class or subclass of Throwable.
     * @param error the expected exception (parent) class
     * @param values the expected values, asserted in order
     * @return this
     */
    public final U assertFailure(Class&lt;? extends Throwable&gt; error, T... values) {
<span class="fc" id="L809">        return assertSubscribed()</span>
<span class="fc" id="L810">                .assertValues(values)</span>
<span class="fc" id="L811">                .assertError(error)</span>
<span class="fc" id="L812">                .assertNotComplete();</span>
    }

    /**
     * Assert that the upstream signalled the specified values in order and then failed
     * with a Throwable for which the provided predicate returns true.
     * @param errorPredicate
     *            the predicate that receives the error Throwable
     *            and should return true for expected errors.
     * @param values the expected values, asserted in order
     * @return this
     */
    public final U assertFailure(Predicate&lt;Throwable&gt; errorPredicate, T... values) {
<span class="fc" id="L825">        return assertSubscribed()</span>
<span class="fc" id="L826">                .assertValues(values)</span>
<span class="fc" id="L827">                .assertError(errorPredicate)</span>
<span class="fc" id="L828">                .assertNotComplete();</span>
    }

    /**
     * Assert that the upstream signalled the specified values in order,
     * then failed with a specific class or subclass of Throwable
     * and with the given exact error message.
     * @param error the expected exception (parent) class
     * @param message the expected failure message
     * @param values the expected values, asserted in order
     * @return this
     */
    public final U assertFailureAndMessage(Class&lt;? extends Throwable&gt; error,
            String message, T... values) {
<span class="fc" id="L842">        return assertSubscribed()</span>
<span class="fc" id="L843">                .assertValues(values)</span>
<span class="fc" id="L844">                .assertError(error)</span>
<span class="fc" id="L845">                .assertErrorMessage(message)</span>
<span class="fc" id="L846">                .assertNotComplete();</span>
    }

    /**
     * Awaits until the internal latch is counted down.
     * &lt;p&gt;If the wait times out or gets interrupted, the TestObserver/TestSubscriber is cancelled.
     * @param time the waiting time
     * @param unit the time unit of the waiting time
     * @return this
     * @throws RuntimeException wrapping an InterruptedException if the wait is interrupted
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public final U awaitDone(long time, TimeUnit unit) {
        try {
<span class="fc bfc" id="L860" title="All 2 branches covered.">            if (!done.await(time, unit)) {</span>
<span class="fc" id="L861">                timeout = true;</span>
<span class="fc" id="L862">                dispose();</span>
            }
<span class="fc" id="L864">        } catch (InterruptedException ex) {</span>
<span class="fc" id="L865">            dispose();</span>
<span class="fc" id="L866">            throw ExceptionHelper.wrapOrThrow(ex);</span>
<span class="fc" id="L867">        }</span>
<span class="fc" id="L868">        return (U)this;</span>
    }

    /**
     * Assert that the TestObserver/TestSubscriber has received a Disposable but no other events.
     * @return this
     */
    public final U assertEmpty() {
<span class="fc" id="L876">        return assertSubscribed()</span>
<span class="fc" id="L877">                .assertNoValues()</span>
<span class="fc" id="L878">                .assertNoErrors()</span>
<span class="fc" id="L879">                .assertNotComplete();</span>
    }

    /**
     * Set the tag displayed along with an assertion failure's
     * other state information.
     * &lt;p&gt;History: 2.0.7 - experimental
     * @param tag the string to display (null won't print any tag)
     * @return this
     * @since 2.1
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public final U withTag(CharSequence tag) {
<span class="fc" id="L892">        this.tag = tag;</span>
<span class="fc" id="L893">        return (U)this;</span>
    }

    /**
     * Enumeration of default wait strategies when waiting for a specific number of
     * items in {@link BaseTestConsumer#awaitCount(int, Runnable)}.
     * &lt;p&gt;History: 2.0.7 - experimental
     * @since 2.1
     */
<span class="fc" id="L902">    public enum TestWaitStrategy implements Runnable {</span>
        /** The wait loop will spin as fast as possible. */
<span class="fc" id="L904">        SPIN {</span>
            @Override
            public void run() {
                // nothing to do
<span class="fc" id="L908">            }</span>
        },
        /** The current thread will be yielded. */
<span class="fc" id="L911">        YIELD {</span>
            @Override
            public void run() {
<span class="fc" id="L914">                Thread.yield();</span>
<span class="fc" id="L915">            }</span>
        },
        /** The current thread sleeps for 1 millisecond. */
<span class="fc" id="L918">        SLEEP_1MS {</span>
            @Override
            public void run() {
<span class="fc" id="L921">                sleep(1);</span>
<span class="fc" id="L922">            }</span>
        },
        /** The current thread sleeps for 10 milliseconds. */
<span class="fc" id="L925">        SLEEP_10MS {</span>
            @Override
            public void run() {
<span class="fc" id="L928">                sleep(10);</span>
<span class="fc" id="L929">            }</span>
        },
        /** The current thread sleeps for 100 milliseconds. */
<span class="fc" id="L932">        SLEEP_100MS {</span>
            @Override
            public void run() {
<span class="fc" id="L935">                sleep(100);</span>
<span class="fc" id="L936">            }</span>
        },
        /** The current thread sleeps for 1000 milliseconds. */
<span class="fc" id="L939">        SLEEP_1000MS {</span>
            @Override
            public void run() {
<span class="fc" id="L942">                sleep(1000);</span>
<span class="fc" id="L943">            }</span>
        }
        ;

        @Override
        public abstract void run();

        static void sleep(int millis) {
            try {
<span class="fc" id="L952">                Thread.sleep(millis);</span>
<span class="fc" id="L953">            } catch (InterruptedException ex) {</span>
<span class="fc" id="L954">                throw new RuntimeException(ex);</span>
<span class="fc" id="L955">            }</span>
<span class="fc" id="L956">        }</span>
    }

    /**
     * Await until the TestObserver/TestSubscriber receives the given
     * number of items or terminates by sleeping 10 milliseconds at a time
     * up to 5000 milliseconds of timeout.
     * &lt;p&gt;History: 2.0.7 - experimental
     * @param atLeast the number of items expected at least
     * @return this
     * @see #awaitCount(int, Runnable, long)
     * @since 2.1
     */
    public final U awaitCount(int atLeast) {
<span class="fc" id="L970">        return awaitCount(atLeast, TestWaitStrategy.SLEEP_10MS, 5000);</span>
    }

    /**
     * Await until the TestObserver/TestSubscriber receives the given
     * number of items or terminates by waiting according to the wait
     * strategy and up to 5000 milliseconds of timeout.
     * &lt;p&gt;History: 2.0.7 - experimental
     * @param atLeast the number of items expected at least
     * @param waitStrategy a Runnable called when the current received count
     *                     hasn't reached the expected value and there was
     *                     no terminal event either, see {@link TestWaitStrategy}
     *                     for examples
     * @return this
     * @see #awaitCount(int, Runnable, long)
     * @since 2.1
     */
    public final U awaitCount(int atLeast, Runnable waitStrategy) {
<span class="fc" id="L988">        return awaitCount(atLeast, waitStrategy, 5000);</span>
    }

    /**
     * Await until the TestObserver/TestSubscriber receives the given
     * number of items or terminates.
     * &lt;p&gt;History: 2.0.7 - experimental
     * @param atLeast the number of items expected at least
     * @param waitStrategy a Runnable called when the current received count
     *                     hasn't reached the expected value and there was
     *                     no terminal event either, see {@link TestWaitStrategy}
     *                     for examples
     * @param timeoutMillis if positive, the await ends if the specified amount of
     *                      time has passed no matter how many items were received
     * @return this
     * @since 2.1
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public final U awaitCount(int atLeast, Runnable waitStrategy, long timeoutMillis) {
<span class="fc" id="L1007">        long start = System.currentTimeMillis();</span>
        for (;;) {
<span class="fc bfc" id="L1009" title="All 4 branches covered.">            if (timeoutMillis &gt; 0L &amp;&amp; System.currentTimeMillis() - start &gt;= timeoutMillis) {</span>
<span class="fc" id="L1010">                timeout = true;</span>
<span class="fc" id="L1011">                break;</span>
            }
<span class="fc bfc" id="L1013" title="All 2 branches covered.">            if (done.getCount() == 0L) {</span>
<span class="fc" id="L1014">                break;</span>
            }
<span class="fc bfc" id="L1016" title="All 2 branches covered.">            if (values.size() &gt;= atLeast) {</span>
<span class="fc" id="L1017">                break;</span>
            }

<span class="fc" id="L1020">            waitStrategy.run();</span>
        }
<span class="fc" id="L1022">        return (U)this;</span>
    }

    /**
     * Returns true if an await timed out.
     * @return true if one of the timeout-based await methods has timed out.
     * &lt;p&gt;History: 2.0.7 - experimental
     * @see #clearTimeout()
     * @see #assertTimeout()
     * @see #assertNoTimeout()
     * @since 2.1
     */
    public final boolean isTimeout() {
<span class="fc" id="L1035">        return timeout;</span>
    }

    /**
     * Clears the timeout flag set by the await methods when they timed out.
     * &lt;p&gt;History: 2.0.7 - experimental
     * @return this
     * @since 2.1
     * @see #isTimeout()
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public final U clearTimeout() {
<span class="fc" id="L1047">        timeout = false;</span>
<span class="fc" id="L1048">        return (U)this;</span>
    }

    /**
     * Asserts that some awaitX method has timed out.
     * &lt;p&gt;History: 2.0.7 - experimental
     * @return this
     * @since 2.1
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public final U assertTimeout() {
<span class="fc bfc" id="L1059" title="All 2 branches covered.">        if (!timeout) {</span>
<span class="fc" id="L1060">            throw fail(&quot;No timeout?!&quot;);</span>
        }
<span class="fc" id="L1062">        return (U)this;</span>
    }

    /**
     * Asserts that some awaitX method has not timed out.
     * &lt;p&gt;History: 2.0.7 - experimental
     * @return this
     * @since 2.1
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public final U assertNoTimeout() {
<span class="fc bfc" id="L1073" title="All 2 branches covered.">        if (timeout) {</span>
<span class="fc" id="L1074">            throw fail(&quot;Timeout?!&quot;);</span>
        }
<span class="fc" id="L1076">        return (U)this;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>