<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ParallelFlowable.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">RxJava_2_x$Unnamed.exec</a> &gt; <a href="index.source.html" class="el_package">io.reactivex.parallel</a> &gt; <span class="el_source">ParallelFlowable.java</span></div><h1>ParallelFlowable.java</h1><pre class="source lang-java linenums">/**
 * Copyright (c) 2016-present, RxJava Contributors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is
 * distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
 * the License for the specific language governing permissions and limitations under the License.
 */

package io.reactivex.parallel;

import java.util.*;
import java.util.concurrent.Callable;

import io.reactivex.*;
import io.reactivex.annotations.*;
import io.reactivex.exceptions.Exceptions;
import io.reactivex.functions.*;
import io.reactivex.internal.functions.*;
import io.reactivex.internal.operators.parallel.*;
import io.reactivex.internal.subscriptions.EmptySubscription;
import io.reactivex.internal.util.*;
import io.reactivex.plugins.RxJavaPlugins;
import org.reactivestreams.*;

/**
 * Abstract base class for Parallel publishers that take an array of Subscribers.
 * &lt;p&gt;
 * Use {@code from()} to start processing a regular Publisher in 'rails'.
 * Use {@code runOn()} to introduce where each 'rail' should run on thread-vise.
 * Use {@code sequential()} to merge the sources back into a single Flowable.
 *
 * &lt;p&gt;History: 2.0.5 - experimental; 2.1 - beta
 * @param &lt;T&gt; the value type
 * @since 2.2
 */
<span class="fc" id="L41">public abstract class ParallelFlowable&lt;T&gt; {</span>

    /**
     * Subscribes an array of Subscribers to this ParallelFlowable and triggers
     * the execution chain for all 'rails'.
     *
     * @param subscribers the subscribers array to run in parallel, the number
     * of items must be equal to the parallelism level of this ParallelFlowable
     * @see #parallelism()
     */
    public abstract void subscribe(@NonNull Subscriber&lt;? super T&gt;[] subscribers);

    /**
     * Returns the number of expected parallel Subscribers.
     * @return the number of expected parallel Subscribers
     */
    public abstract int parallelism();

    /**
     * Validates the number of subscribers and returns true if their number
     * matches the parallelism level of this ParallelFlowable.
     *
     * @param subscribers the array of Subscribers
     * @return true if the number of subscribers equals to the parallelism level
     */
    protected final boolean validate(@NonNull Subscriber&lt;?&gt;[] subscribers) {
<span class="fc" id="L67">        int p = parallelism();</span>
<span class="fc bfc" id="L68" title="All 2 branches covered.">        if (subscribers.length != p) {</span>
<span class="fc" id="L69">            Throwable iae = new IllegalArgumentException(&quot;parallelism = &quot; + p + &quot;, subscribers = &quot; + subscribers.length);</span>
<span class="fc bfc" id="L70" title="All 2 branches covered.">            for (Subscriber&lt;?&gt; s : subscribers) {</span>
<span class="fc" id="L71">                EmptySubscription.error(iae, s);</span>
            }
<span class="fc" id="L73">            return false;</span>
        }
<span class="fc" id="L75">        return true;</span>
    }

    /**
     * Take a Publisher and prepare to consume it on multiple 'rails' (number of CPUs)
     * in a round-robin fashion.
     * @param &lt;T&gt; the value type
     * @param source the source Publisher
     * @return the ParallelFlowable instance
     */
    @CheckReturnValue
    public static &lt;T&gt; ParallelFlowable&lt;T&gt; from(@NonNull Publisher&lt;? extends T&gt; source) {
<span class="fc" id="L87">        return from(source, Runtime.getRuntime().availableProcessors(), Flowable.bufferSize());</span>
    }

    /**
     * Take a Publisher and prepare to consume it on parallelism number of 'rails' in a round-robin fashion.
     * @param &lt;T&gt; the value type
     * @param source the source Publisher
     * @param parallelism the number of parallel rails
     * @return the new ParallelFlowable instance
     */
    @CheckReturnValue
    public static &lt;T&gt; ParallelFlowable&lt;T&gt; from(@NonNull Publisher&lt;? extends T&gt; source, int parallelism) {
<span class="fc" id="L99">        return from(source, parallelism, Flowable.bufferSize());</span>
    }

    /**
     * Take a Publisher and prepare to consume it on parallelism number of 'rails' ,
     * possibly ordered and round-robin fashion and use custom prefetch amount and queue
     * for dealing with the source Publisher's values.
     * @param &lt;T&gt; the value type
     * @param source the source Publisher
     * @param parallelism the number of parallel rails
     * @param prefetch the number of values to prefetch from the source
     * the source until there is a rail ready to process it.
     * @return the new ParallelFlowable instance
     */
    @CheckReturnValue
    @NonNull
    public static &lt;T&gt; ParallelFlowable&lt;T&gt; from(@NonNull Publisher&lt;? extends T&gt; source,
            int parallelism, int prefetch) {
<span class="fc" id="L117">        ObjectHelper.requireNonNull(source, &quot;source&quot;);</span>
<span class="fc" id="L118">        ObjectHelper.verifyPositive(parallelism, &quot;parallelism&quot;);</span>
<span class="fc" id="L119">        ObjectHelper.verifyPositive(prefetch, &quot;prefetch&quot;);</span>

<span class="fc" id="L121">        return RxJavaPlugins.onAssembly(new ParallelFromPublisher&lt;T&gt;(source, parallelism, prefetch));</span>
    }

    /**
     * Calls the specified converter function during assembly time and returns its resulting value.
     * &lt;p&gt;
     * This allows fluent conversion to any other type.
     * &lt;p&gt;History: 2.1.7 - experimental
     * @param &lt;R&gt; the resulting object type
     * @param converter the function that receives the current ParallelFlowable instance and returns a value
     * @return the converted value
     * @throws NullPointerException if converter is null
     * @since 2.2
     */
    @CheckReturnValue
    @NonNull
    public final &lt;R&gt; R as(@NonNull ParallelFlowableConverter&lt;T, R&gt; converter) {
<span class="fc" id="L138">        return ObjectHelper.requireNonNull(converter, &quot;converter is null&quot;).apply(this);</span>
    }

    /**
     * Maps the source values on each 'rail' to another value.
     * &lt;p&gt;
     * Note that the same mapper function may be called from multiple threads concurrently.
     * @param &lt;R&gt; the output value type
     * @param mapper the mapper function turning Ts into Us.
     * @return the new ParallelFlowable instance
     */
    @CheckReturnValue
    @NonNull
    public final &lt;R&gt; ParallelFlowable&lt;R&gt; map(@NonNull Function&lt;? super T, ? extends R&gt; mapper) {
<span class="fc" id="L152">        ObjectHelper.requireNonNull(mapper, &quot;mapper&quot;);</span>
<span class="fc" id="L153">        return RxJavaPlugins.onAssembly(new ParallelMap&lt;T, R&gt;(this, mapper));</span>
    }

    /**
     * Maps the source values on each 'rail' to another value and
     * handles errors based on the given {@link ParallelFailureHandling} enumeration value.
     * &lt;p&gt;
     * Note that the same mapper function may be called from multiple threads concurrently.
     * &lt;p&gt;History: 2.0.8 - experimental
     * @param &lt;R&gt; the output value type
     * @param mapper the mapper function turning Ts into Us.
     * @param errorHandler the enumeration that defines how to handle errors thrown
     *                     from the mapper function
     * @return the new ParallelFlowable instance
     * @since 2.2
     */
    @CheckReturnValue
    @NonNull
    public final &lt;R&gt; ParallelFlowable&lt;R&gt; map(@NonNull Function&lt;? super T, ? extends R&gt; mapper, @NonNull ParallelFailureHandling errorHandler) {
<span class="fc" id="L172">        ObjectHelper.requireNonNull(mapper, &quot;mapper&quot;);</span>
<span class="fc" id="L173">        ObjectHelper.requireNonNull(errorHandler, &quot;errorHandler is null&quot;);</span>
<span class="fc" id="L174">        return RxJavaPlugins.onAssembly(new ParallelMapTry&lt;T, R&gt;(this, mapper, errorHandler));</span>
    }

    /**
     * Maps the source values on each 'rail' to another value and
     * handles errors based on the returned value by the handler function.
     * &lt;p&gt;
     * Note that the same mapper function may be called from multiple threads concurrently.
     * &lt;p&gt;History: 2.0.8 - experimental
     * @param &lt;R&gt; the output value type
     * @param mapper the mapper function turning Ts into Us.
     * @param errorHandler the function called with the current repeat count and
     *                     failure Throwable and should return one of the {@link ParallelFailureHandling}
     *                     enumeration values to indicate how to proceed.
     * @return the new ParallelFlowable instance
     * @since 2.2
     */
    @CheckReturnValue
    @NonNull
    public final &lt;R&gt; ParallelFlowable&lt;R&gt; map(@NonNull Function&lt;? super T, ? extends R&gt; mapper, @NonNull BiFunction&lt;? super Long, ? super Throwable, ParallelFailureHandling&gt; errorHandler) {
<span class="fc" id="L194">        ObjectHelper.requireNonNull(mapper, &quot;mapper&quot;);</span>
<span class="fc" id="L195">        ObjectHelper.requireNonNull(errorHandler, &quot;errorHandler is null&quot;);</span>
<span class="fc" id="L196">        return RxJavaPlugins.onAssembly(new ParallelMapTry&lt;T, R&gt;(this, mapper, errorHandler));</span>
    }

    /**
     * Filters the source values on each 'rail'.
     * &lt;p&gt;
     * Note that the same predicate may be called from multiple threads concurrently.
     * @param predicate the function returning true to keep a value or false to drop a value
     * @return the new ParallelFlowable instance
     */
    @CheckReturnValue
    public final ParallelFlowable&lt;T&gt; filter(@NonNull Predicate&lt;? super T&gt; predicate) {
<span class="fc" id="L208">        ObjectHelper.requireNonNull(predicate, &quot;predicate&quot;);</span>
<span class="fc" id="L209">        return RxJavaPlugins.onAssembly(new ParallelFilter&lt;T&gt;(this, predicate));</span>
    }

    /**
     * Filters the source values on each 'rail' and
     * handles errors based on the given {@link ParallelFailureHandling} enumeration value.
     * &lt;p&gt;
     * Note that the same predicate may be called from multiple threads concurrently.
     * &lt;p&gt;History: 2.0.8 - experimental
     * @param predicate the function returning true to keep a value or false to drop a value
     * @param errorHandler the enumeration that defines how to handle errors thrown
     *                     from the predicate
     * @return the new ParallelFlowable instance
     * @since 2.2
     */
    @CheckReturnValue
    public final ParallelFlowable&lt;T&gt; filter(@NonNull Predicate&lt;? super T&gt; predicate, @NonNull ParallelFailureHandling errorHandler) {
<span class="fc" id="L226">        ObjectHelper.requireNonNull(predicate, &quot;predicate&quot;);</span>
<span class="fc" id="L227">        ObjectHelper.requireNonNull(errorHandler, &quot;errorHandler is null&quot;);</span>
<span class="fc" id="L228">        return RxJavaPlugins.onAssembly(new ParallelFilterTry&lt;T&gt;(this, predicate, errorHandler));</span>
    }

    /**
     * Filters the source values on each 'rail' and
     * handles errors based on the returned value by the handler function.
     * &lt;p&gt;
     * Note that the same predicate may be called from multiple threads concurrently.
     * &lt;p&gt;History: 2.0.8 - experimental
     * @param predicate the function returning true to keep a value or false to drop a value
     * @param errorHandler the function called with the current repeat count and
     *                     failure Throwable and should return one of the {@link ParallelFailureHandling}
     *                     enumeration values to indicate how to proceed.
     * @return the new ParallelFlowable instance
     * @since 2.2
     */
    @CheckReturnValue
    public final ParallelFlowable&lt;T&gt; filter(@NonNull Predicate&lt;? super T&gt; predicate, @NonNull BiFunction&lt;? super Long, ? super Throwable, ParallelFailureHandling&gt; errorHandler) {
<span class="fc" id="L246">        ObjectHelper.requireNonNull(predicate, &quot;predicate&quot;);</span>
<span class="fc" id="L247">        ObjectHelper.requireNonNull(errorHandler, &quot;errorHandler is null&quot;);</span>
<span class="fc" id="L248">        return RxJavaPlugins.onAssembly(new ParallelFilterTry&lt;T&gt;(this, predicate, errorHandler));</span>
    }

    /**
     * Specifies where each 'rail' will observe its incoming values with
     * no work-stealing and default prefetch amount.
     * &lt;p&gt;
     * This operator uses the default prefetch size returned by {@code Flowable.bufferSize()}.
     * &lt;p&gt;
     * The operator will call {@code Scheduler.createWorker()} as many
     * times as this ParallelFlowable's parallelism level is.
     * &lt;p&gt;
     * No assumptions are made about the Scheduler's parallelism level,
     * if the Scheduler's parallelism level is lower than the ParallelFlowable's,
     * some rails may end up on the same thread/worker.
     * &lt;p&gt;
     * This operator doesn't require the Scheduler to be trampolining as it
     * does its own built-in trampolining logic.
     *
     * @param scheduler the scheduler to use
     * @return the new ParallelFlowable instance
     */
    @CheckReturnValue
    @NonNull
    public final ParallelFlowable&lt;T&gt; runOn(@NonNull Scheduler scheduler) {
<span class="fc" id="L273">        return runOn(scheduler, Flowable.bufferSize());</span>
    }

    /**
     * Specifies where each 'rail' will observe its incoming values with
     * possibly work-stealing and a given prefetch amount.
     * &lt;p&gt;
     * This operator uses the default prefetch size returned by {@code Flowable.bufferSize()}.
     * &lt;p&gt;
     * The operator will call {@code Scheduler.createWorker()} as many
     * times as this ParallelFlowable's parallelism level is.
     * &lt;p&gt;
     * No assumptions are made about the Scheduler's parallelism level,
     * if the Scheduler's parallelism level is lower than the ParallelFlowable's,
     * some rails may end up on the same thread/worker.
     * &lt;p&gt;
     * This operator doesn't require the Scheduler to be trampolining as it
     * does its own built-in trampolining logic.
     *
     * @param scheduler the scheduler to use
     * that rail's worker has run out of work.
     * @param prefetch the number of values to request on each 'rail' from the source
     * @return the new ParallelFlowable instance
     */
    @CheckReturnValue
    @NonNull
    public final ParallelFlowable&lt;T&gt; runOn(@NonNull Scheduler scheduler, int prefetch) {
<span class="fc" id="L300">        ObjectHelper.requireNonNull(scheduler, &quot;scheduler&quot;);</span>
<span class="fc" id="L301">        ObjectHelper.verifyPositive(prefetch, &quot;prefetch&quot;);</span>
<span class="fc" id="L302">        return RxJavaPlugins.onAssembly(new ParallelRunOn&lt;T&gt;(this, scheduler, prefetch));</span>
    }

    /**
     * Reduces all values within a 'rail' and across 'rails' with a reducer function into a single
     * sequential value.
     * &lt;p&gt;
     * Note that the same reducer function may be called from multiple threads concurrently.
     * @param reducer the function to reduce two values into one.
     * @return the new Flowable instance emitting the reduced value or empty if the ParallelFlowable was empty
     */
    @CheckReturnValue
    @NonNull
    public final Flowable&lt;T&gt; reduce(@NonNull BiFunction&lt;T, T, T&gt; reducer) {
<span class="fc" id="L316">        ObjectHelper.requireNonNull(reducer, &quot;reducer&quot;);</span>
<span class="fc" id="L317">        return RxJavaPlugins.onAssembly(new ParallelReduceFull&lt;T&gt;(this, reducer));</span>
    }

    /**
     * Reduces all values within a 'rail' to a single value (with a possibly different type) via
     * a reducer function that is initialized on each rail from an initialSupplier value.
     * &lt;p&gt;
     * Note that the same mapper function may be called from multiple threads concurrently.
     * @param &lt;R&gt; the reduced output type
     * @param initialSupplier the supplier for the initial value
     * @param reducer the function to reduce a previous output of reduce (or the initial value supplied)
     * with a current source value.
     * @return the new ParallelFlowable instance
     */
    @CheckReturnValue
    @NonNull
    public final &lt;R&gt; ParallelFlowable&lt;R&gt; reduce(@NonNull Callable&lt;R&gt; initialSupplier, @NonNull BiFunction&lt;R, ? super T, R&gt; reducer) {
<span class="fc" id="L334">        ObjectHelper.requireNonNull(initialSupplier, &quot;initialSupplier&quot;);</span>
<span class="fc" id="L335">        ObjectHelper.requireNonNull(reducer, &quot;reducer&quot;);</span>
<span class="fc" id="L336">        return RxJavaPlugins.onAssembly(new ParallelReduce&lt;T, R&gt;(this, initialSupplier, reducer));</span>
    }

    /**
     * Merges the values from each 'rail' in a round-robin or same-order fashion and
     * exposes it as a regular Publisher sequence, running with a default prefetch value
     * for the rails.
     * &lt;p&gt;
     * This operator uses the default prefetch size returned by {@code Flowable.bufferSize()}.
     * &lt;img width=&quot;640&quot; height=&quot;602&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/parallelflowable.sequential.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code sequential} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @return the new Flowable instance
     * @see ParallelFlowable#sequential(int)
     * @see ParallelFlowable#sequentialDelayError()
     */
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    @CheckReturnValue
    public final Flowable&lt;T&gt; sequential() {
<span class="fc" id="L360">        return sequential(Flowable.bufferSize());</span>
    }

    /**
     * Merges the values from each 'rail' in a round-robin or same-order fashion and
     * exposes it as a regular Publisher sequence, running with a give prefetch value
     * for the rails.
     * &lt;img width=&quot;640&quot; height=&quot;602&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/parallelflowable.sequential.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code sequential} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param prefetch the prefetch amount to use for each rail
     * @return the new Flowable instance
     * @see ParallelFlowable#sequential()
     * @see ParallelFlowable#sequentialDelayError(int)
     */
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    @CheckReturnValue
    @NonNull
    public final Flowable&lt;T&gt; sequential(int prefetch) {
<span class="fc" id="L384">        ObjectHelper.verifyPositive(prefetch, &quot;prefetch&quot;);</span>
<span class="fc" id="L385">        return RxJavaPlugins.onAssembly(new ParallelJoin&lt;T&gt;(this, prefetch, false));</span>
    }

    /**
     * Merges the values from each 'rail' in a round-robin or same-order fashion and
     * exposes it as a regular Flowable sequence, running with a default prefetch value
     * for the rails and delaying errors from all rails till all terminate.
     * &lt;p&gt;
     * This operator uses the default prefetch size returned by {@code Flowable.bufferSize()}.
     * &lt;img width=&quot;640&quot; height=&quot;602&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/parallelflowable.sequential.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code sequentialDelayError} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * &lt;p&gt;History: 2.0.7 - experimental
     * @return the new Flowable instance
     * @see ParallelFlowable#sequentialDelayError(int)
     * @see ParallelFlowable#sequential()
     * @since 2.2
     */
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    @CheckReturnValue
    @NonNull
    public final Flowable&lt;T&gt; sequentialDelayError() {
<span class="fc" id="L412">        return sequentialDelayError(Flowable.bufferSize());</span>
    }

    /**
     * Merges the values from each 'rail' in a round-robin or same-order fashion and
     * exposes it as a regular Publisher sequence, running with a give prefetch value
     * for the rails and delaying errors from all rails till all terminate.
     * &lt;img width=&quot;640&quot; height=&quot;602&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/parallelflowable.sequential.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code sequentialDelayError} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * &lt;p&gt;History: 2.0.7 - experimental
     * @param prefetch the prefetch amount to use for each rail
     * @return the new Flowable instance
     * @see ParallelFlowable#sequential()
     * @see ParallelFlowable#sequentialDelayError()
     * @since 2.2
     */
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    @CheckReturnValue
    @NonNull
    public final Flowable&lt;T&gt; sequentialDelayError(int prefetch) {
<span class="fc" id="L438">        ObjectHelper.verifyPositive(prefetch, &quot;prefetch&quot;);</span>
<span class="fc" id="L439">        return RxJavaPlugins.onAssembly(new ParallelJoin&lt;T&gt;(this, prefetch, true));</span>
    }

    /**
     * Sorts the 'rails' of this ParallelFlowable and returns a Publisher that sequentially
     * picks the smallest next value from the rails.
     * &lt;p&gt;
     * This operator requires a finite source ParallelFlowable.
     *
     * @param comparator the comparator to use
     * @return the new Flowable instance
     */
    @CheckReturnValue
    @NonNull
    public final Flowable&lt;T&gt; sorted(@NonNull Comparator&lt;? super T&gt; comparator) {
<span class="fc" id="L454">        return sorted(comparator, 16);</span>
    }

    /**
     * Sorts the 'rails' of this ParallelFlowable and returns a Publisher that sequentially
     * picks the smallest next value from the rails.
     * &lt;p&gt;
     * This operator requires a finite source ParallelFlowable.
     *
     * @param comparator the comparator to use
     * @param capacityHint the expected number of total elements
     * @return the new Flowable instance
     */
    @CheckReturnValue
    @NonNull
    public final Flowable&lt;T&gt; sorted(@NonNull Comparator&lt;? super T&gt; comparator, int capacityHint) {
<span class="fc" id="L470">        ObjectHelper.requireNonNull(comparator, &quot;comparator is null&quot;);</span>
<span class="fc" id="L471">        ObjectHelper.verifyPositive(capacityHint, &quot;capacityHint&quot;);</span>
<span class="fc" id="L472">        int ch = capacityHint / parallelism() + 1;</span>
<span class="fc" id="L473">        ParallelFlowable&lt;List&lt;T&gt;&gt; railReduced = reduce(Functions.&lt;T&gt;createArrayList(ch), ListAddBiConsumer.&lt;T&gt;instance());</span>
<span class="fc" id="L474">        ParallelFlowable&lt;List&lt;T&gt;&gt; railSorted = railReduced.map(new SorterFunction&lt;T&gt;(comparator));</span>

<span class="fc" id="L476">        return RxJavaPlugins.onAssembly(new ParallelSortedJoin&lt;T&gt;(railSorted, comparator));</span>
    }

    /**
     * Sorts the 'rails' according to the comparator and returns a full sorted list as a Publisher.
     * &lt;p&gt;
     * This operator requires a finite source ParallelFlowable.
     *
     * @param comparator the comparator to compare elements
     * @return the new Flowable instance
     */
    @CheckReturnValue
    @NonNull
    public final Flowable&lt;List&lt;T&gt;&gt; toSortedList(@NonNull Comparator&lt;? super T&gt; comparator) {
<span class="fc" id="L490">        return toSortedList(comparator, 16);</span>
    }
    /**
     * Sorts the 'rails' according to the comparator and returns a full sorted list as a Publisher.
     * &lt;p&gt;
     * This operator requires a finite source ParallelFlowable.
     *
     * @param comparator the comparator to compare elements
     * @param capacityHint the expected number of total elements
     * @return the new Flowable instance
     */
    @CheckReturnValue
    @NonNull
    public final Flowable&lt;List&lt;T&gt;&gt; toSortedList(@NonNull Comparator&lt;? super T&gt; comparator, int capacityHint) {
<span class="fc" id="L504">        ObjectHelper.requireNonNull(comparator, &quot;comparator is null&quot;);</span>
<span class="fc" id="L505">        ObjectHelper.verifyPositive(capacityHint, &quot;capacityHint&quot;);</span>

<span class="fc" id="L507">        int ch = capacityHint / parallelism() + 1;</span>
<span class="fc" id="L508">        ParallelFlowable&lt;List&lt;T&gt;&gt; railReduced = reduce(Functions.&lt;T&gt;createArrayList(ch), ListAddBiConsumer.&lt;T&gt;instance());</span>
<span class="fc" id="L509">        ParallelFlowable&lt;List&lt;T&gt;&gt; railSorted = railReduced.map(new SorterFunction&lt;T&gt;(comparator));</span>

<span class="fc" id="L511">        Flowable&lt;List&lt;T&gt;&gt; merged = railSorted.reduce(new MergerBiFunction&lt;T&gt;(comparator));</span>

<span class="fc" id="L513">        return RxJavaPlugins.onAssembly(merged);</span>
    }

    /**
     * Call the specified consumer with the current element passing through any 'rail'.
     *
     * @param onNext the callback
     * @return the new ParallelFlowable instance
     */
    @CheckReturnValue
    @NonNull
    public final ParallelFlowable&lt;T&gt; doOnNext(@NonNull Consumer&lt;? super T&gt; onNext) {
<span class="fc" id="L525">        ObjectHelper.requireNonNull(onNext, &quot;onNext is null&quot;);</span>
<span class="fc" id="L526">        return RxJavaPlugins.onAssembly(new ParallelPeek&lt;T&gt;(this,</span>
                onNext,
<span class="fc" id="L528">                Functions.emptyConsumer(),</span>
<span class="fc" id="L529">                Functions.emptyConsumer(),</span>
                Functions.EMPTY_ACTION,
                Functions.EMPTY_ACTION,
<span class="fc" id="L532">                Functions.emptyConsumer(),</span>
                Functions.EMPTY_LONG_CONSUMER,
                Functions.EMPTY_ACTION
                ));
    }

    /**
     * Call the specified consumer with the current element passing through any 'rail' and
     * handles errors based on the given {@link ParallelFailureHandling} enumeration value.
     * &lt;p&gt;History: 2.0.8 - experimental
     * @param onNext the callback
     * @param errorHandler the enumeration that defines how to handle errors thrown
     *                     from the onNext consumer
     * @return the new ParallelFlowable instance
     * @since 2.2
     */
    @CheckReturnValue
    @NonNull
    public final ParallelFlowable&lt;T&gt; doOnNext(@NonNull Consumer&lt;? super T&gt; onNext, @NonNull ParallelFailureHandling errorHandler) {
<span class="fc" id="L551">        ObjectHelper.requireNonNull(onNext, &quot;onNext is null&quot;);</span>
<span class="fc" id="L552">        ObjectHelper.requireNonNull(errorHandler, &quot;errorHandler is null&quot;);</span>
<span class="fc" id="L553">        return RxJavaPlugins.onAssembly(new ParallelDoOnNextTry&lt;T&gt;(this, onNext, errorHandler));</span>
    }

    /**
     * Call the specified consumer with the current element passing through any 'rail' and
     * handles errors based on the returned value by the handler function.
     * &lt;p&gt;History: 2.0.8 - experimental
     * @param onNext the callback
     * @param errorHandler the function called with the current repeat count and
     *                     failure Throwable and should return one of the {@link ParallelFailureHandling}
     *                     enumeration values to indicate how to proceed.
     * @return the new ParallelFlowable instance
     * @since 2.2
     */
    @CheckReturnValue
    @NonNull
    public final ParallelFlowable&lt;T&gt; doOnNext(@NonNull Consumer&lt;? super T&gt; onNext, @NonNull BiFunction&lt;? super Long, ? super Throwable, ParallelFailureHandling&gt; errorHandler) {
<span class="fc" id="L570">        ObjectHelper.requireNonNull(onNext, &quot;onNext is null&quot;);</span>
<span class="fc" id="L571">        ObjectHelper.requireNonNull(errorHandler, &quot;errorHandler is null&quot;);</span>
<span class="fc" id="L572">        return RxJavaPlugins.onAssembly(new ParallelDoOnNextTry&lt;T&gt;(this, onNext, errorHandler));</span>
    }

    /**
     * Call the specified consumer with the current element passing through any 'rail'
     * after it has been delivered to downstream within the rail.
     *
     * @param onAfterNext the callback
     * @return the new ParallelFlowable instance
     */
    @CheckReturnValue
    @NonNull
    public final ParallelFlowable&lt;T&gt; doAfterNext(@NonNull Consumer&lt;? super T&gt; onAfterNext) {
<span class="fc" id="L585">        ObjectHelper.requireNonNull(onAfterNext, &quot;onAfterNext is null&quot;);</span>
<span class="fc" id="L586">        return RxJavaPlugins.onAssembly(new ParallelPeek&lt;T&gt;(this,</span>
<span class="fc" id="L587">                Functions.emptyConsumer(),</span>
                onAfterNext,
<span class="fc" id="L589">                Functions.emptyConsumer(),</span>
                Functions.EMPTY_ACTION,
                Functions.EMPTY_ACTION,
<span class="fc" id="L592">                Functions.emptyConsumer(),</span>
                Functions.EMPTY_LONG_CONSUMER,
                Functions.EMPTY_ACTION
                ));
    }

    /**
     * Call the specified consumer with the exception passing through any 'rail'.
     *
     * @param onError the callback
     * @return the new ParallelFlowable instance
     */
    @CheckReturnValue
    @NonNull
    public final ParallelFlowable&lt;T&gt; doOnError(@NonNull Consumer&lt;Throwable&gt; onError) {
<span class="fc" id="L607">        ObjectHelper.requireNonNull(onError, &quot;onError is null&quot;);</span>
<span class="fc" id="L608">        return RxJavaPlugins.onAssembly(new ParallelPeek&lt;T&gt;(this,</span>
<span class="fc" id="L609">                Functions.emptyConsumer(),</span>
<span class="fc" id="L610">                Functions.emptyConsumer(),</span>
                onError,
                Functions.EMPTY_ACTION,
                Functions.EMPTY_ACTION,
<span class="fc" id="L614">                Functions.emptyConsumer(),</span>
                Functions.EMPTY_LONG_CONSUMER,
                Functions.EMPTY_ACTION
                ));
    }

    /**
     * Run the specified Action when a 'rail' completes.
     *
     * @param onComplete the callback
     * @return the new ParallelFlowable instance
     */
    @CheckReturnValue
    @NonNull
    public final ParallelFlowable&lt;T&gt; doOnComplete(@NonNull Action onComplete) {
<span class="fc" id="L629">        ObjectHelper.requireNonNull(onComplete, &quot;onComplete is null&quot;);</span>
<span class="fc" id="L630">        return RxJavaPlugins.onAssembly(new ParallelPeek&lt;T&gt;(this,</span>
<span class="fc" id="L631">                Functions.emptyConsumer(),</span>
<span class="fc" id="L632">                Functions.emptyConsumer(),</span>
<span class="fc" id="L633">                Functions.emptyConsumer(),</span>
                onComplete,
                Functions.EMPTY_ACTION,
<span class="fc" id="L636">                Functions.emptyConsumer(),</span>
                Functions.EMPTY_LONG_CONSUMER,
                Functions.EMPTY_ACTION
                ));
    }

    /**
     * Run the specified Action when a 'rail' completes or signals an error.
     *
     * @param onAfterTerminate the callback
     * @return the new ParallelFlowable instance
     */
    @CheckReturnValue
    @NonNull
    public final ParallelFlowable&lt;T&gt; doAfterTerminated(@NonNull Action onAfterTerminate) {
<span class="fc" id="L651">        ObjectHelper.requireNonNull(onAfterTerminate, &quot;onAfterTerminate is null&quot;);</span>
<span class="fc" id="L652">        return RxJavaPlugins.onAssembly(new ParallelPeek&lt;T&gt;(this,</span>
<span class="fc" id="L653">                Functions.emptyConsumer(),</span>
<span class="fc" id="L654">                Functions.emptyConsumer(),</span>
<span class="fc" id="L655">                Functions.emptyConsumer(),</span>
                Functions.EMPTY_ACTION,
                onAfterTerminate,
<span class="fc" id="L658">                Functions.emptyConsumer(),</span>
                Functions.EMPTY_LONG_CONSUMER,
                Functions.EMPTY_ACTION
                ));
    }

    /**
     * Call the specified callback when a 'rail' receives a Subscription from its upstream.
     *
     * @param onSubscribe the callback
     * @return the new ParallelFlowable instance
     */
    @CheckReturnValue
    @NonNull
    public final ParallelFlowable&lt;T&gt; doOnSubscribe(@NonNull Consumer&lt;? super Subscription&gt; onSubscribe) {
<span class="fc" id="L673">        ObjectHelper.requireNonNull(onSubscribe, &quot;onSubscribe is null&quot;);</span>
<span class="fc" id="L674">        return RxJavaPlugins.onAssembly(new ParallelPeek&lt;T&gt;(this,</span>
<span class="fc" id="L675">                Functions.emptyConsumer(),</span>
<span class="fc" id="L676">                Functions.emptyConsumer(),</span>
<span class="fc" id="L677">                Functions.emptyConsumer(),</span>
                Functions.EMPTY_ACTION,
                Functions.EMPTY_ACTION,
                onSubscribe,
                Functions.EMPTY_LONG_CONSUMER,
                Functions.EMPTY_ACTION
                ));
    }

    /**
     * Call the specified consumer with the request amount if any rail receives a request.
     *
     * @param onRequest the callback
     * @return the new ParallelFlowable instance
     */
    @CheckReturnValue
    @NonNull
    public final ParallelFlowable&lt;T&gt; doOnRequest(@NonNull LongConsumer onRequest) {
<span class="fc" id="L695">        ObjectHelper.requireNonNull(onRequest, &quot;onRequest is null&quot;);</span>
<span class="fc" id="L696">        return RxJavaPlugins.onAssembly(new ParallelPeek&lt;T&gt;(this,</span>
<span class="fc" id="L697">                Functions.emptyConsumer(),</span>
<span class="fc" id="L698">                Functions.emptyConsumer(),</span>
<span class="fc" id="L699">                Functions.emptyConsumer(),</span>
                Functions.EMPTY_ACTION,
                Functions.EMPTY_ACTION,
<span class="fc" id="L702">                Functions.emptyConsumer(),</span>
                onRequest,
                Functions.EMPTY_ACTION
                ));
    }

    /**
     * Run the specified Action when a 'rail' receives a cancellation.
     *
     * @param onCancel the callback
     * @return the new ParallelFlowable instance
     */
    @CheckReturnValue
    @NonNull
    public final ParallelFlowable&lt;T&gt; doOnCancel(@NonNull Action onCancel) {
<span class="fc" id="L717">        ObjectHelper.requireNonNull(onCancel, &quot;onCancel is null&quot;);</span>
<span class="fc" id="L718">        return RxJavaPlugins.onAssembly(new ParallelPeek&lt;T&gt;(this,</span>
<span class="fc" id="L719">                Functions.emptyConsumer(),</span>
<span class="fc" id="L720">                Functions.emptyConsumer(),</span>
<span class="fc" id="L721">                Functions.emptyConsumer(),</span>
                Functions.EMPTY_ACTION,
                Functions.EMPTY_ACTION,
<span class="fc" id="L724">                Functions.emptyConsumer(),</span>
                Functions.EMPTY_LONG_CONSUMER,
                onCancel
                ));
    }

    /**
     * Collect the elements in each rail into a collection supplied via a collectionSupplier
     * and collected into with a collector action, emitting the collection at the end.
     *
     * @param &lt;C&gt; the collection type
     * @param collectionSupplier the supplier of the collection in each rail
     * @param collector the collector, taking the per-rail collection and the current item
     * @return the new ParallelFlowable instance
     */
    @CheckReturnValue
    @NonNull
    public final &lt;C&gt; ParallelFlowable&lt;C&gt; collect(@NonNull Callable&lt;? extends C&gt; collectionSupplier, @NonNull BiConsumer&lt;? super C, ? super T&gt; collector) {
<span class="fc" id="L742">        ObjectHelper.requireNonNull(collectionSupplier, &quot;collectionSupplier is null&quot;);</span>
<span class="fc" id="L743">        ObjectHelper.requireNonNull(collector, &quot;collector is null&quot;);</span>
<span class="fc" id="L744">        return RxJavaPlugins.onAssembly(new ParallelCollect&lt;T, C&gt;(this, collectionSupplier, collector));</span>
    }

    /**
     * Wraps multiple Publishers into a ParallelFlowable which runs them
     * in parallel and unordered.
     *
     * @param &lt;T&gt; the value type
     * @param publishers the array of publishers
     * @return the new ParallelFlowable instance
     */
    @CheckReturnValue
    @NonNull
    public static &lt;T&gt; ParallelFlowable&lt;T&gt; fromArray(@NonNull Publisher&lt;T&gt;... publishers) {
<span class="fc bfc" id="L758" title="All 2 branches covered.">        if (publishers.length == 0) {</span>
<span class="fc" id="L759">            throw new IllegalArgumentException(&quot;Zero publishers not supported&quot;);</span>
        }
<span class="fc" id="L761">        return RxJavaPlugins.onAssembly(new ParallelFromArray&lt;T&gt;(publishers));</span>
    }

    /**
     * Perform a fluent transformation to a value via a converter function which
     * receives this ParallelFlowable.
     *
     * @param &lt;U&gt; the output value type
     * @param converter the converter function from ParallelFlowable to some type
     * @return the value returned by the converter function
     */
    @CheckReturnValue
    @NonNull
    public final &lt;U&gt; U to(@NonNull Function&lt;? super ParallelFlowable&lt;T&gt;, U&gt; converter) {
        try {
<span class="fc" id="L776">            return ObjectHelper.requireNonNull(converter, &quot;converter is null&quot;).apply(this);</span>
<span class="fc" id="L777">        } catch (Throwable ex) {</span>
<span class="fc" id="L778">            Exceptions.throwIfFatal(ex);</span>
<span class="fc" id="L779">            throw ExceptionHelper.wrapOrThrow(ex);</span>
        }
    }

    /**
     * Allows composing operators, in assembly time, on top of this ParallelFlowable
     * and returns another ParallelFlowable with composed features.
     *
     * @param &lt;U&gt; the output value type
     * @param composer the composer function from ParallelFlowable (this) to another ParallelFlowable
     * @return the ParallelFlowable returned by the function
     */
    @CheckReturnValue
    @NonNull
    public final &lt;U&gt; ParallelFlowable&lt;U&gt; compose(@NonNull ParallelTransformer&lt;T, U&gt; composer) {
<span class="fc" id="L794">        return RxJavaPlugins.onAssembly(ObjectHelper.requireNonNull(composer, &quot;composer is null&quot;).apply(this));</span>
    }

    /**
     * Generates and flattens Publishers on each 'rail'.
     * &lt;p&gt;
     * Errors are not delayed and uses unbounded concurrency along with default inner prefetch.
     *
     * @param &lt;R&gt; the result type
     * @param mapper the function to map each rail's value into a Publisher
     * @return the new ParallelFlowable instance
     */
    @CheckReturnValue
    @NonNull
    public final &lt;R&gt; ParallelFlowable&lt;R&gt; flatMap(@NonNull Function&lt;? super T, ? extends Publisher&lt;? extends R&gt;&gt; mapper) {
<span class="fc" id="L809">        return flatMap(mapper, false, Integer.MAX_VALUE, Flowable.bufferSize());</span>
    }

    /**
     * Generates and flattens Publishers on each 'rail', optionally delaying errors.
     * &lt;p&gt;
     * It uses unbounded concurrency along with default inner prefetch.
     *
     * @param &lt;R&gt; the result type
     * @param mapper the function to map each rail's value into a Publisher
     * @param delayError should the errors from the main and the inner sources delayed till everybody terminates?
     * @return the new ParallelFlowable instance
     */
    @CheckReturnValue
    @NonNull
    public final &lt;R&gt; ParallelFlowable&lt;R&gt; flatMap(
            @NonNull Function&lt;? super T, ? extends Publisher&lt;? extends R&gt;&gt; mapper, boolean delayError) {
<span class="fc" id="L826">        return flatMap(mapper, delayError, Integer.MAX_VALUE, Flowable.bufferSize());</span>
    }

    /**
     * Generates and flattens Publishers on each 'rail', optionally delaying errors
     * and having a total number of simultaneous subscriptions to the inner Publishers.
     * &lt;p&gt;
     * It uses a default inner prefetch.
     *
     * @param &lt;R&gt; the result type
     * @param mapper the function to map each rail's value into a Publisher
     * @param delayError should the errors from the main and the inner sources delayed till everybody terminates?
     * @param maxConcurrency the maximum number of simultaneous subscriptions to the generated inner Publishers
     * @return the new ParallelFlowable instance
     */
    @CheckReturnValue
    @NonNull
    public final &lt;R&gt; ParallelFlowable&lt;R&gt; flatMap(
            @NonNull Function&lt;? super T, ? extends Publisher&lt;? extends R&gt;&gt; mapper, boolean delayError, int maxConcurrency) {
<span class="fc" id="L845">        return flatMap(mapper, delayError, maxConcurrency, Flowable.bufferSize());</span>
    }

    /**
     * Generates and flattens Publishers on each 'rail', optionally delaying errors,
     * having a total number of simultaneous subscriptions to the inner Publishers
     * and using the given prefetch amount for the inner Publishers.
     *
     * @param &lt;R&gt; the result type
     * @param mapper the function to map each rail's value into a Publisher
     * @param delayError should the errors from the main and the inner sources delayed till everybody terminates?
     * @param maxConcurrency the maximum number of simultaneous subscriptions to the generated inner Publishers
     * @param prefetch the number of items to prefetch from each inner Publisher
     * @return the new ParallelFlowable instance
     */
    @CheckReturnValue
    @NonNull
    public final &lt;R&gt; ParallelFlowable&lt;R&gt; flatMap(
            @NonNull Function&lt;? super T, ? extends Publisher&lt;? extends R&gt;&gt; mapper,
            boolean delayError, int maxConcurrency, int prefetch) {
<span class="fc" id="L865">        ObjectHelper.requireNonNull(mapper, &quot;mapper is null&quot;);</span>
<span class="fc" id="L866">        ObjectHelper.verifyPositive(maxConcurrency, &quot;maxConcurrency&quot;);</span>
<span class="fc" id="L867">        ObjectHelper.verifyPositive(prefetch, &quot;prefetch&quot;);</span>
<span class="fc" id="L868">        return RxJavaPlugins.onAssembly(new ParallelFlatMap&lt;T, R&gt;(this, mapper, delayError, maxConcurrency, prefetch));</span>
    }

    /**
     * Generates and concatenates Publishers on each 'rail', signalling errors immediately
     * and generating 2 publishers upfront.
     *
     * @param &lt;R&gt; the result type
     * @param mapper the function to map each rail's value into a Publisher
     * source and the inner Publishers (immediate, boundary, end)
     * @return the new ParallelFlowable instance
     */
    @CheckReturnValue
    @NonNull
    public final &lt;R&gt; ParallelFlowable&lt;R&gt; concatMap(
            @NonNull Function&lt;? super T, ? extends Publisher&lt;? extends R&gt;&gt; mapper) {
<span class="fc" id="L884">        return concatMap(mapper, 2);</span>
    }

    /**
     * Generates and concatenates Publishers on each 'rail', signalling errors immediately
     * and using the given prefetch amount for generating Publishers upfront.
     *
     * @param &lt;R&gt; the result type
     * @param mapper the function to map each rail's value into a Publisher
     * @param prefetch the number of items to prefetch from each inner Publisher
     * source and the inner Publishers (immediate, boundary, end)
     * @return the new ParallelFlowable instance
     */
    @CheckReturnValue
    @NonNull
    public final &lt;R&gt; ParallelFlowable&lt;R&gt; concatMap(
            @NonNull Function&lt;? super T, ? extends Publisher&lt;? extends R&gt;&gt; mapper,
                    int prefetch) {
<span class="fc" id="L902">        ObjectHelper.requireNonNull(mapper, &quot;mapper is null&quot;);</span>
<span class="fc" id="L903">        ObjectHelper.verifyPositive(prefetch, &quot;prefetch&quot;);</span>
<span class="fc" id="L904">        return RxJavaPlugins.onAssembly(new ParallelConcatMap&lt;T, R&gt;(this, mapper, prefetch, ErrorMode.IMMEDIATE));</span>
    }

    /**
     * Generates and concatenates Publishers on each 'rail', optionally delaying errors
     * and generating 2 publishers upfront.
     *
     * @param &lt;R&gt; the result type
     * @param mapper the function to map each rail's value into a Publisher
     * @param tillTheEnd if true all errors from the upstream and inner Publishers are delayed
     * till all of them terminate, if false, the error is emitted when an inner Publisher terminates.
     * source and the inner Publishers (immediate, boundary, end)
     * @return the new ParallelFlowable instance
     */
    @CheckReturnValue
    @NonNull
    public final &lt;R&gt; ParallelFlowable&lt;R&gt; concatMapDelayError(
            @NonNull Function&lt;? super T, ? extends Publisher&lt;? extends R&gt;&gt; mapper,
                    boolean tillTheEnd) {
<span class="fc" id="L923">        return concatMapDelayError(mapper, 2, tillTheEnd);</span>
    }

    /**
     * Generates and concatenates Publishers on each 'rail', optionally delaying errors
     * and using the given prefetch amount for generating Publishers upfront.
     *
     * @param &lt;R&gt; the result type
     * @param mapper the function to map each rail's value into a Publisher
     * @param prefetch the number of items to prefetch from each inner Publisher
     * @param tillTheEnd if true all errors from the upstream and inner Publishers are delayed
     * till all of them terminate, if false, the error is emitted when an inner Publisher terminates.
     * @return the new ParallelFlowable instance
     */
    @CheckReturnValue
    @NonNull
    public final &lt;R&gt; ParallelFlowable&lt;R&gt; concatMapDelayError(
            @NonNull Function&lt;? super T, ? extends Publisher&lt;? extends R&gt;&gt; mapper,
                    int prefetch, boolean tillTheEnd) {
<span class="fc" id="L942">        ObjectHelper.requireNonNull(mapper, &quot;mapper is null&quot;);</span>
<span class="fc" id="L943">        ObjectHelper.verifyPositive(prefetch, &quot;prefetch&quot;);</span>
<span class="fc bfc" id="L944" title="All 2 branches covered.">        return RxJavaPlugins.onAssembly(new ParallelConcatMap&lt;T, R&gt;(</span>
                this, mapper, prefetch, tillTheEnd ? ErrorMode.END : ErrorMode.BOUNDARY));
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>