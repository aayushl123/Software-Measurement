<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ParallelFlowableTest.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">RxJava_2_x$Unnamed.exec</a> &gt; <a href="index.source.html" class="el_package">io.reactivex.parallel</a> &gt; <span class="el_source">ParallelFlowableTest.java</span></div><h1>ParallelFlowableTest.java</h1><pre class="source lang-java linenums">/**
 * Copyright (c) 2016-present, RxJava Contributors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is
 * distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
 * the License for the specific language governing permissions and limitations under the License.
 */

package io.reactivex.parallel;

import static org.junit.Assert.*;

import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;

import org.junit.*;
import org.reactivestreams.*;

import io.reactivex.*;
import io.reactivex.exceptions.*;
import io.reactivex.functions.*;
import io.reactivex.internal.functions.Functions;
import io.reactivex.internal.util.*;
import io.reactivex.plugins.RxJavaPlugins;
import io.reactivex.processors.UnicastProcessor;
import io.reactivex.schedulers.Schedulers;
import io.reactivex.subscribers.TestSubscriber;

<span class="fc" id="L35">public class ParallelFlowableTest {</span>

    @Test
    public void sequentialMode() {
<span class="fc" id="L39">        Flowable&lt;Integer&gt; source = Flowable.range(1, 1000000).hide();</span>
<span class="fc bfc" id="L40" title="All 2 branches covered.">        for (int i = 1; i &lt; 33; i++) {</span>
<span class="fc" id="L41">            Flowable&lt;Integer&gt; result = ParallelFlowable.from(source, i)</span>
<span class="fc" id="L42">            .map(new Function&lt;Integer, Integer&gt;() {</span>
                @Override
                public Integer apply(Integer v) throws Exception {
<span class="fc" id="L45">                    return v + 1;</span>
                }
            })
<span class="fc" id="L48">            .sequential()</span>
            ;

<span class="fc" id="L51">            TestSubscriber&lt;Integer&gt; ts = new TestSubscriber&lt;Integer&gt;();</span>

<span class="fc" id="L53">            result.subscribe(ts);</span>

<span class="fc" id="L55">            ts</span>
<span class="fc" id="L56">            .assertSubscribed()</span>
<span class="fc" id="L57">            .assertValueCount(1000000)</span>
<span class="fc" id="L58">            .assertComplete()</span>
<span class="fc" id="L59">            .assertNoErrors()</span>
            ;
        }

<span class="fc" id="L63">    }</span>

    @Test
    public void sequentialModeFused() {
<span class="fc" id="L67">        Flowable&lt;Integer&gt; source = Flowable.range(1, 1000000);</span>
<span class="fc bfc" id="L68" title="All 2 branches covered.">        for (int i = 1; i &lt; 33; i++) {</span>
<span class="fc" id="L69">            Flowable&lt;Integer&gt; result = ParallelFlowable.from(source, i)</span>
<span class="fc" id="L70">            .map(new Function&lt;Integer, Integer&gt;() {</span>
                @Override
                public Integer apply(Integer v) throws Exception {
<span class="fc" id="L73">                    return v + 1;</span>
                }
            })
<span class="fc" id="L76">            .sequential()</span>
            ;

<span class="fc" id="L79">            TestSubscriber&lt;Integer&gt; ts = new TestSubscriber&lt;Integer&gt;();</span>

<span class="fc" id="L81">            result.subscribe(ts);</span>

<span class="fc" id="L83">            ts</span>
<span class="fc" id="L84">            .assertSubscribed()</span>
<span class="fc" id="L85">            .assertValueCount(1000000)</span>
<span class="fc" id="L86">            .assertComplete()</span>
<span class="fc" id="L87">            .assertNoErrors()</span>
            ;
        }

<span class="fc" id="L91">    }</span>

    @Test
    public void parallelMode() {
<span class="fc" id="L95">        Flowable&lt;Integer&gt; source = Flowable.range(1, 1000000).hide();</span>
<span class="fc" id="L96">        int ncpu = Math.max(8, Runtime.getRuntime().availableProcessors());</span>
<span class="fc bfc" id="L97" title="All 2 branches covered.">        for (int i = 1; i &lt; ncpu + 1; i++) {</span>

<span class="fc" id="L99">            ExecutorService exec = Executors.newFixedThreadPool(i);</span>

<span class="fc" id="L101">            Scheduler scheduler = Schedulers.from(exec);</span>

            try {
<span class="fc" id="L104">                Flowable&lt;Integer&gt; result = ParallelFlowable.from(source, i)</span>
<span class="fc" id="L105">                .runOn(scheduler)</span>
<span class="fc" id="L106">                .map(new Function&lt;Integer, Integer&gt;() {</span>
                    @Override
                    public Integer apply(Integer v) throws Exception {
<span class="fc" id="L109">                        return v + 1;</span>
                    }
                })
<span class="fc" id="L112">                .sequential()</span>
                ;

<span class="fc" id="L115">                TestSubscriber&lt;Integer&gt; ts = new TestSubscriber&lt;Integer&gt;();</span>

<span class="fc" id="L117">                result.subscribe(ts);</span>

<span class="fc" id="L119">                ts.awaitDone(10, TimeUnit.SECONDS);</span>

<span class="fc" id="L121">                ts</span>
<span class="fc" id="L122">                .assertSubscribed()</span>
<span class="fc" id="L123">                .assertValueCount(1000000)</span>
<span class="fc" id="L124">                .assertComplete()</span>
<span class="fc" id="L125">                .assertNoErrors()</span>
                ;
            } finally {
<span class="fc" id="L128">                exec.shutdown();</span>
            }
        }

<span class="fc" id="L132">    }</span>

    @Test
    public void parallelModeFused() {
<span class="fc" id="L136">        Flowable&lt;Integer&gt; source = Flowable.range(1, 1000000);</span>
<span class="fc" id="L137">        int ncpu = Math.max(8, Runtime.getRuntime().availableProcessors());</span>
<span class="fc bfc" id="L138" title="All 2 branches covered.">        for (int i = 1; i &lt; ncpu + 1; i++) {</span>

<span class="fc" id="L140">            ExecutorService exec = Executors.newFixedThreadPool(i);</span>

<span class="fc" id="L142">            Scheduler scheduler = Schedulers.from(exec);</span>

            try {
<span class="fc" id="L145">                Flowable&lt;Integer&gt; result = ParallelFlowable.from(source, i)</span>
<span class="fc" id="L146">                .runOn(scheduler)</span>
<span class="fc" id="L147">                .map(new Function&lt;Integer, Integer&gt;() {</span>
                    @Override
                    public Integer apply(Integer v) throws Exception {
<span class="fc" id="L150">                        return v + 1;</span>
                    }
                })
<span class="fc" id="L153">                .sequential()</span>
                ;

<span class="fc" id="L156">                TestSubscriber&lt;Integer&gt; ts = new TestSubscriber&lt;Integer&gt;();</span>

<span class="fc" id="L158">                result.subscribe(ts);</span>

<span class="fc" id="L160">                ts.awaitDone(10, TimeUnit.SECONDS);</span>

<span class="fc" id="L162">                ts</span>
<span class="fc" id="L163">                .assertSubscribed()</span>
<span class="fc" id="L164">                .assertValueCount(1000000)</span>
<span class="fc" id="L165">                .assertComplete()</span>
<span class="fc" id="L166">                .assertNoErrors()</span>
                ;
            } finally {
<span class="fc" id="L169">                exec.shutdown();</span>
            }
        }

<span class="fc" id="L173">    }</span>

    @Test
    public void reduceFull() {
<span class="fc bfc" id="L177" title="All 2 branches covered.">        for (int i = 1; i &lt;= Runtime.getRuntime().availableProcessors() * 2; i++) {</span>
<span class="fc" id="L178">            TestSubscriber&lt;Integer&gt; ts = new TestSubscriber&lt;Integer&gt;();</span>

<span class="fc" id="L180">            Flowable.range(1, 10)</span>
<span class="fc" id="L181">            .parallel(i)</span>
<span class="fc" id="L182">            .reduce(new BiFunction&lt;Integer, Integer, Integer&gt;() {</span>
                @Override
                public Integer apply(Integer a, Integer b) throws Exception {
<span class="fc" id="L185">                    return a + b;</span>
                }
            })
<span class="fc" id="L188">            .subscribe(ts);</span>

<span class="fc" id="L190">            ts.assertResult(55);</span>
        }
<span class="fc" id="L192">    }</span>

    @Test
    public void parallelReduceFull() {
<span class="fc" id="L196">        int m = 100000;</span>
<span class="fc bfc" id="L197" title="All 2 branches covered.">        for (int n = 1; n &lt;= m; n *= 10) {</span>
//            System.out.println(n);
<span class="fc bfc" id="L199" title="All 2 branches covered.">            for (int i = 1; i &lt;= Runtime.getRuntime().availableProcessors(); i++) {</span>
//                System.out.println(&quot;  &quot; + i);

<span class="fc" id="L202">                ExecutorService exec = Executors.newFixedThreadPool(i);</span>

<span class="fc" id="L204">                Scheduler scheduler = Schedulers.from(exec);</span>

                try {
<span class="fc" id="L207">                    TestSubscriber&lt;Long&gt; ts = new TestSubscriber&lt;Long&gt;();</span>

<span class="fc" id="L209">                    Flowable.range(1, n)</span>
<span class="fc" id="L210">                    .map(new Function&lt;Integer, Long&gt;() {</span>
                        @Override
                        public Long apply(Integer v) throws Exception {
<span class="fc" id="L213">                            return (long)v;</span>
                        }
                    })
<span class="fc" id="L216">                    .parallel(i)</span>
<span class="fc" id="L217">                    .runOn(scheduler)</span>
<span class="fc" id="L218">                    .reduce(new BiFunction&lt;Long, Long, Long&gt;() {</span>
                        @Override
                        public Long apply(Long a, Long b) throws Exception {
<span class="fc" id="L221">                            return a + b;</span>
                        }
                    })
<span class="fc" id="L224">                    .subscribe(ts);</span>

<span class="fc" id="L226">                    ts.awaitDone(500, TimeUnit.SECONDS);</span>

<span class="fc" id="L228">                    long e = ((long)n) * (1 + n) / 2;</span>

<span class="fc" id="L230">                    ts.assertResult(e);</span>
                } finally {
<span class="fc" id="L232">                    exec.shutdown();</span>
                }
            }
        }
<span class="fc" id="L236">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void toSortedList() {
<span class="fc" id="L241">        TestSubscriber&lt;List&lt;Integer&gt;&gt; ts = new TestSubscriber&lt;List&lt;Integer&gt;&gt;();</span>

<span class="fc" id="L243">        Flowable.fromArray(10, 9, 8, 7, 6, 5, 4, 3, 2, 1)</span>
<span class="fc" id="L244">        .parallel()</span>
<span class="fc" id="L245">        .toSortedList(Functions.naturalComparator())</span>
<span class="fc" id="L246">        .subscribe(ts);</span>

<span class="fc" id="L248">        ts.assertResult(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10));</span>
<span class="fc" id="L249">    }</span>

    @Test
    public void sorted() {
<span class="fc" id="L253">        TestSubscriber&lt;Integer&gt; ts = new TestSubscriber&lt;Integer&gt;(0);</span>

<span class="fc" id="L255">        Flowable.fromArray(10, 9, 8, 7, 6, 5, 4, 3, 2, 1)</span>
<span class="fc" id="L256">        .parallel()</span>
<span class="fc" id="L257">        .sorted(Functions.naturalComparator())</span>
<span class="fc" id="L258">        .subscribe(ts);</span>

<span class="fc" id="L260">        ts.assertNoValues();</span>

<span class="fc" id="L262">        ts.request(2);</span>

<span class="fc" id="L264">        ts.assertValues(1, 2);</span>

<span class="fc" id="L266">        ts.request(5);</span>

<span class="fc" id="L268">        ts.assertValues(1, 2, 3, 4, 5, 6, 7);</span>

<span class="fc" id="L270">        ts.request(3);</span>

<span class="fc" id="L272">        ts.assertResult(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);</span>
<span class="fc" id="L273">    }</span>

    @Test
    public void collect() {
<span class="fc" id="L277">        Callable&lt;List&lt;Integer&gt;&gt; as = new Callable&lt;List&lt;Integer&gt;&gt;() {</span>
            @Override
            public List&lt;Integer&gt; call() throws Exception {
<span class="fc" id="L280">                return new ArrayList&lt;Integer&gt;();</span>
            }
        };

<span class="fc" id="L284">        TestSubscriber&lt;Integer&gt; ts = new TestSubscriber&lt;Integer&gt;();</span>
<span class="fc" id="L285">        Flowable.range(1, 10)</span>
<span class="fc" id="L286">        .parallel()</span>
<span class="fc" id="L287">        .collect(as, new BiConsumer&lt;List&lt;Integer&gt;, Integer&gt;() {</span>
            @Override
            public void accept(List&lt;Integer&gt; a, Integer b) throws Exception {
<span class="fc" id="L290">                a.add(b);</span>
<span class="fc" id="L291">            }</span>
        })
<span class="fc" id="L293">        .sequential()</span>
<span class="fc" id="L294">        .flatMapIterable(new Function&lt;List&lt;Integer&gt;, Iterable&lt;Integer&gt;&gt;() {</span>
            @Override
            public Iterable&lt;Integer&gt; apply(List&lt;Integer&gt; v) throws Exception {
<span class="fc" id="L297">                return v;</span>
            }
        })
<span class="fc" id="L300">        .subscribe(ts);</span>

<span class="fc" id="L302">        ts.assertValueSet(new HashSet&lt;Integer&gt;(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)))</span>
<span class="fc" id="L303">        .assertNoErrors()</span>
<span class="fc" id="L304">        .assertComplete();</span>
<span class="fc" id="L305">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void from() {
<span class="fc" id="L310">        TestSubscriber&lt;Integer&gt; ts = new TestSubscriber&lt;Integer&gt;();</span>

<span class="fc" id="L312">        ParallelFlowable.fromArray(Flowable.range(1, 5), Flowable.range(6, 5))</span>
<span class="fc" id="L313">        .sequential()</span>
<span class="fc" id="L314">        .subscribe(ts);</span>

<span class="fc" id="L316">        ts.assertValueSet(new HashSet&lt;Integer&gt;(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)))</span>
<span class="fc" id="L317">        .assertNoErrors()</span>
<span class="fc" id="L318">        .assertComplete();</span>
<span class="fc" id="L319">    }</span>

    @Test
    public void concatMapUnordered() {
<span class="fc" id="L323">        TestSubscriber&lt;Integer&gt; ts = new TestSubscriber&lt;Integer&gt;();</span>

<span class="fc" id="L325">        Flowable.range(1, 5)</span>
<span class="fc" id="L326">        .parallel()</span>
<span class="fc" id="L327">        .concatMap(new Function&lt;Integer, Publisher&lt;Integer&gt;&gt;() {</span>
            @Override
            public Publisher&lt;Integer&gt; apply(Integer v) throws Exception {
<span class="fc" id="L330">                return Flowable.range(v * 10 + 1, 3);</span>
            }
        })
<span class="fc" id="L333">        .sequential()</span>
<span class="fc" id="L334">        .subscribe(ts);</span>

<span class="fc" id="L336">        ts.assertValueSet(new HashSet&lt;Integer&gt;(Arrays.asList(11, 12, 13, 21, 22, 23, 31, 32, 33, 41, 42, 43, 51, 52, 53)))</span>
<span class="fc" id="L337">        .assertNoErrors()</span>
<span class="fc" id="L338">        .assertComplete();</span>

<span class="fc" id="L340">    }</span>

    @Test
    public void flatMapUnordered() {
<span class="fc" id="L344">        TestSubscriber&lt;Integer&gt; ts = new TestSubscriber&lt;Integer&gt;();</span>

<span class="fc" id="L346">        Flowable.range(1, 5)</span>
<span class="fc" id="L347">        .parallel()</span>
<span class="fc" id="L348">        .flatMap(new Function&lt;Integer, Publisher&lt;Integer&gt;&gt;() {</span>
            @Override
            public Publisher&lt;Integer&gt; apply(Integer v) throws Exception {
<span class="fc" id="L351">                return Flowable.range(v * 10 + 1, 3);</span>
            }
        })
<span class="fc" id="L354">        .sequential()</span>
<span class="fc" id="L355">        .subscribe(ts);</span>

<span class="fc" id="L357">        ts.assertValueSet(new HashSet&lt;Integer&gt;(Arrays.asList(11, 12, 13, 21, 22, 23, 31, 32, 33, 41, 42, 43, 51, 52, 53)))</span>
<span class="fc" id="L358">        .assertNoErrors()</span>
<span class="fc" id="L359">        .assertComplete();</span>

<span class="fc" id="L361">    }</span>

    @Test
    public void collectAsyncFused() {
<span class="fc" id="L365">        ExecutorService exec = Executors.newFixedThreadPool(3);</span>

<span class="fc" id="L367">        Scheduler s = Schedulers.from(exec);</span>

        try {
<span class="fc" id="L370">            Callable&lt;List&lt;Integer&gt;&gt; as = new Callable&lt;List&lt;Integer&gt;&gt;() {</span>
                @Override
                public List&lt;Integer&gt; call() throws Exception {
<span class="fc" id="L373">                    return new ArrayList&lt;Integer&gt;();</span>
                }
            };
<span class="fc" id="L376">            TestSubscriber&lt;List&lt;Integer&gt;&gt; ts = new TestSubscriber&lt;List&lt;Integer&gt;&gt;();</span>

<span class="fc" id="L378">            Flowable.range(1, 100000)</span>
<span class="fc" id="L379">            .parallel(3)</span>
<span class="fc" id="L380">            .runOn(s)</span>
<span class="fc" id="L381">            .collect(as, new BiConsumer&lt;List&lt;Integer&gt;, Integer&gt;() {</span>
                @Override
                public void accept(List&lt;Integer&gt; a, Integer b) throws Exception {
<span class="fc" id="L384">                    a.add(b);</span>
<span class="fc" id="L385">                }</span>
            })
<span class="fc" id="L387">            .doOnNext(new Consumer&lt;List&lt;Integer&gt;&gt;() {</span>
                @Override
                public void accept(List&lt;Integer&gt; v) throws Exception {
<span class="fc" id="L390">                    System.out.println(v.size());</span>
<span class="fc" id="L391">                }</span>
            })
<span class="fc" id="L393">            .sequential()</span>
<span class="fc" id="L394">            .subscribe(ts);</span>

<span class="fc" id="L396">            ts.awaitDone(5, TimeUnit.SECONDS);</span>
<span class="fc" id="L397">            ts.assertValueCount(3)</span>
<span class="fc" id="L398">            .assertNoErrors()</span>
<span class="fc" id="L399">            .assertComplete()</span>
            ;

<span class="fc" id="L402">            List&lt;List&lt;Integer&gt;&gt; list = ts.values();</span>

<span class="fc" id="L404">            Assert.assertEquals(100000, list.get(0).size() + list.get(1).size() + list.get(2).size());</span>
        } finally {
<span class="fc" id="L406">            exec.shutdown();</span>
        }
<span class="fc" id="L408">    }</span>

    @Test
    public void collectAsync() {
<span class="fc" id="L412">        ExecutorService exec = Executors.newFixedThreadPool(3);</span>

<span class="fc" id="L414">        Scheduler s = Schedulers.from(exec);</span>

        try {
<span class="fc" id="L417">            Callable&lt;List&lt;Integer&gt;&gt; as = new Callable&lt;List&lt;Integer&gt;&gt;() {</span>
                @Override
                public List&lt;Integer&gt; call() throws Exception {
<span class="fc" id="L420">                    return new ArrayList&lt;Integer&gt;();</span>
                }
            };
<span class="fc" id="L423">            TestSubscriber&lt;List&lt;Integer&gt;&gt; ts = new TestSubscriber&lt;List&lt;Integer&gt;&gt;();</span>

<span class="fc" id="L425">            Flowable.range(1, 100000).hide()</span>
<span class="fc" id="L426">            .parallel(3)</span>
<span class="fc" id="L427">            .runOn(s)</span>
<span class="fc" id="L428">            .collect(as, new BiConsumer&lt;List&lt;Integer&gt;, Integer&gt;() {</span>
                @Override
                public void accept(List&lt;Integer&gt; a, Integer b) throws Exception {
<span class="fc" id="L431">                    a.add(b);</span>
<span class="fc" id="L432">                }</span>
            })
<span class="fc" id="L434">            .doOnNext(new Consumer&lt;List&lt;Integer&gt;&gt;() {</span>
                @Override
                public void accept(List&lt;Integer&gt; v) throws Exception {
<span class="fc" id="L437">                    System.out.println(v.size());</span>
<span class="fc" id="L438">                }</span>
            })
<span class="fc" id="L440">            .sequential()</span>
<span class="fc" id="L441">            .subscribe(ts);</span>

<span class="fc" id="L443">            ts.awaitDone(5, TimeUnit.SECONDS);</span>
<span class="fc" id="L444">            ts.assertValueCount(3)</span>
<span class="fc" id="L445">            .assertNoErrors()</span>
<span class="fc" id="L446">            .assertComplete()</span>
            ;

<span class="fc" id="L449">            List&lt;List&lt;Integer&gt;&gt; list = ts.values();</span>

<span class="fc" id="L451">            Assert.assertEquals(100000, list.get(0).size() + list.get(1).size() + list.get(2).size());</span>
        } finally {
<span class="fc" id="L453">            exec.shutdown();</span>
        }
<span class="fc" id="L455">    }</span>

    @Test
    public void collectAsync2() {
<span class="fc" id="L459">        ExecutorService exec = Executors.newFixedThreadPool(3);</span>

<span class="fc" id="L461">        Scheduler s = Schedulers.from(exec);</span>

        try {
<span class="fc" id="L464">            Callable&lt;List&lt;Integer&gt;&gt; as = new Callable&lt;List&lt;Integer&gt;&gt;() {</span>
                @Override
                public List&lt;Integer&gt; call() throws Exception {
<span class="fc" id="L467">                    return new ArrayList&lt;Integer&gt;();</span>
                }
            };
<span class="fc" id="L470">            TestSubscriber&lt;List&lt;Integer&gt;&gt; ts = new TestSubscriber&lt;List&lt;Integer&gt;&gt;();</span>

<span class="fc" id="L472">            Flowable.range(1, 100000).hide()</span>
<span class="fc" id="L473">            .observeOn(s)</span>
<span class="fc" id="L474">            .parallel(3)</span>
<span class="fc" id="L475">            .runOn(s)</span>
<span class="fc" id="L476">            .collect(as, new BiConsumer&lt;List&lt;Integer&gt;, Integer&gt;() {</span>
                @Override
                public void accept(List&lt;Integer&gt; a, Integer b) throws Exception {
<span class="fc" id="L479">                    a.add(b);</span>
<span class="fc" id="L480">                }</span>
            })
<span class="fc" id="L482">            .doOnNext(new Consumer&lt;List&lt;Integer&gt;&gt;() {</span>
                @Override
                public void accept(List&lt;Integer&gt; v) throws Exception {
<span class="fc" id="L485">                    System.out.println(v.size());</span>
<span class="fc" id="L486">                }</span>
            })
<span class="fc" id="L488">            .sequential()</span>
<span class="fc" id="L489">            .subscribe(ts);</span>

<span class="fc" id="L491">            ts.awaitDone(5, TimeUnit.SECONDS);</span>
<span class="fc" id="L492">            ts.assertValueCount(3)</span>
<span class="fc" id="L493">            .assertNoErrors()</span>
<span class="fc" id="L494">            .assertComplete()</span>
            ;

<span class="fc" id="L497">            List&lt;List&lt;Integer&gt;&gt; list = ts.values();</span>

<span class="fc" id="L499">            Assert.assertEquals(100000, list.get(0).size() + list.get(1).size() + list.get(2).size());</span>
        } finally {
<span class="fc" id="L501">            exec.shutdown();</span>
        }
<span class="fc" id="L503">    }</span>

    @Test
    public void collectAsync3() {
<span class="fc" id="L507">        ExecutorService exec = Executors.newFixedThreadPool(3);</span>

<span class="fc" id="L509">        Scheduler s = Schedulers.from(exec);</span>

        try {
<span class="fc" id="L512">            Callable&lt;List&lt;Integer&gt;&gt; as = new Callable&lt;List&lt;Integer&gt;&gt;() {</span>
                @Override
                public List&lt;Integer&gt; call() throws Exception {
<span class="fc" id="L515">                    return new ArrayList&lt;Integer&gt;();</span>
                }
            };
<span class="fc" id="L518">            TestSubscriber&lt;List&lt;Integer&gt;&gt; ts = new TestSubscriber&lt;List&lt;Integer&gt;&gt;();</span>

<span class="fc" id="L520">            Flowable.range(1, 100000).hide()</span>
<span class="fc" id="L521">            .observeOn(s)</span>
<span class="fc" id="L522">            .parallel(3)</span>
<span class="fc" id="L523">            .runOn(s)</span>
<span class="fc" id="L524">            .collect(as, new BiConsumer&lt;List&lt;Integer&gt;, Integer&gt;() {</span>
                @Override
                public void accept(List&lt;Integer&gt; a, Integer b) throws Exception {
<span class="fc" id="L527">                    a.add(b);</span>
<span class="fc" id="L528">                }</span>
            })
<span class="fc" id="L530">            .doOnNext(new Consumer&lt;List&lt;Integer&gt;&gt;() {</span>
                @Override
                public void accept(List&lt;Integer&gt; v) throws Exception {
<span class="fc" id="L533">                    System.out.println(v.size());</span>
<span class="fc" id="L534">                }</span>
            })
<span class="fc" id="L536">            .sequential()</span>
<span class="fc" id="L537">            .subscribe(ts);</span>

<span class="fc" id="L539">            ts.awaitDone(5, TimeUnit.SECONDS);</span>
<span class="fc" id="L540">            ts.assertValueCount(3)</span>
<span class="fc" id="L541">            .assertNoErrors()</span>
<span class="fc" id="L542">            .assertComplete()</span>
            ;

<span class="fc" id="L545">            List&lt;List&lt;Integer&gt;&gt; list = ts.values();</span>

<span class="fc" id="L547">            Assert.assertEquals(100000, list.get(0).size() + list.get(1).size() + list.get(2).size());</span>
        } finally {
<span class="fc" id="L549">            exec.shutdown();</span>
        }
<span class="fc" id="L551">    }</span>

    @Test
    public void collectAsync3Fused() {
<span class="fc" id="L555">        ExecutorService exec = Executors.newFixedThreadPool(3);</span>

<span class="fc" id="L557">        Scheduler s = Schedulers.from(exec);</span>

        try {
<span class="fc" id="L560">            Callable&lt;List&lt;Integer&gt;&gt; as = new Callable&lt;List&lt;Integer&gt;&gt;() {</span>
                @Override
                public List&lt;Integer&gt; call() throws Exception {
<span class="fc" id="L563">                    return new ArrayList&lt;Integer&gt;();</span>
                }
            };
<span class="fc" id="L566">            TestSubscriber&lt;List&lt;Integer&gt;&gt; ts = new TestSubscriber&lt;List&lt;Integer&gt;&gt;();</span>

<span class="fc" id="L568">            Flowable.range(1, 100000)</span>
<span class="fc" id="L569">            .observeOn(s)</span>
<span class="fc" id="L570">            .parallel(3)</span>
<span class="fc" id="L571">            .runOn(s)</span>
<span class="fc" id="L572">            .collect(as, new BiConsumer&lt;List&lt;Integer&gt;, Integer&gt;() {</span>
                @Override
                public void accept(List&lt;Integer&gt; a, Integer b) throws Exception {
<span class="fc" id="L575">                    a.add(b);</span>
<span class="fc" id="L576">                }</span>
            })
<span class="fc" id="L578">            .doOnNext(new Consumer&lt;List&lt;Integer&gt;&gt;() {</span>
                @Override
                public void accept(List&lt;Integer&gt; v) throws Exception {
<span class="fc" id="L581">                    System.out.println(v.size());</span>
<span class="fc" id="L582">                }</span>
            })
<span class="fc" id="L584">            .sequential()</span>
<span class="fc" id="L585">            .subscribe(ts);</span>

<span class="fc" id="L587">            ts.awaitDone(5, TimeUnit.SECONDS);</span>
<span class="fc" id="L588">            ts.assertValueCount(3)</span>
<span class="fc" id="L589">            .assertNoErrors()</span>
<span class="fc" id="L590">            .assertComplete()</span>
            ;

<span class="fc" id="L593">            List&lt;List&lt;Integer&gt;&gt; list = ts.values();</span>

<span class="fc" id="L595">            Assert.assertEquals(100000, list.get(0).size() + list.get(1).size() + list.get(2).size());</span>
        } finally {
<span class="fc" id="L597">            exec.shutdown();</span>
        }
<span class="fc" id="L599">    }</span>

    @Test
    public void collectAsync3Take() {
<span class="fc" id="L603">        ExecutorService exec = Executors.newFixedThreadPool(4);</span>

<span class="fc" id="L605">        Scheduler s = Schedulers.from(exec);</span>

        try {
<span class="fc" id="L608">            Callable&lt;List&lt;Integer&gt;&gt; as = new Callable&lt;List&lt;Integer&gt;&gt;() {</span>
                @Override
                public List&lt;Integer&gt; call() throws Exception {
<span class="fc" id="L611">                    return new ArrayList&lt;Integer&gt;();</span>
                }
            };
<span class="fc" id="L614">            TestSubscriber&lt;List&lt;Integer&gt;&gt; ts = new TestSubscriber&lt;List&lt;Integer&gt;&gt;();</span>

<span class="fc" id="L616">            Flowable.range(1, 100000)</span>
<span class="fc" id="L617">            .take(1000)</span>
<span class="fc" id="L618">            .observeOn(s)</span>
<span class="fc" id="L619">            .parallel(3)</span>
<span class="fc" id="L620">            .runOn(s)</span>
<span class="fc" id="L621">            .collect(as, new BiConsumer&lt;List&lt;Integer&gt;, Integer&gt;() {</span>
                @Override
                public void accept(List&lt;Integer&gt; a, Integer b) throws Exception {
<span class="fc" id="L624">                    a.add(b);</span>
<span class="fc" id="L625">                }</span>
            })
<span class="fc" id="L627">            .doOnNext(new Consumer&lt;List&lt;Integer&gt;&gt;() {</span>
                @Override
                public void accept(List&lt;Integer&gt; v) throws Exception {
<span class="fc" id="L630">                    System.out.println(v.size());</span>
<span class="fc" id="L631">                }</span>
            })
<span class="fc" id="L633">            .sequential()</span>
<span class="fc" id="L634">            .subscribe(ts);</span>

<span class="fc" id="L636">            ts.awaitDone(5, TimeUnit.SECONDS);</span>
<span class="fc" id="L637">            ts.assertValueCount(3)</span>
<span class="fc" id="L638">            .assertNoErrors()</span>
<span class="fc" id="L639">            .assertComplete()</span>
            ;

<span class="fc" id="L642">            List&lt;List&lt;Integer&gt;&gt; list = ts.values();</span>

<span class="fc" id="L644">            Assert.assertEquals(1000, list.get(0).size() + list.get(1).size() + list.get(2).size());</span>
        } finally {
<span class="fc" id="L646">            exec.shutdown();</span>
        }
<span class="fc" id="L648">    }</span>

    @Test
    public void collectAsync4Take() {
<span class="fc" id="L652">        ExecutorService exec = Executors.newFixedThreadPool(3);</span>

<span class="fc" id="L654">        Scheduler s = Schedulers.from(exec);</span>

        try {
<span class="fc" id="L657">            Callable&lt;List&lt;Integer&gt;&gt; as = new Callable&lt;List&lt;Integer&gt;&gt;() {</span>
                @Override
                public List&lt;Integer&gt; call() throws Exception {
<span class="fc" id="L660">                    return new ArrayList&lt;Integer&gt;();</span>
                }
            };
<span class="fc" id="L663">            TestSubscriber&lt;List&lt;Integer&gt;&gt; ts = new TestSubscriber&lt;List&lt;Integer&gt;&gt;();</span>

<span class="fc" id="L665">            UnicastProcessor&lt;Integer&gt; up = UnicastProcessor.create();</span>

<span class="fc bfc" id="L667" title="All 2 branches covered.">            for (int i = 0; i &lt; 1000; i++) {</span>
<span class="fc" id="L668">                up.onNext(i);</span>
            }

<span class="fc" id="L671">            up</span>
<span class="fc" id="L672">            .take(1000)</span>
<span class="fc" id="L673">            .observeOn(s)</span>
<span class="fc" id="L674">            .parallel(3)</span>
<span class="fc" id="L675">            .runOn(s)</span>
<span class="fc" id="L676">            .collect(as, new BiConsumer&lt;List&lt;Integer&gt;, Integer&gt;() {</span>
                @Override
                public void accept(List&lt;Integer&gt; a, Integer b) throws Exception {
<span class="fc" id="L679">                    a.add(b);</span>
<span class="fc" id="L680">                }</span>
            })
<span class="fc" id="L682">            .doOnNext(new Consumer&lt;List&lt;Integer&gt;&gt;() {</span>
                @Override
                public void accept(List&lt;Integer&gt; v) throws Exception {
<span class="fc" id="L685">                    System.out.println(v.size());</span>
<span class="fc" id="L686">                }</span>
            })
<span class="fc" id="L688">            .sequential()</span>
<span class="fc" id="L689">            .subscribe(ts);</span>

<span class="fc" id="L691">            ts.awaitDone(5, TimeUnit.SECONDS);</span>
<span class="fc" id="L692">            ts.assertValueCount(3)</span>
<span class="fc" id="L693">            .assertNoErrors()</span>
<span class="fc" id="L694">            .assertComplete()</span>
            ;

<span class="fc" id="L697">            List&lt;List&lt;Integer&gt;&gt; list = ts.values();</span>

<span class="fc" id="L699">            Assert.assertEquals(1000, list.get(0).size() + list.get(1).size() + list.get(2).size());</span>
        } finally {
<span class="fc" id="L701">            exec.shutdown();</span>
        }
<span class="fc" id="L703">    }</span>

    @Test
    public void emptySourceZeroRequest() {
<span class="fc" id="L707">        TestSubscriber&lt;Object&gt; ts = new TestSubscriber&lt;Object&gt;(0);</span>

<span class="fc" id="L709">        Flowable.range(1, 3).parallel(3).sequential().subscribe(ts);</span>

<span class="fc" id="L711">        ts.request(1);</span>

<span class="fc" id="L713">        ts.assertValue(1);</span>
<span class="fc" id="L714">    }</span>

    @Test
    public void parallelismAndPrefetch() {
<span class="fc bfc" id="L718" title="All 2 branches covered.">        for (int parallelism = 1; parallelism &lt;= 8; parallelism++) {</span>
<span class="fc bfc" id="L719" title="All 2 branches covered.">            for (int prefetch = 1; prefetch &lt;= 1024; prefetch *= 2) {</span>
<span class="fc" id="L720">                Flowable.range(1, 1024 * 1024)</span>
<span class="fc" id="L721">                .parallel(parallelism, prefetch)</span>
<span class="fc" id="L722">                .map(Functions.&lt;Integer&gt;identity())</span>
<span class="fc" id="L723">                .sequential()</span>
<span class="fc" id="L724">                .test()</span>
<span class="fc" id="L725">                .assertSubscribed()</span>
<span class="fc" id="L726">                .assertValueCount(1024 * 1024)</span>
<span class="fc" id="L727">                .assertNoErrors()</span>
<span class="fc" id="L728">                .assertComplete();</span>
            }
        }
<span class="fc" id="L731">    }</span>

    @Test
    public void parallelismAndPrefetchAsync() {
<span class="fc bfc" id="L735" title="All 2 branches covered.">        for (int parallelism = 1; parallelism &lt;= 8; parallelism *= 2) {</span>
<span class="fc bfc" id="L736" title="All 2 branches covered.">            for (int prefetch = 1; prefetch &lt;= 1024; prefetch *= 2) {</span>
<span class="fc" id="L737">                System.out.println(&quot;parallelismAndPrefetchAsync &gt;&gt; &quot; + parallelism + &quot;, &quot; + prefetch);</span>

<span class="fc" id="L739">                Flowable.range(1, 1024 * 1024)</span>
<span class="fc" id="L740">                .parallel(parallelism, prefetch)</span>
<span class="fc" id="L741">                .runOn(Schedulers.computation())</span>
<span class="fc" id="L742">                .map(Functions.&lt;Integer&gt;identity())</span>
<span class="fc" id="L743">                .sequential(prefetch)</span>
<span class="fc" id="L744">                .test()</span>
<span class="fc" id="L745">                .withTag(&quot;parallelism = &quot; + parallelism + &quot;, prefetch = &quot; + prefetch)</span>
<span class="fc" id="L746">                .awaitDone(30, TimeUnit.SECONDS)</span>
<span class="fc" id="L747">                .assertSubscribed()</span>
<span class="fc" id="L748">                .assertValueCount(1024 * 1024)</span>
<span class="fc" id="L749">                .assertNoErrors()</span>
<span class="fc" id="L750">                .assertComplete();</span>
            }
        }
<span class="fc" id="L753">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void badParallelismStage() {
<span class="fc" id="L758">        TestSubscriber&lt;Integer&gt; ts = new TestSubscriber&lt;Integer&gt;();</span>

<span class="fc" id="L760">        Flowable.range(1, 10)</span>
<span class="fc" id="L761">        .parallel(2)</span>
<span class="fc" id="L762">        .subscribe(new Subscriber[] { ts });</span>

<span class="fc" id="L764">        ts.assertFailure(IllegalArgumentException.class);</span>
<span class="fc" id="L765">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void badParallelismStage2() {
<span class="fc" id="L770">        TestSubscriber&lt;Integer&gt; ts1 = new TestSubscriber&lt;Integer&gt;();</span>
<span class="fc" id="L771">        TestSubscriber&lt;Integer&gt; ts2 = new TestSubscriber&lt;Integer&gt;();</span>
<span class="fc" id="L772">        TestSubscriber&lt;Integer&gt; ts3 = new TestSubscriber&lt;Integer&gt;();</span>

<span class="fc" id="L774">        Flowable.range(1, 10)</span>
<span class="fc" id="L775">        .parallel(2)</span>
<span class="fc" id="L776">        .subscribe(new Subscriber[] { ts1, ts2, ts3 });</span>

<span class="fc" id="L778">        ts1.assertFailure(IllegalArgumentException.class);</span>
<span class="fc" id="L779">        ts2.assertFailure(IllegalArgumentException.class);</span>
<span class="fc" id="L780">        ts3.assertFailure(IllegalArgumentException.class);</span>
<span class="fc" id="L781">    }</span>

    @Test
    public void filter() {
<span class="fc" id="L785">        Flowable.range(1, 20)</span>
<span class="fc" id="L786">        .parallel()</span>
<span class="fc" id="L787">        .runOn(Schedulers.computation())</span>
<span class="fc" id="L788">        .filter(new Predicate&lt;Integer&gt;() {</span>
            @Override
            public boolean test(Integer v) throws Exception {
<span class="fc bfc" id="L791" title="All 2 branches covered.">                return v % 2 == 0;</span>
            }
        })
<span class="fc" id="L794">        .sequential()</span>
<span class="fc" id="L795">        .test()</span>
<span class="fc" id="L796">        .awaitDone(5, TimeUnit.SECONDS)</span>
<span class="fc" id="L797">        .assertValueSet(Arrays.asList(2, 4, 6, 8, 10, 12, 14, 16, 18, 20))</span>
<span class="fc" id="L798">        .assertNoErrors()</span>
<span class="fc" id="L799">        .assertComplete();</span>
<span class="fc" id="L800">    }</span>

    @Test
    public void filterThrows() throws Exception {
<span class="fc" id="L804">        final boolean[] cancelled = { false };</span>
<span class="fc" id="L805">        Flowable.range(1, 20).concatWith(Flowable.&lt;Integer&gt;never())</span>
<span class="fc" id="L806">        .doOnCancel(new Action() {</span>
            @Override
            public void run() throws Exception {
<span class="fc" id="L809">                cancelled[0] = true;</span>
<span class="fc" id="L810">            }</span>
        })
<span class="fc" id="L812">        .parallel()</span>
<span class="fc" id="L813">        .runOn(Schedulers.computation())</span>
<span class="fc" id="L814">        .filter(new Predicate&lt;Integer&gt;() {</span>
            @Override
            public boolean test(Integer v) throws Exception {
<span class="fc bfc" id="L817" title="All 2 branches covered.">                if (v == 10) {</span>
<span class="fc" id="L818">                    throw new TestException();</span>
                }
<span class="fc bfc" id="L820" title="All 2 branches covered.">                return v % 2 == 0;</span>
            }
        })
<span class="fc" id="L823">        .sequential()</span>
<span class="fc" id="L824">        .test()</span>
<span class="fc" id="L825">        .awaitDone(5, TimeUnit.SECONDS)</span>
<span class="fc" id="L826">        .assertError(TestException.class)</span>
<span class="fc" id="L827">        .assertNotComplete();</span>

<span class="fc" id="L829">        Thread.sleep(100);</span>

<span class="fc" id="L831">        assertTrue(cancelled[0]);</span>
<span class="fc" id="L832">    }</span>

    @Test
    public void doAfterNext() {
<span class="fc" id="L836">        final int[] count = { 0 };</span>

<span class="fc" id="L838">        Flowable.range(1, 5)</span>
<span class="fc" id="L839">        .parallel()</span>
<span class="fc" id="L840">        .doAfterNext(new Consumer&lt;Integer&gt;() {</span>
            @Override
            public void accept(Integer v) throws Exception {
<span class="fc" id="L843">                count[0]++;</span>
<span class="fc" id="L844">            }</span>
        })
<span class="fc" id="L846">        .sequential()</span>
<span class="fc" id="L847">        .test()</span>
<span class="fc" id="L848">        .assertResult(1, 2, 3, 4, 5);</span>
<span class="fc" id="L849">    }</span>

    @Test
    public void doOnNextThrows() {
<span class="fc" id="L853">        final int[] count = { 0 };</span>

<span class="fc" id="L855">        Flowable.range(1, 5)</span>
<span class="fc" id="L856">        .parallel()</span>
<span class="fc" id="L857">        .doOnNext(new Consumer&lt;Integer&gt;() {</span>
            @Override
            public void accept(Integer v) throws Exception {
<span class="fc bfc" id="L860" title="All 2 branches covered.">                if (v == 3) {</span>
<span class="fc" id="L861">                    throw new TestException();</span>
                } else {
<span class="fc" id="L863">                    count[0]++;</span>
                }
<span class="fc" id="L865">            }</span>
        })
<span class="fc" id="L867">        .sequential()</span>
<span class="fc" id="L868">        .test()</span>
<span class="fc" id="L869">        .assertError(TestException.class)</span>
<span class="fc" id="L870">        .assertNotComplete();</span>

<span class="pc bpc" id="L872" title="1 of 2 branches missed.">        assertTrue(&quot;&quot; + count[0], count[0] &lt; 5);</span>
<span class="fc" id="L873">    }</span>

    @Test
    public void doAfterNextThrows() {
<span class="fc" id="L877">        final int[] count = { 0 };</span>

<span class="fc" id="L879">        Flowable.range(1, 5)</span>
<span class="fc" id="L880">        .parallel()</span>
<span class="fc" id="L881">        .doAfterNext(new Consumer&lt;Integer&gt;() {</span>
            @Override
            public void accept(Integer v) throws Exception {
<span class="fc bfc" id="L884" title="All 2 branches covered.">                if (v == 3) {</span>
<span class="fc" id="L885">                    throw new TestException();</span>
                } else {
<span class="fc" id="L887">                    count[0]++;</span>
                }
<span class="fc" id="L889">            }</span>
        })
<span class="fc" id="L891">        .sequential()</span>
<span class="fc" id="L892">        .test()</span>
<span class="fc" id="L893">        .assertError(TestException.class)</span>
<span class="fc" id="L894">        .assertNotComplete();</span>

<span class="pc bpc" id="L896" title="1 of 2 branches missed.">        assertTrue(&quot;&quot; + count[0], count[0] &lt; 5);</span>
<span class="fc" id="L897">    }</span>

    @Test
    public void errorNotRepeating() throws Exception {
<span class="fc" id="L901">        List&lt;Throwable&gt; errors = TestHelper.trackPluginErrors();</span>
        try {
<span class="fc" id="L903">            Flowable.error(new TestException())</span>
<span class="fc" id="L904">            .parallel()</span>
<span class="fc" id="L905">            .runOn(Schedulers.computation())</span>
<span class="fc" id="L906">            .sequential()</span>
<span class="fc" id="L907">            .test()</span>
<span class="fc" id="L908">            .awaitDone(5, TimeUnit.SECONDS)</span>
<span class="fc" id="L909">            .assertFailure(TestException.class)</span>
            ;

<span class="fc" id="L912">            Thread.sleep(300);</span>

<span class="pc bpc" id="L914" title="1 of 2 branches missed.">            for (Throwable ex : errors) {</span>
<span class="nc" id="L915">                ex.printStackTrace();</span>
<span class="nc" id="L916">            }</span>
<span class="fc" id="L917">            assertTrue(errors.toString(), errors.isEmpty());</span>
        } finally {
<span class="fc" id="L919">            RxJavaPlugins.reset();</span>
        }
<span class="fc" id="L921">    }</span>

    @Test
    public void doOnError() {
<span class="fc" id="L925">        final int[] count = { 0 };</span>

<span class="fc" id="L927">        Flowable.range(1, 5)</span>
<span class="fc" id="L928">        .parallel(2)</span>
<span class="fc" id="L929">        .map(new Function&lt;Integer, Integer&gt;() {</span>
            @Override
            public Integer apply(Integer v) throws Exception {
<span class="fc bfc" id="L932" title="All 2 branches covered.">                if (v == 3) {</span>
<span class="fc" id="L933">                    throw new TestException();</span>
                }
<span class="fc" id="L935">                return v;</span>
            }
        })
<span class="fc" id="L938">        .doOnError(new Consumer&lt;Throwable&gt;() {</span>
            @Override
            public void accept(Throwable e) throws Exception {
<span class="pc bpc" id="L941" title="1 of 2 branches missed.">                if (e instanceof TestException) {</span>
<span class="fc" id="L942">                    count[0]++;</span>
                }
<span class="fc" id="L944">            }</span>
        })
<span class="fc" id="L946">        .sequential()</span>
<span class="fc" id="L947">        .test()</span>
<span class="fc" id="L948">        .assertError(TestException.class)</span>
<span class="fc" id="L949">        .assertNotComplete();</span>

<span class="fc" id="L951">        assertEquals(1, count[0]);</span>
<span class="fc" id="L952">    }</span>

    @Test
    public void doOnErrorThrows() {
<span class="fc" id="L956">        TestSubscriber&lt;Integer&gt; ts = Flowable.range(1, 5)</span>
<span class="fc" id="L957">        .parallel(2)</span>
<span class="fc" id="L958">        .map(new Function&lt;Integer, Integer&gt;() {</span>
            @Override
            public Integer apply(Integer v) throws Exception {
<span class="fc bfc" id="L961" title="All 2 branches covered.">                if (v == 3) {</span>
<span class="fc" id="L962">                    throw new TestException();</span>
                }
<span class="fc" id="L964">                return v;</span>
            }
        })
<span class="fc" id="L967">        .doOnError(new Consumer&lt;Throwable&gt;() {</span>
            @Override
            public void accept(Throwable e) throws Exception {
<span class="pc bpc" id="L970" title="1 of 2 branches missed.">                if (e instanceof TestException) {</span>
<span class="fc" id="L971">                    throw new IOException();</span>
                }
<span class="nc" id="L973">            }</span>
        })
<span class="fc" id="L975">        .sequential()</span>
<span class="fc" id="L976">        .test()</span>
<span class="fc" id="L977">        .assertError(CompositeException.class)</span>
<span class="fc" id="L978">        .assertNotComplete();</span>

<span class="fc" id="L980">        List&lt;Throwable&gt; errors = TestHelper.errorList(ts);</span>
<span class="fc" id="L981">        TestHelper.assertError(errors, 0, TestException.class);</span>
<span class="fc" id="L982">        TestHelper.assertError(errors, 1, IOException.class);</span>
<span class="fc" id="L983">    }</span>

    @Test
    public void doOnComplete() {
<span class="fc" id="L987">        final int[] count = { 0 };</span>

<span class="fc" id="L989">        Flowable.range(1, 5)</span>
<span class="fc" id="L990">        .parallel(2)</span>
<span class="fc" id="L991">        .doOnComplete(new Action() {</span>
            @Override
            public void run() throws Exception {
<span class="fc" id="L994">                count[0]++;</span>
<span class="fc" id="L995">            }</span>
        })
<span class="fc" id="L997">        .sequential()</span>
<span class="fc" id="L998">        .test()</span>
<span class="fc" id="L999">        .assertResult(1, 2, 3, 4, 5);</span>

<span class="fc" id="L1001">        assertEquals(2, count[0]);</span>
<span class="fc" id="L1002">    }</span>

    @Test
    public void doAfterTerminate() {
<span class="fc" id="L1006">        final int[] count = { 0 };</span>

<span class="fc" id="L1008">        Flowable.range(1, 5)</span>
<span class="fc" id="L1009">        .parallel(2)</span>
<span class="fc" id="L1010">        .doAfterTerminated(new Action() {</span>
            @Override
            public void run() throws Exception {
<span class="fc" id="L1013">                count[0]++;</span>
<span class="fc" id="L1014">            }</span>
        })
<span class="fc" id="L1016">        .sequential()</span>
<span class="fc" id="L1017">        .test()</span>
<span class="fc" id="L1018">        .assertResult(1, 2, 3, 4, 5);</span>

<span class="fc" id="L1020">        assertEquals(2, count[0]);</span>
<span class="fc" id="L1021">    }</span>

    @Test
    public void doOnSubscribe() {
<span class="fc" id="L1025">        final int[] count = { 0 };</span>

<span class="fc" id="L1027">        Flowable.range(1, 5)</span>
<span class="fc" id="L1028">        .parallel(2)</span>
<span class="fc" id="L1029">        .doOnSubscribe(new Consumer&lt;Subscription&gt;() {</span>
            @Override
            public void accept(Subscription s) throws Exception {
<span class="fc" id="L1032">                count[0]++;</span>
<span class="fc" id="L1033">            }</span>
        })
<span class="fc" id="L1035">        .sequential()</span>
<span class="fc" id="L1036">        .test()</span>
<span class="fc" id="L1037">        .assertResult(1, 2, 3, 4, 5);</span>

<span class="fc" id="L1039">        assertEquals(2, count[0]);</span>
<span class="fc" id="L1040">    }</span>

    @Test
    public void doOnRequest() {
<span class="fc" id="L1044">        final int[] count = { 0 };</span>

<span class="fc" id="L1046">        Flowable.range(1, 5)</span>
<span class="fc" id="L1047">        .parallel(2)</span>
<span class="fc" id="L1048">        .doOnRequest(new LongConsumer() {</span>
            @Override
            public void accept(long s) throws Exception {
<span class="fc" id="L1051">                count[0]++;</span>
<span class="fc" id="L1052">            }</span>
        })
<span class="fc" id="L1054">        .sequential()</span>
<span class="fc" id="L1055">        .test()</span>
<span class="fc" id="L1056">        .assertResult(1, 2, 3, 4, 5);</span>

<span class="fc" id="L1058">        assertEquals(2, count[0]);</span>
<span class="fc" id="L1059">    }</span>

    @Test
    public void doOnCancel() {
<span class="fc" id="L1063">        final int[] count = { 0 };</span>

<span class="fc" id="L1065">        Flowable.range(1, 5)</span>
<span class="fc" id="L1066">        .parallel(2)</span>
<span class="fc" id="L1067">        .doOnCancel(new Action() {</span>
            @Override
            public void run() throws Exception {
<span class="fc" id="L1070">                count[0]++;</span>
<span class="fc" id="L1071">            }</span>
        })
<span class="fc" id="L1073">        .sequential()</span>
<span class="fc" id="L1074">        .take(2)</span>
<span class="fc" id="L1075">        .test()</span>
<span class="fc" id="L1076">        .assertResult(1, 2);</span>

<span class="fc" id="L1078">        assertEquals(2, count[0]);</span>
<span class="fc" id="L1079">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test(expected = IllegalArgumentException.class)
    public void fromPublishers() {
<span class="nc" id="L1084">        ParallelFlowable.fromArray(new Publisher[0]);</span>
<span class="nc" id="L1085">    }</span>

    @Test
    public void to() {
<span class="fc" id="L1089">        Flowable.range(1, 5)</span>
<span class="fc" id="L1090">        .parallel()</span>
<span class="fc" id="L1091">        .to(new Function&lt;ParallelFlowable&lt;Integer&gt;, Flowable&lt;Integer&gt;&gt;() {</span>
            @Override
            public Flowable&lt;Integer&gt; apply(ParallelFlowable&lt;Integer&gt; pf) throws Exception {
<span class="fc" id="L1094">                return pf.sequential();</span>
            }
        })
<span class="fc" id="L1097">        .test()</span>
<span class="fc" id="L1098">        .assertResult(1, 2, 3, 4, 5);</span>
<span class="fc" id="L1099">    }</span>

    @Test
    public void as() {
<span class="fc" id="L1103">        Flowable.range(1, 5)</span>
<span class="fc" id="L1104">        .parallel()</span>
<span class="fc" id="L1105">        .as(new ParallelFlowableConverter&lt;Integer, Flowable&lt;Integer&gt;&gt;() {</span>
            @Override
            public Flowable&lt;Integer&gt; apply(ParallelFlowable&lt;Integer&gt; pf) {
<span class="fc" id="L1108">                return pf.sequential();</span>
            }
        })
<span class="fc" id="L1111">        .test()</span>
<span class="fc" id="L1112">        .assertResult(1, 2, 3, 4, 5);</span>
<span class="fc" id="L1113">    }</span>

    @Test(expected = TestException.class)
    public void toThrows() {
<span class="fc" id="L1117">        Flowable.range(1, 5)</span>
<span class="fc" id="L1118">        .parallel()</span>
<span class="pc" id="L1119">        .to(new Function&lt;ParallelFlowable&lt;Integer&gt;, Flowable&lt;Integer&gt;&gt;() {</span>
            @Override
            public Flowable&lt;Integer&gt; apply(ParallelFlowable&lt;Integer&gt; pf) throws Exception {
<span class="fc" id="L1122">                throw new TestException();</span>
            }
        });
<span class="nc" id="L1125">    }</span>

    @Test(expected = TestException.class)
    public void asThrows() {
<span class="fc" id="L1129">        Flowable.range(1, 5)</span>
<span class="fc" id="L1130">        .parallel()</span>
<span class="pc" id="L1131">        .as(new ParallelFlowableConverter&lt;Integer, Flowable&lt;Integer&gt;&gt;() {</span>
            @Override
            public Flowable&lt;Integer&gt; apply(ParallelFlowable&lt;Integer&gt; pf) {
<span class="fc" id="L1134">                throw new TestException();</span>
            }
        });
<span class="nc" id="L1137">    }</span>

    @Test
    public void compose() {
<span class="fc" id="L1141">        Flowable.range(1, 5)</span>
<span class="fc" id="L1142">        .parallel()</span>
<span class="fc" id="L1143">        .compose(new ParallelTransformer&lt;Integer, Integer&gt;() {</span>
            @Override
            public ParallelFlowable&lt;Integer&gt; apply(ParallelFlowable&lt;Integer&gt; pf) {
<span class="fc" id="L1146">                return pf.map(new Function&lt;Integer, Integer&gt;() {</span>
                    @Override
                    public Integer apply(Integer v) throws Exception {
<span class="fc" id="L1149">                        return v + 1;</span>
                    }
                });
            }
        })
<span class="fc" id="L1154">        .sequential()</span>
<span class="fc" id="L1155">        .test()</span>
<span class="fc" id="L1156">        .assertResult(2, 3, 4, 5, 6);</span>
<span class="fc" id="L1157">    }</span>

    @Test
    public void flatMapDelayError() {
<span class="fc" id="L1161">        final int[] count = { 0 };</span>

<span class="fc" id="L1163">        Flowable.range(1, 5)</span>
<span class="fc" id="L1164">        .parallel(2)</span>
<span class="fc" id="L1165">        .flatMap(new Function&lt;Integer, Flowable&lt;Integer&gt;&gt;() {</span>
            @Override
            public Flowable&lt;Integer&gt; apply(Integer v) throws Exception {
<span class="fc bfc" id="L1168" title="All 2 branches covered.">                if (v == 3) {</span>
<span class="fc" id="L1169">                   return Flowable.error(new TestException());</span>
                }
<span class="fc" id="L1171">                return Flowable.just(v);</span>
            }
        }, true)
<span class="fc" id="L1174">        .doOnError(new Consumer&lt;Throwable&gt;() {</span>
            @Override
            public void accept(Throwable e) throws Exception {
<span class="pc bpc" id="L1177" title="1 of 2 branches missed.">                if (e instanceof TestException) {</span>
<span class="fc" id="L1178">                    count[0]++;</span>
                }
<span class="fc" id="L1180">            }</span>
        })
<span class="fc" id="L1182">        .sequential()</span>
<span class="fc" id="L1183">        .test()</span>
<span class="fc" id="L1184">        .assertValues(1, 2, 4, 5)</span>
<span class="fc" id="L1185">        .assertError(TestException.class)</span>
<span class="fc" id="L1186">        .assertNotComplete();</span>

<span class="fc" id="L1188">        assertEquals(1, count[0]);</span>
<span class="fc" id="L1189">    }</span>

    @Test
    public void flatMapDelayErrorMaxConcurrency() {
<span class="fc" id="L1193">        final int[] count = { 0 };</span>

<span class="fc" id="L1195">        Flowable.range(1, 5)</span>
<span class="fc" id="L1196">        .parallel(2)</span>
<span class="fc" id="L1197">        .flatMap(new Function&lt;Integer, Flowable&lt;Integer&gt;&gt;() {</span>
            @Override
            public Flowable&lt;Integer&gt; apply(Integer v) throws Exception {
<span class="fc bfc" id="L1200" title="All 2 branches covered.">                if (v == 3) {</span>
<span class="fc" id="L1201">                   return Flowable.error(new TestException());</span>
                }
<span class="fc" id="L1203">                return Flowable.just(v);</span>
            }
        }, true, 1)
<span class="fc" id="L1206">        .doOnError(new Consumer&lt;Throwable&gt;() {</span>
            @Override
            public void accept(Throwable e) throws Exception {
<span class="pc bpc" id="L1209" title="1 of 2 branches missed.">                if (e instanceof TestException) {</span>
<span class="fc" id="L1210">                    count[0]++;</span>
                }
<span class="fc" id="L1212">            }</span>
        })
<span class="fc" id="L1214">        .sequential()</span>
<span class="fc" id="L1215">        .test()</span>
<span class="fc" id="L1216">        .assertValues(1, 2, 4, 5)</span>
<span class="fc" id="L1217">        .assertError(TestException.class)</span>
<span class="fc" id="L1218">        .assertNotComplete();</span>

<span class="fc" id="L1220">        assertEquals(1, count[0]);</span>
<span class="fc" id="L1221">    }</span>

    @Test
    public void concatMapDelayError() {
<span class="fc" id="L1225">        final int[] count = { 0 };</span>

<span class="fc" id="L1227">        Flowable.range(1, 5)</span>
<span class="fc" id="L1228">        .parallel(2)</span>
<span class="fc" id="L1229">        .concatMapDelayError(new Function&lt;Integer, Flowable&lt;Integer&gt;&gt;() {</span>
            @Override
            public Flowable&lt;Integer&gt; apply(Integer v) throws Exception {
<span class="fc bfc" id="L1232" title="All 2 branches covered.">                if (v == 3) {</span>
<span class="fc" id="L1233">                   return Flowable.error(new TestException());</span>
                }
<span class="fc" id="L1235">                return Flowable.just(v);</span>
            }
        }, true)
<span class="fc" id="L1238">        .doOnError(new Consumer&lt;Throwable&gt;() {</span>
            @Override
            public void accept(Throwable e) throws Exception {
<span class="pc bpc" id="L1241" title="1 of 2 branches missed.">                if (e instanceof TestException) {</span>
<span class="fc" id="L1242">                    count[0]++;</span>
                }
<span class="fc" id="L1244">            }</span>
        })
<span class="fc" id="L1246">        .sequential()</span>
<span class="fc" id="L1247">        .test()</span>
<span class="fc" id="L1248">        .assertValues(1, 2, 4, 5)</span>
<span class="fc" id="L1249">        .assertError(TestException.class)</span>
<span class="fc" id="L1250">        .assertNotComplete();</span>

<span class="fc" id="L1252">        assertEquals(1, count[0]);</span>
<span class="fc" id="L1253">    }</span>

    @Test
    public void concatMapDelayErrorPrefetch() {
<span class="fc" id="L1257">        final int[] count = { 0 };</span>

<span class="fc" id="L1259">        Flowable.range(1, 5)</span>
<span class="fc" id="L1260">        .parallel(2)</span>
<span class="fc" id="L1261">        .concatMapDelayError(new Function&lt;Integer, Flowable&lt;Integer&gt;&gt;() {</span>
            @Override
            public Flowable&lt;Integer&gt; apply(Integer v) throws Exception {
<span class="fc bfc" id="L1264" title="All 2 branches covered.">                if (v == 3) {</span>
<span class="fc" id="L1265">                   return Flowable.error(new TestException());</span>
                }
<span class="fc" id="L1267">                return Flowable.just(v);</span>
            }
        }, 1, true)
<span class="fc" id="L1270">        .doOnError(new Consumer&lt;Throwable&gt;() {</span>
            @Override
            public void accept(Throwable e) throws Exception {
<span class="pc bpc" id="L1273" title="1 of 2 branches missed.">                if (e instanceof TestException) {</span>
<span class="fc" id="L1274">                    count[0]++;</span>
                }
<span class="fc" id="L1276">            }</span>
        })
<span class="fc" id="L1278">        .sequential()</span>
<span class="fc" id="L1279">        .test()</span>
<span class="fc" id="L1280">        .assertValues(1, 2, 4, 5)</span>
<span class="fc" id="L1281">        .assertError(TestException.class)</span>
<span class="fc" id="L1282">        .assertNotComplete();</span>

<span class="fc" id="L1284">        assertEquals(1, count[0]);</span>
<span class="fc" id="L1285">    }</span>

    @Test
    public void concatMapDelayErrorBoundary() {
<span class="fc" id="L1289">        final int[] count = { 0 };</span>

<span class="fc" id="L1291">        Flowable.range(1, 5)</span>
<span class="fc" id="L1292">        .parallel(2)</span>
<span class="fc" id="L1293">        .concatMapDelayError(new Function&lt;Integer, Flowable&lt;Integer&gt;&gt;() {</span>
            @Override
            public Flowable&lt;Integer&gt; apply(Integer v) throws Exception {
<span class="fc bfc" id="L1296" title="All 2 branches covered.">                if (v == 3) {</span>
<span class="fc" id="L1297">                   return Flowable.error(new TestException());</span>
                }
<span class="fc" id="L1299">                return Flowable.just(v);</span>
            }
        }, false)
<span class="fc" id="L1302">        .doOnError(new Consumer&lt;Throwable&gt;() {</span>
            @Override
            public void accept(Throwable e) throws Exception {
<span class="pc bpc" id="L1305" title="1 of 2 branches missed.">                if (e instanceof TestException) {</span>
<span class="fc" id="L1306">                    count[0]++;</span>
                }
<span class="fc" id="L1308">            }</span>
        })
<span class="fc" id="L1310">        .sequential()</span>
<span class="fc" id="L1311">        .test()</span>
<span class="fc" id="L1312">        .assertValues(1, 2)</span>
<span class="fc" id="L1313">        .assertError(TestException.class)</span>
<span class="fc" id="L1314">        .assertNotComplete();</span>

<span class="fc" id="L1316">        assertEquals(1, count[0]);</span>
<span class="fc" id="L1317">    }</span>

    public static void checkSubscriberCount(ParallelFlowable&lt;?&gt; source) {
<span class="fc" id="L1320">        int n = source.parallelism();</span>

        @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L1323">        TestSubscriber&lt;Object&gt;[] consumers = new TestSubscriber[n + 1];</span>

<span class="fc bfc" id="L1325" title="All 2 branches covered.">        for (int i = 0; i &lt;= n; i++) {</span>
<span class="fc" id="L1326">            consumers[i] = new TestSubscriber&lt;Object&gt;();</span>
        }

<span class="fc" id="L1329">        source.subscribe(consumers);</span>

<span class="fc bfc" id="L1331" title="All 2 branches covered.">        for (int i = 0; i &lt;= n; i++) {</span>
<span class="fc" id="L1332">            consumers[i].awaitDone(5, TimeUnit.SECONDS)</span>
<span class="fc" id="L1333">            .assertFailure(IllegalArgumentException.class);</span>
        }
<span class="fc" id="L1335">    }</span>

    @Test
    public void checkAddBiConsumer() {
<span class="fc" id="L1339">        TestHelper.checkEnum(ListAddBiConsumer.class);</span>
<span class="fc" id="L1340">    }</span>

    @Test
    public void mergeBiFunction() throws Exception {
<span class="fc" id="L1344">        MergerBiFunction&lt;Integer&gt; f = new MergerBiFunction&lt;Integer&gt;(Functions.&lt;Integer&gt;naturalComparator());</span>

<span class="fc" id="L1346">        assertEquals(0, f.apply(Collections.&lt;Integer&gt;emptyList(), Collections.&lt;Integer&gt;emptyList()).size());</span>

<span class="fc" id="L1348">        assertEquals(Arrays.asList(1, 2), f.apply(Collections.&lt;Integer&gt;emptyList(), Arrays.asList(1, 2)));</span>

<span class="fc bfc" id="L1350" title="All 2 branches covered.">        for (int i = 0; i &lt; 4; i++) {</span>
<span class="fc" id="L1351">            int k = 0;</span>
<span class="fc" id="L1352">            List&lt;Integer&gt; list1 = new ArrayList&lt;Integer&gt;();</span>
<span class="fc bfc" id="L1353" title="All 2 branches covered.">            for (int j = 0; j &lt; i; j++) {</span>
<span class="fc" id="L1354">                list1.add(k++);</span>
            }

<span class="fc" id="L1357">            List&lt;Integer&gt; list2 = new ArrayList&lt;Integer&gt;();</span>
<span class="fc bfc" id="L1358" title="All 2 branches covered.">            for (int j = i; j &lt; 4; j++) {</span>
<span class="fc" id="L1359">                list2.add(k++);</span>
            }

<span class="fc" id="L1362">            assertEquals(Arrays.asList(0, 1, 2, 3), f.apply(list1, list2));</span>
        }
<span class="fc" id="L1364">    }</span>

    @Test
    public void concatMapSubscriberCount() {
<span class="fc" id="L1368">        ParallelFlowableTest.checkSubscriberCount(Flowable.range(1, 5).parallel()</span>
<span class="fc" id="L1369">        .concatMap(Functions.justFunction(Flowable.just(1))));</span>
<span class="fc" id="L1370">    }</span>

    @Test
    public void flatMapSubscriberCount() {
<span class="fc" id="L1374">        ParallelFlowableTest.checkSubscriberCount(Flowable.range(1, 5).parallel()</span>
<span class="fc" id="L1375">        .flatMap(Functions.justFunction(Flowable.just(1))));</span>
<span class="fc" id="L1376">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void fromArraySubscriberCount() {
<span class="fc" id="L1381">        ParallelFlowableTest.checkSubscriberCount(ParallelFlowable.fromArray(new Publisher[] { Flowable.just(1) }));</span>
<span class="fc" id="L1382">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>