<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RxJavaPluginsTest.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">RxJava_2_x$Unnamed.exec</a> &gt; <a href="index.source.html" class="el_package">io.reactivex.plugins</a> &gt; <span class="el_source">RxJavaPluginsTest.java</span></div><h1>RxJavaPluginsTest.java</h1><pre class="source lang-java linenums">/**
 * Copyright (c) 2016-present, RxJava Contributors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.reactivex.plugins;

import static org.junit.Assert.*;

import java.io.*;
import java.lang.Thread.UncaughtExceptionHandler;
import java.lang.reflect.*;
import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.*;

import org.junit.*;
import org.reactivestreams.*;

import io.reactivex.*;
import io.reactivex.Observable;
import io.reactivex.Observer;
import io.reactivex.Scheduler.Worker;
import io.reactivex.disposables.*;
import io.reactivex.exceptions.*;
import io.reactivex.flowables.ConnectableFlowable;
import io.reactivex.functions.*;
import io.reactivex.internal.functions.Functions;
import io.reactivex.internal.operators.completable.CompletableError;
import io.reactivex.internal.operators.flowable.FlowableRange;
import io.reactivex.internal.operators.maybe.MaybeError;
import io.reactivex.internal.operators.observable.ObservableRange;
import io.reactivex.internal.operators.parallel.ParallelFromPublisher;
import io.reactivex.internal.operators.single.SingleJust;
import io.reactivex.internal.schedulers.ImmediateThinScheduler;
import io.reactivex.internal.subscriptions.ScalarSubscription;
import io.reactivex.observables.ConnectableObservable;
import io.reactivex.parallel.ParallelFlowable;
import io.reactivex.schedulers.Schedulers;

<span class="fc" id="L52">public class RxJavaPluginsTest {</span>

//    static Observable&lt;Integer&gt; createObservable() {
//        return Observable.range(1, 5).map(new Function&lt;Integer, Integer&gt;() {
//            @Override
//            public Integer apply(Integer t) {
//                throw new TestException();
//            }
//        });
//    }
//
//    static Flowable&lt;Integer&gt; createFlowable() {
//        return Flowable.range(1, 5).map(new Function&lt;Integer, Integer&gt;() {
//            @Override
//            public Integer apply(Integer t) {
//                throw new TestException();
//            }
//        });
//    }

    @Test
    public void constructorShouldBePrivate() {
<span class="fc" id="L74">        TestHelper.checkUtilityClass(RxJavaPlugins.class);</span>
<span class="fc" id="L75">    }</span>

    @Test
    @Ignore(&quot;Not part of 2.0&quot;)
    public void assemblyTrackingObservable() {
//        RxJavaPlugins.enableAssemblyTracking();
//        try {
//            TestSubscriber&lt;Integer&gt; ts = TestSubscriber.create();
//
//            createObservable().subscribe(ts);
//
//            ts.assertError(TestException.class);
//
//            Throwable ex = ts.getOnErrorEvents().get(0);
//
//            AssemblyStackTraceException aste = AssemblyStackTraceException.find(ex);
//
//            assertNotNull(aste);
//
//            assertTrue(aste.getMessage(), aste.getMessage().contains(&quot;createObservable&quot;));
//
//            RxJavaPlugins.clearAssemblyTracking();
//
//            ts = TestSubscriber.create();
//
//            createObservable().subscribe(ts);
//
//            ts.assertError(TestException.class);
//
//            ex = ts.getOnErrorEvents().get(0);
//
//            aste = AssemblyStackTraceException.find(ex);
//
//            assertNull(aste);
//        } finally {
//            RxJavaPlugins.resetAssemblyTracking();
//        }
<span class="nc" id="L112">    }</span>

//    static Single&lt;Integer&gt; createSingle() {
//        return Single.just(1).map(new Function&lt;Integer, Integer&gt;() {
//            @Override
//            public Integer apply(Integer t) {
//                throw new TestException();
//            }
//        });
//    }

    @Test
    @Ignore(&quot;Not part of 2.0&quot;)
    public void assemblyTrackingSingle() {
//        RxJavaPlugins.enableAssemblyTracking();
//        try {
//            TestSubscriber&lt;Integer&gt; ts = TestSubscriber.create();
//
//            createSingle().subscribe(ts);
//
//            ts.assertError(TestException.class);
//
//            Throwable ex = ts.getOnErrorEvents().get(0);
//
//            AssemblyStackTraceException aste = AssemblyStackTraceException.find(ex);
//
//            assertNotNull(aste);
//
//            assertTrue(aste.getMessage(), aste.getMessage().contains(&quot;createSingle&quot;));
//
//            RxJavaPlugins.clearAssemblyTracking();
//
//            ts = TestSubscriber.create();
//
//            createSingle().subscribe(ts);
//
//            ts.assertError(TestException.class);
//
//            ex = ts.getOnErrorEvents().get(0);
//
//            aste = AssemblyStackTraceException.find(ex);
//
//            assertNull(aste);
//        } finally {
//            RxJavaPlugins.resetAssemblyTracking();
//        }
<span class="nc" id="L158">    }</span>

//    static Completable createCompletable() {
//        return Completable.error(new Callable&lt;Throwable&gt;() {
//            @Override
//            public Throwable call() {
//                return new TestException();
//            }
//        });
//    }

    @Test
    @Ignore(&quot;Not part of 2.0&quot;)
    public void assemblyTrackingCompletable() {
//        RxJavaPlugins.enableAssemblyTracking();
//        try {
//            TestSubscriber&lt;Integer&gt; ts = TestSubscriber.create();
//
//            createCompletable().subscribe(ts);
//
//            ts.assertError(TestException.class);
//
//            Throwable ex = ts.getOnErrorEvents().get(0);
//
//            AssemblyStackTraceException aste = AssemblyStackTraceException.find(ex);
//
//            assertNotNull(aste);
//
//            assertTrue(aste.getMessage(), aste.getMessage().contains(&quot;createCompletable&quot;));
//
//            RxJavaPlugins.clearAssemblyTracking();
//
//            ts = TestSubscriber.create();
//
//            createCompletable().subscribe(ts);
//
//            ts.assertError(TestException.class);
//
//            ex = ts.getOnErrorEvents().get(0);
//
//            aste = AssemblyStackTraceException.find(ex);
//
//            assertNull(aste);
//
//        } finally {
//            RxJavaPlugins.resetAssemblyTracking();
//        }
<span class="nc" id="L205">    }</span>

    @SuppressWarnings({ &quot;rawtypes&quot; })
    @Test
    public void lockdown() throws Exception {
<span class="fc" id="L210">        RxJavaPlugins.reset();</span>
<span class="fc" id="L211">        RxJavaPlugins.lockdown();</span>
        try {
<span class="fc" id="L213">            assertTrue(RxJavaPlugins.isLockdown());</span>
<span class="fc" id="L214">            Consumer a1 = Functions.emptyConsumer();</span>
<span class="fc" id="L215">            Callable f0 = new Callable() {</span>
                @Override
                public Object call() {
<span class="nc" id="L218">                    return null;</span>
                }
            };
<span class="fc" id="L221">            Function f1 = Functions.identity();</span>
<span class="fc" id="L222">            BiFunction f2 = new BiFunction() {</span>
                @Override
                public Object apply(Object t1, Object t2) {
<span class="nc" id="L225">                    return t2;</span>
                }
            };

<span class="fc" id="L229">            BooleanSupplier bs = new BooleanSupplier() {</span>
                @Override
                public boolean getAsBoolean() throws Exception {
<span class="nc" id="L232">                    return true;</span>
                }
            };

<span class="fc bfc" id="L236" title="All 2 branches covered.">            for (Method m : RxJavaPlugins.class.getMethods()) {</span>
<span class="fc bfc" id="L237" title="All 2 branches covered.">                if (m.getName().startsWith(&quot;set&quot;)) {</span>

                    Method getter;

<span class="fc" id="L241">                    Class&lt;?&gt; paramType = m.getParameterTypes()[0];</span>

<span class="fc bfc" id="L243" title="All 2 branches covered.">                    if (paramType == Boolean.TYPE) {</span>
<span class="fc" id="L244">                        getter = RxJavaPlugins.class.getMethod(&quot;is&quot; + m.getName().substring(3));</span>
                    } else {
<span class="fc" id="L246">                        getter = RxJavaPlugins.class.getMethod(&quot;get&quot; + m.getName().substring(3));</span>
                    }

<span class="fc" id="L249">                    Object before = getter.invoke(null);</span>

                    try {
<span class="fc bfc" id="L252" title="All 2 branches covered.">                        if (paramType.isAssignableFrom(Boolean.TYPE)) {</span>
<span class="nc" id="L253">                            m.invoke(null, true);</span>
                        } else
<span class="pc bpc" id="L255" title="1 of 2 branches missed.">                        if (paramType.isAssignableFrom(Callable.class)) {</span>
<span class="nc" id="L256">                            m.invoke(null, f0);</span>
                        } else
<span class="fc bfc" id="L258" title="All 2 branches covered.">                        if (paramType.isAssignableFrom(Function.class)) {</span>
<span class="nc" id="L259">                            m.invoke(null, f1);</span>
                        } else
<span class="fc bfc" id="L261" title="All 2 branches covered.">                        if (paramType.isAssignableFrom(Consumer.class)) {</span>
<span class="nc" id="L262">                            m.invoke(null, a1);</span>
                        } else
<span class="pc bpc" id="L264" title="1 of 2 branches missed.">                        if (paramType.isAssignableFrom(BooleanSupplier.class)) {</span>
<span class="nc" id="L265">                            m.invoke(null, bs);</span>
                        } else {
<span class="nc" id="L267">                            m.invoke(null, f2);</span>
                        }
<span class="nc" id="L269">                        fail(&quot;Should have thrown InvocationTargetException(IllegalStateException)&quot;);</span>
<span class="fc" id="L270">                    } catch (InvocationTargetException ex) {</span>
<span class="pc bpc" id="L271" title="1 of 2 branches missed.">                        if (ex.getCause() instanceof IllegalStateException) {</span>
<span class="fc" id="L272">                            assertEquals(&quot;Plugins can't be changed anymore&quot;, ex.getCause().getMessage());</span>
                        } else {
<span class="nc" id="L274">                            fail(&quot;Should have thrown InvocationTargetException(IllegalStateException)&quot;);</span>
                        }
<span class="nc" id="L276">                    }</span>

<span class="fc" id="L278">                    Object after = getter.invoke(null);</span>

<span class="fc bfc" id="L280" title="All 2 branches covered.">                    if (paramType.isPrimitive()) {</span>
<span class="fc" id="L281">                        assertEquals(m.toString(), before, after);</span>
                    } else {
<span class="fc" id="L283">                        assertSame(m.toString(), before, after);</span>
                    }
                }
            }

//            Object o1 = RxJavaPlugins.getOnObservableCreate();
//            Object o2 = RxJavaPlugins.getOnSingleCreate();
//            Object o3 = RxJavaPlugins.getOnCompletableCreate();
//
//            RxJavaPlugins.enableAssemblyTracking();
//            RxJavaPlugins.clearAssemblyTracking();
//            RxJavaPlugins.resetAssemblyTracking();
//
//
//            assertSame(o1, RxJavaPlugins.getOnObservableCreate());
//            assertSame(o2, RxJavaPlugins.getOnSingleCreate());
//            assertSame(o3, RxJavaPlugins.getOnCompletableCreate());

        } finally {
<span class="fc" id="L302">            RxJavaPlugins.unlock();</span>
<span class="fc" id="L303">            RxJavaPlugins.reset();</span>
<span class="fc" id="L304">            assertFalse(RxJavaPlugins.isLockdown());</span>
        }
<span class="fc" id="L306">    }</span>

<span class="fc" id="L308">    Function&lt;Scheduler, Scheduler&gt; replaceWithImmediate = new Function&lt;Scheduler, Scheduler&gt;() {</span>
        @Override
        public Scheduler apply(Scheduler t) {
<span class="fc" id="L311">            return ImmediateThinScheduler.INSTANCE;</span>
        }
    };

    @Test
    public void overrideSingleScheduler() {
        try {
<span class="fc" id="L318">            RxJavaPlugins.setSingleSchedulerHandler(replaceWithImmediate);</span>

<span class="fc" id="L320">            assertSame(ImmediateThinScheduler.INSTANCE, Schedulers.single());</span>
        } finally {
<span class="fc" id="L322">            RxJavaPlugins.reset();</span>
        }
        // make sure the reset worked
<span class="fc" id="L325">        assertNotSame(ImmediateThinScheduler.INSTANCE, Schedulers.single());</span>
<span class="fc" id="L326">    }</span>

    @Test
    public void overrideComputationScheduler() {
        try {
<span class="fc" id="L331">            RxJavaPlugins.setComputationSchedulerHandler(replaceWithImmediate);</span>

<span class="fc" id="L333">            assertSame(ImmediateThinScheduler.INSTANCE, Schedulers.computation());</span>
        } finally {
<span class="fc" id="L335">            RxJavaPlugins.reset();</span>
        }
        // make sure the reset worked
<span class="fc" id="L338">        assertNotSame(ImmediateThinScheduler.INSTANCE, Schedulers.computation());</span>
<span class="fc" id="L339">    }</span>

    @Test
    public void overrideIoScheduler() {
        try {
<span class="fc" id="L344">            RxJavaPlugins.setIoSchedulerHandler(replaceWithImmediate);</span>

<span class="fc" id="L346">            assertSame(ImmediateThinScheduler.INSTANCE, Schedulers.io());</span>
        } finally {
<span class="fc" id="L348">            RxJavaPlugins.reset();</span>
        }
        // make sure the reset worked
<span class="fc" id="L351">        assertNotSame(ImmediateThinScheduler.INSTANCE, Schedulers.io());</span>
<span class="fc" id="L352">    }</span>

    @Test
    public void overrideNewThreadScheduler() {
        try {
<span class="fc" id="L357">            RxJavaPlugins.setNewThreadSchedulerHandler(replaceWithImmediate);</span>

<span class="fc" id="L359">            assertSame(ImmediateThinScheduler.INSTANCE, Schedulers.newThread());</span>
        } finally {
<span class="fc" id="L361">            RxJavaPlugins.reset();</span>
        }
        // make sure the reset worked
<span class="fc" id="L364">        assertNotSame(ImmediateThinScheduler.INSTANCE, Schedulers.newThread());</span>
<span class="fc" id="L365">    }</span>

<span class="fc" id="L367">    Function&lt;Callable&lt;Scheduler&gt;, Scheduler&gt; initReplaceWithImmediate = new Function&lt;Callable&lt;Scheduler&gt;, Scheduler&gt;() {</span>
        @Override
        public Scheduler apply(Callable&lt;Scheduler&gt; t) {
<span class="fc" id="L370">            return ImmediateThinScheduler.INSTANCE;</span>
        }
    };

    @Test
    public void overrideInitSingleScheduler() {
<span class="fc" id="L376">        final Scheduler s = Schedulers.single(); // make sure the Schedulers is initialized</span>
<span class="fc" id="L377">        Callable&lt;Scheduler&gt; c = new Callable&lt;Scheduler&gt;() {</span>
            @Override
            public Scheduler call() throws Exception {
<span class="fc" id="L380">                return s;</span>
            }
        };
        try {
<span class="fc" id="L384">            RxJavaPlugins.setInitSingleSchedulerHandler(initReplaceWithImmediate);</span>

<span class="fc" id="L386">            assertSame(ImmediateThinScheduler.INSTANCE, RxJavaPlugins.initSingleScheduler(c));</span>
        } finally {
<span class="fc" id="L388">            RxJavaPlugins.reset();</span>
        }
        // make sure the reset worked
<span class="fc" id="L391">        assertSame(s, RxJavaPlugins.initSingleScheduler(c));</span>
<span class="fc" id="L392">    }</span>

    @Test
    public void overrideInitComputationScheduler() {
<span class="fc" id="L396">        final Scheduler s = Schedulers.computation(); // make sure the Schedulers is initialized</span>
<span class="fc" id="L397">        Callable&lt;Scheduler&gt; c = new Callable&lt;Scheduler&gt;() {</span>
            @Override
            public Scheduler call() throws Exception {
<span class="fc" id="L400">                return s;</span>
            }
        };
        try {
<span class="fc" id="L404">            RxJavaPlugins.setInitComputationSchedulerHandler(initReplaceWithImmediate);</span>

<span class="fc" id="L406">            assertSame(ImmediateThinScheduler.INSTANCE, RxJavaPlugins.initComputationScheduler(c));</span>
        } finally {
<span class="fc" id="L408">            RxJavaPlugins.reset();</span>
        }
        // make sure the reset worked
<span class="fc" id="L411">        assertSame(s, RxJavaPlugins.initComputationScheduler(c));</span>
<span class="fc" id="L412">    }</span>

    @Test
    public void overrideInitIoScheduler() {
<span class="fc" id="L416">        final Scheduler s = Schedulers.io(); // make sure the Schedulers is initialized;</span>
<span class="fc" id="L417">        Callable&lt;Scheduler&gt; c = new Callable&lt;Scheduler&gt;() {</span>
            @Override
            public Scheduler call() throws Exception {
<span class="fc" id="L420">                return s;</span>
            }
        };
        try {
<span class="fc" id="L424">            RxJavaPlugins.setInitIoSchedulerHandler(initReplaceWithImmediate);</span>

<span class="fc" id="L426">            assertSame(ImmediateThinScheduler.INSTANCE, RxJavaPlugins.initIoScheduler(c));</span>
        } finally {
<span class="fc" id="L428">            RxJavaPlugins.reset();</span>
        }
        // make sure the reset worked
<span class="fc" id="L431">        assertSame(s, RxJavaPlugins.initIoScheduler(c));</span>
<span class="fc" id="L432">    }</span>

    @Test
    public void overrideInitNewThreadScheduler() {
<span class="fc" id="L436">        final Scheduler s = Schedulers.newThread(); // make sure the Schedulers is initialized;</span>
<span class="fc" id="L437">        Callable&lt;Scheduler&gt; c = new Callable&lt;Scheduler&gt;() {</span>
            @Override
            public Scheduler call() throws Exception {
<span class="fc" id="L440">                return s;</span>
            }
        };
        try {
<span class="fc" id="L444">            RxJavaPlugins.setInitNewThreadSchedulerHandler(initReplaceWithImmediate);</span>

<span class="fc" id="L446">            assertSame(ImmediateThinScheduler.INSTANCE, RxJavaPlugins.initNewThreadScheduler(c));</span>
        } finally {
<span class="fc" id="L448">            RxJavaPlugins.reset();</span>
        }
        // make sure the reset worked
<span class="fc" id="L451">        assertSame(s, RxJavaPlugins.initNewThreadScheduler(c));</span>
<span class="fc" id="L452">    }</span>

<span class="fc" id="L454">    Callable&lt;Scheduler&gt; nullResultCallable = new Callable&lt;Scheduler&gt;() {</span>
        @Override
        public Scheduler call() throws Exception {
<span class="fc" id="L457">            return null;</span>
        }
    };

    @Test
    public void overrideInitSingleSchedulerCrashes() {
        // fail when Callable is null
        try {
<span class="nc" id="L465">            RxJavaPlugins.initSingleScheduler(null);</span>
<span class="nc" id="L466">            fail(&quot;Should have thrown NullPointerException&quot;);</span>
<span class="fc" id="L467">        } catch (NullPointerException npe) {</span>
<span class="fc" id="L468">            assertEquals(&quot;Scheduler Callable can't be null&quot;, npe.getMessage());</span>
<span class="nc" id="L469">        }</span>

        // fail when Callable result is null
        try {
<span class="nc" id="L473">            RxJavaPlugins.initSingleScheduler(nullResultCallable);</span>
<span class="nc" id="L474">            fail(&quot;Should have thrown NullPointerException&quot;);</span>
<span class="fc" id="L475">        } catch (NullPointerException npe) {</span>
<span class="fc" id="L476">            assertEquals(&quot;Scheduler Callable result can't be null&quot;, npe.getMessage());</span>
<span class="nc" id="L477">        }</span>
<span class="fc" id="L478">    }</span>

    @Test
    public void overrideInitComputationSchedulerCrashes() {
        // fail when Callable is null
        try {
<span class="nc" id="L484">            RxJavaPlugins.initComputationScheduler(null);</span>
<span class="nc" id="L485">            fail(&quot;Should have thrown NullPointerException&quot;);</span>
<span class="fc" id="L486">        } catch (NullPointerException npe) {</span>
<span class="fc" id="L487">            assertEquals(&quot;Scheduler Callable can't be null&quot;, npe.getMessage());</span>
<span class="nc" id="L488">        }</span>

        // fail when Callable result is null
        try {
<span class="nc" id="L492">            RxJavaPlugins.initComputationScheduler(nullResultCallable);</span>
<span class="nc" id="L493">            fail(&quot;Should have thrown NullPointerException&quot;);</span>
<span class="fc" id="L494">        } catch (NullPointerException npe) {</span>
<span class="fc" id="L495">            assertEquals(&quot;Scheduler Callable result can't be null&quot;, npe.getMessage());</span>
<span class="nc" id="L496">        }</span>
<span class="fc" id="L497">    }</span>

    @Test
    public void overrideInitIoSchedulerCrashes() {
        // fail when Callable is null
        try {
<span class="nc" id="L503">            RxJavaPlugins.initIoScheduler(null);</span>
<span class="nc" id="L504">            fail(&quot;Should have thrown NullPointerException&quot;);</span>
<span class="fc" id="L505">        } catch (NullPointerException npe) {</span>
<span class="fc" id="L506">            assertEquals(&quot;Scheduler Callable can't be null&quot;, npe.getMessage());</span>
<span class="nc" id="L507">        }</span>

        // fail when Callable result is null
        try {
<span class="nc" id="L511">            RxJavaPlugins.initIoScheduler(nullResultCallable);</span>
<span class="nc" id="L512">            fail(&quot;Should have thrown NullPointerException&quot;);</span>
<span class="fc" id="L513">        } catch (NullPointerException npe) {</span>
<span class="fc" id="L514">            assertEquals(&quot;Scheduler Callable result can't be null&quot;, npe.getMessage());</span>
<span class="nc" id="L515">        }</span>
<span class="fc" id="L516">    }</span>

    @Test
    public void overrideInitNewThreadSchedulerCrashes() {
        // fail when Callable is null
        try {
<span class="nc" id="L522">            RxJavaPlugins.initNewThreadScheduler(null);</span>
<span class="nc" id="L523">            fail(&quot;Should have thrown NullPointerException&quot;);</span>
<span class="fc" id="L524">        } catch (NullPointerException npe) {</span>
            // expected
<span class="fc" id="L526">            assertEquals(&quot;Scheduler Callable can't be null&quot;, npe.getMessage());</span>
<span class="nc" id="L527">        }</span>

        // fail when Callable result is null
        try {
<span class="nc" id="L531">            RxJavaPlugins.initNewThreadScheduler(nullResultCallable);</span>
<span class="nc" id="L532">            fail(&quot;Should have thrown NullPointerException&quot;);</span>
<span class="fc" id="L533">        } catch (NullPointerException npe) {</span>
<span class="fc" id="L534">            assertEquals(&quot;Scheduler Callable result can't be null&quot;, npe.getMessage());</span>
<span class="nc" id="L535">        }</span>
<span class="fc" id="L536">    }</span>

<span class="fc" id="L538">    Callable&lt;Scheduler&gt; unsafeDefault = new Callable&lt;Scheduler&gt;() {</span>
        @Override
        public Scheduler call() throws Exception {
<span class="nc" id="L541">            throw new AssertionError(&quot;Default Scheduler instance should not have been evaluated&quot;);</span>
        }
    };

    @Test
    public void testDefaultSingleSchedulerIsInitializedLazily() {
        // unsafe default Scheduler Callable should not be evaluated
        try {
<span class="fc" id="L549">            RxJavaPlugins.setInitSingleSchedulerHandler(initReplaceWithImmediate);</span>
<span class="fc" id="L550">            RxJavaPlugins.initSingleScheduler(unsafeDefault);</span>
        } finally {
<span class="fc" id="L552">            RxJavaPlugins.reset();</span>
        }

        // make sure the reset worked
<span class="fc" id="L556">        assertNotSame(ImmediateThinScheduler.INSTANCE, Schedulers.single());</span>
<span class="fc" id="L557">    }</span>

    @Test
    public void testDefaultIoSchedulerIsInitializedLazily() {
        // unsafe default Scheduler Callable should not be evaluated
        try {
<span class="fc" id="L563">            RxJavaPlugins.setInitIoSchedulerHandler(initReplaceWithImmediate);</span>
<span class="fc" id="L564">            RxJavaPlugins.initIoScheduler(unsafeDefault);</span>
        } finally {
<span class="fc" id="L566">            RxJavaPlugins.reset();</span>
        }

        // make sure the reset worked
<span class="fc" id="L570">        assertNotSame(ImmediateThinScheduler.INSTANCE, Schedulers.io());</span>
<span class="fc" id="L571">    }</span>

    @Test
    public void testDefaultComputationSchedulerIsInitializedLazily() {
        // unsafe default Scheduler Callable should not be evaluated
        try {
<span class="fc" id="L577">            RxJavaPlugins.setInitComputationSchedulerHandler(initReplaceWithImmediate);</span>
<span class="fc" id="L578">            RxJavaPlugins.initComputationScheduler(unsafeDefault);</span>
        } finally {
<span class="fc" id="L580">            RxJavaPlugins.reset();</span>
        }

        // make sure the reset worked
<span class="fc" id="L584">        assertNotSame(ImmediateThinScheduler.INSTANCE, Schedulers.computation());</span>
<span class="fc" id="L585">    }</span>

    @Test
    public void testDefaultNewThreadSchedulerIsInitializedLazily() {
        // unsafe default Scheduler Callable should not be evaluated
        try {
<span class="fc" id="L591">            RxJavaPlugins.setInitNewThreadSchedulerHandler(initReplaceWithImmediate);</span>
<span class="fc" id="L592">            RxJavaPlugins.initNewThreadScheduler(unsafeDefault);</span>
        } finally {
<span class="fc" id="L594">            RxJavaPlugins.reset();</span>
        }

        // make sure the reset worked
<span class="fc" id="L598">        assertNotSame(ImmediateThinScheduler.INSTANCE, Schedulers.newThread());</span>
<span class="fc" id="L599">    }</span>

    @SuppressWarnings(&quot;rawtypes&quot;)
    @Test
    public void observableCreate() {
        try {
<span class="fc" id="L605">            RxJavaPlugins.setOnObservableAssembly(new Function&lt;Observable, Observable&gt;() {</span>
                @Override
                public Observable apply(Observable t) {
<span class="fc" id="L608">                    return new ObservableRange(1, 2);</span>
                }
            });

<span class="fc" id="L612">            Observable.range(10, 3)</span>
<span class="fc" id="L613">            .test()</span>
<span class="fc" id="L614">            .assertValues(1, 2)</span>
<span class="fc" id="L615">            .assertNoErrors()</span>
<span class="fc" id="L616">            .assertComplete();</span>
        } finally {
<span class="fc" id="L618">            RxJavaPlugins.reset();</span>
        }
        // make sure the reset worked
<span class="fc" id="L621">        Observable.range(10, 3)</span>
<span class="fc" id="L622">        .test()</span>
<span class="fc" id="L623">        .assertValues(10, 11, 12)</span>
<span class="fc" id="L624">        .assertNoErrors()</span>
<span class="fc" id="L625">        .assertComplete();</span>
<span class="fc" id="L626">    }</span>

    @SuppressWarnings(&quot;rawtypes&quot;)
    @Test
    public void flowableCreate() {
        try {
<span class="fc" id="L632">            RxJavaPlugins.setOnFlowableAssembly(new Function&lt;Flowable, Flowable&gt;() {</span>
                @Override
                public Flowable apply(Flowable t) {
<span class="fc" id="L635">                    return new FlowableRange(1, 2);</span>
                }
            });

<span class="fc" id="L639">            Flowable.range(10, 3)</span>
<span class="fc" id="L640">            .test()</span>
<span class="fc" id="L641">            .assertValues(1, 2)</span>
<span class="fc" id="L642">            .assertNoErrors()</span>
<span class="fc" id="L643">            .assertComplete();</span>
        } finally {
<span class="fc" id="L645">            RxJavaPlugins.reset();</span>
        }
        // make sure the reset worked
<span class="fc" id="L648">        Flowable.range(10, 3)</span>
<span class="fc" id="L649">        .test()</span>
<span class="fc" id="L650">        .assertValues(10, 11, 12)</span>
<span class="fc" id="L651">        .assertNoErrors()</span>
<span class="fc" id="L652">        .assertComplete();</span>
<span class="fc" id="L653">    }</span>

    @SuppressWarnings(&quot;rawtypes&quot;)
    @Test
    public void observableStart() {
        try {
<span class="fc" id="L659">            RxJavaPlugins.setOnObservableSubscribe(new BiFunction&lt;Observable, Observer, Observer&gt;() {</span>
                @Override
                public Observer apply(Observable o, final Observer t) {
<span class="fc" id="L662">                    return new Observer() {</span>

                        @Override
                        public void onSubscribe(Disposable d) {
<span class="fc" id="L666">                            t.onSubscribe(d);</span>
<span class="fc" id="L667">                        }</span>

                        @SuppressWarnings(&quot;unchecked&quot;)
                        @Override
                        public void onNext(Object value) {
<span class="fc" id="L672">                            t.onNext((Integer)value - 9);</span>
<span class="fc" id="L673">                        }</span>

                        @Override
                        public void onError(Throwable e) {
<span class="nc" id="L677">                            t.onError(e);</span>
<span class="nc" id="L678">                        }</span>

                        @Override
                        public void onComplete() {
<span class="fc" id="L682">                            t.onComplete();</span>
<span class="fc" id="L683">                        }</span>

                    };
                }
            });

<span class="fc" id="L689">            Observable.range(10, 3)</span>
<span class="fc" id="L690">            .test()</span>
<span class="fc" id="L691">            .assertValues(1, 2, 3)</span>
<span class="fc" id="L692">            .assertNoErrors()</span>
<span class="fc" id="L693">            .assertComplete();</span>
        } finally {
<span class="fc" id="L695">            RxJavaPlugins.reset();</span>
        }
        // make sure the reset worked
<span class="fc" id="L698">        Observable.range(10, 3)</span>
<span class="fc" id="L699">        .test()</span>
<span class="fc" id="L700">        .assertValues(10, 11, 12)</span>
<span class="fc" id="L701">        .assertNoErrors()</span>
<span class="fc" id="L702">        .assertComplete();</span>
<span class="fc" id="L703">    }</span>

    @SuppressWarnings(&quot;rawtypes&quot;)
    @Test
    public void flowableStart() {
        try {
<span class="fc" id="L709">            RxJavaPlugins.setOnFlowableSubscribe(new BiFunction&lt;Flowable, Subscriber, Subscriber&gt;() {</span>
                @Override
                public Subscriber apply(Flowable f, final Subscriber t) {
<span class="fc" id="L712">                    return new Subscriber() {</span>

                        @Override
                        public void onSubscribe(Subscription s) {
<span class="fc" id="L716">                            t.onSubscribe(s);</span>
<span class="fc" id="L717">                        }</span>

                        @SuppressWarnings(&quot;unchecked&quot;)
                        @Override
                        public void onNext(Object value) {
<span class="fc" id="L722">                            t.onNext((Integer)value - 9);</span>
<span class="fc" id="L723">                        }</span>

                        @Override
                        public void onError(Throwable e) {
<span class="nc" id="L727">                            t.onError(e);</span>
<span class="nc" id="L728">                        }</span>

                        @Override
                        public void onComplete() {
<span class="fc" id="L732">                            t.onComplete();</span>
<span class="fc" id="L733">                        }</span>

                    };
                }
            });

<span class="fc" id="L739">            Flowable.range(10, 3)</span>
<span class="fc" id="L740">            .test()</span>
<span class="fc" id="L741">            .assertValues(1, 2, 3)</span>
<span class="fc" id="L742">            .assertNoErrors()</span>
<span class="fc" id="L743">            .assertComplete();</span>
        } finally {
<span class="fc" id="L745">            RxJavaPlugins.reset();</span>
        }
        // make sure the reset worked
<span class="fc" id="L748">        Flowable.range(10, 3)</span>
<span class="fc" id="L749">        .test()</span>
<span class="fc" id="L750">        .assertValues(10, 11, 12)</span>
<span class="fc" id="L751">        .assertNoErrors()</span>
<span class="fc" id="L752">        .assertComplete();</span>
<span class="fc" id="L753">    }</span>

    @Test
    @Ignore(&quot;Different architecture, no longer supported&quot;)
    public void observableReturn() {
//        try {
//            final Subscription s = Subscriptions.empty();
//
//            RxJavaPlugins.setOnObservableReturn(new Function&lt;Subscription, Subscription&gt;() {
//                @Override
//                public Subscription call(Subscription t) {
//                    return s;
//                }
//            });
//
//            TestSubscriber&lt;Integer&gt; ts = TestSubscriber.create();
//
//            Subscription u = Observable.range(10, 3).subscribe(ts);
//
//            ts.assertValues(10, 11, 12);
//            ts.assertNoErrors();
//            ts.assertComplete();
//
//            assertSame(s, u);
//        } finally {
//            RxJavaPlugins.reset();
//        }
<span class="nc" id="L780">    }</span>

    @SuppressWarnings(&quot;rawtypes&quot;)
    @Test
    public void singleCreate() {
        try {
<span class="fc" id="L786">            RxJavaPlugins.setOnSingleAssembly(new Function&lt;Single, Single&gt;() {</span>
                @Override
                public Single apply(Single t) {
<span class="fc" id="L789">                    return new SingleJust&lt;Integer&gt;(10);</span>
                }
            });

<span class="fc" id="L793">            Single.just(1)</span>
<span class="fc" id="L794">            .test()</span>
<span class="fc" id="L795">            .assertValue(10)</span>
<span class="fc" id="L796">            .assertNoErrors()</span>
<span class="fc" id="L797">            .assertComplete();</span>
        } finally {
<span class="fc" id="L799">            RxJavaPlugins.reset();</span>
        }
        // make sure the reset worked
<span class="fc" id="L802">        Single.just(1)</span>
<span class="fc" id="L803">        .test()</span>
<span class="fc" id="L804">        .assertValue(1)</span>
<span class="fc" id="L805">        .assertNoErrors()</span>
<span class="fc" id="L806">        .assertComplete();</span>
<span class="fc" id="L807">    }</span>

    @SuppressWarnings(&quot;rawtypes&quot;)
    @Test
    public void singleStart() {
        try {
<span class="fc" id="L813">            RxJavaPlugins.setOnSingleSubscribe(new BiFunction&lt;Single, SingleObserver, SingleObserver&gt;() {</span>
                @Override
                public SingleObserver apply(Single o, final SingleObserver t) {
<span class="fc" id="L816">                    return new SingleObserver&lt;Object&gt;() {</span>

                        @Override
                        public void onSubscribe(Disposable d) {
<span class="fc" id="L820">                            t.onSubscribe(d);</span>
<span class="fc" id="L821">                        }</span>

                        @SuppressWarnings(&quot;unchecked&quot;)
                        @Override
                        public void onSuccess(Object value) {
<span class="fc" id="L826">                            t.onSuccess(10);</span>
<span class="fc" id="L827">                        }</span>

                        @Override
                        public void onError(Throwable e) {
<span class="nc" id="L831">                            t.onError(e);</span>
<span class="nc" id="L832">                        }</span>

                    };
                }
            });

<span class="fc" id="L838">            Single.just(1)</span>
<span class="fc" id="L839">            .test()</span>
<span class="fc" id="L840">            .assertValue(10)</span>
<span class="fc" id="L841">            .assertNoErrors()</span>
<span class="fc" id="L842">            .assertComplete();</span>
        } finally {
<span class="fc" id="L844">            RxJavaPlugins.reset();</span>
        }
        // make sure the reset worked
<span class="fc" id="L847">        Single.just(1)</span>
<span class="fc" id="L848">        .test()</span>
<span class="fc" id="L849">        .assertValue(1)</span>
<span class="fc" id="L850">        .assertNoErrors()</span>
<span class="fc" id="L851">        .assertComplete();</span>
<span class="fc" id="L852">    }</span>

    @Test
    @Ignore(&quot;Different architecture, no longer supported&quot;)
    public void singleReturn() {
//        try {
//            final Subscription s = Subscriptions.empty();
//
//            RxJavaPlugins.setOnSingleReturn(new Function&lt;Subscription, Subscription&gt;() {
//                @Override
//                public Subscription call(Subscription t) {
//                    return s;
//                }
//            });
//
//            TestSubscriber&lt;Integer&gt; ts = TestSubscriber.create();
//
//            Subscription u = Single.just(1).subscribe(ts);
//
//            ts.assertValue(1);
//            ts.assertNoErrors();
//            ts.assertComplete();
//
//            assertSame(s, u);
//        } finally {
//            RxJavaPlugins.reset();
//        }
<span class="nc" id="L879">    }</span>

    @Test
    public void completableCreate() {
        try {
<span class="fc" id="L884">            RxJavaPlugins.setOnCompletableAssembly(new Function&lt;Completable, Completable&gt;() {</span>
                @Override
                public Completable apply(Completable t) {
<span class="fc" id="L887">                    return new CompletableError(new TestException());</span>
                }
            });

<span class="fc" id="L891">            Completable.complete()</span>
<span class="fc" id="L892">            .test()</span>
<span class="fc" id="L893">            .assertNoValues()</span>
<span class="fc" id="L894">            .assertNotComplete()</span>
<span class="fc" id="L895">            .assertError(TestException.class);</span>
        } finally {
<span class="fc" id="L897">            RxJavaPlugins.reset();</span>
        }
        // make sure the reset worked
<span class="fc" id="L900">        Completable.complete()</span>
<span class="fc" id="L901">        .test()</span>
<span class="fc" id="L902">        .assertNoValues()</span>
<span class="fc" id="L903">        .assertNoErrors()</span>
<span class="fc" id="L904">        .assertComplete();</span>
<span class="fc" id="L905">    }</span>

    @Test
    public void completableStart() {
        try {
<span class="fc" id="L910">            RxJavaPlugins.setOnCompletableSubscribe(new BiFunction&lt;Completable, CompletableObserver, CompletableObserver&gt;() {</span>
                @Override
                public CompletableObserver apply(Completable o, final CompletableObserver t) {
<span class="fc" id="L913">                    return new CompletableObserver() {</span>
                        @Override
                        public void onSubscribe(Disposable d) {
<span class="fc" id="L916">                            t.onSubscribe(d);</span>
<span class="fc" id="L917">                        }</span>

                        @Override
                        public void onError(Throwable e) {
<span class="nc" id="L921">                            t.onError(e);</span>
<span class="nc" id="L922">                        }</span>

                        @Override
                        public void onComplete() {
<span class="fc" id="L926">                            t.onError(new TestException());</span>
<span class="fc" id="L927">                        }</span>
                    };
                }
            });

<span class="fc" id="L932">            Completable.complete()</span>
<span class="fc" id="L933">            .test()</span>
<span class="fc" id="L934">            .assertNoValues()</span>
<span class="fc" id="L935">            .assertNotComplete()</span>
<span class="fc" id="L936">            .assertError(TestException.class);</span>
        } finally {
<span class="fc" id="L938">            RxJavaPlugins.reset();</span>
        }
        // make sure the reset worked

<span class="fc" id="L942">        Completable.complete()</span>
<span class="fc" id="L943">        .test()</span>
<span class="fc" id="L944">        .assertNoValues()</span>
<span class="fc" id="L945">        .assertNoErrors()</span>
<span class="fc" id="L946">        .assertComplete();</span>
<span class="fc" id="L947">    }</span>

    void onSchedule(Worker w) throws InterruptedException {
        try {
            try {
<span class="fc" id="L952">                final AtomicInteger value = new AtomicInteger();</span>
<span class="fc" id="L953">                final CountDownLatch cdl = new CountDownLatch(1);</span>

<span class="fc" id="L955">                RxJavaPlugins.setScheduleHandler(new Function&lt;Runnable, Runnable&gt;() {</span>
                    @Override
                    public Runnable apply(Runnable t) {
<span class="fc" id="L958">                        return new Runnable() {</span>
                            @Override
                            public void run() {
<span class="fc" id="L961">                                value.set(10);</span>
<span class="fc" id="L962">                                cdl.countDown();</span>
<span class="fc" id="L963">                            }</span>
                        };
                    }
                });

<span class="fc" id="L968">                w.schedule(new Runnable() {</span>
                    @Override
                    public void run() {
<span class="nc" id="L971">                        value.set(1);</span>
<span class="nc" id="L972">                        cdl.countDown();</span>
<span class="nc" id="L973">                    }</span>
                });

<span class="fc" id="L976">                cdl.await();</span>

<span class="fc" id="L978">                assertEquals(10, value.get());</span>

            } finally {

<span class="fc" id="L982">                RxJavaPlugins.reset();</span>
            }

            // make sure the reset worked
<span class="fc" id="L986">            final AtomicInteger value = new AtomicInteger();</span>
<span class="fc" id="L987">            final CountDownLatch cdl = new CountDownLatch(1);</span>

<span class="fc" id="L989">            w.schedule(new Runnable() {</span>
                @Override
                public void run() {
<span class="fc" id="L992">                    value.set(1);</span>
<span class="fc" id="L993">                    cdl.countDown();</span>
<span class="fc" id="L994">                }</span>
            });

<span class="fc" id="L997">            cdl.await();</span>

<span class="fc" id="L999">            assertEquals(1, value.get());</span>
        } finally {
<span class="fc" id="L1001">            w.dispose();</span>
        }
<span class="fc" id="L1003">    }</span>

    @Test
    public void onScheduleComputation() throws InterruptedException {
<span class="fc" id="L1007">        onSchedule(Schedulers.computation().createWorker());</span>
<span class="fc" id="L1008">    }</span>

    @Test
    public void onScheduleIO() throws InterruptedException {
<span class="fc" id="L1012">        onSchedule(Schedulers.io().createWorker());</span>
<span class="fc" id="L1013">    }</span>

    @Test
    public void onScheduleNewThread() throws InterruptedException {
<span class="fc" id="L1017">        onSchedule(Schedulers.newThread().createWorker());</span>
<span class="fc" id="L1018">    }</span>

    @Test
    public void onError() {
        try {
<span class="fc" id="L1023">            final List&lt;Throwable&gt; list = new ArrayList&lt;Throwable&gt;();</span>

<span class="fc" id="L1025">            RxJavaPlugins.setErrorHandler(new Consumer&lt;Throwable&gt;() {</span>
                @Override
                public void accept(Throwable t) {
<span class="fc" id="L1028">                    list.add(t);</span>
<span class="fc" id="L1029">                }</span>
            });

<span class="fc" id="L1032">            RxJavaPlugins.onError(new TestException(&quot;Forced failure&quot;));</span>

<span class="fc" id="L1034">            assertEquals(1, list.size());</span>
<span class="fc" id="L1035">            assertUndeliverableTestException(list, 0, &quot;Forced failure&quot;);</span>
        } finally {
<span class="fc" id="L1037">            RxJavaPlugins.reset();</span>
        }
<span class="fc" id="L1039">    }</span>

    @Test
    @Ignore(&quot;No (need for) clear() method in 2.0&quot;)
    public void clear() throws Exception {
//        RxJavaPlugins.reset();
//        try {
//            RxJavaPlugins.clear();
//            for (Method m : RxJavaPlugins.class.getMethods()) {
//                if (m.getName().startsWith(&quot;getOn&quot;)) {
//                    assertNull(m.toString(), m.invoke(null));
//                }
//            }
//
//        } finally {
//            RxJavaPlugins.reset();
//        }
//
//        for (Method m : RxJavaPlugins.class.getMethods()) {
//            if (m.getName().startsWith(&quot;getOn&quot;)
//                    &amp;&amp; !m.getName().endsWith(&quot;Scheduler&quot;)
//                    &amp;&amp; !m.getName().contains(&quot;GenericScheduledExecutorService&quot;)) {
//                assertNotNull(m.toString(), m.invoke(null));
//            }
//        }
<span class="nc" id="L1064">    }</span>

    @Test
    public void onErrorNoHandler() {
        try {
<span class="fc" id="L1069">            final List&lt;Throwable&gt; list = new ArrayList&lt;Throwable&gt;();</span>

<span class="fc" id="L1071">            RxJavaPlugins.setErrorHandler(null);</span>

<span class="fc" id="L1073">            Thread.currentThread().setUncaughtExceptionHandler(new UncaughtExceptionHandler() {</span>

                @Override
                public void uncaughtException(Thread t, Throwable e) {
<span class="fc" id="L1077">                    list.add(e);</span>

<span class="fc" id="L1079">                }</span>
            });

<span class="fc" id="L1082">            RxJavaPlugins.onError(new TestException(&quot;Forced failure&quot;));</span>

<span class="fc" id="L1084">            Thread.currentThread().setUncaughtExceptionHandler(null);</span>

            // this will be printed on the console and should not crash
<span class="fc" id="L1087">            RxJavaPlugins.onError(new TestException(&quot;Forced failure 3&quot;));</span>

<span class="fc" id="L1089">            assertEquals(1, list.size());</span>
<span class="fc" id="L1090">            assertUndeliverableTestException(list, 0, &quot;Forced failure&quot;);</span>
        } finally {
<span class="fc" id="L1092">            RxJavaPlugins.reset();</span>
<span class="fc" id="L1093">            Thread.currentThread().setUncaughtExceptionHandler(null);</span>
        }
<span class="fc" id="L1095">    }</span>

    @Test
    public void onErrorCrashes() {
        try {
<span class="fc" id="L1100">            final List&lt;Throwable&gt; list = new ArrayList&lt;Throwable&gt;();</span>

<span class="fc" id="L1102">            RxJavaPlugins.setErrorHandler(new Consumer&lt;Throwable&gt;() {</span>
                @Override
                public void accept(Throwable t) {
<span class="fc" id="L1105">                    throw new TestException(&quot;Forced failure 2&quot;);</span>
                }
            });

<span class="fc" id="L1109">            Thread.currentThread().setUncaughtExceptionHandler(new UncaughtExceptionHandler() {</span>

                @Override
                public void uncaughtException(Thread t, Throwable e) {
<span class="fc" id="L1113">                    list.add(e);</span>

<span class="fc" id="L1115">                }</span>
            });

<span class="fc" id="L1118">            RxJavaPlugins.onError(new TestException(&quot;Forced failure&quot;));</span>

<span class="fc" id="L1120">            assertEquals(2, list.size());</span>
<span class="fc" id="L1121">            assertTestException(list, 0, &quot;Forced failure 2&quot;);</span>
<span class="fc" id="L1122">            assertUndeliverableTestException(list, 1, &quot;Forced failure&quot;);</span>

<span class="fc" id="L1124">            Thread.currentThread().setUncaughtExceptionHandler(null);</span>

        } finally {
<span class="fc" id="L1127">            RxJavaPlugins.reset();</span>
<span class="fc" id="L1128">            Thread.currentThread().setUncaughtExceptionHandler(null);</span>
        }
<span class="fc" id="L1130">    }</span>

    @Test
    public void onErrorWithNull() {
        try {
<span class="fc" id="L1135">            final List&lt;Throwable&gt; list = new ArrayList&lt;Throwable&gt;();</span>

<span class="fc" id="L1137">            RxJavaPlugins.setErrorHandler(new Consumer&lt;Throwable&gt;() {</span>
                @Override
                public void accept(Throwable t) {
<span class="fc" id="L1140">                    throw new TestException(&quot;Forced failure 2&quot;);</span>
                }
            });

<span class="fc" id="L1144">            Thread.currentThread().setUncaughtExceptionHandler(new UncaughtExceptionHandler() {</span>

                @Override
                public void uncaughtException(Thread t, Throwable e) {
<span class="fc" id="L1148">                    list.add(e);</span>

<span class="fc" id="L1150">                }</span>
            });

<span class="fc" id="L1153">            RxJavaPlugins.onError(null);</span>

<span class="fc" id="L1155">            assertEquals(2, list.size());</span>
<span class="fc" id="L1156">            assertTestException(list, 0, &quot;Forced failure 2&quot;);</span>
<span class="fc" id="L1157">            assertNPE(list, 1);</span>

<span class="fc" id="L1159">            RxJavaPlugins.reset();</span>

<span class="fc" id="L1161">            RxJavaPlugins.onError(null);</span>

<span class="fc" id="L1163">            assertNPE(list, 2);</span>

        } finally {
<span class="fc" id="L1166">            RxJavaPlugins.reset();</span>

<span class="fc" id="L1168">            Thread.currentThread().setUncaughtExceptionHandler(null);</span>
        }
<span class="fc" id="L1170">    }</span>

    /**
     * Ensure set*() accepts a consumers/functions with wider bounds.
     * @throws Exception on error
     */
    @Test
    @SuppressWarnings(&quot;rawtypes&quot;)
    public void onErrorWithSuper() throws Exception {
        try {
<span class="fc" id="L1180">            Consumer&lt;? super Throwable&gt; errorHandler = new Consumer&lt;Throwable&gt;() {</span>
                @Override
                public void accept(Throwable t) {
<span class="nc" id="L1183">                    throw new TestException(&quot;Forced failure 2&quot;);</span>
                }
            };
<span class="fc" id="L1186">            RxJavaPlugins.setErrorHandler(errorHandler);</span>

<span class="fc" id="L1188">            Consumer&lt;? super Throwable&gt; errorHandler1 = RxJavaPlugins.getErrorHandler();</span>
<span class="fc" id="L1189">            assertSame(errorHandler, errorHandler1);</span>

<span class="fc" id="L1191">            Function&lt;? super Scheduler, ? extends Scheduler&gt; scheduler2scheduler = new Function&lt;Scheduler, Scheduler&gt;() {</span>
                @Override
                public Scheduler apply(Scheduler scheduler) throws Exception {
<span class="nc" id="L1194">                    return scheduler;</span>
                }
            };
<span class="fc" id="L1197">            Function&lt;? super Callable&lt;Scheduler&gt;, ? extends Scheduler&gt; callable2scheduler = new Function&lt;Callable&lt;Scheduler&gt;, Scheduler&gt;() {</span>
                @Override
                public Scheduler apply(Callable&lt;Scheduler&gt; schedulerCallable) throws Exception {
<span class="nc" id="L1200">                    return schedulerCallable.call();</span>
                }
            };
<span class="fc" id="L1203">            Function&lt;? super ConnectableFlowable, ? extends ConnectableFlowable&gt; connectableFlowable2ConnectableFlowable = new Function&lt;ConnectableFlowable, ConnectableFlowable&gt;() {</span>
                @Override
                public ConnectableFlowable apply(ConnectableFlowable connectableFlowable) throws Exception {
<span class="nc" id="L1206">                    return connectableFlowable;</span>
                }
            };
<span class="fc" id="L1209">            Function&lt;? super ConnectableObservable, ? extends ConnectableObservable&gt; connectableObservable2ConnectableObservable = new Function&lt;ConnectableObservable, ConnectableObservable&gt;() {</span>
                @Override
                public ConnectableObservable apply(ConnectableObservable connectableObservable) throws Exception {
<span class="nc" id="L1212">                    return connectableObservable;</span>
                }
            };
<span class="fc" id="L1215">            Function&lt;? super Flowable, ? extends Flowable&gt; flowable2Flowable = new Function&lt;Flowable, Flowable&gt;() {</span>
                @Override
                public Flowable apply(Flowable flowable) throws Exception {
<span class="nc" id="L1218">                    return flowable;</span>
                }
            };
<span class="fc" id="L1221">            BiFunction&lt;? super Flowable, ? super Subscriber, ? extends Subscriber&gt; flowable2subscriber = new BiFunction&lt;Flowable, Subscriber, Subscriber&gt;() {</span>
                @Override
                public Subscriber apply(Flowable flowable, Subscriber subscriber) throws Exception {
<span class="nc" id="L1224">                    return subscriber;</span>
                }
            };
<span class="fc" id="L1227">            Function&lt;Maybe, Maybe&gt; maybe2maybe = new Function&lt;Maybe, Maybe&gt;() {</span>
                @Override
                public Maybe apply(Maybe maybe) throws Exception {
<span class="nc" id="L1230">                    return maybe;</span>
                }
            };
<span class="fc" id="L1233">            BiFunction&lt;Maybe, MaybeObserver, MaybeObserver&gt; maybe2observer = new BiFunction&lt;Maybe, MaybeObserver, MaybeObserver&gt;() {</span>
                @Override
                public MaybeObserver apply(Maybe maybe, MaybeObserver maybeObserver) throws Exception {
<span class="nc" id="L1236">                    return maybeObserver;</span>
                }
            };
<span class="fc" id="L1239">            Function&lt;Observable, Observable&gt; observable2observable = new Function&lt;Observable, Observable&gt;() {</span>
                @Override
                public Observable apply(Observable observable) throws Exception {
<span class="nc" id="L1242">                    return observable;</span>
                }
            };
<span class="fc" id="L1245">            BiFunction&lt;? super Observable, ? super Observer, ? extends Observer&gt; observable2observer = new BiFunction&lt;Observable, Observer, Observer&gt;() {</span>
                @Override
                public Observer apply(Observable observable, Observer observer) throws Exception {
<span class="nc" id="L1248">                    return observer;</span>
                }
            };
<span class="fc" id="L1251">            Function&lt;? super ParallelFlowable, ? extends ParallelFlowable&gt; parallelFlowable2parallelFlowable = new Function&lt;ParallelFlowable, ParallelFlowable&gt;() {</span>
                @Override
                public ParallelFlowable apply(ParallelFlowable parallelFlowable) throws Exception {
<span class="nc" id="L1254">                    return parallelFlowable;</span>
                }
            };
<span class="fc" id="L1257">            Function&lt;Single, Single&gt; single2single = new Function&lt;Single, Single&gt;() {</span>
                @Override
                public Single apply(Single single) throws Exception {
<span class="nc" id="L1260">                    return single;</span>
                }
            };
<span class="fc" id="L1263">            BiFunction&lt;? super Single, ? super SingleObserver, ? extends SingleObserver&gt; single2observer = new BiFunction&lt;Single, SingleObserver, SingleObserver&gt;() {</span>
                @Override
                public SingleObserver apply(Single single, SingleObserver singleObserver) throws Exception {
<span class="nc" id="L1266">                    return singleObserver;</span>
                }
            };
<span class="fc" id="L1269">            Function&lt;? super Runnable, ? extends Runnable&gt; runnable2runnable = new Function&lt;Runnable, Runnable&gt;() {</span>
                @Override
                public Runnable apply(Runnable runnable) throws Exception {
<span class="nc" id="L1272">                    return runnable;</span>
                }
            };
<span class="fc" id="L1275">            BiFunction&lt;? super Completable, ? super CompletableObserver, ? extends CompletableObserver&gt; completableObserver2completableObserver = new BiFunction&lt;Completable, CompletableObserver, CompletableObserver&gt;() {</span>
                @Override
                public CompletableObserver apply(Completable completable, CompletableObserver completableObserver) throws Exception {
<span class="nc" id="L1278">                    return completableObserver;</span>
                }
            };
<span class="fc" id="L1281">            Function&lt;? super Completable, ? extends Completable&gt; completable2completable = new Function&lt;Completable, Completable&gt;() {</span>
                @Override
                public Completable apply(Completable completable) throws Exception {
<span class="nc" id="L1284">                    return completable;</span>
                }
            };

<span class="fc" id="L1288">            RxJavaPlugins.setInitComputationSchedulerHandler(callable2scheduler);</span>
<span class="fc" id="L1289">            RxJavaPlugins.setComputationSchedulerHandler(scheduler2scheduler);</span>
<span class="fc" id="L1290">            RxJavaPlugins.setIoSchedulerHandler(scheduler2scheduler);</span>
<span class="fc" id="L1291">            RxJavaPlugins.setNewThreadSchedulerHandler(scheduler2scheduler);</span>
<span class="fc" id="L1292">            RxJavaPlugins.setOnConnectableFlowableAssembly(connectableFlowable2ConnectableFlowable);</span>
<span class="fc" id="L1293">            RxJavaPlugins.setOnConnectableObservableAssembly(connectableObservable2ConnectableObservable);</span>
<span class="fc" id="L1294">            RxJavaPlugins.setOnFlowableAssembly(flowable2Flowable);</span>
<span class="fc" id="L1295">            RxJavaPlugins.setOnFlowableSubscribe(flowable2subscriber);</span>
<span class="fc" id="L1296">            RxJavaPlugins.setOnMaybeAssembly(maybe2maybe);</span>
<span class="fc" id="L1297">            RxJavaPlugins.setOnMaybeSubscribe(maybe2observer);</span>
<span class="fc" id="L1298">            RxJavaPlugins.setOnObservableAssembly(observable2observable);</span>
<span class="fc" id="L1299">            RxJavaPlugins.setOnObservableSubscribe(observable2observer);</span>
<span class="fc" id="L1300">            RxJavaPlugins.setOnParallelAssembly(parallelFlowable2parallelFlowable);</span>
<span class="fc" id="L1301">            RxJavaPlugins.setOnSingleAssembly(single2single);</span>
<span class="fc" id="L1302">            RxJavaPlugins.setOnSingleSubscribe(single2observer);</span>
<span class="fc" id="L1303">            RxJavaPlugins.setScheduleHandler(runnable2runnable);</span>
<span class="fc" id="L1304">            RxJavaPlugins.setSingleSchedulerHandler(scheduler2scheduler);</span>
<span class="fc" id="L1305">            RxJavaPlugins.setOnCompletableSubscribe(completableObserver2completableObserver);</span>
<span class="fc" id="L1306">            RxJavaPlugins.setOnCompletableAssembly(completable2completable);</span>
<span class="fc" id="L1307">            RxJavaPlugins.setInitSingleSchedulerHandler(callable2scheduler);</span>
<span class="fc" id="L1308">            RxJavaPlugins.setInitNewThreadSchedulerHandler(callable2scheduler);</span>
<span class="fc" id="L1309">            RxJavaPlugins.setInitIoSchedulerHandler(callable2scheduler);</span>
        } finally {
<span class="fc" id="L1311">            RxJavaPlugins.reset();</span>
        }
<span class="fc" id="L1313">    }</span>

    @SuppressWarnings({&quot;rawtypes&quot;, &quot;unchecked&quot; })
    @Test
    public void clearIsPassthrough() {
        try {
<span class="fc" id="L1319">            RxJavaPlugins.reset();</span>

<span class="fc" id="L1321">            assertNull(RxJavaPlugins.onAssembly((Observable)null));</span>

<span class="fc" id="L1323">            assertNull(RxJavaPlugins.onAssembly((ConnectableObservable)null));</span>

<span class="fc" id="L1325">            assertNull(RxJavaPlugins.onAssembly((Flowable)null));</span>

<span class="fc" id="L1327">            assertNull(RxJavaPlugins.onAssembly((ConnectableFlowable)null));</span>

<span class="fc" id="L1329">            Observable oos = new Observable() {</span>
                @Override
                public void subscribeActual(Observer t) {

<span class="nc" id="L1333">                }</span>
            };

<span class="fc" id="L1336">            Flowable fos = new Flowable() {</span>
                @Override
                public void subscribeActual(Subscriber t) {

<span class="nc" id="L1340">                }</span>
            };

<span class="fc" id="L1343">            assertSame(oos, RxJavaPlugins.onAssembly(oos));</span>

<span class="fc" id="L1345">            assertSame(fos, RxJavaPlugins.onAssembly(fos));</span>

<span class="fc" id="L1347">            assertNull(RxJavaPlugins.onAssembly((Single)null));</span>

<span class="fc" id="L1349">            Single sos = new Single() {</span>
                @Override
                public void subscribeActual(SingleObserver t) {

<span class="nc" id="L1353">                }</span>
            };

<span class="fc" id="L1356">            assertSame(sos, RxJavaPlugins.onAssembly(sos));</span>

<span class="fc" id="L1358">            assertNull(RxJavaPlugins.onAssembly((Completable)null));</span>

<span class="fc" id="L1360">            Completable cos = new Completable() {</span>
                @Override
                public void subscribeActual(CompletableObserver t) {

<span class="nc" id="L1364">                }</span>
            };

<span class="fc" id="L1367">            assertSame(cos, RxJavaPlugins.onAssembly(cos));</span>

<span class="fc" id="L1369">            assertNull(RxJavaPlugins.onAssembly((Maybe)null));</span>

<span class="fc" id="L1371">            Maybe myb = new Maybe() {</span>
                @Override
                public void subscribeActual(MaybeObserver t) {

<span class="nc" id="L1375">                }</span>
            };

<span class="fc" id="L1378">            assertSame(myb, RxJavaPlugins.onAssembly(myb));</span>

<span class="fc" id="L1380">            Runnable action = Functions.EMPTY_RUNNABLE;</span>
<span class="fc" id="L1381">            assertSame(action, RxJavaPlugins.onSchedule(action));</span>

<span class="fc" id="L1383">            class AllSubscriber implements Subscriber, Observer, SingleObserver, CompletableObserver, MaybeObserver {</span>

                @Override
                public void onSuccess(Object value) {

<span class="nc" id="L1388">                }</span>

                @Override
                public void onSubscribe(Disposable d) {

<span class="nc" id="L1393">                }</span>

                @Override
                public void onSubscribe(Subscription s) {

<span class="nc" id="L1398">                }</span>

                @Override
                public void onNext(Object t) {

<span class="nc" id="L1403">                }</span>

                @Override
                public void onError(Throwable t) {

<span class="nc" id="L1408">                }</span>

                @Override
                public void onComplete() {

<span class="nc" id="L1413">                }</span>

            }

<span class="fc" id="L1417">            AllSubscriber all = new AllSubscriber();</span>

<span class="fc" id="L1419">            assertNull(RxJavaPlugins.onSubscribe(Observable.never(), null));</span>

<span class="fc" id="L1421">            assertSame(all, RxJavaPlugins.onSubscribe(Observable.never(), all));</span>

<span class="fc" id="L1423">            assertNull(RxJavaPlugins.onSubscribe(Flowable.never(), null));</span>

<span class="fc" id="L1425">            assertSame(all, RxJavaPlugins.onSubscribe(Flowable.never(), all));</span>

<span class="fc" id="L1427">            assertNull(RxJavaPlugins.onSubscribe(Single.just(1), null));</span>

<span class="fc" id="L1429">            assertSame(all, RxJavaPlugins.onSubscribe(Single.just(1), all));</span>

<span class="fc" id="L1431">            assertNull(RxJavaPlugins.onSubscribe(Completable.never(), null));</span>

<span class="fc" id="L1433">            assertSame(all, RxJavaPlugins.onSubscribe(Completable.never(), all));</span>

<span class="fc" id="L1435">            assertNull(RxJavaPlugins.onSubscribe(Maybe.never(), null));</span>

<span class="fc" id="L1437">            assertSame(all, RxJavaPlugins.onSubscribe(Maybe.never(), all));</span>

            // These hooks don't exist in 2.0
//            Subscription subscription = Subscriptions.empty();
//
//            assertNull(RxJavaPlugins.onObservableReturn(null));
//
//            assertSame(subscription, RxJavaPlugins.onObservableReturn(subscription));
//
//            assertNull(RxJavaPlugins.onSingleReturn(null));
//
//            assertSame(subscription, RxJavaPlugins.onSingleReturn(subscription));
//
//            TestException ex = new TestException();
//
//            assertNull(RxJavaPlugins.onObservableError(null));
//
//            assertSame(ex, RxJavaPlugins.onObservableError(ex));
//
//            assertNull(RxJavaPlugins.onSingleError(null));
//
//            assertSame(ex, RxJavaPlugins.onSingleError(ex));
//
//            assertNull(RxJavaPlugins.onCompletableError(null));
//
//            assertSame(ex, RxJavaPlugins.onCompletableError(ex));
//
//            Observable.Operator oop = new Observable.Operator() {
//                @Override
//                public Object call(Object t) {
//                    return t;
//                }
//            };
//
//            assertNull(RxJavaPlugins.onObservableLift(null));
//
//            assertSame(oop, RxJavaPlugins.onObservableLift(oop));
//
//            assertNull(RxJavaPlugins.onSingleLift(null));
//
//            assertSame(oop, RxJavaPlugins.onSingleLift(oop));
//
//            Completable.CompletableOperator cop = new Completable.CompletableOperator() {
//                @Override
//                public CompletableSubscriber call(CompletableSubscriber t) {
//                    return t;
//                }
//            };
//
//            assertNull(RxJavaPlugins.onCompletableLift(null));
//
//            assertSame(cop, RxJavaPlugins.onCompletableLift(cop));

<span class="fc" id="L1490">            final Scheduler s = ImmediateThinScheduler.INSTANCE;</span>
<span class="fc" id="L1491">            Callable&lt;Scheduler&gt; c = new Callable&lt;Scheduler&gt;() {</span>
                @Override
                public Scheduler call() throws Exception {
<span class="fc" id="L1494">                    return s;</span>
                }
            };
<span class="fc" id="L1497">            assertSame(s, RxJavaPlugins.onComputationScheduler(s));</span>

<span class="fc" id="L1499">            assertSame(s, RxJavaPlugins.onIoScheduler(s));</span>

<span class="fc" id="L1501">            assertSame(s, RxJavaPlugins.onNewThreadScheduler(s));</span>

<span class="fc" id="L1503">            assertSame(s, RxJavaPlugins.onSingleScheduler(s));</span>

<span class="fc" id="L1505">            assertSame(s, RxJavaPlugins.initComputationScheduler(c));</span>

<span class="fc" id="L1507">            assertSame(s, RxJavaPlugins.initIoScheduler(c));</span>

<span class="fc" id="L1509">            assertSame(s, RxJavaPlugins.initNewThreadScheduler(c));</span>

<span class="fc" id="L1511">            assertSame(s, RxJavaPlugins.initSingleScheduler(c));</span>

        } finally {
<span class="fc" id="L1514">            RxJavaPlugins.reset();</span>
        }
<span class="fc" id="L1516">    }</span>

    static void assertTestException(List&lt;Throwable&gt; list, int index, String message) {
<span class="fc" id="L1519">        assertTrue(list.get(index).toString(), list.get(index) instanceof TestException);</span>
<span class="fc" id="L1520">        assertEquals(message, list.get(index).getMessage());</span>
<span class="fc" id="L1521">    }</span>

    static void assertUndeliverableTestException(List&lt;Throwable&gt; list, int index, String message) {
<span class="fc" id="L1524">        assertTrue(list.get(index).toString(), list.get(index).getCause() instanceof TestException);</span>
<span class="fc" id="L1525">        assertEquals(message, list.get(index).getCause().getMessage());</span>
<span class="fc" id="L1526">    }</span>

    static void assertNPE(List&lt;Throwable&gt; list, int index) {
<span class="fc" id="L1529">        assertTrue(list.get(index).toString(), list.get(index) instanceof NullPointerException);</span>
<span class="fc" id="L1530">    }</span>

    @Test
    @Ignore(&quot;Not present in 2.0&quot;)
    public void onXError() {
//        try {
//            final List&lt;Throwable&gt; list = new ArrayList&lt;Throwable&gt;();
//
//            final TestException ex = new TestException();
//
//            Function&lt;Throwable, Throwable&gt; errorHandler = new Function&lt;Throwable, Throwable&gt;() {
//                @Override
//                public Throwable a(Throwable t) {
//                    list.add(t);
//                    return ex;
//                }
//            };
//
//            RxJavaPlugins.setOnObservableSubscribeError(errorHandler);
//
//            RxJavaPlugins.setOnSingleSubscribeError(errorHandler);
//
//            RxJavaPlugins.setOnCompletableSubscribeError(errorHandler);
//
//            assertSame(ex, RxJavaPlugins.onObservableError(new TestException(&quot;Forced failure 1&quot;)));
//
//            assertSame(ex, RxJavaPlugins.onSingleError(new TestException(&quot;Forced failure 2&quot;)));
//
//            assertSame(ex, RxJavaPlugins.onCompletableError(new TestException(&quot;Forced failure 3&quot;)));
//
//            assertTestException(list, 0, &quot;Forced failure 1&quot;);
//
//            assertTestException(list, 1, &quot;Forced failure 2&quot;);
//
//            assertTestException(list, 2, &quot;Forced failure 3&quot;);
//        } finally {
//            RxJavaPlugins.reset();
//        }
<span class="nc" id="L1568">    }</span>

//    @SuppressWarnings(&quot;deprecation&quot;)
    @Test
    @Ignore(&quot;Not present in 2.0&quot;)
    public void onPluginsXError() {
//        try {
//            RxJavaPlugins.reset();
//
//            final List&lt;Throwable&gt; list = new ArrayList&lt;Throwable&gt;();
//
//            final TestException ex = new TestException();
//
//            final Function&lt;Throwable, Throwable&gt; errorHandler = new Function&lt;Throwable, Throwable&gt;() {
//                @Override
//                public Throwable apply(Throwable t) {
//                    list.add(t);
//                    return ex;
//                }
//            };
//
//            RxJavaPlugins.getInstance().registerObservableExecutionHook(new RxJavaObservableExecutionHook() {
//                @Override
//                public &lt;T&gt; Throwable onSubscribeError(Throwable e) {
//                    return errorHandler.call(e);
//                }
//            });
//
//            RxJavaPlugins.getInstance().registerSingleExecutionHook(new RxJavaSingleExecutionHook() {
//                @Override
//                public &lt;T&gt; Throwable onSubscribeError(Throwable e) {
//                    return errorHandler.call(e);
//                }
//            });
//
//            RxJavaPlugins.getInstance().registerCompletableExecutionHook(new RxJavaCompletableExecutionHook() {
//                @Override
//                public Throwable onSubscribeError(Throwable e) {
//                    return errorHandler.call(e);
//                }
//            });
//
//            assertSame(ex, RxJavaPlugins.onObservableError(new TestException(&quot;Forced failure 1&quot;)));
//
//            assertSame(ex, RxJavaPlugins.onSingleError(new TestException(&quot;Forced failure 2&quot;)));
//
//            assertSame(ex, RxJavaPlugins.onCompletableError(new TestException(&quot;Forced failure 3&quot;)));
//
//            assertTestException(list, 0, &quot;Forced failure 1&quot;);
//
//            assertTestException(list, 1, &quot;Forced failure 2&quot;);
//
//            assertTestException(list, 2, &quot;Forced failure 3&quot;);
//        } finally {
//            RxJavaPlugins.getInstance().reset();
//            RxJavaPlugins.reset();
//        }
<span class="nc" id="L1625">    }</span>

//    @SuppressWarnings({ &quot;rawtypes&quot;, &quot;unchecked&quot; })
    @Test
    @Ignore(&quot;Not present in 2.0&quot;)
    public void onXLift() {
//        try {
//            Completable.CompletableOperator cop = new Completable.CompletableOperator() {
//                @Override
//                public CompletableSubscriber call(CompletableSubscriber t) {
//                    return t;
//                }
//            };
//
//            Observable.Operator oop = new Observable.Operator() {
//                @Override
//                public Object call(Object t) {
//                    return t;
//                }
//            };
//
//            final int[] counter = { 0 };
//
//            RxJavaPlugins.setOnObservableLift(new Function&lt;Operator, Operator&gt;() {
//                @Override
//                public Operator call(Operator t) {
//                    counter[0]++;
//                    return t;
//                }
//            });
//
//            RxJavaPlugins.setOnSingleLift(new Function&lt;Operator, Operator&gt;() {
//                @Override
//                public Operator call(Operator t) {
//                    counter[0]++;
//                    return t;
//                }
//            });
//
//            RxJavaPlugins.setOnCompletableLift(new Function&lt;CompletableOperator, CompletableOperator&gt;() {
//                @Override
//                public CompletableOperator call(CompletableOperator t) {
//                    counter[0]++;
//                    return t;
//                }
//            });
//
//            assertSame(oop, RxJavaPlugins.onObservableLift(oop));
//
//            assertSame(oop, RxJavaPlugins.onSingleLift(oop));
//
//            assertSame(cop, RxJavaPlugins.onCompletableLift(cop));
//
//            assertEquals(3, counter[0]);
//
//        } finally {
//            RxJavaPlugins.reset();
//        }
<span class="nc" id="L1683">    }</span>

//    @SuppressWarnings({ &quot;rawtypes&quot;, &quot;unchecked&quot;, &quot;deprecation&quot; })
    @Test
    @Ignore(&quot;Not present in 2.0&quot;)
    public void onPluginsXLift() {
//        try {
//
//            RxJavaPlugins.getInstance().reset();
//            RxJavaPlugins.reset();
//
//            Completable.CompletableOperator cop = new Completable.CompletableOperator() {
//                @Override
//                public CompletableSubscriber call(CompletableSubscriber t) {
//                    return t;
//                }
//            };
//
//            Observable.Operator oop = new Observable.Operator() {
//                @Override
//                public Object call(Object t) {
//                    return t;
//                }
//            };
//
//            final int[] counter = { 0 };
//
//            final Function&lt;Operator, Operator&gt; onObservableLift = new Function&lt;Operator, Operator&gt;() {
//                @Override
//                public Operator call(Operator t) {
//                    counter[0]++;
//                    return t;
//                }
//            };
//
//            final Function&lt;CompletableOperator, CompletableOperator&gt; onCompletableLift = new Function&lt;CompletableOperator, CompletableOperator&gt;() {
//                @Override
//                public CompletableOperator call(CompletableOperator t) {
//                    counter[0]++;
//                    return t;
//                }
//            };
//
//            RxJavaPlugins.getInstance().registerObservableExecutionHook(new RxJavaObservableExecutionHook() {
//                @Override
//                public &lt;T, R&gt; Operator&lt;? extends R, ? super T&gt; onLift(Operator&lt;? extends R, ? super T&gt; lift) {
//                    return onObservableLift.call(lift);
//                }
//            });
//
//            RxJavaPlugins.getInstance().registerSingleExecutionHook(new RxJavaSingleExecutionHook() {
//                @Override
//                public &lt;T, R&gt; Operator&lt;? extends R, ? super T&gt; onLift(Operator&lt;? extends R, ? super T&gt; lift) {
//                    return onObservableLift.call(lift);
//                }
//            });
//
//            RxJavaPlugins.getInstance().registerCompletableExecutionHook(new RxJavaCompletableExecutionHook() {
//                @Override
//                public CompletableOperator onLift(CompletableOperator lift) {
//                    return onCompletableLift.call(lift);
//                }
//            });
//
//            assertSame(oop, RxJavaPlugins.onObservableLift(oop));
//
//            assertSame(oop, RxJavaPlugins.onSingleLift(oop));
//
//            assertSame(cop, RxJavaPlugins.onCompletableLift(cop));
//
//            assertEquals(3, counter[0]);
//
//        } finally {
//            RxJavaPlugins.reset();
//        }
<span class="nc" id="L1758">    }</span>

    @SuppressWarnings(&quot;rawtypes&quot;)
    @Test
    public void overrideConnectableObservable() {
        try {
<span class="fc" id="L1764">            RxJavaPlugins.setOnConnectableObservableAssembly(new Function&lt;ConnectableObservable, ConnectableObservable&gt;() {</span>
                @Override
                public ConnectableObservable apply(ConnectableObservable co) throws Exception {
<span class="fc" id="L1767">                    return new ConnectableObservable() {</span>

                        @Override
                        public void connect(Consumer connection) {

<span class="fc" id="L1772">                        }</span>

                        @SuppressWarnings(&quot;unchecked&quot;)
                        @Override
                        protected void subscribeActual(Observer observer) {
<span class="fc" id="L1777">                            observer.onSubscribe(Disposables.empty());</span>
<span class="fc" id="L1778">                            observer.onNext(10);</span>
<span class="fc" id="L1779">                            observer.onComplete();</span>
<span class="fc" id="L1780">                        }</span>
                    };
                }
            });

<span class="fc" id="L1785">            Observable</span>
<span class="fc" id="L1786">            .just(1)</span>
<span class="fc" id="L1787">            .publish()</span>
<span class="fc" id="L1788">            .autoConnect()</span>
<span class="fc" id="L1789">            .test()</span>
<span class="fc" id="L1790">            .assertResult(10);</span>

        } finally {
<span class="fc" id="L1793">            RxJavaPlugins.reset();</span>
        }

<span class="fc" id="L1796">        Observable</span>
<span class="fc" id="L1797">        .just(1)</span>
<span class="fc" id="L1798">        .publish()</span>
<span class="fc" id="L1799">        .autoConnect()</span>
<span class="fc" id="L1800">        .test()</span>
<span class="fc" id="L1801">        .assertResult(1);</span>
<span class="fc" id="L1802">    }</span>

    @SuppressWarnings(&quot;rawtypes&quot;)
    @Test
    public void overrideConnectableFlowable() {
        try {
<span class="fc" id="L1808">            RxJavaPlugins.setOnConnectableFlowableAssembly(new Function&lt;ConnectableFlowable, ConnectableFlowable&gt;() {</span>
                @Override
                public ConnectableFlowable apply(ConnectableFlowable co) throws Exception {
<span class="fc" id="L1811">                    return new ConnectableFlowable() {</span>

                        @Override
                        public void connect(Consumer connection) {

<span class="fc" id="L1816">                        }</span>

                        @SuppressWarnings(&quot;unchecked&quot;)
                        @Override
                        protected void subscribeActual(Subscriber subscriber) {
<span class="fc" id="L1821">                            subscriber.onSubscribe(new ScalarSubscription(subscriber, 10));</span>
<span class="fc" id="L1822">                        }</span>
                    };
                }
            });

<span class="fc" id="L1827">            Flowable</span>
<span class="fc" id="L1828">            .just(1)</span>
<span class="fc" id="L1829">            .publish()</span>
<span class="fc" id="L1830">            .autoConnect()</span>
<span class="fc" id="L1831">            .test()</span>
<span class="fc" id="L1832">            .assertResult(10);</span>

        } finally {
<span class="fc" id="L1835">            RxJavaPlugins.reset();</span>
        }

<span class="fc" id="L1838">        Flowable</span>
<span class="fc" id="L1839">        .just(1)</span>
<span class="fc" id="L1840">        .publish()</span>
<span class="fc" id="L1841">        .autoConnect()</span>
<span class="fc" id="L1842">        .test()</span>
<span class="fc" id="L1843">        .assertResult(1);</span>
<span class="fc" id="L1844">    }</span>

    @SuppressWarnings(&quot;rawtypes&quot;)
    @Test
    public void assemblyHookCrashes() {
        try {
<span class="fc" id="L1850">            RxJavaPlugins.setOnFlowableAssembly(new Function&lt;Flowable, Flowable&gt;() {</span>
                @Override
                public Flowable apply(Flowable f) throws Exception {
<span class="fc" id="L1853">                    throw new IllegalArgumentException();</span>
                }
            });

            try {
<span class="nc" id="L1858">                Flowable.empty();</span>
<span class="nc" id="L1859">                fail(&quot;Should have thrown!&quot;);</span>
<span class="fc" id="L1860">            } catch (IllegalArgumentException ex) {</span>
                // expected
<span class="nc" id="L1862">            }</span>

<span class="fc" id="L1864">            RxJavaPlugins.setOnFlowableAssembly(new Function&lt;Flowable, Flowable&gt;() {</span>
                @Override
                public Flowable apply(Flowable f) throws Exception {
<span class="fc" id="L1867">                    throw new InternalError();</span>
                }
            });

            try {
<span class="nc" id="L1872">                Flowable.empty();</span>
<span class="nc" id="L1873">                fail(&quot;Should have thrown!&quot;);</span>
<span class="fc" id="L1874">            } catch (InternalError ex) {</span>
                // expected
<span class="nc" id="L1876">            }</span>

<span class="fc" id="L1878">            RxJavaPlugins.setOnFlowableAssembly(new Function&lt;Flowable, Flowable&gt;() {</span>
                @Override
                public Flowable apply(Flowable f) throws Exception {
<span class="fc" id="L1881">                    throw new IOException();</span>
                }
            });

            try {
<span class="nc" id="L1886">                Flowable.empty();</span>
<span class="nc" id="L1887">                fail(&quot;Should have thrown!&quot;);</span>
<span class="fc" id="L1888">            } catch (RuntimeException ex) {</span>
<span class="pc bpc" id="L1889" title="1 of 2 branches missed.">                if (!(ex.getCause() instanceof IOException)) {</span>
<span class="nc" id="L1890">                    fail(ex.getCause().toString() + &quot;: Should have thrown RuntimeException(IOException)&quot;);</span>
                }
<span class="nc" id="L1892">            }</span>
        } finally {
<span class="fc" id="L1894">            RxJavaPlugins.reset();</span>
        }
<span class="fc" id="L1896">    }</span>

    @SuppressWarnings(&quot;rawtypes&quot;)
    @Test
    public void subscribeHookCrashes() {
        try {
<span class="fc" id="L1902">            RxJavaPlugins.setOnFlowableSubscribe(new BiFunction&lt;Flowable, Subscriber, Subscriber&gt;() {</span>
                @Override
                public Subscriber apply(Flowable f, Subscriber s) throws Exception {
<span class="fc" id="L1905">                    throw new IllegalArgumentException();</span>
                }
            });

            try {
<span class="nc" id="L1910">                Flowable.empty().test();</span>
<span class="nc" id="L1911">                fail(&quot;Should have thrown!&quot;);</span>
<span class="fc" id="L1912">            } catch (NullPointerException ex) {</span>
<span class="pc bpc" id="L1913" title="1 of 2 branches missed.">                if (!(ex.getCause() instanceof IllegalArgumentException)) {</span>
<span class="nc" id="L1914">                    fail(ex.getCause().toString() + &quot;: Should have thrown NullPointerException(IllegalArgumentException)&quot;);</span>
                }
<span class="nc" id="L1916">            }</span>

<span class="fc" id="L1918">            RxJavaPlugins.setOnFlowableSubscribe(new BiFunction&lt;Flowable, Subscriber, Subscriber&gt;() {</span>
                @Override
                public Subscriber apply(Flowable f, Subscriber s) throws Exception {
<span class="fc" id="L1921">                    throw new InternalError();</span>
                }
            });

            try {
<span class="nc" id="L1926">                Flowable.empty().test();</span>
<span class="nc" id="L1927">                fail(&quot;Should have thrown!&quot;);</span>
<span class="fc" id="L1928">            } catch (InternalError ex) {</span>
                // expected
<span class="nc" id="L1930">            }</span>

<span class="fc" id="L1932">            RxJavaPlugins.setOnFlowableSubscribe(new BiFunction&lt;Flowable, Subscriber, Subscriber&gt;() {</span>
                @Override
                public Subscriber apply(Flowable f, Subscriber s) throws Exception {
<span class="fc" id="L1935">                    throw new IOException();</span>
                }
            });

            try {
<span class="nc" id="L1940">                Flowable.empty().test();</span>
<span class="nc" id="L1941">                fail(&quot;Should have thrown!&quot;);</span>
<span class="fc" id="L1942">            } catch (NullPointerException ex) {</span>
<span class="pc bpc" id="L1943" title="1 of 2 branches missed.">                if (!(ex.getCause() instanceof RuntimeException)) {</span>
<span class="nc" id="L1944">                    fail(ex.getCause().toString() + &quot;: Should have thrown NullPointerException(RuntimeException(IOException))&quot;);</span>
                }
<span class="pc bpc" id="L1946" title="1 of 2 branches missed.">                if (!(ex.getCause().getCause() instanceof IOException)) {</span>
<span class="nc" id="L1947">                    fail(ex.getCause().toString() + &quot;: Should have thrown NullPointerException(RuntimeException(IOException))&quot;);</span>
                }
<span class="nc" id="L1949">            }</span>
        } finally {
<span class="fc" id="L1951">            RxJavaPlugins.reset();</span>
        }
<span class="fc" id="L1953">    }</span>

    @SuppressWarnings(&quot;rawtypes&quot;)
    @Test
    public void maybeCreate() {
        try {
<span class="fc" id="L1959">            RxJavaPlugins.setOnMaybeAssembly(new Function&lt;Maybe, Maybe&gt;() {</span>
                @Override
                public Maybe apply(Maybe t) {
<span class="fc" id="L1962">                    return new MaybeError(new TestException());</span>
                }
            });

<span class="fc" id="L1966">            Maybe.empty()</span>
<span class="fc" id="L1967">            .test()</span>
<span class="fc" id="L1968">            .assertNoValues()</span>
<span class="fc" id="L1969">            .assertNotComplete()</span>
<span class="fc" id="L1970">            .assertError(TestException.class);</span>
        } finally {
<span class="fc" id="L1972">            RxJavaPlugins.reset();</span>
        }
        // make sure the reset worked
<span class="fc" id="L1975">        Maybe.empty()</span>
<span class="fc" id="L1976">        .test()</span>
<span class="fc" id="L1977">        .assertNoValues()</span>
<span class="fc" id="L1978">        .assertNoErrors()</span>
<span class="fc" id="L1979">        .assertComplete();</span>
<span class="fc" id="L1980">    }</span>

    @Test
    @SuppressWarnings(&quot;rawtypes&quot;)
    public void maybeStart() {
        try {
<span class="fc" id="L1986">            RxJavaPlugins.setOnMaybeSubscribe(new BiFunction&lt;Maybe, MaybeObserver, MaybeObserver&gt;() {</span>
                @Override
                public MaybeObserver apply(Maybe o, final MaybeObserver t) {
<span class="fc" id="L1989">                    return new MaybeObserver() {</span>
                        @Override
                        public void onSubscribe(Disposable d) {
<span class="fc" id="L1992">                            t.onSubscribe(d);</span>
<span class="fc" id="L1993">                        }</span>

                        @SuppressWarnings(&quot;unchecked&quot;)
                        @Override
                        public void onSuccess(Object value) {
<span class="nc" id="L1998">                            t.onSuccess(value);</span>
<span class="nc" id="L1999">                        }</span>

                        @Override
                        public void onError(Throwable e) {
<span class="nc" id="L2003">                            t.onError(e);</span>
<span class="nc" id="L2004">                        }</span>

                        @Override
                        public void onComplete() {
<span class="fc" id="L2008">                            t.onError(new TestException());</span>
<span class="fc" id="L2009">                        }</span>
                    };
                }
            });

<span class="fc" id="L2014">            Maybe.empty()</span>
<span class="fc" id="L2015">            .test()</span>
<span class="fc" id="L2016">            .assertNoValues()</span>
<span class="fc" id="L2017">            .assertNotComplete()</span>
<span class="fc" id="L2018">            .assertError(TestException.class);</span>
        } finally {
<span class="fc" id="L2020">            RxJavaPlugins.reset();</span>
        }
        // make sure the reset worked

<span class="fc" id="L2024">        Maybe.empty()</span>
<span class="fc" id="L2025">        .test()</span>
<span class="fc" id="L2026">        .assertNoValues()</span>
<span class="fc" id="L2027">        .assertNoErrors()</span>
<span class="fc" id="L2028">        .assertComplete();</span>
<span class="fc" id="L2029">    }</span>

    @Test
    public void onErrorNull() {
        try {
<span class="fc" id="L2034">            final AtomicReference&lt;Throwable&gt; t = new AtomicReference&lt;Throwable&gt;();</span>

<span class="fc" id="L2036">            RxJavaPlugins.setErrorHandler(new Consumer&lt;Throwable&gt;() {</span>
                @Override
                public void accept(final Throwable throwable) throws Exception {
<span class="fc" id="L2039">                    t.set(throwable);</span>
<span class="fc" id="L2040">                }</span>
            });

<span class="fc" id="L2043">            RxJavaPlugins.onError(null);</span>

<span class="fc" id="L2045">            final Throwable throwable = t.get();</span>
<span class="fc" id="L2046">            assertEquals(&quot;onError called with null. Null values are generally not allowed in 2.x operators and sources.&quot;, throwable.getMessage());</span>
<span class="fc" id="L2047">            assertTrue(throwable instanceof NullPointerException);</span>
        } finally {
<span class="fc" id="L2049">            RxJavaPlugins.reset();</span>
        }
<span class="fc" id="L2051">    }</span>

    private static void verifyThread(Scheduler scheduler, String expectedThreadName)
            throws AssertionError {
<span class="fc" id="L2055">        assertNotNull(scheduler);</span>
<span class="fc" id="L2056">        Worker w = scheduler.createWorker();</span>
        try {
<span class="fc" id="L2058">            final AtomicReference&lt;Thread&gt; value = new AtomicReference&lt;Thread&gt;();</span>
<span class="fc" id="L2059">            final CountDownLatch cdl = new CountDownLatch(1);</span>

<span class="fc" id="L2061">            w.schedule(new Runnable() {</span>
                @Override
                public void run() {
<span class="fc" id="L2064">                    value.set(Thread.currentThread());</span>
<span class="fc" id="L2065">                    cdl.countDown();</span>
<span class="fc" id="L2066">                }</span>
            });

<span class="fc" id="L2069">            cdl.await();</span>

<span class="fc" id="L2071">            Thread t = value.get();</span>
<span class="fc" id="L2072">            assertNotNull(t);</span>
<span class="fc" id="L2073">            assertTrue(expectedThreadName.equals(t.getName()));</span>
<span class="nc" id="L2074">        } catch (Exception e) {</span>
<span class="nc" id="L2075">            fail();</span>
        } finally {
<span class="fc" id="L2077">            w.dispose();</span>
        }
<span class="fc" id="L2079">    }</span>

    @Test
    public void createComputationScheduler() {
<span class="fc" id="L2083">        final String name = &quot;ComputationSchedulerTest&quot;;</span>
<span class="fc" id="L2084">        ThreadFactory factory = new ThreadFactory() {</span>
            @Override
            public Thread newThread(Runnable r) {
<span class="fc" id="L2087">                return new Thread(r, name);</span>
            }
        };

<span class="fc" id="L2091">        final Scheduler customScheduler = RxJavaPlugins.createComputationScheduler(factory);</span>
<span class="fc" id="L2092">        RxJavaPlugins.setComputationSchedulerHandler(new Function&lt;Scheduler, Scheduler&gt;() {</span>
            @Override
            public Scheduler apply(Scheduler scheduler) throws Exception {
<span class="fc" id="L2095">                return customScheduler;</span>
            }
        });

        try {
<span class="fc" id="L2100">            verifyThread(Schedulers.computation(), name);</span>
        } finally {
<span class="fc" id="L2102">            customScheduler.shutdown();</span>
<span class="fc" id="L2103">            RxJavaPlugins.reset();</span>
        }
<span class="fc" id="L2105">    }</span>

    @Test
    public void createIoScheduler() {
<span class="fc" id="L2109">        final String name = &quot;IoSchedulerTest&quot;;</span>
<span class="fc" id="L2110">        ThreadFactory factory = new ThreadFactory() {</span>
            @Override
            public Thread newThread(Runnable r) {
<span class="fc" id="L2113">                return new Thread(r, name);</span>
            }
        };

<span class="fc" id="L2117">        final Scheduler customScheduler = RxJavaPlugins.createIoScheduler(factory);</span>
<span class="fc" id="L2118">        RxJavaPlugins.setIoSchedulerHandler(new Function&lt;Scheduler, Scheduler&gt;() {</span>
            @Override
            public Scheduler apply(Scheduler scheduler) throws Exception {
<span class="fc" id="L2121">                return customScheduler;</span>
            }
        });

        try {
<span class="fc" id="L2126">            verifyThread(Schedulers.io(), name);</span>
        } finally {
<span class="fc" id="L2128">            customScheduler.shutdown();</span>
<span class="fc" id="L2129">            RxJavaPlugins.reset();</span>
        }
<span class="fc" id="L2131">    }</span>

    @Test
    public void createNewThreadScheduler() {
<span class="fc" id="L2135">        final String name = &quot;NewThreadSchedulerTest&quot;;</span>
<span class="fc" id="L2136">        ThreadFactory factory = new ThreadFactory() {</span>
            @Override
            public Thread newThread(Runnable r) {
<span class="fc" id="L2139">                return new Thread(r, name);</span>
            }
        };

<span class="fc" id="L2143">        final Scheduler customScheduler = RxJavaPlugins.createNewThreadScheduler(factory);</span>
<span class="fc" id="L2144">        RxJavaPlugins.setNewThreadSchedulerHandler(new Function&lt;Scheduler, Scheduler&gt;() {</span>
            @Override
            public Scheduler apply(Scheduler scheduler) throws Exception {
<span class="fc" id="L2147">                return customScheduler;</span>
            }
        });

        try {
<span class="fc" id="L2152">            verifyThread(Schedulers.newThread(), name);</span>
        } finally {
<span class="fc" id="L2154">            customScheduler.shutdown();</span>
<span class="fc" id="L2155">            RxJavaPlugins.reset();</span>
        }
<span class="fc" id="L2157">    }</span>

    @Test
    public void createSingleScheduler() {
<span class="fc" id="L2161">        final String name = &quot;SingleSchedulerTest&quot;;</span>
<span class="fc" id="L2162">        ThreadFactory factory = new ThreadFactory() {</span>
            @Override
            public Thread newThread(Runnable r) {
<span class="fc" id="L2165">                return new Thread(r, name);</span>
            }
        };

<span class="fc" id="L2169">        final Scheduler customScheduler = RxJavaPlugins.createSingleScheduler(factory);</span>

<span class="fc" id="L2171">        RxJavaPlugins.setSingleSchedulerHandler(new Function&lt;Scheduler, Scheduler&gt;() {</span>
            @Override
            public Scheduler apply(Scheduler scheduler) throws Exception {
<span class="fc" id="L2174">                return customScheduler;</span>
            }
        });

        try {
<span class="fc" id="L2179">            verifyThread(Schedulers.single(), name);</span>
        } finally {
<span class="fc" id="L2181">            customScheduler.shutdown();</span>
<span class="fc" id="L2182">            RxJavaPlugins.reset();</span>
        }
<span class="fc" id="L2184">    }</span>

    @Test
    public void onBeforeBlocking() {
        try {
<span class="fc" id="L2189">            RxJavaPlugins.setOnBeforeBlocking(new BooleanSupplier() {</span>
                @Override
                public boolean getAsBoolean() throws Exception {
<span class="fc" id="L2192">                    throw new IllegalArgumentException();</span>
                }
            });

            try {
<span class="nc" id="L2197">                RxJavaPlugins.onBeforeBlocking();</span>
<span class="nc" id="L2198">                fail(&quot;Should have thrown&quot;);</span>
<span class="fc" id="L2199">            } catch (IllegalArgumentException ex) {</span>
                // expected
<span class="nc" id="L2201">            }</span>
        } finally {
<span class="fc" id="L2203">            RxJavaPlugins.reset();</span>
        }
<span class="fc" id="L2205">    }</span>

    @SuppressWarnings(&quot;rawtypes&quot;)
    @Test
    public void onParallelAssembly() {
        try {
<span class="fc" id="L2211">            RxJavaPlugins.setOnParallelAssembly(new Function&lt;ParallelFlowable, ParallelFlowable&gt;() {</span>
                @Override
                public ParallelFlowable apply(ParallelFlowable pf) throws Exception {
<span class="fc" id="L2214">                    return new ParallelFromPublisher&lt;Integer&gt;(Flowable.just(2), 2, 2);</span>
                }
            });

<span class="fc" id="L2218">            Flowable.just(1)</span>
<span class="fc" id="L2219">            .parallel()</span>
<span class="fc" id="L2220">            .sequential()</span>
<span class="fc" id="L2221">            .test()</span>
<span class="fc" id="L2222">            .assertResult(2);</span>
        } finally {
<span class="fc" id="L2224">            RxJavaPlugins.reset();</span>
        }

<span class="fc" id="L2227">        Flowable.just(1)</span>
<span class="fc" id="L2228">        .parallel()</span>
<span class="fc" id="L2229">        .sequential()</span>
<span class="fc" id="L2230">        .test()</span>
<span class="fc" id="L2231">        .assertResult(1);</span>
<span class="fc" id="L2232">    }</span>

    @Test
    public void isBug() {
<span class="fc" id="L2236">        assertFalse(RxJavaPlugins.isBug(new RuntimeException()));</span>
<span class="fc" id="L2237">        assertFalse(RxJavaPlugins.isBug(new IOException()));</span>
<span class="fc" id="L2238">        assertFalse(RxJavaPlugins.isBug(new InterruptedException()));</span>
<span class="fc" id="L2239">        assertFalse(RxJavaPlugins.isBug(new InterruptedIOException()));</span>

<span class="fc" id="L2241">        assertTrue(RxJavaPlugins.isBug(new NullPointerException()));</span>
<span class="fc" id="L2242">        assertTrue(RxJavaPlugins.isBug(new IllegalArgumentException()));</span>
<span class="fc" id="L2243">        assertTrue(RxJavaPlugins.isBug(new IllegalStateException()));</span>
<span class="fc" id="L2244">        assertTrue(RxJavaPlugins.isBug(new MissingBackpressureException()));</span>
<span class="fc" id="L2245">        assertTrue(RxJavaPlugins.isBug(new ProtocolViolationException(&quot;&quot;)));</span>
<span class="fc" id="L2246">        assertTrue(RxJavaPlugins.isBug(new UndeliverableException(new TestException())));</span>
<span class="fc" id="L2247">        assertTrue(RxJavaPlugins.isBug(new CompositeException(new TestException())));</span>
<span class="fc" id="L2248">        assertTrue(RxJavaPlugins.isBug(new OnErrorNotImplementedException(new TestException())));</span>
<span class="fc" id="L2249">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>