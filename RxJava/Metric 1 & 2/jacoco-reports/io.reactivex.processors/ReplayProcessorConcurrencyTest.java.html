<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ReplayProcessorConcurrencyTest.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">RxJava_2_x$Unnamed.exec</a> &gt; <a href="index.source.html" class="el_package">io.reactivex.processors</a> &gt; <span class="el_source">ReplayProcessorConcurrencyTest.java</span></div><h1>ReplayProcessorConcurrencyTest.java</h1><pre class="source lang-java linenums">/**
 * Copyright (c) 2016-present, RxJava Contributors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is
 * distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
 * the License for the specific language governing permissions and limitations under the License.
 */

package io.reactivex.processors;

import static org.junit.Assert.assertEquals;

import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicReference;

import org.junit.*;
import org.reactivestreams.*;

import io.reactivex.*;
import io.reactivex.functions.Consumer;
import io.reactivex.schedulers.Schedulers;
import io.reactivex.subscribers.*;

<span class="fc" id="L30">public class ReplayProcessorConcurrencyTest {</span>

    @Test(timeout = 4000)
    public void testReplaySubjectConcurrentSubscribersDoingReplayDontBlockEachOther() throws InterruptedException {
<span class="fc" id="L34">        final ReplayProcessor&lt;Long&gt; replay = ReplayProcessor.create();</span>
<span class="fc" id="L35">        Thread source = new Thread(new Runnable() {</span>

            @Override
            public void run() {
<span class="fc" id="L39">                Flowable.unsafeCreate(new Publisher&lt;Long&gt;() {</span>

                    @Override
                    public void subscribe(Subscriber&lt;? super Long&gt; subscriber) {
<span class="fc" id="L43">                        System.out.println(&quot;********* Start Source Data ***********&quot;);</span>
<span class="fc bfc" id="L44" title="All 2 branches covered.">                        for (long l = 1; l &lt;= 10000; l++) {</span>
<span class="fc" id="L45">                            subscriber.onNext(l);</span>
                        }
<span class="fc" id="L47">                        System.out.println(&quot;********* Finished Source Data ***********&quot;);</span>
<span class="fc" id="L48">                        subscriber.onComplete();</span>
<span class="fc" id="L49">                    }</span>
<span class="fc" id="L50">                }).subscribe(replay);</span>
<span class="fc" id="L51">            }</span>
        });
<span class="fc" id="L53">        source.start();</span>

<span class="fc" id="L55">        long v = replay.blockingLast();</span>
<span class="fc" id="L56">        assertEquals(10000, v);</span>

        // it's been played through once so now it will all be replays
<span class="fc" id="L59">        final CountDownLatch slowLatch = new CountDownLatch(1);</span>
<span class="fc" id="L60">        Thread slowThread = new Thread(new Runnable() {</span>

            @Override
            public void run() {
<span class="fc" id="L64">                Subscriber&lt;Long&gt; slow = new DefaultSubscriber&lt;Long&gt;() {</span>

                    @Override
                    public void onComplete() {
<span class="fc" id="L68">                        System.out.println(&quot;*** Slow Observer completed&quot;);</span>
<span class="fc" id="L69">                        slowLatch.countDown();</span>
<span class="fc" id="L70">                    }</span>

                    @Override
                    public void onError(Throwable e) {
<span class="nc" id="L74">                    }</span>

                    @Override
                    public void onNext(Long args) {
<span class="fc bfc" id="L78" title="All 2 branches covered.">                        if (args == 1) {</span>
<span class="fc" id="L79">                            System.out.println(&quot;*** Slow Observer STARTED&quot;);</span>
                        }
                        try {
<span class="fc bfc" id="L82" title="All 2 branches covered.">                            if (args % 10 == 0) {</span>
<span class="fc" id="L83">                                Thread.sleep(1);</span>
                            }
<span class="nc" id="L85">                        } catch (InterruptedException e) {</span>
<span class="nc" id="L86">                            e.printStackTrace();</span>
<span class="fc" id="L87">                        }</span>
<span class="fc" id="L88">                    }</span>
                };
<span class="fc" id="L90">                replay.subscribe(slow);</span>
                try {
<span class="fc" id="L92">                    slowLatch.await();</span>
<span class="nc" id="L93">                } catch (InterruptedException e1) {</span>
<span class="nc" id="L94">                    e1.printStackTrace();</span>
<span class="fc" id="L95">                }</span>
<span class="fc" id="L96">            }</span>
        });
<span class="fc" id="L98">        slowThread.start();</span>

<span class="fc" id="L100">        Thread fastThread = new Thread(new Runnable() {</span>

            @Override
            public void run() {
<span class="fc" id="L104">                final CountDownLatch fastLatch = new CountDownLatch(1);</span>
<span class="fc" id="L105">                Subscriber&lt;Long&gt; fast = new DefaultSubscriber&lt;Long&gt;() {</span>

                    @Override
                    public void onComplete() {
<span class="fc" id="L109">                        System.out.println(&quot;*** Fast Observer completed&quot;);</span>
<span class="fc" id="L110">                        fastLatch.countDown();</span>
<span class="fc" id="L111">                    }</span>

                    @Override
                    public void onError(Throwable e) {
<span class="nc" id="L115">                    }</span>

                    @Override
                    public void onNext(Long args) {
<span class="fc bfc" id="L119" title="All 2 branches covered.">                        if (args == 1) {</span>
<span class="fc" id="L120">                            System.out.println(&quot;*** Fast Observer STARTED&quot;);</span>
                        }
<span class="fc" id="L122">                    }</span>
                };
<span class="fc" id="L124">                replay.subscribe(fast);</span>
                try {
<span class="fc" id="L126">                    fastLatch.await();</span>
<span class="nc" id="L127">                } catch (InterruptedException e1) {</span>
<span class="nc" id="L128">                    e1.printStackTrace();</span>
<span class="fc" id="L129">                }</span>
<span class="fc" id="L130">            }</span>
        });
<span class="fc" id="L132">        fastThread.start();</span>
<span class="fc" id="L133">        fastThread.join();</span>

        // slow should not yet be completed when fast completes
<span class="fc" id="L136">        assertEquals(1, slowLatch.getCount());</span>

<span class="fc" id="L138">        slowThread.join();</span>
<span class="fc" id="L139">    }</span>

    @Test
    public void testReplaySubjectConcurrentSubscriptions() throws InterruptedException {
<span class="fc" id="L143">        final ReplayProcessor&lt;Long&gt; replay = ReplayProcessor.create();</span>
<span class="fc" id="L144">        Thread source = new Thread(new Runnable() {</span>

            @Override
            public void run() {
<span class="fc" id="L148">                Flowable.unsafeCreate(new Publisher&lt;Long&gt;() {</span>

                    @Override
                    public void subscribe(Subscriber&lt;? super Long&gt; subscriber) {
<span class="fc" id="L152">                        System.out.println(&quot;********* Start Source Data ***********&quot;);</span>
<span class="fc bfc" id="L153" title="All 2 branches covered.">                        for (long l = 1; l &lt;= 10000; l++) {</span>
<span class="fc" id="L154">                            subscriber.onNext(l);</span>
                        }
<span class="fc" id="L156">                        System.out.println(&quot;********* Finished Source Data ***********&quot;);</span>
<span class="fc" id="L157">                        subscriber.onComplete();</span>
<span class="fc" id="L158">                    }</span>
<span class="fc" id="L159">                }).subscribe(replay);</span>
<span class="fc" id="L160">            }</span>
        });

        // used to collect results of each thread
<span class="fc" id="L164">        final List&lt;List&lt;Long&gt;&gt; listOfListsOfValues = Collections.synchronizedList(new ArrayList&lt;List&lt;Long&gt;&gt;());</span>
<span class="fc" id="L165">        final List&lt;Thread&gt; threads = Collections.synchronizedList(new ArrayList&lt;Thread&gt;());</span>

<span class="fc bfc" id="L167" title="All 2 branches covered.">        for (int i = 1; i &lt;= 200; i++) {</span>
<span class="fc" id="L168">            final int count = i;</span>
<span class="fc bfc" id="L169" title="All 2 branches covered.">            if (count == 20) {</span>
                // start source data after we have some already subscribed
                // and while others are in process of subscribing
<span class="fc" id="L172">                source.start();</span>
            }
<span class="fc bfc" id="L174" title="All 2 branches covered.">            if (count == 100) {</span>
                // wait for source to finish then keep adding after it's done
<span class="fc" id="L176">                source.join();</span>
            }
<span class="fc" id="L178">            Thread t = new Thread(new Runnable() {</span>

                @Override
                public void run() {
<span class="fc" id="L182">                    List&lt;Long&gt; values = replay.toList().blockingGet();</span>
<span class="fc" id="L183">                    listOfListsOfValues.add(values);</span>
<span class="fc" id="L184">                    System.out.println(&quot;Finished thread: &quot; + count);</span>
<span class="fc" id="L185">                }</span>
            });
<span class="fc" id="L187">            t.start();</span>
<span class="fc" id="L188">            System.out.println(&quot;Started thread: &quot; + i);</span>
<span class="fc" id="L189">            threads.add(t);</span>
        }

        // wait for all threads to complete
<span class="fc bfc" id="L193" title="All 2 branches covered.">        for (Thread t : threads) {</span>
<span class="fc" id="L194">            t.join();</span>
<span class="fc" id="L195">        }</span>

        // assert all threads got the same results
<span class="fc" id="L198">        List&lt;Long&gt; sums = new ArrayList&lt;Long&gt;();</span>
<span class="fc bfc" id="L199" title="All 2 branches covered.">        for (List&lt;Long&gt; values : listOfListsOfValues) {</span>
<span class="fc" id="L200">            long v = 0;</span>
<span class="fc bfc" id="L201" title="All 2 branches covered.">            for (long l : values) {</span>
<span class="fc" id="L202">                v += l;</span>
<span class="fc" id="L203">            }</span>
<span class="fc" id="L204">            sums.add(v);</span>
<span class="fc" id="L205">        }</span>

<span class="fc" id="L207">        long expected = sums.get(0);</span>
<span class="fc" id="L208">        boolean success = true;</span>
<span class="fc bfc" id="L209" title="All 2 branches covered.">        for (long l : sums) {</span>
<span class="pc bpc" id="L210" title="1 of 2 branches missed.">            if (l != expected) {</span>
<span class="nc" id="L211">                success = false;</span>
<span class="nc" id="L212">                System.out.println(&quot;FAILURE =&gt; Expected &quot; + expected + &quot; but got: &quot; + l);</span>
            }
<span class="fc" id="L214">        }</span>

<span class="pc bpc" id="L216" title="1 of 2 branches missed.">        if (success) {</span>
<span class="fc" id="L217">            System.out.println(&quot;Success! &quot; + sums.size() + &quot; each had the same sum of &quot; + expected);</span>
        } else {
<span class="nc" id="L219">            throw new RuntimeException(&quot;Concurrency Bug&quot;);</span>
        }

<span class="fc" id="L222">    }</span>

    /**
     * Can receive timeout if subscribe never receives an onError/onComplete ... which reveals a race condition.
     */
    @Test(timeout = 10000)
    public void testSubscribeCompletionRaceCondition() {
<span class="fc bfc" id="L229" title="All 2 branches covered.">        for (int i = 0; i &lt; 50; i++) {</span>
<span class="fc" id="L230">            final ReplayProcessor&lt;String&gt; processor = ReplayProcessor.create();</span>
<span class="fc" id="L231">            final AtomicReference&lt;String&gt; value1 = new AtomicReference&lt;String&gt;();</span>

<span class="fc" id="L233">            processor.subscribe(new Consumer&lt;String&gt;() {</span>

                @Override
                public void accept(String t1) {
                    try {
                        // simulate a slow observer
<span class="fc" id="L239">                        Thread.sleep(50);</span>
<span class="nc" id="L240">                    } catch (InterruptedException e) {</span>
<span class="nc" id="L241">                        e.printStackTrace();</span>
<span class="fc" id="L242">                    }</span>
<span class="fc" id="L243">                    value1.set(t1);</span>
<span class="fc" id="L244">                }</span>

            });

<span class="fc" id="L248">            Thread t1 = new Thread(new Runnable() {</span>

                @Override
                public void run() {
<span class="fc" id="L252">                    processor.onNext(&quot;value&quot;);</span>
<span class="fc" id="L253">                    processor.onComplete();</span>
<span class="fc" id="L254">                }</span>
            });

<span class="fc" id="L257">            SubjectObserverThread t2 = new SubjectObserverThread(processor);</span>
<span class="fc" id="L258">            SubjectObserverThread t3 = new SubjectObserverThread(processor);</span>
<span class="fc" id="L259">            SubjectObserverThread t4 = new SubjectObserverThread(processor);</span>
<span class="fc" id="L260">            SubjectObserverThread t5 = new SubjectObserverThread(processor);</span>

<span class="fc" id="L262">            t2.start();</span>
<span class="fc" id="L263">            t3.start();</span>
<span class="fc" id="L264">            t1.start();</span>
<span class="fc" id="L265">            t4.start();</span>
<span class="fc" id="L266">            t5.start();</span>
            try {
<span class="fc" id="L268">                t1.join();</span>
<span class="fc" id="L269">                t2.join();</span>
<span class="fc" id="L270">                t3.join();</span>
<span class="fc" id="L271">                t4.join();</span>
<span class="fc" id="L272">                t5.join();</span>
<span class="nc" id="L273">            } catch (InterruptedException e) {</span>
<span class="nc" id="L274">                throw new RuntimeException(e);</span>
<span class="fc" id="L275">            }</span>

<span class="fc" id="L277">            assertEquals(&quot;value&quot;, value1.get());</span>
<span class="fc" id="L278">            assertEquals(&quot;value&quot;, t2.value.get());</span>
<span class="fc" id="L279">            assertEquals(&quot;value&quot;, t3.value.get());</span>
<span class="fc" id="L280">            assertEquals(&quot;value&quot;, t4.value.get());</span>
<span class="fc" id="L281">            assertEquals(&quot;value&quot;, t5.value.get());</span>
        }

<span class="fc" id="L284">    }</span>

    /**
     * Make sure emission-subscription races are handled correctly.
     * https://github.com/ReactiveX/RxJava/issues/1147
     */
    @Test
    public void testRaceForTerminalState() {
<span class="fc" id="L292">        final List&lt;Integer&gt; expected = Arrays.asList(1);</span>
<span class="fc bfc" id="L293" title="All 2 branches covered.">        for (int i = 0; i &lt; 100000; i++) {</span>
<span class="fc" id="L294">            TestSubscriber&lt;Integer&gt; ts = new TestSubscriber&lt;Integer&gt;();</span>
<span class="fc" id="L295">            Flowable.just(1).subscribeOn(Schedulers.computation()).cache().subscribe(ts);</span>
<span class="fc" id="L296">            ts.awaitTerminalEvent();</span>
<span class="fc" id="L297">            ts.assertValueSequence(expected);</span>
<span class="fc" id="L298">            ts.assertTerminated();</span>
        }
<span class="fc" id="L300">    }</span>

    static class SubjectObserverThread extends Thread {

        private final ReplayProcessor&lt;String&gt; processor;
<span class="fc" id="L305">        private final AtomicReference&lt;String&gt; value = new AtomicReference&lt;String&gt;();</span>

<span class="fc" id="L307">        SubjectObserverThread(ReplayProcessor&lt;String&gt; processor) {</span>
<span class="fc" id="L308">            this.processor = processor;</span>
<span class="fc" id="L309">        }</span>

        @Override
        public void run() {
            try {
                // a timeout exception will happen if we don't get a terminal state
<span class="fc" id="L315">                String v = processor.timeout(2000, TimeUnit.MILLISECONDS).blockingSingle();</span>
<span class="fc" id="L316">                value.set(v);</span>
<span class="nc" id="L317">            } catch (Exception e) {</span>
<span class="nc" id="L318">                e.printStackTrace();</span>
<span class="fc" id="L319">            }</span>
<span class="fc" id="L320">        }</span>
    }

    @Test
    public void testReplaySubjectEmissionSubscriptionRace() throws Exception {
<span class="fc" id="L325">        Scheduler s = Schedulers.io();</span>
<span class="fc" id="L326">        Scheduler.Worker worker = Schedulers.io().createWorker();</span>
        try {
<span class="fc bfc" id="L328" title="All 2 branches covered.">            for (int i = 0; i &lt; 50000; i++) {</span>
<span class="fc bfc" id="L329" title="All 2 branches covered.">                if (i % 1000 == 0) {</span>
<span class="fc" id="L330">                    System.out.println(i);</span>
                }
<span class="fc" id="L332">                final ReplayProcessor&lt;Object&gt; rs = ReplayProcessor.create();</span>

<span class="fc" id="L334">                final CountDownLatch finish = new CountDownLatch(1);</span>
<span class="fc" id="L335">                final CountDownLatch start = new CountDownLatch(1);</span>

<span class="fc" id="L337">                worker.schedule(new Runnable() {</span>
                    @Override
                    public void run() {
                        try {
<span class="fc" id="L341">                            start.await();</span>
<span class="nc" id="L342">                        } catch (Exception e1) {</span>
<span class="nc" id="L343">                            e1.printStackTrace();</span>
<span class="fc" id="L344">                        }</span>
<span class="fc" id="L345">                        rs.onNext(1);</span>
<span class="fc" id="L346">                    }</span>
                });

<span class="fc" id="L349">                final AtomicReference&lt;Object&gt; o = new AtomicReference&lt;Object&gt;();</span>

<span class="fc" id="L351">                rs.subscribeOn(s).observeOn(Schedulers.io())</span>
<span class="fc" id="L352">                .subscribe(new DefaultSubscriber&lt;Object&gt;() {</span>

                    @Override
                    public void onComplete() {
<span class="fc" id="L356">                        o.set(-1);</span>
<span class="fc" id="L357">                        finish.countDown();</span>
<span class="fc" id="L358">                    }</span>

                    @Override
                    public void onError(Throwable e) {
<span class="nc" id="L362">                        o.set(e);</span>
<span class="nc" id="L363">                        finish.countDown();</span>
<span class="nc" id="L364">                    }</span>

                    @Override
                    public void onNext(Object t) {
<span class="fc" id="L368">                        o.set(t);</span>
<span class="fc" id="L369">                        finish.countDown();</span>
<span class="fc" id="L370">                    }</span>

                });
<span class="fc" id="L373">                start.countDown();</span>

<span class="pc bpc" id="L375" title="1 of 2 branches missed.">                if (!finish.await(5, TimeUnit.SECONDS)) {</span>
<span class="nc" id="L376">                    System.out.println(o.get());</span>
<span class="nc" id="L377">                    System.out.println(rs.hasSubscribers());</span>
<span class="nc" id="L378">                    rs.onComplete();</span>
<span class="nc" id="L379">                    Assert.fail(&quot;Timeout @ &quot; + i);</span>
<span class="nc" id="L380">                    break;</span>
                } else {
<span class="fc" id="L382">                    Assert.assertEquals(1, o.get());</span>
<span class="fc" id="L383">                    worker.schedule(new Runnable() {</span>
                        @Override
                        public void run() {
<span class="fc" id="L386">                            rs.onComplete();</span>
<span class="fc" id="L387">                        }</span>
                    });

                }
            }
        } finally {
<span class="fc" id="L393">            worker.dispose();</span>
        }
<span class="fc" id="L395">    }</span>

    @Test(timeout = 10000)
    public void testConcurrentSizeAndHasAnyValue() throws InterruptedException {
<span class="fc" id="L399">        final ReplayProcessor&lt;Object&gt; rs = ReplayProcessor.create();</span>
<span class="fc" id="L400">        final CyclicBarrier cb = new CyclicBarrier(2);</span>

<span class="fc" id="L402">        Thread t = new Thread(new Runnable() {</span>
            @Override
            public void run() {
                try {
<span class="fc" id="L406">                    cb.await();</span>
<span class="nc" id="L407">                } catch (InterruptedException e) {</span>
<span class="nc" id="L408">                    return;</span>
<span class="nc" id="L409">                } catch (BrokenBarrierException e) {</span>
<span class="nc" id="L410">                    return;</span>
<span class="fc" id="L411">                }</span>
<span class="fc bfc" id="L412" title="All 2 branches covered.">                for (int i = 0; i &lt; 1000000; i++) {</span>
<span class="fc" id="L413">                    rs.onNext(i);</span>
                }
<span class="fc" id="L415">                rs.onComplete();</span>
<span class="fc" id="L416">                System.out.println(&quot;Replay fill Thread finished!&quot;);</span>
<span class="fc" id="L417">            }</span>
        });
<span class="fc" id="L419">        t.start();</span>
        try {
<span class="fc" id="L421">            cb.await();</span>
<span class="nc" id="L422">        } catch (InterruptedException e) {</span>
<span class="nc" id="L423">            return;</span>
<span class="nc" id="L424">        } catch (BrokenBarrierException e) {</span>
<span class="nc" id="L425">            return;</span>
<span class="fc" id="L426">        }</span>
<span class="fc" id="L427">        int lastSize = 0;</span>
<span class="pc bpc" id="L428" title="1 of 4 branches missed.">        for (; !rs.hasThrowable() &amp;&amp; !rs.hasComplete();) {</span>
<span class="fc" id="L429">            int size = rs.size();</span>
<span class="fc" id="L430">            boolean hasAny = rs.hasValue();</span>
<span class="fc" id="L431">            Object[] values = rs.getValues();</span>
<span class="pc bpc" id="L432" title="1 of 2 branches missed.">            if (size &lt; lastSize) {</span>
<span class="nc" id="L433">                Assert.fail(&quot;Size decreased! &quot; + lastSize + &quot; -&gt; &quot; + size);</span>
            }
<span class="pc bpc" id="L435" title="2 of 4 branches missed.">            if ((size &gt; 0) &amp;&amp; !hasAny) {</span>
<span class="nc" id="L436">                Assert.fail(&quot;hasAnyValue reports emptyness but size doesn't&quot;);</span>
            }
<span class="pc bpc" id="L438" title="1 of 2 branches missed.">            if (size &gt; values.length) {</span>
<span class="nc" id="L439">                Assert.fail(&quot;Got fewer values than size! &quot; + size + &quot; -&gt; &quot; + values.length);</span>
            }
<span class="fc" id="L441">            lastSize = size;</span>
<span class="fc" id="L442">        }</span>

<span class="fc" id="L444">        t.join();</span>
<span class="fc" id="L445">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>