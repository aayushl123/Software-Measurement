<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ReplayProcessorTest.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">RxJava_2_x$Unnamed.exec</a> &gt; <a href="index.source.html" class="el_package">io.reactivex.processors</a> &gt; <span class="el_source">ReplayProcessorTest.java</span></div><h1>ReplayProcessorTest.java</h1><pre class="source lang-java linenums">/**
 * Copyright (c) 2016-present, RxJava Contributors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is
 * distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
 * the License for the specific language governing permissions and limitations under the License.
 */

package io.reactivex.processors;

import static org.junit.Assert.*;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;

import java.lang.management.*;
import java.util.Arrays;
import java.util.concurrent.*;
import java.util.concurrent.atomic.*;

import org.junit.*;
import org.mockito.*;
import org.reactivestreams.*;

import io.reactivex.*;
import io.reactivex.disposables.Disposable;
import io.reactivex.exceptions.TestException;
import io.reactivex.functions.*;
import io.reactivex.internal.subscriptions.BooleanSubscription;
import io.reactivex.processors.ReplayProcessor.*;
import io.reactivex.schedulers.*;
import io.reactivex.subscribers.*;

<span class="fc" id="L38">public class ReplayProcessorTest extends FlowableProcessorTest&lt;Object&gt; {</span>

<span class="fc" id="L40">    private final Throwable testException = new Throwable();</span>

    @Override
    protected FlowableProcessor&lt;Object&gt; create() {
<span class="fc" id="L44">        return ReplayProcessor.create();</span>
    }

    @Test
    public void testCompleted() {
<span class="fc" id="L49">        ReplayProcessor&lt;String&gt; processor = ReplayProcessor.create();</span>

<span class="fc" id="L51">        Subscriber&lt;String&gt; subscriber1 = TestHelper.mockSubscriber();</span>
<span class="fc" id="L52">        processor.subscribe(subscriber1);</span>

<span class="fc" id="L54">        processor.onNext(&quot;one&quot;);</span>
<span class="fc" id="L55">        processor.onNext(&quot;two&quot;);</span>
<span class="fc" id="L56">        processor.onNext(&quot;three&quot;);</span>
<span class="fc" id="L57">        processor.onComplete();</span>

<span class="fc" id="L59">        processor.onNext(&quot;four&quot;);</span>
<span class="fc" id="L60">        processor.onComplete();</span>
<span class="fc" id="L61">        processor.onError(new Throwable());</span>

<span class="fc" id="L63">        assertCompletedSubscriber(subscriber1);</span>

        // assert that subscribing a 2nd time gets the same data
<span class="fc" id="L66">        Subscriber&lt;String&gt; subscriber2 = TestHelper.mockSubscriber();</span>
<span class="fc" id="L67">        processor.subscribe(subscriber2);</span>
<span class="fc" id="L68">        assertCompletedSubscriber(subscriber2);</span>
<span class="fc" id="L69">    }</span>

    @Test
    public void testCompletedStopsEmittingData() {
<span class="fc" id="L73">        ReplayProcessor&lt;Integer&gt; channel = ReplayProcessor.create();</span>
<span class="fc" id="L74">        Subscriber&lt;Object&gt; observerA = TestHelper.mockSubscriber();</span>
<span class="fc" id="L75">        Subscriber&lt;Object&gt; observerB = TestHelper.mockSubscriber();</span>
<span class="fc" id="L76">        Subscriber&lt;Object&gt; observerC = TestHelper.mockSubscriber();</span>
<span class="fc" id="L77">        Subscriber&lt;Object&gt; observerD = TestHelper.mockSubscriber();</span>
<span class="fc" id="L78">        TestSubscriber&lt;Object&gt; ts = new TestSubscriber&lt;Object&gt;(observerA);</span>

<span class="fc" id="L80">        channel.subscribe(ts);</span>
<span class="fc" id="L81">        channel.subscribe(observerB);</span>

<span class="fc" id="L83">        InOrder inOrderA = inOrder(observerA);</span>
<span class="fc" id="L84">        InOrder inOrderB = inOrder(observerB);</span>
<span class="fc" id="L85">        InOrder inOrderC = inOrder(observerC);</span>
<span class="fc" id="L86">        InOrder inOrderD = inOrder(observerD);</span>

<span class="fc" id="L88">        channel.onNext(42);</span>

        // both A and B should have received 42 from before subscription
<span class="fc" id="L91">        inOrderA.verify(observerA).onNext(42);</span>
<span class="fc" id="L92">        inOrderB.verify(observerB).onNext(42);</span>

<span class="fc" id="L94">        ts.dispose();</span>

        // a should receive no more
<span class="fc" id="L97">        inOrderA.verifyNoMoreInteractions();</span>

<span class="fc" id="L99">        channel.onNext(4711);</span>

        // only be should receive 4711 at this point
<span class="fc" id="L102">        inOrderB.verify(observerB).onNext(4711);</span>

<span class="fc" id="L104">        channel.onComplete();</span>

        // B is subscribed so should receive onComplete
<span class="fc" id="L107">        inOrderB.verify(observerB).onComplete();</span>

<span class="fc" id="L109">        channel.subscribe(observerC);</span>

        // when C subscribes it should receive 42, 4711, onComplete
<span class="fc" id="L112">        inOrderC.verify(observerC).onNext(42);</span>
<span class="fc" id="L113">        inOrderC.verify(observerC).onNext(4711);</span>
<span class="fc" id="L114">        inOrderC.verify(observerC).onComplete();</span>

        // if further events are propagated they should be ignored
<span class="fc" id="L117">        channel.onNext(13);</span>
<span class="fc" id="L118">        channel.onNext(14);</span>
<span class="fc" id="L119">        channel.onNext(15);</span>
<span class="fc" id="L120">        channel.onError(new RuntimeException());</span>

        // a new subscription should only receive what was emitted prior to terminal state onComplete
<span class="fc" id="L123">        channel.subscribe(observerD);</span>

<span class="fc" id="L125">        inOrderD.verify(observerD).onNext(42);</span>
<span class="fc" id="L126">        inOrderD.verify(observerD).onNext(4711);</span>
<span class="fc" id="L127">        inOrderD.verify(observerD).onComplete();</span>

<span class="fc" id="L129">        verify(observerA).onSubscribe((Subscription)notNull());</span>
<span class="fc" id="L130">        verify(observerB).onSubscribe((Subscription)notNull());</span>
<span class="fc" id="L131">        verify(observerC).onSubscribe((Subscription)notNull());</span>
<span class="fc" id="L132">        verify(observerD).onSubscribe((Subscription)notNull());</span>
<span class="fc" id="L133">        Mockito.verifyNoMoreInteractions(observerA);</span>
<span class="fc" id="L134">        Mockito.verifyNoMoreInteractions(observerB);</span>
<span class="fc" id="L135">        Mockito.verifyNoMoreInteractions(observerC);</span>
<span class="fc" id="L136">        Mockito.verifyNoMoreInteractions(observerD);</span>

<span class="fc" id="L138">    }</span>

    @Test
    public void testCompletedAfterError() {
<span class="fc" id="L142">        ReplayProcessor&lt;String&gt; processor = ReplayProcessor.create();</span>

<span class="fc" id="L144">        Subscriber&lt;String&gt; subscriber = TestHelper.mockSubscriber();</span>

<span class="fc" id="L146">        processor.onNext(&quot;one&quot;);</span>
<span class="fc" id="L147">        processor.onError(testException);</span>
<span class="fc" id="L148">        processor.onNext(&quot;two&quot;);</span>
<span class="fc" id="L149">        processor.onComplete();</span>
<span class="fc" id="L150">        processor.onError(new RuntimeException());</span>

<span class="fc" id="L152">        processor.subscribe(subscriber);</span>
<span class="fc" id="L153">        verify(subscriber).onSubscribe((Subscription)notNull());</span>
<span class="fc" id="L154">        verify(subscriber, times(1)).onNext(&quot;one&quot;);</span>
<span class="fc" id="L155">        verify(subscriber, times(1)).onError(testException);</span>
<span class="fc" id="L156">        verifyNoMoreInteractions(subscriber);</span>
<span class="fc" id="L157">    }</span>

    private void assertCompletedSubscriber(Subscriber&lt;String&gt; subscriber) {
<span class="fc" id="L160">        InOrder inOrder = inOrder(subscriber);</span>

<span class="fc" id="L162">        inOrder.verify(subscriber, times(1)).onNext(&quot;one&quot;);</span>
<span class="fc" id="L163">        inOrder.verify(subscriber, times(1)).onNext(&quot;two&quot;);</span>
<span class="fc" id="L164">        inOrder.verify(subscriber, times(1)).onNext(&quot;three&quot;);</span>
<span class="fc" id="L165">        inOrder.verify(subscriber, Mockito.never()).onError(any(Throwable.class));</span>
<span class="fc" id="L166">        inOrder.verify(subscriber, times(1)).onComplete();</span>
<span class="fc" id="L167">        inOrder.verifyNoMoreInteractions();</span>
<span class="fc" id="L168">    }</span>

    @Test
    public void testError() {
<span class="fc" id="L172">        ReplayProcessor&lt;String&gt; processor = ReplayProcessor.create();</span>

<span class="fc" id="L174">        Subscriber&lt;String&gt; subscriber = TestHelper.mockSubscriber();</span>
<span class="fc" id="L175">        processor.subscribe(subscriber);</span>

<span class="fc" id="L177">        processor.onNext(&quot;one&quot;);</span>
<span class="fc" id="L178">        processor.onNext(&quot;two&quot;);</span>
<span class="fc" id="L179">        processor.onNext(&quot;three&quot;);</span>
<span class="fc" id="L180">        processor.onError(testException);</span>

<span class="fc" id="L182">        processor.onNext(&quot;four&quot;);</span>
<span class="fc" id="L183">        processor.onError(new Throwable());</span>
<span class="fc" id="L184">        processor.onComplete();</span>

<span class="fc" id="L186">        assertErrorSubscriber(subscriber);</span>

<span class="fc" id="L188">        subscriber = TestHelper.mockSubscriber();</span>
<span class="fc" id="L189">        processor.subscribe(subscriber);</span>
<span class="fc" id="L190">        assertErrorSubscriber(subscriber);</span>
<span class="fc" id="L191">    }</span>

    private void assertErrorSubscriber(Subscriber&lt;String&gt; subscriber) {
<span class="fc" id="L194">        verify(subscriber, times(1)).onNext(&quot;one&quot;);</span>
<span class="fc" id="L195">        verify(subscriber, times(1)).onNext(&quot;two&quot;);</span>
<span class="fc" id="L196">        verify(subscriber, times(1)).onNext(&quot;three&quot;);</span>
<span class="fc" id="L197">        verify(subscriber, times(1)).onError(testException);</span>
<span class="fc" id="L198">        verify(subscriber, Mockito.never()).onComplete();</span>
<span class="fc" id="L199">    }</span>

    @Test
    public void testSubscribeMidSequence() {
<span class="fc" id="L203">        ReplayProcessor&lt;String&gt; processor = ReplayProcessor.create();</span>

<span class="fc" id="L205">        Subscriber&lt;String&gt; subscriber = TestHelper.mockSubscriber();</span>
<span class="fc" id="L206">        processor.subscribe(subscriber);</span>

<span class="fc" id="L208">        processor.onNext(&quot;one&quot;);</span>
<span class="fc" id="L209">        processor.onNext(&quot;two&quot;);</span>

<span class="fc" id="L211">        assertObservedUntilTwo(subscriber);</span>

<span class="fc" id="L213">        Subscriber&lt;String&gt; anotherSubscriber = TestHelper.mockSubscriber();</span>
<span class="fc" id="L214">        processor.subscribe(anotherSubscriber);</span>
<span class="fc" id="L215">        assertObservedUntilTwo(anotherSubscriber);</span>

<span class="fc" id="L217">        processor.onNext(&quot;three&quot;);</span>
<span class="fc" id="L218">        processor.onComplete();</span>

<span class="fc" id="L220">        assertCompletedSubscriber(subscriber);</span>
<span class="fc" id="L221">        assertCompletedSubscriber(anotherSubscriber);</span>
<span class="fc" id="L222">    }</span>

    @Test
    public void testUnsubscribeFirstSubscriber() {
<span class="fc" id="L226">        ReplayProcessor&lt;String&gt; processor = ReplayProcessor.create();</span>

<span class="fc" id="L228">        Subscriber&lt;String&gt; subscriber = TestHelper.mockSubscriber();</span>
<span class="fc" id="L229">        TestSubscriber&lt;String&gt; ts = new TestSubscriber&lt;String&gt;(subscriber);</span>
<span class="fc" id="L230">        processor.subscribe(ts);</span>

<span class="fc" id="L232">        processor.onNext(&quot;one&quot;);</span>
<span class="fc" id="L233">        processor.onNext(&quot;two&quot;);</span>

<span class="fc" id="L235">        ts.dispose();</span>
<span class="fc" id="L236">        assertObservedUntilTwo(subscriber);</span>

<span class="fc" id="L238">        Subscriber&lt;String&gt; anotherSubscriber = TestHelper.mockSubscriber();</span>
<span class="fc" id="L239">        processor.subscribe(anotherSubscriber);</span>
<span class="fc" id="L240">        assertObservedUntilTwo(anotherSubscriber);</span>

<span class="fc" id="L242">        processor.onNext(&quot;three&quot;);</span>
<span class="fc" id="L243">        processor.onComplete();</span>

<span class="fc" id="L245">        assertObservedUntilTwo(subscriber);</span>
<span class="fc" id="L246">        assertCompletedSubscriber(anotherSubscriber);</span>
<span class="fc" id="L247">    }</span>

    private void assertObservedUntilTwo(Subscriber&lt;String&gt; subscriber) {
<span class="fc" id="L250">        verify(subscriber, times(1)).onNext(&quot;one&quot;);</span>
<span class="fc" id="L251">        verify(subscriber, times(1)).onNext(&quot;two&quot;);</span>
<span class="fc" id="L252">        verify(subscriber, Mockito.never()).onNext(&quot;three&quot;);</span>
<span class="fc" id="L253">        verify(subscriber, Mockito.never()).onError(any(Throwable.class));</span>
<span class="fc" id="L254">        verify(subscriber, Mockito.never()).onComplete();</span>
<span class="fc" id="L255">    }</span>

    @Test(timeout = 2000)
    public void testNewSubscriberDoesntBlockExisting() throws InterruptedException {

<span class="fc" id="L260">        final AtomicReference&lt;String&gt; lastValueForSubscriber1 = new AtomicReference&lt;String&gt;();</span>
<span class="fc" id="L261">        Subscriber&lt;String&gt; subscriber1 = new DefaultSubscriber&lt;String&gt;() {</span>

            @Override
            public void onComplete() {

<span class="fc" id="L266">            }</span>

            @Override
            public void onError(Throwable e) {

<span class="nc" id="L271">            }</span>

            @Override
            public void onNext(String v) {
<span class="fc" id="L275">                System.out.println(&quot;observer1: &quot; + v);</span>
<span class="fc" id="L276">                lastValueForSubscriber1.set(v);</span>
<span class="fc" id="L277">            }</span>

        };

<span class="fc" id="L281">        final AtomicReference&lt;String&gt; lastValueForSubscriber2 = new AtomicReference&lt;String&gt;();</span>
<span class="fc" id="L282">        final CountDownLatch oneReceived = new CountDownLatch(1);</span>
<span class="fc" id="L283">        final CountDownLatch makeSlow = new CountDownLatch(1);</span>
<span class="fc" id="L284">        final CountDownLatch completed = new CountDownLatch(1);</span>
<span class="fc" id="L285">        Subscriber&lt;String&gt; subscriber2 = new DefaultSubscriber&lt;String&gt;() {</span>

            @Override
            public void onComplete() {
<span class="fc" id="L289">                completed.countDown();</span>
<span class="fc" id="L290">            }</span>

            @Override
            public void onError(Throwable e) {

<span class="nc" id="L295">            }</span>

            @Override
            public void onNext(String v) {
<span class="fc" id="L299">                System.out.println(&quot;observer2: &quot; + v);</span>
<span class="fc bfc" id="L300" title="All 2 branches covered.">                if (v.equals(&quot;one&quot;)) {</span>
<span class="fc" id="L301">                    oneReceived.countDown();</span>
                } else {
                    try {
<span class="fc" id="L304">                        makeSlow.await();</span>
<span class="nc" id="L305">                    } catch (InterruptedException e) {</span>
<span class="nc" id="L306">                        e.printStackTrace();</span>
<span class="fc" id="L307">                    }</span>
<span class="fc" id="L308">                    lastValueForSubscriber2.set(v);</span>
                }
<span class="fc" id="L310">            }</span>

        };

<span class="fc" id="L314">        ReplayProcessor&lt;String&gt; processor = ReplayProcessor.create();</span>
<span class="fc" id="L315">        processor.subscribe(subscriber1);</span>
<span class="fc" id="L316">        processor.onNext(&quot;one&quot;);</span>
<span class="fc" id="L317">        assertEquals(&quot;one&quot;, lastValueForSubscriber1.get());</span>
<span class="fc" id="L318">        processor.onNext(&quot;two&quot;);</span>
<span class="fc" id="L319">        assertEquals(&quot;two&quot;, lastValueForSubscriber1.get());</span>

        // use subscribeOn to make this async otherwise we deadlock as we are using CountDownLatches
<span class="fc" id="L322">        processor.subscribeOn(Schedulers.newThread()).subscribe(subscriber2);</span>

<span class="fc" id="L324">        System.out.println(&quot;before waiting for one&quot;);</span>

        // wait until observer2 starts having replay occur
<span class="fc" id="L327">        oneReceived.await();</span>

<span class="fc" id="L329">        System.out.println(&quot;after waiting for one&quot;);</span>

<span class="fc" id="L331">        processor.onNext(&quot;three&quot;);</span>

<span class="fc" id="L333">        System.out.println(&quot;sent three&quot;);</span>

        // if subscription blocked existing subscribers then 'makeSlow' would cause this to not be there yet
<span class="fc" id="L336">        assertEquals(&quot;three&quot;, lastValueForSubscriber1.get());</span>

<span class="fc" id="L338">        System.out.println(&quot;about to send onComplete&quot;);</span>

<span class="fc" id="L340">        processor.onComplete();</span>

<span class="fc" id="L342">        System.out.println(&quot;completed processor&quot;);</span>

        // release
<span class="fc" id="L345">        makeSlow.countDown();</span>

<span class="fc" id="L347">        System.out.println(&quot;makeSlow released&quot;);</span>

<span class="fc" id="L349">        completed.await();</span>
        // all of them should be emitted with the last being &quot;three&quot;
<span class="fc" id="L351">        assertEquals(&quot;three&quot;, lastValueForSubscriber2.get());</span>

<span class="fc" id="L353">    }</span>

    @Test
    public void testSubscriptionLeak() {
<span class="fc" id="L357">        ReplayProcessor&lt;Object&gt; replaySubject = ReplayProcessor.create();</span>

<span class="fc" id="L359">        Disposable connection = replaySubject.subscribe();</span>

<span class="fc" id="L361">        assertEquals(1, replaySubject.subscriberCount());</span>

<span class="fc" id="L363">        connection.dispose();</span>

<span class="fc" id="L365">        assertEquals(0, replaySubject.subscriberCount());</span>
<span class="fc" id="L366">    }</span>

    @Test(timeout = 1000)
    public void testUnsubscriptionCase() {
<span class="fc" id="L370">        ReplayProcessor&lt;String&gt; src = ReplayProcessor.create();</span>

<span class="fc bfc" id="L372" title="All 2 branches covered.">        for (int i = 0; i &lt; 10; i++) {</span>
<span class="fc" id="L373">            final Subscriber&lt;Object&gt; subscriber = TestHelper.mockSubscriber();</span>
<span class="fc" id="L374">            InOrder inOrder = inOrder(subscriber);</span>
<span class="fc" id="L375">            String v = &quot;&quot; + i;</span>
<span class="fc" id="L376">            src.onNext(v);</span>
<span class="fc" id="L377">            System.out.printf(&quot;Turn: %d%n&quot;, i);</span>
<span class="fc" id="L378">            src.firstElement().toFlowable()</span>
<span class="fc" id="L379">                .flatMap(new Function&lt;String, Flowable&lt;String&gt;&gt;() {</span>

                    @Override
                    public Flowable&lt;String&gt; apply(String t1) {
<span class="fc" id="L383">                        return Flowable.just(t1 + &quot;, &quot; + t1);</span>
                    }
                })
<span class="fc" id="L386">                .subscribe(new DefaultSubscriber&lt;String&gt;() {</span>
                    @Override
                    public void onNext(String t) {
<span class="fc" id="L389">                        System.out.println(t);</span>
<span class="fc" id="L390">                        subscriber.onNext(t);</span>
<span class="fc" id="L391">                    }</span>

                    @Override
                    public void onError(Throwable e) {
<span class="nc" id="L395">                        subscriber.onError(e);</span>
<span class="nc" id="L396">                    }</span>

                    @Override
                    public void onComplete() {
<span class="fc" id="L400">                        subscriber.onComplete();</span>
<span class="fc" id="L401">                    }</span>
                });
<span class="fc" id="L403">            inOrder.verify(subscriber).onNext(&quot;0, 0&quot;);</span>
<span class="fc" id="L404">            inOrder.verify(subscriber).onComplete();</span>
<span class="fc" id="L405">            verify(subscriber, never()).onError(any(Throwable.class));</span>
        }
<span class="fc" id="L407">    }</span>

    @Test
    public void testTerminateOnce() {
<span class="fc" id="L411">        ReplayProcessor&lt;Integer&gt; source = ReplayProcessor.create();</span>
<span class="fc" id="L412">        source.onNext(1);</span>
<span class="fc" id="L413">        source.onNext(2);</span>
<span class="fc" id="L414">        source.onComplete();</span>

<span class="fc" id="L416">        final Subscriber&lt;Integer&gt; subscriber = TestHelper.mockSubscriber();</span>

<span class="fc" id="L418">        source.subscribe(new DefaultSubscriber&lt;Integer&gt;() {</span>

            @Override
            public void onNext(Integer t) {
<span class="fc" id="L422">                subscriber.onNext(t);</span>
<span class="fc" id="L423">            }</span>

            @Override
            public void onError(Throwable e) {
<span class="nc" id="L427">                subscriber.onError(e);</span>
<span class="nc" id="L428">            }</span>

            @Override
            public void onComplete() {
<span class="fc" id="L432">                subscriber.onComplete();</span>
<span class="fc" id="L433">            }</span>
        });

<span class="fc" id="L436">        verify(subscriber).onNext(1);</span>
<span class="fc" id="L437">        verify(subscriber).onNext(2);</span>
<span class="fc" id="L438">        verify(subscriber).onComplete();</span>
<span class="fc" id="L439">        verify(subscriber, never()).onError(any(Throwable.class));</span>
<span class="fc" id="L440">    }</span>

    @Test
    public void testReplay1AfterTermination() {
<span class="fc" id="L444">        ReplayProcessor&lt;Integer&gt; source = ReplayProcessor.createWithSize(1);</span>

<span class="fc" id="L446">        source.onNext(1);</span>
<span class="fc" id="L447">        source.onNext(2);</span>
<span class="fc" id="L448">        source.onComplete();</span>

<span class="fc bfc" id="L450" title="All 2 branches covered.">        for (int i = 0; i &lt; 1; i++) {</span>
<span class="fc" id="L451">            Subscriber&lt;Integer&gt; subscriber = TestHelper.mockSubscriber();</span>

<span class="fc" id="L453">            source.subscribe(subscriber);</span>

<span class="fc" id="L455">            verify(subscriber, never()).onNext(1);</span>
<span class="fc" id="L456">            verify(subscriber).onNext(2);</span>
<span class="fc" id="L457">            verify(subscriber).onComplete();</span>
<span class="fc" id="L458">            verify(subscriber, never()).onError(any(Throwable.class));</span>
        }
<span class="fc" id="L460">    }</span>

    @Test
    public void testReplay1Directly() {
<span class="fc" id="L464">        ReplayProcessor&lt;Integer&gt; source = ReplayProcessor.createWithSize(1);</span>

<span class="fc" id="L466">        Subscriber&lt;Integer&gt; subscriber = TestHelper.mockSubscriber();</span>

<span class="fc" id="L468">        source.onNext(1);</span>
<span class="fc" id="L469">        source.onNext(2);</span>

<span class="fc" id="L471">        source.subscribe(subscriber);</span>

<span class="fc" id="L473">        source.onNext(3);</span>
<span class="fc" id="L474">        source.onComplete();</span>

<span class="fc" id="L476">        verify(subscriber, never()).onNext(1);</span>
<span class="fc" id="L477">        verify(subscriber).onNext(2);</span>
<span class="fc" id="L478">        verify(subscriber).onNext(3);</span>
<span class="fc" id="L479">        verify(subscriber).onComplete();</span>
<span class="fc" id="L480">        verify(subscriber, never()).onError(any(Throwable.class));</span>
<span class="fc" id="L481">    }</span>

    @Test
    public void testReplayTimestampedAfterTermination() {
<span class="fc" id="L485">        TestScheduler scheduler = new TestScheduler();</span>
<span class="fc" id="L486">        ReplayProcessor&lt;Integer&gt; source = ReplayProcessor.createWithTime(1, TimeUnit.SECONDS, scheduler);</span>

<span class="fc" id="L488">        source.onNext(1);</span>

<span class="fc" id="L490">        scheduler.advanceTimeBy(1, TimeUnit.SECONDS);</span>

<span class="fc" id="L492">        source.onNext(2);</span>

<span class="fc" id="L494">        scheduler.advanceTimeBy(1, TimeUnit.SECONDS);</span>

<span class="fc" id="L496">        source.onNext(3);</span>
<span class="fc" id="L497">        source.onComplete();</span>

<span class="fc" id="L499">        scheduler.advanceTimeBy(1, TimeUnit.SECONDS);</span>

<span class="fc" id="L501">        Subscriber&lt;Integer&gt; subscriber = TestHelper.mockSubscriber();</span>

<span class="fc" id="L503">        source.subscribe(subscriber);</span>

<span class="fc" id="L505">        verify(subscriber, never()).onNext(1);</span>
<span class="fc" id="L506">        verify(subscriber, never()).onNext(2);</span>
<span class="fc" id="L507">        verify(subscriber, never()).onNext(3);</span>
<span class="fc" id="L508">        verify(subscriber).onComplete();</span>
<span class="fc" id="L509">        verify(subscriber, never()).onError(any(Throwable.class));</span>
<span class="fc" id="L510">    }</span>

    @Test
    public void testReplayTimestampedDirectly() {
<span class="fc" id="L514">        TestScheduler scheduler = new TestScheduler();</span>
<span class="fc" id="L515">        ReplayProcessor&lt;Integer&gt; source = ReplayProcessor.createWithTime(1, TimeUnit.SECONDS, scheduler);</span>

<span class="fc" id="L517">        source.onNext(1);</span>

<span class="fc" id="L519">        scheduler.advanceTimeBy(1, TimeUnit.SECONDS);</span>

<span class="fc" id="L521">        Subscriber&lt;Integer&gt; subscriber = TestHelper.mockSubscriber();</span>

<span class="fc" id="L523">        source.subscribe(subscriber);</span>

<span class="fc" id="L525">        source.onNext(2);</span>

<span class="fc" id="L527">        scheduler.advanceTimeBy(1, TimeUnit.SECONDS);</span>

<span class="fc" id="L529">        source.onNext(3);</span>

<span class="fc" id="L531">        scheduler.advanceTimeBy(1, TimeUnit.SECONDS);</span>

<span class="fc" id="L533">        source.onComplete();</span>

<span class="fc" id="L535">        scheduler.advanceTimeBy(1, TimeUnit.SECONDS);</span>

<span class="fc" id="L537">        verify(subscriber, never()).onError(any(Throwable.class));</span>
<span class="fc" id="L538">        verify(subscriber, never()).onNext(1);</span>
<span class="fc" id="L539">        verify(subscriber).onNext(2);</span>
<span class="fc" id="L540">        verify(subscriber).onNext(3);</span>
<span class="fc" id="L541">        verify(subscriber).onComplete();</span>
<span class="fc" id="L542">    }</span>

    // FIXME RS subscribers can't throw
//    @Test
//    public void testOnErrorThrowsDoesntPreventDelivery() {
//        ReplayProcessor&lt;String&gt; ps = ReplayProcessor.create();
//
//        ps.subscribe();
//        TestSubscriber&lt;String&gt; ts = new TestSubscriber&lt;String&gt;();
//        ps.subscribe(ts);
//
//        try {
//            ps.onError(new RuntimeException(&quot;an exception&quot;));
//            fail(&quot;expect OnErrorNotImplementedException&quot;);
//        } catch (OnErrorNotImplementedException e) {
//            // ignore
//        }
//        // even though the onError above throws we should still receive it on the other subscriber
//        assertEquals(1, ts.errors().size());
//    }

    // FIXME RS subscribers can't throw
//    /**
//     * This one has multiple failures so should get a CompositeException
//     */
//    @Test
//    public void testOnErrorThrowsDoesntPreventDelivery2() {
//        ReplayProcessor&lt;String&gt; ps = ReplayProcessor.create();
//
//        ps.subscribe();
//        ps.subscribe();
//        TestSubscriber&lt;String&gt; ts = new TestSubscriber&lt;String&gt;();
//        ps.subscribe(ts);
//        ps.subscribe();
//        ps.subscribe();
//        ps.subscribe();
//
//        try {
//            ps.onError(new RuntimeException(&quot;an exception&quot;));
//            fail(&quot;expect OnErrorNotImplementedException&quot;);
//        } catch (CompositeException e) {
//            // we should have 5 of them
//            assertEquals(5, e.getExceptions().size());
//        }
//        // even though the onError above throws we should still receive it on the other subscriber
//        assertEquals(1, ts.getOnErrorEvents().size());
//    }

    @Test
    public void testCurrentStateMethodsNormal() {
<span class="fc" id="L592">        ReplayProcessor&lt;Object&gt; as = ReplayProcessor.create();</span>

<span class="fc" id="L594">        assertFalse(as.hasThrowable());</span>
<span class="fc" id="L595">        assertFalse(as.hasComplete());</span>
<span class="fc" id="L596">        assertNull(as.getThrowable());</span>

<span class="fc" id="L598">        as.onNext(1);</span>

<span class="fc" id="L600">        assertFalse(as.hasThrowable());</span>
<span class="fc" id="L601">        assertFalse(as.hasComplete());</span>
<span class="fc" id="L602">        assertNull(as.getThrowable());</span>

<span class="fc" id="L604">        as.onComplete();</span>

<span class="fc" id="L606">        assertFalse(as.hasThrowable());</span>
<span class="fc" id="L607">        assertTrue(as.hasComplete());</span>
<span class="fc" id="L608">        assertNull(as.getThrowable());</span>
<span class="fc" id="L609">    }</span>

    @Test
    public void testCurrentStateMethodsEmpty() {
<span class="fc" id="L613">        ReplayProcessor&lt;Object&gt; as = ReplayProcessor.create();</span>

<span class="fc" id="L615">        assertFalse(as.hasThrowable());</span>
<span class="fc" id="L616">        assertFalse(as.hasComplete());</span>
<span class="fc" id="L617">        assertNull(as.getThrowable());</span>

<span class="fc" id="L619">        as.onComplete();</span>

<span class="fc" id="L621">        assertFalse(as.hasThrowable());</span>
<span class="fc" id="L622">        assertTrue(as.hasComplete());</span>
<span class="fc" id="L623">        assertNull(as.getThrowable());</span>
<span class="fc" id="L624">    }</span>

    @Test
    public void testCurrentStateMethodsError() {
<span class="fc" id="L628">        ReplayProcessor&lt;Object&gt; as = ReplayProcessor.create();</span>

<span class="fc" id="L630">        assertFalse(as.hasThrowable());</span>
<span class="fc" id="L631">        assertFalse(as.hasComplete());</span>
<span class="fc" id="L632">        assertNull(as.getThrowable());</span>

<span class="fc" id="L634">        as.onError(new TestException());</span>

<span class="fc" id="L636">        assertTrue(as.hasThrowable());</span>
<span class="fc" id="L637">        assertFalse(as.hasComplete());</span>
<span class="fc" id="L638">        assertTrue(as.getThrowable() instanceof TestException);</span>
<span class="fc" id="L639">    }</span>

    @Test
    public void testSizeAndHasAnyValueUnbounded() {
<span class="fc" id="L643">        ReplayProcessor&lt;Object&gt; rs = ReplayProcessor.create();</span>

<span class="fc" id="L645">        assertEquals(0, rs.size());</span>
<span class="fc" id="L646">        assertFalse(rs.hasValue());</span>

<span class="fc" id="L648">        rs.onNext(1);</span>

<span class="fc" id="L650">        assertEquals(1, rs.size());</span>
<span class="fc" id="L651">        assertTrue(rs.hasValue());</span>

<span class="fc" id="L653">        rs.onNext(1);</span>

<span class="fc" id="L655">        assertEquals(2, rs.size());</span>
<span class="fc" id="L656">        assertTrue(rs.hasValue());</span>

<span class="fc" id="L658">        rs.onComplete();</span>

<span class="fc" id="L660">        assertEquals(2, rs.size());</span>
<span class="fc" id="L661">        assertTrue(rs.hasValue());</span>
<span class="fc" id="L662">    }</span>

    @Test
    public void testSizeAndHasAnyValueEffectivelyUnbounded() {
<span class="fc" id="L666">        ReplayProcessor&lt;Object&gt; rs = ReplayProcessor.createUnbounded();</span>

<span class="fc" id="L668">        assertEquals(0, rs.size());</span>
<span class="fc" id="L669">        assertFalse(rs.hasValue());</span>

<span class="fc" id="L671">        rs.onNext(1);</span>

<span class="fc" id="L673">        assertEquals(1, rs.size());</span>
<span class="fc" id="L674">        assertTrue(rs.hasValue());</span>

<span class="fc" id="L676">        rs.onNext(1);</span>

<span class="fc" id="L678">        assertEquals(2, rs.size());</span>
<span class="fc" id="L679">        assertTrue(rs.hasValue());</span>

<span class="fc" id="L681">        rs.onComplete();</span>

<span class="fc" id="L683">        assertEquals(2, rs.size());</span>
<span class="fc" id="L684">        assertTrue(rs.hasValue());</span>
<span class="fc" id="L685">    }</span>

    @Test
    public void testSizeAndHasAnyValueUnboundedError() {
<span class="fc" id="L689">        ReplayProcessor&lt;Object&gt; rs = ReplayProcessor.create();</span>

<span class="fc" id="L691">        assertEquals(0, rs.size());</span>
<span class="fc" id="L692">        assertFalse(rs.hasValue());</span>

<span class="fc" id="L694">        rs.onNext(1);</span>

<span class="fc" id="L696">        assertEquals(1, rs.size());</span>
<span class="fc" id="L697">        assertTrue(rs.hasValue());</span>

<span class="fc" id="L699">        rs.onNext(1);</span>

<span class="fc" id="L701">        assertEquals(2, rs.size());</span>
<span class="fc" id="L702">        assertTrue(rs.hasValue());</span>

<span class="fc" id="L704">        rs.onError(new TestException());</span>

<span class="fc" id="L706">        assertEquals(2, rs.size());</span>
<span class="fc" id="L707">        assertTrue(rs.hasValue());</span>
<span class="fc" id="L708">    }</span>

    @Test
    public void testSizeAndHasAnyValueEffectivelyUnboundedError() {
<span class="fc" id="L712">        ReplayProcessor&lt;Object&gt; rs = ReplayProcessor.createUnbounded();</span>

<span class="fc" id="L714">        assertEquals(0, rs.size());</span>
<span class="fc" id="L715">        assertFalse(rs.hasValue());</span>

<span class="fc" id="L717">        rs.onNext(1);</span>

<span class="fc" id="L719">        assertEquals(1, rs.size());</span>
<span class="fc" id="L720">        assertTrue(rs.hasValue());</span>

<span class="fc" id="L722">        rs.onNext(1);</span>

<span class="fc" id="L724">        assertEquals(2, rs.size());</span>
<span class="fc" id="L725">        assertTrue(rs.hasValue());</span>

<span class="fc" id="L727">        rs.onError(new TestException());</span>

<span class="fc" id="L729">        assertEquals(2, rs.size());</span>
<span class="fc" id="L730">        assertTrue(rs.hasValue());</span>
<span class="fc" id="L731">    }</span>

    @Test
    public void testSizeAndHasAnyValueUnboundedEmptyError() {
<span class="fc" id="L735">        ReplayProcessor&lt;Object&gt; rs = ReplayProcessor.create();</span>

<span class="fc" id="L737">        rs.onError(new TestException());</span>

<span class="fc" id="L739">        assertEquals(0, rs.size());</span>
<span class="fc" id="L740">        assertFalse(rs.hasValue());</span>
<span class="fc" id="L741">    }</span>

    @Test
    public void testSizeAndHasAnyValueEffectivelyUnboundedEmptyError() {
<span class="fc" id="L745">        ReplayProcessor&lt;Object&gt; rs = ReplayProcessor.createUnbounded();</span>

<span class="fc" id="L747">        rs.onError(new TestException());</span>

<span class="fc" id="L749">        assertEquals(0, rs.size());</span>
<span class="fc" id="L750">        assertFalse(rs.hasValue());</span>
<span class="fc" id="L751">    }</span>

    @Test
    public void testSizeAndHasAnyValueUnboundedEmptyCompleted() {
<span class="fc" id="L755">        ReplayProcessor&lt;Object&gt; rs = ReplayProcessor.create();</span>

<span class="fc" id="L757">        rs.onComplete();</span>

<span class="fc" id="L759">        assertEquals(0, rs.size());</span>
<span class="fc" id="L760">        assertFalse(rs.hasValue());</span>
<span class="fc" id="L761">    }</span>

    @Test
    public void testSizeAndHasAnyValueEffectivelyUnboundedEmptyCompleted() {
<span class="fc" id="L765">        ReplayProcessor&lt;Object&gt; rs = ReplayProcessor.createUnbounded();</span>

<span class="fc" id="L767">        rs.onComplete();</span>

<span class="fc" id="L769">        assertEquals(0, rs.size());</span>
<span class="fc" id="L770">        assertFalse(rs.hasValue());</span>
<span class="fc" id="L771">    }</span>

    @Test
    public void testSizeAndHasAnyValueSizeBounded() {
<span class="fc" id="L775">        ReplayProcessor&lt;Object&gt; rs = ReplayProcessor.createWithSize(1);</span>

<span class="fc" id="L777">        assertEquals(0, rs.size());</span>
<span class="fc" id="L778">        assertFalse(rs.hasValue());</span>

<span class="fc bfc" id="L780" title="All 2 branches covered.">        for (int i = 0; i &lt; 1000; i++) {</span>
<span class="fc" id="L781">            rs.onNext(i);</span>

<span class="fc" id="L783">            assertEquals(1, rs.size());</span>
<span class="fc" id="L784">            assertTrue(rs.hasValue());</span>
        }

<span class="fc" id="L787">        rs.onComplete();</span>

<span class="fc" id="L789">        assertEquals(1, rs.size());</span>
<span class="fc" id="L790">        assertTrue(rs.hasValue());</span>
<span class="fc" id="L791">    }</span>

    @Test
    public void testSizeAndHasAnyValueTimeBounded() {
<span class="fc" id="L795">        TestScheduler ts = new TestScheduler();</span>
<span class="fc" id="L796">        ReplayProcessor&lt;Object&gt; rs = ReplayProcessor.createWithTime(1, TimeUnit.SECONDS, ts);</span>

<span class="fc" id="L798">        assertEquals(0, rs.size());</span>
<span class="fc" id="L799">        assertFalse(rs.hasValue());</span>

<span class="fc bfc" id="L801" title="All 2 branches covered.">        for (int i = 0; i &lt; 1000; i++) {</span>
<span class="fc" id="L802">            rs.onNext(i);</span>
<span class="fc" id="L803">            assertEquals(1, rs.size());</span>
<span class="fc" id="L804">            assertTrue(rs.hasValue());</span>
<span class="fc" id="L805">            ts.advanceTimeBy(2, TimeUnit.SECONDS);</span>
<span class="fc" id="L806">            assertEquals(0, rs.size());</span>
<span class="fc" id="L807">            assertFalse(rs.hasValue());</span>
        }

<span class="fc" id="L810">        rs.onComplete();</span>

<span class="fc" id="L812">        assertEquals(0, rs.size());</span>
<span class="fc" id="L813">        assertFalse(rs.hasValue());</span>
<span class="fc" id="L814">    }</span>

    @Test
    public void testGetValues() {
<span class="fc" id="L818">        ReplayProcessor&lt;Object&gt; rs = ReplayProcessor.create();</span>
<span class="fc" id="L819">        Object[] expected = new Object[10];</span>
<span class="fc bfc" id="L820" title="All 2 branches covered.">        for (int i = 0; i &lt; expected.length; i++) {</span>
<span class="fc" id="L821">            expected[i] = i;</span>
<span class="fc" id="L822">            rs.onNext(i);</span>
<span class="fc" id="L823">            assertArrayEquals(Arrays.copyOf(expected, i + 1), rs.getValues());</span>
        }
<span class="fc" id="L825">        rs.onComplete();</span>

<span class="fc" id="L827">        assertArrayEquals(expected, rs.getValues());</span>

<span class="fc" id="L829">    }</span>

    @Test
    public void testGetValuesUnbounded() {
<span class="fc" id="L833">        ReplayProcessor&lt;Object&gt; rs = ReplayProcessor.createUnbounded();</span>
<span class="fc" id="L834">        Object[] expected = new Object[10];</span>
<span class="fc bfc" id="L835" title="All 2 branches covered.">        for (int i = 0; i &lt; expected.length; i++) {</span>
<span class="fc" id="L836">            expected[i] = i;</span>
<span class="fc" id="L837">            rs.onNext(i);</span>
<span class="fc" id="L838">            assertArrayEquals(Arrays.copyOf(expected, i + 1), rs.getValues());</span>
        }
<span class="fc" id="L840">        rs.onComplete();</span>

<span class="fc" id="L842">        assertArrayEquals(expected, rs.getValues());</span>

<span class="fc" id="L844">    }</span>

    @Test
    public void testBackpressureHonored() {
<span class="fc" id="L848">        ReplayProcessor&lt;Integer&gt; rs = ReplayProcessor.create();</span>
<span class="fc" id="L849">        rs.onNext(1);</span>
<span class="fc" id="L850">        rs.onNext(2);</span>
<span class="fc" id="L851">        rs.onNext(3);</span>
<span class="fc" id="L852">        rs.onComplete();</span>

<span class="fc" id="L854">        TestSubscriber&lt;Integer&gt; ts = new TestSubscriber&lt;Integer&gt;(0L);</span>

<span class="fc" id="L856">        rs.subscribe(ts);</span>

<span class="fc" id="L858">        ts.request(1);</span>
<span class="fc" id="L859">        ts.assertValue(1);</span>
<span class="fc" id="L860">        ts.assertNotComplete();</span>
<span class="fc" id="L861">        ts.assertNoErrors();</span>

<span class="fc" id="L863">        ts.request(1);</span>
<span class="fc" id="L864">        ts.assertValues(1, 2);</span>
<span class="fc" id="L865">        ts.assertNotComplete();</span>
<span class="fc" id="L866">        ts.assertNoErrors();</span>

<span class="fc" id="L868">        ts.request(1);</span>
<span class="fc" id="L869">        ts.assertValues(1, 2, 3);</span>
<span class="fc" id="L870">        ts.assertComplete();</span>
<span class="fc" id="L871">        ts.assertNoErrors();</span>
<span class="fc" id="L872">    }</span>

    @Test
    public void testBackpressureHonoredSizeBound() {
<span class="fc" id="L876">        ReplayProcessor&lt;Integer&gt; rs = ReplayProcessor.createWithSize(100);</span>
<span class="fc" id="L877">        rs.onNext(1);</span>
<span class="fc" id="L878">        rs.onNext(2);</span>
<span class="fc" id="L879">        rs.onNext(3);</span>
<span class="fc" id="L880">        rs.onComplete();</span>

<span class="fc" id="L882">        TestSubscriber&lt;Integer&gt; ts = new TestSubscriber&lt;Integer&gt;(0L);</span>

<span class="fc" id="L884">        rs.subscribe(ts);</span>

<span class="fc" id="L886">        ts.request(1);</span>
<span class="fc" id="L887">        ts.assertValue(1);</span>
<span class="fc" id="L888">        ts.assertNotComplete();</span>
<span class="fc" id="L889">        ts.assertNoErrors();</span>

<span class="fc" id="L891">        ts.request(1);</span>
<span class="fc" id="L892">        ts.assertValues(1, 2);</span>
<span class="fc" id="L893">        ts.assertNotComplete();</span>
<span class="fc" id="L894">        ts.assertNoErrors();</span>

<span class="fc" id="L896">        ts.request(1);</span>
<span class="fc" id="L897">        ts.assertValues(1, 2, 3);</span>
<span class="fc" id="L898">        ts.assertComplete();</span>
<span class="fc" id="L899">        ts.assertNoErrors();</span>
<span class="fc" id="L900">    }</span>

    @Test
    public void testBackpressureHonoredTimeBound() {
<span class="fc" id="L904">        ReplayProcessor&lt;Integer&gt; rs = ReplayProcessor.createWithTime(1, TimeUnit.DAYS, Schedulers.trampoline());</span>
<span class="fc" id="L905">        rs.onNext(1);</span>
<span class="fc" id="L906">        rs.onNext(2);</span>
<span class="fc" id="L907">        rs.onNext(3);</span>
<span class="fc" id="L908">        rs.onComplete();</span>

<span class="fc" id="L910">        TestSubscriber&lt;Integer&gt; ts = new TestSubscriber&lt;Integer&gt;(0L);</span>

<span class="fc" id="L912">        rs.subscribe(ts);</span>

<span class="fc" id="L914">        ts.request(1);</span>
<span class="fc" id="L915">        ts.assertValue(1);</span>
<span class="fc" id="L916">        ts.assertNotComplete();</span>
<span class="fc" id="L917">        ts.assertNoErrors();</span>

<span class="fc" id="L919">        ts.request(1);</span>
<span class="fc" id="L920">        ts.assertValues(1, 2);</span>
<span class="fc" id="L921">        ts.assertNotComplete();</span>
<span class="fc" id="L922">        ts.assertNoErrors();</span>

<span class="fc" id="L924">        ts.request(1);</span>
<span class="fc" id="L925">        ts.assertValues(1, 2, 3);</span>
<span class="fc" id="L926">        ts.assertComplete();</span>
<span class="fc" id="L927">        ts.assertNoErrors();</span>
<span class="fc" id="L928">    }</span>

    @Test
    public void createInvalidCapacity() {
        try {
<span class="nc" id="L933">            ReplayProcessor.create(-99);</span>
<span class="nc" id="L934">            fail(&quot;Didn't throw IllegalArgumentException&quot;);</span>
<span class="fc" id="L935">        } catch (IllegalArgumentException ex) {</span>
<span class="fc" id="L936">            assertEquals(&quot;capacityHint &gt; 0 required but it was -99&quot;, ex.getMessage());</span>
<span class="nc" id="L937">        }</span>
<span class="fc" id="L938">    }</span>

    @Test
    public void createWithSizeInvalidCapacity() {
        try {
<span class="nc" id="L943">            ReplayProcessor.createWithSize(-99);</span>
<span class="nc" id="L944">            fail(&quot;Didn't throw IllegalArgumentException&quot;);</span>
<span class="fc" id="L945">        } catch (IllegalArgumentException ex) {</span>
<span class="fc" id="L946">            assertEquals(&quot;maxSize &gt; 0 required but it was -99&quot;, ex.getMessage());</span>
<span class="nc" id="L947">        }</span>
<span class="fc" id="L948">    }</span>

    @Test
    public void createWithTimeAndSizeInvalidCapacity() {
        try {
<span class="nc" id="L953">            ReplayProcessor.createWithTimeAndSize(1, TimeUnit.DAYS, Schedulers.computation(), -99);</span>
<span class="nc" id="L954">            fail(&quot;Didn't throw IllegalArgumentException&quot;);</span>
<span class="fc" id="L955">        } catch (IllegalArgumentException ex) {</span>
<span class="fc" id="L956">            assertEquals(&quot;maxSize &gt; 0 required but it was -99&quot;, ex.getMessage());</span>
<span class="nc" id="L957">        }</span>
<span class="fc" id="L958">    }</span>

    @Test
    public void hasSubscribers() {
<span class="fc" id="L962">        ReplayProcessor&lt;Integer&gt; rp = ReplayProcessor.create();</span>

<span class="fc" id="L964">        assertFalse(rp.hasSubscribers());</span>

<span class="fc" id="L966">        TestSubscriber&lt;Integer&gt; ts = rp.test();</span>

<span class="fc" id="L968">        assertTrue(rp.hasSubscribers());</span>

<span class="fc" id="L970">        ts.cancel();</span>

<span class="fc" id="L972">        assertFalse(rp.hasSubscribers());</span>
<span class="fc" id="L973">    }</span>

    @Test
    public void peekStateUnbounded() {
<span class="fc" id="L977">        ReplayProcessor&lt;Integer&gt; rp = ReplayProcessor.create();</span>

<span class="fc" id="L979">        rp.onNext(1);</span>

<span class="fc" id="L981">        assertEquals((Integer)1, rp.getValue());</span>

<span class="fc" id="L983">        assertEquals(1, rp.getValues()[0]);</span>
<span class="fc" id="L984">    }</span>

    @Test
    public void peekStateTimeAndSize() {
<span class="fc" id="L988">        ReplayProcessor&lt;Integer&gt; rp = ReplayProcessor.createWithTimeAndSize(1, TimeUnit.DAYS, Schedulers.computation(), 1);</span>

<span class="fc" id="L990">        rp.onNext(1);</span>

<span class="fc" id="L992">        assertEquals((Integer)1, rp.getValue());</span>

<span class="fc" id="L994">        assertEquals(1, rp.getValues()[0]);</span>

<span class="fc" id="L996">        rp.onNext(2);</span>

<span class="fc" id="L998">        assertEquals((Integer)2, rp.getValue());</span>

<span class="fc" id="L1000">        assertEquals(2, rp.getValues()[0]);</span>

<span class="fc" id="L1002">        assertEquals((Integer)2, rp.getValues(new Integer[0])[0]);</span>

<span class="fc" id="L1004">        assertEquals((Integer)2, rp.getValues(new Integer[1])[0]);</span>

<span class="fc" id="L1006">        Integer[] a = new Integer[2];</span>
<span class="fc" id="L1007">        assertEquals((Integer)2, rp.getValues(a)[0]);</span>
<span class="fc" id="L1008">        assertNull(a[1]);</span>
<span class="fc" id="L1009">    }</span>

    @Test
    public void peekStateTimeAndSizeValue() {
<span class="fc" id="L1013">        ReplayProcessor&lt;Integer&gt; rp = ReplayProcessor.createWithTimeAndSize(1, TimeUnit.DAYS, Schedulers.computation(), 1);</span>

<span class="fc" id="L1015">        assertNull(rp.getValue());</span>

<span class="fc" id="L1017">        assertEquals(0, rp.getValues().length);</span>

<span class="fc" id="L1019">        assertNull(rp.getValues(new Integer[2])[0]);</span>

<span class="fc" id="L1021">        rp.onComplete();</span>

<span class="fc" id="L1023">        assertNull(rp.getValue());</span>

<span class="fc" id="L1025">        assertEquals(0, rp.getValues().length);</span>

<span class="fc" id="L1027">        assertNull(rp.getValues(new Integer[2])[0]);</span>

<span class="fc" id="L1029">        rp = ReplayProcessor.createWithTimeAndSize(1, TimeUnit.DAYS, Schedulers.computation(), 1);</span>
<span class="fc" id="L1030">        rp.onError(new TestException());</span>

<span class="fc" id="L1032">        assertNull(rp.getValue());</span>

<span class="fc" id="L1034">        assertEquals(0, rp.getValues().length);</span>

<span class="fc" id="L1036">        assertNull(rp.getValues(new Integer[2])[0]);</span>
<span class="fc" id="L1037">    }</span>

    @Test
    public void peekStateTimeAndSizeValueExpired() {
<span class="fc" id="L1041">        TestScheduler scheduler = new TestScheduler();</span>
<span class="fc" id="L1042">        ReplayProcessor&lt;Integer&gt; rp = ReplayProcessor.createWithTime(1, TimeUnit.DAYS, scheduler);</span>

<span class="fc" id="L1044">        assertNull(rp.getValue());</span>
<span class="fc" id="L1045">        assertNull(rp.getValues(new Integer[2])[0]);</span>

<span class="fc" id="L1047">        rp.onNext(2);</span>

<span class="fc" id="L1049">        assertEquals((Integer)2, rp.getValue());</span>
<span class="fc" id="L1050">        assertEquals(2, rp.getValues()[0]);</span>

<span class="fc" id="L1052">        scheduler.advanceTimeBy(2, TimeUnit.DAYS);</span>

<span class="fc" id="L1054">        assertEquals(null, rp.getValue());</span>
<span class="fc" id="L1055">        assertEquals(0, rp.getValues().length);</span>
<span class="fc" id="L1056">        assertNull(rp.getValues(new Integer[2])[0]);</span>
<span class="fc" id="L1057">    }</span>

    @Test
    public void capacityHint() {
<span class="fc" id="L1061">        ReplayProcessor&lt;Integer&gt; rp = ReplayProcessor.create(8);</span>

<span class="fc bfc" id="L1063" title="All 2 branches covered.">        for (int i = 0; i &lt; 15; i++) {</span>
<span class="fc" id="L1064">            rp.onNext(i);</span>
        }
<span class="fc" id="L1066">        rp.onComplete();</span>

<span class="fc" id="L1068">        rp.test().assertResult(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14);</span>
<span class="fc" id="L1069">    }</span>

    @Test
    public void subscribeCancelRace() {
<span class="fc bfc" id="L1073" title="All 2 branches covered.">        for (int i = 0; i &lt; TestHelper.RACE_DEFAULT_LOOPS; i++) {</span>
<span class="fc" id="L1074">            final TestSubscriber&lt;Integer&gt; ts = new TestSubscriber&lt;Integer&gt;();</span>

<span class="fc" id="L1076">            final ReplayProcessor&lt;Integer&gt; rp = ReplayProcessor.create();</span>

<span class="fc" id="L1078">            Runnable r1 = new Runnable() {</span>
                @Override
                public void run() {
<span class="fc" id="L1081">                    rp.subscribe(ts);</span>
<span class="fc" id="L1082">                }</span>
            };

<span class="fc" id="L1085">            Runnable r2 = new Runnable() {</span>
                @Override
                public void run() {
<span class="fc" id="L1088">                    ts.cancel();</span>
<span class="fc" id="L1089">                }</span>
            };

<span class="fc" id="L1092">            TestHelper.race(r1, r2);</span>
        }
<span class="fc" id="L1094">    }</span>

    @Test
    public void subscribeAfterDone() {
<span class="fc" id="L1098">        ReplayProcessor&lt;Integer&gt; rp = ReplayProcessor.create();</span>
<span class="fc" id="L1099">        rp.onComplete();</span>

<span class="fc" id="L1101">        BooleanSubscription bs = new BooleanSubscription();</span>

<span class="fc" id="L1103">        rp.onSubscribe(bs);</span>

<span class="fc" id="L1105">        assertTrue(bs.isCancelled());</span>
<span class="fc" id="L1106">    }</span>

    @Test
    public void subscribeRace() {
<span class="fc bfc" id="L1110" title="All 2 branches covered.">        for (int i = 0; i &lt; TestHelper.RACE_DEFAULT_LOOPS; i++) {</span>
<span class="fc" id="L1111">            final ReplayProcessor&lt;Integer&gt; rp = ReplayProcessor.create();</span>

<span class="fc" id="L1113">            Runnable r1 = new Runnable() {</span>
                @Override
                public void run() {
<span class="fc" id="L1116">                    rp.test();</span>
<span class="fc" id="L1117">                }</span>
            };

<span class="fc" id="L1120">            TestHelper.race(r1, r1);</span>
        }
<span class="fc" id="L1122">    }</span>

    @Test
    public void cancelUpfront() {
<span class="fc" id="L1126">        ReplayProcessor&lt;Integer&gt; rp = ReplayProcessor.create();</span>
<span class="fc" id="L1127">        rp.test();</span>
<span class="fc" id="L1128">        rp.test();</span>

<span class="fc" id="L1130">        TestSubscriber&lt;Integer&gt; ts = rp.test(0L, true);</span>

<span class="fc" id="L1132">        assertEquals(2, rp.subscriberCount());</span>

<span class="fc" id="L1134">        ts.assertEmpty();</span>
<span class="fc" id="L1135">    }</span>

    @Test
    public void cancelRace() {
<span class="fc bfc" id="L1139" title="All 2 branches covered.">        for (int i = 0; i &lt; TestHelper.RACE_DEFAULT_LOOPS; i++) {</span>

<span class="fc" id="L1141">            final ReplayProcessor&lt;Integer&gt; rp = ReplayProcessor.create();</span>
<span class="fc" id="L1142">            final TestSubscriber&lt;Integer&gt; ts1 = rp.test();</span>
<span class="fc" id="L1143">            final TestSubscriber&lt;Integer&gt; ts2 = rp.test();</span>

<span class="fc" id="L1145">            Runnable r1 = new Runnable() {</span>
                @Override
                public void run() {
<span class="fc" id="L1148">                    ts1.cancel();</span>
<span class="fc" id="L1149">                }</span>
            };

<span class="fc" id="L1152">            Runnable r2 = new Runnable() {</span>
                @Override
                public void run() {
<span class="fc" id="L1155">                    ts2.cancel();</span>
<span class="fc" id="L1156">                }</span>
            };

<span class="fc" id="L1159">            TestHelper.race(r1, r2);</span>

<span class="fc" id="L1161">            assertFalse(rp.hasSubscribers());</span>
        }
<span class="fc" id="L1163">    }</span>

    @Test
    public void sizeboundReplayError() {
<span class="fc" id="L1167">        ReplayProcessor&lt;Integer&gt; rp = ReplayProcessor.createWithSize(2);</span>

<span class="fc" id="L1169">        rp.onNext(1);</span>
<span class="fc" id="L1170">        rp.onNext(2);</span>
<span class="fc" id="L1171">        rp.onNext(3);</span>
<span class="fc" id="L1172">        rp.onNext(4);</span>
<span class="fc" id="L1173">        rp.onError(new TestException());</span>

<span class="fc" id="L1175">        rp.test()</span>
<span class="fc" id="L1176">        .assertFailure(TestException.class, 3, 4);</span>
<span class="fc" id="L1177">    }</span>

    @Test
    public void sizeAndTimeBoundReplayError() {
<span class="fc" id="L1181">        ReplayProcessor&lt;Integer&gt; rp = ReplayProcessor.createWithTimeAndSize(1, TimeUnit.DAYS, Schedulers.single(), 2);</span>

<span class="fc" id="L1183">        rp.onNext(1);</span>
<span class="fc" id="L1184">        rp.onNext(2);</span>
<span class="fc" id="L1185">        rp.onNext(3);</span>
<span class="fc" id="L1186">        rp.onNext(4);</span>
<span class="fc" id="L1187">        rp.onError(new TestException());</span>

<span class="fc" id="L1189">        rp.test()</span>
<span class="fc" id="L1190">        .assertFailure(TestException.class, 3, 4);</span>
<span class="fc" id="L1191">    }</span>

    @Test
    public void replayRequestRace() {
<span class="fc bfc" id="L1195" title="All 2 branches covered.">        for (int i = 0; i &lt; TestHelper.RACE_DEFAULT_LOOPS; i++) {</span>

<span class="fc" id="L1197">            final ReplayProcessor&lt;Integer&gt; rp = ReplayProcessor.createWithTimeAndSize(1, TimeUnit.DAYS, Schedulers.single(), 2);</span>
<span class="fc" id="L1198">            final TestSubscriber&lt;Integer&gt; ts = rp.test(0L);</span>

<span class="fc" id="L1200">            Runnable r1 = new Runnable() {</span>
                @Override
                public void run() {
<span class="fc" id="L1203">                    ts.request(1);</span>
<span class="fc" id="L1204">                }</span>
            };

<span class="fc" id="L1207">            Runnable r2 = new Runnable() {</span>
                @Override
                public void run() {
<span class="fc" id="L1210">                    rp.onNext(1);</span>
<span class="fc" id="L1211">                }</span>
            };

<span class="fc" id="L1214">            TestHelper.race(r1, r2);</span>
        }
<span class="fc" id="L1216">    }</span>

    @Test
    public void timedSkipOld() {
<span class="fc" id="L1220">        TestScheduler scheduler = new TestScheduler();</span>

<span class="fc" id="L1222">        ReplayProcessor&lt;Integer&gt; rp = ReplayProcessor.createWithTimeAndSize(1, TimeUnit.SECONDS, scheduler, 2);</span>

<span class="fc" id="L1224">        rp.onNext(1);</span>
<span class="fc" id="L1225">        scheduler.advanceTimeBy(1, TimeUnit.SECONDS);</span>

<span class="fc" id="L1227">        rp.test()</span>
<span class="fc" id="L1228">        .assertEmpty();</span>
<span class="fc" id="L1229">    }</span>

    @Test
    public void takeSizeAndTime() {
<span class="fc" id="L1233">        TestScheduler scheduler = new TestScheduler();</span>

<span class="fc" id="L1235">        ReplayProcessor&lt;Integer&gt; rp = ReplayProcessor.createWithTimeAndSize(1, TimeUnit.SECONDS, scheduler, 2);</span>

<span class="fc" id="L1237">        rp.onNext(1);</span>
<span class="fc" id="L1238">        rp.onNext(2);</span>
<span class="fc" id="L1239">        rp.onNext(3);</span>

<span class="fc" id="L1241">        rp</span>
<span class="fc" id="L1242">        .take(1)</span>
<span class="fc" id="L1243">        .test()</span>
<span class="fc" id="L1244">        .assertResult(2);</span>
<span class="fc" id="L1245">    }</span>

    @Test
    public void takeSize() {
<span class="fc" id="L1249">        ReplayProcessor&lt;Integer&gt; rp = ReplayProcessor.createWithSize(2);</span>

<span class="fc" id="L1251">        rp.onNext(1);</span>
<span class="fc" id="L1252">        rp.onNext(2);</span>
<span class="fc" id="L1253">        rp.onNext(3);</span>

<span class="fc" id="L1255">        rp</span>
<span class="fc" id="L1256">        .take(1)</span>
<span class="fc" id="L1257">        .test()</span>
<span class="fc" id="L1258">        .assertResult(2);</span>
<span class="fc" id="L1259">    }</span>

    @Test
    public void reentrantDrain() {
<span class="fc" id="L1263">        TestScheduler scheduler = new TestScheduler();</span>

<span class="fc" id="L1265">        final ReplayProcessor&lt;Integer&gt; rp = ReplayProcessor.createWithTimeAndSize(1, TimeUnit.SECONDS, scheduler, 2);</span>

<span class="fc" id="L1267">        TestSubscriber&lt;Integer&gt; ts = new TestSubscriber&lt;Integer&gt;() {</span>
            @Override
            public void onNext(Integer t) {
<span class="fc bfc" id="L1270" title="All 2 branches covered.">                if (t == 1) {</span>
<span class="fc" id="L1271">                    rp.onNext(2);</span>
                }
<span class="fc" id="L1273">                super.onNext(t);</span>
<span class="fc" id="L1274">            }</span>
        };

<span class="fc" id="L1277">        rp.subscribe(ts);</span>

<span class="fc" id="L1279">        rp.onNext(1);</span>
<span class="fc" id="L1280">        rp.onComplete();</span>

<span class="fc" id="L1282">        ts.assertResult(1, 2);</span>
<span class="fc" id="L1283">    }</span>

    @Test
    public void reentrantDrainBackpressured() {
<span class="fc" id="L1287">        TestScheduler scheduler = new TestScheduler();</span>

<span class="fc" id="L1289">        final ReplayProcessor&lt;Integer&gt; rp = ReplayProcessor.createWithTimeAndSize(1, TimeUnit.SECONDS, scheduler, 2);</span>

<span class="fc" id="L1291">        TestSubscriber&lt;Integer&gt; ts = new TestSubscriber&lt;Integer&gt;(1L) {</span>
            @Override
            public void onNext(Integer t) {
<span class="fc bfc" id="L1294" title="All 2 branches covered.">                if (t == 1) {</span>
<span class="fc" id="L1295">                    rp.onNext(2);</span>
                }
<span class="fc" id="L1297">                super.onNext(t);</span>
<span class="fc" id="L1298">            }</span>
        };

<span class="fc" id="L1301">        rp.subscribe(ts);</span>

<span class="fc" id="L1303">        rp.onNext(1);</span>
<span class="fc" id="L1304">        rp.onComplete();</span>

<span class="fc" id="L1306">        ts.request(1);</span>

<span class="fc" id="L1308">        ts.assertResult(1, 2);</span>
<span class="fc" id="L1309">    }</span>

    @Test
    public void timedNoOutdatedData() {
<span class="fc" id="L1313">        TestScheduler scheduler = new TestScheduler();</span>

<span class="fc" id="L1315">        ReplayProcessor&lt;Integer&gt; source = ReplayProcessor.createWithTime(2, TimeUnit.SECONDS, scheduler);</span>
<span class="fc" id="L1316">        source.onNext(1);</span>
<span class="fc" id="L1317">        source.onComplete();</span>

<span class="fc" id="L1319">        source.test().assertResult(1);</span>

<span class="fc" id="L1321">        source.test().assertResult(1);</span>

<span class="fc" id="L1323">        scheduler.advanceTimeBy(3, TimeUnit.SECONDS);</span>

<span class="fc" id="L1325">        source.test().assertResult();</span>
<span class="fc" id="L1326">    }</span>

    @Test
    public void unboundedRequestCompleteRace() {
<span class="fc bfc" id="L1330" title="All 2 branches covered.">        for (int i = 0; i &lt; TestHelper.RACE_LONG_LOOPS; i++) {</span>
<span class="fc" id="L1331">            final ReplayProcessor&lt;Integer&gt; source = ReplayProcessor.create();</span>

<span class="fc" id="L1333">            final TestSubscriber&lt;Integer&gt; ts = source.test(0);</span>

<span class="fc" id="L1335">            Runnable r1 = new Runnable() {</span>
                @Override
                public void run() {
<span class="fc" id="L1338">                    source.onComplete();</span>
<span class="fc" id="L1339">                }</span>
            };

<span class="fc" id="L1342">            Runnable r2 = new Runnable() {</span>
                @Override
                public void run() {
<span class="fc" id="L1345">                    ts.request(1);</span>
<span class="fc" id="L1346">                }</span>
            };

<span class="fc" id="L1349">            TestHelper.race(r1, r2);</span>

<span class="fc" id="L1351">            ts.assertResult();</span>
        }
<span class="fc" id="L1353">    }</span>

    @Test
    public void sizeRequestCompleteRace() {
<span class="fc bfc" id="L1357" title="All 2 branches covered.">        for (int i = 0; i &lt; TestHelper.RACE_LONG_LOOPS; i++) {</span>
<span class="fc" id="L1358">            final ReplayProcessor&lt;Integer&gt; source = ReplayProcessor.createWithSize(10);</span>

<span class="fc" id="L1360">            final TestSubscriber&lt;Integer&gt; ts = source.test(0);</span>

<span class="fc" id="L1362">            Runnable r1 = new Runnable() {</span>
                @Override
                public void run() {
<span class="fc" id="L1365">                    source.onComplete();</span>
<span class="fc" id="L1366">                }</span>
            };

<span class="fc" id="L1369">            Runnable r2 = new Runnable() {</span>
                @Override
                public void run() {
<span class="fc" id="L1372">                    ts.request(1);</span>
<span class="fc" id="L1373">                }</span>
            };

<span class="fc" id="L1376">            TestHelper.race(r1, r2);</span>

<span class="fc" id="L1378">            ts.assertResult();</span>
        }
<span class="fc" id="L1380">    }</span>

    @Test
    public void timedRequestCompleteRace() {
<span class="fc bfc" id="L1384" title="All 2 branches covered.">        for (int i = 0; i &lt; TestHelper.RACE_LONG_LOOPS; i++) {</span>
<span class="fc" id="L1385">            final ReplayProcessor&lt;Integer&gt; source = ReplayProcessor.createWithTime(2, TimeUnit.HOURS, Schedulers.single());</span>

<span class="fc" id="L1387">            final TestSubscriber&lt;Integer&gt; ts = source.test(0);</span>

<span class="fc" id="L1389">            Runnable r1 = new Runnable() {</span>
                @Override
                public void run() {
<span class="fc" id="L1392">                    source.onComplete();</span>
<span class="fc" id="L1393">                }</span>
            };

<span class="fc" id="L1396">            Runnable r2 = new Runnable() {</span>
                @Override
                public void run() {
<span class="fc" id="L1399">                    ts.request(1);</span>
<span class="fc" id="L1400">                }</span>
            };

<span class="fc" id="L1403">            TestHelper.race(r1, r2);</span>

<span class="fc" id="L1405">            ts.assertResult();</span>
        }
<span class="fc" id="L1407">    }</span>

    @Test
    public void timeAndSizeRequestCompleteRace() {
<span class="fc bfc" id="L1411" title="All 2 branches covered.">        for (int i = 0; i &lt; TestHelper.RACE_LONG_LOOPS; i++) {</span>
<span class="fc" id="L1412">            final ReplayProcessor&lt;Integer&gt; source = ReplayProcessor.createWithTimeAndSize(2, TimeUnit.HOURS, Schedulers.single(), 100);</span>

<span class="fc" id="L1414">            final TestSubscriber&lt;Integer&gt; ts = source.test(0);</span>

<span class="fc" id="L1416">            Runnable r1 = new Runnable() {</span>
                @Override
                public void run() {
<span class="fc" id="L1419">                    source.onComplete();</span>
<span class="fc" id="L1420">                }</span>
            };

<span class="fc" id="L1423">            Runnable r2 = new Runnable() {</span>
                @Override
                public void run() {
<span class="fc" id="L1426">                    ts.request(1);</span>
<span class="fc" id="L1427">                }</span>
            };

<span class="fc" id="L1430">            TestHelper.race(r1, r2);</span>

<span class="fc" id="L1432">            ts.assertResult();</span>
        }
<span class="fc" id="L1434">    }</span>

    @Test
    public void unboundedZeroRequestComplete() {
<span class="fc" id="L1438">        final ReplayProcessor&lt;Integer&gt; source = ReplayProcessor.create();</span>

<span class="fc" id="L1440">        source.onComplete();</span>

<span class="fc" id="L1442">        source.test(0).assertResult();</span>
<span class="fc" id="L1443">    }</span>

    @Test
    public void unboundedZeroRequestError() {
<span class="fc" id="L1447">        final ReplayProcessor&lt;Integer&gt; source = ReplayProcessor.create();</span>

<span class="fc" id="L1449">        source.onError(new TestException());</span>

<span class="fc" id="L1451">        source.test(0).assertFailure(TestException.class);</span>
<span class="fc" id="L1452">    }</span>

    @Test
    public void sizeBoundZeroRequestComplete() {
<span class="fc" id="L1456">        final ReplayProcessor&lt;Integer&gt; source = ReplayProcessor.createWithSize(16);</span>

<span class="fc" id="L1458">        source.onComplete();</span>

<span class="fc" id="L1460">        source.test(0).assertResult();</span>
<span class="fc" id="L1461">    }</span>

    @Test
    public void sizeBoundZeroRequestError() {
<span class="fc" id="L1465">        final ReplayProcessor&lt;Integer&gt; source = ReplayProcessor.createWithSize(16);</span>

<span class="fc" id="L1467">        source.onError(new TestException());</span>

<span class="fc" id="L1469">        source.test(0).assertFailure(TestException.class);</span>
<span class="fc" id="L1470">    }</span>

    @Test
    public void timeBoundZeroRequestComplete() {
<span class="fc" id="L1474">        final ReplayProcessor&lt;Integer&gt; source = ReplayProcessor.createWithTime(1, TimeUnit.MINUTES, Schedulers.single());</span>

<span class="fc" id="L1476">        source.onComplete();</span>

<span class="fc" id="L1478">        source.test(0).assertResult();</span>
<span class="fc" id="L1479">    }</span>

    @Test
    public void timeBoundZeroRequestError() {
<span class="fc" id="L1483">        final ReplayProcessor&lt;Integer&gt; source = ReplayProcessor.createWithTime(1, TimeUnit.MINUTES, Schedulers.single());</span>

<span class="fc" id="L1485">        source.onError(new TestException());</span>

<span class="fc" id="L1487">        source.test(0).assertFailure(TestException.class);</span>
<span class="fc" id="L1488">    }</span>

    @Test
    public void timeAndSizeBoundZeroRequestComplete() {
<span class="fc" id="L1492">        final ReplayProcessor&lt;Integer&gt; source = ReplayProcessor.createWithTimeAndSize(1, TimeUnit.MINUTES, Schedulers.single(), 16);</span>

<span class="fc" id="L1494">        source.onComplete();</span>

<span class="fc" id="L1496">        source.test(0).assertResult();</span>
<span class="fc" id="L1497">    }</span>

    @Test
    public void timeAndSizeBoundZeroRequestError() {
<span class="fc" id="L1501">        final ReplayProcessor&lt;Integer&gt; source = ReplayProcessor.createWithTimeAndSize(1, TimeUnit.MINUTES, Schedulers.single(), 16);</span>

<span class="fc" id="L1503">        source.onError(new TestException());</span>

<span class="fc" id="L1505">        source.test(0).assertFailure(TestException.class);</span>
<span class="fc" id="L1506">    }</span>

    TestSubscriber&lt;Integer&gt; take1AndCancel() {
<span class="fc" id="L1509">        return new TestSubscriber&lt;Integer&gt;(1) {</span>
            @Override
            public void onNext(Integer t) {
<span class="fc" id="L1512">                super.onNext(t);</span>
<span class="fc" id="L1513">                cancel();</span>
<span class="fc" id="L1514">                onComplete();</span>
<span class="fc" id="L1515">            }</span>
        };
    }

    @Test
    public void unboundedCancelAfterOne() {
<span class="fc" id="L1521">        ReplayProcessor&lt;Integer&gt; source = ReplayProcessor.create();</span>
<span class="fc" id="L1522">        source.onNext(1);</span>

<span class="fc" id="L1524">        source.subscribeWith(take1AndCancel())</span>
<span class="fc" id="L1525">        .assertResult(1);</span>
<span class="fc" id="L1526">    }</span>

    @Test
    public void sizeBoundCancelAfterOne() {
<span class="fc" id="L1530">        ReplayProcessor&lt;Integer&gt; source = ReplayProcessor.createWithSize(16);</span>
<span class="fc" id="L1531">        source.onNext(1);</span>

<span class="fc" id="L1533">        source.subscribeWith(take1AndCancel())</span>
<span class="fc" id="L1534">        .assertResult(1);</span>
<span class="fc" id="L1535">    }</span>

    @Test
    public void timeBoundCancelAfterOne() {
<span class="fc" id="L1539">        ReplayProcessor&lt;Integer&gt; source = ReplayProcessor.createWithTime(1, TimeUnit.MINUTES, Schedulers.single());</span>
<span class="fc" id="L1540">        source.onNext(1);</span>

<span class="fc" id="L1542">        source.subscribeWith(take1AndCancel())</span>
<span class="fc" id="L1543">        .assertResult(1);</span>
<span class="fc" id="L1544">    }</span>

    @Test
    public void timeAndSizeBoundCancelAfterOne() {
<span class="fc" id="L1548">        ReplayProcessor&lt;Integer&gt; source = ReplayProcessor.createWithTimeAndSize(1, TimeUnit.MINUTES, Schedulers.single(), 16);</span>
<span class="fc" id="L1549">        source.onNext(1);</span>

<span class="fc" id="L1551">        source.subscribeWith(take1AndCancel())</span>
<span class="fc" id="L1552">        .assertResult(1);</span>
<span class="fc" id="L1553">    }</span>

    @Test
    public void noHeadRetentionCompleteSize() {
<span class="fc" id="L1557">        ReplayProcessor&lt;Integer&gt; source = ReplayProcessor.createWithSize(1);</span>

<span class="fc" id="L1559">        source.onNext(1);</span>
<span class="fc" id="L1560">        source.onNext(2);</span>
<span class="fc" id="L1561">        source.onComplete();</span>

<span class="fc" id="L1563">        SizeBoundReplayBuffer&lt;Integer&gt; buf = (SizeBoundReplayBuffer&lt;Integer&gt;)source.buffer;</span>

<span class="fc" id="L1565">        assertNull(buf.head.value);</span>

<span class="fc" id="L1567">        Object o = buf.head;</span>

<span class="fc" id="L1569">        source.cleanupBuffer();</span>

<span class="fc" id="L1571">        assertSame(o, buf.head);</span>
<span class="fc" id="L1572">    }</span>

    @Test
    public void noHeadRetentionErrorSize() {
<span class="fc" id="L1576">        ReplayProcessor&lt;Integer&gt; source = ReplayProcessor.createWithSize(1);</span>

<span class="fc" id="L1578">        source.onNext(1);</span>
<span class="fc" id="L1579">        source.onNext(2);</span>
<span class="fc" id="L1580">        source.onError(new TestException());</span>

<span class="fc" id="L1582">        SizeBoundReplayBuffer&lt;Integer&gt; buf = (SizeBoundReplayBuffer&lt;Integer&gt;)source.buffer;</span>

<span class="fc" id="L1584">        assertNull(buf.head.value);</span>

<span class="fc" id="L1586">        Object o = buf.head;</span>

<span class="fc" id="L1588">        source.cleanupBuffer();</span>

<span class="fc" id="L1590">        assertSame(o, buf.head);</span>
<span class="fc" id="L1591">    }</span>

    @Test
    public void unboundedCleanupBufferNoOp() {
<span class="fc" id="L1595">        ReplayProcessor&lt;Integer&gt; source = ReplayProcessor.create(1);</span>

<span class="fc" id="L1597">        source.onNext(1);</span>
<span class="fc" id="L1598">        source.onNext(2);</span>

<span class="fc" id="L1600">        source.cleanupBuffer();</span>

<span class="fc" id="L1602">        source.test().assertValuesOnly(1, 2);</span>
<span class="fc" id="L1603">    }</span>

    @Test
    public void noHeadRetentionSize() {
<span class="fc" id="L1607">        ReplayProcessor&lt;Integer&gt; source = ReplayProcessor.createWithSize(1);</span>

<span class="fc" id="L1609">        source.onNext(1);</span>
<span class="fc" id="L1610">        source.onNext(2);</span>

<span class="fc" id="L1612">        SizeBoundReplayBuffer&lt;Integer&gt; buf = (SizeBoundReplayBuffer&lt;Integer&gt;)source.buffer;</span>

<span class="fc" id="L1614">        assertNotNull(buf.head.value);</span>

<span class="fc" id="L1616">        source.cleanupBuffer();</span>

<span class="fc" id="L1618">        assertNull(buf.head.value);</span>

<span class="fc" id="L1620">        Object o = buf.head;</span>

<span class="fc" id="L1622">        source.cleanupBuffer();</span>

<span class="fc" id="L1624">        assertSame(o, buf.head);</span>
<span class="fc" id="L1625">    }</span>

    @Test
    public void noHeadRetentionCompleteTime() {
<span class="fc" id="L1629">        ReplayProcessor&lt;Integer&gt; source = ReplayProcessor.createWithTime(1, TimeUnit.MINUTES, Schedulers.computation());</span>

<span class="fc" id="L1631">        source.onNext(1);</span>
<span class="fc" id="L1632">        source.onNext(2);</span>
<span class="fc" id="L1633">        source.onComplete();</span>

<span class="fc" id="L1635">        SizeAndTimeBoundReplayBuffer&lt;Integer&gt; buf = (SizeAndTimeBoundReplayBuffer&lt;Integer&gt;)source.buffer;</span>

<span class="fc" id="L1637">        assertNull(buf.head.value);</span>

<span class="fc" id="L1639">        Object o = buf.head;</span>

<span class="fc" id="L1641">        source.cleanupBuffer();</span>

<span class="fc" id="L1643">        assertSame(o, buf.head);</span>
<span class="fc" id="L1644">    }</span>

    @Test
    public void noHeadRetentionErrorTime() {
<span class="fc" id="L1648">        ReplayProcessor&lt;Integer&gt; source = ReplayProcessor.createWithTime(1, TimeUnit.MINUTES, Schedulers.computation());</span>

<span class="fc" id="L1650">        source.onNext(1);</span>
<span class="fc" id="L1651">        source.onNext(2);</span>
<span class="fc" id="L1652">        source.onError(new TestException());</span>

<span class="fc" id="L1654">        SizeAndTimeBoundReplayBuffer&lt;Integer&gt; buf = (SizeAndTimeBoundReplayBuffer&lt;Integer&gt;)source.buffer;</span>

<span class="fc" id="L1656">        assertNull(buf.head.value);</span>

<span class="fc" id="L1658">        Object o = buf.head;</span>

<span class="fc" id="L1660">        source.cleanupBuffer();</span>

<span class="fc" id="L1662">        assertSame(o, buf.head);</span>
<span class="fc" id="L1663">    }</span>

    @Test
    public void noHeadRetentionTime() {
<span class="fc" id="L1667">        TestScheduler sch = new TestScheduler();</span>

<span class="fc" id="L1669">        ReplayProcessor&lt;Integer&gt; source = ReplayProcessor.createWithTime(1, TimeUnit.MILLISECONDS, sch);</span>

<span class="fc" id="L1671">        source.onNext(1);</span>

<span class="fc" id="L1673">        sch.advanceTimeBy(2, TimeUnit.MILLISECONDS);</span>

<span class="fc" id="L1675">        source.onNext(2);</span>

<span class="fc" id="L1677">        SizeAndTimeBoundReplayBuffer&lt;Integer&gt; buf = (SizeAndTimeBoundReplayBuffer&lt;Integer&gt;)source.buffer;</span>

<span class="fc" id="L1679">        assertNotNull(buf.head.value);</span>

<span class="fc" id="L1681">        source.cleanupBuffer();</span>

<span class="fc" id="L1683">        assertNull(buf.head.value);</span>

<span class="fc" id="L1685">        Object o = buf.head;</span>

<span class="fc" id="L1687">        source.cleanupBuffer();</span>

<span class="fc" id="L1689">        assertSame(o, buf.head);</span>
<span class="fc" id="L1690">    }</span>

    @Test
    public void invalidRequest() {
<span class="fc" id="L1694">        TestHelper.assertBadRequestReported(ReplayProcessor.create());</span>
<span class="fc" id="L1695">    }</span>

    @Test
    public void noBoundedRetentionViaThreadLocal() throws Exception {
<span class="fc" id="L1699">        final ReplayProcessor&lt;byte[]&gt; rp = ReplayProcessor.createWithSize(1);</span>

<span class="fc" id="L1701">        Flowable&lt;byte[]&gt; source = rp.take(1)</span>
<span class="fc" id="L1702">        .concatMap(new Function&lt;byte[], Publisher&lt;byte[]&gt;&gt;() {</span>
            @Override
            public Publisher&lt;byte[]&gt; apply(byte[] v) throws Exception {
<span class="fc" id="L1705">                return rp;</span>
            }
        })
<span class="fc" id="L1708">        .takeLast(1)</span>
        ;

<span class="fc" id="L1711">        System.out.println(&quot;Bounded Replay Leak check: Wait before GC&quot;);</span>
<span class="fc" id="L1712">        Thread.sleep(1000);</span>

<span class="fc" id="L1714">        System.out.println(&quot;Bounded Replay Leak check: GC&quot;);</span>
<span class="fc" id="L1715">        System.gc();</span>

<span class="fc" id="L1717">        Thread.sleep(500);</span>

<span class="fc" id="L1719">        final MemoryMXBean memoryMXBean = ManagementFactory.getMemoryMXBean();</span>
<span class="fc" id="L1720">        MemoryUsage memHeap = memoryMXBean.getHeapMemoryUsage();</span>
<span class="fc" id="L1721">        long initial = memHeap.getUsed();</span>

<span class="fc" id="L1723">        System.out.printf(&quot;Bounded Replay Leak check: Starting: %.3f MB%n&quot;, initial / 1024.0 / 1024.0);</span>

<span class="fc" id="L1725">        final AtomicLong after = new AtomicLong();</span>

<span class="fc" id="L1727">        source.subscribe(new Consumer&lt;byte[]&gt;() {</span>
            @Override
            public void accept(byte[] v) throws Exception {
<span class="fc" id="L1730">                System.out.println(&quot;Bounded Replay Leak check: Wait before GC 2&quot;);</span>
<span class="fc" id="L1731">                Thread.sleep(1000);</span>

<span class="fc" id="L1733">                System.out.println(&quot;Bounded Replay Leak check:  GC 2&quot;);</span>
<span class="fc" id="L1734">                System.gc();</span>

<span class="fc" id="L1736">                Thread.sleep(500);</span>

<span class="fc" id="L1738">                after.set(memoryMXBean.getHeapMemoryUsage().getUsed());</span>
<span class="fc" id="L1739">            }</span>
        });

<span class="fc bfc" id="L1742" title="All 2 branches covered.">        for (int i = 0; i &lt; 200; i++) {</span>
<span class="fc" id="L1743">            rp.onNext(new byte[1024 * 1024]);</span>
        }
<span class="fc" id="L1745">        rp.onComplete();</span>

<span class="fc" id="L1747">        System.out.printf(&quot;Bounded Replay Leak check: After: %.3f MB%n&quot;, after.get() / 1024.0 / 1024.0);</span>

<span class="pc bpc" id="L1749" title="1 of 2 branches missed.">        if (initial + 100 * 1024 * 1024 &lt; after.get()) {</span>
<span class="nc" id="L1750">            Assert.fail(&quot;Bounded Replay Leak check: Memory leak detected: &quot; + (initial / 1024.0 / 1024.0)</span>
<span class="nc" id="L1751">                    + &quot; -&gt; &quot; + after.get() / 1024.0 / 1024.0);</span>
        }
<span class="fc" id="L1753">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>