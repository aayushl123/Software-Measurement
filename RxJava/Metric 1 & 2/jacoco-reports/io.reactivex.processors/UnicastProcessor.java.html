<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>UnicastProcessor.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">RxJava_2_x$Unnamed.exec</a> &gt; <a href="index.source.html" class="el_package">io.reactivex.processors</a> &gt; <span class="el_source">UnicastProcessor.java</span></div><h1>UnicastProcessor.java</h1><pre class="source lang-java linenums">/**
 * Copyright (c) 2016-present, RxJava Contributors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is
 * distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
 * the License for the specific language governing permissions and limitations under the License.
 */

package io.reactivex.processors;

import io.reactivex.annotations.CheckReturnValue;
import java.util.concurrent.atomic.*;

import io.reactivex.annotations.Nullable;
import io.reactivex.annotations.NonNull;
import org.reactivestreams.*;

import io.reactivex.internal.functions.ObjectHelper;
import io.reactivex.internal.fuseable.QueueSubscription;
import io.reactivex.internal.queue.SpscLinkedArrayQueue;
import io.reactivex.internal.subscriptions.*;
import io.reactivex.internal.util.BackpressureHelper;
import io.reactivex.plugins.RxJavaPlugins;

/**
 * A {@link FlowableProcessor} variant that queues up events until a single {@link Subscriber} subscribes to it, replays
 * those events to it until the {@code Subscriber} catches up and then switches to relaying events live to
 * this single {@code Subscriber} until this {@code UnicastProcessor} terminates or the {@code Subscriber} cancels
 * its subscription.
 * &lt;p&gt;
 * &lt;img width=&quot;640&quot; height=&quot;370&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/UnicastProcessor.png&quot; alt=&quot;&quot;&gt;
 * &lt;p&gt;
 * This processor does not have a public constructor by design; a new empty instance of this
 * {@code UnicastProcessor} can be created via the following {@code create} methods that
 * allow specifying the retention policy for items:
 * &lt;ul&gt;
 * &lt;li&gt;{@link #create()} - creates an empty, unbounded {@code UnicastProcessor} that
 *     caches all items and the terminal event it receives.&lt;/li&gt;
 * &lt;li&gt;{@link #create(int)} - creates an empty, unbounded {@code UnicastProcessor}
 *     with a hint about how many &lt;b&gt;total&lt;/b&gt; items one expects to retain.&lt;/li&gt;
 * &lt;li&gt;{@link #create(boolean)} - creates an empty, unbounded {@code UnicastProcessor} that
 *     optionally delays an error it receives and replays it after the regular items have been emitted.&lt;/li&gt;
 * &lt;li&gt;{@link #create(int, Runnable)} - creates an empty, unbounded {@code UnicastProcessor}
 *     with a hint about how many &lt;b&gt;total&lt;/b&gt; items one expects to retain and a callback that will be
 *     called exactly once when the {@code UnicastProcessor} gets terminated or the single {@code Subscriber} cancels.&lt;/li&gt;
 * &lt;li&gt;{@link #create(int, Runnable, boolean)} - creates an empty, unbounded {@code UnicastProcessor}
 *     with a hint about how many &lt;b&gt;total&lt;/b&gt; items one expects to retain and a callback that will be
 *     called exactly once when the {@code UnicastProcessor} gets terminated or the single {@code Subscriber} cancels
 *     and optionally delays an error it receives and replays it after the regular items have been emitted.&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;p&gt;
 * If more than one {@code Subscriber} attempts to subscribe to this Processor, they
 * will receive an {@link IllegalStateException} if this {@link UnicastProcessor} hasn't terminated yet,
 * or the Subscribers receive the terminal event (error or completion) if this
 * Processor has terminated.
 * &lt;p&gt;
 * The {@code UnicastProcessor} buffers notifications and replays them to the single {@code Subscriber} as requested,
 * for which it holds upstream items an unbounded internal buffer until they can be emitted.
 * &lt;p&gt;
 * Since a {@code UnicastProcessor} is a Reactive Streams {@code Processor},
 * {@code null}s are not allowed (&lt;a href=&quot;https://github.com/reactive-streams/reactive-streams-jvm#2.13&quot;&gt;Rule 2.13&lt;/a&gt;) as
 * parameters to {@link #onNext(Object)} and {@link #onError(Throwable)}. Such calls will result in a
 * {@link NullPointerException} being thrown and the processor's state is not changed.
 * &lt;p&gt;
 * Since a {@code UnicastProcessor} is a {@link io.reactivex.Flowable} as well as a {@link FlowableProcessor}, it
 * honors the downstream backpressure but consumes an upstream source in an unbounded manner (requesting {@code Long.MAX_VALUE}).
 * &lt;p&gt;
 * When this {@code UnicastProcessor} is terminated via {@link #onError(Throwable)} the current or late single {@code Subscriber}
 * may receive the {@code Throwable} before any available items could be emitted. To make sure an {@code onError} event is delivered
 * to the {@code Subscriber} after the normal items, create a {@code UnicastProcessor} with the {@link #create(boolean)} or
 * {@link #create(int, Runnable, boolean)} factory methods.
 * &lt;p&gt;
 * Even though {@code UnicastProcessor} implements the {@code Subscriber} interface, calling
 * {@code onSubscribe} is not required (&lt;a href=&quot;https://github.com/reactive-streams/reactive-streams-jvm#2.12&quot;&gt;Rule 2.12&lt;/a&gt;)
 * if the processor is used as a standalone source. However, calling {@code onSubscribe}
 * after the {@code UnicastProcessor} reached its terminal state will result in the
 * given {@code Subscription} being canceled immediately.
 * &lt;p&gt;
 * Calling {@link #onNext(Object)}, {@link #onError(Throwable)} and {@link #onComplete()}
 * is required to be serialized (called from the same thread or called non-overlappingly from different threads
 * through external means of serialization). The {@link #toSerialized()} method available to all {@link FlowableProcessor}s
 * provides such serialization and also protects against reentrance (i.e., when a downstream {@code Subscriber}
 * consuming this processor also wants to call {@link #onNext(Object)} on this processor recursively).
 * &lt;p&gt;
 * This {@code UnicastProcessor} supports the standard state-peeking methods {@link #hasComplete()}, {@link #hasThrowable()},
 * {@link #getThrowable()} and {@link #hasSubscribers()}.
 * &lt;dl&gt;
 *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
 *  &lt;dd&gt;{@code UnicastProcessor} honors the downstream backpressure but consumes an upstream source
 *  (if any) in an unbounded manner (requesting {@code Long.MAX_VALUE}).&lt;/dd&gt;
 *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
 *  &lt;dd&gt;{@code UnicastProcessor} does not operate by default on a particular {@link io.reactivex.Scheduler} and
 *  the single {@code Subscriber} gets notified on the thread the respective {@code onXXX} methods were invoked.&lt;/dd&gt;
 *  &lt;dt&gt;&lt;b&gt;Error handling:&lt;/b&gt;&lt;/dt&gt;
 *  &lt;dd&gt;When the {@link #onError(Throwable)} is called, the {@code UnicastProcessor} enters into a terminal state
 *  and emits the same {@code Throwable} instance to the current single {@code Subscriber}. During this emission,
 *  if the single {@code Subscriber}s cancels its respective {@code Subscription}s, the
 *  {@code Throwable} is delivered to the global error handler via
 *  {@link io.reactivex.plugins.RxJavaPlugins#onError(Throwable)}.
 *  If there were no {@code Subscriber}s subscribed to this {@code UnicastProcessor} when the {@code onError()}
 *  was called, the global error handler is not invoked.
 *  &lt;/dd&gt;
 * &lt;/dl&gt;
 * &lt;p&gt;
 * Example usage:
 * &lt;pre&gt;&lt;code&gt;
 * UnicastProcessor&amp;lt;Integer&amp;gt; processor = UnicastProcessor.create();
 *
 * TestSubscriber&amp;lt;Integer&amp;gt; ts1 = processor.test();
 *
 * // fresh UnicastProcessors are empty
 * ts1.assertEmpty();
 *
 * TestSubscriber&amp;lt;Integer&amp;gt; ts2 = processor.test();
 *
 * // A UnicastProcessor only allows one Subscriber during its lifetime
 * ts2.assertFailure(IllegalStateException.class);
 *
 * processor.onNext(1);
 * ts1.assertValue(1);
 *
 * processor.onNext(2);
 * ts1.assertValues(1, 2);
 *
 * processor.onComplete();
 * ts1.assertResult(1, 2);
 *
 * // ----------------------------------------------------
 *
 * UnicastProcessor&amp;lt;Integer&amp;gt; processor2 = UnicastProcessor.create();
 *
 * // a UnicastProcessor caches events until its single Subscriber subscribes
 * processor2.onNext(1);
 * processor2.onNext(2);
 * processor2.onComplete();
 *
 * TestSubscriber&amp;lt;Integer&amp;gt; ts3 = processor2.test();
 *
 * // the cached events are emitted in order
 * ts3.assertResult(1, 2);
 * &lt;/code&gt;&lt;/pre&gt;
 *
 * @param &lt;T&gt; the value type received and emitted by this Processor subclass
 * @since 2.0
 */
public final class UnicastProcessor&lt;T&gt; extends FlowableProcessor&lt;T&gt; {

    final SpscLinkedArrayQueue&lt;T&gt; queue;

    final AtomicReference&lt;Runnable&gt; onTerminate;

    final boolean delayError;

    volatile boolean done;

    Throwable error;

    final AtomicReference&lt;Subscriber&lt;? super T&gt;&gt; downstream;

    volatile boolean cancelled;

    final AtomicBoolean once;

    final BasicIntQueueSubscription&lt;T&gt; wip;

    final AtomicLong requested;

    boolean enableOperatorFusion;

    /**
     * Creates an UnicastSubject with an internal buffer capacity hint 16.
     * @param &lt;T&gt; the value type
     * @return an UnicastSubject instance
     */
    @CheckReturnValue
    @NonNull
    public static &lt;T&gt; UnicastProcessor&lt;T&gt; create() {
<span class="fc" id="L183">        return new UnicastProcessor&lt;T&gt;(bufferSize());</span>
    }

    /**
     * Creates an UnicastProcessor with the given internal buffer capacity hint.
     * @param &lt;T&gt; the value type
     * @param capacityHint the hint to size the internal unbounded buffer
     * @return an UnicastProcessor instance
     */
    @CheckReturnValue
    @NonNull
    public static &lt;T&gt; UnicastProcessor&lt;T&gt; create(int capacityHint) {
<span class="fc" id="L195">        return new UnicastProcessor&lt;T&gt;(capacityHint);</span>
    }

    /**
     * Creates an UnicastProcessor with default internal buffer capacity hint and delay error flag.
     * &lt;p&gt;History: 2.0.8 - experimental
     * @param &lt;T&gt; the value type
     * @param delayError deliver pending onNext events before onError
     * @return an UnicastProcessor instance
     * @since 2.2
     */
    @CheckReturnValue
    @NonNull
    public static &lt;T&gt; UnicastProcessor&lt;T&gt; create(boolean delayError) {
<span class="fc" id="L209">        return new UnicastProcessor&lt;T&gt;(bufferSize(), null, delayError);</span>
    }

    /**
     * Creates an UnicastProcessor with the given internal buffer capacity hint and a callback for
     * the case when the single Subscriber cancels its subscription.
     *
     * &lt;p&gt;The callback, if not null, is called exactly once and
     * non-overlapped with any active replay.
     *
     * @param &lt;T&gt; the value type
     * @param capacityHint the hint to size the internal unbounded buffer
     * @param onCancelled the non null callback
     * @return an UnicastProcessor instance
     */
    @CheckReturnValue
    @NonNull
    public static &lt;T&gt; UnicastProcessor&lt;T&gt; create(int capacityHint, Runnable onCancelled) {
<span class="fc" id="L227">        ObjectHelper.requireNonNull(onCancelled, &quot;onTerminate&quot;);</span>
<span class="fc" id="L228">        return new UnicastProcessor&lt;T&gt;(capacityHint, onCancelled);</span>
    }

    /**
     * Creates an UnicastProcessor with the given internal buffer capacity hint, delay error flag and a callback for
     * the case when the single Subscriber cancels its subscription.
     *
     * &lt;p&gt;The callback, if not null, is called exactly once and
     * non-overlapped with any active replay.
     * &lt;p&gt;History: 2.0.8 - experimental
     * @param &lt;T&gt; the value type
     * @param capacityHint the hint to size the internal unbounded buffer
     * @param onCancelled the non null callback
     * @param delayError deliver pending onNext events before onError
     * @return an UnicastProcessor instance
     * @since 2.2
     */
    @CheckReturnValue
    @NonNull
    public static &lt;T&gt; UnicastProcessor&lt;T&gt; create(int capacityHint, Runnable onCancelled, boolean delayError) {
<span class="fc" id="L248">        ObjectHelper.requireNonNull(onCancelled, &quot;onTerminate&quot;);</span>
<span class="fc" id="L249">        return new UnicastProcessor&lt;T&gt;(capacityHint, onCancelled, delayError);</span>
    }

    /**
     * Creates an UnicastProcessor with the given capacity hint.
     * @param capacityHint the capacity hint for the internal, unbounded queue
     * @since 2.0
     */
    UnicastProcessor(int capacityHint) {
<span class="fc" id="L258">        this(capacityHint, null, true);</span>
<span class="fc" id="L259">    }</span>

    /**
     * Creates an UnicastProcessor with the given capacity hint and callback
     * for when the Processor is terminated normally or its single Subscriber cancels.
     * @param capacityHint the capacity hint for the internal, unbounded queue
     * @param onTerminate the callback to run when the Processor is terminated or cancelled, null not allowed
     * @since 2.0
     */
    UnicastProcessor(int capacityHint, Runnable onTerminate) {
<span class="fc" id="L269">        this(capacityHint, onTerminate, true);</span>
<span class="fc" id="L270">    }</span>

    /**
     * Creates an UnicastProcessor with the given capacity hint and callback
     * for when the Processor is terminated normally or its single Subscriber cancels.
     * &lt;p&gt;History: 2.0.8 - experimental
     * @param capacityHint the capacity hint for the internal, unbounded queue
     * @param onTerminate the callback to run when the Processor is terminated or cancelled, null not allowed
     * @param delayError deliver pending onNext events before onError
     * @since 2.2
     */
<span class="fc" id="L281">    UnicastProcessor(int capacityHint, Runnable onTerminate, boolean delayError) {</span>
<span class="fc" id="L282">        this.queue = new SpscLinkedArrayQueue&lt;T&gt;(ObjectHelper.verifyPositive(capacityHint, &quot;capacityHint&quot;));</span>
<span class="fc" id="L283">        this.onTerminate = new AtomicReference&lt;Runnable&gt;(onTerminate);</span>
<span class="fc" id="L284">        this.delayError = delayError;</span>
<span class="fc" id="L285">        this.downstream = new AtomicReference&lt;Subscriber&lt;? super T&gt;&gt;();</span>
<span class="fc" id="L286">        this.once = new AtomicBoolean();</span>
<span class="fc" id="L287">        this.wip = new UnicastQueueSubscription();</span>
<span class="fc" id="L288">        this.requested = new AtomicLong();</span>
<span class="fc" id="L289">    }</span>

    void doTerminate() {
<span class="fc" id="L292">        Runnable r = onTerminate.getAndSet(null);</span>
<span class="fc bfc" id="L293" title="All 2 branches covered.">        if (r != null) {</span>
<span class="fc" id="L294">            r.run();</span>
        }
<span class="fc" id="L296">    }</span>

    void drainRegular(Subscriber&lt;? super T&gt; a) {
<span class="fc" id="L299">        int missed = 1;</span>

<span class="fc" id="L301">        final SpscLinkedArrayQueue&lt;T&gt; q = queue;</span>
<span class="fc bfc" id="L302" title="All 2 branches covered.">        final boolean failFast = !delayError;</span>
        for (;;) {

<span class="fc" id="L305">            long r = requested.get();</span>
<span class="fc" id="L306">            long e = 0L;</span>

<span class="fc bfc" id="L308" title="All 2 branches covered.">            while (r != e) {</span>
<span class="fc" id="L309">                boolean d = done;</span>

<span class="fc" id="L311">                T t = q.poll();</span>
<span class="fc bfc" id="L312" title="All 2 branches covered.">                boolean empty = t == null;</span>

<span class="fc bfc" id="L314" title="All 2 branches covered.">                if (checkTerminated(failFast, d, empty, a, q)) {</span>
<span class="fc" id="L315">                    return;</span>
                }

<span class="fc bfc" id="L318" title="All 2 branches covered.">                if (empty) {</span>
<span class="fc" id="L319">                    break;</span>
                }

<span class="fc" id="L322">                a.onNext(t);</span>

<span class="fc" id="L324">                e++;</span>
<span class="fc" id="L325">            }</span>

<span class="fc bfc" id="L327" title="All 4 branches covered.">            if (r == e &amp;&amp; checkTerminated(failFast, done, q.isEmpty(), a, q)) {</span>
<span class="fc" id="L328">                return;</span>
            }

<span class="fc bfc" id="L331" title="All 4 branches covered.">            if (e != 0 &amp;&amp; r != Long.MAX_VALUE) {</span>
<span class="fc" id="L332">                requested.addAndGet(-e);</span>
            }

<span class="fc" id="L335">            missed = wip.addAndGet(-missed);</span>
<span class="fc bfc" id="L336" title="All 2 branches covered.">            if (missed == 0) {</span>
<span class="fc" id="L337">                break;</span>
            }
<span class="fc" id="L339">        }</span>
<span class="fc" id="L340">    }</span>

    void drainFused(Subscriber&lt;? super T&gt; a) {
<span class="fc" id="L343">        int missed = 1;</span>

<span class="fc" id="L345">        final SpscLinkedArrayQueue&lt;T&gt; q = queue;</span>
<span class="fc bfc" id="L346" title="All 2 branches covered.">        final boolean failFast = !delayError;</span>
        for (;;) {

<span class="fc bfc" id="L349" title="All 2 branches covered.">            if (cancelled) {</span>
<span class="fc" id="L350">                q.clear();</span>
<span class="fc" id="L351">                downstream.lazySet(null);</span>
<span class="fc" id="L352">                return;</span>
            }

<span class="fc" id="L355">            boolean d = done;</span>

<span class="fc bfc" id="L357" title="All 6 branches covered.">            if (failFast &amp;&amp; d &amp;&amp; error != null) {</span>
<span class="fc" id="L358">                q.clear();</span>
<span class="fc" id="L359">                downstream.lazySet(null);</span>
<span class="fc" id="L360">                a.onError(error);</span>
<span class="fc" id="L361">                return;</span>
            }
<span class="fc" id="L363">            a.onNext(null);</span>

<span class="fc bfc" id="L365" title="All 2 branches covered.">            if (d) {</span>
<span class="fc" id="L366">                downstream.lazySet(null);</span>

<span class="fc" id="L368">                Throwable ex = error;</span>
<span class="fc bfc" id="L369" title="All 2 branches covered.">                if (ex != null) {</span>
<span class="fc" id="L370">                    a.onError(ex);</span>
                } else {
<span class="fc" id="L372">                    a.onComplete();</span>
                }
<span class="fc" id="L374">                return;</span>
            }

<span class="fc" id="L377">            missed = wip.addAndGet(-missed);</span>
<span class="fc bfc" id="L378" title="All 2 branches covered.">            if (missed == 0) {</span>
<span class="fc" id="L379">                break;</span>
            }
<span class="fc" id="L381">        }</span>
<span class="fc" id="L382">    }</span>

    void drain() {
<span class="fc bfc" id="L385" title="All 2 branches covered.">        if (wip.getAndIncrement() != 0) {</span>
<span class="fc" id="L386">            return;</span>
        }

<span class="fc" id="L389">        int missed = 1;</span>

<span class="fc" id="L391">        Subscriber&lt;? super T&gt; a = downstream.get();</span>
        for (;;) {
<span class="fc bfc" id="L393" title="All 2 branches covered.">            if (a != null) {</span>

<span class="fc bfc" id="L395" title="All 2 branches covered.">                if (enableOperatorFusion) {</span>
<span class="fc" id="L396">                    drainFused(a);</span>
                } else {
<span class="fc" id="L398">                    drainRegular(a);</span>
                }
<span class="fc" id="L400">                return;</span>
            }

<span class="fc" id="L403">            missed = wip.addAndGet(-missed);</span>
<span class="fc bfc" id="L404" title="All 2 branches covered.">            if (missed == 0) {</span>
<span class="fc" id="L405">                break;</span>
            }
<span class="fc" id="L407">            a = downstream.get();</span>
        }
<span class="fc" id="L409">    }</span>

    boolean checkTerminated(boolean failFast, boolean d, boolean empty, Subscriber&lt;? super T&gt; a, SpscLinkedArrayQueue&lt;T&gt; q) {
<span class="fc bfc" id="L412" title="All 2 branches covered.">        if (cancelled) {</span>
<span class="fc" id="L413">            q.clear();</span>
<span class="fc" id="L414">            downstream.lazySet(null);</span>
<span class="fc" id="L415">            return true;</span>
        }

<span class="fc bfc" id="L418" title="All 2 branches covered.">        if (d) {</span>
<span class="fc bfc" id="L419" title="All 4 branches covered.">            if (failFast &amp;&amp; error != null) {</span>
<span class="fc" id="L420">                q.clear();</span>
<span class="fc" id="L421">                downstream.lazySet(null);</span>
<span class="fc" id="L422">                a.onError(error);</span>
<span class="fc" id="L423">                return true;</span>
            }
<span class="fc bfc" id="L425" title="All 2 branches covered.">            if (empty) {</span>
<span class="fc" id="L426">                Throwable e = error;</span>
<span class="fc" id="L427">                downstream.lazySet(null);</span>
<span class="fc bfc" id="L428" title="All 2 branches covered.">                if (e != null) {</span>
<span class="fc" id="L429">                    a.onError(e);</span>
                } else {
<span class="fc" id="L431">                    a.onComplete();</span>
                }
<span class="fc" id="L433">                return true;</span>
            }
        }

<span class="fc" id="L437">        return false;</span>
    }

    @Override
    public void onSubscribe(Subscription s) {
<span class="fc bfc" id="L442" title="All 4 branches covered.">        if (done || cancelled) {</span>
<span class="fc" id="L443">            s.cancel();</span>
        } else {
<span class="fc" id="L445">            s.request(Long.MAX_VALUE);</span>
        }
<span class="fc" id="L447">    }</span>

    @Override
    public void onNext(T t) {
<span class="fc" id="L451">        ObjectHelper.requireNonNull(t, &quot;onNext called with null. Null values are generally not allowed in 2.x operators and sources.&quot;);</span>

<span class="fc bfc" id="L453" title="All 4 branches covered.">        if (done || cancelled) {</span>
<span class="fc" id="L454">            return;</span>
        }

<span class="fc" id="L457">        queue.offer(t);</span>
<span class="fc" id="L458">        drain();</span>
<span class="fc" id="L459">    }</span>

    @Override
    public void onError(Throwable t) {
<span class="fc" id="L463">        ObjectHelper.requireNonNull(t, &quot;onError called with null. Null values are generally not allowed in 2.x operators and sources.&quot;);</span>

<span class="fc bfc" id="L465" title="All 4 branches covered.">        if (done || cancelled) {</span>
<span class="fc" id="L466">            RxJavaPlugins.onError(t);</span>
<span class="fc" id="L467">            return;</span>
        }

<span class="fc" id="L470">        error = t;</span>
<span class="fc" id="L471">        done = true;</span>

<span class="fc" id="L473">        doTerminate();</span>

<span class="fc" id="L475">        drain();</span>
<span class="fc" id="L476">    }</span>

    @Override
    public void onComplete() {
<span class="fc bfc" id="L480" title="All 4 branches covered.">        if (done || cancelled) {</span>
<span class="fc" id="L481">            return;</span>
        }

<span class="fc" id="L484">        done = true;</span>

<span class="fc" id="L486">        doTerminate();</span>

<span class="fc" id="L488">        drain();</span>
<span class="fc" id="L489">    }</span>

    @Override
    protected void subscribeActual(Subscriber&lt;? super T&gt; s) {
<span class="fc bfc" id="L493" title="All 4 branches covered.">        if (!once.get() &amp;&amp; once.compareAndSet(false, true)) {</span>

<span class="fc" id="L495">            s.onSubscribe(wip);</span>
<span class="fc" id="L496">            downstream.set(s);</span>
<span class="fc bfc" id="L497" title="All 2 branches covered.">            if (cancelled) {</span>
<span class="fc" id="L498">                downstream.lazySet(null);</span>
            } else {
<span class="fc" id="L500">                drain();</span>
            }
        } else {
<span class="fc" id="L503">            EmptySubscription.error(new IllegalStateException(&quot;This processor allows only a single Subscriber&quot;), s);</span>
        }
<span class="fc" id="L505">    }</span>

<span class="fc" id="L507">    final class UnicastQueueSubscription extends BasicIntQueueSubscription&lt;T&gt; {</span>

        private static final long serialVersionUID = -4896760517184205454L;

        @Nullable
        @Override
        public T poll() {
<span class="fc" id="L514">            return queue.poll();</span>
        }

        @Override
        public boolean isEmpty() {
<span class="fc" id="L519">            return queue.isEmpty();</span>
        }

        @Override
        public void clear() {
<span class="fc" id="L524">            queue.clear();</span>
<span class="fc" id="L525">        }</span>

        @Override
        public int requestFusion(int requestedMode) {
<span class="fc bfc" id="L529" title="All 2 branches covered.">            if ((requestedMode &amp; QueueSubscription.ASYNC) != 0) {</span>
<span class="fc" id="L530">                enableOperatorFusion = true;</span>
<span class="fc" id="L531">                return QueueSubscription.ASYNC;</span>
            }
<span class="fc" id="L533">            return QueueSubscription.NONE;</span>
        }

        @Override
        public void request(long n) {
<span class="fc bfc" id="L538" title="All 2 branches covered.">            if (SubscriptionHelper.validate(n)) {</span>
<span class="fc" id="L539">                BackpressureHelper.add(requested, n);</span>
<span class="fc" id="L540">                drain();</span>
            }
<span class="fc" id="L542">        }</span>

        @Override
        public void cancel() {
<span class="fc bfc" id="L546" title="All 2 branches covered.">            if (cancelled) {</span>
<span class="fc" id="L547">                return;</span>
            }
<span class="fc" id="L549">            cancelled = true;</span>

<span class="fc" id="L551">            doTerminate();</span>

<span class="fc bfc" id="L553" title="All 2 branches covered.">            if (!enableOperatorFusion) {</span>
<span class="fc bfc" id="L554" title="All 2 branches covered.">                if (wip.getAndIncrement() == 0) {</span>
<span class="fc" id="L555">                    queue.clear();</span>
<span class="fc" id="L556">                    downstream.lazySet(null);</span>
                }
            }
<span class="fc" id="L559">        }</span>
    }

    @Override
    public boolean hasSubscribers() {
<span class="fc bfc" id="L564" title="All 2 branches covered.">        return downstream.get() != null;</span>
    }

    @Override
    @Nullable
    public Throwable getThrowable() {
<span class="fc bfc" id="L570" title="All 2 branches covered.">        if (done) {</span>
<span class="fc" id="L571">            return error;</span>
        }
<span class="fc" id="L573">        return null;</span>
    }

    @Override
    public boolean hasComplete() {
<span class="fc bfc" id="L578" title="All 4 branches covered.">        return done &amp;&amp; error == null;</span>
    }

    @Override
    public boolean hasThrowable() {
<span class="fc bfc" id="L583" title="All 4 branches covered.">        return done &amp;&amp; error != null;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>