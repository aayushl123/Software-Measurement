<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Schedulers.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">RxJava_2_x$Unnamed.exec</a> &gt; <a href="index.source.html" class="el_package">io.reactivex.schedulers</a> &gt; <span class="el_source">Schedulers.java</span></div><h1>Schedulers.java</h1><pre class="source lang-java linenums">/**
 * Copyright (c) 2016-present, RxJava Contributors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is
 * distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
 * the License for the specific language governing permissions and limitations under the License.
 */

package io.reactivex.schedulers;

import java.util.concurrent.*;

import io.reactivex.Scheduler;
import io.reactivex.annotations.*;
import io.reactivex.internal.schedulers.*;
import io.reactivex.plugins.RxJavaPlugins;

/**
 * Static factory methods for returning standard Scheduler instances.
 * &lt;p&gt;
 * The initial and runtime values of the various scheduler types can be overridden via the
 * {@code RxJavaPlugins.setInit(scheduler name)SchedulerHandler()} and
 * {@code RxJavaPlugins.set(scheduler name)SchedulerHandler()} respectively.
 * &lt;p&gt;
 * &lt;strong&gt;Supported system properties ({@code System.getProperty()}):&lt;/strong&gt;
 * &lt;ul&gt;
 * &lt;li&gt;{@code rx2.io-keep-alive-time} (long): sets the keep-alive time of the {@link #io()} Scheduler workers, default is {@link IoScheduler#KEEP_ALIVE_TIME_DEFAULT}&lt;/li&gt;
 * &lt;li&gt;{@code rx2.io-priority} (int): sets the thread priority of the {@link #io()} Scheduler, default is {@link Thread#NORM_PRIORITY}&lt;/li&gt;
 * &lt;li&gt;{@code rx2.computation-threads} (int): sets the number of threads in the {@link #computation()} Scheduler, default is the number of available CPUs&lt;/li&gt;
 * &lt;li&gt;{@code rx2.computation-priority} (int): sets the thread priority of the {@link #computation()} Scheduler, default is {@link Thread#NORM_PRIORITY}&lt;/li&gt;
 * &lt;li&gt;{@code rx2.newthread-priority} (int): sets the thread priority of the {@link #newThread()} Scheduler, default is {@link Thread#NORM_PRIORITY}&lt;/li&gt;
 * &lt;li&gt;{@code rx2.single-priority} (int): sets the thread priority of the {@link #single()} Scheduler, default is {@link Thread#NORM_PRIORITY}&lt;/li&gt;
 * &lt;li&gt;{@code rx2.purge-enabled} (boolean): enables periodic purging of all Scheduler's backing thread pools, default is false&lt;/li&gt;
 * &lt;li&gt;{@code rx2.purge-period-seconds} (int): specifies the periodic purge interval of all Scheduler's backing thread pools, default is 1 second&lt;/li&gt;
 * &lt;/ul&gt;
 */
public final class Schedulers {
    @NonNull
    static final Scheduler SINGLE;

    @NonNull
    static final Scheduler COMPUTATION;

    @NonNull
    static final Scheduler IO;

    @NonNull
    static final Scheduler TRAMPOLINE;

    @NonNull
    static final Scheduler NEW_THREAD;

<span class="fc" id="L58">    static final class SingleHolder {</span>
<span class="fc" id="L59">        static final Scheduler DEFAULT = new SingleScheduler();</span>
    }

<span class="fc" id="L62">    static final class ComputationHolder {</span>
<span class="fc" id="L63">        static final Scheduler DEFAULT = new ComputationScheduler();</span>
    }

<span class="fc" id="L66">    static final class IoHolder {</span>
<span class="fc" id="L67">        static final Scheduler DEFAULT = new IoScheduler();</span>
    }

<span class="fc" id="L70">    static final class NewThreadHolder {</span>
<span class="fc" id="L71">        static final Scheduler DEFAULT = new NewThreadScheduler();</span>
    }

    static {
<span class="fc" id="L75">        SINGLE = RxJavaPlugins.initSingleScheduler(new SingleTask());</span>

<span class="fc" id="L77">        COMPUTATION = RxJavaPlugins.initComputationScheduler(new ComputationTask());</span>

<span class="fc" id="L79">        IO = RxJavaPlugins.initIoScheduler(new IOTask());</span>

<span class="fc" id="L81">        TRAMPOLINE = TrampolineScheduler.instance();</span>

<span class="fc" id="L83">        NEW_THREAD = RxJavaPlugins.initNewThreadScheduler(new NewThreadTask());</span>
<span class="fc" id="L84">    }</span>

    /** Utility class. */
<span class="fc" id="L87">    private Schedulers() {</span>
<span class="fc" id="L88">        throw new IllegalStateException(&quot;No instances!&quot;);</span>
    }

    /**
     * Returns a default, shared {@link Scheduler} instance intended for computational work.
     * &lt;p&gt;
     * This can be used for event-loops, processing callbacks and other computational work.
     * &lt;p&gt;
     * It is not recommended to perform blocking, IO-bound work on this scheduler. Use {@link #io()} instead.
     * &lt;p&gt;
     * The default instance has a backing pool of single-threaded {@link ScheduledExecutorService} instances equal to
     * the number of available processors ({@link java.lang.Runtime#availableProcessors()}) to the Java VM.
     * &lt;p&gt;
     * Unhandled errors will be delivered to the scheduler Thread's {@link java.lang.Thread.UncaughtExceptionHandler}.
     * &lt;p&gt;
     * This type of scheduler is less sensitive to leaking {@link io.reactivex.Scheduler.Worker} instances, although
     * not disposing a worker that has timed/delayed tasks not cancelled by other means may leak resources and/or
     * execute those tasks &quot;unexpectedly&quot;.
     * &lt;p&gt;
     * If the {@link RxJavaPlugins#setFailOnNonBlockingScheduler(boolean)} is set to true, attempting to execute
     * operators that block while running on this scheduler will throw an {@link IllegalStateException}.
     * &lt;p&gt;
     * You can control certain properties of this standard scheduler via system properties that have to be set
     * before the {@link Schedulers} class is referenced in your code.
     * &lt;p&gt;&lt;strong&gt;Supported system properties ({@code System.getProperty()}):&lt;/strong&gt;
     * &lt;ul&gt;
     * &lt;li&gt;{@code rx2.computation-threads} (int): sets the number of threads in the {@link #computation()} Scheduler, default is the number of available CPUs&lt;/li&gt;
     * &lt;li&gt;{@code rx2.computation-priority} (int): sets the thread priority of the {@link #computation()} Scheduler, default is {@link Thread#NORM_PRIORITY}&lt;/li&gt;
     * &lt;/ul&gt;
     * &lt;p&gt;
     * The default value of this scheduler can be overridden at initialization time via the
     * {@link RxJavaPlugins#setInitComputationSchedulerHandler(io.reactivex.functions.Function)} plugin method.
     * Note that due to possible initialization cycles, using any of the other scheduler-returning methods will
     * result in a {@code NullPointerException}.
     * Once the {@link Schedulers} class has been initialized, you can override the returned {@link Scheduler} instance
     * via the {@link RxJavaPlugins#setComputationSchedulerHandler(io.reactivex.functions.Function)} method.
     * &lt;p&gt;
     * It is possible to create a fresh instance of this scheduler with a custom ThreadFactory, via the
     * {@link RxJavaPlugins#createComputationScheduler(ThreadFactory)} method. Note that such custom
     * instances require a manual call to {@link Scheduler#shutdown()} to allow the JVM to exit or the
     * (J2EE) container to unload properly.
     * &lt;p&gt;Operators on the base reactive classes that use this scheduler are marked with the
     * &amp;#64;{@link io.reactivex.annotations.SchedulerSupport SchedulerSupport}({@link io.reactivex.annotations.SchedulerSupport#COMPUTATION COMPUTATION})
     * annotation.
     * @return a {@link Scheduler} meant for computation-bound work
     */
    @NonNull
    public static Scheduler computation() {
<span class="fc" id="L136">        return RxJavaPlugins.onComputationScheduler(COMPUTATION);</span>
    }

    /**
     * Returns a default, shared {@link Scheduler} instance intended for IO-bound work.
     * &lt;p&gt;
     * This can be used for asynchronously performing blocking IO.
     * &lt;p&gt;
     * The implementation is backed by a pool of single-threaded {@link ScheduledExecutorService} instances
     * that will try to reuse previously started instances used by the worker
     * returned by {@link io.reactivex.Scheduler#createWorker()} but otherwise will start a new backing
     * {@link ScheduledExecutorService} instance. Note that this scheduler may create an unbounded number
     * of worker threads that can result in system slowdowns or {@code OutOfMemoryError}. Therefore, for casual uses
     * or when implementing an operator, the Worker instances must be disposed via {@link io.reactivex.Scheduler.Worker#dispose()}.
     * &lt;p&gt;
     * It is not recommended to perform computational work on this scheduler. Use {@link #computation()} instead.
     * &lt;p&gt;
     * Unhandled errors will be delivered to the scheduler Thread's {@link java.lang.Thread.UncaughtExceptionHandler}.
     * &lt;p&gt;
     * You can control certain properties of this standard scheduler via system properties that have to be set
     * before the {@link Schedulers} class is referenced in your code.
     * &lt;p&gt;&lt;strong&gt;Supported system properties ({@code System.getProperty()}):&lt;/strong&gt;
     * &lt;ul&gt;
     * &lt;li&gt;{@code rx2.io-keep-alive-time} (long): sets the keep-alive time of the {@link #io()} Scheduler workers, default is {@link IoScheduler#KEEP_ALIVE_TIME_DEFAULT}&lt;/li&gt;
     * &lt;li&gt;{@code rx2.io-priority} (int): sets the thread priority of the {@link #io()} Scheduler, default is {@link Thread#NORM_PRIORITY}&lt;/li&gt;
     * &lt;/ul&gt;
     * &lt;p&gt;
     * The default value of this scheduler can be overridden at initialization time via the
     * {@link RxJavaPlugins#setInitIoSchedulerHandler(io.reactivex.functions.Function)} plugin method.
     * Note that due to possible initialization cycles, using any of the other scheduler-returning methods will
     * result in a {@code NullPointerException}.
     * Once the {@link Schedulers} class has been initialized, you can override the returned {@link Scheduler} instance
     * via the {@link RxJavaPlugins#setIoSchedulerHandler(io.reactivex.functions.Function)} method.
     * &lt;p&gt;
     * It is possible to create a fresh instance of this scheduler with a custom ThreadFactory, via the
     * {@link RxJavaPlugins#createIoScheduler(ThreadFactory)} method. Note that such custom
     * instances require a manual call to {@link Scheduler#shutdown()} to allow the JVM to exit or the
     * (J2EE) container to unload properly.
     * &lt;p&gt;Operators on the base reactive classes that use this scheduler are marked with the
     * &amp;#64;{@link io.reactivex.annotations.SchedulerSupport SchedulerSupport}({@link io.reactivex.annotations.SchedulerSupport#IO IO})
     * annotation.
     * @return a {@link Scheduler} meant for IO-bound work
     */
    @NonNull
    public static Scheduler io() {
<span class="fc" id="L181">        return RxJavaPlugins.onIoScheduler(IO);</span>
    }

    /**
     * Returns a default, shared {@link Scheduler} instance whose {@link io.reactivex.Scheduler.Worker}
     * instances queue work and execute them in a FIFO manner on one of the participating threads.
     * &lt;p&gt;
     * The default implementation's {@link Scheduler#scheduleDirect(Runnable)} methods execute the tasks on the current thread
     * without any queueing and the timed overloads use blocking sleep as well.
     * &lt;p&gt;
     * Note that this scheduler can't be reliably used to return the execution of
     * tasks to the &quot;main&quot; thread. Such behavior requires a blocking-queueing scheduler currently not provided
     * by RxJava itself but may be found in external libraries.
     * &lt;p&gt;
     * This scheduler can't be overridden via an {@link RxJavaPlugins} method.
     * @return a {@link Scheduler} that queues work on the current thread
     */
    @NonNull
    public static Scheduler trampoline() {
<span class="fc" id="L200">        return TRAMPOLINE;</span>
    }

    /**
     * Returns a default, shared {@link Scheduler} instance that creates a new {@link Thread} for each unit of work.
     * &lt;p&gt;
     * The default implementation of this scheduler creates a new, single-threaded {@link ScheduledExecutorService} for
     * each invocation of the {@link Scheduler#scheduleDirect(Runnable)} (plus its overloads) and {@link Scheduler#createWorker()}
     * methods, thus an unbounded number of worker threads may be created that can
     * result in system slowdowns or {@code OutOfMemoryError}. Therefore, for casual uses or when implementing an operator,
     * the Worker instances must be disposed via {@link io.reactivex.Scheduler.Worker#dispose()}.
     * &lt;p&gt;
     * Unhandled errors will be delivered to the scheduler Thread's {@link java.lang.Thread.UncaughtExceptionHandler}.
     * &lt;p&gt;
     * You can control certain properties of this standard scheduler via system properties that have to be set
     * before the {@link Schedulers} class is referenced in your code.
     * &lt;p&gt;&lt;strong&gt;Supported system properties ({@code System.getProperty()}):&lt;/strong&gt;
     * &lt;ul&gt;
     * &lt;li&gt;{@code rx2.newthread-priority} (int): sets the thread priority of the {@link #newThread()} Scheduler, default is {@link Thread#NORM_PRIORITY}&lt;/li&gt;
     * &lt;/ul&gt;
     * &lt;p&gt;
     * The default value of this scheduler can be overridden at initialization time via the
     * {@link RxJavaPlugins#setInitNewThreadSchedulerHandler(io.reactivex.functions.Function)} plugin method.
     * Note that due to possible initialization cycles, using any of the other scheduler-returning methods will
     * result in a {@code NullPointerException}.
     * Once the {@link Schedulers} class has been initialized, you can override the returned {@link Scheduler} instance
     * via the {@link RxJavaPlugins#setNewThreadSchedulerHandler(io.reactivex.functions.Function)} method.
     * &lt;p&gt;
     * It is possible to create a fresh instance of this scheduler with a custom ThreadFactory, via the
     * {@link RxJavaPlugins#createNewThreadScheduler(ThreadFactory)} method. Note that such custom
     * instances require a manual call to {@link Scheduler#shutdown()} to allow the JVM to exit or the
     * (J2EE) container to unload properly.
     * &lt;p&gt;Operators on the base reactive classes that use this scheduler are marked with the
     * &amp;#64;{@link io.reactivex.annotations.SchedulerSupport SchedulerSupport}({@link io.reactivex.annotations.SchedulerSupport#NEW_THREAD NEW_TRHEAD})
     * annotation.
     * @return a {@link Scheduler} that creates new threads
     */
    @NonNull
    public static Scheduler newThread() {
<span class="fc" id="L239">        return RxJavaPlugins.onNewThreadScheduler(NEW_THREAD);</span>
    }

    /**
     * Returns a default, shared, single-thread-backed {@link Scheduler} instance for work
     * requiring strongly-sequential execution on the same background thread.
     * &lt;p&gt;
     * Uses:
     * &lt;ul&gt;
     * &lt;li&gt;event loop&lt;/li&gt;
     * &lt;li&gt;support Schedulers.from(Executor) and from(ExecutorService) with delayed scheduling&lt;/li&gt;
     * &lt;li&gt;support benchmarks that pipeline data from some thread to another thread and
     * avoid core-bashing of computation's round-robin nature&lt;/li&gt;
     * &lt;/ul&gt;
     * &lt;p&gt;
     * Unhandled errors will be delivered to the scheduler Thread's {@link java.lang.Thread.UncaughtExceptionHandler}.
     * &lt;p&gt;
     * This type of scheduler is less sensitive to leaking {@link io.reactivex.Scheduler.Worker} instances, although
     * not disposing a worker that has timed/delayed tasks not cancelled by other means may leak resources and/or
     * execute those tasks &quot;unexpectedly&quot;.
     * &lt;p&gt;
     * If the {@link RxJavaPlugins#setFailOnNonBlockingScheduler(boolean)} is set to true, attempting to execute
     * operators that block while running on this scheduler will throw an {@link IllegalStateException}.
     * &lt;p&gt;
     * You can control certain properties of this standard scheduler via system properties that have to be set
     * before the {@link Schedulers} class is referenced in your code.
     * &lt;p&gt;&lt;strong&gt;Supported system properties ({@code System.getProperty()}):&lt;/strong&gt;
     * &lt;ul&gt;
     * &lt;li&gt;{@code rx2.single-priority} (int): sets the thread priority of the {@link #single()} Scheduler, default is {@link Thread#NORM_PRIORITY}&lt;/li&gt;
     * &lt;/ul&gt;
     * &lt;p&gt;
     * The default value of this scheduler can be overridden at initialization time via the
     * {@link RxJavaPlugins#setInitSingleSchedulerHandler(io.reactivex.functions.Function)} plugin method.
     * Note that due to possible initialization cycles, using any of the other scheduler-returning methods will
     * result in a {@code NullPointerException}.
     * Once the {@link Schedulers} class has been initialized, you can override the returned {@link Scheduler} instance
     * via the {@link RxJavaPlugins#setSingleSchedulerHandler(io.reactivex.functions.Function)} method.
     * &lt;p&gt;
     * It is possible to create a fresh instance of this scheduler with a custom ThreadFactory, via the
     * {@link RxJavaPlugins#createSingleScheduler(ThreadFactory)} method. Note that such custom
     * instances require a manual call to {@link Scheduler#shutdown()} to allow the JVM to exit or the
     * (J2EE) container to unload properly.
     * &lt;p&gt;Operators on the base reactive classes that use this scheduler are marked with the
     * &amp;#64;{@link io.reactivex.annotations.SchedulerSupport SchedulerSupport}({@link io.reactivex.annotations.SchedulerSupport#SINGLE SINGLE})
     * annotation.
     * @return a {@link Scheduler} that shares a single backing thread.
     * @since 2.0
     */
    @NonNull
    public static Scheduler single() {
<span class="fc" id="L289">        return RxJavaPlugins.onSingleScheduler(SINGLE);</span>
    }

    /**
     * Wraps an {@link Executor} into a new Scheduler instance and delegates {@code schedule()}
     * calls to it.
     * &lt;p&gt;
     * If the provided executor doesn't support any of the more specific standard Java executor
     * APIs, cancelling tasks scheduled by this scheduler can't be interrupted when they are
     * executing but only prevented from running prior to that. In addition, tasks scheduled with
     * a time delay or periodically will use the {@link #single()} scheduler for the timed waiting
     * before posting the actual task to the given executor.
     * &lt;p&gt;
     * Tasks submitted to the {@link Scheduler.Worker} of this {@code Scheduler} are also not interruptible. Use the
     * {@link #from(Executor, boolean)} overload to enable task interruption via this wrapper.
     * &lt;p&gt;
     * If the provided executor supports the standard Java {@link ExecutorService} API,
     * cancelling tasks scheduled by this scheduler can be cancelled/interrupted by calling
     * {@link io.reactivex.disposables.Disposable#dispose()}. In addition, tasks scheduled with
     * a time delay or periodically will use the {@link #single()} scheduler for the timed waiting
     * before posting the actual task to the given executor.
     * &lt;p&gt;
     * If the provided executor supports the standard Java {@link ScheduledExecutorService} API,
     * cancelling tasks scheduled by this scheduler can be cancelled/interrupted by calling
     * {@link io.reactivex.disposables.Disposable#dispose()}. In addition, tasks scheduled with
     * a time delay or periodically will use the provided executor. Note, however, if the provided
     * {@code ScheduledExecutorService} instance is not single threaded, tasks scheduled
     * with a time delay close to each other may end up executing in different order than
     * the original schedule() call was issued. This limitation may be lifted in a future patch.
     * &lt;p&gt;
     * Starting, stopping and restarting this scheduler is not supported (no-op) and the provided
     * executor's lifecycle must be managed externally:
     * &lt;pre&gt;&lt;code&gt;
     * ExecutorService exec = Executors.newSingleThreadedExecutor();
     * try {
     *     Scheduler scheduler = Schedulers.from(exec);
     *     Flowable.just(1)
     *        .subscribeOn(scheduler)
     *        .map(v -&amp;gt; v + 1)
     *        .observeOn(scheduler)
     *        .blockingSubscribe(System.out::println);
     * } finally {
     *     exec.shutdown();
     * }
     * &lt;/code&gt;&lt;/pre&gt;
     * &lt;p&gt;
     * This type of scheduler is less sensitive to leaking {@link Scheduler.Worker} instances, although
     * not disposing a worker that has timed/delayed tasks not cancelled by other means may leak resources and/or
     * execute those tasks &quot;unexpectedly&quot;.
     * &lt;p&gt;
     * Note that this method returns a new {@link Scheduler} instance, even for the same {@link Executor} instance.
     * @param executor
     *          the executor to wrap
     * @return the new Scheduler wrapping the Executor
     */
    @NonNull
    public static Scheduler from(@NonNull Executor executor) {
<span class="fc" id="L346">        return new ExecutorScheduler(executor, false);</span>
    }

    /**
     * Wraps an {@link Executor} into a new Scheduler instance and delegates {@code schedule()}
     * calls to it.
     * &lt;p&gt;
     * The tasks scheduled by the returned {@link Scheduler} and its {@link Scheduler.Worker}
     * can be optionally interrupted.
     * &lt;p&gt;
     * If the provided executor doesn't support any of the more specific standard Java executor
     * APIs, tasks scheduled with a time delay or periodically will use the
     * {@link #single()} scheduler for the timed waiting
     * before posting the actual task to the given executor.
     * &lt;p&gt;
     * If the provided executor supports the standard Java {@link ExecutorService} API,
     * canceling tasks scheduled by this scheduler can be cancelled/interrupted by calling
     * {@link io.reactivex.disposables.Disposable#dispose()}. In addition, tasks scheduled with
     * a time delay or periodically will use the {@link #single()} scheduler for the timed waiting
     * before posting the actual task to the given executor.
     * &lt;p&gt;
     * If the provided executor supports the standard Java {@link ScheduledExecutorService} API,
     * canceling tasks scheduled by this scheduler can be cancelled/interrupted by calling
     * {@link io.reactivex.disposables.Disposable#dispose()}. In addition, tasks scheduled with
     * a time delay or periodically will use the provided executor. Note, however, if the provided
     * {@code ScheduledExecutorService} instance is not single threaded, tasks scheduled
     * with a time delay close to each other may end up executing in different order than
     * the original schedule() call was issued. This limitation may be lifted in a future patch.
     * &lt;p&gt;
     * Starting, stopping and restarting this scheduler is not supported (no-op) and the provided
     * executor's lifecycle must be managed externally:
     * &lt;pre&gt;&lt;code&gt;
     * ExecutorService exec = Executors.newSingleThreadedExecutor();
     * try {
     *     Scheduler scheduler = Schedulers.from(exec, true);
     *     Flowable.just(1)
     *        .subscribeOn(scheduler)
     *        .map(v -&amp;gt; v + 1)
     *        .observeOn(scheduler)
     *        .blockingSubscribe(System.out::println);
     * } finally {
     *     exec.shutdown();
     * }
     * &lt;/code&gt;&lt;/pre&gt;
     * &lt;p&gt;
     * This type of scheduler is less sensitive to leaking {@link Scheduler.Worker} instances, although
     * not disposing a worker that has timed/delayed tasks not cancelled by other means may leak resources and/or
     * execute those tasks &quot;unexpectedly&quot;.
     * &lt;p&gt;
     * Note that this method returns a new {@link Scheduler} instance, even for the same {@link Executor} instance.
     * @param executor
     *          the executor to wrap
     * @param interruptibleWorker if {@code true} the tasks submitted to the {@link Scheduler.Worker} will
     * be interrupted when the task is disposed.
     * @return the new Scheduler wrapping the Executor
     * @since 2.2.6 - experimental
     */
    @NonNull
    @Experimental
    public static Scheduler from(@NonNull Executor executor, boolean interruptibleWorker) {
<span class="fc" id="L406">        return new ExecutorScheduler(executor, interruptibleWorker);</span>
    }

    /**
     * Shuts down the standard Schedulers.
     * &lt;p&gt;The operation is idempotent and thread-safe.
     */
    public static void shutdown() {
<span class="fc" id="L414">        computation().shutdown();</span>
<span class="fc" id="L415">        io().shutdown();</span>
<span class="fc" id="L416">        newThread().shutdown();</span>
<span class="fc" id="L417">        single().shutdown();</span>
<span class="fc" id="L418">        trampoline().shutdown();</span>
<span class="fc" id="L419">        SchedulerPoolFactory.shutdown();</span>
<span class="fc" id="L420">    }</span>

    /**
     * Starts the standard Schedulers.
     * &lt;p&gt;The operation is idempotent and thread-safe.
     */
    public static void start() {
<span class="fc" id="L427">        computation().start();</span>
<span class="fc" id="L428">        io().start();</span>
<span class="fc" id="L429">        newThread().start();</span>
<span class="fc" id="L430">        single().start();</span>
<span class="fc" id="L431">        trampoline().start();</span>
<span class="fc" id="L432">        SchedulerPoolFactory.start();</span>
<span class="fc" id="L433">    }</span>

<span class="fc" id="L435">    static final class IOTask implements Callable&lt;Scheduler&gt; {</span>
        @Override
        public Scheduler call() throws Exception {
<span class="fc" id="L438">            return IoHolder.DEFAULT;</span>
        }
    }

<span class="fc" id="L442">    static final class NewThreadTask implements Callable&lt;Scheduler&gt; {</span>
        @Override
        public Scheduler call() throws Exception {
<span class="fc" id="L445">            return NewThreadHolder.DEFAULT;</span>
        }
    }

<span class="fc" id="L449">    static final class SingleTask implements Callable&lt;Scheduler&gt; {</span>
        @Override
        public Scheduler call() throws Exception {
<span class="fc" id="L452">            return SingleHolder.DEFAULT;</span>
        }
    }

<span class="fc" id="L456">    static final class ComputationTask implements Callable&lt;Scheduler&gt; {</span>
        @Override
        public Scheduler call() throws Exception {
<span class="fc" id="L459">            return ComputationHolder.DEFAULT;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>