<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SingleNullTests.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">RxJava_2_x$Unnamed.exec</a> &gt; <a href="index.source.html" class="el_package">io.reactivex.single</a> &gt; <span class="el_source">SingleNullTests.java</span></div><h1>SingleNullTests.java</h1><pre class="source lang-java linenums">/**
 * Copyright (c) 2016-present, RxJava Contributors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is
 * distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
 * the License for the specific language governing permissions and limitations under the License.
 */

package io.reactivex.single;

import java.lang.reflect.*;
import java.util.*;
import java.util.concurrent.*;

import static org.junit.Assert.*;
import org.junit.*;
import org.reactivestreams.*;

import io.reactivex.*;
import io.reactivex.SingleOperator;
import io.reactivex.exceptions.*;
import io.reactivex.functions.*;
import io.reactivex.internal.functions.Functions;
import io.reactivex.schedulers.Schedulers;

<span class="fc" id="L31">public class SingleNullTests {</span>

<span class="fc" id="L33">    Single&lt;Integer&gt; just1 = Single.just(1);</span>

<span class="fc" id="L35">    Single&lt;Integer&gt; error = Single.error(new TestException());</span>

    @Test(expected = NullPointerException.class)
    public void ambIterableNull() {
<span class="nc" id="L39">        Single.amb((Iterable&lt;Single&lt;Integer&gt;&gt;)null);</span>
<span class="nc" id="L40">    }</span>

    @Test
    public void ambIterableIteratorNull() {
<span class="fc" id="L44">        Single.amb(new Iterable&lt;Single&lt;Object&gt;&gt;() {</span>
            @Override
            public Iterator&lt;Single&lt;Object&gt;&gt; iterator() {
<span class="fc" id="L47">                return null;</span>
            }
<span class="fc" id="L49">        }).test().assertError(NullPointerException.class);</span>
<span class="fc" id="L50">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void ambIterableOneIsNull() {
<span class="fc" id="L55">        Single.amb(Arrays.asList(null, just1))</span>
<span class="fc" id="L56">                .test()</span>
<span class="fc" id="L57">                .assertError(NullPointerException.class);</span>
<span class="fc" id="L58">    }</span>

    @Test(expected = NullPointerException.class)
    public void ambArrayNull() {
<span class="nc" id="L62">        Single.ambArray((Single&lt;Integer&gt;[])null);</span>
<span class="nc" id="L63">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void ambArrayOneIsNull() {
<span class="fc" id="L68">        Single.ambArray(null, just1)</span>
<span class="fc" id="L69">            .test()</span>
<span class="fc" id="L70">            .assertError(NullPointerException.class);</span>
<span class="fc" id="L71">    }</span>

    @Test(expected = NullPointerException.class)
    public void concatIterableNull() {
<span class="nc" id="L75">        Single.concat((Iterable&lt;Single&lt;Integer&gt;&gt;)null);</span>
<span class="nc" id="L76">    }</span>

    @Test(expected = NullPointerException.class)
    public void concatIterableIteratorNull() {
<span class="fc" id="L80">        Single.concat(new Iterable&lt;Single&lt;Object&gt;&gt;() {</span>
            @Override
            public Iterator&lt;Single&lt;Object&gt;&gt; iterator() {
<span class="fc" id="L83">                return null;</span>
            }
<span class="nc" id="L85">        }).blockingSubscribe();</span>
<span class="nc" id="L86">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test(expected = NullPointerException.class)
    public void concatIterableOneIsNull() {
<span class="nc" id="L91">        Single.concat(Arrays.asList(just1, null)).blockingSubscribe();</span>
<span class="nc" id="L92">    }</span>

    @Test(expected = NullPointerException.class)
    public void concatObservableNull() {
<span class="nc" id="L96">        Single.concat((Flowable&lt;Single&lt;Integer&gt;&gt;)null);</span>
<span class="nc" id="L97">    }</span>

    @Test
    public void concatNull() throws Exception {
<span class="fc" id="L101">        int maxArgs = 4;</span>

        @SuppressWarnings(&quot;rawtypes&quot;)
<span class="fc" id="L104">        Class&lt;Single&gt; clazz = Single.class;</span>
<span class="fc bfc" id="L105" title="All 2 branches covered.">        for (int argCount = 2; argCount &lt;= maxArgs; argCount++) {</span>
<span class="fc bfc" id="L106" title="All 2 branches covered.">            for (int argNull = 1; argNull &lt;= argCount; argNull++) {</span>
<span class="fc" id="L107">                Class&lt;?&gt;[] params = new Class[argCount];</span>
<span class="fc" id="L108">                Arrays.fill(params, SingleSource.class);</span>

<span class="fc" id="L110">                Object[] values = new Object[argCount];</span>
<span class="fc" id="L111">                Arrays.fill(values, just1);</span>
<span class="fc" id="L112">                values[argNull - 1] = null;</span>

<span class="fc" id="L114">                Method m = clazz.getMethod(&quot;concat&quot;, params);</span>

                try {
<span class="nc" id="L117">                    m.invoke(null, values);</span>
<span class="nc" id="L118">                    Assert.fail(&quot;No exception for argCount &quot; + argCount + &quot; / argNull &quot; + argNull);</span>
<span class="fc" id="L119">                } catch (InvocationTargetException ex) {</span>
<span class="pc bpc" id="L120" title="1 of 2 branches missed.">                    if (!(ex.getCause() instanceof NullPointerException)) {</span>
<span class="nc" id="L121">                        Assert.fail(&quot;Unexpected exception for argCount &quot; + argCount + &quot; / argNull &quot; + argNull + &quot;: &quot; + ex);</span>
                    }
<span class="nc" id="L123">                }</span>
            }
        }
<span class="fc" id="L126">    }</span>

    @Test(expected = NullPointerException.class)
    public void createNull() {
<span class="nc" id="L130">        Single.unsafeCreate(null);</span>
<span class="nc" id="L131">    }</span>

    @Test(expected = NullPointerException.class)
    public void deferNull() {
<span class="nc" id="L135">        Single.defer(null);</span>
<span class="nc" id="L136">    }</span>

    @Test(expected = NullPointerException.class)
    public void deferReturnsNull() {
<span class="nc" id="L140">        Single.defer(Functions.&lt;Single&lt;Object&gt;&gt;nullSupplier()).blockingGet();</span>
<span class="nc" id="L141">    }</span>

    @Test(expected = NullPointerException.class)
    public void errorSupplierNull() {
<span class="nc" id="L145">        Single.error((Callable&lt;Throwable&gt;)null);</span>
<span class="nc" id="L146">    }</span>

    @Test(expected = NullPointerException.class)
    public void errorSupplierReturnsNull() {
<span class="nc" id="L150">        Single.error(Functions.&lt;Throwable&gt;nullSupplier()).blockingGet();</span>
<span class="nc" id="L151">    }</span>

    @Test(expected = NullPointerException.class)
    public void errorNull() {
<span class="nc" id="L155">        Single.error((Throwable)null);</span>
<span class="nc" id="L156">    }</span>

    @Test(expected = NullPointerException.class)
    public void fromCallableNull() {
<span class="nc" id="L160">        Single.fromCallable(null);</span>
<span class="nc" id="L161">    }</span>

    @Test(expected = NullPointerException.class)
    public void fromCallableReturnsNull() {
<span class="fc" id="L165">        Single.fromCallable(new Callable&lt;Object&gt;() {</span>
            @Override
            public Object call() throws Exception {
<span class="fc" id="L168">                return null;</span>
            }
<span class="nc" id="L170">        }).blockingGet();</span>
<span class="nc" id="L171">    }</span>

    @Test(expected = NullPointerException.class)
    public void fromFutureNull() {
<span class="nc" id="L175">        Single.fromFuture((Future&lt;Integer&gt;)null);</span>
<span class="nc" id="L176">    }</span>

    @Test(expected = NullPointerException.class)
    public void fromFutureReturnsNull() {
<span class="fc" id="L180">        FutureTask&lt;Object&gt; f = new FutureTask&lt;Object&gt;(Functions.EMPTY_RUNNABLE, null);</span>
<span class="fc" id="L181">        f.run();</span>
<span class="nc" id="L182">        Single.fromFuture(f).blockingGet();</span>
<span class="nc" id="L183">    }</span>

    @Test(expected = NullPointerException.class)
    public void fromFutureTimedFutureNull() {
<span class="nc" id="L187">        Single.fromFuture(null, 1, TimeUnit.SECONDS);</span>
<span class="nc" id="L188">    }</span>

    @Test(expected = NullPointerException.class)
    public void fromFutureTimedUnitNull() {
<span class="pc" id="L192">        Single.fromFuture(new FutureTask&lt;Object&gt;(new Callable&lt;Object&gt;() {</span>
            @Override
            public Object call() throws Exception {
<span class="nc" id="L195">                return null;</span>
            }
        }), 1, null);
<span class="nc" id="L198">    }</span>

    @Test(expected = NullPointerException.class)
    public void fromFutureTimedSchedulerNull() {
<span class="pc" id="L202">        Single.fromFuture(new FutureTask&lt;Object&gt;(new Callable&lt;Object&gt;() {</span>
            @Override
            public Object call() throws Exception {
<span class="nc" id="L205">                return null;</span>
            }
        }), 1, TimeUnit.SECONDS, null);
<span class="nc" id="L208">    }</span>

    @Test(expected = NullPointerException.class)
    public void fromFutureTimedReturnsNull() {
<span class="fc" id="L212">        FutureTask&lt;Object&gt; f = new FutureTask&lt;Object&gt;(Functions.EMPTY_RUNNABLE, null);</span>
<span class="fc" id="L213">        f.run();</span>
<span class="nc" id="L214">        Single.fromFuture(f, 1, TimeUnit.SECONDS).blockingGet();</span>
<span class="nc" id="L215">    }</span>

    @Test(expected = NullPointerException.class)
    public void fromFutureSchedulerNull() {
<span class="pc" id="L219">        Single.fromFuture(new FutureTask&lt;Object&gt;(new Callable&lt;Object&gt;() {</span>
            @Override
            public Object call() throws Exception {
<span class="nc" id="L222">                return null;</span>
            }
        }), null);
<span class="nc" id="L225">    }</span>

    @Test(expected = NullPointerException.class)
    public void fromPublisherNull() {
<span class="nc" id="L229">        Single.fromPublisher(null);</span>
<span class="nc" id="L230">    }</span>

    @Test(expected = NullPointerException.class)
    public void justNull() {
<span class="nc" id="L234">        Single.just(null);</span>
<span class="nc" id="L235">    }</span>

    @Test(expected = NullPointerException.class)
    public void mergeIterableNull() {
<span class="nc" id="L239">        Single.merge((Iterable&lt;Single&lt;Integer&gt;&gt;)null);</span>
<span class="nc" id="L240">    }</span>

    @Test(expected = NullPointerException.class)
    public void mergeIterableIteratorNull() {
<span class="fc" id="L244">        Single.merge(new Iterable&lt;Single&lt;Object&gt;&gt;() {</span>
            @Override
            public Iterator&lt;Single&lt;Object&gt;&gt; iterator() {
<span class="fc" id="L247">                return null;</span>
            }
<span class="nc" id="L249">        }).blockingSubscribe();</span>
<span class="nc" id="L250">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test(expected = NullPointerException.class)
    public void mergeIterableOneIsNull() {
<span class="nc" id="L255">        Single.merge(Arrays.asList(null, just1)).blockingSubscribe();</span>
<span class="nc" id="L256">    }</span>

    @Test(expected = NullPointerException.class)
    public void mergeSingleNull() {
<span class="nc" id="L260">        Single.merge((Single&lt;Single&lt;Integer&gt;&gt;)null);</span>
<span class="nc" id="L261">    }</span>

    @Test
    public void mergeNull() throws Exception {
<span class="fc" id="L265">        int maxArgs = 4;</span>

        @SuppressWarnings(&quot;rawtypes&quot;)
<span class="fc" id="L268">        Class&lt;Single&gt; clazz = Single.class;</span>
<span class="fc bfc" id="L269" title="All 2 branches covered.">        for (int argCount = 2; argCount &lt;= maxArgs; argCount++) {</span>
<span class="fc bfc" id="L270" title="All 2 branches covered.">            for (int argNull = 1; argNull &lt;= argCount; argNull++) {</span>
<span class="fc" id="L271">                Class&lt;?&gt;[] params = new Class[argCount];</span>
<span class="fc" id="L272">                Arrays.fill(params, SingleSource.class);</span>

<span class="fc" id="L274">                Object[] values = new Object[argCount];</span>
<span class="fc" id="L275">                Arrays.fill(values, just1);</span>
<span class="fc" id="L276">                values[argNull - 1] = null;</span>

<span class="fc" id="L278">                Method m = clazz.getMethod(&quot;merge&quot;, params);</span>

                try {
<span class="nc" id="L281">                    m.invoke(null, values);</span>
<span class="nc" id="L282">                    Assert.fail(&quot;No exception for argCount &quot; + argCount + &quot; / argNull &quot; + argNull);</span>
<span class="fc" id="L283">                } catch (InvocationTargetException ex) {</span>
<span class="pc bpc" id="L284" title="1 of 2 branches missed.">                    if (!(ex.getCause() instanceof NullPointerException)) {</span>
<span class="nc" id="L285">                        Assert.fail(&quot;Unexpected exception for argCount &quot; + argCount + &quot; / argNull &quot; + argNull + &quot;: &quot; + ex);</span>
                    }
<span class="nc" id="L287">                }</span>
            }
        }
<span class="fc" id="L290">    }</span>

    @Test(expected = NullPointerException.class)
    public void timerUnitNull() {
<span class="nc" id="L294">        Single.timer(1, null);</span>
<span class="nc" id="L295">    }</span>

    @Test(expected = NullPointerException.class)
    public void timerSchedulerNull() {
<span class="nc" id="L299">        Single.timer(1, TimeUnit.SECONDS, null);</span>
<span class="nc" id="L300">    }</span>

    @Test(expected = NullPointerException.class)
    public void equalsFirstNull() {
<span class="nc" id="L304">        Single.equals(null, just1);</span>
<span class="nc" id="L305">    }</span>

    @Test(expected = NullPointerException.class)
    public void equalsSecondNull() {
<span class="nc" id="L309">        Single.equals(just1, null);</span>
<span class="nc" id="L310">    }</span>

    @Test(expected = NullPointerException.class)
    public void usingResourceSupplierNull() {
<span class="pc" id="L314">        Single.using(null, new Function&lt;Object, Single&lt;Integer&gt;&gt;() {</span>
            @Override
            public Single&lt;Integer&gt; apply(Object d) {
<span class="nc" id="L317">                return just1;</span>
            }
<span class="fc" id="L319">        }, Functions.emptyConsumer());</span>
<span class="nc" id="L320">    }</span>

    @Test(expected = NullPointerException.class)
    public void usingSingleSupplierNull() {
<span class="pc" id="L324">        Single.using(new Callable&lt;Object&gt;() {</span>
            @Override
            public Object call() {
<span class="nc" id="L327">                return 1;</span>
            }
<span class="fc" id="L329">        }, null, Functions.emptyConsumer());</span>
<span class="nc" id="L330">    }</span>

    @Test(expected = NullPointerException.class)
    public void usingSingleSupplierReturnsNull() {
<span class="fc" id="L334">        Single.using(new Callable&lt;Object&gt;() {</span>
            @Override
            public Object call() {
<span class="fc" id="L337">                return 1;</span>
            }
<span class="fc" id="L339">        }, new Function&lt;Object, Single&lt;Object&gt;&gt;() {</span>
            @Override
            public Single&lt;Object&gt; apply(Object d) {
<span class="fc" id="L342">                return null;</span>
            }
<span class="pc" id="L344">        }, Functions.emptyConsumer()).blockingGet();</span>
<span class="nc" id="L345">    }</span>

    @Test(expected = NullPointerException.class)
    public void usingDisposeNull() {
<span class="pc" id="L349">        Single.using(new Callable&lt;Object&gt;() {</span>
            @Override
            public Object call() {
<span class="nc" id="L352">                return 1;</span>
            }
<span class="fc" id="L354">        }, new Function&lt;Object, Single&lt;Integer&gt;&gt;() {</span>
            @Override
            public Single&lt;Integer&gt; apply(Object d) {
<span class="nc" id="L357">                return just1;</span>
            }
        }, null);
<span class="nc" id="L360">    }</span>

    @Test(expected = NullPointerException.class)
    public void zipIterableNull() {
<span class="pc" id="L364">        Single.zip((Iterable&lt;Single&lt;Integer&gt;&gt;)null, new Function&lt;Object[], Object&gt;() {</span>
            @Override
            public Object apply(Object[] v) {
<span class="nc" id="L367">                return 1;</span>
            }
        });
<span class="nc" id="L370">    }</span>

    @Test(expected = NullPointerException.class)
    public void zipIterableIteratorNull() {
<span class="fc" id="L374">        Single.zip(new Iterable&lt;Single&lt;Object&gt;&gt;() {</span>
            @Override
            public Iterator&lt;Single&lt;Object&gt;&gt; iterator() {
<span class="fc" id="L377">                return null;</span>
            }
<span class="fc" id="L379">        }, new Function&lt;Object[], Object&gt;() {</span>
            @Override
            public Object apply(Object[] v) {
<span class="nc" id="L382">                return 1;</span>
            }
<span class="nc" id="L384">        }).blockingGet();</span>
<span class="nc" id="L385">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test(expected = NullPointerException.class)
    public void zipIterableOneIsNull() {
<span class="fc" id="L390">        Single.zip(Arrays.asList(null, just1), new Function&lt;Object[], Object&gt;() {</span>
            @Override
            public Object apply(Object[] v) {
<span class="nc" id="L393">                return 1;</span>
            }
<span class="nc" id="L395">        }).blockingGet();</span>
<span class="nc" id="L396">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test(expected = NullPointerException.class)
    public void zipIterableOneFunctionNull() {
<span class="nc" id="L401">        Single.zip(Arrays.asList(just1, just1), null).blockingGet();</span>
<span class="nc" id="L402">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test(expected = NullPointerException.class)
    public void zipIterableOneFunctionReturnsNull() {
<span class="fc" id="L407">        Single.zip(Arrays.asList(just1, just1), new Function&lt;Object[], Object&gt;() {</span>
            @Override
            public Object apply(Object[] v) {
<span class="fc" id="L410">                return null;</span>
            }
<span class="nc" id="L412">        }).blockingGet();</span>
<span class="nc" id="L413">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test
    public void zipNull() throws Exception {
        @SuppressWarnings(&quot;rawtypes&quot;)
<span class="fc" id="L419">        Class&lt;Single&gt; clazz = Single.class;</span>
<span class="fc bfc" id="L420" title="All 2 branches covered.">        for (int argCount = 3; argCount &lt; 10; argCount++) {</span>
<span class="fc bfc" id="L421" title="All 2 branches covered.">            for (int argNull = 1; argNull &lt;= argCount; argNull++) {</span>
<span class="fc" id="L422">                Class&lt;?&gt;[] params = new Class[argCount + 1];</span>
<span class="fc" id="L423">                Arrays.fill(params, SingleSource.class);</span>
<span class="fc" id="L424">                Class&lt;?&gt; fniClass = Class.forName(&quot;io.reactivex.functions.Function&quot; + argCount);</span>
<span class="fc" id="L425">                params[argCount] = fniClass;</span>

<span class="fc" id="L427">                Object[] values = new Object[argCount + 1];</span>
<span class="fc" id="L428">                Arrays.fill(values, just1);</span>
<span class="fc" id="L429">                values[argNull - 1] = null;</span>
<span class="fc" id="L430">                values[argCount] = Proxy.newProxyInstance(getClass().getClassLoader(), new Class[] { fniClass }, new InvocationHandler() {</span>
                    @Override
                    public Object invoke(Object o, Method m, Object[] a) throws Throwable {
<span class="nc" id="L433">                        return 1;</span>
                    }
                });

<span class="fc" id="L437">                Method m = clazz.getMethod(&quot;zip&quot;, params);</span>

                try {
<span class="nc" id="L440">                    m.invoke(null, values);</span>
<span class="nc" id="L441">                    Assert.fail(&quot;No exception for argCount &quot; + argCount + &quot; / argNull &quot; + argNull);</span>
<span class="fc" id="L442">                } catch (InvocationTargetException ex) {</span>
<span class="pc bpc" id="L443" title="1 of 2 branches missed.">                    if (!(ex.getCause() instanceof NullPointerException)) {</span>
<span class="nc" id="L444">                        Assert.fail(&quot;Unexpected exception for argCount &quot; + argCount + &quot; / argNull &quot; + argNull + &quot;: &quot; + ex);</span>
                    }
<span class="nc" id="L446">                }</span>

<span class="fc" id="L448">                values[argCount] = Proxy.newProxyInstance(getClass().getClassLoader(), new Class[] { fniClass }, new InvocationHandler() {</span>
                    @Override
                    public Object invoke(Object o, Method m1, Object[] a) throws Throwable {
<span class="nc" id="L451">                        return null;</span>
                    }
                });
                try {
<span class="nc" id="L455">                    ((Single&lt;Object&gt;)m.invoke(null, values)).blockingGet();</span>
<span class="nc" id="L456">                    Assert.fail(&quot;No exception for argCount &quot; + argCount + &quot; / argNull &quot; + argNull);</span>
<span class="fc" id="L457">                } catch (InvocationTargetException ex) {</span>
<span class="pc bpc" id="L458" title="1 of 2 branches missed.">                    if (!(ex.getCause() instanceof NullPointerException)) {</span>
<span class="nc" id="L459">                        Assert.fail(&quot;Unexpected exception for argCount &quot; + argCount + &quot; / argNull &quot; + argNull + &quot;: &quot; + ex);</span>
                    }
<span class="nc" id="L461">                }</span>

            }

<span class="fc" id="L465">            Class&lt;?&gt;[] params = new Class[argCount + 1];</span>
<span class="fc" id="L466">            Arrays.fill(params, SingleSource.class);</span>
<span class="fc" id="L467">            Class&lt;?&gt; fniClass = Class.forName(&quot;io.reactivex.functions.Function&quot; + argCount);</span>
<span class="fc" id="L468">            params[argCount] = fniClass;</span>

<span class="fc" id="L470">            Object[] values = new Object[argCount + 1];</span>
<span class="fc" id="L471">            Arrays.fill(values, just1);</span>
<span class="fc" id="L472">            values[argCount] = null;</span>

<span class="fc" id="L474">            Method m = clazz.getMethod(&quot;zip&quot;, params);</span>

            try {
<span class="nc" id="L477">                m.invoke(null, values);</span>
<span class="nc" id="L478">                Assert.fail(&quot;No exception for argCount &quot; + argCount + &quot; / zipper function &quot;);</span>
<span class="fc" id="L479">            } catch (InvocationTargetException ex) {</span>
<span class="pc bpc" id="L480" title="1 of 2 branches missed.">                if (!(ex.getCause() instanceof NullPointerException)) {</span>
<span class="nc" id="L481">                    Assert.fail(&quot;Unexpected exception for argCount &quot; + argCount + &quot; / zipper function: &quot; + ex);</span>
                }
<span class="nc" id="L483">            }</span>
        }
<span class="fc" id="L485">    }</span>

    @Test(expected = NullPointerException.class)
    public void zip2FirstNull() {
<span class="pc" id="L489">        Single.zip(null, just1, new BiFunction&lt;Object, Integer, Object&gt;() {</span>
            @Override
            public Object apply(Object a, Integer b) {
<span class="nc" id="L492">                return 1;</span>
            }
        });
<span class="nc" id="L495">    }</span>

    @Test(expected = NullPointerException.class)
    public void zip2SecondNull() {
<span class="pc" id="L499">        Single.zip(just1, null, new BiFunction&lt;Integer, Object, Object&gt;() {</span>
            @Override
            public Object apply(Integer a, Object b) {
<span class="nc" id="L502">                return 1;</span>
            }
        });
<span class="nc" id="L505">    }</span>

    @Test(expected = NullPointerException.class)
    public void zip2ZipperNull() {
<span class="nc" id="L509">        Single.zip(just1, just1, null);</span>
<span class="nc" id="L510">    }</span>

    @Test(expected = NullPointerException.class)
    public void zip2ZipperReturnsdNull() {
<span class="pc" id="L514">        Single.zip(just1, null, new BiFunction&lt;Integer, Object, Object&gt;() {</span>
            @Override
            public Object apply(Integer a, Object b) {
<span class="nc" id="L517">                return null;</span>
            }
<span class="nc" id="L519">        }).blockingGet();</span>
<span class="nc" id="L520">    }</span>

    @Test(expected = NullPointerException.class)
    public void zipArrayNull() {
<span class="pc" id="L524">        Single.zipArray(new Function&lt;Object[], Object&gt;() {</span>
            @Override
            public Object apply(Object[] v) {
<span class="nc" id="L527">                return 1;</span>
            }
        }, (Single&lt;Integer&gt;[])null);
<span class="nc" id="L530">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test(expected = NullPointerException.class)
    public void zipIterableTwoIsNull() {
<span class="fc" id="L535">        Single.zip(Arrays.asList(just1, null), new Function&lt;Object[], Object&gt;() {</span>
            @Override
            public Object apply(Object[] v) {
<span class="nc" id="L538">                return 1;</span>
            }
        })
<span class="nc" id="L541">        .blockingGet();</span>
<span class="nc" id="L542">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test(expected = NullPointerException.class)
    public void zipArrayOneIsNull() {
<span class="fc" id="L547">        Single.zipArray(new Function&lt;Object[], Object&gt;() {</span>
            @Override
            public Object apply(Object[] v) {
<span class="nc" id="L550">                return 1;</span>
            }
        }, just1, null)
<span class="nc" id="L553">        .blockingGet();</span>
<span class="nc" id="L554">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test(expected = NullPointerException.class)
    public void zipArrayFunctionNull() {
<span class="nc" id="L559">        Single.zipArray(null, just1, just1);</span>
<span class="nc" id="L560">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    @Test(expected = NullPointerException.class)
    public void zipArrayFunctionReturnsNull() {
<span class="fc" id="L565">        Single.zipArray(new Function&lt;Object[], Object&gt;() {</span>
            @Override
            public Object apply(Object[] v) {
<span class="fc" id="L568">                return null;</span>
            }
<span class="nc" id="L570">        }, just1, just1).blockingGet();</span>
<span class="nc" id="L571">    }</span>

    //**************************************************
    // Instance methods
    //**************************************************

    @Test(expected = NullPointerException.class)
    public void ambWithNull() {
<span class="nc" id="L579">        just1.ambWith(null);</span>
<span class="nc" id="L580">    }</span>

    @Test(expected = NullPointerException.class)
    public void composeNull() {
<span class="nc" id="L584">        just1.compose(null);</span>
<span class="nc" id="L585">    }</span>

    @Test(expected = NullPointerException.class)
    public void castNull() {
<span class="nc" id="L589">        just1.cast(null);</span>
<span class="nc" id="L590">    }</span>

    @Test(expected = NullPointerException.class)
    public void concatWith() {
<span class="nc" id="L594">        just1.concatWith(null);</span>
<span class="nc" id="L595">    }</span>

    @Test(expected = NullPointerException.class)
    public void delayUnitNull() {
<span class="nc" id="L599">        just1.delay(1, null);</span>
<span class="nc" id="L600">    }</span>

    @Test(expected = NullPointerException.class)
    public void delaySchedulerNull() {
<span class="nc" id="L604">        just1.delay(1, TimeUnit.SECONDS, null);</span>
<span class="nc" id="L605">    }</span>

    @Test(expected = NullPointerException.class)
    public void doOnSubscribeNull() {
<span class="nc" id="L609">        just1.doOnSubscribe(null);</span>
<span class="nc" id="L610">    }</span>

    @Test(expected = NullPointerException.class)
    public void doOnSuccess() {
<span class="nc" id="L614">        just1.doOnSuccess(null);</span>
<span class="nc" id="L615">    }</span>

    @Test(expected = NullPointerException.class)
    public void doOnError() {
<span class="nc" id="L619">        error.doOnError(null);</span>
<span class="nc" id="L620">    }</span>

    @Test(expected = NullPointerException.class)
    public void doOnDisposeNull() {
<span class="nc" id="L624">        just1.doOnDispose(null);</span>
<span class="nc" id="L625">    }</span>

    @Test(expected = NullPointerException.class)
    public void flatMapNull() {
<span class="nc" id="L629">        just1.flatMap(null);</span>
<span class="nc" id="L630">    }</span>

    @Test(expected = NullPointerException.class)
    public void flatMapFunctionReturnsNull() {
<span class="fc" id="L634">        just1.flatMap(new Function&lt;Integer, Single&lt;Object&gt;&gt;() {</span>
            @Override
            public Single&lt;Object&gt; apply(Integer v) {
<span class="fc" id="L637">                return null;</span>
            }
<span class="nc" id="L639">        }).blockingGet();</span>
<span class="nc" id="L640">    }</span>

    @Test(expected = NullPointerException.class)
    public void flatMapPublisherNull() {
<span class="nc" id="L644">        just1.flatMapPublisher(null);</span>
<span class="nc" id="L645">    }</span>

    @Test(expected = NullPointerException.class)
    public void flatMapPublisherFunctionReturnsNull() {
<span class="fc" id="L649">        just1.flatMapPublisher(new Function&lt;Integer, Publisher&lt;Object&gt;&gt;() {</span>
            @Override
            public Publisher&lt;Object&gt; apply(Integer v) {
<span class="fc" id="L652">                return null;</span>
            }
<span class="nc" id="L654">        }).blockingSubscribe();</span>
<span class="nc" id="L655">    }</span>

    @Test(expected = NullPointerException.class)
    public void liftNull() {
<span class="nc" id="L659">        just1.lift(null);</span>
<span class="nc" id="L660">    }</span>

    @Test(expected = NullPointerException.class)
    public void liftFunctionReturnsNull() {
<span class="fc" id="L664">        just1.lift(new SingleOperator&lt;Object, Integer&gt;() {</span>
            @Override
            public SingleObserver&lt;? super Integer&gt; apply(SingleObserver&lt;? super Object&gt; observer) {
<span class="fc" id="L667">                return null;</span>
            }
<span class="nc" id="L669">        }).blockingGet();</span>
<span class="nc" id="L670">    }</span>

    @Test(expected = NullPointerException.class)
    public void containsNull() {
<span class="nc" id="L674">        just1.contains(null);</span>
<span class="nc" id="L675">    }</span>

    @Test(expected = NullPointerException.class)
    public void containsComparerNull() {
<span class="nc" id="L679">        just1.contains(1, null);</span>
<span class="nc" id="L680">    }</span>

    @Test(expected = NullPointerException.class)
    public void mergeWithNull() {
<span class="nc" id="L684">        just1.mergeWith(null);</span>
<span class="nc" id="L685">    }</span>

    @Test(expected = NullPointerException.class)
    public void observeOnNull() {
<span class="nc" id="L689">        just1.observeOn(null);</span>
<span class="nc" id="L690">    }</span>

    @Test(expected = NullPointerException.class)
    public void onErrorReturnSupplierNull() {
<span class="nc" id="L694">        just1.onErrorReturn((Function&lt;Throwable, Integer&gt;)null);</span>
<span class="nc" id="L695">    }</span>

    @Test(expected = NullPointerException.class)
    public void onErrorReturnsSupplierReturnsNull() {
<span class="fc" id="L699">        error.onErrorReturn(new Function&lt;Throwable, Integer&gt;() {</span>
            @Override
            public Integer apply(Throwable t) throws Exception {
<span class="fc" id="L702">                return null;</span>
            }
<span class="nc" id="L704">        }).blockingGet();</span>
<span class="nc" id="L705">    }</span>

    @Test(expected = NullPointerException.class)
    public void onErrorReturnValueNull() {
<span class="nc" id="L709">        error.onErrorReturnItem(null);</span>
<span class="nc" id="L710">    }</span>

    @Test(expected = NullPointerException.class)
    public void onErrorResumeNextSingleNull() {
<span class="nc" id="L714">        error.onErrorResumeNext((Single&lt;Integer&gt;)null);</span>
<span class="nc" id="L715">    }</span>

    @Test(expected = NullPointerException.class)
    public void onErrorResumeNextFunctionNull() {
<span class="nc" id="L719">        error.onErrorResumeNext((Function&lt;Throwable, Single&lt;Integer&gt;&gt;)null);</span>
<span class="nc" id="L720">    }</span>

    @Test
    public void onErrorResumeNextFunctionReturnsNull() {
        try {
<span class="fc" id="L725">            error.onErrorResumeNext(new Function&lt;Throwable, Single&lt;Integer&gt;&gt;() {</span>
                @Override
                public Single&lt;Integer&gt; apply(Throwable e) {
<span class="fc" id="L728">                    return null;</span>
                }
<span class="nc" id="L730">            }).blockingGet();</span>
<span class="fc" id="L731">        } catch (CompositeException ex) {</span>
<span class="fc" id="L732">            assertTrue(ex.toString(), ex.getExceptions().get(1) instanceof NullPointerException);</span>
<span class="nc" id="L733">        }</span>
<span class="fc" id="L734">    }</span>

    @Test(expected = NullPointerException.class)
    public void repeatWhenNull() {
<span class="nc" id="L738">        error.repeatWhen(null);</span>
<span class="nc" id="L739">    }</span>

    @Test(expected = NullPointerException.class)
    public void repeatWhenFunctionReturnsNull() {
<span class="fc" id="L743">        error.repeatWhen(new Function&lt;Flowable&lt;Object&gt;, Publisher&lt;Object&gt;&gt;() {</span>
            @Override
            public Publisher&lt;Object&gt; apply(Flowable&lt;Object&gt; v) {
<span class="fc" id="L746">                return null;</span>
            }
<span class="nc" id="L748">        }).blockingSubscribe();</span>
<span class="nc" id="L749">    }</span>

    @Test(expected = NullPointerException.class)
    public void repeatUntilNull() {
<span class="nc" id="L753">        error.repeatUntil(null);</span>
<span class="nc" id="L754">    }</span>

    @Test(expected = NullPointerException.class)
    public void retryBiPreducateNull() {
<span class="nc" id="L758">        error.retry((BiPredicate&lt;Integer, Throwable&gt;)null);</span>
<span class="nc" id="L759">    }</span>

    @Test(expected = NullPointerException.class)
    public void retryPredicateNull() {
<span class="nc" id="L763">        error.retry((Predicate&lt;Throwable&gt;)null);</span>
<span class="nc" id="L764">    }</span>

    @Test(expected = NullPointerException.class)
    public void retryWhenNull() {
<span class="nc" id="L768">        error.retryWhen(null);</span>
<span class="nc" id="L769">    }</span>

    @Test(expected = NullPointerException.class)
    public void retryWhenFunctionReturnsNull() {
<span class="fc" id="L773">        error.retryWhen(new Function&lt;Flowable&lt;? extends Throwable&gt;, Publisher&lt;Object&gt;&gt;() {</span>
            @Override
            public Publisher&lt;Object&gt; apply(Flowable&lt;? extends Throwable&gt; e) {
<span class="fc" id="L776">                return null;</span>
            }
<span class="nc" id="L778">        }).blockingGet();</span>
<span class="nc" id="L779">    }</span>

    @Test(expected = NullPointerException.class)
    public void subscribeBiConsumerNull() {
<span class="nc" id="L783">        just1.subscribe((BiConsumer&lt;Integer, Throwable&gt;)null);</span>
<span class="nc" id="L784">    }</span>

    @Test(expected = NullPointerException.class)
    public void subscribeConsumerNull() {
<span class="nc" id="L788">        just1.subscribe((Consumer&lt;Integer&gt;)null);</span>
<span class="nc" id="L789">    }</span>

    @Test(expected = NullPointerException.class)
    public void subscribeSingeSubscriberNull() {
<span class="nc" id="L793">        just1.subscribe((SingleObserver&lt;Integer&gt;)null);</span>
<span class="nc" id="L794">    }</span>

    @Test(expected = NullPointerException.class)
    public void subscribeOnSuccessNull() {
<span class="pc" id="L798">        just1.subscribe(null, new Consumer&lt;Throwable&gt;() {</span>
            @Override
<span class="nc" id="L800">            public void accept(Throwable e) { }</span>
        });
<span class="nc" id="L802">    }</span>

    @Test(expected = NullPointerException.class)
    public void subscribeOnErrorNull() {
<span class="pc" id="L806">        just1.subscribe(new Consumer&lt;Integer&gt;() {</span>
            @Override
<span class="nc" id="L808">            public void accept(Integer v) { }</span>
        }, null);
<span class="nc" id="L810">    }</span>

    @Test(expected = NullPointerException.class)
    public void subscribeSubscriberNull() {
<span class="nc" id="L814">        just1.toFlowable().subscribe((Subscriber&lt;Integer&gt;)null);</span>
<span class="nc" id="L815">    }</span>

    @Test(expected = NullPointerException.class)
    public void subscribeOnNull() {
<span class="nc" id="L819">        just1.subscribeOn(null);</span>
<span class="nc" id="L820">    }</span>

    @Test(expected = NullPointerException.class)
    public void timeoutUnitNull() {
<span class="nc" id="L824">        just1.timeout(1, null);</span>
<span class="nc" id="L825">    }</span>

    @Test(expected = NullPointerException.class)
    public void timeoutSchedulerNull() {
<span class="nc" id="L829">        just1.timeout(1, TimeUnit.SECONDS, (Scheduler)null);</span>
<span class="nc" id="L830">    }</span>

    @Test(expected = NullPointerException.class)
    public void timeoutOtherNull() {
<span class="nc" id="L834">        just1.timeout(1, TimeUnit.SECONDS, Schedulers.single(), null);</span>
<span class="nc" id="L835">    }</span>

    @Test(expected = NullPointerException.class)
    public void timeoutOther2Null() {
<span class="nc" id="L839">        just1.timeout(1, TimeUnit.SECONDS, (Single&lt;Integer&gt;)null);</span>
<span class="nc" id="L840">    }</span>

    @Test(expected = NullPointerException.class)
    public void toNull() {
<span class="nc" id="L844">        just1.to(null);</span>
<span class="nc" id="L845">    }</span>

    @Test(expected = NullPointerException.class)
    public void asNull() {
<span class="nc" id="L849">        just1.as(null);</span>
<span class="nc" id="L850">    }</span>

    @Test(expected = NullPointerException.class)
    public void zipWithNull() {
<span class="pc" id="L854">        just1.zipWith(null, new BiFunction&lt;Integer, Object, Object&gt;() {</span>
            @Override
            public Object apply(Integer a, Object b) {
<span class="nc" id="L857">                return 1;</span>
            }
        });
<span class="nc" id="L860">    }</span>

    @Test(expected = NullPointerException.class)
    public void zipWithFunctionNull() {
<span class="nc" id="L864">        just1.zipWith(just1, null);</span>
<span class="nc" id="L865">    }</span>

    @Test(expected = NullPointerException.class)
    public void zipWithFunctionReturnsNull() {
<span class="fc" id="L869">        just1.zipWith(just1, new BiFunction&lt;Integer, Integer, Object&gt;() {</span>
            @Override
            public Object apply(Integer a, Integer b) {
<span class="fc" id="L872">                return null;</span>
            }
<span class="nc" id="L874">        }).blockingGet();</span>
<span class="nc" id="L875">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>