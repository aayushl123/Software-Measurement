<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ReplaySubject.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">RxJava_2_x$Unnamed.exec</a> &gt; <a href="index.source.html" class="el_package">io.reactivex.subjects</a> &gt; <span class="el_source">ReplaySubject.java</span></div><h1>ReplaySubject.java</h1><pre class="source lang-java linenums">/**
 * Copyright (c) 2016-present, RxJava Contributors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is
 * distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
 * the License for the specific language governing permissions and limitations under the License.
 */

package io.reactivex.subjects;

import java.lang.reflect.Array;
import java.util.*;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.*;

import io.reactivex.Observer;
import io.reactivex.Scheduler;
import io.reactivex.annotations.*;
import io.reactivex.disposables.Disposable;
import io.reactivex.internal.functions.ObjectHelper;
import io.reactivex.internal.util.NotificationLite;
import io.reactivex.plugins.RxJavaPlugins;

/**
 * Replays events (in a configurable bounded or unbounded manner) to current and late {@link Observer}s.
 * &lt;p&gt;
 * This subject does not have a public constructor by design; a new empty instance of this
 * {@code ReplaySubject} can be created via the following {@code create} methods that
 * allow specifying the retention policy for items:
 * &lt;ul&gt;
 * &lt;li&gt;{@link #create()} - creates an empty, unbounded {@code ReplaySubject} that
 *     caches all items and the terminal event it receives.
 * &lt;p&gt;
 * &lt;img width=&quot;640&quot; height=&quot;299&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/ReplaySubject.u.png&quot; alt=&quot;&quot;&gt;
 * &lt;p&gt;
 * &lt;img width=&quot;640&quot; height=&quot;398&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/ReplaySubject.ue.png&quot; alt=&quot;&quot;&gt;
 * &lt;/li&gt;
 * &lt;li&gt;{@link #create(int)} - creates an empty, unbounded {@code ReplaySubject}
 *     with a hint about how many &lt;b&gt;total&lt;/b&gt; items one expects to retain.
 * &lt;/li&gt;
 * &lt;li&gt;{@link #createWithSize(int)} - creates an empty, size-bound {@code ReplaySubject}
 *     that retains at most the given number of the latest item it receives.
 * &lt;p&gt;
 * &lt;img width=&quot;640&quot; height=&quot;420&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/ReplaySubject.n.png&quot; alt=&quot;&quot;&gt;
 * &lt;/li&gt;
 * &lt;li&gt;{@link #createWithTime(long, TimeUnit, Scheduler)} - creates an empty, time-bound
 *     {@code ReplaySubject} that retains items no older than the specified time amount.
 * &lt;p&gt;
 * &lt;img width=&quot;640&quot; height=&quot;415&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/ReplaySubject.t.png&quot; alt=&quot;&quot;&gt;
 * &lt;/li&gt;
 * &lt;li&gt;{@link #createWithTimeAndSize(long, TimeUnit, Scheduler, int)} - creates an empty,
 *     time- and size-bound {@code ReplaySubject} that retains at most the given number
 *     items that are also not older than the specified time amount.
 * &lt;p&gt;
 * &lt;img width=&quot;640&quot; height=&quot;404&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/ReplaySubject.nt.png&quot; alt=&quot;&quot;&gt;
 * &lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;p&gt;
 * Since a {@code Subject} is conceptionally derived from the {@code Processor} type in the Reactive Streams specification,
 * {@code null}s are not allowed (&lt;a href=&quot;https://github.com/reactive-streams/reactive-streams-jvm#2.13&quot;&gt;Rule 2.13&lt;/a&gt;) as
 * parameters to {@link #onNext(Object)} and {@link #onError(Throwable)}. Such calls will result in a
 * {@link NullPointerException} being thrown and the subject's state is not changed.
 * &lt;p&gt;
 * Since a {@code ReplaySubject} is an {@link io.reactivex.Observable}, it does not support backpressure.
 * &lt;p&gt;
 * When this {@code ReplaySubject} is terminated via {@link #onError(Throwable)} or {@link #onComplete()},
 * late {@link io.reactivex.Observer}s will receive the retained/cached items first (if any) followed by the respective
 * terminal event. If the {@code ReplaySubject} has a time-bound, the age of the retained/cached items are still considered
 * when replaying and thus it may result in no items being emitted before the terminal event.
 * &lt;p&gt;
 * Once an {@code Observer} has subscribed, it will receive items continuously from that point on. Bounds only affect how
 * many past items a new {@code Observer} will receive before it catches up with the live event feed.
 * &lt;p&gt;
 * Even though {@code ReplaySubject} implements the {@code Observer} interface, calling
 * {@code onSubscribe} is not required (&lt;a href=&quot;https://github.com/reactive-streams/reactive-streams-jvm#2.12&quot;&gt;Rule 2.12&lt;/a&gt;)
 * if the subject is used as a standalone source. However, calling {@code onSubscribe}
 * after the {@code ReplaySubject} reached its terminal state will result in the
 * given {@code Disposable} being disposed immediately.
 * &lt;p&gt;
 * Calling {@link #onNext(Object)}, {@link #onError(Throwable)} and {@link #onComplete()}
 * is required to be serialized (called from the same thread or called non-overlappingly from different threads
 * through external means of serialization). The {@link #toSerialized()} method available to all {@code Subject}s
 * provides such serialization and also protects against reentrance (i.e., when a downstream {@code Observer}
 * consuming this subject also wants to call {@link #onNext(Object)} on this subject recursively).
 * &lt;p&gt;
 * This {@code ReplaySubject} supports the standard state-peeking methods {@link #hasComplete()}, {@link #hasThrowable()},
 * {@link #getThrowable()} and {@link #hasObservers()} as well as means to read the retained/cached items
 * in a non-blocking and thread-safe manner via {@link #hasValue()}, {@link #getValue()},
 * {@link #getValues()} or {@link #getValues(Object[])}.
 * &lt;p&gt;
 * Note that due to concurrency requirements, a size- and time-bounded {@code ReplaySubject} may hold strong references to more
 * source emissions than specified while it isn't terminated yet. Use the {@link #cleanupBuffer()} to allow
 * such inaccessible items to be cleaned up by GC once no consumer references it anymore.
 * &lt;dl&gt;
 *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
 *  &lt;dd&gt;{@code ReplaySubject} does not operate by default on a particular {@link io.reactivex.Scheduler} and
 *  the {@code Observer}s get notified on the thread the respective {@code onXXX} methods were invoked.
 *  Time-bound {@code ReplaySubject}s use the given {@code Scheduler} in their {@code create} methods
 *  as time source to timestamp of items received for the age checks.&lt;/dd&gt;
 *  &lt;dt&gt;&lt;b&gt;Error handling:&lt;/b&gt;&lt;/dt&gt;
 *  &lt;dd&gt;When the {@link #onError(Throwable)} is called, the {@code ReplaySubject} enters into a terminal state
 *  and emits the same {@code Throwable} instance to the last set of {@code Observer}s. During this emission,
 *  if one or more {@code Observer}s dispose their respective {@code Disposable}s, the
 *  {@code Throwable} is delivered to the global error handler via
 *  {@link io.reactivex.plugins.RxJavaPlugins#onError(Throwable)} (multiple times if multiple {@code Observer}s
 *  cancel at once).
 *  If there were no {@code Observer}s subscribed to this {@code ReplaySubject} when the {@code onError()}
 *  was called, the global error handler is not invoked.
 *  &lt;/dd&gt;
 * &lt;/dl&gt;
 * &lt;p&gt;
 * Example usage:
 * &lt;pre&gt; {@code

  ReplaySubject&lt;Object&gt; subject = ReplaySubject.create();
  subject.onNext(&quot;one&quot;);
  subject.onNext(&quot;two&quot;);
  subject.onNext(&quot;three&quot;);
  subject.onComplete();

  // both of the following will get the onNext/onComplete calls from above
  subject.subscribe(observer1);
  subject.subscribe(observer2);

  } &lt;/pre&gt;
 *
 * @param &lt;T&gt; the value type
 */
public final class ReplaySubject&lt;T&gt; extends Subject&lt;T&gt; {
    final ReplayBuffer&lt;T&gt; buffer;

    final AtomicReference&lt;ReplayDisposable&lt;T&gt;[]&gt; observers;

    @SuppressWarnings(&quot;rawtypes&quot;)
<span class="fc" id="L140">    static final ReplayDisposable[] EMPTY = new ReplayDisposable[0];</span>

    @SuppressWarnings(&quot;rawtypes&quot;)
<span class="fc" id="L143">    static final ReplayDisposable[] TERMINATED = new ReplayDisposable[0];</span>

    boolean done;

    /**
     * Creates an unbounded replay subject.
     * &lt;p&gt;
     * The internal buffer is backed by an {@link ArrayList} and starts with an initial capacity of 16. Once the
     * number of items reaches this capacity, it will grow as necessary (usually by 50%). However, as the
     * number of items grows, this causes frequent array reallocation and copying, and may hurt performance
     * and latency. This can be avoided with the {@link #create(int)} overload which takes an initial capacity
     * parameter and can be tuned to reduce the array reallocation frequency as needed.
     *
     * @param &lt;T&gt;
     *          the type of items observed and emitted by the Subject
     * @return the created subject
     */
    @CheckReturnValue
    @NonNull
    public static &lt;T&gt; ReplaySubject&lt;T&gt; create() {
<span class="fc" id="L163">        return new ReplaySubject&lt;T&gt;(new UnboundedReplayBuffer&lt;T&gt;(16));</span>
    }

    /**
     * Creates an unbounded replay subject with the specified initial buffer capacity.
     * &lt;p&gt;
     * Use this method to avoid excessive array reallocation while the internal buffer grows to accommodate new
     * items. For example, if you know that the buffer will hold 32k items, you can ask the
     * {@code ReplaySubject} to preallocate its internal array with a capacity to hold that many items. Once
     * the items start to arrive, the internal array won't need to grow, creating less garbage and no overhead
     * due to frequent array-copying.
     *
     * @param &lt;T&gt;
     *          the type of items observed and emitted by the Subject
     * @param capacityHint
     *          the initial buffer capacity
     * @return the created subject
     */
    @CheckReturnValue
    @NonNull
    public static &lt;T&gt; ReplaySubject&lt;T&gt; create(int capacityHint) {
<span class="fc" id="L184">        return new ReplaySubject&lt;T&gt;(new UnboundedReplayBuffer&lt;T&gt;(capacityHint));</span>
    }

    /**
     * Creates a size-bounded replay subject.
     * &lt;p&gt;
     * In this setting, the {@code ReplaySubject} holds at most {@code size} items in its internal buffer and
     * discards the oldest item.
     * &lt;p&gt;
     * When observers subscribe to a terminated {@code ReplaySubject}, they are guaranteed to see at most
     * {@code size} {@code onNext} events followed by a termination event.
     * &lt;p&gt;
     * If an observer subscribes while the {@code ReplaySubject} is active, it will observe all items in the
     * buffer at that point in time and each item observed afterwards, even if the buffer evicts items due to
     * the size constraint in the mean time. In other words, once an Observer subscribes, it will receive items
     * without gaps in the sequence.
     *
     * @param &lt;T&gt;
     *          the type of items observed and emitted by the Subject
     * @param maxSize
     *          the maximum number of buffered items
     * @return the created subject
     */
    @CheckReturnValue
    @NonNull
    public static &lt;T&gt; ReplaySubject&lt;T&gt; createWithSize(int maxSize) {
<span class="fc" id="L210">        return new ReplaySubject&lt;T&gt;(new SizeBoundReplayBuffer&lt;T&gt;(maxSize));</span>
    }

    /**
     * Creates an unbounded replay subject with the bounded-implementation for testing purposes.
     * &lt;p&gt;
     * This variant behaves like the regular unbounded {@code ReplaySubject} created via {@link #create()} but
     * uses the structures of the bounded-implementation. This is by no means intended for the replacement of
     * the original, array-backed and unbounded {@code ReplaySubject} due to the additional overhead of the
     * linked-list based internal buffer. The sole purpose is to allow testing and reasoning about the behavior
     * of the bounded implementations without the interference of the eviction policies.
     *
     * @param &lt;T&gt;
     *          the type of items observed and emitted by the Subject
     * @return the created subject
     */
    /* test */ static &lt;T&gt; ReplaySubject&lt;T&gt; createUnbounded() {
<span class="fc" id="L227">        return new ReplaySubject&lt;T&gt;(new SizeBoundReplayBuffer&lt;T&gt;(Integer.MAX_VALUE));</span>
    }

    /**
     * Creates a time-bounded replay subject.
     * &lt;p&gt;
     * In this setting, the {@code ReplaySubject} internally tags each observed item with a timestamp value
     * supplied by the {@link Scheduler} and keeps only those whose age is less than the supplied time value
     * converted to milliseconds. For example, an item arrives at T=0 and the max age is set to 5; at T&amp;gt;=5
     * this first item is then evicted by any subsequent item or termination event, leaving the buffer empty.
     * &lt;p&gt;
     * Once the subject is terminated, observers subscribing to it will receive items that remained in the
     * buffer after the terminal event, regardless of their age.
     * &lt;p&gt;
     * If an observer subscribes while the {@code ReplaySubject} is active, it will observe only those items
     * from within the buffer that have an age less than the specified time, and each item observed thereafter,
     * even if the buffer evicts items due to the time constraint in the mean time. In other words, once an
     * observer subscribes, it observes items without gaps in the sequence except for any outdated items at the
     * beginning of the sequence.
     * &lt;p&gt;
     * Note that terminal notifications ({@code onError} and {@code onComplete}) trigger eviction as well. For
     * example, with a max age of 5, the first item is observed at T=0, then an {@code onComplete} notification
     * arrives at T=10. If an observer subscribes at T=11, it will find an empty {@code ReplaySubject} with just
     * an {@code onComplete} notification.
     *
     * @param &lt;T&gt;
     *          the type of items observed and emitted by the Subject
     * @param maxAge
     *          the maximum age of the contained items
     * @param unit
     *          the time unit of {@code time}
     * @param scheduler
     *          the {@link Scheduler} that provides the current time
     * @return the created subject
     */
    @CheckReturnValue
    @NonNull
    public static &lt;T&gt; ReplaySubject&lt;T&gt; createWithTime(long maxAge, TimeUnit unit, Scheduler scheduler) {
<span class="fc" id="L265">        return new ReplaySubject&lt;T&gt;(new SizeAndTimeBoundReplayBuffer&lt;T&gt;(Integer.MAX_VALUE, maxAge, unit, scheduler));</span>
    }

    /**
     * Creates a time- and size-bounded replay subject.
     * &lt;p&gt;
     * In this setting, the {@code ReplaySubject} internally tags each received item with a timestamp value
     * supplied by the {@link Scheduler} and holds at most {@code size} items in its internal buffer. It evicts
     * items from the start of the buffer if their age becomes less-than or equal to the supplied age in
     * milliseconds or the buffer reaches its {@code size} limit.
     * &lt;p&gt;
     * When observers subscribe to a terminated {@code ReplaySubject}, they observe the items that remained in
     * the buffer after the terminal notification, regardless of their age, but at most {@code size} items.
     * &lt;p&gt;
     * If an observer subscribes while the {@code ReplaySubject} is active, it will observe only those items
     * from within the buffer that have age less than the specified time and each subsequent item, even if the
     * buffer evicts items due to the time constraint in the mean time. In other words, once an observer
     * subscribes, it observes items without gaps in the sequence except for the outdated items at the beginning
     * of the sequence.
     * &lt;p&gt;
     * Note that terminal notifications ({@code onError} and {@code onComplete}) trigger eviction as well. For
     * example, with a max age of 5, the first item is observed at T=0, then an {@code onComplete} notification
     * arrives at T=10. If an observer subscribes at T=11, it will find an empty {@code ReplaySubject} with just
     * an {@code onComplete} notification.
     *
     * @param &lt;T&gt;
     *          the type of items observed and emitted by the Subject
     * @param maxAge
     *          the maximum age of the contained items
     * @param unit
     *          the time unit of {@code time}
     * @param maxSize
     *          the maximum number of buffered items
     * @param scheduler
     *          the {@link Scheduler} that provides the current time
     * @return the created subject
     */
    @CheckReturnValue
    @NonNull
    public static &lt;T&gt; ReplaySubject&lt;T&gt; createWithTimeAndSize(long maxAge, TimeUnit unit, Scheduler scheduler, int maxSize) {
<span class="fc" id="L305">        return new ReplaySubject&lt;T&gt;(new SizeAndTimeBoundReplayBuffer&lt;T&gt;(maxSize, maxAge, unit, scheduler));</span>
    }

    /**
     * Constructs a ReplayProcessor with the given custom ReplayBuffer instance.
     * @param buffer the ReplayBuffer instance, not null (not verified)
     */
    @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L313">    ReplaySubject(ReplayBuffer&lt;T&gt; buffer) {</span>
<span class="fc" id="L314">        this.buffer = buffer;</span>
<span class="fc" id="L315">        this.observers = new AtomicReference&lt;ReplayDisposable&lt;T&gt;[]&gt;(EMPTY);</span>
<span class="fc" id="L316">    }</span>

    @Override
    protected void subscribeActual(Observer&lt;? super T&gt; observer) {
<span class="fc" id="L320">        ReplayDisposable&lt;T&gt; rs = new ReplayDisposable&lt;T&gt;(observer, this);</span>
<span class="fc" id="L321">        observer.onSubscribe(rs);</span>

<span class="fc bfc" id="L323" title="All 2 branches covered.">        if (!rs.cancelled) {</span>
<span class="fc bfc" id="L324" title="All 2 branches covered.">            if (add(rs)) {</span>
<span class="fc bfc" id="L325" title="All 2 branches covered.">                if (rs.cancelled) {</span>
<span class="fc" id="L326">                    remove(rs);</span>
<span class="fc" id="L327">                    return;</span>
                }
            }
<span class="fc" id="L330">            buffer.replay(rs);</span>
        }
<span class="fc" id="L332">    }</span>

    @Override
    public void onSubscribe(Disposable d) {
<span class="fc bfc" id="L336" title="All 2 branches covered.">        if (done) {</span>
<span class="fc" id="L337">            d.dispose();</span>
        }
<span class="fc" id="L339">    }</span>

    @Override
    public void onNext(T t) {
<span class="fc" id="L343">        ObjectHelper.requireNonNull(t, &quot;onNext called with null. Null values are generally not allowed in 2.x operators and sources.&quot;);</span>
<span class="fc bfc" id="L344" title="All 2 branches covered.">        if (done) {</span>
<span class="fc" id="L345">            return;</span>
        }

<span class="fc" id="L348">        ReplayBuffer&lt;T&gt; b = buffer;</span>
<span class="fc" id="L349">        b.add(t);</span>

<span class="fc bfc" id="L351" title="All 2 branches covered.">        for (ReplayDisposable&lt;T&gt; rs : observers.get()) {</span>
<span class="fc" id="L352">            b.replay(rs);</span>
        }
<span class="fc" id="L354">    }</span>

    @Override
    public void onError(Throwable t) {
<span class="fc" id="L358">        ObjectHelper.requireNonNull(t, &quot;onError called with null. Null values are generally not allowed in 2.x operators and sources.&quot;);</span>
<span class="fc bfc" id="L359" title="All 2 branches covered.">        if (done) {</span>
<span class="fc" id="L360">            RxJavaPlugins.onError(t);</span>
<span class="fc" id="L361">            return;</span>
        }
<span class="fc" id="L363">        done = true;</span>

<span class="fc" id="L365">        Object o = NotificationLite.error(t);</span>

<span class="fc" id="L367">        ReplayBuffer&lt;T&gt; b = buffer;</span>

<span class="fc" id="L369">        b.addFinal(o);</span>

<span class="fc bfc" id="L371" title="All 2 branches covered.">        for (ReplayDisposable&lt;T&gt; rs : terminate(o)) {</span>
<span class="fc" id="L372">            b.replay(rs);</span>
        }
<span class="fc" id="L374">    }</span>

    @Override
    public void onComplete() {
<span class="fc bfc" id="L378" title="All 2 branches covered.">        if (done) {</span>
<span class="fc" id="L379">            return;</span>
        }
<span class="fc" id="L381">        done = true;</span>

<span class="fc" id="L383">        Object o = NotificationLite.complete();</span>

<span class="fc" id="L385">        ReplayBuffer&lt;T&gt; b = buffer;</span>

<span class="fc" id="L387">        b.addFinal(o);</span>

<span class="fc bfc" id="L389" title="All 2 branches covered.">        for (ReplayDisposable&lt;T&gt; rs : terminate(o)) {</span>
<span class="fc" id="L390">            b.replay(rs);</span>
        }
<span class="fc" id="L392">    }</span>

    @Override
    public boolean hasObservers() {
<span class="fc bfc" id="L396" title="All 2 branches covered.">        return observers.get().length != 0;</span>
    }

    /* test */ int observerCount() {
<span class="fc" id="L400">        return observers.get().length;</span>
    }

    @Override
    @Nullable
    public Throwable getThrowable() {
<span class="fc" id="L406">        Object o = buffer.get();</span>
<span class="fc bfc" id="L407" title="All 2 branches covered.">        if (NotificationLite.isError(o)) {</span>
<span class="fc" id="L408">            return NotificationLite.getError(o);</span>
        }
<span class="fc" id="L410">        return null;</span>
    }

    /**
     * Returns a single value the Subject currently has or null if no such value exists.
     * &lt;p&gt;The method is thread-safe.
     * @return a single value the Subject currently has or null if no such value exists
     */
    @Nullable
    public T getValue() {
<span class="fc" id="L420">        return buffer.getValue();</span>
    }

    /**
     * Makes sure the item cached by the head node in a bounded
     * ReplaySubject is released (as it is never part of a replay).
     * &lt;p&gt;
     * By default, live bounded buffers will remember one item before
     * the currently receivable one to ensure subscribers can always
     * receive a continuous sequence of items. A terminated ReplaySubject
     * automatically releases this inaccessible item.
     * &lt;p&gt;
     * The method must be called sequentially, similar to the standard
     * {@code onXXX} methods.
     * &lt;p&gt;History: 2.1.11 - experimental
     * @since 2.2
     */
    public void cleanupBuffer() {
<span class="fc" id="L438">        buffer.trimHead();</span>
<span class="fc" id="L439">    }</span>

    /** An empty array to avoid allocation in getValues(). */
<span class="fc" id="L442">    private static final Object[] EMPTY_ARRAY = new Object[0];</span>

    /**
     * Returns an Object array containing snapshot all values of the Subject.
     * &lt;p&gt;The method is thread-safe.
     * @return the array containing the snapshot of all values of the Subject
     */
    public Object[] getValues() {
        @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L451">        T[] a = (T[])EMPTY_ARRAY;</span>
<span class="fc" id="L452">        T[] b = getValues(a);</span>
<span class="fc bfc" id="L453" title="All 2 branches covered.">        if (b == EMPTY_ARRAY) {</span>
<span class="fc" id="L454">            return new Object[0];</span>
        }
<span class="fc" id="L456">        return b;</span>

    }

    /**
     * Returns a typed array containing a snapshot of all values of the Subject.
     * &lt;p&gt;The method follows the conventions of Collection.toArray by setting the array element
     * after the last value to null (if the capacity permits).
     * &lt;p&gt;The method is thread-safe.
     * @param array the target array to copy values into if it fits
     * @return the given array if the values fit into it or a new array containing all values
     */
    public T[] getValues(T[] array) {
<span class="fc" id="L469">        return buffer.getValues(array);</span>
    }

    @Override
    public boolean hasComplete() {
<span class="fc" id="L474">        Object o = buffer.get();</span>
<span class="fc" id="L475">        return NotificationLite.isComplete(o);</span>
    }

    @Override
    public boolean hasThrowable() {
<span class="fc" id="L480">        Object o = buffer.get();</span>
<span class="fc" id="L481">        return NotificationLite.isError(o);</span>
    }

    /**
     * Returns true if the subject has any value.
     * &lt;p&gt;The method is thread-safe.
     * @return true if the subject has any value
     */
    public boolean hasValue() {
<span class="fc bfc" id="L490" title="All 2 branches covered.">        return buffer.size() != 0; // NOPMD</span>
    }

    /* test*/ int size() {
<span class="fc" id="L494">        return buffer.size();</span>
    }

    boolean add(ReplayDisposable&lt;T&gt; rs) {
        for (;;) {
<span class="fc" id="L499">            ReplayDisposable&lt;T&gt;[] a = observers.get();</span>
<span class="fc bfc" id="L500" title="All 2 branches covered.">            if (a == TERMINATED) {</span>
<span class="fc" id="L501">                return false;</span>
            }
<span class="fc" id="L503">            int len = a.length;</span>
            @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L505">            ReplayDisposable&lt;T&gt;[] b = new ReplayDisposable[len + 1];</span>
<span class="fc" id="L506">            System.arraycopy(a, 0, b, 0, len);</span>
<span class="fc" id="L507">            b[len] = rs;</span>
<span class="fc bfc" id="L508" title="All 2 branches covered.">            if (observers.compareAndSet(a, b)) {</span>
<span class="fc" id="L509">                return true;</span>
            }
<span class="fc" id="L511">        }</span>
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    void remove(ReplayDisposable&lt;T&gt; rs) {
        for (;;) {
<span class="fc" id="L517">            ReplayDisposable&lt;T&gt;[] a = observers.get();</span>
<span class="fc bfc" id="L518" title="All 4 branches covered.">            if (a == TERMINATED || a == EMPTY) {</span>
<span class="fc" id="L519">                return;</span>
            }
<span class="fc" id="L521">            int len = a.length;</span>
<span class="fc" id="L522">            int j = -1;</span>
<span class="fc bfc" id="L523" title="All 2 branches covered.">            for (int i = 0; i &lt; len; i++) {</span>
<span class="fc bfc" id="L524" title="All 2 branches covered.">                if (a[i] == rs) {</span>
<span class="fc" id="L525">                    j = i;</span>
<span class="fc" id="L526">                    break;</span>
                }
            }

<span class="fc bfc" id="L530" title="All 2 branches covered.">            if (j &lt; 0) {</span>
<span class="fc" id="L531">                return;</span>
            }
            ReplayDisposable&lt;T&gt;[] b;
<span class="fc bfc" id="L534" title="All 2 branches covered.">            if (len == 1) {</span>
<span class="fc" id="L535">                b = EMPTY;</span>
            } else {
<span class="fc" id="L537">                b = new ReplayDisposable[len - 1];</span>
<span class="fc" id="L538">                System.arraycopy(a, 0, b, 0, j);</span>
<span class="fc" id="L539">                System.arraycopy(a, j + 1, b, j, len - j - 1);</span>
            }
<span class="fc bfc" id="L541" title="All 2 branches covered.">            if (observers.compareAndSet(a, b)) {</span>
<span class="fc" id="L542">                return;</span>
            }
<span class="fc" id="L544">        }</span>
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    ReplayDisposable&lt;T&gt;[] terminate(Object terminalValue) {
<span class="pc bpc" id="L549" title="1 of 2 branches missed.">        if (buffer.compareAndSet(null, terminalValue)) {</span>
<span class="fc" id="L550">            return observers.getAndSet(TERMINATED);</span>
        }
<span class="nc" id="L552">        return TERMINATED;</span>
    }

    /**
     * Abstraction over a buffer that receives events and replays them to
     * individual Observers.
     *
     * @param &lt;T&gt; the value type
     */
    interface ReplayBuffer&lt;T&gt; {

        void add(T value);

        void addFinal(Object notificationLite);

        void replay(ReplayDisposable&lt;T&gt; rs);

        int size();

        @Nullable
        T getValue();

        T[] getValues(T[] array);
        /**
         * Returns the terminal NotificationLite object or null if not yet terminated.
         * @return the terminal NotificationLite object or null if not yet terminated
         */
        Object get();

        /**
         * Atomically compares and sets the next terminal NotificationLite object if the
         * current equals to the expected NotificationLite object.
         * @param expected the expected NotificationLite object
         * @param next the next NotificationLite object
         * @return true if successful
         */
        boolean compareAndSet(Object expected, Object next);

        /**
         * Make sure an old inaccessible head value is released
         * in a bounded buffer.
         */
        void trimHead();
    }

    static final class ReplayDisposable&lt;T&gt; extends AtomicInteger implements Disposable {

        private static final long serialVersionUID = 466549804534799122L;
        final Observer&lt;? super T&gt; downstream;
        final ReplaySubject&lt;T&gt; state;

        Object index;

        volatile boolean cancelled;

<span class="fc" id="L607">        ReplayDisposable(Observer&lt;? super T&gt; actual, ReplaySubject&lt;T&gt; state) {</span>
<span class="fc" id="L608">            this.downstream = actual;</span>
<span class="fc" id="L609">            this.state = state;</span>
<span class="fc" id="L610">        }</span>

        @Override
        public void dispose() {
<span class="fc bfc" id="L614" title="All 2 branches covered.">            if (!cancelled) {</span>
<span class="fc" id="L615">                cancelled = true;</span>
<span class="fc" id="L616">                state.remove(this);</span>
            }
<span class="fc" id="L618">        }</span>

        @Override
        public boolean isDisposed() {
<span class="fc" id="L622">            return cancelled;</span>
        }
    }

    static final class UnboundedReplayBuffer&lt;T&gt;
    extends AtomicReference&lt;Object&gt;
    implements ReplayBuffer&lt;T&gt; {

        private static final long serialVersionUID = -733876083048047795L;

        final List&lt;Object&gt; buffer;

        volatile boolean done;

        volatile int size;

<span class="fc" id="L638">        UnboundedReplayBuffer(int capacityHint) {</span>
<span class="fc" id="L639">            this.buffer = new ArrayList&lt;Object&gt;(ObjectHelper.verifyPositive(capacityHint, &quot;capacityHint&quot;));</span>
<span class="fc" id="L640">        }</span>

        @Override
        public void add(T value) {
<span class="fc" id="L644">            buffer.add(value);</span>
<span class="fc" id="L645">            size++;</span>
<span class="fc" id="L646">        }</span>

        @Override
        public void addFinal(Object notificationLite) {
<span class="fc" id="L650">            buffer.add(notificationLite);</span>
<span class="fc" id="L651">            trimHead();</span>
<span class="fc" id="L652">            size++;</span>
<span class="fc" id="L653">            done = true;</span>
<span class="fc" id="L654">        }</span>

        @Override
        public void trimHead() {
            // no-op in this type of buffer
<span class="fc" id="L659">        }</span>

        @Override
        @Nullable
        @SuppressWarnings(&quot;unchecked&quot;)
        public T getValue() {
<span class="fc" id="L665">            int s = size;</span>
<span class="fc bfc" id="L666" title="All 2 branches covered.">            if (s != 0) {</span>
<span class="fc" id="L667">                List&lt;Object&gt; b = buffer;</span>
<span class="fc" id="L668">                Object o = b.get(s - 1);</span>
<span class="fc bfc" id="L669" title="All 4 branches covered.">                if (NotificationLite.isComplete(o) || NotificationLite.isError(o)) {</span>
<span class="fc bfc" id="L670" title="All 2 branches covered.">                    if (s == 1) {</span>
<span class="fc" id="L671">                        return null;</span>
                    }
<span class="fc" id="L673">                    return (T)b.get(s - 2);</span>
                }
<span class="fc" id="L675">                return (T)o;</span>
            }
<span class="fc" id="L677">            return null;</span>
        }

        @Override
        @SuppressWarnings(&quot;unchecked&quot;)
        public T[] getValues(T[] array) {
<span class="fc" id="L683">            int s = size;</span>
<span class="fc bfc" id="L684" title="All 2 branches covered.">            if (s == 0) {</span>
<span class="fc bfc" id="L685" title="All 2 branches covered.">                if (array.length != 0) {</span>
<span class="fc" id="L686">                    array[0] = null;</span>
                }
<span class="fc" id="L688">                return array;</span>
            }
<span class="fc" id="L690">            List&lt;Object&gt; b = buffer;</span>
<span class="fc" id="L691">            Object o = b.get(s - 1);</span>

<span class="fc bfc" id="L693" title="All 4 branches covered.">            if (NotificationLite.isComplete(o) || NotificationLite.isError(o)) {</span>
<span class="fc" id="L694">                s--;</span>
<span class="fc bfc" id="L695" title="All 2 branches covered.">                if (s == 0) {</span>
<span class="fc bfc" id="L696" title="All 2 branches covered.">                    if (array.length != 0) {</span>
<span class="fc" id="L697">                        array[0] = null;</span>
                    }
<span class="fc" id="L699">                    return array;</span>
                }
            }

<span class="fc bfc" id="L703" title="All 2 branches covered.">            if (array.length &lt; s) {</span>
<span class="fc" id="L704">                array = (T[])Array.newInstance(array.getClass().getComponentType(), s);</span>
            }
<span class="fc bfc" id="L706" title="All 2 branches covered.">            for (int i = 0; i &lt; s; i++) {</span>
<span class="fc" id="L707">                array[i] = (T)b.get(i);</span>
            }
<span class="fc bfc" id="L709" title="All 2 branches covered.">            if (array.length &gt; s) {</span>
<span class="fc" id="L710">                array[s] = null;</span>
            }

<span class="fc" id="L713">            return array;</span>
        }

        @Override
        @SuppressWarnings(&quot;unchecked&quot;)
        public void replay(ReplayDisposable&lt;T&gt; rs) {
<span class="fc bfc" id="L719" title="All 2 branches covered.">            if (rs.getAndIncrement() != 0) {</span>
<span class="fc" id="L720">                return;</span>
            }

<span class="fc" id="L723">            int missed = 1;</span>
<span class="fc" id="L724">            final List&lt;Object&gt; b = buffer;</span>
<span class="fc" id="L725">            final Observer&lt;? super T&gt; a = rs.downstream;</span>

<span class="fc" id="L727">            Integer indexObject = (Integer)rs.index;</span>
            int index;
<span class="fc bfc" id="L729" title="All 2 branches covered.">            if (indexObject != null) {</span>
<span class="fc" id="L730">                index = indexObject;</span>
            } else {
<span class="fc" id="L732">                index = 0;</span>
<span class="fc" id="L733">                rs.index = 0;</span>
            }

            for (;;) {

<span class="fc bfc" id="L738" title="All 2 branches covered.">                if (rs.cancelled) {</span>
<span class="fc" id="L739">                    rs.index = null;</span>
<span class="fc" id="L740">                    return;</span>
                }

<span class="fc" id="L743">                int s = size;</span>

<span class="fc bfc" id="L745" title="All 2 branches covered.">                while (s != index) {</span>

<span class="fc bfc" id="L747" title="All 2 branches covered.">                    if (rs.cancelled) {</span>
<span class="fc" id="L748">                        rs.index = null;</span>
<span class="fc" id="L749">                        return;</span>
                    }

<span class="fc" id="L752">                    Object o = b.get(index);</span>

<span class="fc bfc" id="L754" title="All 2 branches covered.">                    if (done) {</span>
<span class="fc bfc" id="L755" title="All 2 branches covered.">                        if (index + 1 == s) {</span>
<span class="fc" id="L756">                            s = size;</span>
<span class="fc bfc" id="L757" title="All 2 branches covered.">                            if (index + 1 == s) {</span>
<span class="fc bfc" id="L758" title="All 2 branches covered.">                                if (NotificationLite.isComplete(o)) {</span>
<span class="fc" id="L759">                                    a.onComplete();</span>
                                } else {
<span class="fc" id="L761">                                    a.onError(NotificationLite.getError(o));</span>
                                }
<span class="fc" id="L763">                                rs.index = null;</span>
<span class="fc" id="L764">                                rs.cancelled = true;</span>
<span class="fc" id="L765">                                return;</span>
                            }
                        }
                    }

<span class="fc" id="L770">                    a.onNext((T)o);</span>
<span class="fc" id="L771">                    index++;</span>
<span class="fc" id="L772">                }</span>

<span class="fc bfc" id="L774" title="All 2 branches covered.">                if (index != size) {</span>
<span class="fc" id="L775">                    continue;</span>
                }

<span class="fc" id="L778">                rs.index = index;</span>

<span class="fc" id="L780">                missed = rs.addAndGet(-missed);</span>
<span class="fc bfc" id="L781" title="All 2 branches covered.">                if (missed == 0) {</span>
<span class="fc" id="L782">                    break;</span>
                }
<span class="fc" id="L784">            }</span>
<span class="fc" id="L785">        }</span>

        @Override
        public int size() {
<span class="fc" id="L789">            int s = size;</span>
<span class="fc bfc" id="L790" title="All 2 branches covered.">            if (s != 0) {</span>
<span class="fc" id="L791">                Object o = buffer.get(s - 1);</span>
<span class="fc bfc" id="L792" title="All 4 branches covered.">                if (NotificationLite.isComplete(o) || NotificationLite.isError(o)) {</span>
<span class="fc" id="L793">                    return s - 1;</span>
                }
<span class="fc" id="L795">                return s;</span>
            }
<span class="fc" id="L797">            return 0;</span>
        }
    }

    static final class Node&lt;T&gt; extends AtomicReference&lt;Node&lt;T&gt;&gt; {

        private static final long serialVersionUID = 6404226426336033100L;

        final T value;

<span class="fc" id="L807">        Node(T value) {</span>
<span class="fc" id="L808">            this.value = value;</span>
<span class="fc" id="L809">        }</span>
    }

    static final class TimedNode&lt;T&gt; extends AtomicReference&lt;TimedNode&lt;T&gt;&gt; {

        private static final long serialVersionUID = 6404226426336033100L;

        final T value;
        final long time;

<span class="fc" id="L819">        TimedNode(T value, long time) {</span>
<span class="fc" id="L820">            this.value = value;</span>
<span class="fc" id="L821">            this.time = time;</span>
<span class="fc" id="L822">        }</span>
    }

    static final class SizeBoundReplayBuffer&lt;T&gt;
    extends AtomicReference&lt;Object&gt;
    implements ReplayBuffer&lt;T&gt; {

        private static final long serialVersionUID = 1107649250281456395L;

        final int maxSize;
        int size;

        volatile Node&lt;Object&gt; head;

        Node&lt;Object&gt; tail;

        volatile boolean done;

<span class="fc" id="L840">        SizeBoundReplayBuffer(int maxSize) {</span>
<span class="fc" id="L841">            this.maxSize = ObjectHelper.verifyPositive(maxSize, &quot;maxSize&quot;);</span>
<span class="fc" id="L842">            Node&lt;Object&gt; h = new Node&lt;Object&gt;(null);</span>
<span class="fc" id="L843">            this.tail = h;</span>
<span class="fc" id="L844">            this.head = h;</span>
<span class="fc" id="L845">        }</span>

        void trim() {
<span class="fc bfc" id="L848" title="All 2 branches covered.">            if (size &gt; maxSize) {</span>
<span class="fc" id="L849">                size--;</span>
<span class="fc" id="L850">                Node&lt;Object&gt; h = head;</span>
<span class="fc" id="L851">                head = h.get();</span>
            }
<span class="fc" id="L853">        }</span>

        @Override
        public void add(T value) {
<span class="fc" id="L857">            Node&lt;Object&gt; n = new Node&lt;Object&gt;(value);</span>
<span class="fc" id="L858">            Node&lt;Object&gt; t = tail;</span>

<span class="fc" id="L860">            tail = n;</span>
<span class="fc" id="L861">            size++;</span>
<span class="fc" id="L862">            t.set(n); // releases both the tail and size</span>

<span class="fc" id="L864">            trim();</span>
<span class="fc" id="L865">        }</span>

        @Override
        public void addFinal(Object notificationLite) {
<span class="fc" id="L869">            Node&lt;Object&gt; n = new Node&lt;Object&gt;(notificationLite);</span>
<span class="fc" id="L870">            Node&lt;Object&gt; t = tail;</span>

<span class="fc" id="L872">            tail = n;</span>
<span class="fc" id="L873">            size++;</span>
<span class="fc" id="L874">            t.lazySet(n); // releases both the tail and size</span>

<span class="fc" id="L876">            trimHead();</span>
<span class="fc" id="L877">            done = true;</span>
<span class="fc" id="L878">        }</span>

        /**
         * Replace a non-empty head node with an empty one to
         * allow the GC of the inaccessible old value.
         */
        @Override
        public void trimHead() {
<span class="fc" id="L886">            Node&lt;Object&gt; h = head;</span>
<span class="fc bfc" id="L887" title="All 2 branches covered.">            if (h.value != null) {</span>
<span class="fc" id="L888">                Node&lt;Object&gt; n = new Node&lt;Object&gt;(null);</span>
<span class="fc" id="L889">                n.lazySet(h.get());</span>
<span class="fc" id="L890">                head = n;</span>
            }
<span class="fc" id="L892">        }</span>

        @Override
        @Nullable
        @SuppressWarnings(&quot;unchecked&quot;)
        public T getValue() {
<span class="fc" id="L898">            Node&lt;Object&gt; prev = null;</span>
<span class="fc" id="L899">            Node&lt;Object&gt; h = head;</span>

            for (;;) {
<span class="fc" id="L902">                Node&lt;Object&gt; next = h.get();</span>
<span class="fc bfc" id="L903" title="All 2 branches covered.">                if (next == null) {</span>
<span class="fc" id="L904">                    break;</span>
                }
<span class="fc" id="L906">                prev = h;</span>
<span class="fc" id="L907">                h = next;</span>
<span class="fc" id="L908">            }</span>

<span class="fc" id="L910">            Object v = h.value;</span>
<span class="fc bfc" id="L911" title="All 2 branches covered.">            if (v == null) {</span>
<span class="fc" id="L912">                return null;</span>
            }
<span class="fc bfc" id="L914" title="All 4 branches covered.">            if (NotificationLite.isComplete(v) || NotificationLite.isError(v)) {</span>
<span class="fc" id="L915">                return (T)prev.value;</span>
            }

<span class="fc" id="L918">            return (T)v;</span>
        }

        @Override
        @SuppressWarnings(&quot;unchecked&quot;)
        public T[] getValues(T[] array) {
<span class="fc" id="L924">            Node&lt;Object&gt; h = head;</span>
<span class="fc" id="L925">            int s = size();</span>

<span class="fc bfc" id="L927" title="All 2 branches covered.">            if (s == 0) {</span>
<span class="fc bfc" id="L928" title="All 2 branches covered.">                if (array.length != 0) {</span>
<span class="fc" id="L929">                    array[0] = null;</span>
                }
            } else {
<span class="fc bfc" id="L932" title="All 2 branches covered.">                if (array.length &lt; s) {</span>
<span class="fc" id="L933">                    array = (T[])Array.newInstance(array.getClass().getComponentType(), s);</span>
                }

<span class="fc" id="L936">                int i = 0;</span>
<span class="fc bfc" id="L937" title="All 2 branches covered.">                while (i != s) {</span>
<span class="fc" id="L938">                    Node&lt;Object&gt; next = h.get();</span>
<span class="fc" id="L939">                    array[i] = (T)next.value;</span>
<span class="fc" id="L940">                    i++;</span>
<span class="fc" id="L941">                    h = next;</span>
<span class="fc" id="L942">                }</span>
<span class="fc bfc" id="L943" title="All 2 branches covered.">                if (array.length &gt; s) {</span>
<span class="fc" id="L944">                    array[s] = null;</span>
                }
            }

<span class="fc" id="L948">            return array;</span>
        }

        @Override
        @SuppressWarnings(&quot;unchecked&quot;)
        public void replay(ReplayDisposable&lt;T&gt; rs) {
<span class="fc bfc" id="L954" title="All 2 branches covered.">            if (rs.getAndIncrement() != 0) {</span>
<span class="fc" id="L955">                return;</span>
            }

<span class="fc" id="L958">            int missed = 1;</span>
<span class="fc" id="L959">            final Observer&lt;? super T&gt; a = rs.downstream;</span>

<span class="fc" id="L961">            Node&lt;Object&gt; index = (Node&lt;Object&gt;)rs.index;</span>
<span class="fc bfc" id="L962" title="All 2 branches covered.">            if (index == null) {</span>
<span class="fc" id="L963">                index = head;</span>
            }

            for (;;) {

                for (;;) {
<span class="fc bfc" id="L969" title="All 2 branches covered.">                    if (rs.cancelled) {</span>
<span class="fc" id="L970">                        rs.index = null;</span>
<span class="fc" id="L971">                        return;</span>
                    }

<span class="fc" id="L974">                    Node&lt;Object&gt; n = index.get();</span>

<span class="fc bfc" id="L976" title="All 2 branches covered.">                    if (n == null) {</span>
<span class="fc" id="L977">                        break;</span>
                    }

<span class="fc" id="L980">                    Object o = n.value;</span>

<span class="fc bfc" id="L982" title="All 2 branches covered.">                    if (done) {</span>
<span class="fc bfc" id="L983" title="All 2 branches covered.">                        if (n.get() == null) {</span>

<span class="fc bfc" id="L985" title="All 2 branches covered.">                            if (NotificationLite.isComplete(o)) {</span>
<span class="fc" id="L986">                                a.onComplete();</span>
                            } else {
<span class="fc" id="L988">                                a.onError(NotificationLite.getError(o));</span>
                            }
<span class="fc" id="L990">                            rs.index = null;</span>
<span class="fc" id="L991">                            rs.cancelled = true;</span>
<span class="fc" id="L992">                            return;</span>
                        }
                    }

<span class="fc" id="L996">                    a.onNext((T)o);</span>

<span class="fc" id="L998">                    index = n;</span>
<span class="fc" id="L999">                }</span>

<span class="fc bfc" id="L1001" title="All 2 branches covered.">                if (index.get() != null) {</span>
<span class="fc" id="L1002">                    continue;</span>
                }

<span class="fc" id="L1005">                rs.index = index;</span>

<span class="fc" id="L1007">                missed = rs.addAndGet(-missed);</span>
<span class="fc bfc" id="L1008" title="All 2 branches covered.">                if (missed == 0) {</span>
<span class="fc" id="L1009">                    break;</span>
                }
            }
<span class="fc" id="L1012">        }</span>

        @Override
        public int size() {
<span class="fc" id="L1016">            int s = 0;</span>
<span class="fc" id="L1017">            Node&lt;Object&gt; h = head;</span>
<span class="pc bpc" id="L1018" title="1 of 2 branches missed.">            while (s != Integer.MAX_VALUE) {</span>
<span class="fc" id="L1019">                Node&lt;Object&gt; next = h.get();</span>
<span class="fc bfc" id="L1020" title="All 2 branches covered.">                if (next == null) {</span>
<span class="fc" id="L1021">                    Object o = h.value;</span>
<span class="fc bfc" id="L1022" title="All 4 branches covered.">                    if (NotificationLite.isComplete(o) || NotificationLite.isError(o)) {</span>
<span class="fc" id="L1023">                        s--;</span>
                    }
                    break;
                }
<span class="fc" id="L1027">                s++;</span>
<span class="fc" id="L1028">                h = next;</span>
<span class="fc" id="L1029">            }</span>

<span class="fc" id="L1031">            return s;</span>
        }
    }

    static final class SizeAndTimeBoundReplayBuffer&lt;T&gt;
    extends AtomicReference&lt;Object&gt;
    implements ReplayBuffer&lt;T&gt; {

        private static final long serialVersionUID = -8056260896137901749L;

        final int maxSize;
        final long maxAge;
        final TimeUnit unit;
        final Scheduler scheduler;
        int size;

        volatile TimedNode&lt;Object&gt; head;

        TimedNode&lt;Object&gt; tail;

        volatile boolean done;

<span class="fc" id="L1053">        SizeAndTimeBoundReplayBuffer(int maxSize, long maxAge, TimeUnit unit, Scheduler scheduler) {</span>
<span class="fc" id="L1054">            this.maxSize = ObjectHelper.verifyPositive(maxSize, &quot;maxSize&quot;);</span>
<span class="fc" id="L1055">            this.maxAge = ObjectHelper.verifyPositive(maxAge, &quot;maxAge&quot;);</span>
<span class="fc" id="L1056">            this.unit = ObjectHelper.requireNonNull(unit, &quot;unit is null&quot;);</span>
<span class="fc" id="L1057">            this.scheduler = ObjectHelper.requireNonNull(scheduler, &quot;scheduler is null&quot;);</span>
<span class="fc" id="L1058">            TimedNode&lt;Object&gt; h = new TimedNode&lt;Object&gt;(null, 0L);</span>
<span class="fc" id="L1059">            this.tail = h;</span>
<span class="fc" id="L1060">            this.head = h;</span>
<span class="fc" id="L1061">        }</span>

        void trim() {
<span class="fc bfc" id="L1064" title="All 2 branches covered.">            if (size &gt; maxSize) {</span>
<span class="fc" id="L1065">                size--;</span>
<span class="fc" id="L1066">                TimedNode&lt;Object&gt; h = head;</span>
<span class="fc" id="L1067">                head = h.get();</span>
            }
<span class="fc" id="L1069">            long limit = scheduler.now(unit) - maxAge;</span>

<span class="fc" id="L1071">            TimedNode&lt;Object&gt; h = head;</span>

            for (;;) {
<span class="fc" id="L1074">                TimedNode&lt;Object&gt; next = h.get();</span>
<span class="fc bfc" id="L1075" title="All 2 branches covered.">                if (next == null) {</span>
<span class="fc" id="L1076">                    head = h;</span>
<span class="fc" id="L1077">                    break;</span>
                }

<span class="fc bfc" id="L1080" title="All 2 branches covered.">                if (next.time &gt; limit) {</span>
<span class="fc" id="L1081">                    head = h;</span>
<span class="fc" id="L1082">                    break;</span>
                }

<span class="fc" id="L1085">                h = next;</span>
<span class="fc" id="L1086">            }</span>

<span class="fc" id="L1088">        }</span>

        void trimFinal() {
<span class="fc" id="L1091">            long limit = scheduler.now(unit) - maxAge;</span>

<span class="fc" id="L1093">            TimedNode&lt;Object&gt; h = head;</span>

            for (;;) {
<span class="fc" id="L1096">                TimedNode&lt;Object&gt; next = h.get();</span>
<span class="fc bfc" id="L1097" title="All 2 branches covered.">                if (next.get() == null) {</span>
<span class="fc bfc" id="L1098" title="All 2 branches covered.">                    if (h.value != null) {</span>
<span class="fc" id="L1099">                        TimedNode&lt;Object&gt; lasth = new TimedNode&lt;Object&gt;(null, 0L);</span>
<span class="fc" id="L1100">                        lasth.lazySet(h.get());</span>
<span class="fc" id="L1101">                        head = lasth;</span>
<span class="fc" id="L1102">                    } else {</span>
<span class="fc" id="L1103">                        head = h;</span>
                    }
<span class="fc" id="L1105">                    break;</span>
                }

<span class="fc bfc" id="L1108" title="All 2 branches covered.">                if (next.time &gt; limit) {</span>
<span class="fc bfc" id="L1109" title="All 2 branches covered.">                    if (h.value != null) {</span>
<span class="fc" id="L1110">                        TimedNode&lt;Object&gt; lasth = new TimedNode&lt;Object&gt;(null, 0L);</span>
<span class="fc" id="L1111">                        lasth.lazySet(h.get());</span>
<span class="fc" id="L1112">                        head = lasth;</span>
<span class="fc" id="L1113">                    } else {</span>
<span class="fc" id="L1114">                        head = h;</span>
                    }
<span class="fc" id="L1116">                    break;</span>
                }

<span class="fc" id="L1119">                h = next;</span>
<span class="fc" id="L1120">            }</span>
<span class="fc" id="L1121">        }</span>

        @Override
        public void add(T value) {
<span class="fc" id="L1125">            TimedNode&lt;Object&gt; n = new TimedNode&lt;Object&gt;(value, scheduler.now(unit));</span>
<span class="fc" id="L1126">            TimedNode&lt;Object&gt; t = tail;</span>

<span class="fc" id="L1128">            tail = n;</span>
<span class="fc" id="L1129">            size++;</span>
<span class="fc" id="L1130">            t.set(n); // releases both the tail and size</span>

<span class="fc" id="L1132">            trim();</span>
<span class="fc" id="L1133">        }</span>

        @Override
        public void addFinal(Object notificationLite) {
<span class="fc" id="L1137">            TimedNode&lt;Object&gt; n = new TimedNode&lt;Object&gt;(notificationLite, Long.MAX_VALUE);</span>
<span class="fc" id="L1138">            TimedNode&lt;Object&gt; t = tail;</span>

<span class="fc" id="L1140">            tail = n;</span>
<span class="fc" id="L1141">            size++;</span>
<span class="fc" id="L1142">            t.lazySet(n); // releases both the tail and size</span>
<span class="fc" id="L1143">            trimFinal();</span>

<span class="fc" id="L1145">            done = true;</span>
<span class="fc" id="L1146">        }</span>

        /**
         * Replace a non-empty head node with an empty one to
         * allow the GC of the inaccessible old value.
         */
        @Override
        public void trimHead() {
<span class="fc" id="L1154">            TimedNode&lt;Object&gt; h = head;</span>
<span class="fc bfc" id="L1155" title="All 2 branches covered.">            if (h.value != null) {</span>
<span class="fc" id="L1156">                TimedNode&lt;Object&gt; n = new TimedNode&lt;Object&gt;(null, 0);</span>
<span class="fc" id="L1157">                n.lazySet(h.get());</span>
<span class="fc" id="L1158">                head = n;</span>
            }
<span class="fc" id="L1160">        }</span>

        @Override
        @Nullable
        @SuppressWarnings(&quot;unchecked&quot;)
        public T getValue() {
<span class="fc" id="L1166">            TimedNode&lt;Object&gt; prev = null;</span>
<span class="fc" id="L1167">            TimedNode&lt;Object&gt; h = head;</span>

            for (;;) {
<span class="fc" id="L1170">                TimedNode&lt;Object&gt; next = h.get();</span>
<span class="fc bfc" id="L1171" title="All 2 branches covered.">                if (next == null) {</span>
<span class="fc" id="L1172">                    break;</span>
                }
<span class="fc" id="L1174">                prev = h;</span>
<span class="fc" id="L1175">                h = next;</span>
<span class="fc" id="L1176">            }</span>

<span class="fc" id="L1178">            long limit = scheduler.now(unit) - maxAge;</span>
<span class="fc bfc" id="L1179" title="All 2 branches covered.">            if (h.time &lt; limit) {</span>
<span class="fc" id="L1180">                return null;</span>
            }

<span class="fc" id="L1183">            Object v = h.value;</span>
<span class="fc bfc" id="L1184" title="All 2 branches covered.">            if (v == null) {</span>
<span class="fc" id="L1185">                return null;</span>
            }
<span class="fc bfc" id="L1187" title="All 4 branches covered.">            if (NotificationLite.isComplete(v) || NotificationLite.isError(v)) {</span>
<span class="fc" id="L1188">                return (T)prev.value;</span>
            }

<span class="fc" id="L1191">            return (T)v;</span>
        }

        TimedNode&lt;Object&gt; getHead() {
<span class="fc" id="L1195">            TimedNode&lt;Object&gt; index = head;</span>
            // skip old entries
<span class="fc" id="L1197">            long limit = scheduler.now(unit) - maxAge;</span>
<span class="fc" id="L1198">            TimedNode&lt;Object&gt; next = index.get();</span>
<span class="fc bfc" id="L1199" title="All 2 branches covered.">            while (next != null) {</span>
<span class="fc" id="L1200">                long ts = next.time;</span>
<span class="fc bfc" id="L1201" title="All 2 branches covered.">                if (ts &gt; limit) {</span>
<span class="fc" id="L1202">                    break;</span>
                }
<span class="fc" id="L1204">                index = next;</span>
<span class="fc" id="L1205">                next = index.get();</span>
<span class="fc" id="L1206">            }</span>
<span class="fc" id="L1207">            return index;</span>
        }

        @Override
        @SuppressWarnings(&quot;unchecked&quot;)
        public T[] getValues(T[] array) {
<span class="fc" id="L1213">            TimedNode&lt;Object&gt; h = getHead();</span>
<span class="fc" id="L1214">            int s = size(h);</span>

<span class="fc bfc" id="L1216" title="All 2 branches covered.">            if (s == 0) {</span>
<span class="fc bfc" id="L1217" title="All 2 branches covered.">                if (array.length != 0) {</span>
<span class="fc" id="L1218">                    array[0] = null;</span>
                }
            } else {
<span class="fc bfc" id="L1221" title="All 2 branches covered.">                if (array.length &lt; s) {</span>
<span class="fc" id="L1222">                    array = (T[])Array.newInstance(array.getClass().getComponentType(), s);</span>
                }

<span class="fc" id="L1225">                int i = 0;</span>
<span class="fc bfc" id="L1226" title="All 2 branches covered.">                while (i != s) {</span>
<span class="fc" id="L1227">                    TimedNode&lt;Object&gt; next = h.get();</span>
<span class="fc" id="L1228">                    array[i] = (T)next.value;</span>
<span class="fc" id="L1229">                    i++;</span>
<span class="fc" id="L1230">                    h = next;</span>
<span class="fc" id="L1231">                }</span>
<span class="fc bfc" id="L1232" title="All 2 branches covered.">                if (array.length &gt; s) {</span>
<span class="fc" id="L1233">                    array[s] = null;</span>
                }
            }

<span class="fc" id="L1237">            return array;</span>
        }

        @Override
        @SuppressWarnings(&quot;unchecked&quot;)
        public void replay(ReplayDisposable&lt;T&gt; rs) {
<span class="fc bfc" id="L1243" title="All 2 branches covered.">            if (rs.getAndIncrement() != 0) {</span>
<span class="fc" id="L1244">                return;</span>
            }

<span class="fc" id="L1247">            int missed = 1;</span>
<span class="fc" id="L1248">            final Observer&lt;? super T&gt; a = rs.downstream;</span>

<span class="fc" id="L1250">            TimedNode&lt;Object&gt; index = (TimedNode&lt;Object&gt;)rs.index;</span>
<span class="fc bfc" id="L1251" title="All 2 branches covered.">            if (index == null) {</span>
<span class="fc" id="L1252">                index = getHead();</span>
            }

            for (;;) {

<span class="pc bpc" id="L1257" title="1 of 2 branches missed.">                if (rs.cancelled) {</span>
<span class="nc" id="L1258">                    rs.index = null;</span>
<span class="nc" id="L1259">                    return;</span>
                }

                for (;;) {
<span class="fc bfc" id="L1263" title="All 2 branches covered.">                    if (rs.cancelled) {</span>
<span class="fc" id="L1264">                        rs.index = null;</span>
<span class="fc" id="L1265">                        return;</span>
                    }

<span class="fc" id="L1268">                    TimedNode&lt;Object&gt; n = index.get();</span>

<span class="fc bfc" id="L1270" title="All 2 branches covered.">                    if (n == null) {</span>
<span class="fc" id="L1271">                        break;</span>
                    }

<span class="fc" id="L1274">                    Object o = n.value;</span>

<span class="fc bfc" id="L1276" title="All 2 branches covered.">                    if (done) {</span>
<span class="fc bfc" id="L1277" title="All 2 branches covered.">                        if (n.get() == null) {</span>

<span class="fc bfc" id="L1279" title="All 2 branches covered.">                            if (NotificationLite.isComplete(o)) {</span>
<span class="fc" id="L1280">                                a.onComplete();</span>
                            } else {
<span class="fc" id="L1282">                                a.onError(NotificationLite.getError(o));</span>
                            }
<span class="fc" id="L1284">                            rs.index = null;</span>
<span class="fc" id="L1285">                            rs.cancelled = true;</span>
<span class="fc" id="L1286">                            return;</span>
                        }
                    }

<span class="fc" id="L1290">                    a.onNext((T)o);</span>

<span class="fc" id="L1292">                    index = n;</span>
<span class="fc" id="L1293">                }</span>

<span class="pc bpc" id="L1295" title="1 of 2 branches missed.">                if (index.get() != null) {</span>
<span class="nc" id="L1296">                    continue;</span>
                }

<span class="fc" id="L1299">                rs.index = index;</span>

<span class="fc" id="L1301">                missed = rs.addAndGet(-missed);</span>
<span class="fc bfc" id="L1302" title="All 2 branches covered.">                if (missed == 0) {</span>
<span class="fc" id="L1303">                    break;</span>
                }
            }
<span class="fc" id="L1306">        }</span>

        @Override
        public int size() {
<span class="fc" id="L1310">            return size(getHead());</span>
        }

        int size(TimedNode&lt;Object&gt; h) {
<span class="fc" id="L1314">            int s = 0;</span>
<span class="pc bpc" id="L1315" title="1 of 2 branches missed.">            while (s != Integer.MAX_VALUE) {</span>
<span class="fc" id="L1316">                TimedNode&lt;Object&gt; next = h.get();</span>
<span class="fc bfc" id="L1317" title="All 2 branches covered.">                if (next == null) {</span>
<span class="fc" id="L1318">                    Object o = h.value;</span>
<span class="fc bfc" id="L1319" title="All 4 branches covered.">                    if (NotificationLite.isComplete(o) || NotificationLite.isError(o)) {</span>
<span class="fc" id="L1320">                        s--;</span>
                    }
                    break;
                }
<span class="fc" id="L1324">                s++;</span>
<span class="fc" id="L1325">                h = next;</span>
<span class="fc" id="L1326">            }</span>

<span class="fc" id="L1328">            return s;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>