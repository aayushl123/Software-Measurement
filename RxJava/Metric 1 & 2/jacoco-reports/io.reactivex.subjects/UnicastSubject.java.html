<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>UnicastSubject.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">RxJava_2_x$Unnamed.exec</a> &gt; <a href="index.source.html" class="el_package">io.reactivex.subjects</a> &gt; <span class="el_source">UnicastSubject.java</span></div><h1>UnicastSubject.java</h1><pre class="source lang-java linenums">/**
 * Copyright (c) 2016-present, RxJava Contributors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is
 * distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
 * the License for the specific language governing permissions and limitations under the License.
 */

package io.reactivex.subjects;

import io.reactivex.annotations.Nullable;
import io.reactivex.annotations.NonNull;
import io.reactivex.plugins.RxJavaPlugins;

import java.util.concurrent.atomic.*;

import io.reactivex.*;
import io.reactivex.annotations.CheckReturnValue;
import io.reactivex.disposables.Disposable;
import io.reactivex.internal.disposables.EmptyDisposable;
import io.reactivex.internal.functions.ObjectHelper;
import io.reactivex.internal.fuseable.SimpleQueue;
import io.reactivex.internal.observers.BasicIntQueueDisposable;
import io.reactivex.internal.queue.SpscLinkedArrayQueue;

/**
 * A Subject that queues up events until a single {@link Observer} subscribes to it, replays
 * those events to it until the {@code Observer} catches up and then switches to relaying events live to
 * this single {@code Observer} until this {@code UnicastSubject} terminates or the {@code Observer} unsubscribes.
 * &lt;p&gt;
 * &lt;img width=&quot;640&quot; height=&quot;370&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/UnicastSubject.png&quot; alt=&quot;&quot;&gt;
 * &lt;p&gt;
 * Note that {@code UnicastSubject} holds an unbounded internal buffer.
 * &lt;p&gt;
 * This subject does not have a public constructor by design; a new empty instance of this
 * {@code UnicastSubject} can be created via the following {@code create} methods that
 * allow specifying the retention policy for items:
 * &lt;ul&gt;
 * &lt;li&gt;{@link #create()} - creates an empty, unbounded {@code UnicastSubject} that
 *     caches all items and the terminal event it receives.&lt;/li&gt;
 * &lt;li&gt;{@link #create(int)} - creates an empty, unbounded {@code UnicastSubject}
 *     with a hint about how many &lt;b&gt;total&lt;/b&gt; items one expects to retain.&lt;/li&gt;
 * &lt;li&gt;{@link #create(boolean)} - creates an empty, unbounded {@code UnicastSubject} that
 *     optionally delays an error it receives and replays it after the regular items have been emitted.&lt;/li&gt;
 * &lt;li&gt;{@link #create(int, Runnable)} - creates an empty, unbounded {@code UnicastSubject}
 *     with a hint about how many &lt;b&gt;total&lt;/b&gt; items one expects to retain and a callback that will be
 *     called exactly once when the {@code UnicastSubject} gets terminated or the single {@code Observer} unsubscribes.&lt;/li&gt;
 * &lt;li&gt;{@link #create(int, Runnable, boolean)} - creates an empty, unbounded {@code UnicastSubject}
 *     with a hint about how many &lt;b&gt;total&lt;/b&gt; items one expects to retain and a callback that will be
 *     called exactly once when the {@code UnicastSubject} gets terminated or the single {@code Observer} unsubscribes
 *     and optionally delays an error it receives and replays it after the regular items have been emitted.&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;p&gt;
 * If more than one {@code Observer} attempts to subscribe to this {@code UnicastSubject}, they
 * will receive an {@code IllegalStateException} indicating the single-use-only nature of this {@code UnicastSubject},
 * even if the {@code UnicastSubject} already terminated with an error.
 * &lt;p&gt;
 * Since a {@code Subject} is conceptionally derived from the {@code Processor} type in the Reactive Streams specification,
 * {@code null}s are not allowed (&lt;a href=&quot;https://github.com/reactive-streams/reactive-streams-jvm#2.13&quot;&gt;Rule 2.13&lt;/a&gt;) as
 * parameters to {@link #onNext(Object)} and {@link #onError(Throwable)}. Such calls will result in a
 * {@link NullPointerException} being thrown and the subject's state is not changed.
 * &lt;p&gt;
 * Since a {@code UnicastSubject} is an {@link io.reactivex.Observable}, it does not support backpressure.
 * &lt;p&gt;
 * When this {@code UnicastSubject} is terminated via {@link #onError(Throwable)} the current or late single {@code Observer}
 * may receive the {@code Throwable} before any available items could be emitted. To make sure an onError event is delivered
 * to the {@code Observer} after the normal items, create a {@code UnicastSubject} with the {@link #create(boolean)} or
 * {@link #create(int, Runnable, boolean)} factory methods.
 * &lt;p&gt;
 * Even though {@code UnicastSubject} implements the {@code Observer} interface, calling
 * {@code onSubscribe} is not required (&lt;a href=&quot;https://github.com/reactive-streams/reactive-streams-jvm#2.12&quot;&gt;Rule 2.12&lt;/a&gt;)
 * if the subject is used as a standalone source. However, calling {@code onSubscribe}
 * after the {@code UnicastSubject} reached its terminal state will result in the
 * given {@code Disposable} being disposed immediately.
 * &lt;p&gt;
 * Calling {@link #onNext(Object)}, {@link #onError(Throwable)} and {@link #onComplete()}
 * is required to be serialized (called from the same thread or called non-overlappingly from different threads
 * through external means of serialization). The {@link #toSerialized()} method available to all {@code Subject}s
 * provides such serialization and also protects against reentrance (i.e., when a downstream {@code Observer}
 * consuming this subject also wants to call {@link #onNext(Object)} on this subject recursively).
 * &lt;p&gt;
 * This {@code UnicastSubject} supports the standard state-peeking methods {@link #hasComplete()}, {@link #hasThrowable()},
 * {@link #getThrowable()} and {@link #hasObservers()}.
 * &lt;dl&gt;
 *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
 *  &lt;dd&gt;{@code UnicastSubject} does not operate by default on a particular {@link io.reactivex.Scheduler} and
 *  the single {@code Observer} gets notified on the thread the respective {@code onXXX} methods were invoked.&lt;/dd&gt;
 *  &lt;dt&gt;&lt;b&gt;Error handling:&lt;/b&gt;&lt;/dt&gt;
 *  &lt;dd&gt;When the {@link #onError(Throwable)} is called, the {@code UnicastSubject} enters into a terminal state
 *  and emits the same {@code Throwable} instance to the current single {@code Observer}. During this emission,
 *  if the single {@code Observer}s disposes its respective {@code Disposable}, the
 *  {@code Throwable} is delivered to the global error handler via
 *  {@link io.reactivex.plugins.RxJavaPlugins#onError(Throwable)}.
 *  If there were no {@code Observer}s subscribed to this {@code UnicastSubject} when the {@code onError()}
 *  was called, the global error handler is not invoked.
 *  &lt;/dd&gt;
 * &lt;/dl&gt;
 * &lt;p&gt;
 * Example usage:
 * &lt;pre&gt;&lt;code&gt;
 * UnicastSubject&amp;lt;Integer&amp;gt; subject = UnicastSubject.create();
 *
 * TestObserver&amp;lt;Integer&amp;gt; to1 = subject.test();
 *
 * // fresh UnicastSubjects are empty
 * to1.assertEmpty();
 *
 * TestObserver&amp;lt;Integer&amp;gt; to2 = subject.test();
 *
 * // A UnicastSubject only allows one Observer during its lifetime
 * to2.assertFailure(IllegalStateException.class);
 *
 * subject.onNext(1);
 * to1.assertValue(1);
 *
 * subject.onNext(2);
 * to1.assertValues(1, 2);
 *
 * subject.onComplete();
 * to1.assertResult(1, 2);
 *
 * // ----------------------------------------------------
 *
 * UnicastSubject&amp;lt;Integer&amp;gt; subject2 = UnicastSubject.create();
 *
 * // a UnicastSubject caches events until its single Observer subscribes
 * subject2.onNext(1);
 * subject2.onNext(2);
 * subject2.onComplete();
 *
 * TestObserver&amp;lt;Integer&amp;gt; to3 = subject2.test();
 *
 * // the cached events are emitted in order
 * to3.assertResult(1, 2);
 * &lt;/code&gt;&lt;/pre&gt;
 * @param &lt;T&gt; the value type received and emitted by this Subject subclass
 * @since 2.0
 */
public final class UnicastSubject&lt;T&gt; extends Subject&lt;T&gt; {
    /** The queue that buffers the source events. */
    final SpscLinkedArrayQueue&lt;T&gt; queue;

    /** The single Observer. */
    final AtomicReference&lt;Observer&lt;? super T&gt;&gt; downstream;

    /** The optional callback when the Subject gets cancelled or terminates. */
    final AtomicReference&lt;Runnable&gt; onTerminate;

    /** deliver onNext events before error event. */
    final boolean delayError;

    /** Indicates the single observer has cancelled. */
    volatile boolean disposed;

    /** Indicates the source has terminated. */
    volatile boolean done;
    /**
     * The terminal error if not null.
     * Must be set before writing to done and read after done == true.
     */
    Throwable error;

    /** Set to 1 atomically for the first and only Subscriber. */
    final AtomicBoolean once;

    /** The wip counter and QueueDisposable surface. */
    final BasicIntQueueDisposable&lt;T&gt; wip;

    boolean enableOperatorFusion;

    /**
     * Creates an UnicastSubject with an internal buffer capacity hint 16.
     * @param &lt;T&gt; the value type
     * @return an UnicastSubject instance
     */
    @CheckReturnValue
    @NonNull
    public static &lt;T&gt; UnicastSubject&lt;T&gt; create() {
<span class="fc" id="L184">        return new UnicastSubject&lt;T&gt;(bufferSize(), true);</span>
    }

    /**
     * Creates an UnicastSubject with the given internal buffer capacity hint.
     * @param &lt;T&gt; the value type
     * @param capacityHint the hint to size the internal unbounded buffer
     * @return an UnicastSubject instance
     */
    @CheckReturnValue
    @NonNull
    public static &lt;T&gt; UnicastSubject&lt;T&gt; create(int capacityHint) {
<span class="fc" id="L196">        return new UnicastSubject&lt;T&gt;(capacityHint, true);</span>
    }

    /**
     * Creates an UnicastSubject with the given internal buffer capacity hint and a callback for
     * the case when the single Subscriber cancels its subscription.
     *
     * &lt;p&gt;The callback, if not null, is called exactly once and
     * non-overlapped with any active replay.
     *
     * @param &lt;T&gt; the value type
     * @param capacityHint the hint to size the internal unbounded buffer
     * @param onTerminate the callback to run when the Subject is terminated or cancelled, null not allowed
     * @return an UnicastSubject instance
     */
    @CheckReturnValue
    @NonNull
    public static &lt;T&gt; UnicastSubject&lt;T&gt; create(int capacityHint, Runnable onTerminate) {
<span class="fc" id="L214">        return new UnicastSubject&lt;T&gt;(capacityHint, onTerminate, true);</span>
    }

    /**
     * Creates an UnicastSubject with the given internal buffer capacity hint, delay error flag and
     * a callback for the case when the single Subscriber cancels its subscription.
     *
     * &lt;p&gt;The callback, if not null, is called exactly once and
     * non-overlapped with any active replay.
     * &lt;p&gt;History: 2.0.8 - experimental
     * @param &lt;T&gt; the value type
     * @param capacityHint the hint to size the internal unbounded buffer
     * @param onTerminate the callback to run when the Subject is terminated or cancelled, null not allowed
     * @param delayError deliver pending onNext events before onError
     * @return an UnicastSubject instance
     * @since 2.2
     */
    @CheckReturnValue
    @NonNull
    public static &lt;T&gt; UnicastSubject&lt;T&gt; create(int capacityHint, Runnable onTerminate, boolean delayError) {
<span class="fc" id="L234">        return new UnicastSubject&lt;T&gt;(capacityHint, onTerminate, delayError);</span>
    }

    /**
     * Creates an UnicastSubject with an internal buffer capacity hint 16 and given delay error flag.
     *
     * &lt;p&gt;The callback, if not null, is called exactly once and
     * non-overlapped with any active replay.
     * &lt;p&gt;History: 2.0.8 - experimental
     * @param &lt;T&gt; the value type
     * @param delayError deliver pending onNext events before onError
     * @return an UnicastSubject instance
     * @since 2.2
     */
    @CheckReturnValue
    @NonNull
    public static &lt;T&gt; UnicastSubject&lt;T&gt; create(boolean delayError) {
<span class="fc" id="L251">        return new UnicastSubject&lt;T&gt;(bufferSize(), delayError);</span>
    }

    /**
     * Creates an UnicastSubject with the given capacity hint and delay error flag.
     * &lt;p&gt;History: 2.0.8 - experimental
     * @param capacityHint the capacity hint for the internal, unbounded queue
     * @param delayError deliver pending onNext events before onError
     * @since 2.2
     */
<span class="fc" id="L261">    UnicastSubject(int capacityHint, boolean delayError) {</span>
<span class="fc" id="L262">        this.queue = new SpscLinkedArrayQueue&lt;T&gt;(ObjectHelper.verifyPositive(capacityHint, &quot;capacityHint&quot;));</span>
<span class="fc" id="L263">        this.onTerminate = new AtomicReference&lt;Runnable&gt;();</span>
<span class="fc" id="L264">        this.delayError = delayError;</span>
<span class="fc" id="L265">        this.downstream = new AtomicReference&lt;Observer&lt;? super T&gt;&gt;();</span>
<span class="fc" id="L266">        this.once = new AtomicBoolean();</span>
<span class="fc" id="L267">        this.wip = new UnicastQueueDisposable();</span>
<span class="fc" id="L268">    }</span>

    /**
     * Creates an UnicastSubject with the given capacity hint and callback
     * for when the Subject is terminated normally or its single Subscriber cancels.
     * @param capacityHint the capacity hint for the internal, unbounded queue
     * @param onTerminate the callback to run when the Subject is terminated or cancelled, null not allowed
     * @since 2.0
     *
     * */
    UnicastSubject(int capacityHint, Runnable onTerminate) {
<span class="fc" id="L279">        this(capacityHint, onTerminate, true);</span>
<span class="fc" id="L280">    }</span>

    /**
     * Creates an UnicastSubject with the given capacity hint, delay error flag and callback
     * for when the Subject is terminated normally or its single Subscriber cancels.
     * &lt;p&gt;History: 2.0.8 - experimental
     * @param capacityHint the capacity hint for the internal, unbounded queue
     * @param onTerminate the callback to run when the Subject is terminated or cancelled, null not allowed
     * @param delayError deliver pending onNext events before onError
     * @since 2.2
     */
<span class="fc" id="L291">    UnicastSubject(int capacityHint, Runnable onTerminate, boolean delayError) {</span>
<span class="fc" id="L292">        this.queue = new SpscLinkedArrayQueue&lt;T&gt;(ObjectHelper.verifyPositive(capacityHint, &quot;capacityHint&quot;));</span>
<span class="fc" id="L293">        this.onTerminate = new AtomicReference&lt;Runnable&gt;(ObjectHelper.requireNonNull(onTerminate, &quot;onTerminate&quot;));</span>
<span class="fc" id="L294">        this.delayError = delayError;</span>
<span class="fc" id="L295">        this.downstream = new AtomicReference&lt;Observer&lt;? super T&gt;&gt;();</span>
<span class="fc" id="L296">        this.once = new AtomicBoolean();</span>
<span class="fc" id="L297">        this.wip = new UnicastQueueDisposable();</span>
<span class="fc" id="L298">    }</span>

    @Override
    protected void subscribeActual(Observer&lt;? super T&gt; observer) {
<span class="fc bfc" id="L302" title="All 4 branches covered.">        if (!once.get() &amp;&amp; once.compareAndSet(false, true)) {</span>
<span class="fc" id="L303">            observer.onSubscribe(wip);</span>
<span class="fc" id="L304">            downstream.lazySet(observer); // full barrier in drain</span>
<span class="fc bfc" id="L305" title="All 2 branches covered.">            if (disposed) {</span>
<span class="fc" id="L306">                downstream.lazySet(null);</span>
<span class="fc" id="L307">                return;</span>
            }
<span class="fc" id="L309">            drain();</span>
        } else {
<span class="fc" id="L311">            EmptyDisposable.error(new IllegalStateException(&quot;Only a single observer allowed.&quot;), observer);</span>
        }
<span class="fc" id="L313">    }</span>

    void doTerminate() {
<span class="fc" id="L316">        Runnable r = onTerminate.get();</span>
<span class="fc bfc" id="L317" title="All 4 branches covered.">        if (r != null &amp;&amp; onTerminate.compareAndSet(r, null)) {</span>
<span class="fc" id="L318">            r.run();</span>
        }
<span class="fc" id="L320">    }</span>

    @Override
    public void onSubscribe(Disposable d) {
<span class="fc bfc" id="L324" title="All 4 branches covered.">        if (done || disposed) {</span>
<span class="fc" id="L325">            d.dispose();</span>
        }
<span class="fc" id="L327">    }</span>

    @Override
    public void onNext(T t) {
<span class="fc" id="L331">        ObjectHelper.requireNonNull(t, &quot;onNext called with null. Null values are generally not allowed in 2.x operators and sources.&quot;);</span>
<span class="fc bfc" id="L332" title="All 4 branches covered.">        if (done || disposed) {</span>
<span class="fc" id="L333">            return;</span>
        }
<span class="fc" id="L335">        queue.offer(t);</span>
<span class="fc" id="L336">        drain();</span>
<span class="fc" id="L337">    }</span>

    @Override
    public void onError(Throwable t) {
<span class="fc" id="L341">        ObjectHelper.requireNonNull(t, &quot;onError called with null. Null values are generally not allowed in 2.x operators and sources.&quot;);</span>
<span class="fc bfc" id="L342" title="All 4 branches covered.">        if (done || disposed) {</span>
<span class="fc" id="L343">            RxJavaPlugins.onError(t);</span>
<span class="fc" id="L344">            return;</span>
        }
<span class="fc" id="L346">        error = t;</span>
<span class="fc" id="L347">        done = true;</span>

<span class="fc" id="L349">        doTerminate();</span>

<span class="fc" id="L351">        drain();</span>
<span class="fc" id="L352">    }</span>

    @Override
    public void onComplete() {
<span class="fc bfc" id="L356" title="All 4 branches covered.">        if (done || disposed) {</span>
<span class="fc" id="L357">            return;</span>
        }
<span class="fc" id="L359">        done = true;</span>

<span class="fc" id="L361">        doTerminate();</span>

<span class="fc" id="L363">        drain();</span>
<span class="fc" id="L364">    }</span>

    void drainNormal(Observer&lt;? super T&gt; a) {
<span class="fc" id="L367">        int missed = 1;</span>
<span class="fc" id="L368">        SimpleQueue&lt;T&gt; q = queue;</span>
<span class="fc bfc" id="L369" title="All 2 branches covered.">        boolean failFast = !this.delayError;</span>
<span class="fc" id="L370">        boolean canBeError = true;</span>
        for (;;) {
            for (;;) {

<span class="fc bfc" id="L374" title="All 2 branches covered.">                if (disposed) {</span>
<span class="fc" id="L375">                    downstream.lazySet(null);</span>
<span class="fc" id="L376">                    q.clear();</span>
<span class="fc" id="L377">                    return;</span>
                }

<span class="fc" id="L380">                boolean d = this.done;</span>
<span class="fc" id="L381">                T v = queue.poll();</span>
<span class="fc bfc" id="L382" title="All 2 branches covered.">                boolean empty = v == null;</span>

<span class="fc bfc" id="L384" title="All 2 branches covered.">                if (d) {</span>
<span class="fc bfc" id="L385" title="All 4 branches covered.">                    if (failFast &amp;&amp; canBeError) {</span>
<span class="fc bfc" id="L386" title="All 2 branches covered.">                        if (failedFast(q, a)) {</span>
<span class="fc" id="L387">                            return;</span>
                        } else {
<span class="fc" id="L389">                            canBeError = false;</span>
                        }
                    }

<span class="fc bfc" id="L393" title="All 2 branches covered.">                    if (empty) {</span>
<span class="fc" id="L394">                        errorOrComplete(a);</span>
<span class="fc" id="L395">                        return;</span>
                    }
                }

<span class="fc bfc" id="L399" title="All 2 branches covered.">                if (empty) {</span>
<span class="fc" id="L400">                    break;</span>
                }

<span class="fc" id="L403">                a.onNext(v);</span>
<span class="fc" id="L404">            }</span>

<span class="fc" id="L406">            missed = wip.addAndGet(-missed);</span>
<span class="fc bfc" id="L407" title="All 2 branches covered.">            if (missed == 0) {</span>
<span class="fc" id="L408">                break;</span>
            }
        }
<span class="fc" id="L411">    }</span>

    void drainFused(Observer&lt;? super T&gt; a) {
<span class="fc" id="L414">        int missed = 1;</span>

<span class="fc" id="L416">        final SpscLinkedArrayQueue&lt;T&gt; q = queue;</span>
<span class="fc bfc" id="L417" title="All 2 branches covered.">        final boolean failFast = !delayError;</span>

        for (;;) {

<span class="fc bfc" id="L421" title="All 2 branches covered.">            if (disposed) {</span>
<span class="fc" id="L422">                downstream.lazySet(null);</span>
<span class="fc" id="L423">                q.clear();</span>
<span class="fc" id="L424">                return;</span>
            }
<span class="fc" id="L426">            boolean d = done;</span>

<span class="fc bfc" id="L428" title="All 4 branches covered.">            if (failFast &amp;&amp; d) {</span>
<span class="fc bfc" id="L429" title="All 2 branches covered.">                if (failedFast(q, a)) {</span>
<span class="fc" id="L430">                    return;</span>
                }
            }

<span class="fc" id="L434">            a.onNext(null);</span>

<span class="fc bfc" id="L436" title="All 2 branches covered.">            if (d) {</span>
<span class="fc" id="L437">                errorOrComplete(a);</span>
<span class="fc" id="L438">                return;</span>
            }

<span class="fc" id="L441">            missed = wip.addAndGet(-missed);</span>
<span class="fc bfc" id="L442" title="All 2 branches covered.">            if (missed == 0) {</span>
<span class="fc" id="L443">                break;</span>
            }
<span class="fc" id="L445">        }</span>
<span class="fc" id="L446">    }</span>

    void errorOrComplete(Observer&lt;? super T&gt; a) {
<span class="fc" id="L449">        downstream.lazySet(null);</span>
<span class="fc" id="L450">        Throwable ex = error;</span>
<span class="fc bfc" id="L451" title="All 2 branches covered.">        if (ex != null) {</span>
<span class="fc" id="L452">            a.onError(ex);</span>
        } else {
<span class="fc" id="L454">            a.onComplete();</span>
        }
<span class="fc" id="L456">    }</span>

    boolean failedFast(final SimpleQueue&lt;T&gt; q, Observer&lt;? super T&gt; a) {
<span class="fc" id="L459">        Throwable ex = error;</span>
<span class="fc bfc" id="L460" title="All 2 branches covered.">        if (ex != null) {</span>
<span class="fc" id="L461">            downstream.lazySet(null);</span>
<span class="fc" id="L462">            q.clear();</span>
<span class="fc" id="L463">            a.onError(ex);</span>
<span class="fc" id="L464">            return true;</span>
        } else {
<span class="fc" id="L466">            return false;</span>
        }
    }

    void drain() {
<span class="fc bfc" id="L471" title="All 2 branches covered.">        if (wip.getAndIncrement() != 0) {</span>
<span class="fc" id="L472">            return;</span>
        }

<span class="fc" id="L475">        Observer&lt;? super T&gt; a = downstream.get();</span>
<span class="fc" id="L476">        int missed = 1;</span>

        for (;;) {

<span class="fc bfc" id="L480" title="All 2 branches covered.">            if (a != null) {</span>
<span class="fc bfc" id="L481" title="All 2 branches covered.">                if (enableOperatorFusion) {</span>
<span class="fc" id="L482">                    drainFused(a);</span>
                } else {
<span class="fc" id="L484">                    drainNormal(a);</span>
                }
<span class="fc" id="L486">                return;</span>
            }

<span class="fc" id="L489">            missed = wip.addAndGet(-missed);</span>
<span class="fc bfc" id="L490" title="All 2 branches covered.">            if (missed == 0) {</span>
<span class="fc" id="L491">                break;</span>
            }

<span class="fc" id="L494">            a = downstream.get();</span>
        }
<span class="fc" id="L496">    }</span>

    @Override
    public boolean hasObservers() {
<span class="fc bfc" id="L500" title="All 2 branches covered.">        return downstream.get() != null;</span>
    }

    @Override
    @Nullable
    public Throwable getThrowable() {
<span class="fc bfc" id="L506" title="All 2 branches covered.">        if (done) {</span>
<span class="fc" id="L507">            return error;</span>
        }
<span class="fc" id="L509">        return null;</span>
    }

    @Override
    public boolean hasThrowable() {
<span class="fc bfc" id="L514" title="All 4 branches covered.">        return done &amp;&amp; error != null;</span>
    }

    @Override
    public boolean hasComplete() {
<span class="fc bfc" id="L519" title="All 4 branches covered.">        return done &amp;&amp; error == null;</span>
    }

<span class="fc" id="L522">    final class UnicastQueueDisposable extends BasicIntQueueDisposable&lt;T&gt; {</span>

        private static final long serialVersionUID = 7926949470189395511L;

        @Override
        public int requestFusion(int mode) {
<span class="fc bfc" id="L528" title="All 2 branches covered.">            if ((mode &amp; ASYNC) != 0) {</span>
<span class="fc" id="L529">                enableOperatorFusion = true;</span>
<span class="fc" id="L530">                return ASYNC;</span>
            }
<span class="fc" id="L532">            return NONE;</span>
        }

        @Nullable
        @Override
        public T poll() throws Exception {
<span class="fc" id="L538">            return queue.poll();</span>
        }

        @Override
        public boolean isEmpty() {
<span class="fc" id="L543">            return queue.isEmpty();</span>
        }

        @Override
        public void clear() {
<span class="fc" id="L548">            queue.clear();</span>
<span class="fc" id="L549">        }</span>

        @Override
        public void dispose() {
<span class="fc bfc" id="L553" title="All 2 branches covered.">            if (!disposed) {</span>
<span class="fc" id="L554">                disposed = true;</span>

<span class="fc" id="L556">                doTerminate();</span>

<span class="fc" id="L558">                downstream.lazySet(null);</span>
<span class="fc bfc" id="L559" title="All 2 branches covered.">                if (wip.getAndIncrement() == 0) {</span>
<span class="fc" id="L560">                    downstream.lazySet(null);</span>
<span class="fc" id="L561">                    queue.clear();</span>
                }
            }
<span class="fc" id="L564">        }</span>

        @Override
        public boolean isDisposed() {
<span class="fc" id="L568">            return disposed;</span>
        }

    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>