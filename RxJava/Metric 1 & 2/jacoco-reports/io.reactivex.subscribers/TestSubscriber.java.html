<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TestSubscriber.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">RxJava_2_x$Unnamed.exec</a> &gt; <a href="index.source.html" class="el_package">io.reactivex.subscribers</a> &gt; <span class="el_source">TestSubscriber.java</span></div><h1>TestSubscriber.java</h1><pre class="source lang-java linenums">/**
 * Copyright (c) 2016-present, RxJava Contributors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is
 * distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
 * the License for the specific language governing permissions and limitations under the License.
 */
package io.reactivex.subscribers;

import java.util.concurrent.atomic.*;

import org.reactivestreams.*;

import io.reactivex.FlowableSubscriber;
import io.reactivex.disposables.Disposable;
import io.reactivex.functions.Consumer;
import io.reactivex.internal.fuseable.QueueSubscription;
import io.reactivex.internal.subscriptions.SubscriptionHelper;
import io.reactivex.internal.util.ExceptionHelper;
import io.reactivex.observers.BaseTestConsumer;

/**
 * A subscriber that records events and allows making assertions about them.
 *
 * &lt;p&gt;You can override the onSubscribe, onNext, onError, onComplete, request and
 * cancel methods but not the others (this is by design).
 *
 * &lt;p&gt;The TestSubscriber implements Disposable for convenience where dispose calls cancel.
 *
 * &lt;p&gt;When calling the default request method, you are requesting on behalf of the
 * wrapped actual subscriber.
 *
 * @param &lt;T&gt; the value type
 */
public class TestSubscriber&lt;T&gt;
extends BaseTestConsumer&lt;T, TestSubscriber&lt;T&gt;&gt;
implements FlowableSubscriber&lt;T&gt;, Subscription, Disposable {
    /** The actual subscriber to forward events to. */
    private final Subscriber&lt;? super T&gt; downstream;

    /** Makes sure the incoming Subscriptions get cancelled immediately. */
    private volatile boolean cancelled;

    /** Holds the current subscription if any. */
    private final AtomicReference&lt;Subscription&gt; upstream;

    /** Holds the requested amount until a subscription arrives. */
    private final AtomicLong missedRequested;

    private QueueSubscription&lt;T&gt; qs;

    /**
     * Creates a TestSubscriber with Long.MAX_VALUE initial request.
     * @param &lt;T&gt; the value type
     * @return the new TestSubscriber instance.
     */
    public static &lt;T&gt; TestSubscriber&lt;T&gt; create() {
<span class="fc" id="L63">        return new TestSubscriber&lt;T&gt;();</span>
    }

    /**
     * Creates a TestSubscriber with the given initial request.
     * @param &lt;T&gt; the value type
     * @param initialRequested the initial requested amount
     * @return the new TestSubscriber instance.
     */
    public static &lt;T&gt; TestSubscriber&lt;T&gt; create(long initialRequested) {
<span class="fc" id="L73">        return new TestSubscriber&lt;T&gt;(initialRequested);</span>
    }

    /**
     * Constructs a forwarding TestSubscriber.
     * @param &lt;T&gt; the value type received
     * @param delegate the actual Subscriber to forward events to
     * @return the new TestObserver instance
     */
    public static &lt;T&gt; TestSubscriber&lt;T&gt; create(Subscriber&lt;? super T&gt; delegate) {
<span class="fc" id="L83">        return new TestSubscriber&lt;T&gt;(delegate);</span>
    }

    /**
     * Constructs a non-forwarding TestSubscriber with an initial request value of Long.MAX_VALUE.
     */
    public TestSubscriber() {
<span class="fc" id="L90">        this(EmptySubscriber.INSTANCE, Long.MAX_VALUE);</span>
<span class="fc" id="L91">    }</span>

    /**
     * Constructs a non-forwarding TestSubscriber with the specified initial request value.
     * &lt;p&gt;The TestSubscriber doesn't validate the initialRequest value so one can
     * test sources with invalid values as well.
     * @param initialRequest the initial request value
     */
    public TestSubscriber(long initialRequest) {
<span class="fc" id="L100">        this(EmptySubscriber.INSTANCE, initialRequest);</span>
<span class="fc" id="L101">    }</span>

    /**
     * Constructs a forwarding TestSubscriber but leaves the requesting to the wrapped subscriber.
     * @param downstream the actual Subscriber to forward events to
     */
    public TestSubscriber(Subscriber&lt;? super T&gt; downstream) {
<span class="fc" id="L108">        this(downstream, Long.MAX_VALUE);</span>
<span class="fc" id="L109">    }</span>

    /**
     * Constructs a forwarding TestSubscriber with the specified initial request value.
     * &lt;p&gt;The TestSubscriber doesn't validate the initialRequest value so one can
     * test sources with invalid values as well.
     * @param actual the actual Subscriber to forward events to
     * @param initialRequest the initial request value
     */
    public TestSubscriber(Subscriber&lt;? super T&gt; actual, long initialRequest) {
<span class="fc" id="L119">        super();</span>
<span class="fc bfc" id="L120" title="All 2 branches covered.">        if (initialRequest &lt; 0) {</span>
<span class="fc" id="L121">            throw new IllegalArgumentException(&quot;Negative initial request not allowed&quot;);</span>
        }
<span class="fc" id="L123">        this.downstream = actual;</span>
<span class="fc" id="L124">        this.upstream = new AtomicReference&lt;Subscription&gt;();</span>
<span class="fc" id="L125">        this.missedRequested = new AtomicLong(initialRequest);</span>
<span class="fc" id="L126">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    @Override
    public void onSubscribe(Subscription s) {
<span class="fc" id="L131">        lastThread = Thread.currentThread();</span>

<span class="fc bfc" id="L133" title="All 2 branches covered.">        if (s == null) {</span>
<span class="fc" id="L134">            errors.add(new NullPointerException(&quot;onSubscribe received a null Subscription&quot;));</span>
<span class="fc" id="L135">            return;</span>
        }
<span class="fc bfc" id="L137" title="All 2 branches covered.">        if (!upstream.compareAndSet(null, s)) {</span>
<span class="fc" id="L138">            s.cancel();</span>
<span class="fc bfc" id="L139" title="All 2 branches covered.">            if (upstream.get() != SubscriptionHelper.CANCELLED) {</span>
<span class="fc" id="L140">                errors.add(new IllegalStateException(&quot;onSubscribe received multiple subscriptions: &quot; + s));</span>
            }
<span class="fc" id="L142">            return;</span>
        }

<span class="fc bfc" id="L145" title="All 2 branches covered.">        if (initialFusionMode != 0) {</span>
<span class="fc bfc" id="L146" title="All 2 branches covered.">            if (s instanceof QueueSubscription) {</span>
<span class="fc" id="L147">                qs = (QueueSubscription&lt;T&gt;)s;</span>

<span class="fc" id="L149">                int m = qs.requestFusion(initialFusionMode);</span>
<span class="fc" id="L150">                establishedFusionMode = m;</span>

<span class="fc bfc" id="L152" title="All 2 branches covered.">                if (m == QueueSubscription.SYNC) {</span>
<span class="fc" id="L153">                    checkSubscriptionOnce = true;</span>
<span class="fc" id="L154">                    lastThread = Thread.currentThread();</span>
                    try {
                        T t;
<span class="fc bfc" id="L157" title="All 2 branches covered.">                        while ((t = qs.poll()) != null) {</span>
<span class="fc" id="L158">                            values.add(t);</span>
                        }
<span class="fc" id="L160">                        completions++;</span>
<span class="fc" id="L161">                    } catch (Throwable ex) {</span>
                        // Exceptions.throwIfFatal(e); TODO add fatal exceptions?
<span class="fc" id="L163">                        errors.add(ex);</span>
<span class="fc" id="L164">                    }</span>
<span class="fc" id="L165">                    return;</span>
                }
            }
        }

<span class="fc" id="L170">        downstream.onSubscribe(s);</span>

<span class="fc" id="L172">        long mr = missedRequested.getAndSet(0L);</span>
<span class="fc bfc" id="L173" title="All 2 branches covered.">        if (mr != 0L) {</span>
<span class="fc" id="L174">            s.request(mr);</span>
        }

<span class="fc" id="L177">        onStart();</span>
<span class="fc" id="L178">    }</span>

    /**
     * Called after the onSubscribe is called and handled.
     */
    protected void onStart() {

<span class="fc" id="L185">    }</span>

    @Override
    public void onNext(T t) {
<span class="fc bfc" id="L189" title="All 2 branches covered.">        if (!checkSubscriptionOnce) {</span>
<span class="fc" id="L190">            checkSubscriptionOnce = true;</span>
<span class="fc bfc" id="L191" title="All 2 branches covered.">            if (upstream.get() == null) {</span>
<span class="fc" id="L192">                errors.add(new IllegalStateException(&quot;onSubscribe not called in proper order&quot;));</span>
            }
        }
<span class="fc" id="L195">        lastThread = Thread.currentThread();</span>

<span class="fc bfc" id="L197" title="All 2 branches covered.">        if (establishedFusionMode == QueueSubscription.ASYNC) {</span>
            try {
<span class="fc bfc" id="L199" title="All 2 branches covered.">                while ((t = qs.poll()) != null) {</span>
<span class="fc" id="L200">                    values.add(t);</span>
                }
<span class="fc" id="L202">            } catch (Throwable ex) {</span>
                // Exceptions.throwIfFatal(e); TODO add fatal exceptions?
<span class="fc" id="L204">                errors.add(ex);</span>
<span class="fc" id="L205">                qs.cancel();</span>
<span class="fc" id="L206">            }</span>
<span class="fc" id="L207">            return;</span>
        }

<span class="fc" id="L210">        values.add(t);</span>

<span class="fc bfc" id="L212" title="All 2 branches covered.">        if (t == null) {</span>
<span class="fc" id="L213">            errors.add(new NullPointerException(&quot;onNext received a null value&quot;));</span>
        }

<span class="fc" id="L216">        downstream.onNext(t);</span>
<span class="fc" id="L217">    }</span>

    @Override
    public void onError(Throwable t) {
<span class="fc bfc" id="L221" title="All 2 branches covered.">        if (!checkSubscriptionOnce) {</span>
<span class="fc" id="L222">            checkSubscriptionOnce = true;</span>
<span class="fc bfc" id="L223" title="All 2 branches covered.">            if (upstream.get() == null) {</span>
<span class="fc" id="L224">                errors.add(new NullPointerException(&quot;onSubscribe not called in proper order&quot;));</span>
            }
        }
        try {
<span class="fc" id="L228">            lastThread = Thread.currentThread();</span>
<span class="fc" id="L229">            errors.add(t);</span>

<span class="fc bfc" id="L231" title="All 2 branches covered.">            if (t == null) {</span>
<span class="fc" id="L232">                errors.add(new IllegalStateException(&quot;onError received a null Throwable&quot;));</span>
            }

<span class="fc" id="L235">            downstream.onError(t);</span>
        } finally {
<span class="fc" id="L237">            done.countDown();</span>
        }
<span class="fc" id="L239">    }</span>

    @Override
    public void onComplete() {
<span class="fc bfc" id="L243" title="All 2 branches covered.">        if (!checkSubscriptionOnce) {</span>
<span class="fc" id="L244">            checkSubscriptionOnce = true;</span>
<span class="fc bfc" id="L245" title="All 2 branches covered.">            if (upstream.get() == null) {</span>
<span class="fc" id="L246">                errors.add(new IllegalStateException(&quot;onSubscribe not called in proper order&quot;));</span>
            }
        }
        try {
<span class="fc" id="L250">            lastThread = Thread.currentThread();</span>
<span class="fc" id="L251">            completions++;</span>

<span class="fc" id="L253">            downstream.onComplete();</span>
        } finally {
<span class="fc" id="L255">            done.countDown();</span>
        }
<span class="fc" id="L257">    }</span>

    @Override
    public final void request(long n) {
<span class="fc" id="L261">        SubscriptionHelper.deferredRequest(upstream, missedRequested, n);</span>
<span class="fc" id="L262">    }</span>

    @Override
    public final void cancel() {
<span class="pc bpc" id="L266" title="1 of 2 branches missed.">        if (!cancelled) {</span>
<span class="fc" id="L267">            cancelled = true;</span>
<span class="fc" id="L268">            SubscriptionHelper.cancel(upstream);</span>
        }
<span class="fc" id="L270">    }</span>

    /**
     * Returns true if this TestSubscriber has been cancelled.
     * @return true if this TestSubscriber has been cancelled
     */
    public final boolean isCancelled() {
<span class="fc" id="L277">        return cancelled;</span>
    }

    @Override
    public final void dispose() {
<span class="fc" id="L282">        cancel();</span>
<span class="fc" id="L283">    }</span>

    @Override
    public final boolean isDisposed() {
<span class="fc" id="L287">        return cancelled;</span>
    }

    // state retrieval methods

    /**
     * Returns true if this TestSubscriber received a subscription.
     * @return true if this TestSubscriber received a subscription
     */
    public final boolean hasSubscription() {
<span class="fc bfc" id="L297" title="All 2 branches covered.">        return upstream.get() != null;</span>
    }

    // assertion methods

    /**
     * Assert that the onSubscribe method was called exactly once.
     * @return this
     */
    @Override
    public final TestSubscriber&lt;T&gt; assertSubscribed() {
<span class="fc bfc" id="L308" title="All 2 branches covered.">        if (upstream.get() == null) {</span>
<span class="fc" id="L309">            throw fail(&quot;Not subscribed!&quot;);</span>
        }
<span class="fc" id="L311">        return this;</span>
    }

    /**
     * Assert that the onSubscribe method hasn't been called at all.
     * @return this
     */
    @Override
    public final TestSubscriber&lt;T&gt; assertNotSubscribed() {
<span class="fc bfc" id="L320" title="All 2 branches covered.">        if (upstream.get() != null) {</span>
<span class="fc" id="L321">            throw fail(&quot;Subscribed!&quot;);</span>
        } else
<span class="fc bfc" id="L323" title="All 2 branches covered.">        if (!errors.isEmpty()) {</span>
<span class="fc" id="L324">            throw fail(&quot;Not subscribed but errors found&quot;);</span>
        }
<span class="fc" id="L326">        return this;</span>
    }

    /**
     * Sets the initial fusion mode if the upstream supports fusion.
     * &lt;p&gt;Package-private: avoid leaking the now internal fusion properties into the public API.
     * Use SubscriberFusion to work with such tests.
     * @param mode the mode to establish, see the {@link QueueSubscription} constants
     * @return this
     */
    final TestSubscriber&lt;T&gt; setInitialFusionMode(int mode) {
<span class="fc" id="L337">        this.initialFusionMode = mode;</span>
<span class="fc" id="L338">        return this;</span>
    }

    /**
     * Asserts that the given fusion mode has been established
     * &lt;p&gt;Package-private: avoid leaking the now internal fusion properties into the public API.
     * Use SubscriberFusion to work with such tests.
     * @param mode the expected mode
     * @return this
     */
    final TestSubscriber&lt;T&gt; assertFusionMode(int mode) {
<span class="fc" id="L349">        int m = establishedFusionMode;</span>
<span class="fc bfc" id="L350" title="All 2 branches covered.">        if (m != mode) {</span>
<span class="fc bfc" id="L351" title="All 2 branches covered.">            if (qs != null) {</span>
<span class="fc" id="L352">                throw new AssertionError(&quot;Fusion mode different. Expected: &quot; + fusionModeToString(mode)</span>
<span class="fc" id="L353">                + &quot;, actual: &quot; + fusionModeToString(m));</span>
            } else {
<span class="fc" id="L355">                throw fail(&quot;Upstream is not fuseable&quot;);</span>
            }
        }
<span class="fc" id="L358">        return this;</span>
    }

    static String fusionModeToString(int mode) {
<span class="fc bfc" id="L362" title="All 4 branches covered.">        switch (mode) {</span>
<span class="fc" id="L363">        case QueueSubscription.NONE : return &quot;NONE&quot;;</span>
<span class="fc" id="L364">        case QueueSubscription.SYNC : return &quot;SYNC&quot;;</span>
<span class="fc" id="L365">        case QueueSubscription.ASYNC : return &quot;ASYNC&quot;;</span>
<span class="fc" id="L366">        default: return &quot;Unknown(&quot; + mode + &quot;)&quot;;</span>
        }
    }

    /**
     * Assert that the upstream is a fuseable source.
     * &lt;p&gt;Package-private: avoid leaking the now internal fusion properties into the public API.
     * Use SubscriberFusion to work with such tests.
     * @return this
     */
    final TestSubscriber&lt;T&gt; assertFuseable() {
<span class="fc bfc" id="L377" title="All 2 branches covered.">        if (qs == null) {</span>
<span class="fc" id="L378">            throw new AssertionError(&quot;Upstream is not fuseable.&quot;);</span>
        }
<span class="fc" id="L380">        return this;</span>
    }

    /**
     * Assert that the upstream is not a fuseable source.
     * &lt;p&gt;Package-private: avoid leaking the now internal fusion properties into the public API.
     * Use SubscriberFusion to work with such tests.
     * @return this
     */
    final TestSubscriber&lt;T&gt; assertNotFuseable() {
<span class="fc bfc" id="L390" title="All 2 branches covered.">        if (qs != null) {</span>
<span class="fc" id="L391">            throw new AssertionError(&quot;Upstream is fuseable.&quot;);</span>
        }
<span class="fc" id="L393">        return this;</span>
    }

    /**
     * Run a check consumer with this TestSubscriber instance.
     * @param check the check consumer to run
     * @return this
     */
    public final TestSubscriber&lt;T&gt; assertOf(Consumer&lt;? super TestSubscriber&lt;T&gt;&gt; check) {
        try {
<span class="fc" id="L403">            check.accept(this);</span>
<span class="fc" id="L404">        } catch (Throwable ex) {</span>
<span class="fc" id="L405">            throw ExceptionHelper.wrapOrThrow(ex);</span>
<span class="fc" id="L406">        }</span>
<span class="fc" id="L407">        return this;</span>
    }

    /**
     * Calls {@link #request(long)} and returns this.
     * &lt;p&gt;History: 2.0.1 - experimental
     * @param n the request amount
     * @return this
     * @since 2.1
     */
    public final TestSubscriber&lt;T&gt; requestMore(long n) {
<span class="fc" id="L418">        request(n);</span>
<span class="fc" id="L419">        return this;</span>
    }

    /**
     * A subscriber that ignores all events and does not report errors.
     */
<span class="fc" id="L425">    enum EmptySubscriber implements FlowableSubscriber&lt;Object&gt; {</span>
<span class="fc" id="L426">        INSTANCE;</span>

        @Override
        public void onSubscribe(Subscription s) {
<span class="fc" id="L430">        }</span>

        @Override
        public void onNext(Object t) {
<span class="fc" id="L434">        }</span>

        @Override
        public void onError(Throwable t) {
<span class="fc" id="L438">        }</span>

        @Override
        public void onComplete() {
<span class="fc" id="L442">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>