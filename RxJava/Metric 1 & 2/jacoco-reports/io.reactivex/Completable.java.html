<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Completable.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">RxJava_2_x$Unnamed.exec</a> &gt; <a href="index.source.html" class="el_package">io.reactivex</a> &gt; <span class="el_source">Completable.java</span></div><h1>Completable.java</h1><pre class="source lang-java linenums">/**
 * Copyright (c) 2016-present, RxJava Contributors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is
 * distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
 * the License for the specific language governing permissions and limitations under the License.
 */
package io.reactivex;

import java.util.concurrent.*;

import org.reactivestreams.Publisher;

import io.reactivex.annotations.*;
import io.reactivex.disposables.Disposable;
import io.reactivex.exceptions.Exceptions;
import io.reactivex.functions.*;
import io.reactivex.internal.functions.*;
import io.reactivex.internal.fuseable.*;
import io.reactivex.internal.observers.*;
import io.reactivex.internal.operators.completable.*;
import io.reactivex.internal.operators.maybe.*;
import io.reactivex.internal.operators.mixed.*;
import io.reactivex.internal.operators.single.*;
import io.reactivex.internal.util.ExceptionHelper;
import io.reactivex.observers.TestObserver;
import io.reactivex.plugins.RxJavaPlugins;
import io.reactivex.schedulers.Schedulers;

/**
 * The {@code Completable} class represents a deferred computation without any value but
 * only indication for completion or exception.
 * &lt;p&gt;
 * {@code Completable} behaves similarly to {@link Observable} except that it can only emit either
 * a completion or error signal (there is no {@code onNext} or {@code onSuccess} as with the other
 * reactive types).
 * &lt;p&gt;
 * The {@code Completable} class implements the {@link CompletableSource} base interface and the default consumer
 * type it interacts with is the {@link CompletableObserver} via the {@link #subscribe(CompletableObserver)} method.
 * The {@code Completable} operates with the following sequential protocol:
 * &lt;pre&gt;&lt;code&gt;
 *     onSubscribe (onError | onComplete)?
 * &lt;/code&gt;&lt;/pre&gt;
 * &lt;p&gt;
 * Note that as with the {@code Observable} protocol, {@code onError} and {@code onComplete} are mutually exclusive events.
 * &lt;p&gt;
 * Like {@link Observable}, a running {@code Completable} can be stopped through the {@link Disposable} instance
 * provided to consumers through {@link SingleObserver#onSubscribe}.
 * &lt;p&gt;
 * Like an {@code Observable}, a {@code Completable} is lazy, can be either &quot;hot&quot; or &quot;cold&quot;, synchronous or
 * asynchronous. {@code Completable} instances returned by the methods of this class are &lt;em&gt;cold&lt;/em&gt;
 * and there is a standard &lt;em&gt;hot&lt;/em&gt; implementation in the form of a subject:
 * {@link io.reactivex.subjects.CompletableSubject CompletableSubject}.
 * &lt;p&gt;
 * The documentation for this class makes use of marble diagrams. The following legend explains these diagrams:
 * &lt;p&gt;
 * &lt;img width=&quot;640&quot; height=&quot;577&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.png&quot; alt=&quot;&quot;&gt;
 * &lt;p&gt;
 * See {@link Flowable} or {@link Observable} for the
 * implementation of the Reactive Pattern for a stream or vector of values.
 * &lt;p&gt;
 * Example:
 * &lt;pre&gt;&lt;code&gt;
 * Disposable d = Completable.complete()
 *    .delay(10, TimeUnit.SECONDS, Schedulers.io())
 *    .subscribeWith(new DisposableCompletableObserver() {
 *        &amp;#64;Override
 *        public void onStart() {
 *            System.out.println(&quot;Started&quot;);
 *        }
 *
 *        &amp;#64;Override
 *        public void onError(Throwable error) {
 *            error.printStackTrace();
 *        }
 *
 *        &amp;#64;Override
 *        public void onComplete() {
 *            System.out.println(&quot;Done!&quot;);
 *        }
 *    });
 * 
 * Thread.sleep(5000);
 * 
 * d.dispose();
 * &lt;/code&gt;&lt;/pre&gt;
 * &lt;p&gt;
 * Note that by design, subscriptions via {@link #subscribe(CompletableObserver)} can't be disposed
 * from the outside (hence the
 * {@code void} return of the {@link #subscribe(CompletableObserver)} method) and it is the
 * responsibility of the implementor of the {@code CompletableObserver} to allow this to happen.
 * RxJava supports such usage with the standard
 * {@link io.reactivex.observers.DisposableCompletableObserver DisposableCompletableObserver} instance.
 * For convenience, the {@link #subscribeWith(CompletableObserver)} method is provided as well to
 * allow working with a {@code CompletableObserver} (or subclass) instance to be applied with in
 * a fluent manner (such as in the example above).
 *
 * @see io.reactivex.observers.DisposableCompletableObserver
 */
<span class="fc" id="L105">public abstract class Completable implements CompletableSource {</span>
    /**
     * Returns a Completable which terminates as soon as one of the source Completables
     * terminates (normally or with an error) and disposes all other Completables.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;518&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.ambArray.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code ambArray} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param sources the array of source Completables. A subscription to each source will
     *            occur in the same order as in this array.
     * @return the new Completable instance
     * @throws NullPointerException if sources is null
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public static Completable ambArray(final CompletableSource... sources) {
<span class="fc" id="L124">        ObjectHelper.requireNonNull(sources, &quot;sources is null&quot;);</span>
<span class="fc bfc" id="L125" title="All 2 branches covered.">        if (sources.length == 0) {</span>
<span class="fc" id="L126">            return complete();</span>
        }
<span class="fc bfc" id="L128" title="All 2 branches covered.">        if (sources.length == 1) {</span>
<span class="fc" id="L129">            return wrap(sources[0]);</span>
        }

<span class="fc" id="L132">        return RxJavaPlugins.onAssembly(new CompletableAmb(sources, null));</span>
    }

    /**
     * Returns a Completable which terminates as soon as one of the source Completables
     * terminates (normally or with an error) and disposes all other Completables.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;518&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.amb.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code amb} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param sources the array of source Completables. A subscription to each source will
     *            occur in the same order as in this Iterable.
     * @return the new Completable instance
     * @throws NullPointerException if sources is null
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public static Completable amb(final Iterable&lt;? extends CompletableSource&gt; sources) {
<span class="fc" id="L153">        ObjectHelper.requireNonNull(sources, &quot;sources is null&quot;);</span>

<span class="fc" id="L155">        return RxJavaPlugins.onAssembly(new CompletableAmb(null, sources));</span>
    }

    /**
     * Returns a Completable instance that completes immediately when subscribed to.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;472&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.complete.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code complete} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @return a Completable instance that completes immediately
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public static Completable complete() {
<span class="fc" id="L172">        return RxJavaPlugins.onAssembly(CompletableEmpty.INSTANCE);</span>
    }

    /**
     * Returns a Completable which completes only when all sources complete, one after another.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;283&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.concatArray.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code concatArray} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param sources the sources to concatenate
     * @return the Completable instance which completes only when all sources complete
     * @throws NullPointerException if sources is null
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public static Completable concatArray(CompletableSource... sources) {
<span class="fc" id="L191">        ObjectHelper.requireNonNull(sources, &quot;sources is null&quot;);</span>
<span class="fc bfc" id="L192" title="All 2 branches covered.">        if (sources.length == 0) {</span>
<span class="fc" id="L193">            return complete();</span>
        } else
<span class="fc bfc" id="L195" title="All 2 branches covered.">        if (sources.length == 1) {</span>
<span class="fc" id="L196">            return wrap(sources[0]);</span>
        }
<span class="fc" id="L198">        return RxJavaPlugins.onAssembly(new CompletableConcatArray(sources));</span>
    }

    /**
     * Returns a Completable which completes only when all sources complete, one after another.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;303&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.concat.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code concat} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param sources the sources to concatenate
     * @return the Completable instance which completes only when all sources complete
     * @throws NullPointerException if sources is null
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public static Completable concat(Iterable&lt;? extends CompletableSource&gt; sources) {
<span class="fc" id="L217">        ObjectHelper.requireNonNull(sources, &quot;sources is null&quot;);</span>

<span class="fc" id="L219">        return RxJavaPlugins.onAssembly(new CompletableConcatIterable(sources));</span>
    }

    /**
     * Returns a Completable which completes only when all sources complete, one after another.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;237&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.concat.p.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The returned {@code Completable} honors the backpressure of the downstream consumer
     *  and expects the other {@code Publisher} to honor it as well.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code concat} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param sources the sources to concatenate
     * @return the Completable instance which completes only when all sources complete
     * @throws NullPointerException if sources is null
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    @BackpressureSupport(BackpressureKind.FULL)
    public static Completable concat(Publisher&lt;? extends CompletableSource&gt; sources) {
<span class="fc" id="L241">        return concat(sources, 2);</span>
    }

    /**
     * Returns a Completable which completes only when all sources complete, one after another.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;237&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.concat.pn.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The returned {@code Completable} honors the backpressure of the downstream consumer
     *  and expects the other {@code Publisher} to honor it as well.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code concat} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param sources the sources to concatenate
     * @param prefetch the number of sources to prefetch from the sources
     * @return the Completable instance which completes only when all sources complete
     * @throws NullPointerException if sources is null
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    @BackpressureSupport(BackpressureKind.FULL)
    public static Completable concat(Publisher&lt;? extends CompletableSource&gt; sources, int prefetch) {
<span class="fc" id="L265">        ObjectHelper.requireNonNull(sources, &quot;sources is null&quot;);</span>
<span class="fc" id="L266">        ObjectHelper.verifyPositive(prefetch, &quot;prefetch&quot;);</span>
<span class="fc" id="L267">        return RxJavaPlugins.onAssembly(new CompletableConcat(sources, prefetch));</span>
    }

    /**
     * Provides an API (via a cold Completable) that bridges the reactive world with the callback-style world.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;442&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.create.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * Example:
     * &lt;pre&gt;&lt;code&gt;
     * Completable.create(emitter -&amp;gt; {
     *     Callback listener = new Callback() {
     *         &amp;#64;Override
     *         public void onEvent(Event e) {
     *             emitter.onComplete();
     *         }
     *
     *         &amp;#64;Override
     *         public void onFailure(Exception e) {
     *             emitter.onError(e);
     *         }
     *     };
     *
     *     AutoCloseable c = api.someMethod(listener);
     *
     *     emitter.setCancellable(c::close);
     *
     * });
     * &lt;/code&gt;&lt;/pre&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code create} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param source the emitter that is called when a CompletableObserver subscribes to the returned {@code Completable}
     * @return the new Completable instance
     * @see CompletableOnSubscribe
     * @see Cancellable
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public static Completable create(CompletableOnSubscribe source) {
<span class="fc" id="L309">        ObjectHelper.requireNonNull(source, &quot;source is null&quot;);</span>
<span class="fc" id="L310">        return RxJavaPlugins.onAssembly(new CompletableCreate(source));</span>
    }

    /**
     * Constructs a Completable instance by wrapping the given source callback
     * &lt;strong&gt;without any safeguards; you should manage the lifecycle and response
     * to downstream disposal&lt;/strong&gt;.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;260&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.unsafeCreate.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code unsafeCreate} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param source the callback which will receive the CompletableObserver instances
     * when the Completable is subscribed to.
     * @return the created Completable instance
     * @throws NullPointerException if source is null
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public static Completable unsafeCreate(CompletableSource source) {
<span class="fc" id="L332">        ObjectHelper.requireNonNull(source, &quot;source is null&quot;);</span>
<span class="fc bfc" id="L333" title="All 2 branches covered.">        if (source instanceof Completable) {</span>
<span class="fc" id="L334">            throw new IllegalArgumentException(&quot;Use of unsafeCreate(Completable)!&quot;);</span>
        }
<span class="fc" id="L336">        return RxJavaPlugins.onAssembly(new CompletableFromUnsafeSource(source));</span>
    }

    /**
     * Defers the subscription to a Completable instance returned by a supplier.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;298&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.defer.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code defer} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param completableSupplier the supplier that returns the Completable that will be subscribed to.
     * @return the Completable instance
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public static Completable defer(final Callable&lt;? extends CompletableSource&gt; completableSupplier) {
<span class="fc" id="L354">        ObjectHelper.requireNonNull(completableSupplier, &quot;completableSupplier&quot;);</span>
<span class="fc" id="L355">        return RxJavaPlugins.onAssembly(new CompletableDefer(completableSupplier));</span>
    }

    /**
     * Creates a Completable which calls the given error supplier for each subscriber
     * and emits its returned Throwable.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;462&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.error.f.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * If the errorSupplier returns null, the child CompletableObservers will receive a
     * NullPointerException.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code error} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param errorSupplier the error supplier, not null
     * @return the new Completable instance
     * @throws NullPointerException if errorSupplier is null
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public static Completable error(final Callable&lt;? extends Throwable&gt; errorSupplier) {
<span class="fc" id="L378">        ObjectHelper.requireNonNull(errorSupplier, &quot;errorSupplier is null&quot;);</span>
<span class="fc" id="L379">        return RxJavaPlugins.onAssembly(new CompletableErrorSupplier(errorSupplier));</span>
    }

    /**
     * Creates a Completable instance that emits the given Throwable exception to subscribers.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;462&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.error.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code error} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param error the Throwable instance to emit, not null
     * @return the new Completable instance
     * @throws NullPointerException if error is null
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public static Completable error(final Throwable error) {
<span class="fc" id="L398">        ObjectHelper.requireNonNull(error, &quot;error is null&quot;);</span>
<span class="fc" id="L399">        return RxJavaPlugins.onAssembly(new CompletableError(error));</span>
    }

    /**
     * Returns a Completable instance that runs the given Action for each subscriber and
     * emits either an unchecked exception or simply completes.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;297&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.fromAction.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code fromAction} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Error handling:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt; If the {@link Action} throws an exception, the respective {@link Throwable} is
     *  delivered to the downstream via {@link CompletableObserver#onError(Throwable)},
     *  except when the downstream has disposed this {@code Completable} source.
     *  In this latter case, the {@code Throwable} is delivered to the global error handler via
     *  {@link RxJavaPlugins#onError(Throwable)} as an {@link io.reactivex.exceptions.UndeliverableException UndeliverableException}.
     *  &lt;/dd&gt;
     * &lt;/dl&gt;
     * @param run the runnable to run for each subscriber
     * @return the new Completable instance
     * @throws NullPointerException if run is null
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public static Completable fromAction(final Action run) {
<span class="fc" id="L426">        ObjectHelper.requireNonNull(run, &quot;run is null&quot;);</span>
<span class="fc" id="L427">        return RxJavaPlugins.onAssembly(new CompletableFromAction(run));</span>
    }

    /**
     * Returns a Completable which when subscribed, executes the callable function, ignores its
     * normal result and emits onError or onComplete only.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;286&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.fromCallable.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code fromCallable} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Error handling:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt; If the {@link Callable} throws an exception, the respective {@link Throwable} is
     *  delivered to the downstream via {@link CompletableObserver#onError(Throwable)},
     *  except when the downstream has disposed this {@code Completable} source.
     *  In this latter case, the {@code Throwable} is delivered to the global error handler via
     *  {@link RxJavaPlugins#onError(Throwable)} as an {@link io.reactivex.exceptions.UndeliverableException UndeliverableException}.
     *  &lt;/dd&gt;
     * &lt;/dl&gt;
     * @param callable the callable instance to execute for each subscriber
     * @return the new Completable instance
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public static Completable fromCallable(final Callable&lt;?&gt; callable) {
<span class="fc" id="L453">        ObjectHelper.requireNonNull(callable, &quot;callable is null&quot;);</span>
<span class="fc" id="L454">        return RxJavaPlugins.onAssembly(new CompletableFromCallable(callable));</span>
    }

    /**
     * Returns a Completable instance that reacts to the termination of the given Future in a blocking fashion.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;628&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.fromFuture.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * Note that if any of the observers to this Completable call dispose, this Completable will cancel the future.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code fromFuture} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param future the future to react to
     * @return the new Completable instance
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public static Completable fromFuture(final Future&lt;?&gt; future) {
<span class="fc" id="L474">        ObjectHelper.requireNonNull(future, &quot;future is null&quot;);</span>
<span class="fc" id="L475">        return fromAction(Functions.futureAction(future));</span>
    }

    /**
     * Returns a Completable instance that when subscribed to, subscribes to the {@code Maybe} instance and
     * emits a completion event if the maybe emits {@code onSuccess}/{@code onComplete} or forwards any
     * {@code onError} events.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;235&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.fromMaybe.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code fromMaybe} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * &lt;p&gt;History: 2.1.17 - beta
     * @param &lt;T&gt; the value type of the {@link MaybeSource} element
     * @param maybe the Maybe instance to subscribe to, not null
     * @return the new Completable instance
     * @throws NullPointerException if single is null
     * @since 2.2
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Completable fromMaybe(final MaybeSource&lt;T&gt; maybe) {
<span class="fc" id="L499">        ObjectHelper.requireNonNull(maybe, &quot;maybe is null&quot;);</span>
<span class="fc" id="L500">        return RxJavaPlugins.onAssembly(new MaybeIgnoreElementCompletable&lt;T&gt;(maybe));</span>
    }

    /**
     * Returns a Completable instance that runs the given Runnable for each subscriber and
     * emits either its exception or simply completes.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;297&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.fromRunnable.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code fromRunnable} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Error handling:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt; If the {@link Runnable} throws an exception, the respective {@link Throwable} is
     *  delivered to the downstream via {@link CompletableObserver#onError(Throwable)},
     *  except when the downstream has disposed this {@code Completable} source.
     *  In this latter case, the {@code Throwable} is delivered to the global error handler via
     *  {@link RxJavaPlugins#onError(Throwable)} as an {@link io.reactivex.exceptions.UndeliverableException UndeliverableException}.
     *  &lt;/dd&gt;
     * &lt;/dl&gt;
     * @param run the runnable to run for each subscriber
     * @return the new Completable instance
     * @throws NullPointerException if run is null
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public static Completable fromRunnable(final Runnable run) {
<span class="fc" id="L527">        ObjectHelper.requireNonNull(run, &quot;run is null&quot;);</span>
<span class="fc" id="L528">        return RxJavaPlugins.onAssembly(new CompletableFromRunnable(run));</span>
    }

    /**
     * Returns a Completable instance that subscribes to the given Observable, ignores all values and
     * emits only the terminal event.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;414&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.fromObservable.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code fromObservable} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;T&gt; the type of the Observable
     * @param observable the Observable instance to subscribe to, not null
     * @return the new Completable instance
     * @throws NullPointerException if flowable is null
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Completable fromObservable(final ObservableSource&lt;T&gt; observable) {
<span class="fc" id="L549">        ObjectHelper.requireNonNull(observable, &quot;observable is null&quot;);</span>
<span class="fc" id="L550">        return RxJavaPlugins.onAssembly(new CompletableFromObservable&lt;T&gt;(observable));</span>
    }

    /**
     * Returns a Completable instance that subscribes to the given publisher, ignores all values and
     * emits only the terminal event.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;422&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.fromPublisher.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * The {@link Publisher} must follow the
     * &lt;a href=&quot;https://github.com/reactive-streams/reactive-streams-jvm#reactive-streams&quot;&gt;Reactive-Streams specification&lt;/a&gt;.
     * Violating the specification may result in undefined behavior.
     * &lt;p&gt;
     * If possible, use {@link #create(CompletableOnSubscribe)} to create a
     * source-like {@code Completable} instead.
     * &lt;p&gt;
     * Note that even though {@link Publisher} appears to be a functional interface, it
     * is not recommended to implement it through a lambda as the specification requires
     * state management that is not achievable with a stateless lambda.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The returned {@code Completable} honors the backpressure of the downstream consumer
     *  and expects the other {@code Publisher} to honor it as well.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code fromPublisher} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;T&gt; the type of the publisher
     * @param publisher the Publisher instance to subscribe to, not null
     * @return the new Completable instance
     * @throws NullPointerException if publisher is null
     * @see #create(CompletableOnSubscribe)
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Completable fromPublisher(final Publisher&lt;T&gt; publisher) {
<span class="fc" id="L587">        ObjectHelper.requireNonNull(publisher, &quot;publisher is null&quot;);</span>
<span class="fc" id="L588">        return RxJavaPlugins.onAssembly(new CompletableFromPublisher&lt;T&gt;(publisher));</span>
    }

    /**
     * Returns a Completable instance that when subscribed to, subscribes to the Single instance and
     * emits a completion event if the single emits onSuccess or forwards any onError events.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;356&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.fromSingle.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code fromSingle} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;T&gt; the value type of the Single
     * @param single the Single instance to subscribe to, not null
     * @return the new Completable instance
     * @throws NullPointerException if single is null
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Completable fromSingle(final SingleSource&lt;T&gt; single) {
<span class="fc" id="L609">        ObjectHelper.requireNonNull(single, &quot;single is null&quot;);</span>
<span class="fc" id="L610">        return RxJavaPlugins.onAssembly(new CompletableFromSingle&lt;T&gt;(single));</span>
    }

    /**
     * Returns a Completable instance that subscribes to all sources at once and
     * completes only when all source Completables complete or one of them emits an error.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;270&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.mergeArray.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code mergeArray} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Error handling:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;If any of the source {@code CompletableSource}s signal a {@code Throwable} via {@code onError}, the resulting
     *  {@code Completable} terminates with that {@code Throwable} and all other source {@code CompletableSource}s are disposed.
     *  If more than one {@code CompletableSource} signals an error, the resulting {@code Completable} may terminate with the
     *  first one's error or, depending on the concurrency of the sources, may terminate with a
     *  {@code CompositeException} containing two or more of the various error signals.
     *  {@code Throwable}s that didn't make into the composite will be sent (individually) to the global error handler via
     *  {@link RxJavaPlugins#onError(Throwable)} method as {@code UndeliverableException} errors. Similarly, {@code Throwable}s
     *  signaled by source(s) after the returned {@code Completable} has been disposed or terminated with a
     *  (composite) error will be sent to the same global error handler.
     *  Use {@link #mergeArrayDelayError(CompletableSource...)} to merge sources and terminate only when all source {@code CompletableSource}s
     *  have completed or failed with an error.
     *  &lt;/dd&gt;
     * &lt;/dl&gt;
     * @param sources the iterable sequence of sources.
     * @return the new Completable instance
     * @throws NullPointerException if sources is null
     * @see #mergeArrayDelayError(CompletableSource...)
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public static Completable mergeArray(CompletableSource... sources) {
<span class="fc" id="L644">        ObjectHelper.requireNonNull(sources, &quot;sources is null&quot;);</span>
<span class="fc bfc" id="L645" title="All 2 branches covered.">        if (sources.length == 0) {</span>
<span class="fc" id="L646">            return complete();</span>
        } else
<span class="fc bfc" id="L648" title="All 2 branches covered.">        if (sources.length == 1) {</span>
<span class="fc" id="L649">            return wrap(sources[0]);</span>
        }
<span class="fc" id="L651">        return RxJavaPlugins.onAssembly(new CompletableMergeArray(sources));</span>
    }

    /**
     * Returns a Completable instance that subscribes to all sources at once and
     * completes only when all source Completables complete or one of them emits an error.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;311&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.merge.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code merge} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Error handling:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;If any of the source {@code CompletableSource}s signal a {@code Throwable} via {@code onError}, the resulting
     *  {@code Completable} terminates with that {@code Throwable} and all other source {@code CompletableSource}s are disposed.
     *  If more than one {@code CompletableSource} signals an error, the resulting {@code Completable} may terminate with the
     *  first one's error or, depending on the concurrency of the sources, may terminate with a
     *  {@code CompositeException} containing two or more of the various error signals.
     *  {@code Throwable}s that didn't make into the composite will be sent (individually) to the global error handler via
     *  {@link RxJavaPlugins#onError(Throwable)} method as {@code UndeliverableException} errors. Similarly, {@code Throwable}s
     *  signaled by source(s) after the returned {@code Completable} has been disposed or terminated with a
     *  (composite) error will be sent to the same global error handler.
     *  Use {@link #mergeDelayError(Iterable)} to merge sources and terminate only when all source {@code CompletableSource}s
     *  have completed or failed with an error.
     *  &lt;/dd&gt;
     * &lt;/dl&gt;
     * @param sources the iterable sequence of sources.
     * @return the new Completable instance
     * @throws NullPointerException if sources is null
     * @see #mergeDelayError(Iterable)
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public static Completable merge(Iterable&lt;? extends CompletableSource&gt; sources) {
<span class="fc" id="L685">        ObjectHelper.requireNonNull(sources, &quot;sources is null&quot;);</span>
<span class="fc" id="L686">        return RxJavaPlugins.onAssembly(new CompletableMergeIterable(sources));</span>
    }

    /**
     * Returns a Completable instance that subscribes to all sources at once and
     * completes only when all source Completables complete or one of them emits an error.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;336&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.merge.p.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The returned {@code Completable} honors the backpressure of the downstream consumer
     *  and expects the other {@code Publisher} to honor it as well.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code merge} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Error handling:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;If any of the source {@code CompletableSource}s signal a {@code Throwable} via {@code onError}, the resulting
     *  {@code Completable} terminates with that {@code Throwable} and all other source {@code CompletableSource}s are disposed.
     *  If more than one {@code CompletableSource} signals an error, the resulting {@code Completable} may terminate with the
     *  first one's error or, depending on the concurrency of the sources, may terminate with a
     *  {@code CompositeException} containing two or more of the various error signals.
     *  {@code Throwable}s that didn't make into the composite will be sent (individually) to the global error handler via
     *  {@link RxJavaPlugins#onError(Throwable)} method as {@code UndeliverableException} errors. Similarly, {@code Throwable}s
     *  signaled by source(s) after the returned {@code Completable} has been disposed or terminated with a
     *  (composite) error will be sent to the same global error handler.
     *  Use {@link #mergeDelayError(Publisher)} to merge sources and terminate only when all source {@code CompletableSource}s
     *  have completed or failed with an error.
     *  &lt;/dd&gt;
     * &lt;/dl&gt;
     * @param sources the iterable sequence of sources.
     * @return the new Completable instance
     * @throws NullPointerException if sources is null
     * @see #mergeDelayError(Publisher)
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    public static Completable merge(Publisher&lt;? extends CompletableSource&gt; sources) {
<span class="fc" id="L723">        return merge0(sources, Integer.MAX_VALUE, false);</span>
    }

    /**
     * Returns a Completable instance that keeps subscriptions to a limited number of sources at once and
     * completes only when all source Completables complete or one of them emits an error.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;269&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.merge.pn.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The returned {@code Completable} honors the backpressure of the downstream consumer
     *  and expects the other {@code Publisher} to honor it as well.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code merge} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Error handling:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;If any of the source {@code CompletableSource}s signal a {@code Throwable} via {@code onError}, the resulting
     *  {@code Completable} terminates with that {@code Throwable} and all other source {@code CompletableSource}s are disposed.
     *  If more than one {@code CompletableSource} signals an error, the resulting {@code Completable} may terminate with the
     *  first one's error or, depending on the concurrency of the sources, may terminate with a
     *  {@code CompositeException} containing two or more of the various error signals.
     *  {@code Throwable}s that didn't make into the composite will be sent (individually) to the global error handler via
     *  {@link RxJavaPlugins#onError(Throwable)} method as {@code UndeliverableException} errors. Similarly, {@code Throwable}s
     *  signaled by source(s) after the returned {@code Completable} has been disposed or terminated with a
     *  (composite) error will be sent to the same global error handler.
     *  Use {@link #mergeDelayError(Publisher, int)} to merge sources and terminate only when all source {@code CompletableSource}s
     *  have completed or failed with an error.
     *  &lt;/dd&gt;
     * &lt;/dl&gt;
     * @param sources the iterable sequence of sources.
     * @param maxConcurrency the maximum number of concurrent subscriptions
     * @return the new Completable instance
     * @throws NullPointerException if sources is null
     * @throws IllegalArgumentException if maxConcurrency is less than 1
     * @see #mergeDelayError(Publisher, int)
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    @BackpressureSupport(BackpressureKind.FULL)
    public static Completable merge(Publisher&lt;? extends CompletableSource&gt; sources, int maxConcurrency) {
<span class="fc" id="L762">        return merge0(sources, maxConcurrency, false);</span>
    }

    /**
     * Returns a Completable instance that keeps subscriptions to a limited number of sources at once and
     * completes only when all source Completables terminate in one way or another, combining any exceptions
     * thrown by either the sources Observable or the inner Completable instances.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The returned {@code Flowable} honors the backpressure of the downstream consumer
     *  and expects the other {@code Publisher} to honor it as well.
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code merge0} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param sources the iterable sequence of sources.
     * @param maxConcurrency the maximum number of concurrent subscriptions
     * @param delayErrors delay all errors from the main source and from the inner Completables?
     * @return the new Completable instance
     * @throws NullPointerException if sources is null
     * @throws IllegalArgumentException if maxConcurrency is less than 1
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    @BackpressureSupport(BackpressureKind.FULL)
    private static Completable merge0(Publisher&lt;? extends CompletableSource&gt; sources, int maxConcurrency, boolean delayErrors) {
<span class="fc" id="L788">        ObjectHelper.requireNonNull(sources, &quot;sources is null&quot;);</span>
<span class="fc" id="L789">        ObjectHelper.verifyPositive(maxConcurrency, &quot;maxConcurrency&quot;);</span>
<span class="fc" id="L790">        return RxJavaPlugins.onAssembly(new CompletableMerge(sources, maxConcurrency, delayErrors));</span>
    }

    /**
     * Returns a CompletableConsumable that subscribes to all Completables in the source array and delays
     * any error emitted by either the sources observable or any of the inner Completables until all of
     * them terminate in a way or another.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;430&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.mergeArrayDelayError.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code mergeArrayDelayError} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param sources the array of Completables
     * @return the new Completable instance
     * @throws NullPointerException if sources is null
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public static Completable mergeArrayDelayError(CompletableSource... sources) {
<span class="fc" id="L811">        ObjectHelper.requireNonNull(sources, &quot;sources is null&quot;);</span>
<span class="fc" id="L812">        return RxJavaPlugins.onAssembly(new CompletableMergeDelayErrorArray(sources));</span>
    }

    /**
     * Returns a Completable that subscribes to all Completables in the source sequence and delays
     * any error emitted by either the sources observable or any of the inner Completables until all of
     * them terminate in a way or another.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;475&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.mergeDelayError.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code mergeDelayError} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param sources the sequence of Completables
     * @return the new Completable instance
     * @throws NullPointerException if sources is null
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public static Completable mergeDelayError(Iterable&lt;? extends CompletableSource&gt; sources) {
<span class="fc" id="L833">        ObjectHelper.requireNonNull(sources, &quot;sources is null&quot;);</span>
<span class="fc" id="L834">        return RxJavaPlugins.onAssembly(new CompletableMergeDelayErrorIterable(sources));</span>
    }

    /**
     * Returns a Completable that subscribes to all Completables in the source sequence and delays
     * any error emitted by either the sources observable or any of the inner Completables until all of
     * them terminate in a way or another.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;466&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.mergeDelayError.p.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The returned {@code Completable} honors the backpressure of the downstream consumer
     *  and expects the other {@code Publisher} to honor it as well.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code mergeDelayError} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param sources the sequence of Completables
     * @return the new Completable instance
     * @throws NullPointerException if sources is null
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    public static Completable mergeDelayError(Publisher&lt;? extends CompletableSource&gt; sources) {
<span class="fc" id="L858">        return merge0(sources, Integer.MAX_VALUE, true);</span>
    }

    /**
     * Returns a Completable that subscribes to a limited number of inner Completables at once in
     * the source sequence and delays any error emitted by either the sources
     * observable or any of the inner Completables until all of
     * them terminate in a way or another.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;440&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.mergeDelayError.pn.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The returned {@code Completable} honors the backpressure of the downstream consumer
     *  and expects the other {@code Publisher} to honor it as well.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code mergeDelayError} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param sources the sequence of Completables
     * @param maxConcurrency the maximum number of concurrent subscriptions to Completables
     * @return the new Completable instance
     * @throws NullPointerException if sources is null
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    @BackpressureSupport(BackpressureKind.FULL)
    public static Completable mergeDelayError(Publisher&lt;? extends CompletableSource&gt; sources, int maxConcurrency) {
<span class="fc" id="L884">        return merge0(sources, maxConcurrency, true);</span>
    }

    /**
     * Returns a Completable that never calls onError or onComplete.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;512&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.never.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code never} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @return the singleton instance that never calls onError or onComplete
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public static Completable never() {
<span class="fc" id="L900">        return RxJavaPlugins.onAssembly(CompletableNever.INSTANCE);</span>
    }

    /**
     * Returns a Completable instance that fires its onComplete event after the given delay elapsed.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;413&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.timer.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code timer} does operate by default on the {@code computation} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param delay the delay time
     * @param unit the delay unit
     * @return the new Completable instance
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.COMPUTATION)
    public static Completable timer(long delay, TimeUnit unit) {
<span class="fc" id="L918">        return timer(delay, unit, Schedulers.computation());</span>
    }

    /**
     * Returns a Completable instance that fires its onComplete event after the given delay elapsed
     * by using the supplied scheduler.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;413&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.timer.s.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code timer} operates on the {@link Scheduler} you specify.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param delay the delay time
     * @param unit the delay unit
     * @param scheduler the scheduler where to emit the complete event
     * @return the new Completable instance
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public static Completable timer(final long delay, final TimeUnit unit, final Scheduler scheduler) {
<span class="fc" id="L939">        ObjectHelper.requireNonNull(unit, &quot;unit is null&quot;);</span>
<span class="fc" id="L940">        ObjectHelper.requireNonNull(scheduler, &quot;scheduler is null&quot;);</span>
<span class="fc" id="L941">        return RxJavaPlugins.onAssembly(new CompletableTimer(delay, unit, scheduler));</span>
    }

    /**
     * Creates a NullPointerException instance and sets the given Throwable as its initial cause.
     * @param ex the Throwable instance to use as cause, not null (not verified)
     * @return the created NullPointerException
     */
    private static NullPointerException toNpe(Throwable ex) {
<span class="fc" id="L950">        NullPointerException npe = new NullPointerException(&quot;Actually not, but can't pass out an exception otherwise...&quot;);</span>
<span class="fc" id="L951">        npe.initCause(ex);</span>
<span class="fc" id="L952">        return npe;</span>
    }

    /**
     * Returns a Completable instance which manages a resource along
     * with a custom Completable instance while the subscription is active.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;388&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.using.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * This overload disposes eagerly before the terminal event is emitted.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code using} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;R&gt; the resource type
     * @param resourceSupplier the supplier that returns a resource to be managed.
     * @param completableFunction the function that given a resource returns a Completable instance that will be subscribed to
     * @param disposer the consumer that disposes the resource created by the resource supplier
     * @return the new Completable instance
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;R&gt; Completable using(Callable&lt;R&gt; resourceSupplier,
            Function&lt;? super R, ? extends CompletableSource&gt; completableFunction,
            Consumer&lt;? super R&gt; disposer) {
<span class="fc" id="L977">        return using(resourceSupplier, completableFunction, disposer, true);</span>
    }

    /**
     * Returns a Completable instance which manages a resource along
     * with a custom Completable instance while the subscription is active and performs eager or lazy
     * resource disposition.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;332&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.using.b.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * If this overload performs a lazy disposal after the terminal event is emitted.
     * Exceptions thrown at this time will be delivered to RxJavaPlugins only.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code using} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;R&gt; the resource type
     * @param resourceSupplier the supplier that returns a resource to be managed
     * @param completableFunction the function that given a resource returns a non-null
     * Completable instance that will be subscribed to
     * @param disposer the consumer that disposes the resource created by the resource supplier
     * @param eager if true, the resource is disposed before the terminal event is emitted, if false, the
     * resource is disposed after the terminal event has been emitted
     * @return the new Completable instance
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;R&gt; Completable using(
            final Callable&lt;R&gt; resourceSupplier,
            final Function&lt;? super R, ? extends CompletableSource&gt; completableFunction,
            final Consumer&lt;? super R&gt; disposer,
            final boolean eager) {
<span class="fc" id="L1010">        ObjectHelper.requireNonNull(resourceSupplier, &quot;resourceSupplier is null&quot;);</span>
<span class="fc" id="L1011">        ObjectHelper.requireNonNull(completableFunction, &quot;completableFunction is null&quot;);</span>
<span class="fc" id="L1012">        ObjectHelper.requireNonNull(disposer, &quot;disposer is null&quot;);</span>

<span class="fc" id="L1014">        return RxJavaPlugins.onAssembly(new CompletableUsing&lt;R&gt;(resourceSupplier, completableFunction, disposer, eager));</span>
    }

    /**
     * Wraps the given CompletableSource into a Completable
     * if not already Completable.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;354&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.wrap.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code wrap} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param source the source to wrap
     * @return the source or its wrapper Completable
     * @throws NullPointerException if source is null
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public static Completable wrap(CompletableSource source) {
<span class="fc" id="L1034">        ObjectHelper.requireNonNull(source, &quot;source is null&quot;);</span>
<span class="fc bfc" id="L1035" title="All 2 branches covered.">        if (source instanceof Completable) {</span>
<span class="fc" id="L1036">            return RxJavaPlugins.onAssembly((Completable)source);</span>
        }
<span class="fc" id="L1038">        return RxJavaPlugins.onAssembly(new CompletableFromUnsafeSource(source));</span>
    }

    /**
     * Returns a Completable that emits the a terminated event of either this Completable
     * or the other Completable whichever fires first.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;484&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.ambWith.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code ambWith} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param other the other Completable, not null. A subscription to this provided source will occur after subscribing
     *            to the current source.
     * @return the new Completable instance
     * @throws NullPointerException if other is null
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Completable ambWith(CompletableSource other) {
<span class="fc" id="L1059">        ObjectHelper.requireNonNull(other, &quot;other is null&quot;);</span>
<span class="fc" id="L1060">        return ambArray(this, other);</span>
    }

    /**
     * Returns an Observable which will subscribe to this Completable and once that is completed then
     * will subscribe to the {@code next} ObservableSource. An error event from this Completable will be
     * propagated to the downstream subscriber and will result in skipping the subscription of the
     * Observable.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;278&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.andThen.o.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code andThen} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;T&gt; the value type of the next ObservableSource
     * @param next the Observable to subscribe after this Completable is completed, not null
     * @return Observable that composes this Completable and next
     * @throws NullPointerException if next is null
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;T&gt; Observable&lt;T&gt; andThen(ObservableSource&lt;T&gt; next) {
<span class="fc" id="L1083">        ObjectHelper.requireNonNull(next, &quot;next is null&quot;);</span>
<span class="fc" id="L1084">        return RxJavaPlugins.onAssembly(new CompletableAndThenObservable&lt;T&gt;(this, next));</span>
    }

    /**
     * Returns a Flowable which will subscribe to this Completable and once that is completed then
     * will subscribe to the {@code next} Flowable. An error event from this Completable will be
     * propagated to the downstream subscriber and will result in skipping the subscription of the
     * Publisher.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;249&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.andThen.p.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The returned {@code Flowable} honors the backpressure of the downstream consumer
     *  and expects the other {@code Publisher} to honor it as well.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code andThen} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;T&gt; the value type of the next Publisher
     * @param next the Publisher to subscribe after this Completable is completed, not null
     * @return Flowable that composes this Completable and next
     * @throws NullPointerException if next is null
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;T&gt; Flowable&lt;T&gt; andThen(Publisher&lt;T&gt; next) {
<span class="fc" id="L1111">        ObjectHelper.requireNonNull(next, &quot;next is null&quot;);</span>
<span class="fc" id="L1112">        return RxJavaPlugins.onAssembly(new CompletableAndThenPublisher&lt;T&gt;(this, next));</span>
    }

    /**
     * Returns a Single which will subscribe to this Completable and once that is completed then
     * will subscribe to the {@code next} SingleSource. An error event from this Completable will be
     * propagated to the downstream subscriber and will result in skipping the subscription of the
     * Single.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;437&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.andThen.s.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code andThen} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T&gt; the value type of the next SingleSource
     * @param next the Single to subscribe after this Completable is completed, not null
     * @return Single that composes this Completable and next
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;T&gt; Single&lt;T&gt; andThen(SingleSource&lt;T&gt; next) {
<span class="fc" id="L1135">        ObjectHelper.requireNonNull(next, &quot;next is null&quot;);</span>
<span class="fc" id="L1136">        return RxJavaPlugins.onAssembly(new SingleDelayWithCompletable&lt;T&gt;(next, this));</span>
    }

    /**
     * Returns a {@link Maybe} which will subscribe to this Completable and once that is completed then
     * will subscribe to the {@code next} MaybeSource. An error event from this Completable will be
     * propagated to the downstream subscriber and will result in skipping the subscription of the
     * Maybe.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;280&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.andThen.m.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code andThen} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T&gt; the value type of the next MaybeSource
     * @param next the Maybe to subscribe after this Completable is completed, not null
     * @return Maybe that composes this Completable and next
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;T&gt; Maybe&lt;T&gt; andThen(MaybeSource&lt;T&gt; next) {
<span class="fc" id="L1159">        ObjectHelper.requireNonNull(next, &quot;next is null&quot;);</span>
<span class="fc" id="L1160">        return RxJavaPlugins.onAssembly(new MaybeDelayWithCompletable&lt;T&gt;(next, this));</span>
    }

    /**
     * Returns a Completable that first runs this Completable
     * and then the other completable.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;437&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.andThen.c.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * This is an alias for {@link #concatWith(CompletableSource)}.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code andThen} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param next the other Completable, not null
     * @return the new Completable instance
     * @throws NullPointerException if other is null
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Completable andThen(CompletableSource next) {
<span class="fc" id="L1181">        ObjectHelper.requireNonNull(next, &quot;next is null&quot;);</span>
<span class="fc" id="L1182">        return RxJavaPlugins.onAssembly(new CompletableAndThenCompletable(this, next));</span>
    }

    /**
     * Calls the specified converter function during assembly time and returns its resulting value.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;751&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.as.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * This allows fluent conversion to any other type.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code as} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * &lt;p&gt;History: 2.1.7 - experimental
     * @param &lt;R&gt; the resulting object type
     * @param converter the function that receives the current Completable instance and returns a value
     * @return the converted value
     * @throws NullPointerException if converter is null
     * @since 2.2
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;R&gt; R as(@NonNull CompletableConverter&lt;? extends R&gt; converter) {
<span class="fc" id="L1205">        return ObjectHelper.requireNonNull(converter, &quot;converter is null&quot;).apply(this);</span>
    }

    /**
     * Subscribes to and awaits the termination of this Completable instance in a blocking manner and
     * rethrows any exception emitted.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;432&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.blockingAwait.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code blockingAwait} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Error handling:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;If the source signals an error, the operator wraps a checked {@link Exception}
     *  into {@link RuntimeException} and throws that. Otherwise, {@code RuntimeException}s and
     *  {@link Error}s are rethrown as they are.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @throws RuntimeException wrapping an InterruptedException if the current thread is interrupted
     */
    @SchedulerSupport(SchedulerSupport.NONE)
    public final void blockingAwait() {
<span class="fc" id="L1225">        BlockingMultiObserver&lt;Void&gt; observer = new BlockingMultiObserver&lt;Void&gt;();</span>
<span class="fc" id="L1226">        subscribe(observer);</span>
<span class="fc" id="L1227">        observer.blockingGet();</span>
<span class="fc" id="L1228">    }</span>

    /**
     * Subscribes to and awaits the termination of this Completable instance in a blocking manner
     * with a specific timeout and rethrows any exception emitted within the timeout window.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;348&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.blockingAwait.t.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code blockingAwait} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Error handling:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;If the source signals an error, the operator wraps a checked {@link Exception}
     *  into {@link RuntimeException} and throws that. Otherwise, {@code RuntimeException}s and
     *  {@link Error}s are rethrown as they are.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param timeout the timeout value
     * @param unit the timeout unit
     * @return true if the this Completable instance completed normally within the time limit,
     * false if the timeout elapsed before this Completable terminated.
     * @throws RuntimeException wrapping an InterruptedException if the current thread is interrupted
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final boolean blockingAwait(long timeout, TimeUnit unit) {
<span class="fc" id="L1253">        ObjectHelper.requireNonNull(unit, &quot;unit is null&quot;);</span>
<span class="fc" id="L1254">        BlockingMultiObserver&lt;Void&gt; observer = new BlockingMultiObserver&lt;Void&gt;();</span>
<span class="fc" id="L1255">        subscribe(observer);</span>
<span class="fc" id="L1256">        return observer.blockingAwait(timeout, unit);</span>
    }

    /**
     * Subscribes to this Completable instance and blocks until it terminates, then returns null or
     * the emitted exception if any.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;435&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.blockingGet.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code blockingGet} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @return the throwable if this terminated with an error, null otherwise
     * @throws RuntimeException that wraps an InterruptedException if the wait is interrupted
     */
    @Nullable
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Throwable blockingGet() {
<span class="fc" id="L1275">        BlockingMultiObserver&lt;Void&gt; observer = new BlockingMultiObserver&lt;Void&gt;();</span>
<span class="fc" id="L1276">        subscribe(observer);</span>
<span class="fc" id="L1277">        return observer.blockingGetError();</span>
    }

    /**
     * Subscribes to this Completable instance and blocks until it terminates or the specified timeout
     * elapses, then returns null for normal termination or the emitted exception if any.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;348&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.blockingGet.t.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code blockingGet} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param timeout the timeout value
     * @param unit the time unit
     * @return the throwable if this terminated with an error, null otherwise
     * @throws RuntimeException that wraps an InterruptedException if the wait is interrupted or
     * TimeoutException if the specified timeout elapsed before it
     */
    @Nullable
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Throwable blockingGet(long timeout, TimeUnit unit) {
<span class="fc" id="L1299">        ObjectHelper.requireNonNull(unit, &quot;unit is null&quot;);</span>
<span class="fc" id="L1300">        BlockingMultiObserver&lt;Void&gt; observer = new BlockingMultiObserver&lt;Void&gt;();</span>
<span class="fc" id="L1301">        subscribe(observer);</span>
<span class="fc" id="L1302">        return observer.blockingGetError(timeout, unit);</span>
    }

    /**
     * Subscribes to this Completable only once, when the first CompletableObserver
     * subscribes to the result Completable, caches its terminal event
     * and relays/replays it to observers.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;375&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.cache.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * Note that this operator doesn't allow disposing the connection
     * of the upstream source.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code cache} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * &lt;p&gt;History: 2.0.4 - experimental
     * @return the new Completable instance
     * @since 2.1
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Completable cache() {
<span class="fc" id="L1325">        return RxJavaPlugins.onAssembly(new CompletableCache(this));</span>
    }

    /**
     * Calls the given transformer function with this instance and returns the function's resulting
     * Completable.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;625&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.compose.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code compose} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param transformer the transformer function, not null
     * @return the Completable returned by the function
     * @throws NullPointerException if transformer is null
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Completable compose(CompletableTransformer transformer) {
<span class="fc" id="L1344">        return wrap(ObjectHelper.requireNonNull(transformer, &quot;transformer is null&quot;).apply(this));</span>
    }

    /**
     * Concatenates this Completable with another Completable.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;317&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.concatWith.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code concatWith} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param other the other Completable, not null
     * @return the new Completable which subscribes to this and then the other Completable
     * @throws NullPointerException if other is null
     * @see #andThen(MaybeSource)
     * @see #andThen(ObservableSource)
     * @see #andThen(SingleSource)
     * @see #andThen(Publisher)
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Completable concatWith(CompletableSource other) {
<span class="fc" id="L1367">        ObjectHelper.requireNonNull(other, &quot;other is null&quot;);</span>
<span class="fc" id="L1368">        return RxJavaPlugins.onAssembly(new CompletableAndThenCompletable(this, other));</span>
    }

    /**
     * Returns a Completable which delays the emission of the completion event by the given time.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;343&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.delay.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code delay} does operate by default on the {@code computation} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param delay the delay time
     * @param unit the delay unit
     * @return the new Completable instance
     * @throws NullPointerException if unit is null
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.COMPUTATION)
    public final Completable delay(long delay, TimeUnit unit) {
<span class="fc" id="L1387">        return delay(delay, unit, Schedulers.computation(), false);</span>
    }

    /**
     * Returns a Completable which delays the emission of the completion event by the given time while
     * running on the specified scheduler.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;313&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.delay.s.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code delay} operates on the {@link Scheduler} you specify.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param delay the delay time
     * @param unit the delay unit
     * @param scheduler the scheduler to run the delayed completion on
     * @return the new Completable instance
     * @throws NullPointerException if unit or scheduler is null
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Completable delay(long delay, TimeUnit unit, Scheduler scheduler) {
<span class="fc" id="L1408">        return delay(delay, unit, scheduler, false);</span>
    }

    /**
     * Returns a Completable which delays the emission of the completion event, and optionally the error as well, by the given time while
     * running on the specified scheduler.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;253&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.delay.sb.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code delay} operates on the {@link Scheduler} you specify.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param delay the delay time
     * @param unit the delay unit
     * @param scheduler the scheduler to run the delayed completion on
     * @param delayError delay the error emission as well?
     * @return the new Completable instance
     * @throws NullPointerException if unit or scheduler is null
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Completable delay(final long delay, final TimeUnit unit, final Scheduler scheduler, final boolean delayError) {
<span class="fc" id="L1431">        ObjectHelper.requireNonNull(unit, &quot;unit is null&quot;);</span>
<span class="fc" id="L1432">        ObjectHelper.requireNonNull(scheduler, &quot;scheduler is null&quot;);</span>
<span class="fc" id="L1433">        return RxJavaPlugins.onAssembly(new CompletableDelay(this, delay, unit, scheduler, delayError));</span>
    }

    /**
     * Returns a Completable that delays the subscription to the source CompletableSource by a given amount of time.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;475&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.delaySubscription.t.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code delaySubscription} operates by default on the {@code computation} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param delay the time to delay the subscription
     * @param unit  the time unit of {@code delay}
     * @return a Completable that delays the subscription to the source CompletableSource by the given amount
     * @since 2.2.3 - experimental
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/delay.html&quot;&gt;ReactiveX operators documentation: Delay&lt;/a&gt;
     */
    @CheckReturnValue
    @Experimental
    @SchedulerSupport(SchedulerSupport.COMPUTATION)
    public final Completable delaySubscription(long delay, TimeUnit unit) {
<span class="fc" id="L1455">        return delaySubscription(delay, unit, Schedulers.computation());</span>
    }

    /**
     * Returns a Completable that delays the subscription to the source CompletableSource by a given amount of time,
     * both waiting and subscribing on a given Scheduler.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;420&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.delaySubscription.ts.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;You specify which {@link Scheduler} this operator will use.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param delay     the time to delay the subscription
     * @param unit      the time unit of {@code delay}
     * @param scheduler the Scheduler on which the waiting and subscription will happen
     * @return a Completable that delays the subscription to the source CompletableSource by a given
     * amount, waiting and subscribing on the given Scheduler
     * @since 2.2.3 - experimental
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/delay.html&quot;&gt;ReactiveX operators documentation: Delay&lt;/a&gt;
     */
    @CheckReturnValue
    @Experimental
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Completable delaySubscription(long delay, TimeUnit unit, Scheduler scheduler) {
<span class="fc" id="L1480">        return Completable.timer(delay, unit, scheduler).andThen(this);</span>
    }

    /**
     * Returns a Completable which calls the given onComplete callback if this Completable completes.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;304&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.doOnComplete.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code doOnComplete} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param onComplete the callback to call when this emits an onComplete event
     * @return the new Completable instance
     * @throws NullPointerException if onComplete is null
     * @see #doFinally(Action)
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Completable doOnComplete(Action onComplete) {
<span class="fc" id="L1499">        return doOnLifecycle(Functions.emptyConsumer(), Functions.emptyConsumer(),</span>
                onComplete, Functions.EMPTY_ACTION,
                Functions.EMPTY_ACTION, Functions.EMPTY_ACTION);
    }

    /**
     * Calls the shared {@code Action} if a CompletableObserver subscribed to the current
     * Completable disposes the common Disposable it received via onSubscribe.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;589&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.doOnDispose.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code doOnDispose} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param onDispose the action to call when the child subscriber disposes the subscription
     * @return the new Completable instance
     * @throws NullPointerException if onDispose is null
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Completable doOnDispose(Action onDispose) {
<span class="fc" id="L1520">        return doOnLifecycle(Functions.emptyConsumer(), Functions.emptyConsumer(),</span>
                Functions.EMPTY_ACTION, Functions.EMPTY_ACTION,
                Functions.EMPTY_ACTION, onDispose);
    }

    /**
     * Returns a Completable which calls the given onError callback if this Completable emits an error.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;304&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.doOnError.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code doOnError} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param onError the error callback
     * @return the new Completable instance
     * @throws NullPointerException if onError is null
     * @see #doFinally(Action)
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Completable doOnError(Consumer&lt;? super Throwable&gt; onError) {
<span class="fc" id="L1541">        return doOnLifecycle(Functions.emptyConsumer(), onError,</span>
                Functions.EMPTY_ACTION, Functions.EMPTY_ACTION,
                Functions.EMPTY_ACTION, Functions.EMPTY_ACTION);
    }

    /**
     * Returns a Completable which calls the given onEvent callback with the (throwable) for an onError
     * or (null) for an onComplete signal from this Completable before delivering said signal to the downstream.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.doOnEvent.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code doOnEvent} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param onEvent the event callback
     * @return the new Completable instance
     * @throws NullPointerException if onEvent is null
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Completable doOnEvent(final Consumer&lt;? super Throwable&gt; onEvent) {
<span class="fc" id="L1563">        ObjectHelper.requireNonNull(onEvent, &quot;onEvent is null&quot;);</span>
<span class="fc" id="L1564">        return RxJavaPlugins.onAssembly(new CompletableDoOnEvent(this, onEvent));</span>
    }

    /**
     * Returns a Completable instance that calls the various callbacks on the specific
     * lifecycle events.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code doOnLifecycle} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param onSubscribe the consumer called when a CompletableSubscriber subscribes.
     * @param onError the consumer called when this emits an onError event
     * @param onComplete the runnable called just before when this Completable completes normally
     * @param onAfterTerminate the runnable called after this Completable completes normally
     * @param onDispose the runnable called when the child disposes the subscription
     * @return the new Completable instance
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    private Completable doOnLifecycle(
            final Consumer&lt;? super Disposable&gt; onSubscribe,
            final Consumer&lt;? super Throwable&gt; onError,
            final Action onComplete,
            final Action onTerminate,
            final Action onAfterTerminate,
            final Action onDispose) {
<span class="fc" id="L1591">        ObjectHelper.requireNonNull(onSubscribe, &quot;onSubscribe is null&quot;);</span>
<span class="fc" id="L1592">        ObjectHelper.requireNonNull(onError, &quot;onError is null&quot;);</span>
<span class="fc" id="L1593">        ObjectHelper.requireNonNull(onComplete, &quot;onComplete is null&quot;);</span>
<span class="fc" id="L1594">        ObjectHelper.requireNonNull(onTerminate, &quot;onTerminate is null&quot;);</span>
<span class="fc" id="L1595">        ObjectHelper.requireNonNull(onAfterTerminate, &quot;onAfterTerminate is null&quot;);</span>
<span class="fc" id="L1596">        ObjectHelper.requireNonNull(onDispose, &quot;onDispose is null&quot;);</span>
<span class="fc" id="L1597">        return RxJavaPlugins.onAssembly(new CompletablePeek(this, onSubscribe, onError, onComplete, onTerminate, onAfterTerminate, onDispose));</span>
    }

    /**
     * Returns a Completable instance that calls the given onSubscribe callback with the disposable
     * that child subscribers receive on subscription.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;304&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.doOnSubscribe.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code doOnSubscribe} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param onSubscribe the callback called when a child subscriber subscribes
     * @return the new Completable instance
     * @throws NullPointerException if onSubscribe is null
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Completable doOnSubscribe(Consumer&lt;? super Disposable&gt; onSubscribe) {
<span class="fc" id="L1616">        return doOnLifecycle(onSubscribe, Functions.emptyConsumer(),</span>
                Functions.EMPTY_ACTION, Functions.EMPTY_ACTION,
                Functions.EMPTY_ACTION, Functions.EMPTY_ACTION);
    }

    /**
     * Returns a Completable instance that calls the given onTerminate callback just before this Completable
     * completes normally or with an exception.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;304&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.doOnTerminate.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code doOnTerminate} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param onTerminate the callback to call just before this Completable terminates
     * @return the new Completable instance
     * @see #doFinally(Action)
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Completable doOnTerminate(final Action onTerminate) {
<span class="fc" id="L1637">        return doOnLifecycle(Functions.emptyConsumer(), Functions.emptyConsumer(),</span>
                Functions.EMPTY_ACTION, onTerminate,
                Functions.EMPTY_ACTION, Functions.EMPTY_ACTION);
    }

    /**
     * Returns a Completable instance that calls the given onTerminate callback after this Completable
     * completes normally or with an exception.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;304&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.doAfterTerminate.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code doAfterTerminate} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param onAfterTerminate the callback to call after this Completable terminates
     * @return the new Completable instance
     * @see #doFinally(Action)
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Completable doAfterTerminate(final Action onAfterTerminate) {
<span class="fc" id="L1658">        return doOnLifecycle(</span>
<span class="fc" id="L1659">                Functions.emptyConsumer(),</span>
<span class="fc" id="L1660">                Functions.emptyConsumer(),</span>
                Functions.EMPTY_ACTION,
                Functions.EMPTY_ACTION,
                onAfterTerminate,
                Functions.EMPTY_ACTION);
    }
    /**
     * Calls the specified action after this Completable signals onError or onComplete or gets disposed by
     * the downstream.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;331&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.doFinally.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * In case of a race between a terminal event and a dispose call, the provided {@code onFinally} action
     * is executed once per subscription.
     * &lt;p&gt;
     * Note that the {@code onFinally} action is shared between subscriptions and as such
     * should be thread-safe.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code doFinally} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * &lt;p&gt;History: 2.0.1 - experimental
     * @param onFinally the action called when this Completable terminates or gets disposed
     * @return the new Completable instance
     * @since 2.1
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Completable doFinally(Action onFinally) {
<span class="fc" id="L1690">        ObjectHelper.requireNonNull(onFinally, &quot;onFinally is null&quot;);</span>
<span class="fc" id="L1691">        return RxJavaPlugins.onAssembly(new CompletableDoFinally(this, onFinally));</span>
    }

    /**
     * &lt;strong&gt;This method requires advanced knowledge about building operators, please consider
     * other standard composition methods first;&lt;/strong&gt;
     * Returns a {@code Completable} which, when subscribed to, invokes the {@link CompletableOperator#apply(CompletableObserver) apply(CompletableObserver)} method
     * of the provided {@link CompletableOperator} for each individual downstream {@link Completable} and allows the
     * insertion of a custom operator by accessing the downstream's {@link CompletableObserver} during this subscription phase
     * and providing a new {@code CompletableObserver}, containing the custom operator's intended business logic, that will be
     * used in the subscription process going further upstream.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;313&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.lift.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * Generally, such a new {@code CompletableObserver} will wrap the downstream's {@code CompletableObserver} and forwards the
     * {@code onError} and {@code onComplete} events from the upstream directly or according to the
     * emission pattern the custom operator's business logic requires. In addition, such operator can intercept the
     * flow control calls of {@code dispose} and {@code isDisposed} that would have traveled upstream and perform
     * additional actions depending on the same business logic requirements.
     * &lt;p&gt;
     * Example:
     * &lt;pre&gt;&lt;code&gt;
     * // Step 1: Create the consumer type that will be returned by the CompletableOperator.apply():
     * 
     * public final class CustomCompletableObserver implements CompletableObserver, Disposable {
     *
     *     // The downstream's CompletableObserver that will receive the onXXX events
     *     final CompletableObserver downstream;
     *
     *     // The connection to the upstream source that will call this class' onXXX methods
     *     Disposable upstream;
     *
     *     // The constructor takes the downstream subscriber and usually any other parameters
     *     public CustomCompletableObserver(CompletableObserver downstream) {
     *         this.downstream = downstream;
     *     }
     *
     *     // In the subscription phase, the upstream sends a Disposable to this class
     *     // and subsequently this class has to send a Disposable to the downstream.
     *     // Note that relaying the upstream's Disposable directly is not allowed in RxJava
     *     &amp;#64;Override
     *     public void onSubscribe(Disposable d) {
     *         if (upstream != null) {
     *             d.dispose();
     *         } else {
     *             upstream = d;
     *             downstream.onSubscribe(this);
     *         }
     *     }
     *
     *     // Some operators may handle the upstream's error while others
     *     // could just forward it to the downstream.
     *     &amp;#64;Override
     *     public void onError(Throwable throwable) {
     *         downstream.onError(throwable);
     *     }
     *
     *     // When the upstream completes, usually the downstream should complete as well.
     *     // In completable, this could also mean doing some side-effects
     *     &amp;#64;Override
     *     public void onComplete() {
     *         System.out.println(&quot;Sequence completed&quot;);
     *         downstream.onComplete();
     *     }
     *
     *     // Some operators may use their own resources which should be cleaned up if
     *     // the downstream disposes the flow before it completed. Operators without
     *     // resources can simply forward the dispose to the upstream.
     *     // In some cases, a disposed flag may be set by this method so that other parts
     *     // of this class may detect the dispose and stop sending events
     *     // to the downstream.
     *     &amp;#64;Override
     *     public void dispose() {
     *         upstream.dispose();
     *     }
     *
     *     // Some operators may simply forward the call to the upstream while others
     *     // can return the disposed flag set in dispose().
     *     &amp;#64;Override
     *     public boolean isDisposed() {
     *         return upstream.isDisposed();
     *     }
     * }
     *
     * // Step 2: Create a class that implements the CompletableOperator interface and
     * //         returns the custom consumer type from above in its apply() method.
     * //         Such class may define additional parameters to be submitted to
     * //         the custom consumer type.
     *
     * final class CustomCompletableOperator implements CompletableOperator {
     *     &amp;#64;Override
     *     public CompletableObserver apply(CompletableObserver upstream) {
     *         return new CustomCompletableObserver(upstream);
     *     }
     * }
     *
     * // Step 3: Apply the custom operator via lift() in a flow by creating an instance of it
     * //         or reusing an existing one.
     *
     * Completable.complete()
     * .lift(new CustomCompletableOperator())
     * .test()
     * .assertResult();
     * &lt;/code&gt;&lt;/pre&gt;
     * &lt;p&gt;
     * Creating custom operators can be complicated and it is recommended one consults the
     * &lt;a href=&quot;https://github.com/ReactiveX/RxJava/wiki/Writing-operators-for-2.0&quot;&gt;RxJava wiki: Writing operators&lt;/a&gt; page about
     * the tools, requirements, rules, considerations and pitfalls of implementing them.
     * &lt;p&gt;
     * Note that implementing custom operators via this {@code lift()} method adds slightly more overhead by requiring
     * an additional allocation and indirection per assembled flows. Instead, extending the abstract {@code Completable}
     * class and creating a {@link CompletableTransformer} with it is recommended.
     * &lt;p&gt;
     * Note also that it is not possible to stop the subscription phase in {@code lift()} as the {@code apply()} method
     * requires a non-null {@code CompletableObserver} instance to be returned, which is then unconditionally subscribed to
     * the upstream {@code Completable}. For example, if the operator decided there is no reason to subscribe to the
     * upstream source because of some optimization possibility or a failure to prepare the operator, it still has to
     * return a {@code CompletableObserver} that should immediately dispose the upstream's {@code Disposable} in its
     * {@code onSubscribe} method. Again, using a {@code CompletableTransformer} and extending the {@code Completable} is
     * a better option as {@link #subscribeActual} can decide to not subscribe to its upstream after all.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code lift} does not operate by default on a particular {@link Scheduler}, however, the
     *  {@link CompletableOperator} may use a {@code Scheduler} to support its own asynchronous behavior.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param onLift the {@link CompletableOperator} that receives the downstream's {@code CompletableObserver} and should return
     *               a {@code CompletableObserver} with custom behavior to be used as the consumer for the current
     *               {@code Completable}.
     * @return the new Completable instance
     * @see &lt;a href=&quot;https://github.com/ReactiveX/RxJava/wiki/Writing-operators-for-2.0&quot;&gt;RxJava wiki: Writing operators&lt;/a&gt;
     * @see #compose(CompletableTransformer)
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Completable lift(final CompletableOperator onLift) {
<span class="fc" id="L1828">        ObjectHelper.requireNonNull(onLift, &quot;onLift is null&quot;);</span>
<span class="fc" id="L1829">        return RxJavaPlugins.onAssembly(new CompletableLift(this, onLift));</span>
    }

    /**
     * Maps the signal types of this Completable into a {@link Notification} of the same kind
     * and emits it as a single success value to downstream.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/materialize.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code materialize} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;T&gt; the intended target element type of the notification
     * @return the new Single instance
     * @since 2.2.4 - experimental
     * @see Single#dematerialize(Function)
     */
    @Experimental
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;T&gt; Single&lt;Notification&lt;T&gt;&gt; materialize() {
<span class="fc" id="L1850">        return RxJavaPlugins.onAssembly(new CompletableMaterialize&lt;T&gt;(this));</span>
    }

    /**
     * Returns a Completable which subscribes to this and the other Completable and completes
     * when both of them complete or one emits an error.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;442&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.mergeWith.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code mergeWith} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param other the other Completable instance
     * @return the new Completable instance
     * @throws NullPointerException if other is null
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Completable mergeWith(CompletableSource other) {
<span class="fc" id="L1870">        ObjectHelper.requireNonNull(other, &quot;other is null&quot;);</span>
<span class="fc" id="L1871">        return mergeArray(this, other);</span>
    }

    /**
     * Returns a Completable which emits the terminal events from the thread of the specified scheduler.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;523&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.observeOn.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code observeOn} operates on a {@link Scheduler} you specify.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param scheduler the scheduler to emit terminal events on
     * @return the new Completable instance
     * @throws NullPointerException if scheduler is null
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Completable observeOn(final Scheduler scheduler) {
<span class="fc" id="L1890">        ObjectHelper.requireNonNull(scheduler, &quot;scheduler is null&quot;);</span>
<span class="fc" id="L1891">        return RxJavaPlugins.onAssembly(new CompletableObserveOn(this, scheduler));</span>
    }

    /**
     * Returns a Completable instance that if this Completable emits an error, it will emit an onComplete
     * and swallow the throwable.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;585&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.onErrorComplete.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code onErrorComplete} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @return the new Completable instance
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Completable onErrorComplete() {
<span class="fc" id="L1908">        return onErrorComplete(Functions.alwaysTrue());</span>
    }

    /**
     * Returns a Completable instance that if this Completable emits an error and the predicate returns
     * true, it will emit an onComplete and swallow the throwable.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;283&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.onErrorComplete.f.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code onErrorComplete} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param predicate the predicate to call when an Throwable is emitted which should return true
     * if the Throwable should be swallowed and replaced with an onComplete.
     * @return the new Completable instance
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Completable onErrorComplete(final Predicate&lt;? super Throwable&gt; predicate) {
<span class="fc" id="L1928">        ObjectHelper.requireNonNull(predicate, &quot;predicate is null&quot;);</span>

<span class="fc" id="L1930">        return RxJavaPlugins.onAssembly(new CompletableOnErrorComplete(this, predicate));</span>
    }

    /**
     * Returns a Completable instance that when encounters an error from this Completable, calls the
     * specified mapper function that returns another Completable instance for it and resumes the
     * execution with it.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;426&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.onErrorResumeNext.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code onErrorResumeNext} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param errorMapper the mapper function that takes the error and should return a Completable as
     * continuation.
     * @return the new Completable instance
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Completable onErrorResumeNext(final Function&lt;? super Throwable, ? extends CompletableSource&gt; errorMapper) {
<span class="fc" id="L1951">        ObjectHelper.requireNonNull(errorMapper, &quot;errorMapper is null&quot;);</span>
<span class="fc" id="L1952">        return RxJavaPlugins.onAssembly(new CompletableResumeNext(this, errorMapper));</span>
    }

    /**
     * Nulls out references to the upstream producer and downstream CompletableObserver if
     * the sequence is terminated or downstream calls dispose().
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;326&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.onTerminateDetach.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code onTerminateDetach} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * &lt;p&gt;History: 2.1.5 - experimental
     * @return a Completable which nulls out references to the upstream producer and downstream CompletableObserver if
     * the sequence is terminated or downstream calls dispose()
     * @since 2.2
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Completable onTerminateDetach() {
<span class="fc" id="L1972">        return RxJavaPlugins.onAssembly(new CompletableDetach(this));</span>
    }

    /**
     * Returns a Completable that repeatedly subscribes to this Completable until disposed.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;373&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.repeat.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code repeat} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @return the new Completable instance
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Completable repeat() {
<span class="fc" id="L1988">        return fromPublisher(toFlowable().repeat());</span>
    }

    /**
     * Returns a Completable that subscribes repeatedly at most the given times to this Completable.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;408&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.repeat.n.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code repeat} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param times the number of times the resubscription should happen
     * @return the new Completable instance
     * @throws IllegalArgumentException if times is less than zero
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Completable repeat(long times) {
<span class="fc" id="L2006">        return fromPublisher(toFlowable().repeat(times));</span>
    }

    /**
     * Returns a Completable that repeatedly subscribes to this Completable so long as the given
     * stop supplier returns false.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;381&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.repeatUntil.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code repeatUntil} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param stop the supplier that should return true to stop resubscribing.
     * @return the new Completable instance
     * @throws NullPointerException if stop is null
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Completable repeatUntil(BooleanSupplier stop) {
<span class="fc" id="L2025">        return fromPublisher(toFlowable().repeatUntil(stop));</span>
    }

    /**
     * Returns a Completable instance that repeats when the Publisher returned by the handler
     * emits an item or completes when this Publisher emits a completed event.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;586&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.repeatWhen.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code repeatWhen} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param handler the function that transforms the stream of values indicating the completion of
     * this Completable and returns a Publisher that emits items for repeating or completes to indicate the
     * repetition should stop
     * @return the new Completable instance
     * @throws NullPointerException if stop is null
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Completable repeatWhen(Function&lt;? super Flowable&lt;Object&gt;, ? extends Publisher&lt;?&gt;&gt; handler) {
<span class="fc" id="L2046">        return fromPublisher(toFlowable().repeatWhen(handler));</span>
    }

    /**
     * Returns a Completable that retries this Completable as long as it emits an onError event.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;368&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.retry.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code retry} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @return the new Completable instance
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Completable retry() {
<span class="fc" id="L2062">        return fromPublisher(toFlowable().retry());</span>
    }

    /**
     * Returns a Completable that retries this Completable in case of an error as long as the predicate
     * returns true.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;325&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.retry.ff.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code retry} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param predicate the predicate called when this emits an error with the repeat count and the latest exception
     * and should return true to retry.
     * @return the new Completable instance
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Completable retry(BiPredicate&lt;? super Integer, ? super Throwable&gt; predicate) {
<span class="fc" id="L2081">        return fromPublisher(toFlowable().retry(predicate));</span>
    }

    /**
     * Returns a Completable that when this Completable emits an error, retries at most the given
     * number of times before giving up and emitting the last error.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;451&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.retry.n.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code retry} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param times the number of times to resubscribe if the current Completable fails
     * @return the new Completable instance
     * @throws IllegalArgumentException if times is negative
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Completable retry(long times) {
<span class="fc" id="L2100">        return fromPublisher(toFlowable().retry(times));</span>
    }

    /**
     * Returns a Completable that when this Completable emits an error, retries at most times
     * or until the predicate returns false, whichever happens first and emitting the last error.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;361&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.retry.nf.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code retry} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * &lt;p&gt;History: 2.1.8 - experimental
     * @param times the number of times to resubscribe if the current Completable fails
     * @param predicate the predicate that is called with the latest throwable and should return
     * true to indicate the returned Completable should resubscribe to this Completable.
     * @return the new Completable instance
     * @throws NullPointerException if predicate is null
     * @throws IllegalArgumentException if times is negative
     * @since 2.2
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Completable retry(long times, Predicate&lt;? super Throwable&gt; predicate) {
<span class="fc" id="L2124">        return fromPublisher(toFlowable().retry(times, predicate));</span>
    }

    /**
     * Returns a Completable that when this Completable emits an error, calls the given predicate with
     * the latest exception to decide whether to resubscribe to this or not.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;336&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.retry.f.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code retry} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param predicate the predicate that is called with the latest throwable and should return
     * true to indicate the returned Completable should resubscribe to this Completable.
     * @return the new Completable instance
     * @throws NullPointerException if predicate is null
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Completable retry(Predicate&lt;? super Throwable&gt; predicate) {
<span class="fc" id="L2144">        return fromPublisher(toFlowable().retry(predicate));</span>
    }

    /**
     * Returns a Completable which given a Publisher and when this Completable emits an error, delivers
     * that error through a Flowable and the Publisher should signal a value indicating a retry in response
     * or a terminal event indicating a termination.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;586&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.retryWhen.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * Note that the inner {@code Publisher} returned by the handler function should signal
     * either {@code onNext}, {@code onError} or {@code onComplete} in response to the received
     * {@code Throwable} to indicate the operator should retry or terminate. If the upstream to
     * the operator is asynchronous, signalling onNext followed by onComplete immediately may
     * result in the sequence to be completed immediately. Similarly, if this inner
     * {@code Publisher} signals {@code onError} or {@code onComplete} while the upstream is
     * active, the sequence is terminated with the same signal immediately.
     * &lt;p&gt;
     * The following example demonstrates how to retry an asynchronous source with a delay:
     * &lt;pre&gt;&lt;code&gt;
     * Completable.timer(1, TimeUnit.SECONDS)
     *     .doOnSubscribe(s -&amp;gt; System.out.println(&quot;subscribing&quot;))
     *     .doOnComplete(() -&amp;gt; { throw new RuntimeException(); })
     *     .retryWhen(errors -&amp;gt; {
     *         AtomicInteger counter = new AtomicInteger();
     *         return errors
     *                   .takeWhile(e -&amp;gt; counter.getAndIncrement() != 3)
     *                   .flatMap(e -&amp;gt; {
     *                       System.out.println(&quot;delay retry by &quot; + counter.get() + &quot; second(s)&quot;);
     *                       return Flowable.timer(counter.get(), TimeUnit.SECONDS);
     *                   });
     *     })
     *     .blockingAwait();
     * &lt;/code&gt;&lt;/pre&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code retryWhen} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param handler the handler that receives a Flowable delivering Throwables and should return a Publisher that
     * emits items to indicate retries or emits terminal events to indicate termination.
     * @return the new Completable instance
     * @throws NullPointerException if handler is null
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Completable retryWhen(Function&lt;? super Flowable&lt;Throwable&gt;, ? extends Publisher&lt;?&gt;&gt; handler) {
<span class="fc" id="L2190">        return fromPublisher(toFlowable().retryWhen(handler));</span>
    }

    /**
     * Returns a Completable which first runs the other Completable
     * then this completable if the other completed normally.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;437&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.startWith.c.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code startWith} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param other the other completable to run first
     * @return the new Completable instance
     * @throws NullPointerException if other is null
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Completable startWith(CompletableSource other) {
<span class="fc" id="L2210">        ObjectHelper.requireNonNull(other, &quot;other is null&quot;);</span>
<span class="fc" id="L2211">        return concatArray(other, this);</span>
    }

    /**
     * Returns an Observable which first delivers the events
     * of the other Observable then runs this CompletableConsumable.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;289&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.startWith.o.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code startWith} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;T&gt; the value type
     * @param other the other Observable to run first
     * @return the new Observable instance
     * @throws NullPointerException if other is null
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;T&gt; Observable&lt;T&gt; startWith(Observable&lt;T&gt; other) {
<span class="fc" id="L2232">        ObjectHelper.requireNonNull(other, &quot;other is null&quot;);</span>
<span class="fc" id="L2233">        return other.concatWith(this.&lt;T&gt;toObservable());</span>
    }
    /**
     * Returns a Flowable which first delivers the events
     * of the other Publisher then runs this Completable.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;250&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.startWith.p.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The returned {@code Flowable} honors the backpressure of the downstream consumer
     *  and expects the other {@code Publisher} to honor it as well.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code startWith} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;T&gt; the value type
     * @param other the other Publisher to run first
     * @return the new Flowable instance
     * @throws NullPointerException if other is null
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;T&gt; Flowable&lt;T&gt; startWith(Publisher&lt;T&gt; other) {
<span class="fc" id="L2257">        ObjectHelper.requireNonNull(other, &quot;other is null&quot;);</span>
<span class="fc" id="L2258">        return this.&lt;T&gt;toFlowable().startWith(other);</span>
    }

    /**
     * Hides the identity of this Completable and its Disposable.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;432&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.hide.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * Allows preventing certain identity-based optimizations (fusion).
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code hide} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * &lt;p&gt;History: 2.0.5 - experimental
     * @return the new Completable instance
     * @since 2.1
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Completable hide() {
<span class="fc" id="L2278">        return RxJavaPlugins.onAssembly(new CompletableHide(this));</span>
    }

    /**
     * Subscribes to this CompletableConsumable and returns a Disposable which can be used to dispose
     * the subscription.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;352&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.subscribe.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code subscribe} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @return the Disposable that allows disposing the subscription
     */
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Disposable subscribe() {
<span class="fc" id="L2294">        EmptyCompletableObserver observer = new EmptyCompletableObserver();</span>
<span class="fc" id="L2295">        subscribe(observer);</span>
<span class="fc" id="L2296">        return observer;</span>
    }

    @SchedulerSupport(SchedulerSupport.NONE)
    @Override
    public final void subscribe(CompletableObserver observer) {
<span class="fc" id="L2302">        ObjectHelper.requireNonNull(observer, &quot;observer is null&quot;);</span>
        try {

<span class="fc" id="L2305">            observer = RxJavaPlugins.onSubscribe(this, observer);</span>

<span class="fc" id="L2307">            ObjectHelper.requireNonNull(observer, &quot;The RxJavaPlugins.onSubscribe hook returned a null CompletableObserver. Please check the handler provided to RxJavaPlugins.setOnCompletableSubscribe for invalid null returns. Further reading: https://github.com/ReactiveX/RxJava/wiki/Plugins&quot;);</span>

<span class="fc" id="L2309">            subscribeActual(observer);</span>
<span class="fc" id="L2310">        } catch (NullPointerException ex) { // NOPMD</span>
<span class="fc" id="L2311">            throw ex;</span>
<span class="fc" id="L2312">        } catch (Throwable ex) {</span>
<span class="fc" id="L2313">            Exceptions.throwIfFatal(ex);</span>
<span class="fc" id="L2314">            RxJavaPlugins.onError(ex);</span>
<span class="fc" id="L2315">            throw toNpe(ex);</span>
<span class="fc" id="L2316">        }</span>
<span class="fc" id="L2317">    }</span>

    /**
     * Implement this method to handle the incoming {@link CompletableObserver}s and
     * perform the business logic in your operator.
     * &lt;p&gt;There is no need to call any of the plugin hooks on the current {@code Completable} instance or
     * the {@code CompletableObserver}; all hooks and basic safeguards have been
     * applied by {@link #subscribe(CompletableObserver)} before this method gets called.
     * @param observer the CompletableObserver instance, never null
     */
    protected abstract void subscribeActual(CompletableObserver observer);

    /**
     * Subscribes a given CompletableObserver (subclass) to this Completable and returns the given
     * CompletableObserver as is.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;349&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.subscribeWith.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;Usage example:
     * &lt;pre&gt;&lt;code&gt;
     * Completable source = Completable.complete().delay(1, TimeUnit.SECONDS);
     * CompositeDisposable composite = new CompositeDisposable();
     *
     * DisposableCompletableObserver ds = new DisposableCompletableObserver() {
     *     // ...
     * };
     *
     * composite.add(source.subscribeWith(ds));
     * &lt;/code&gt;&lt;/pre&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code subscribeWith} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;E&gt; the type of the CompletableObserver to use and return
     * @param observer the CompletableObserver (subclass) to use and return, not null
     * @return the input {@code observer}
     * @throws NullPointerException if {@code observer} is null
     * @since 2.0
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;E extends CompletableObserver&gt; E subscribeWith(E observer) {
<span class="fc" id="L2358">        subscribe(observer);</span>
<span class="fc" id="L2359">        return observer;</span>
    }

    /**
     * Subscribes to this Completable and calls back either the onError or onComplete functions.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;352&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.subscribe.ff.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code subscribe} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param onComplete the runnable that is called if the Completable completes normally
     * @param onError the consumer that is called if this Completable emits an error
     * @return the Disposable that can be used for disposing the subscription asynchronously
     * @throws NullPointerException if either callback is null
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Disposable subscribe(final Action onComplete, final Consumer&lt;? super Throwable&gt; onError) {
<span class="fc" id="L2379">        ObjectHelper.requireNonNull(onError, &quot;onError is null&quot;);</span>
<span class="fc" id="L2380">        ObjectHelper.requireNonNull(onComplete, &quot;onComplete is null&quot;);</span>

<span class="fc" id="L2382">        CallbackCompletableObserver observer = new CallbackCompletableObserver(onError, onComplete);</span>
<span class="fc" id="L2383">        subscribe(observer);</span>
<span class="fc" id="L2384">        return observer;</span>
    }

    /**
     * Subscribes to this Completable and calls the given Action when this Completable
     * completes normally.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;352&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.subscribe.f.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * If the Completable emits an error, it is wrapped into an
     * {@link io.reactivex.exceptions.OnErrorNotImplementedException OnErrorNotImplementedException}
     * and routed to the RxJavaPlugins.onError handler.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code subscribe} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param onComplete the runnable called when this Completable completes normally
     * @return the Disposable that allows disposing the subscription
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Disposable subscribe(final Action onComplete) {
<span class="fc" id="L2407">        ObjectHelper.requireNonNull(onComplete, &quot;onComplete is null&quot;);</span>

<span class="fc" id="L2409">        CallbackCompletableObserver observer = new CallbackCompletableObserver(onComplete);</span>
<span class="fc" id="L2410">        subscribe(observer);</span>
<span class="fc" id="L2411">        return observer;</span>
    }

    /**
     * Returns a Completable which subscribes the child subscriber on the specified scheduler, making
     * sure the subscription side-effects happen on that specific thread of the scheduler.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;686&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.subscribeOn.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code subscribeOn} operates on a {@link Scheduler} you specify.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param scheduler the Scheduler to subscribe on
     * @return the new Completable instance
     * @throws NullPointerException if scheduler is null
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Completable subscribeOn(final Scheduler scheduler) {
<span class="fc" id="L2431">        ObjectHelper.requireNonNull(scheduler, &quot;scheduler is null&quot;);</span>

<span class="fc" id="L2433">        return RxJavaPlugins.onAssembly(new CompletableSubscribeOn(this, scheduler));</span>
    }

    /**
     * Terminates the downstream if this or the other {@code Completable}
     * terminates (wins the termination race) while disposing the connection to the losing source.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;468&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.takeuntil.c.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code takeUntil} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Error handling:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;If both this and the other sources signal an error, only one of the errors
     *  is signaled to the downstream and the other error is signaled to the global
     *  error handler via {@link RxJavaPlugins#onError(Throwable)}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * &lt;p&gt;History: 2.1.17 - experimental
     * @param other the other completable source to observe for the terminal signals
     * @return the new Completable instance
     * @since 2.2
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Completable takeUntil(CompletableSource other) {
<span class="fc" id="L2458">        ObjectHelper.requireNonNull(other, &quot;other is null&quot;);</span>

<span class="fc" id="L2460">        return RxJavaPlugins.onAssembly(new CompletableTakeUntilCompletable(this, other));</span>
    }

    /**
     * Returns a Completable that runs this Completable and emits a TimeoutException in case
     * this Completable doesn't complete within the given time.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;348&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.timeout.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code timeout} signals the TimeoutException on the {@code computation} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param timeout the timeout value
     * @param unit the timeout unit
     * @return the new Completable instance
     * @throws NullPointerException if unit is null
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.COMPUTATION)
    public final Completable timeout(long timeout, TimeUnit unit) {
<span class="fc" id="L2480">        return timeout0(timeout, unit, Schedulers.computation(), null);</span>
    }

    /**
     * Returns a Completable that runs this Completable and switches to the other Completable
     * in case this Completable doesn't complete within the given time.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;308&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.timeout.c.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code timeout} subscribes to the other CompletableSource on
     *  the {@code computation} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param timeout the timeout value
     * @param unit the timeout unit
     * @param other the other Completable instance to switch to in case of a timeout
     * @return the new Completable instance
     * @throws NullPointerException if unit or other is null
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.COMPUTATION)
    public final Completable timeout(long timeout, TimeUnit unit, CompletableSource other) {
<span class="fc" id="L2503">        ObjectHelper.requireNonNull(other, &quot;other is null&quot;);</span>
<span class="fc" id="L2504">        return timeout0(timeout, unit, Schedulers.computation(), other);</span>
    }

    /**
     * Returns a Completable that runs this Completable and emits a TimeoutException in case
     * this Completable doesn't complete within the given time while &quot;waiting&quot; on the specified
     * Scheduler.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;348&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.timeout.s.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code timeout} signals the TimeoutException on the {@link Scheduler} you specify.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param timeout the timeout value
     * @param unit the timeout unit
     * @param scheduler the scheduler to use to wait for completion
     * @return the new Completable instance
     * @throws NullPointerException if unit or scheduler is null
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Completable timeout(long timeout, TimeUnit unit, Scheduler scheduler) {
<span class="fc" id="L2526">        return timeout0(timeout, unit, scheduler, null);</span>
    }

    /**
     * Returns a Completable that runs this Completable and switches to the other Completable
     * in case this Completable doesn't complete within the given time while &quot;waiting&quot; on
     * the specified scheduler.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;308&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.timeout.sc.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code timeout} subscribes to the other CompletableSource on
     *  the {@link Scheduler} you specify.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param timeout the timeout value
     * @param unit the timeout unit
     * @param scheduler the scheduler to use to wait for completion
     * @param other the other Completable instance to switch to in case of a timeout
     * @return the new Completable instance
     * @throws NullPointerException if unit, scheduler or other is null
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Completable timeout(long timeout, TimeUnit unit, Scheduler scheduler, CompletableSource other) {
<span class="fc" id="L2551">        ObjectHelper.requireNonNull(other, &quot;other is null&quot;);</span>
<span class="fc" id="L2552">        return timeout0(timeout, unit, scheduler, other);</span>
    }

    /**
     * Returns a Completable that runs this Completable and optionally switches to the other Completable
     * in case this Completable doesn't complete within the given time while &quot;waiting&quot; on
     * the specified scheduler.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;You specify the {@link Scheduler} this operator runs on.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param timeout the timeout value
     * @param unit the timeout unit
     * @param scheduler the scheduler to use to wait for completion
     * @param other the other Completable instance to switch to in case of a timeout,
     * if null a TimeoutException is emitted instead
     * @return the new Completable instance
     * @throws NullPointerException if unit or scheduler
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    private Completable timeout0(long timeout, TimeUnit unit, Scheduler scheduler, CompletableSource other) {
<span class="fc" id="L2575">        ObjectHelper.requireNonNull(unit, &quot;unit is null&quot;);</span>
<span class="fc" id="L2576">        ObjectHelper.requireNonNull(scheduler, &quot;scheduler is null&quot;);</span>
<span class="fc" id="L2577">        return RxJavaPlugins.onAssembly(new CompletableTimeout(this, timeout, unit, scheduler, other));</span>
    }

    /**
     * Allows fluent conversion to another type via a function callback.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;751&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.to.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code to} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;U&gt; the output type
     * @param converter the function called with this which should return some other value.
     * @return the converted value
     * @throws NullPointerException if converter is null
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;U&gt; U to(Function&lt;? super Completable, U&gt; converter) {
        try {
<span class="fc" id="L2597">            return ObjectHelper.requireNonNull(converter, &quot;converter is null&quot;).apply(this);</span>
<span class="fc" id="L2598">        } catch (Throwable ex) {</span>
<span class="fc" id="L2599">            Exceptions.throwIfFatal(ex);</span>
<span class="fc" id="L2600">            throw ExceptionHelper.wrapOrThrow(ex);</span>
        }
    }

    /**
     * Returns a Flowable which when subscribed to subscribes to this Completable and
     * relays the terminal events to the subscriber.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;585&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.toFlowable.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The returned {@code Flowable} honors the backpressure of the downstream consumer.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code toFlowable} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;T&gt; the value type
     * @return the new Flowable instance
     */
    @CheckReturnValue
    @SuppressWarnings(&quot;unchecked&quot;)
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;T&gt; Flowable&lt;T&gt; toFlowable() {
<span class="fc bfc" id="L2623" title="All 2 branches covered.">        if (this instanceof FuseToFlowable) {</span>
<span class="fc" id="L2624">            return ((FuseToFlowable&lt;T&gt;)this).fuseToFlowable();</span>
        }
<span class="fc" id="L2626">        return RxJavaPlugins.onAssembly(new CompletableToFlowable&lt;T&gt;(this));</span>
    }

    /**
     * Converts this Completable into a {@link Maybe}.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;585&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.toMaybe.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code toMaybe} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T&gt; the value type
     * @return a {@link Maybe} that only calls {@code onComplete} or {@code onError}, based on which one is
     *         called by the source Completable.
     */
    @CheckReturnValue
    @SuppressWarnings(&quot;unchecked&quot;)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;T&gt; Maybe&lt;T&gt; toMaybe() {
<span class="fc bfc" id="L2646" title="All 2 branches covered.">        if (this instanceof FuseToMaybe) {</span>
<span class="fc" id="L2647">            return ((FuseToMaybe&lt;T&gt;)this).fuseToMaybe();</span>
        }
<span class="fc" id="L2649">        return RxJavaPlugins.onAssembly(new MaybeFromCompletable&lt;T&gt;(this));</span>
    }

    /**
     * Returns an Observable which when subscribed to subscribes to this Completable and
     * relays the terminal events to the subscriber.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;293&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.toObservable.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code toObservable} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;T&gt; the value type
     * @return the new Observable created
     */
    @CheckReturnValue
    @SuppressWarnings(&quot;unchecked&quot;)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;T&gt; Observable&lt;T&gt; toObservable() {
<span class="fc bfc" id="L2668" title="All 2 branches covered.">        if (this instanceof FuseToObservable) {</span>
<span class="fc" id="L2669">            return ((FuseToObservable&lt;T&gt;)this).fuseToObservable();</span>
        }
<span class="fc" id="L2671">        return RxJavaPlugins.onAssembly(new CompletableToObservable&lt;T&gt;(this));</span>
    }

    /**
     * Converts this Completable into a Single which when this Completable completes normally,
     * calls the given supplier and emits its returned value through onSuccess.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;583&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.toSingle.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code toSingle} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;T&gt; the value type
     * @param completionValueSupplier the value supplier called when this Completable completes normally
     * @return the new Single instance
     * @throws NullPointerException if completionValueSupplier is null
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;T&gt; Single&lt;T&gt; toSingle(final Callable&lt;? extends T&gt; completionValueSupplier) {
<span class="fc" id="L2692">        ObjectHelper.requireNonNull(completionValueSupplier, &quot;completionValueSupplier is null&quot;);</span>
<span class="fc" id="L2693">        return RxJavaPlugins.onAssembly(new CompletableToSingle&lt;T&gt;(this, completionValueSupplier, null));</span>
    }

    /**
     * Converts this Completable into a Single which when this Completable completes normally,
     * emits the given value through onSuccess.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;583&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.toSingleDefault.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code toSingleDefault} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;T&gt; the value type
     * @param completionValue the value to emit when this Completable completes normally
     * @return the new Single instance
     * @throws NullPointerException if completionValue is null
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;T&gt; Single&lt;T&gt; toSingleDefault(final T completionValue) {
<span class="fc" id="L2714">        ObjectHelper.requireNonNull(completionValue, &quot;completionValue is null&quot;);</span>
<span class="fc" id="L2715">        return RxJavaPlugins.onAssembly(new CompletableToSingle&lt;T&gt;(this, null, completionValue));</span>
    }

    /**
     * Returns a Completable which makes sure when a subscriber disposes the subscription, the
     * dispose is called on the specified scheduler.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;716&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.unsubscribeOn.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code unsubscribeOn} calls dispose() of the upstream on the {@link Scheduler} you specify.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param scheduler the target scheduler where to execute the disposing
     * @return the new Completable instance
     * @throws NullPointerException if scheduler is null
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Completable unsubscribeOn(final Scheduler scheduler) {
<span class="fc" id="L2735">        ObjectHelper.requireNonNull(scheduler, &quot;scheduler is null&quot;);</span>
<span class="fc" id="L2736">        return RxJavaPlugins.onAssembly(new CompletableDisposeOn(this, scheduler));</span>
    }
    // -------------------------------------------------------------------------
    // Fluent test support, super handy and reduces test preparation boilerplate
    // -------------------------------------------------------------------------

    /**
     * Creates a TestObserver and subscribes
     * it to this Completable.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;458&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.test.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code test} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @return the new TestObserver instance
     * @since 2.0
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public final TestObserver&lt;Void&gt; test() {
<span class="fc" id="L2757">        TestObserver&lt;Void&gt; to = new TestObserver&lt;Void&gt;();</span>
<span class="fc" id="L2758">        subscribe(to);</span>
<span class="fc" id="L2759">        return to;</span>
    }

    /**
     * Creates a TestObserver optionally in cancelled state, then subscribes it to this Completable.
     * @param cancelled if true, the TestObserver will be cancelled before subscribing to this
     * Completable.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;499&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.test.b.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code test} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @return the new TestObserver instance
     * @since 2.0
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public final TestObserver&lt;Void&gt; test(boolean cancelled) {
<span class="fc" id="L2778">        TestObserver&lt;Void&gt; to = new TestObserver&lt;Void&gt;();</span>

<span class="fc bfc" id="L2780" title="All 2 branches covered.">        if (cancelled) {</span>
<span class="fc" id="L2781">            to.cancel();</span>
        }
<span class="fc" id="L2783">        subscribe(to);</span>
<span class="fc" id="L2784">        return to;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>