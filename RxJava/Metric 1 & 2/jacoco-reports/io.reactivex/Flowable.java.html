<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Flowable.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">RxJava_2_x$Unnamed.exec</a> &gt; <a href="index.source.html" class="el_package">io.reactivex</a> &gt; <span class="el_source">Flowable.java</span></div><h1>Flowable.java</h1><pre class="source lang-java linenums">/**
 * Copyright (c) 2016-present, RxJava Contributors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is
 * distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
 * the License for the specific language governing permissions and limitations under the License.
 */
package io.reactivex;

import java.util.*;
import java.util.concurrent.*;

import org.reactivestreams.*;

import io.reactivex.annotations.*;
import io.reactivex.disposables.Disposable;
import io.reactivex.exceptions.Exceptions;
import io.reactivex.flowables.*;
import io.reactivex.functions.*;
import io.reactivex.internal.functions.*;
import io.reactivex.internal.fuseable.*;
import io.reactivex.internal.operators.flowable.*;
import io.reactivex.internal.operators.mixed.*;
import io.reactivex.internal.operators.observable.*;
import io.reactivex.internal.schedulers.ImmediateThinScheduler;
import io.reactivex.internal.subscribers.*;
import io.reactivex.internal.util.*;
import io.reactivex.parallel.ParallelFlowable;
import io.reactivex.plugins.RxJavaPlugins;
import io.reactivex.schedulers.*;
import io.reactivex.subscribers.*;

/**
 * The Flowable class that implements the Reactive-Streams Pattern and offers factory methods,
 * intermediate operators and the ability to consume reactive dataflows.
 * &lt;p&gt;
 * Reactive-Streams operates with {@code Publisher}s which {@code Flowable} extends. Many operators
 * therefore accept general {@code Publisher}s directly and allow direct interoperation with other
 * Reactive-Streams implementations.
 * &lt;p&gt;
 * The Flowable hosts the default buffer size of 128 elements for operators, accessible via {@link #bufferSize()},
 * that can be overridden globally via the system parameter {@code rx2.buffer-size}. Most operators, however, have
 * overloads that allow setting their internal buffer size explicitly.
 * &lt;p&gt;
 * The documentation for this class makes use of marble diagrams. The following legend explains these diagrams:
 * &lt;p&gt;
 * &lt;img width=&quot;640&quot; height=&quot;317&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/legend.png&quot; alt=&quot;&quot;&gt;
 * &lt;p&gt;
 * For more information see the &lt;a href=&quot;http://reactivex.io/documentation/Publisher.html&quot;&gt;ReactiveX
 * documentation&lt;/a&gt;.
 *
 * @param &lt;T&gt;
 *            the type of the items emitted by the Flowable
 */
<span class="fc" id="L60">public abstract class Flowable&lt;T&gt; implements Publisher&lt;T&gt; {</span>
    /** The default buffer size. */
    static final int BUFFER_SIZE;
    static {
<span class="fc" id="L64">        BUFFER_SIZE = Math.max(1, Integer.getInteger(&quot;rx2.buffer-size&quot;, 128));</span>
<span class="fc" id="L65">    }</span>

    /**
     * Mirrors the one Publisher in an Iterable of several Publishers that first either emits an item or sends
     * a termination notification.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;385&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/amb.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator itself doesn't interfere with backpressure which is determined by the winning
     *  {@code Publisher}'s backpressure behavior.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code amb} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T&gt; the common element type
     * @param sources
     *            an Iterable of Publishers sources competing to react first. A subscription to each Publisher will
     *            occur in the same order as in this Iterable.
     * @return a Flowable that emits the same sequence as whichever of the source Publishers first
     *         emitted an item or sent a termination notification
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/amb.html&quot;&gt;ReactiveX operators documentation: Amb&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Flowable&lt;T&gt; amb(Iterable&lt;? extends Publisher&lt;? extends T&gt;&gt; sources) {
<span class="fc" id="L93">        ObjectHelper.requireNonNull(sources, &quot;sources is null&quot;);</span>
<span class="fc" id="L94">        return RxJavaPlugins.onAssembly(new FlowableAmb&lt;T&gt;(null, sources));</span>
    }

    /**
     * Mirrors the one Publisher in an array of several Publishers that first either emits an item or sends
     * a termination notification.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;385&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/amb.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator itself doesn't interfere with backpressure which is determined by the winning
     *  {@code Publisher}'s backpressure behavior.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code ambArray} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T&gt; the common element type
     * @param sources
     *            an array of Publisher sources competing to react first. A subscription to each Publisher will
     *            occur in the same order as in this Iterable.
     * @return a Flowable that emits the same sequence as whichever of the source Publishers first
     *         emitted an item or sent a termination notification
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/amb.html&quot;&gt;ReactiveX operators documentation: Amb&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Flowable&lt;T&gt; ambArray(Publisher&lt;? extends T&gt;... sources) {
<span class="fc" id="L123">        ObjectHelper.requireNonNull(sources, &quot;sources is null&quot;);</span>
<span class="fc" id="L124">        int len = sources.length;</span>
<span class="fc bfc" id="L125" title="All 2 branches covered.">        if (len == 0) {</span>
<span class="fc" id="L126">            return empty();</span>
        } else
<span class="fc bfc" id="L128" title="All 2 branches covered.">        if (len == 1) {</span>
<span class="fc" id="L129">            return fromPublisher(sources[0]);</span>
        }
<span class="fc" id="L131">        return RxJavaPlugins.onAssembly(new FlowableAmb&lt;T&gt;(sources, null));</span>
    }

    /**
     * Returns the default internal buffer size used by most async operators.
     * &lt;p&gt;The value can be overridden via system parameter {@code rx2.buffer-size}
     * &lt;em&gt;before&lt;/em&gt; the Flowable class is loaded.
     * @return the default internal buffer size.
     */
    public static int bufferSize() {
<span class="fc" id="L141">        return BUFFER_SIZE;</span>
    }

    /**
     * Combines a collection of source Publishers by emitting an item that aggregates the latest values of each of
     * the source Publishers each time an item is received from any of the source Publishers, where this
     * aggregation is defined by a specified function.
     * &lt;p&gt;
     * Note on method signature: since Java doesn't allow creating a generic array with {@code new T[]}, the
     * implementation of this operator has to create an {@code Object[]} instead. Unfortunately, a
     * {@code Function&lt;Integer[], R&gt;} passed to the method would trigger a {@code ClassCastException}.
     * &lt;p&gt;
     * If any of the sources never produces an item but only terminates (normally or with an error), the
     * resulting sequence terminates immediately (normally or with all the errors accumulated until that point).
     * If that input source is also synchronous, other sources after it will not be subscribed to.
     * &lt;p&gt;
     * If the provided array of source Publishers is empty, the resulting sequence completes immediately without emitting
     * any items and without any calls to the combiner function.
     *
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s
     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal
     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code combineLatest} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T&gt;
     *            the common base type of source values
     * @param &lt;R&gt;
     *            the result type
     * @param sources
     *            the collection of source Publishers
     * @param combiner
     *            the aggregation function used to combine the items emitted by the source Publishers
     * @return a Flowable that emits items that are the result of combining the items emitted by the source
     *         Publishers by means of the given aggregation function
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/combinelatest.html&quot;&gt;ReactiveX operators documentation: CombineLatest&lt;/a&gt;
     */
    @SchedulerSupport(SchedulerSupport.NONE)
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    public static &lt;T, R&gt; Flowable&lt;R&gt; combineLatest(Publisher&lt;? extends T&gt;[] sources, Function&lt;? super Object[], ? extends R&gt; combiner) {
<span class="fc" id="L185">        return combineLatest(sources, combiner, bufferSize());</span>
    }

    /**
     * Combines a collection of source Publishers by emitting an item that aggregates the latest values of each of
     * the source Publishers each time an item is received from any of the source Publishers, where this
     * aggregation is defined by a specified function.
     * &lt;p&gt;
     * Note on method signature: since Java doesn't allow creating a generic array with {@code new T[]}, the
     * implementation of this operator has to create an {@code Object[]} instead. Unfortunately, a
     * {@code Function&lt;Integer[], R&gt;} passed to the method would trigger a {@code ClassCastException}.
     * &lt;p&gt;
     * If any of the sources never produces an item but only terminates (normally or with an error), the
     * resulting sequence terminates immediately (normally or with all the errors accumulated until that point).
     * If that input source is also synchronous, other sources after it will not be subscribed to.
     * &lt;p&gt;
     * If there are no source Publishers provided, the resulting sequence completes immediately without emitting
     * any items and without any calls to the combiner function.
     *
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s
     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal
     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code combineLatest} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T&gt;
     *            the common base type of source values
     * @param &lt;R&gt;
     *            the result type
     * @param sources
     *            the collection of source Publishers
     * @param combiner
     *            the aggregation function used to combine the items emitted by the source Publishers
     * @return a Flowable that emits items that are the result of combining the items emitted by the source
     *         Publishers by means of the given aggregation function
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/combinelatest.html&quot;&gt;ReactiveX operators documentation: CombineLatest&lt;/a&gt;
     */
    @SchedulerSupport(SchedulerSupport.NONE)
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    public static &lt;T, R&gt; Flowable&lt;R&gt; combineLatest(Function&lt;? super Object[], ? extends R&gt; combiner, Publisher&lt;? extends T&gt;... sources) {
<span class="fc" id="L229">        return combineLatest(sources, combiner, bufferSize());</span>
    }

    /**
     * Combines a collection of source Publishers by emitting an item that aggregates the latest values of each of
     * the source Publishers each time an item is received from any of the source Publishers, where this
     * aggregation is defined by a specified function.
     * &lt;p&gt;
     * Note on method signature: since Java doesn't allow creating a generic array with {@code new T[]}, the
     * implementation of this operator has to create an {@code Object[]} instead. Unfortunately, a
     * {@code Function&lt;Integer[], R&gt;} passed to the method would trigger a {@code ClassCastException}.
     * &lt;p&gt;
     * If any of the sources never produces an item but only terminates (normally or with an error), the
     * resulting sequence terminates immediately (normally or with all the errors accumulated until that point).
     * If that input source is also synchronous, other sources after it will not be subscribed to.
     * &lt;p&gt;
     * If the provided array of source Publishers is empty, the resulting sequence completes immediately without emitting
     * any items and without any calls to the combiner function.
     *
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s
     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal
     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code combineLatest} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T&gt;
     *            the common base type of source values
     * @param &lt;R&gt;
     *            the result type
     * @param sources
     *            the collection of source Publishers
     * @param combiner
     *            the aggregation function used to combine the items emitted by the source Publishers
     * @param bufferSize
     *            the internal buffer size and prefetch amount applied to every source Flowable
     * @return a Flowable that emits items that are the result of combining the items emitted by the source
     *         Publishers by means of the given aggregation function
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/combinelatest.html&quot;&gt;ReactiveX operators documentation: CombineLatest&lt;/a&gt;
     */
    @SchedulerSupport(SchedulerSupport.NONE)
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    public static &lt;T, R&gt; Flowable&lt;R&gt; combineLatest(Publisher&lt;? extends T&gt;[] sources, Function&lt;? super Object[], ? extends R&gt; combiner, int bufferSize) {
<span class="fc" id="L276">        ObjectHelper.requireNonNull(sources, &quot;sources is null&quot;);</span>
<span class="fc bfc" id="L277" title="All 2 branches covered.">        if (sources.length == 0) {</span>
<span class="fc" id="L278">            return empty();</span>
        }
<span class="fc" id="L280">        ObjectHelper.requireNonNull(combiner, &quot;combiner is null&quot;);</span>
<span class="fc" id="L281">        ObjectHelper.verifyPositive(bufferSize, &quot;bufferSize&quot;);</span>
<span class="fc" id="L282">        return RxJavaPlugins.onAssembly(new FlowableCombineLatest&lt;T, R&gt;(sources, combiner, bufferSize, false));</span>
    }

    /**
     * Combines a collection of source Publishers by emitting an item that aggregates the latest values of each of
     * the source Publishers each time an item is received from any of the source Publishers, where this
     * aggregation is defined by a specified function.
     * &lt;p&gt;
     * Note on method signature: since Java doesn't allow creating a generic array with {@code new T[]}, the
     * implementation of this operator has to create an {@code Object[]} instead. Unfortunately, a
     * {@code Function&lt;Integer[], R&gt;} passed to the method would trigger a {@code ClassCastException}.
     * &lt;p&gt;
     * If any of the sources never produces an item but only terminates (normally or with an error), the
     * resulting sequence terminates immediately (normally or with all the errors accumulated until that point).
     * If that input source is also synchronous, other sources after it will not be subscribed to.
     * &lt;p&gt;
     * If the provided iterable of source Publishers is empty, the resulting sequence completes immediately without emitting
     * any items and without any calls to the combiner function.
     *
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s
     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal
     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code combineLatest} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T&gt;
     *            the common base type of source values
     * @param &lt;R&gt;
     *            the result type
     * @param sources
     *            the collection of source Publishers
     * @param combiner
     *            the aggregation function used to combine the items emitted by the source Publishers
     * @return a Flowable that emits items that are the result of combining the items emitted by the source
     *         Publishers by means of the given aggregation function
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/combinelatest.html&quot;&gt;ReactiveX operators documentation: CombineLatest&lt;/a&gt;
     */
    @SchedulerSupport(SchedulerSupport.NONE)
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    public static &lt;T, R&gt; Flowable&lt;R&gt; combineLatest(Iterable&lt;? extends Publisher&lt;? extends T&gt;&gt; sources,
            Function&lt;? super Object[], ? extends R&gt; combiner) {
<span class="fc" id="L327">        return combineLatest(sources, combiner, bufferSize());</span>
    }

    /**
     * Combines a collection of source Publishers by emitting an item that aggregates the latest values of each of
     * the source Publishers each time an item is received from any of the source Publishers, where this
     * aggregation is defined by a specified function.
     * &lt;p&gt;
     * Note on method signature: since Java doesn't allow creating a generic array with {@code new T[]}, the
     * implementation of this operator has to create an {@code Object[]} instead. Unfortunately, a
     * {@code Function&lt;Integer[], R&gt;} passed to the method would trigger a {@code ClassCastException}.
     * &lt;p&gt;
     * If any of the sources never produces an item but only terminates (normally or with an error), the
     * resulting sequence terminates immediately (normally or with all the errors accumulated until that point).
     * If that input source is also synchronous, other sources after it will not be subscribed to.
     * &lt;p&gt;
     * If the provided iterable of source Publishers is empty, the resulting sequence completes immediately without emitting any items and
     * without any calls to the combiner function.
     *
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s
     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal
     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code combineLatest} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T&gt;
     *            the common base type of source values
     * @param &lt;R&gt;
     *            the result type
     * @param sources
     *            the collection of source Publishers
     * @param combiner
     *            the aggregation function used to combine the items emitted by the source Publishers
     * @param bufferSize
     *            the internal buffer size and prefetch amount applied to every source Flowable
     * @return a Flowable that emits items that are the result of combining the items emitted by the source
     *         Publishers by means of the given aggregation function
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/combinelatest.html&quot;&gt;ReactiveX operators documentation: CombineLatest&lt;/a&gt;
     */
    @SchedulerSupport(SchedulerSupport.NONE)
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    public static &lt;T, R&gt; Flowable&lt;R&gt; combineLatest(Iterable&lt;? extends Publisher&lt;? extends T&gt;&gt; sources,
            Function&lt;? super Object[], ? extends R&gt; combiner, int bufferSize) {
<span class="fc" id="L375">        ObjectHelper.requireNonNull(sources, &quot;sources is null&quot;);</span>
<span class="fc" id="L376">        ObjectHelper.requireNonNull(combiner, &quot;combiner is null&quot;);</span>
<span class="fc" id="L377">        ObjectHelper.verifyPositive(bufferSize, &quot;bufferSize&quot;);</span>
<span class="fc" id="L378">        return RxJavaPlugins.onAssembly(new FlowableCombineLatest&lt;T, R&gt;(sources, combiner, bufferSize, false));</span>
    }

    /**
     * Combines a collection of source Publishers by emitting an item that aggregates the latest values of each of
     * the source Publishers each time an item is received from any of the source Publishers, where this
     * aggregation is defined by a specified function.
     * &lt;p&gt;
     * Note on method signature: since Java doesn't allow creating a generic array with {@code new T[]}, the
     * implementation of this operator has to create an {@code Object[]} instead. Unfortunately, a
     * {@code Function&lt;Integer[], R&gt;} passed to the method would trigger a {@code ClassCastException}.
     * &lt;p&gt;
     * If any of the sources never produces an item but only terminates (normally or with an error), the
     * resulting sequence terminates immediately (normally or with all the errors accumulated until that point).
     * If that input source is also synchronous, other sources after it will not be subscribed to.
     * &lt;p&gt;
     * If the provided array of source Publishers is empty, the resulting sequence completes immediately without emitting
     * any items and without any calls to the combiner function.
     *
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s
     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal
     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code combineLatestDelayError} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T&gt;
     *            the common base type of source values
     * @param &lt;R&gt;
     *            the result type
     * @param sources
     *            the collection of source Publishers
     * @param combiner
     *            the aggregation function used to combine the items emitted by the source Publishers
     * @return a Flowable that emits items that are the result of combining the items emitted by the source
     *         Publishers by means of the given aggregation function
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/combinelatest.html&quot;&gt;ReactiveX operators documentation: CombineLatest&lt;/a&gt;
     */
    @SchedulerSupport(SchedulerSupport.NONE)
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    public static &lt;T, R&gt; Flowable&lt;R&gt; combineLatestDelayError(Publisher&lt;? extends T&gt;[] sources,
            Function&lt;? super Object[], ? extends R&gt; combiner) {
<span class="fc" id="L423">        return combineLatestDelayError(sources, combiner, bufferSize());</span>
    }

    /**
     * Combines a collection of source Publishers by emitting an item that aggregates the latest values of each of
     * the source Publishers each time an item is received from any of the source Publishers, where this
     * aggregation is defined by a specified function and delays any error from the sources until
     * all source Publishers terminate.
     * &lt;p&gt;
     * Note on method signature: since Java doesn't allow creating a generic array with {@code new T[]}, the
     * implementation of this operator has to create an {@code Object[]} instead. Unfortunately, a
     * {@code Function&lt;Integer[], R&gt;} passed to the method would trigger a {@code ClassCastException}.
     * &lt;p&gt;
     * If any of the sources never produces an item but only terminates (normally or with an error), the
     * resulting sequence terminates immediately (normally or with all the errors accumulated until that point).
     * If that input source is also synchronous, other sources after it will not be subscribed to.
     * &lt;p&gt;
     * If there are no source Publishers provided, the resulting sequence completes immediately without emitting
     * any items and without any calls to the combiner function.
     *
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s
     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal
     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code combineLatestDelayError} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T&gt;
     *            the common base type of source values
     * @param &lt;R&gt;
     *            the result type
     * @param sources
     *            the collection of source Publishers
     * @param combiner
     *            the aggregation function used to combine the items emitted by the source Publishers
     * @return a Flowable that emits items that are the result of combining the items emitted by the source
     *         Publishers by means of the given aggregation function
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/combinelatest.html&quot;&gt;ReactiveX operators documentation: CombineLatest&lt;/a&gt;
     */
    @SchedulerSupport(SchedulerSupport.NONE)
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    public static &lt;T, R&gt; Flowable&lt;R&gt; combineLatestDelayError(Function&lt;? super Object[], ? extends R&gt; combiner,
            Publisher&lt;? extends T&gt;... sources) {
<span class="fc" id="L469">        return combineLatestDelayError(sources, combiner, bufferSize());</span>
    }

    /**
     * Combines a collection of source Publishers by emitting an item that aggregates the latest values of each of
     * the source Publishers each time an item is received from any of the source Publisher, where this
     * aggregation is defined by a specified function and delays any error from the sources until
     * all source Publishers terminate.
     * &lt;p&gt;
     * Note on method signature: since Java doesn't allow creating a generic array with {@code new T[]}, the
     * implementation of this operator has to create an {@code Object[]} instead. Unfortunately, a
     * {@code Function&lt;Integer[], R&gt;} passed to the method would trigger a {@code ClassCastException}.
     * &lt;p&gt;
     * If any of the sources never produces an item but only terminates (normally or with an error), the
     * resulting sequence terminates immediately (normally or with all the errors accumulated until that point).
     * If that input source is also synchronous, other sources after it will not be subscribed to.
     * &lt;p&gt;
     * If there are no source Publishers provided, the resulting sequence completes immediately without emitting
     * any items and without any calls to the combiner function.
     *
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s
     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal
     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code combineLatestDelayError} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T&gt;
     *            the common base type of source values
     * @param &lt;R&gt;
     *            the result type
     * @param sources
     *            the collection of source Publishers
     * @param combiner
     *            the aggregation function used to combine the items emitted by the source Publishers
     * @param bufferSize
     *            the internal buffer size and prefetch amount applied to every source Publisher
     * @return a Flowable that emits items that are the result of combining the items emitted by the source
     *         Publishers by means of the given aggregation function
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/combinelatest.html&quot;&gt;ReactiveX operators documentation: CombineLatest&lt;/a&gt;
     */
    @SchedulerSupport(SchedulerSupport.NONE)
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    public static &lt;T, R&gt; Flowable&lt;R&gt; combineLatestDelayError(Function&lt;? super Object[], ? extends R&gt; combiner,
            int bufferSize, Publisher&lt;? extends T&gt;... sources) {
<span class="fc" id="L517">        return combineLatestDelayError(sources, combiner, bufferSize);</span>
    }

    /**
     * Combines a collection of source Publishers by emitting an item that aggregates the latest values of each of
     * the source Publishers each time an item is received from any of the source Publishers, where this
     * aggregation is defined by a specified function and delays any error from the sources until
     * all source Publishers terminate.
     * &lt;p&gt;
     * Note on method signature: since Java doesn't allow creating a generic array with {@code new T[]}, the
     * implementation of this operator has to create an {@code Object[]} instead. Unfortunately, a
     * {@code Function&lt;Integer[], R&gt;} passed to the method would trigger a {@code ClassCastException}.
     * &lt;p&gt;
     * If any of the sources never produces an item but only terminates (normally or with an error), the
     * resulting sequence terminates immediately (normally or with all the errors accumulated until that point).
     * If that input source is also synchronous, other sources after it will not be subscribed to.
     * &lt;p&gt;
     * If the provided array of source Publishers is empty, the resulting sequence completes immediately without emitting
     * any items and without any calls to the combiner function.
     *
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s
     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal
     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code combineLatestDelayError} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T&gt;
     *            the common base type of source values
     * @param &lt;R&gt;
     *            the result type
     * @param sources
     *            the collection of source Publishers
     * @param combiner
     *            the aggregation function used to combine the items emitted by the source Publishers
     * @param bufferSize
     *            the internal buffer size and prefetch amount applied to every source Flowable
     * @return a Flowable that emits items that are the result of combining the items emitted by the source
     *         Publishers by means of the given aggregation function
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/combinelatest.html&quot;&gt;ReactiveX operators documentation: CombineLatest&lt;/a&gt;
     */
    @SchedulerSupport(SchedulerSupport.NONE)
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    public static &lt;T, R&gt; Flowable&lt;R&gt; combineLatestDelayError(Publisher&lt;? extends T&gt;[] sources,
            Function&lt;? super Object[], ? extends R&gt; combiner, int bufferSize) {
<span class="fc" id="L566">        ObjectHelper.requireNonNull(sources, &quot;sources is null&quot;);</span>
<span class="fc" id="L567">        ObjectHelper.requireNonNull(combiner, &quot;combiner is null&quot;);</span>
<span class="fc" id="L568">        ObjectHelper.verifyPositive(bufferSize, &quot;bufferSize&quot;);</span>
<span class="fc bfc" id="L569" title="All 2 branches covered.">        if (sources.length == 0) {</span>
<span class="fc" id="L570">            return empty();</span>
        }
<span class="fc" id="L572">        return RxJavaPlugins.onAssembly(new FlowableCombineLatest&lt;T, R&gt;(sources, combiner, bufferSize, true));</span>
    }

    /**
     * Combines a collection of source Publishers by emitting an item that aggregates the latest values of each of
     * the source Publishers each time an item is received from any of the source Publishers, where this
     * aggregation is defined by a specified function and delays any error from the sources until
     * all source Publishers terminate.
     * &lt;p&gt;
     * Note on method signature: since Java doesn't allow creating a generic array with {@code new T[]}, the
     * implementation of this operator has to create an {@code Object[]} instead. Unfortunately, a
     * {@code Function&lt;Integer[], R&gt;} passed to the method would trigger a {@code ClassCastException}.
     * &lt;p&gt;
     * If any of the sources never produces an item but only terminates (normally or with an error), the
     * resulting sequence terminates immediately (normally or with all the errors accumulated until that point).
     * If that input source is also synchronous, other sources after it will not be subscribed to.
     * &lt;p&gt;
     * If the provided iterable of source Publishers is empty, the resulting sequence completes immediately without emitting
     * any items and without any calls to the combiner function.
     *
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s
     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal
     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code combineLatestDelayError} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T&gt;
     *            the common base type of source values
     * @param &lt;R&gt;
     *            the result type
     * @param sources
     *            the collection of source Publishers
     * @param combiner
     *            the aggregation function used to combine the items emitted by the source Publishers
     * @return a Flowable that emits items that are the result of combining the items emitted by the source
     *         Publishers by means of the given aggregation function
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/combinelatest.html&quot;&gt;ReactiveX operators documentation: CombineLatest&lt;/a&gt;
     */
    @SchedulerSupport(SchedulerSupport.NONE)
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    public static &lt;T, R&gt; Flowable&lt;R&gt; combineLatestDelayError(Iterable&lt;? extends Publisher&lt;? extends T&gt;&gt; sources,
            Function&lt;? super Object[], ? extends R&gt; combiner) {
<span class="fc" id="L618">        return combineLatestDelayError(sources, combiner, bufferSize());</span>
    }

    /**
     * Combines a collection of source Publishers by emitting an item that aggregates the latest values of each of
     * the source Publishers each time an item is received from any of the source Publishers, where this
     * aggregation is defined by a specified function and delays any error from the sources until
     * all source Publishers terminate.
     * &lt;p&gt;
     * Note on method signature: since Java doesn't allow creating a generic array with {@code new T[]}, the
     * implementation of this operator has to create an {@code Object[]} instead. Unfortunately, a
     * {@code Function&lt;Integer[], R&gt;} passed to the method would trigger a {@code ClassCastException}.
     * &lt;p&gt;
     * If any of the sources never produces an item but only terminates (normally or with an error), the
     * resulting sequence terminates immediately (normally or with all the errors accumulated until that point).
     * If that input source is also synchronous, other sources after it will not be subscribed to.
     * &lt;p&gt;
     * If the provided iterable of source Publishers is empty, the resulting sequence completes immediately without emitting
     * any items and without any calls to the combiner function.
     *
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s
     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal
     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code combineLatestDelayError} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T&gt;
     *            the common base type of source values
     * @param &lt;R&gt;
     *            the result type
     * @param sources
     *            the collection of source Publishers
     * @param combiner
     *            the aggregation function used to combine the items emitted by the source Publishers
     * @param bufferSize
     *            the internal buffer size and prefetch amount applied to every source Flowable
     * @return a Flowable that emits items that are the result of combining the items emitted by the source
     *         Publishers by means of the given aggregation function
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/combinelatest.html&quot;&gt;ReactiveX operators documentation: CombineLatest&lt;/a&gt;
     */
    @SchedulerSupport(SchedulerSupport.NONE)
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    public static &lt;T, R&gt; Flowable&lt;R&gt; combineLatestDelayError(Iterable&lt;? extends Publisher&lt;? extends T&gt;&gt; sources,
            Function&lt;? super Object[], ? extends R&gt; combiner, int bufferSize) {
<span class="fc" id="L666">        ObjectHelper.requireNonNull(sources, &quot;sources is null&quot;);</span>
<span class="fc" id="L667">        ObjectHelper.requireNonNull(combiner, &quot;combiner is null&quot;);</span>
<span class="fc" id="L668">        ObjectHelper.verifyPositive(bufferSize, &quot;bufferSize&quot;);</span>
<span class="fc" id="L669">        return RxJavaPlugins.onAssembly(new FlowableCombineLatest&lt;T, R&gt;(sources, combiner, bufferSize, true));</span>
    }

    /**
     * Combines two source Publishers by emitting an item that aggregates the latest values of each of the
     * source Publishers each time an item is received from either of the source Publishers, where this
     * aggregation is defined by a specified function.
     * &lt;p&gt;
     * If any of the sources never produces an item but only terminates (normally or with an error), the
     * resulting sequence terminates immediately (normally or with all the errors accumulated until that point).
     * If that input source is also synchronous, other sources after it will not be subscribed to.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/combineLatest.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s
     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal
     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code combineLatest} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T1&gt; the element type of the first source
     * @param &lt;T2&gt; the element type of the second source
     * @param &lt;R&gt; the combined output type
     * @param source1
     *            the first source Publisher
     * @param source2
     *            the second source Publisher
     * @param combiner
     *            the aggregation function used to combine the items emitted by the source Publishers
     * @return a Flowable that emits items that are the result of combining the items emitted by the source
     *         Publishers by means of the given aggregation function
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/combinelatest.html&quot;&gt;ReactiveX operators documentation: CombineLatest&lt;/a&gt;
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T1, T2, R&gt; Flowable&lt;R&gt; combineLatest(
            Publisher&lt;? extends T1&gt; source1, Publisher&lt;? extends T2&gt; source2,
            BiFunction&lt;? super T1, ? super T2, ? extends R&gt; combiner) {
<span class="fc" id="L711">        ObjectHelper.requireNonNull(source1, &quot;source1 is null&quot;);</span>
<span class="fc" id="L712">        ObjectHelper.requireNonNull(source2, &quot;source2 is null&quot;);</span>
<span class="fc" id="L713">        Function&lt;Object[], R&gt; f = Functions.toFunction(combiner);</span>
<span class="fc" id="L714">        return combineLatest(f, source1, source2);</span>
    }

    /**
     * Combines three source Publishers by emitting an item that aggregates the latest values of each of the
     * source Publishers each time an item is received from any of the source Publishers, where this
     * aggregation is defined by a specified function.
     * &lt;p&gt;
     * If any of the sources never produces an item but only terminates (normally or with an error), the
     * resulting sequence terminates immediately (normally or with all the errors accumulated until that point).
     * If that input source is also synchronous, other sources after it will not be subscribed to.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/combineLatest.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s
     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal
     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code combineLatest} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T1&gt; the element type of the first source
     * @param &lt;T2&gt; the element type of the second source
     * @param &lt;T3&gt; the element type of the third source
     * @param &lt;R&gt; the combined output type
     * @param source1
     *            the first source Publisher
     * @param source2
     *            the second source Publisher
     * @param source3
     *            the third source Publisher
     * @param combiner
     *            the aggregation function used to combine the items emitted by the source Publishers
     * @return a Flowable that emits items that are the result of combining the items emitted by the source
     *         Publishers by means of the given aggregation function
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/combinelatest.html&quot;&gt;ReactiveX operators documentation: CombineLatest&lt;/a&gt;
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T1, T2, T3, R&gt; Flowable&lt;R&gt; combineLatest(
            Publisher&lt;? extends T1&gt; source1, Publisher&lt;? extends T2&gt; source2,
            Publisher&lt;? extends T3&gt; source3,
            Function3&lt;? super T1, ? super T2, ? super T3, ? extends R&gt; combiner) {
<span class="fc" id="L761">        ObjectHelper.requireNonNull(source1, &quot;source1 is null&quot;);</span>
<span class="fc" id="L762">        ObjectHelper.requireNonNull(source2, &quot;source2 is null&quot;);</span>
<span class="fc" id="L763">        ObjectHelper.requireNonNull(source3, &quot;source3 is null&quot;);</span>
<span class="fc" id="L764">        return combineLatest(Functions.toFunction(combiner), source1, source2, source3);</span>
    }

    /**
     * Combines four source Publishers by emitting an item that aggregates the latest values of each of the
     * source Publishers each time an item is received from any of the source Publishers, where this
     * aggregation is defined by a specified function.
     * &lt;p&gt;
     * If any of the sources never produces an item but only terminates (normally or with an error), the
     * resulting sequence terminates immediately (normally or with all the errors accumulated until that point).
     * If that input source is also synchronous, other sources after it will not be subscribed to.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/combineLatest.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s
     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal
     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code combineLatest} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T1&gt; the element type of the first source
     * @param &lt;T2&gt; the element type of the second source
     * @param &lt;T3&gt; the element type of the third source
     * @param &lt;T4&gt; the element type of the fourth source
     * @param &lt;R&gt; the combined output type
     * @param source1
     *            the first source Publisher
     * @param source2
     *            the second source Publisher
     * @param source3
     *            the third source Publisher
     * @param source4
     *            the fourth source Publisher
     * @param combiner
     *            the aggregation function used to combine the items emitted by the source Publishers
     * @return a Flowable that emits items that are the result of combining the items emitted by the source
     *         Publishers by means of the given aggregation function
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/combinelatest.html&quot;&gt;ReactiveX operators documentation: CombineLatest&lt;/a&gt;
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T1, T2, T3, T4, R&gt; Flowable&lt;R&gt; combineLatest(
            Publisher&lt;? extends T1&gt; source1, Publisher&lt;? extends T2&gt; source2,
            Publisher&lt;? extends T3&gt; source3, Publisher&lt;? extends T4&gt; source4,
            Function4&lt;? super T1, ? super T2, ? super T3, ? super T4, ? extends R&gt; combiner) {
<span class="fc" id="L814">        ObjectHelper.requireNonNull(source1, &quot;source1 is null&quot;);</span>
<span class="fc" id="L815">        ObjectHelper.requireNonNull(source2, &quot;source2 is null&quot;);</span>
<span class="fc" id="L816">        ObjectHelper.requireNonNull(source3, &quot;source3 is null&quot;);</span>
<span class="fc" id="L817">        ObjectHelper.requireNonNull(source4, &quot;source4 is null&quot;);</span>
<span class="fc" id="L818">        return combineLatest(Functions.toFunction(combiner), source1, source2, source3, source4);</span>
    }

    /**
     * Combines five source Publishers by emitting an item that aggregates the latest values of each of the
     * source Publishers each time an item is received from any of the source Publishers, where this
     * aggregation is defined by a specified function.
     * &lt;p&gt;
     * If any of the sources never produces an item but only terminates (normally or with an error), the
     * resulting sequence terminates immediately (normally or with all the errors accumulated until that point).
     * If that input source is also synchronous, other sources after it will not be subscribed to.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/combineLatest.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s
     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal
     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code combineLatest} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T1&gt; the element type of the first source
     * @param &lt;T2&gt; the element type of the second source
     * @param &lt;T3&gt; the element type of the third source
     * @param &lt;T4&gt; the element type of the fourth source
     * @param &lt;T5&gt; the element type of the fifth source
     * @param &lt;R&gt; the combined output type
     * @param source1
     *            the first source Publisher
     * @param source2
     *            the second source Publisher
     * @param source3
     *            the third source Publisher
     * @param source4
     *            the fourth source Publisher
     * @param source5
     *            the fifth source Publisher
     * @param combiner
     *            the aggregation function used to combine the items emitted by the source Publishers
     * @return a Flowable that emits items that are the result of combining the items emitted by the source
     *         Publishers by means of the given aggregation function
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/combinelatest.html&quot;&gt;ReactiveX operators documentation: CombineLatest&lt;/a&gt;
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T1, T2, T3, T4, T5, R&gt; Flowable&lt;R&gt; combineLatest(
            Publisher&lt;? extends T1&gt; source1, Publisher&lt;? extends T2&gt; source2,
            Publisher&lt;? extends T3&gt; source3, Publisher&lt;? extends T4&gt; source4,
            Publisher&lt;? extends T5&gt; source5,
            Function5&lt;? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? extends R&gt; combiner) {
<span class="fc" id="L872">        ObjectHelper.requireNonNull(source1, &quot;source1 is null&quot;);</span>
<span class="fc" id="L873">        ObjectHelper.requireNonNull(source2, &quot;source2 is null&quot;);</span>
<span class="fc" id="L874">        ObjectHelper.requireNonNull(source3, &quot;source3 is null&quot;);</span>
<span class="fc" id="L875">        ObjectHelper.requireNonNull(source4, &quot;source4 is null&quot;);</span>
<span class="fc" id="L876">        ObjectHelper.requireNonNull(source5, &quot;source5 is null&quot;);</span>
<span class="fc" id="L877">        return combineLatest(Functions.toFunction(combiner), source1, source2, source3, source4, source5);</span>
    }

    /**
     * Combines six source Publishers by emitting an item that aggregates the latest values of each of the
     * source Publishers each time an item is received from any of the source Publishers, where this
     * aggregation is defined by a specified function.
     * &lt;p&gt;
     * If any of the sources never produces an item but only terminates (normally or with an error), the
     * resulting sequence terminates immediately (normally or with all the errors accumulated until that point).
     * If that input source is also synchronous, other sources after it will not be subscribed to.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/combineLatest.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s
     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal
     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code combineLatest} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T1&gt; the element type of the first source
     * @param &lt;T2&gt; the element type of the second source
     * @param &lt;T3&gt; the element type of the third source
     * @param &lt;T4&gt; the element type of the fourth source
     * @param &lt;T5&gt; the element type of the fifth source
     * @param &lt;T6&gt; the element type of the sixth source
     * @param &lt;R&gt; the combined output type
     * @param source1
     *            the first source Publisher
     * @param source2
     *            the second source Publisher
     * @param source3
     *            the third source Publisher
     * @param source4
     *            the fourth source Publisher
     * @param source5
     *            the fifth source Publisher
     * @param source6
     *            the sixth source Publisher
     * @param combiner
     *            the aggregation function used to combine the items emitted by the source Publishers
     * @return a Flowable that emits items that are the result of combining the items emitted by the source
     *         Publishers by means of the given aggregation function
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/combinelatest.html&quot;&gt;ReactiveX operators documentation: CombineLatest&lt;/a&gt;
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T1, T2, T3, T4, T5, T6, R&gt; Flowable&lt;R&gt; combineLatest(
            Publisher&lt;? extends T1&gt; source1, Publisher&lt;? extends T2&gt; source2,
            Publisher&lt;? extends T3&gt; source3, Publisher&lt;? extends T4&gt; source4,
            Publisher&lt;? extends T5&gt; source5, Publisher&lt;? extends T6&gt; source6,
            Function6&lt;? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? extends R&gt; combiner) {
<span class="fc" id="L934">        ObjectHelper.requireNonNull(source1, &quot;source1 is null&quot;);</span>
<span class="fc" id="L935">        ObjectHelper.requireNonNull(source2, &quot;source2 is null&quot;);</span>
<span class="fc" id="L936">        ObjectHelper.requireNonNull(source3, &quot;source3 is null&quot;);</span>
<span class="fc" id="L937">        ObjectHelper.requireNonNull(source4, &quot;source4 is null&quot;);</span>
<span class="fc" id="L938">        ObjectHelper.requireNonNull(source5, &quot;source5 is null&quot;);</span>
<span class="fc" id="L939">        ObjectHelper.requireNonNull(source6, &quot;source6 is null&quot;);</span>
<span class="fc" id="L940">        return combineLatest(Functions.toFunction(combiner), source1, source2, source3, source4, source5, source6);</span>
    }

    /**
     * Combines seven source Publishers by emitting an item that aggregates the latest values of each of the
     * source Publishers each time an item is received from any of the source Publishers, where this
     * aggregation is defined by a specified function.
     * &lt;p&gt;
     * If any of the sources never produces an item but only terminates (normally or with an error), the
     * resulting sequence terminates immediately (normally or with all the errors accumulated until that point).
     * If that input source is also synchronous, other sources after it will not be subscribed to.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/combineLatest.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s
     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal
     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code combineLatest} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T1&gt; the element type of the first source
     * @param &lt;T2&gt; the element type of the second source
     * @param &lt;T3&gt; the element type of the third source
     * @param &lt;T4&gt; the element type of the fourth source
     * @param &lt;T5&gt; the element type of the fifth source
     * @param &lt;T6&gt; the element type of the sixth source
     * @param &lt;T7&gt; the element type of the seventh source
     * @param &lt;R&gt; the combined output type
     * @param source1
     *            the first source Publisher
     * @param source2
     *            the second source Publisher
     * @param source3
     *            the third source Publisher
     * @param source4
     *            the fourth source Publisher
     * @param source5
     *            the fifth source Publisher
     * @param source6
     *            the sixth source Publisher
     * @param source7
     *            the seventh source Publisher
     * @param combiner
     *            the aggregation function used to combine the items emitted by the source Publishers
     * @return a Flowable that emits items that are the result of combining the items emitted by the source
     *         Publishers by means of the given aggregation function
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/combinelatest.html&quot;&gt;ReactiveX operators documentation: CombineLatest&lt;/a&gt;
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T1, T2, T3, T4, T5, T6, T7, R&gt; Flowable&lt;R&gt; combineLatest(
            Publisher&lt;? extends T1&gt; source1, Publisher&lt;? extends T2&gt; source2,
            Publisher&lt;? extends T3&gt; source3, Publisher&lt;? extends T4&gt; source4,
            Publisher&lt;? extends T5&gt; source5, Publisher&lt;? extends T6&gt; source6,
            Publisher&lt;? extends T7&gt; source7,
            Function7&lt;? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? extends R&gt; combiner) {
<span class="fc" id="L1001">        ObjectHelper.requireNonNull(source1, &quot;source1 is null&quot;);</span>
<span class="fc" id="L1002">        ObjectHelper.requireNonNull(source2, &quot;source2 is null&quot;);</span>
<span class="fc" id="L1003">        ObjectHelper.requireNonNull(source3, &quot;source3 is null&quot;);</span>
<span class="fc" id="L1004">        ObjectHelper.requireNonNull(source4, &quot;source4 is null&quot;);</span>
<span class="fc" id="L1005">        ObjectHelper.requireNonNull(source5, &quot;source5 is null&quot;);</span>
<span class="fc" id="L1006">        ObjectHelper.requireNonNull(source6, &quot;source6 is null&quot;);</span>
<span class="fc" id="L1007">        ObjectHelper.requireNonNull(source7, &quot;source7 is null&quot;);</span>
<span class="fc" id="L1008">        return combineLatest(Functions.toFunction(combiner), source1, source2, source3, source4, source5, source6, source7);</span>
    }

    /**
     * Combines eight source Publishers by emitting an item that aggregates the latest values of each of the
     * source Publishers each time an item is received from any of the source Publishers, where this
     * aggregation is defined by a specified function.
     * &lt;p&gt;
     * If any of the sources never produces an item but only terminates (normally or with an error), the
     * resulting sequence terminates immediately (normally or with all the errors accumulated until that point).
     * If that input source is also synchronous, other sources after it will not be subscribed to.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/combineLatest.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s
     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal
     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code combineLatest} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T1&gt; the element type of the first source
     * @param &lt;T2&gt; the element type of the second source
     * @param &lt;T3&gt; the element type of the third source
     * @param &lt;T4&gt; the element type of the fourth source
     * @param &lt;T5&gt; the element type of the fifth source
     * @param &lt;T6&gt; the element type of the sixth source
     * @param &lt;T7&gt; the element type of the seventh source
     * @param &lt;T8&gt; the element type of the eighth source
     * @param &lt;R&gt; the combined output type
     * @param source1
     *            the first source Publisher
     * @param source2
     *            the second source Publisher
     * @param source3
     *            the third source Publisher
     * @param source4
     *            the fourth source Publisher
     * @param source5
     *            the fifth source Publisher
     * @param source6
     *            the sixth source Publisher
     * @param source7
     *            the seventh source Publisher
     * @param source8
     *            the eighth source Publisher
     * @param combiner
     *            the aggregation function used to combine the items emitted by the source Publishers
     * @return a Flowable that emits items that are the result of combining the items emitted by the source
     *         Publishers by means of the given aggregation function
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/combinelatest.html&quot;&gt;ReactiveX operators documentation: CombineLatest&lt;/a&gt;
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T1, T2, T3, T4, T5, T6, T7, T8, R&gt; Flowable&lt;R&gt; combineLatest(
            Publisher&lt;? extends T1&gt; source1, Publisher&lt;? extends T2&gt; source2,
            Publisher&lt;? extends T3&gt; source3, Publisher&lt;? extends T4&gt; source4,
            Publisher&lt;? extends T5&gt; source5, Publisher&lt;? extends T6&gt; source6,
            Publisher&lt;? extends T7&gt; source7, Publisher&lt;? extends T8&gt; source8,
            Function8&lt;? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? super T8, ? extends R&gt; combiner) {
<span class="fc" id="L1072">        ObjectHelper.requireNonNull(source1, &quot;source1 is null&quot;);</span>
<span class="fc" id="L1073">        ObjectHelper.requireNonNull(source2, &quot;source2 is null&quot;);</span>
<span class="fc" id="L1074">        ObjectHelper.requireNonNull(source3, &quot;source3 is null&quot;);</span>
<span class="fc" id="L1075">        ObjectHelper.requireNonNull(source4, &quot;source4 is null&quot;);</span>
<span class="fc" id="L1076">        ObjectHelper.requireNonNull(source5, &quot;source5 is null&quot;);</span>
<span class="fc" id="L1077">        ObjectHelper.requireNonNull(source6, &quot;source6 is null&quot;);</span>
<span class="fc" id="L1078">        ObjectHelper.requireNonNull(source7, &quot;source7 is null&quot;);</span>
<span class="fc" id="L1079">        ObjectHelper.requireNonNull(source8, &quot;source8 is null&quot;);</span>
<span class="fc" id="L1080">        return combineLatest(Functions.toFunction(combiner), source1, source2, source3, source4, source5, source6, source7, source8);</span>
    }

    /**
     * Combines nine source Publishers by emitting an item that aggregates the latest values of each of the
     * source Publishers each time an item is received from any of the source Publishers, where this
     * aggregation is defined by a specified function.
     * &lt;p&gt;
     * If any of the sources never produces an item but only terminates (normally or with an error), the
     * resulting sequence terminates immediately (normally or with all the errors accumulated until that point).
     * If that input source is also synchronous, other sources after it will not be subscribed to.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/combineLatest.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}s
     *   are requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal
     *   {@code MissingBackpressureException}) and may lead to {@code OutOfMemoryError} due to internal buffer bloat.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code combineLatest} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T1&gt; the element type of the first source
     * @param &lt;T2&gt; the element type of the second source
     * @param &lt;T3&gt; the element type of the third source
     * @param &lt;T4&gt; the element type of the fourth source
     * @param &lt;T5&gt; the element type of the fifth source
     * @param &lt;T6&gt; the element type of the sixth source
     * @param &lt;T7&gt; the element type of the seventh source
     * @param &lt;T8&gt; the element type of the eighth source
     * @param &lt;T9&gt; the element type of the ninth source
     * @param &lt;R&gt; the combined output type
     * @param source1
     *            the first source Publisher
     * @param source2
     *            the second source Publisher
     * @param source3
     *            the third source Publisher
     * @param source4
     *            the fourth source Publisher
     * @param source5
     *            the fifth source Publisher
     * @param source6
     *            the sixth source Publisher
     * @param source7
     *            the seventh source Publisher
     * @param source8
     *            the eighth source Publisher
     * @param source9
     *            the ninth source Publisher
     * @param combiner
     *            the aggregation function used to combine the items emitted by the source Publishers
     * @return a Flowable that emits items that are the result of combining the items emitted by the source
     *         Publishers by means of the given aggregation function
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/combinelatest.html&quot;&gt;ReactiveX operators documentation: CombineLatest&lt;/a&gt;
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T1, T2, T3, T4, T5, T6, T7, T8, T9, R&gt; Flowable&lt;R&gt; combineLatest(
            Publisher&lt;? extends T1&gt; source1, Publisher&lt;? extends T2&gt; source2,
            Publisher&lt;? extends T3&gt; source3, Publisher&lt;? extends T4&gt; source4,
            Publisher&lt;? extends T5&gt; source5, Publisher&lt;? extends T6&gt; source6,
            Publisher&lt;? extends T7&gt; source7, Publisher&lt;? extends T8&gt; source8,
            Publisher&lt;? extends T9&gt; source9,
            Function9&lt;? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? super T8, ? super T9, ? extends R&gt; combiner) {
<span class="fc" id="L1148">        ObjectHelper.requireNonNull(source1, &quot;source1 is null&quot;);</span>
<span class="fc" id="L1149">        ObjectHelper.requireNonNull(source2, &quot;source2 is null&quot;);</span>
<span class="fc" id="L1150">        ObjectHelper.requireNonNull(source3, &quot;source3 is null&quot;);</span>
<span class="fc" id="L1151">        ObjectHelper.requireNonNull(source4, &quot;source4 is null&quot;);</span>
<span class="fc" id="L1152">        ObjectHelper.requireNonNull(source5, &quot;source5 is null&quot;);</span>
<span class="fc" id="L1153">        ObjectHelper.requireNonNull(source6, &quot;source6 is null&quot;);</span>
<span class="fc" id="L1154">        ObjectHelper.requireNonNull(source7, &quot;source7 is null&quot;);</span>
<span class="fc" id="L1155">        ObjectHelper.requireNonNull(source8, &quot;source8 is null&quot;);</span>
<span class="fc" id="L1156">        ObjectHelper.requireNonNull(source9, &quot;source9 is null&quot;);</span>
<span class="fc" id="L1157">        return combineLatest(Functions.toFunction(combiner), source1, source2, source3, source4, source5, source6, source7, source8, source9);</span>
    }

    /**
     * Concatenates elements of each Publisher provided via an Iterable sequence into a single sequence
     * of elements without interleaving them.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concat.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream. The {@code Publisher}
     *  sources are expected to honor backpressure as well.
     *  If any of the source {@code Publisher}s violate this, it &lt;em&gt;may&lt;/em&gt; throw an
     *  {@code IllegalStateException} when the source {@code Publisher} completes.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code concat} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;T&gt; the common value type of the sources
     * @param sources the Iterable sequence of Publishers
     * @return the new Flowable instance
     */
    @SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Flowable&lt;T&gt; concat(Iterable&lt;? extends Publisher&lt;? extends T&gt;&gt; sources) {
<span class="fc" id="L1184">        ObjectHelper.requireNonNull(sources, &quot;sources is null&quot;);</span>
        // unlike general sources, fromIterable can only throw on a boundary because it is consumed only there
<span class="fc" id="L1186">        return fromIterable(sources).concatMapDelayError((Function)Functions.identity(), 2, false);</span>
    }

    /**
     * Returns a Flowable that emits the items emitted by each of the Publishers emitted by the source
     * Publisher, one after the other, without interleaving them.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concat.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream. Both the outer and inner {@code Publisher}
     *  sources are expected to honor backpressure as well. If the outer violates this, a
     *  {@code MissingBackpressureException} is signaled. If any of the inner {@code Publisher}s violates
     *  this, it &lt;em&gt;may&lt;/em&gt; throw an {@code IllegalStateException} when an inner {@code Publisher} completes.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code concat} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T&gt; the common element base type
     * @param sources
     *            a Publisher that emits Publishers
     * @return a Flowable that emits items all of the items emitted by the Publishers emitted by
     *         {@code Publishers}, one after the other, without interleaving them
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/concat.html&quot;&gt;ReactiveX operators documentation: Concat&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Flowable&lt;T&gt; concat(Publisher&lt;? extends Publisher&lt;? extends T&gt;&gt; sources) {
<span class="fc" id="L1215">        return concat(sources, bufferSize());</span>
    }

    /**
     * Returns a Flowable that emits the items emitted by each of the Publishers emitted by the source
     * Publisher, one after the other, without interleaving them.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concat.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream. Both the outer and inner {@code Publisher}
     *  sources are expected to honor backpressure as well. If the outer violates this, a
     *  {@code MissingBackpressureException} is signaled. If any of the inner {@code Publisher}s violates
     *  this, it &lt;em&gt;may&lt;/em&gt; throw an {@code IllegalStateException} when an inner {@code Publisher} completes.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code concat} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T&gt; the common element base type
     * @param sources
     *            a Publisher that emits Publishers
     * @param prefetch
     *            the number of Publishers to prefetch from the sources sequence.
     * @return a Flowable that emits items all of the items emitted by the Publishers emitted by
     *         {@code Publishers}, one after the other, without interleaving them
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/concat.html&quot;&gt;ReactiveX operators documentation: Concat&lt;/a&gt;
     */
    @SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Flowable&lt;T&gt; concat(Publisher&lt;? extends Publisher&lt;? extends T&gt;&gt; sources, int prefetch) {
<span class="fc" id="L1247">        return fromPublisher(sources).concatMap((Function)Functions.identity(), prefetch);</span>
    }

    /**
     * Returns a Flowable that emits the items emitted by two Publishers, one after the other, without
     * interleaving them.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concat.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream. The {@code Publisher}
     *  sources are expected to honor backpressure as well.
     *  If any of the source {@code Publisher}s violate this, it &lt;em&gt;may&lt;/em&gt; throw an
     *  {@code IllegalStateException} when the source {@code Publisher} completes.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code concat} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T&gt; the common element base type
     * @param source1
     *            a Publisher to be concatenated
     * @param source2
     *            a Publisher to be concatenated
     * @return a Flowable that emits items emitted by the two source Publishers, one after the other,
     *         without interleaving them
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/concat.html&quot;&gt;ReactiveX operators documentation: Concat&lt;/a&gt;
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Flowable&lt;T&gt; concat(Publisher&lt;? extends T&gt; source1, Publisher&lt;? extends T&gt; source2) {
<span class="fc" id="L1280">        ObjectHelper.requireNonNull(source1, &quot;source1 is null&quot;);</span>
<span class="fc" id="L1281">        ObjectHelper.requireNonNull(source2, &quot;source2 is null&quot;);</span>
<span class="fc" id="L1282">        return concatArray(source1, source2);</span>
    }

    /**
     * Returns a Flowable that emits the items emitted by three Publishers, one after the other, without
     * interleaving them.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concat.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream. The {@code Publisher}
     *  sources are expected to honor backpressure as well.
     *  If any of the source {@code Publisher}s violate this, it &lt;em&gt;may&lt;/em&gt; throw an
     *  {@code IllegalStateException} when the source {@code Publisher} completes.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code concat} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T&gt; the common element base type
     * @param source1
     *            a Publisher to be concatenated
     * @param source2
     *            a Publisher to be concatenated
     * @param source3
     *            a Publisher to be concatenated
     * @return a Flowable that emits items emitted by the three source Publishers, one after the other,
     *         without interleaving them
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/concat.html&quot;&gt;ReactiveX operators documentation: Concat&lt;/a&gt;
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Flowable&lt;T&gt; concat(
            Publisher&lt;? extends T&gt; source1, Publisher&lt;? extends T&gt; source2,
            Publisher&lt;? extends T&gt; source3) {
<span class="fc" id="L1319">        ObjectHelper.requireNonNull(source1, &quot;source1 is null&quot;);</span>
<span class="fc" id="L1320">        ObjectHelper.requireNonNull(source2, &quot;source2 is null&quot;);</span>
<span class="fc" id="L1321">        ObjectHelper.requireNonNull(source3, &quot;source3 is null&quot;);</span>
<span class="fc" id="L1322">        return concatArray(source1, source2, source3);</span>
    }

    /**
     * Returns a Flowable that emits the items emitted by four Publishers, one after the other, without
     * interleaving them.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concat.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream. The {@code Publisher}
     *  sources are expected to honor backpressure as well.
     *  If any of the source {@code Publisher}s violate this, it &lt;em&gt;may&lt;/em&gt; throw an
     *  {@code IllegalStateException} when the source {@code Publisher} completes.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code concat} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T&gt; the common element base type
     * @param source1
     *            a Publisher to be concatenated
     * @param source2
     *            a Publisher to be concatenated
     * @param source3
     *            a Publisher to be concatenated
     * @param source4
     *            a Publisher to be concatenated
     * @return a Flowable that emits items emitted by the four source Publishers, one after the other,
     *         without interleaving them
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/concat.html&quot;&gt;ReactiveX operators documentation: Concat&lt;/a&gt;
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Flowable&lt;T&gt; concat(
            Publisher&lt;? extends T&gt; source1, Publisher&lt;? extends T&gt; source2,
            Publisher&lt;? extends T&gt; source3, Publisher&lt;? extends T&gt; source4) {
<span class="fc" id="L1361">        ObjectHelper.requireNonNull(source1, &quot;source1 is null&quot;);</span>
<span class="fc" id="L1362">        ObjectHelper.requireNonNull(source2, &quot;source2 is null&quot;);</span>
<span class="fc" id="L1363">        ObjectHelper.requireNonNull(source3, &quot;source3 is null&quot;);</span>
<span class="fc" id="L1364">        ObjectHelper.requireNonNull(source4, &quot;source4 is null&quot;);</span>
<span class="fc" id="L1365">        return concatArray(source1, source2, source3, source4);</span>
    }

    /**
     * Concatenates a variable number of Publisher sources.
     * &lt;p&gt;
     * Note: named this way because of overload conflict with concat(Publisher&amp;lt;Publisher&amp;gt;).
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concat.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream. The {@code Publisher}
     *  sources are expected to honor backpressure as well.
     *  If any of the source {@code Publisher}s violate this, it &lt;em&gt;may&lt;/em&gt; throw an
     *  {@code IllegalStateException} when the source {@code Publisher} completes.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code concatArray} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param sources the array of sources
     * @param &lt;T&gt; the common base value type
     * @return the new Publisher instance
     * @throws NullPointerException if sources is null
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Flowable&lt;T&gt; concatArray(Publisher&lt;? extends T&gt;... sources) {
<span class="fc bfc" id="L1392" title="All 2 branches covered.">        if (sources.length == 0) {</span>
<span class="fc" id="L1393">            return empty();</span>
        } else
<span class="fc bfc" id="L1395" title="All 2 branches covered.">        if (sources.length == 1) {</span>
<span class="fc" id="L1396">            return fromPublisher(sources[0]);</span>
        }
<span class="fc" id="L1398">        return RxJavaPlugins.onAssembly(new FlowableConcatArray&lt;T&gt;(sources, false));</span>
    }

    /**
     * Concatenates a variable number of Publisher sources and delays errors from any of them
     * till all terminate.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concat.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream. The {@code Publisher}
     *  sources are expected to honor backpressure as well.
     *  If any of the source {@code Publisher}s violate this, it &lt;em&gt;may&lt;/em&gt; throw an
     *  {@code IllegalStateException} when the source {@code Publisher} completes.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code concatArrayDelayError} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param sources the array of sources
     * @param &lt;T&gt; the common base value type
     * @return the new Flowable instance
     * @throws NullPointerException if sources is null
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Flowable&lt;T&gt; concatArrayDelayError(Publisher&lt;? extends T&gt;... sources) {
<span class="fc bfc" id="L1424" title="All 2 branches covered.">        if (sources.length == 0) {</span>
<span class="fc" id="L1425">            return empty();</span>
        } else
<span class="fc bfc" id="L1427" title="All 2 branches covered.">        if (sources.length == 1) {</span>
<span class="fc" id="L1428">            return fromPublisher(sources[0]);</span>
        }
<span class="fc" id="L1430">        return RxJavaPlugins.onAssembly(new FlowableConcatArray&lt;T&gt;(sources, true));</span>
    }

    /**
     * Concatenates an array of Publishers eagerly into a single stream of values.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Flowable.concatArrayEager.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * Eager concatenation means that once a subscriber subscribes, this operator subscribes to all of the
     * source Publishers. The operator buffers the values emitted by these Publishers and then drains them
     * in order, each one after the previous one completes.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream. The {@code Publisher}
     *  sources are expected to honor backpressure as well.
     *  If any of the source {@code Publisher}s violate this, the operator will signal a
     *  {@code MissingBackpressureException}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This method does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;T&gt; the value type
     * @param sources an array of Publishers that need to be eagerly concatenated
     * @return the new Publisher instance with the specified concatenation behavior
     * @since 2.0
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Flowable&lt;T&gt; concatArrayEager(Publisher&lt;? extends T&gt;... sources) {
<span class="fc" id="L1459">        return concatArrayEager(bufferSize(), bufferSize(), sources);</span>
    }

    /**
     * Concatenates an array of Publishers eagerly into a single stream of values.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;406&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Flowable.concatArrayEager.nn.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * Eager concatenation means that once a subscriber subscribes, this operator subscribes to all of the
     * source Publishers. The operator buffers the values emitted by these Publishers and then drains them
     * in order, each one after the previous one completes.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream. The {@code Publisher}
     *  sources are expected to honor backpressure as well.
     *  If any of the source {@code Publisher}s violate this, the operator will signal a
     *  {@code MissingBackpressureException}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This method does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;T&gt; the value type
     * @param sources an array of Publishers that need to be eagerly concatenated
     * @param maxConcurrency the maximum number of concurrent subscriptions at a time, Integer.MAX_VALUE
     *                       is interpreted as an indication to subscribe to all sources at once
     * @param prefetch the number of elements to prefetch from each Publisher source
     * @return the new Publisher instance with the specified concatenation behavior
     * @since 2.0
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    @SuppressWarnings({ &quot;rawtypes&quot;, &quot;unchecked&quot; })
    public static &lt;T&gt; Flowable&lt;T&gt; concatArrayEager(int maxConcurrency, int prefetch, Publisher&lt;? extends T&gt;... sources) {
<span class="fc" id="L1493">        ObjectHelper.requireNonNull(sources, &quot;sources is null&quot;);</span>
<span class="fc" id="L1494">        ObjectHelper.verifyPositive(maxConcurrency, &quot;maxConcurrency&quot;);</span>
<span class="fc" id="L1495">        ObjectHelper.verifyPositive(prefetch, &quot;prefetch&quot;);</span>
<span class="fc" id="L1496">        return RxJavaPlugins.onAssembly(new FlowableConcatMapEager(new FlowableFromArray(sources), Functions.identity(), maxConcurrency, prefetch, ErrorMode.IMMEDIATE));</span>
    }

    /**
     * Concatenates an array of {@link Publisher}s eagerly into a single stream of values
     * and delaying any errors until all sources terminate.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;358&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Flowable.concatArrayEagerDelayError.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * Eager concatenation means that once a subscriber subscribes, this operator subscribes to all of the
     * source {@code Publisher}s. The operator buffers the values emitted by these {@code Publisher}s
     * and then drains them in order, each one after the previous one completes.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream. The {@code Publisher}
     *  sources are expected to honor backpressure as well.
     *  If any of the source {@code Publisher}s violate this, the operator will signal a
     *  {@code MissingBackpressureException}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This method does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;T&gt; the value type
     * @param sources an array of {@code Publisher}s that need to be eagerly concatenated
     * @return the new Flowable instance with the specified concatenation behavior
     * @since 2.2.1 - experimental
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    @BackpressureSupport(BackpressureKind.FULL)
    public static &lt;T&gt; Flowable&lt;T&gt; concatArrayEagerDelayError(Publisher&lt;? extends T&gt;... sources) {
<span class="fc" id="L1526">        return concatArrayEagerDelayError(bufferSize(), bufferSize(), sources);</span>
    }

    /**
     * Concatenates an array of {@link Publisher}s eagerly into a single stream of values
     * and delaying any errors until all sources terminate.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;359&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Flowable.concatArrayEagerDelayError.nn.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * Eager concatenation means that once a subscriber subscribes, this operator subscribes to all of the
     * source {@code Publisher}s. The operator buffers the values emitted by these {@code Publisher}s
     * and then drains them in order, each one after the previous one completes.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream. The {@code Publisher}
     *  sources are expected to honor backpressure as well.
     *  If any of the source {@code Publisher}s violate this, the operator will signal a
     *  {@code MissingBackpressureException}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This method does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;T&gt; the value type
     * @param sources an array of {@code Publisher}s that need to be eagerly concatenated
     * @param maxConcurrency the maximum number of concurrent subscriptions at a time, Integer.MAX_VALUE
     *                       is interpreted as indication to subscribe to all sources at once
     * @param prefetch the number of elements to prefetch from each {@code Publisher} source
     * @return the new Flowable instance with the specified concatenation behavior
     * @since 2.2.1 - experimental
     */
    @SuppressWarnings({ &quot;rawtypes&quot;, &quot;unchecked&quot; })
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    @BackpressureSupport(BackpressureKind.FULL)
    public static &lt;T&gt; Flowable&lt;T&gt; concatArrayEagerDelayError(int maxConcurrency, int prefetch, Publisher&lt;? extends T&gt;... sources) {
<span class="fc" id="L1560">        return fromArray(sources).concatMapEagerDelayError((Function)Functions.identity(), maxConcurrency, prefetch, true);</span>
    }

    /**
     * Concatenates the Iterable sequence of Publishers into a single sequence by subscribing to each Publisher,
     * one after the other, one at a time and delays any errors till the all inner Publishers terminate.
     *
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream. Both the outer and inner {@code Publisher}
     *  sources are expected to honor backpressure as well. If the outer violates this, a
     *  {@code MissingBackpressureException} is signaled. If any of the inner {@code Publisher}s violates
     *  this, it &lt;em&gt;may&lt;/em&gt; throw an {@code IllegalStateException} when an inner {@code Publisher} completes.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code concatDelayError} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T&gt; the common element base type
     * @param sources the Iterable sequence of Publishers
     * @return the new Publisher with the concatenating behavior
     */
    @SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Flowable&lt;T&gt; concatDelayError(Iterable&lt;? extends Publisher&lt;? extends T&gt;&gt; sources) {
<span class="fc" id="L1587">        ObjectHelper.requireNonNull(sources, &quot;sources is null&quot;);</span>
<span class="fc" id="L1588">        return fromIterable(sources).concatMapDelayError((Function)Functions.identity());</span>
    }

    /**
     * Concatenates the Publisher sequence of Publishers into a single sequence by subscribing to each inner Publisher,
     * one after the other, one at a time and delays any errors till the all inner and the outer Publishers terminate.
     *
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code concatDelayError} fully supports backpressure.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code concatDelayError} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T&gt; the common element base type
     * @param sources the Publisher sequence of Publishers
     * @return the new Publisher with the concatenating behavior
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Flowable&lt;T&gt; concatDelayError(Publisher&lt;? extends Publisher&lt;? extends T&gt;&gt; sources) {
<span class="fc" id="L1610">        return concatDelayError(sources, bufferSize(), true);</span>
    }

    /**
     * Concatenates the Publisher sequence of Publishers into a single sequence by subscribing to each inner Publisher,
     * one after the other, one at a time and delays any errors till the all inner and the outer Publishers terminate.
     *
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code concatDelayError} fully supports backpressure.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code concatDelayError} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T&gt; the common element base type
     * @param sources the Publisher sequence of Publishers
     * @param prefetch the number of elements to prefetch from the outer Publisher
     * @param tillTheEnd if true exceptions from the outer and all inner Publishers are delayed to the end
     *                   if false, exception from the outer Publisher is delayed till the current Publisher terminates
     * @return the new Publisher with the concatenating behavior
     */
    @SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Flowable&lt;T&gt; concatDelayError(Publisher&lt;? extends Publisher&lt;? extends T&gt;&gt; sources, int prefetch, boolean tillTheEnd) {
<span class="fc" id="L1636">        return fromPublisher(sources).concatMapDelayError((Function)Functions.identity(), prefetch, tillTheEnd);</span>
    }

    /**
     * Concatenates a Publisher sequence of Publishers eagerly into a single stream of values.
     * &lt;p&gt;
     * Eager concatenation means that once a subscriber subscribes, this operator subscribes to all of the
     * emitted source Publishers as they are observed. The operator buffers the values emitted by these
     * Publishers and then drains them in order, each one after the previous one completes.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;Backpressure is honored towards the downstream and both the outer and inner Publishers are
     *  expected to support backpressure. Violating this assumption, the operator will
     *  signal {@code MissingBackpressureException}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This method does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;T&gt; the value type
     * @param sources a sequence of Publishers that need to be eagerly concatenated
     * @return the new Publisher instance with the specified concatenation behavior
     * @since 2.0
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Flowable&lt;T&gt; concatEager(Publisher&lt;? extends Publisher&lt;? extends T&gt;&gt; sources) {
<span class="fc" id="L1662">        return concatEager(sources, bufferSize(), bufferSize());</span>
    }

    /**
     * Concatenates a Publisher sequence of Publishers eagerly into a single stream of values.
     * &lt;p&gt;
     * Eager concatenation means that once a subscriber subscribes, this operator subscribes to all of the
     * emitted source Publishers as they are observed. The operator buffers the values emitted by these
     * Publishers and then drains them in order, each one after the previous one completes.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;Backpressure is honored towards the downstream and both the outer and inner Publishers are
     *  expected to support backpressure. Violating this assumption, the operator will
     *  signal {@code MissingBackpressureException}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This method does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;T&gt; the value type
     * @param sources a sequence of Publishers that need to be eagerly concatenated
     * @param maxConcurrency the maximum number of concurrently running inner Publishers; Integer.MAX_VALUE
     *                       is interpreted as all inner Publishers can be active at the same time
     * @param prefetch the number of elements to prefetch from each inner Publisher source
     * @return the new Publisher instance with the specified concatenation behavior
     * @since 2.0
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    @SuppressWarnings({ &quot;rawtypes&quot;, &quot;unchecked&quot; })
    public static &lt;T&gt; Flowable&lt;T&gt; concatEager(Publisher&lt;? extends Publisher&lt;? extends T&gt;&gt; sources, int maxConcurrency, int prefetch) {
<span class="fc" id="L1693">        ObjectHelper.requireNonNull(sources, &quot;sources is null&quot;);</span>
<span class="fc" id="L1694">        ObjectHelper.verifyPositive(maxConcurrency, &quot;maxConcurrency&quot;);</span>
<span class="fc" id="L1695">        ObjectHelper.verifyPositive(prefetch, &quot;prefetch&quot;);</span>
<span class="fc" id="L1696">        return RxJavaPlugins.onAssembly(new FlowableConcatMapEagerPublisher(sources, Functions.identity(), maxConcurrency, prefetch, ErrorMode.IMMEDIATE));</span>
    }

    /**
     * Concatenates a sequence of Publishers eagerly into a single stream of values.
     * &lt;p&gt;
     * Eager concatenation means that once a subscriber subscribes, this operator subscribes to all of the
     * source Publishers. The operator buffers the values emitted by these Publishers and then drains them
     * in order, each one after the previous one completes.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;Backpressure is honored towards the downstream and the inner Publishers are
     *  expected to support backpressure. Violating this assumption, the operator will
     *  signal {@code MissingBackpressureException}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This method does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;T&gt; the value type
     * @param sources a sequence of Publishers that need to be eagerly concatenated
     * @return the new Publisher instance with the specified concatenation behavior
     * @since 2.0
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Flowable&lt;T&gt; concatEager(Iterable&lt;? extends Publisher&lt;? extends T&gt;&gt; sources) {
<span class="fc" id="L1722">        return concatEager(sources, bufferSize(), bufferSize());</span>
    }

    /**
     * Concatenates a sequence of Publishers eagerly into a single stream of values.
     * &lt;p&gt;
     * Eager concatenation means that once a subscriber subscribes, this operator subscribes to all of the
     * source Publishers. The operator buffers the values emitted by these Publishers and then drains them
     * in order, each one after the previous one completes.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;Backpressure is honored towards the downstream and both the outer and inner Publishers are
     *  expected to support backpressure. Violating this assumption, the operator will
     *  signal {@code MissingBackpressureException}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This method does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;T&gt; the value type
     * @param sources a sequence of Publishers that need to be eagerly concatenated
     * @param maxConcurrency the maximum number of concurrently running inner Publishers; Integer.MAX_VALUE
     *                       is interpreted as all inner Publishers can be active at the same time
     * @param prefetch the number of elements to prefetch from each inner Publisher source
     * @return the new Publisher instance with the specified concatenation behavior
     * @since 2.0
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    @SuppressWarnings({ &quot;rawtypes&quot;, &quot;unchecked&quot; })
    public static &lt;T&gt; Flowable&lt;T&gt; concatEager(Iterable&lt;? extends Publisher&lt;? extends T&gt;&gt; sources, int maxConcurrency, int prefetch) {
<span class="fc" id="L1753">        ObjectHelper.requireNonNull(sources, &quot;sources is null&quot;);</span>
<span class="fc" id="L1754">        ObjectHelper.verifyPositive(maxConcurrency, &quot;maxConcurrency&quot;);</span>
<span class="fc" id="L1755">        ObjectHelper.verifyPositive(prefetch, &quot;prefetch&quot;);</span>
<span class="fc" id="L1756">        return RxJavaPlugins.onAssembly(new FlowableConcatMapEager(new FlowableFromIterable(sources), Functions.identity(), maxConcurrency, prefetch, ErrorMode.IMMEDIATE));</span>
    }

    /**
     * Provides an API (via a cold Flowable) that bridges the reactive world with the callback-style,
     * generally non-backpressured world.
     * &lt;p&gt;
     * Example:
     * &lt;pre&gt;&lt;code&gt;
     * Flowable.&amp;lt;Event&amp;gt;create(emitter -&amp;gt; {
     *     Callback listener = new Callback() {
     *         &amp;#64;Override
     *         public void onEvent(Event e) {
     *             emitter.onNext(e);
     *             if (e.isLast()) {
     *                 emitter.onComplete();
     *             }
     *         }
     *
     *         &amp;#64;Override
     *         public void onFailure(Exception e) {
     *             emitter.onError(e);
     *         }
     *     };
     *
     *     AutoCloseable c = api.someMethod(listener);
     *
     *     emitter.setCancellable(c::close);
     *
     * }, BackpressureStrategy.BUFFER);
     * &lt;/code&gt;&lt;/pre&gt;
     * &lt;p&gt;
     * You should call the FlowableEmitter onNext, onError and onComplete methods in a serialized fashion. The
     * rest of its methods are thread-safe.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The backpressure behavior is determined by the {@code mode} parameter.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code create} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T&gt; the element type
     * @param source the emitter that is called when a Subscriber subscribes to the returned {@code Flowable}
     * @param mode the backpressure mode to apply if the downstream Subscriber doesn't request (fast) enough
     * @return the new Flowable instance
     * @see FlowableOnSubscribe
     * @see BackpressureStrategy
     * @see Cancellable
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.SPECIAL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Flowable&lt;T&gt; create(FlowableOnSubscribe&lt;T&gt; source, BackpressureStrategy mode) {
<span class="fc" id="L1810">        ObjectHelper.requireNonNull(source, &quot;source is null&quot;);</span>
<span class="fc" id="L1811">        ObjectHelper.requireNonNull(mode, &quot;mode is null&quot;);</span>
<span class="fc" id="L1812">        return RxJavaPlugins.onAssembly(new FlowableCreate&lt;T&gt;(source, mode));</span>
    }

    /**
     * Returns a Flowable that calls a Publisher factory to create a Publisher for each new Subscriber
     * that subscribes. That is, for each subscriber, the actual Publisher that subscriber observes is
     * determined by the factory function.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;340&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/defer.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * The defer Subscriber allows you to defer or delay emitting items from a Publisher until such time as a
     * Subscriber subscribes to the Publisher. This allows a {@link Subscriber} to easily obtain updates or a
     * refreshed version of the sequence.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator itself doesn't interfere with backpressure which is determined by the {@code Publisher}
     *  returned by the {@code supplier}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code defer} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param supplier
     *            the Publisher factory function to invoke for each {@link Subscriber} that subscribes to the
     *            resulting Publisher
     * @param &lt;T&gt;
     *            the type of the items emitted by the Publisher
     * @return a Flowable whose {@link Subscriber}s' subscriptions trigger an invocation of the given
     *         Publisher factory function
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/defer.html&quot;&gt;ReactiveX operators documentation: Defer&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Flowable&lt;T&gt; defer(Callable&lt;? extends Publisher&lt;? extends T&gt;&gt; supplier) {
<span class="fc" id="L1847">        ObjectHelper.requireNonNull(supplier, &quot;supplier is null&quot;);</span>
<span class="fc" id="L1848">        return RxJavaPlugins.onAssembly(new FlowableDefer&lt;T&gt;(supplier));</span>
    }

    /**
     * Returns a Flowable that emits no items to the {@link Subscriber} and immediately invokes its
     * {@link Subscriber#onComplete onComplete} method.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;190&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/empty.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This source doesn't produce any elements and effectively ignores downstream backpressure.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code empty} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T&gt;
     *            the type of the items (ostensibly) emitted by the Publisher
     * @return a Flowable that emits no items to the {@link Subscriber} but immediately invokes the
     *         {@link Subscriber}'s {@link Subscriber#onComplete() onComplete} method
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/empty-never-throw.html&quot;&gt;ReactiveX operators documentation: Empty&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.NONE)
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; Flowable&lt;T&gt; empty() {
<span class="fc" id="L1874">        return RxJavaPlugins.onAssembly((Flowable&lt;T&gt;) FlowableEmpty.INSTANCE);</span>
    }

    /**
     * Returns a Flowable that invokes a {@link Subscriber}'s {@link Subscriber#onError onError} method when the
     * Subscriber subscribes to it.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;190&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/error.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This source doesn't produce any elements and effectively ignores downstream backpressure.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code error} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param supplier
     *            a Callable factory to return a Throwable for each individual Subscriber
     * @param &lt;T&gt;
     *            the type of the items (ostensibly) emitted by the Publisher
     * @return a Flowable that invokes the {@link Subscriber}'s {@link Subscriber#onError onError} method when
     *         the Subscriber subscribes to it
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/empty-never-throw.html&quot;&gt;ReactiveX operators documentation: Throw&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Flowable&lt;T&gt; error(Callable&lt;? extends Throwable&gt; supplier) {
<span class="fc" id="L1902">        ObjectHelper.requireNonNull(supplier, &quot;supplier is null&quot;);</span>
<span class="fc" id="L1903">        return RxJavaPlugins.onAssembly(new FlowableError&lt;T&gt;(supplier));</span>
    }

    /**
     * Returns a Flowable that invokes a {@link Subscriber}'s {@link Subscriber#onError onError} method when the
     * Subscriber subscribes to it.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;190&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/error.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This source doesn't produce any elements and effectively ignores downstream backpressure.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code error} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param throwable
     *            the particular Throwable to pass to {@link Subscriber#onError onError}
     * @param &lt;T&gt;
     *            the type of the items (ostensibly) emitted by the Publisher
     * @return a Flowable that invokes the {@link Subscriber}'s {@link Subscriber#onError onError} method when
     *         the Subscriber subscribes to it
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/empty-never-throw.html&quot;&gt;ReactiveX operators documentation: Throw&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Flowable&lt;T&gt; error(final Throwable throwable) {
<span class="fc" id="L1931">        ObjectHelper.requireNonNull(throwable, &quot;throwable is null&quot;);</span>
<span class="fc" id="L1932">        return error(Functions.justCallable(throwable));</span>
    }

    /**
     * Converts an Array into a Publisher that emits the items in the Array.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;315&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/from.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream and iterates the given {@code array}
     *  on demand (i.e., when requested).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code fromArray} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param items
     *            the array of elements
     * @param &lt;T&gt;
     *            the type of items in the Array and the type of items to be emitted by the resulting Publisher
     * @return a Flowable that emits each item in the source Array
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/from.html&quot;&gt;ReactiveX operators documentation: From&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Flowable&lt;T&gt; fromArray(T... items) {
<span class="fc" id="L1959">        ObjectHelper.requireNonNull(items, &quot;items is null&quot;);</span>
<span class="fc bfc" id="L1960" title="All 2 branches covered.">        if (items.length == 0) {</span>
<span class="fc" id="L1961">            return empty();</span>
        }
<span class="fc bfc" id="L1963" title="All 2 branches covered.">        if (items.length == 1) {</span>
<span class="fc" id="L1964">            return just(items[0]);</span>
        }
<span class="fc" id="L1966">        return RxJavaPlugins.onAssembly(new FlowableFromArray&lt;T&gt;(items));</span>
    }

    /**
     * Returns a Flowable that, when a Subscriber subscribes to it, invokes a function you specify and then
     * emits the value returned from that function.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/fromCallable.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * This allows you to defer the execution of the function you specify until a Subscriber subscribes to the
     * Publisher. That is to say, it makes the function &quot;lazy.&quot;
     * &lt;dl&gt;
     *   &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *   &lt;dd&gt;The operator honors backpressure from downstream.&lt;/dd&gt;
     *   &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *   &lt;dd&gt;{@code fromCallable} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     *   &lt;dt&gt;&lt;b&gt;Error handling:&lt;/b&gt;&lt;/dt&gt;
     *   &lt;dd&gt; If the {@link Callable} throws an exception, the respective {@link Throwable} is
     *   delivered to the downstream via {@link Subscriber#onError(Throwable)},
     *   except when the downstream has canceled this {@code Flowable} source.
     *   In this latter case, the {@code Throwable} is delivered to the global error handler via
     *   {@link RxJavaPlugins#onError(Throwable)} as an {@link io.reactivex.exceptions.UndeliverableException UndeliverableException}.
     *   &lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param supplier
     *         a function, the execution of which should be deferred; {@code fromCallable} will invoke this
     *         function only when a Subscriber subscribes to the Publisher that {@code fromCallable} returns
     * @param &lt;T&gt;
     *         the type of the item emitted by the Publisher
     * @return a Flowable whose {@link Subscriber}s' subscriptions trigger an invocation of the given function
     * @see #defer(Callable)
     * @since 2.0
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Flowable&lt;T&gt; fromCallable(Callable&lt;? extends T&gt; supplier) {
<span class="fc" id="L2005">        ObjectHelper.requireNonNull(supplier, &quot;supplier is null&quot;);</span>
<span class="fc" id="L2006">        return RxJavaPlugins.onAssembly(new FlowableFromCallable&lt;T&gt;(supplier));</span>
    }

    /**
     * Converts a {@link Future} into a Publisher.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;315&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/from.Future.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * You can convert any object that supports the {@link Future} interface into a Publisher that emits the
     * return value of the {@link Future#get} method of that object by passing the object into the {@code from}
     * method.
     * &lt;p&gt;
     * &lt;em&gt;Important note:&lt;/em&gt; This Publisher is blocking on the thread it gets subscribed on; you cannot cancel it.
     * &lt;p&gt;
     * Unlike 1.x, canceling the Flowable won't cancel the future. If necessary, one can use composition to achieve the
     * cancellation effect: {@code futurePublisher.doOnCancel(() -&gt; future.cancel(true));}.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code fromFuture} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param future
     *            the source {@link Future}
     * @param &lt;T&gt;
     *            the type of object that the {@link Future} returns, and also the type of item to be emitted by
     *            the resulting Publisher
     * @return a Flowable that emits the item from the source {@link Future}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/from.html&quot;&gt;ReactiveX operators documentation: From&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Flowable&lt;T&gt; fromFuture(Future&lt;? extends T&gt; future) {
<span class="fc" id="L2042">        ObjectHelper.requireNonNull(future, &quot;future is null&quot;);</span>
<span class="fc" id="L2043">        return RxJavaPlugins.onAssembly(new FlowableFromFuture&lt;T&gt;(future, 0L, null));</span>
    }

    /**
     * Converts a {@link Future} into a Publisher, with a timeout on the Future.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;315&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/from.Future.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * You can convert any object that supports the {@link Future} interface into a Publisher that emits the
     * return value of the {@link Future#get} method of that object by passing the object into the {@code fromFuture}
     * method.
     * &lt;p&gt;
     * Unlike 1.x, canceling the Flowable won't cancel the future. If necessary, one can use composition to achieve the
     * cancellation effect: {@code futurePublisher.doOnCancel(() -&gt; future.cancel(true));}.
     * &lt;p&gt;
     * &lt;em&gt;Important note:&lt;/em&gt; This Publisher is blocking on the thread it gets subscribed on; you cannot cancel it.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code fromFuture} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param future
     *            the source {@link Future}
     * @param timeout
     *            the maximum time to wait before calling {@code get}
     * @param unit
     *            the {@link TimeUnit} of the {@code timeout} argument
     * @param &lt;T&gt;
     *            the type of object that the {@link Future} returns, and also the type of item to be emitted by
     *            the resulting Publisher
     * @return a Flowable that emits the item from the source {@link Future}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/from.html&quot;&gt;ReactiveX operators documentation: From&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Flowable&lt;T&gt; fromFuture(Future&lt;? extends T&gt; future, long timeout, TimeUnit unit) {
<span class="fc" id="L2083">        ObjectHelper.requireNonNull(future, &quot;future is null&quot;);</span>
<span class="fc" id="L2084">        ObjectHelper.requireNonNull(unit, &quot;unit is null&quot;);</span>
<span class="fc" id="L2085">        return RxJavaPlugins.onAssembly(new FlowableFromFuture&lt;T&gt;(future, timeout, unit));</span>
    }

    /**
     * Converts a {@link Future} into a Publisher, with a timeout on the Future.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;315&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/from.Future.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * You can convert any object that supports the {@link Future} interface into a Publisher that emits the
     * return value of the {@link Future#get} method of that object by passing the object into the {@code from}
     * method.
     * &lt;p&gt;
     * Unlike 1.x, canceling the Flowable won't cancel the future. If necessary, one can use composition to achieve the
     * cancellation effect: {@code futurePublisher.doOnCancel(() -&gt; future.cancel(true));}.
     * &lt;p&gt;
     * &lt;em&gt;Important note:&lt;/em&gt; This Publisher is blocking; you cannot cancel it.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code fromFuture} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param future
     *            the source {@link Future}
     * @param timeout
     *            the maximum time to wait before calling {@code get}
     * @param unit
     *            the {@link TimeUnit} of the {@code timeout} argument
     * @param scheduler
     *            the {@link Scheduler} to wait for the Future on. Use a Scheduler such as
     *            {@link Schedulers#io()} that can block and wait on the Future
     * @param &lt;T&gt;
     *            the type of object that the {@link Future} returns, and also the type of item to be emitted by
     *            the resulting Publisher
     * @return a Flowable that emits the item from the source {@link Future}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/from.html&quot;&gt;ReactiveX operators documentation: From&lt;/a&gt;
     */
    @SuppressWarnings({ &quot;unchecked&quot;, &quot;cast&quot; })
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public static &lt;T&gt; Flowable&lt;T&gt; fromFuture(Future&lt;? extends T&gt; future, long timeout, TimeUnit unit, Scheduler scheduler) {
<span class="fc" id="L2129">        ObjectHelper.requireNonNull(scheduler, &quot;scheduler is null&quot;);</span>
<span class="fc" id="L2130">        return fromFuture((Future&lt;T&gt;)future, timeout, unit).subscribeOn(scheduler);</span>
    }

    /**
     * Converts a {@link Future}, operating on a specified {@link Scheduler}, into a Publisher.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;315&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/from.Future.s.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * You can convert any object that supports the {@link Future} interface into a Publisher that emits the
     * return value of the {@link Future#get} method of that object by passing the object into the {@code from}
     * method.
     * &lt;p&gt;
     * Unlike 1.x, canceling the Flowable won't cancel the future. If necessary, one can use composition to achieve the
     * cancellation effect: {@code futurePublisher.doOnCancel(() -&gt; future.cancel(true));}.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;You specify which {@link Scheduler} this operator will use.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param future
     *            the source {@link Future}
     * @param scheduler
     *            the {@link Scheduler} to wait for the Future on. Use a Scheduler such as
     *            {@link Schedulers#io()} that can block and wait on the Future
     * @param &lt;T&gt;
     *            the type of object that the {@link Future} returns, and also the type of item to be emitted by
     *            the resulting Publisher
     * @return a Flowable that emits the item from the source {@link Future}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/from.html&quot;&gt;ReactiveX operators documentation: From&lt;/a&gt;
     */
    @SuppressWarnings({ &quot;cast&quot;, &quot;unchecked&quot; })
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public static &lt;T&gt; Flowable&lt;T&gt; fromFuture(Future&lt;? extends T&gt; future, Scheduler scheduler) {
<span class="fc" id="L2168">        ObjectHelper.requireNonNull(scheduler, &quot;scheduler is null&quot;);</span>
<span class="fc" id="L2169">        return fromFuture((Future&lt;T&gt;)future).subscribeOn(scheduler);</span>
    }

    /**
     * Converts an {@link Iterable} sequence into a Publisher that emits the items in the sequence.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;315&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/from.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream and iterates the given {@code iterable}
     *  on demand (i.e., when requested).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code fromIterable} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param source
     *            the source {@link Iterable} sequence
     * @param &lt;T&gt;
     *            the type of items in the {@link Iterable} sequence and the type of items to be emitted by the
     *            resulting Publisher
     * @return a Flowable that emits each item in the source {@link Iterable} sequence
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/from.html&quot;&gt;ReactiveX operators documentation: From&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Flowable&lt;T&gt; fromIterable(Iterable&lt;? extends T&gt; source) {
<span class="fc" id="L2197">        ObjectHelper.requireNonNull(source, &quot;source is null&quot;);</span>
<span class="fc" id="L2198">        return RxJavaPlugins.onAssembly(new FlowableFromIterable&lt;T&gt;(source));</span>
    }

    /**
     * Converts an arbitrary Reactive-Streams Publisher into a Flowable if not already a
     * Flowable.
     * &lt;p&gt;
     * The {@link Publisher} must follow the
     * &lt;a href=&quot;https://github.com/reactive-streams/reactive-streams-jvm#reactive-streams&quot;&gt;Reactive-Streams specification&lt;/a&gt;.
     * Violating the specification may result in undefined behavior.
     * &lt;p&gt;
     * If possible, use {@link #create(FlowableOnSubscribe, BackpressureStrategy)} to create a
     * source-like {@code Flowable} instead.
     * &lt;p&gt;
     * Note that even though {@link Publisher} appears to be a functional interface, it
     * is not recommended to implement it through a lambda as the specification requires
     * state management that is not achievable with a stateless lambda.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator is a pass-through for backpressure and its behavior is determined by the
     *  backpressure behavior of the wrapped publisher.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code fromPublisher} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;T&gt; the value type of the flow
     * @param source the Publisher to convert
     * @return the new Flowable instance
     * @throws NullPointerException if the {@code source} {@code Publisher} is null
     * @see #create(FlowableOnSubscribe, BackpressureStrategy)
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.NONE)
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; Flowable&lt;T&gt; fromPublisher(final Publisher&lt;? extends T&gt; source) {
<span class="fc bfc" id="L2234" title="All 2 branches covered.">        if (source instanceof Flowable) {</span>
<span class="fc" id="L2235">            return RxJavaPlugins.onAssembly((Flowable&lt;T&gt;)source);</span>
        }
<span class="fc" id="L2237">        ObjectHelper.requireNonNull(source, &quot;source is null&quot;);</span>

<span class="fc" id="L2239">        return RxJavaPlugins.onAssembly(new FlowableFromPublisher&lt;T&gt;(source));</span>
    }

    /**
     * Returns a cold, synchronous, stateless and backpressure-aware generator of values.
     * &lt;p&gt;
     * Note that the {@link Emitter#onNext}, {@link Emitter#onError} and
     * {@link Emitter#onComplete} methods provided to the function via the {@link Emitter} instance should be called synchronously,
     * never concurrently and only while the function body is executing. Calling them from multiple threads
     * or outside the function call is not supported and leads to an undefined behavior.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors downstream backpressure.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code generate} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T&gt; the generated value type
     * @param generator the Consumer called whenever a particular downstream Subscriber has
     * requested a value. The callback then should call {@code onNext}, {@code onError} or
     * {@code onComplete} to signal a value or a terminal event. Signaling multiple {@code onNext}
     * in a call will make the operator signal {@code IllegalStateException}.
     * @return the new Flowable instance
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Flowable&lt;T&gt; generate(final Consumer&lt;Emitter&lt;T&gt;&gt; generator) {
<span class="fc" id="L2268">        ObjectHelper.requireNonNull(generator, &quot;generator is null&quot;);</span>
<span class="fc" id="L2269">        return generate(Functions.nullSupplier(),</span>
<span class="fc" id="L2270">                FlowableInternalHelper.&lt;T, Object&gt;simpleGenerator(generator),</span>
<span class="fc" id="L2271">                Functions.emptyConsumer());</span>
    }

    /**
     * Returns a cold, synchronous, stateful and backpressure-aware generator of values.
     * &lt;p&gt;
     * Note that the {@link Emitter#onNext}, {@link Emitter#onError} and
     * {@link Emitter#onComplete} methods provided to the function via the {@link Emitter} instance should be called synchronously,
     * never concurrently and only while the function body is executing. Calling them from multiple threads
     * or outside the function call is not supported and leads to an undefined behavior.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors downstream backpressure.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code generate} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;S&gt; the type of the per-Subscriber state
     * @param &lt;T&gt; the generated value type
     * @param initialState the Callable to generate the initial state for each Subscriber
     * @param generator the Consumer called with the current state whenever a particular downstream Subscriber has
     * requested a value. The callback then should call {@code onNext}, {@code onError} or
     * {@code onComplete} to signal a value or a terminal event. Signaling multiple {@code onNext}
     * in a call will make the operator signal {@code IllegalStateException}.
     * @return the new Flowable instance
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T, S&gt; Flowable&lt;T&gt; generate(Callable&lt;S&gt; initialState, final BiConsumer&lt;S, Emitter&lt;T&gt;&gt; generator) {
<span class="fc" id="L2302">        ObjectHelper.requireNonNull(generator, &quot;generator is null&quot;);</span>
<span class="fc" id="L2303">        return generate(initialState, FlowableInternalHelper.&lt;T, S&gt;simpleBiGenerator(generator),</span>
<span class="fc" id="L2304">                Functions.emptyConsumer());</span>
    }

    /**
     * Returns a cold, synchronous, stateful and backpressure-aware generator of values.
     * &lt;p&gt;
     * Note that the {@link Emitter#onNext}, {@link Emitter#onError} and
     * {@link Emitter#onComplete} methods provided to the function via the {@link Emitter} instance should be called synchronously,
     * never concurrently and only while the function body is executing. Calling them from multiple threads
     * or outside the function call is not supported and leads to an undefined behavior.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors downstream backpressure.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code generate} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;S&gt; the type of the per-Subscriber state
     * @param &lt;T&gt; the generated value type
     * @param initialState the Callable to generate the initial state for each Subscriber
     * @param generator the Consumer called with the current state whenever a particular downstream Subscriber has
     * requested a value. The callback then should call {@code onNext}, {@code onError} or
     * {@code onComplete} to signal a value or a terminal event. Signaling multiple {@code onNext}
     * in a call will make the operator signal {@code IllegalStateException}.
     * @param disposeState the Consumer that is called with the current state when the generator
     * terminates the sequence or it gets canceled
     * @return the new Flowable instance
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T, S&gt; Flowable&lt;T&gt; generate(Callable&lt;S&gt; initialState, final BiConsumer&lt;S, Emitter&lt;T&gt;&gt; generator,
            Consumer&lt;? super S&gt; disposeState) {
<span class="fc" id="L2338">        ObjectHelper.requireNonNull(generator, &quot;generator is null&quot;);</span>
<span class="fc" id="L2339">        return generate(initialState, FlowableInternalHelper.&lt;T, S&gt;simpleBiGenerator(generator), disposeState);</span>
    }

    /**
     * Returns a cold, synchronous, stateful and backpressure-aware generator of values.
     * &lt;p&gt;
     * Note that the {@link Emitter#onNext}, {@link Emitter#onError} and
     * {@link Emitter#onComplete} methods provided to the function via the {@link Emitter} instance should be called synchronously,
     * never concurrently and only while the function body is executing. Calling them from multiple threads
     * or outside the function call is not supported and leads to an undefined behavior.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors downstream backpressure.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code generate} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;S&gt; the type of the per-Subscriber state
     * @param &lt;T&gt; the generated value type
     * @param initialState the Callable to generate the initial state for each Subscriber
     * @param generator the Function called with the current state whenever a particular downstream Subscriber has
     * requested a value. The callback then should call {@code onNext}, {@code onError} or
     * {@code onComplete} to signal a value or a terminal event and should return a (new) state for
     * the next invocation. Signaling multiple {@code onNext}
     * in a call will make the operator signal {@code IllegalStateException}.
     * @return the new Flowable instance
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T, S&gt; Flowable&lt;T&gt; generate(Callable&lt;S&gt; initialState, BiFunction&lt;S, Emitter&lt;T&gt;, S&gt; generator) {
<span class="fc" id="L2370">        return generate(initialState, generator, Functions.emptyConsumer());</span>
    }

    /**
     * Returns a cold, synchronous, stateful and backpressure-aware generator of values.
     * &lt;p&gt;
     * Note that the {@link Emitter#onNext}, {@link Emitter#onError} and
     * {@link Emitter#onComplete} methods provided to the function via the {@link Emitter} instance should be called synchronously,
     * never concurrently and only while the function body is executing. Calling them from multiple threads
     * or outside the function call is not supported and leads to an undefined behavior.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors downstream backpressure.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code generate} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;S&gt; the type of the per-Subscriber state
     * @param &lt;T&gt; the generated value type
     * @param initialState the Callable to generate the initial state for each Subscriber
     * @param generator the Function called with the current state whenever a particular downstream Subscriber has
     * requested a value. The callback then should call {@code onNext}, {@code onError} or
     * {@code onComplete} to signal a value or a terminal event and should return a (new) state for
     * the next invocation. Signaling multiple {@code onNext}
     * in a call will make the operator signal {@code IllegalStateException}.
     * @param disposeState the Consumer that is called with the current state when the generator
     * terminates the sequence or it gets canceled
     * @return the new Flowable instance
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T, S&gt; Flowable&lt;T&gt; generate(Callable&lt;S&gt; initialState, BiFunction&lt;S, Emitter&lt;T&gt;, S&gt; generator, Consumer&lt;? super S&gt; disposeState) {
<span class="fc" id="L2404">        ObjectHelper.requireNonNull(initialState, &quot;initialState is null&quot;);</span>
<span class="fc" id="L2405">        ObjectHelper.requireNonNull(generator, &quot;generator is null&quot;);</span>
<span class="fc" id="L2406">        ObjectHelper.requireNonNull(disposeState, &quot;disposeState is null&quot;);</span>
<span class="fc" id="L2407">        return RxJavaPlugins.onAssembly(new FlowableGenerate&lt;T, S&gt;(initialState, generator, disposeState));</span>
    }

    /**
     * Returns a Flowable that emits a {@code 0L} after the {@code initialDelay} and ever-increasing numbers
     * after each {@code period} of time thereafter.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;200&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/timer.p.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator generates values based on time and ignores downstream backpressure which
     *  may lead to {@code MissingBackpressureException} at some point in the chain.
     *  Consumers should consider applying one of the {@code onBackpressureXXX} operators as well.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code interval} operates by default on the {@code computation} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param initialDelay
     *            the initial delay time to wait before emitting the first value of 0L
     * @param period
     *            the period of time between emissions of the subsequent numbers
     * @param unit
     *            the time unit for both {@code initialDelay} and {@code period}
     * @return a Flowable that emits a 0L after the {@code initialDelay} and ever-increasing numbers after
     *         each {@code period} of time thereafter
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/interval.html&quot;&gt;ReactiveX operators documentation: Interval&lt;/a&gt;
     * @since 1.0.12
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.COMPUTATION)
    public static Flowable&lt;Long&gt; interval(long initialDelay, long period, TimeUnit unit) {
<span class="fc" id="L2439">        return interval(initialDelay, period, unit, Schedulers.computation());</span>
    }

    /**
     * Returns a Flowable that emits a {@code 0L} after the {@code initialDelay} and ever-increasing numbers
     * after each {@code period} of time thereafter, on a specified {@link Scheduler}.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;200&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/timer.ps.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator generates values based on time and ignores downstream backpressure which
     *  may lead to {@code MissingBackpressureException} at some point in the chain.
     *  Consumers should consider applying one of the {@code onBackpressureXXX} operators as well.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;You specify which {@link Scheduler} this operator will use.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param initialDelay
     *            the initial delay time to wait before emitting the first value of 0L
     * @param period
     *            the period of time between emissions of the subsequent numbers
     * @param unit
     *            the time unit for both {@code initialDelay} and {@code period}
     * @param scheduler
     *            the Scheduler on which the waiting happens and items are emitted
     * @return a Flowable that emits a 0L after the {@code initialDelay} and ever-increasing numbers after
     *         each {@code period} of time thereafter, while running on the given Scheduler
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/interval.html&quot;&gt;ReactiveX operators documentation: Interval&lt;/a&gt;
     * @since 1.0.12
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public static Flowable&lt;Long&gt; interval(long initialDelay, long period, TimeUnit unit, Scheduler scheduler) {
<span class="fc" id="L2474">        ObjectHelper.requireNonNull(unit, &quot;unit is null&quot;);</span>
<span class="fc" id="L2475">        ObjectHelper.requireNonNull(scheduler, &quot;scheduler is null&quot;);</span>
<span class="fc" id="L2476">        return RxJavaPlugins.onAssembly(new FlowableInterval(Math.max(0L, initialDelay), Math.max(0L, period), unit, scheduler));</span>
    }

    /**
     * Returns a Flowable that emits a sequential number every specified interval of time.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;195&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/interval.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator signals a {@code MissingBackpressureException} if the downstream
     *  is not ready to receive the next value.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code interval} operates by default on the {@code computation} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param period
     *            the period size in time units (see below)
     * @param unit
     *            time units to use for the interval size
     * @return a Flowable that emits a sequential number each time interval
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/interval.html&quot;&gt;ReactiveX operators documentation: Interval&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.COMPUTATION)
    public static Flowable&lt;Long&gt; interval(long period, TimeUnit unit) {
<span class="fc" id="L2502">        return interval(period, period, unit, Schedulers.computation());</span>
    }

    /**
     * Returns a Flowable that emits a sequential number every specified interval of time, on a
     * specified Scheduler.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;200&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/interval.s.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator generates values based on time and ignores downstream backpressure which
     *  may lead to {@code MissingBackpressureException} at some point in the chain.
     *  Consumers should consider applying one of the {@code onBackpressureXXX} operators as well.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;You specify which {@link Scheduler} this operator will use.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param period
     *            the period size in time units (see below)
     * @param unit
     *            time units to use for the interval size
     * @param scheduler
     *            the Scheduler to use for scheduling the items
     * @return a Flowable that emits a sequential number each time interval
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/interval.html&quot;&gt;ReactiveX operators documentation: Interval&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public static Flowable&lt;Long&gt; interval(long period, TimeUnit unit, Scheduler scheduler) {
<span class="fc" id="L2532">        return interval(period, period, unit, scheduler);</span>
    }

    /**
     * Signals a range of long values, the first after some initial delay and the rest periodically after.
     * &lt;p&gt;
     * The sequence completes immediately after the last value (start + count - 1) has been reached.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator signals a {@code MissingBackpressureException} if the downstream can't keep up.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code intervalRange} by default operates on the {@link Schedulers#computation() computation} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param start that start value of the range
     * @param count the number of values to emit in total, if zero, the operator emits an onComplete after the initial delay.
     * @param initialDelay the initial delay before signaling the first value (the start)
     * @param period the period between subsequent values
     * @param unit the unit of measure of the initialDelay and period amounts
     * @return the new Flowable instance
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.COMPUTATION)
    public static Flowable&lt;Long&gt; intervalRange(long start, long count, long initialDelay, long period, TimeUnit unit) {
<span class="fc" id="L2556">        return intervalRange(start, count, initialDelay, period, unit, Schedulers.computation());</span>
    }

    /**
     * Signals a range of long values, the first after some initial delay and the rest periodically after.
     * &lt;p&gt;
     * The sequence completes immediately after the last value (start + count - 1) has been reached.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator signals a {@code MissingBackpressureException} if the downstream can't keep up.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;you provide the {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param start that start value of the range
     * @param count the number of values to emit in total, if zero, the operator emits an onComplete after the initial delay.
     * @param initialDelay the initial delay before signaling the first value (the start)
     * @param period the period between subsequent values
     * @param unit the unit of measure of the initialDelay and period amounts
     * @param scheduler the target scheduler where the values and terminal signals will be emitted
     * @return the new Flowable instance
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public static Flowable&lt;Long&gt; intervalRange(long start, long count, long initialDelay, long period, TimeUnit unit, Scheduler scheduler) {
<span class="fc bfc" id="L2582" title="All 2 branches covered.">        if (count &lt; 0L) {</span>
<span class="fc" id="L2583">            throw new IllegalArgumentException(&quot;count &gt;= 0 required but it was &quot; + count);</span>
        }
<span class="fc bfc" id="L2585" title="All 2 branches covered.">        if (count == 0L) {</span>
<span class="fc" id="L2586">            return Flowable.&lt;Long&gt;empty().delay(initialDelay, unit, scheduler);</span>
        }

<span class="fc" id="L2589">        long end = start + (count - 1);</span>
<span class="fc bfc" id="L2590" title="All 4 branches covered.">        if (start &gt; 0 &amp;&amp; end &lt; 0) {</span>
<span class="fc" id="L2591">            throw new IllegalArgumentException(&quot;Overflow! start + count is bigger than Long.MAX_VALUE&quot;);</span>
        }
<span class="fc" id="L2593">        ObjectHelper.requireNonNull(unit, &quot;unit is null&quot;);</span>
<span class="fc" id="L2594">        ObjectHelper.requireNonNull(scheduler, &quot;scheduler is null&quot;);</span>

<span class="fc" id="L2596">        return RxJavaPlugins.onAssembly(new FlowableIntervalRange(start, end, Math.max(0L, initialDelay), Math.max(0L, period), unit, scheduler));</span>
    }

    /**
     * Returns a Flowable that signals the given (constant reference) item and then completes.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * Note that the item is taken and re-emitted as is and not computed by any means by {@code just}. Use {@link #fromCallable(Callable)}
     * to generate a single item on demand (when {@code Subscriber}s subscribe to it).
     * &lt;p&gt;
     * See the multi-parameter overloads of {@code just} to emit more than one (constant reference) items one after the other.
     * Use {@link #fromArray(Object...)} to emit an arbitrary number of items that are known upfront.
     * &lt;p&gt;
     * To emit the items of an {@link Iterable} sequence (such as a {@link java.util.List}), use {@link #fromIterable(Iterable)}.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code just} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param item
     *            the item to emit
     * @param &lt;T&gt;
     *            the type of that item
     * @return a Flowable that emits {@code value} as a single item and then completes
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/just.html&quot;&gt;ReactiveX operators documentation: Just&lt;/a&gt;
     * @see #just(Object, Object)
     * @see #fromCallable(Callable)
     * @see #fromArray(Object...)
     * @see #fromIterable(Iterable)
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Flowable&lt;T&gt; just(T item) {
<span class="fc" id="L2634">        ObjectHelper.requireNonNull(item, &quot;item is null&quot;);</span>
<span class="fc" id="L2635">        return RxJavaPlugins.onAssembly(new FlowableJust&lt;T&gt;(item));</span>
    }

    /**
     * Converts two items into a Publisher that emits those items.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;315&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.m.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream and signals each value on-demand (i.e., when requested).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code just} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param item1
     *            first item
     * @param item2
     *            second item
     * @param &lt;T&gt;
     *            the type of these items
     * @return a Flowable that emits each item
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/just.html&quot;&gt;ReactiveX operators documentation: Just&lt;/a&gt;
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Flowable&lt;T&gt; just(T item1, T item2) {
<span class="fc" id="L2664">        ObjectHelper.requireNonNull(item1, &quot;item1 is null&quot;);</span>
<span class="fc" id="L2665">        ObjectHelper.requireNonNull(item2, &quot;item2 is null&quot;);</span>

<span class="fc" id="L2667">        return fromArray(item1, item2);</span>
    }

    /**
     * Converts three items into a Publisher that emits those items.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;315&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.m.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream and signals each value on-demand (i.e., when requested).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code just} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param item1
     *            first item
     * @param item2
     *            second item
     * @param item3
     *            third item
     * @param &lt;T&gt;
     *            the type of these items
     * @return a Flowable that emits each item
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/just.html&quot;&gt;ReactiveX operators documentation: Just&lt;/a&gt;
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Flowable&lt;T&gt; just(T item1, T item2, T item3) {
<span class="fc" id="L2698">        ObjectHelper.requireNonNull(item1, &quot;item1 is null&quot;);</span>
<span class="fc" id="L2699">        ObjectHelper.requireNonNull(item2, &quot;item2 is null&quot;);</span>
<span class="fc" id="L2700">        ObjectHelper.requireNonNull(item3, &quot;item3 is null&quot;);</span>

<span class="fc" id="L2702">        return fromArray(item1, item2, item3);</span>
    }

    /**
     * Converts four items into a Publisher that emits those items.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;315&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.m.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream and signals each value on-demand (i.e., when requested).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code just} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param item1
     *            first item
     * @param item2
     *            second item
     * @param item3
     *            third item
     * @param item4
     *            fourth item
     * @param &lt;T&gt;
     *            the type of these items
     * @return a Flowable that emits each item
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/just.html&quot;&gt;ReactiveX operators documentation: Just&lt;/a&gt;
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Flowable&lt;T&gt; just(T item1, T item2, T item3, T item4) {
<span class="fc" id="L2735">        ObjectHelper.requireNonNull(item1, &quot;item1 is null&quot;);</span>
<span class="fc" id="L2736">        ObjectHelper.requireNonNull(item2, &quot;item2 is null&quot;);</span>
<span class="fc" id="L2737">        ObjectHelper.requireNonNull(item3, &quot;item3 is null&quot;);</span>
<span class="fc" id="L2738">        ObjectHelper.requireNonNull(item4, &quot;item4 is null&quot;);</span>

<span class="fc" id="L2740">        return fromArray(item1, item2, item3, item4);</span>
    }

    /**
     * Converts five items into a Publisher that emits those items.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;315&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.m.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream and signals each value on-demand (i.e., when requested).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code just} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param item1
     *            first item
     * @param item2
     *            second item
     * @param item3
     *            third item
     * @param item4
     *            fourth item
     * @param item5
     *            fifth item
     * @param &lt;T&gt;
     *            the type of these items
     * @return a Flowable that emits each item
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/just.html&quot;&gt;ReactiveX operators documentation: Just&lt;/a&gt;
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Flowable&lt;T&gt; just(T item1, T item2, T item3, T item4, T item5) {
<span class="fc" id="L2775">        ObjectHelper.requireNonNull(item1, &quot;item1 is null&quot;);</span>
<span class="fc" id="L2776">        ObjectHelper.requireNonNull(item2, &quot;item2 is null&quot;);</span>
<span class="fc" id="L2777">        ObjectHelper.requireNonNull(item3, &quot;item3 is null&quot;);</span>
<span class="fc" id="L2778">        ObjectHelper.requireNonNull(item4, &quot;item4 is null&quot;);</span>
<span class="fc" id="L2779">        ObjectHelper.requireNonNull(item5, &quot;item5 is null&quot;);</span>

<span class="fc" id="L2781">        return fromArray(item1, item2, item3, item4, item5);</span>
    }

    /**
     * Converts six items into a Publisher that emits those items.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;315&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.m.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream and signals each value on-demand (i.e., when requested).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code just} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param item1
     *            first item
     * @param item2
     *            second item
     * @param item3
     *            third item
     * @param item4
     *            fourth item
     * @param item5
     *            fifth item
     * @param item6
     *            sixth item
     * @param &lt;T&gt;
     *            the type of these items
     * @return a Flowable that emits each item
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/just.html&quot;&gt;ReactiveX operators documentation: Just&lt;/a&gt;
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Flowable&lt;T&gt; just(T item1, T item2, T item3, T item4, T item5, T item6) {
<span class="fc" id="L2818">        ObjectHelper.requireNonNull(item1, &quot;item1 is null&quot;);</span>
<span class="fc" id="L2819">        ObjectHelper.requireNonNull(item2, &quot;item2 is null&quot;);</span>
<span class="fc" id="L2820">        ObjectHelper.requireNonNull(item3, &quot;item3 is null&quot;);</span>
<span class="fc" id="L2821">        ObjectHelper.requireNonNull(item4, &quot;item4 is null&quot;);</span>
<span class="fc" id="L2822">        ObjectHelper.requireNonNull(item5, &quot;item5 is null&quot;);</span>
<span class="fc" id="L2823">        ObjectHelper.requireNonNull(item6, &quot;item6 is null&quot;);</span>

<span class="fc" id="L2825">        return fromArray(item1, item2, item3, item4, item5, item6);</span>
    }

    /**
     * Converts seven items into a Publisher that emits those items.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;315&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.m.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream and signals each value on-demand (i.e., when requested).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code just} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param item1
     *            first item
     * @param item2
     *            second item
     * @param item3
     *            third item
     * @param item4
     *            fourth item
     * @param item5
     *            fifth item
     * @param item6
     *            sixth item
     * @param item7
     *            seventh item
     * @param &lt;T&gt;
     *            the type of these items
     * @return a Flowable that emits each item
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/just.html&quot;&gt;ReactiveX operators documentation: Just&lt;/a&gt;
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Flowable&lt;T&gt; just(T item1, T item2, T item3, T item4, T item5, T item6, T item7) {
<span class="fc" id="L2864">        ObjectHelper.requireNonNull(item1, &quot;item1 is null&quot;);</span>
<span class="fc" id="L2865">        ObjectHelper.requireNonNull(item2, &quot;item2 is null&quot;);</span>
<span class="fc" id="L2866">        ObjectHelper.requireNonNull(item3, &quot;item3 is null&quot;);</span>
<span class="fc" id="L2867">        ObjectHelper.requireNonNull(item4, &quot;item4 is null&quot;);</span>
<span class="fc" id="L2868">        ObjectHelper.requireNonNull(item5, &quot;item5 is null&quot;);</span>
<span class="fc" id="L2869">        ObjectHelper.requireNonNull(item6, &quot;item6 is null&quot;);</span>
<span class="fc" id="L2870">        ObjectHelper.requireNonNull(item7, &quot;item7 is null&quot;);</span>

<span class="fc" id="L2872">        return fromArray(item1, item2, item3, item4, item5, item6, item7);</span>
    }

    /**
     * Converts eight items into a Publisher that emits those items.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;315&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.m.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream and signals each value on-demand (i.e., when requested).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code just} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param item1
     *            first item
     * @param item2
     *            second item
     * @param item3
     *            third item
     * @param item4
     *            fourth item
     * @param item5
     *            fifth item
     * @param item6
     *            sixth item
     * @param item7
     *            seventh item
     * @param item8
     *            eighth item
     * @param &lt;T&gt;
     *            the type of these items
     * @return a Flowable that emits each item
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/just.html&quot;&gt;ReactiveX operators documentation: Just&lt;/a&gt;
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Flowable&lt;T&gt; just(T item1, T item2, T item3, T item4, T item5, T item6, T item7, T item8) {
<span class="fc" id="L2913">        ObjectHelper.requireNonNull(item1, &quot;item1 is null&quot;);</span>
<span class="fc" id="L2914">        ObjectHelper.requireNonNull(item2, &quot;item2 is null&quot;);</span>
<span class="fc" id="L2915">        ObjectHelper.requireNonNull(item3, &quot;item3 is null&quot;);</span>
<span class="fc" id="L2916">        ObjectHelper.requireNonNull(item4, &quot;item4 is null&quot;);</span>
<span class="fc" id="L2917">        ObjectHelper.requireNonNull(item5, &quot;item5 is null&quot;);</span>
<span class="fc" id="L2918">        ObjectHelper.requireNonNull(item6, &quot;item6 is null&quot;);</span>
<span class="fc" id="L2919">        ObjectHelper.requireNonNull(item7, &quot;item7 is null&quot;);</span>
<span class="fc" id="L2920">        ObjectHelper.requireNonNull(item8, &quot;item8 is null&quot;);</span>

<span class="fc" id="L2922">        return fromArray(item1, item2, item3, item4, item5, item6, item7, item8);</span>
    }

    /**
     * Converts nine items into a Publisher that emits those items.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;315&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.m.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream and signals each value on-demand (i.e., when requested).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code just} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param item1
     *            first item
     * @param item2
     *            second item
     * @param item3
     *            third item
     * @param item4
     *            fourth item
     * @param item5
     *            fifth item
     * @param item6
     *            sixth item
     * @param item7
     *            seventh item
     * @param item8
     *            eighth item
     * @param item9
     *            ninth item
     * @param &lt;T&gt;
     *            the type of these items
     * @return a Flowable that emits each item
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/just.html&quot;&gt;ReactiveX operators documentation: Just&lt;/a&gt;
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Flowable&lt;T&gt; just(T item1, T item2, T item3, T item4, T item5, T item6, T item7, T item8, T item9) {
<span class="fc" id="L2965">        ObjectHelper.requireNonNull(item1, &quot;item1 is null&quot;);</span>
<span class="fc" id="L2966">        ObjectHelper.requireNonNull(item2, &quot;item2 is null&quot;);</span>
<span class="fc" id="L2967">        ObjectHelper.requireNonNull(item3, &quot;item3 is null&quot;);</span>
<span class="fc" id="L2968">        ObjectHelper.requireNonNull(item4, &quot;item4 is null&quot;);</span>
<span class="fc" id="L2969">        ObjectHelper.requireNonNull(item5, &quot;item5 is null&quot;);</span>
<span class="fc" id="L2970">        ObjectHelper.requireNonNull(item6, &quot;item6 is null&quot;);</span>
<span class="fc" id="L2971">        ObjectHelper.requireNonNull(item7, &quot;item7 is null&quot;);</span>
<span class="fc" id="L2972">        ObjectHelper.requireNonNull(item8, &quot;item8 is null&quot;);</span>
<span class="fc" id="L2973">        ObjectHelper.requireNonNull(item9, &quot;item9 is null&quot;);</span>

<span class="fc" id="L2975">        return fromArray(item1, item2, item3, item4, item5, item6, item7, item8, item9);</span>
    }

    /**
     * Converts ten items into a Publisher that emits those items.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;315&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.m.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream and signals each value on-demand (i.e., when requested).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code just} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param item1
     *            first item
     * @param item2
     *            second item
     * @param item3
     *            third item
     * @param item4
     *            fourth item
     * @param item5
     *            fifth item
     * @param item6
     *            sixth item
     * @param item7
     *            seventh item
     * @param item8
     *            eighth item
     * @param item9
     *            ninth item
     * @param item10
     *            tenth item
     * @param &lt;T&gt;
     *            the type of these items
     * @return a Flowable that emits each item
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/just.html&quot;&gt;ReactiveX operators documentation: Just&lt;/a&gt;
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Flowable&lt;T&gt; just(T item1, T item2, T item3, T item4, T item5, T item6, T item7, T item8, T item9, T item10) {
<span class="fc" id="L3020">        ObjectHelper.requireNonNull(item1, &quot;item1 is null&quot;);</span>
<span class="fc" id="L3021">        ObjectHelper.requireNonNull(item2, &quot;item2 is null&quot;);</span>
<span class="fc" id="L3022">        ObjectHelper.requireNonNull(item3, &quot;item3 is null&quot;);</span>
<span class="fc" id="L3023">        ObjectHelper.requireNonNull(item4, &quot;item4 is null&quot;);</span>
<span class="fc" id="L3024">        ObjectHelper.requireNonNull(item5, &quot;item5 is null&quot;);</span>
<span class="fc" id="L3025">        ObjectHelper.requireNonNull(item6, &quot;item6 is null&quot;);</span>
<span class="fc" id="L3026">        ObjectHelper.requireNonNull(item7, &quot;item7 is null&quot;);</span>
<span class="fc" id="L3027">        ObjectHelper.requireNonNull(item8, &quot;item8 is null&quot;);</span>
<span class="fc" id="L3028">        ObjectHelper.requireNonNull(item9, &quot;item9 is null&quot;);</span>
<span class="fc" id="L3029">        ObjectHelper.requireNonNull(item10, &quot;item10 is null&quot;);</span>

<span class="fc" id="L3031">        return fromArray(item1, item2, item3, item4, item5, item6, item7, item8, item9, item10);</span>
    }

    /**
     * Flattens an Iterable of Publishers into one Publisher, without any transformation, while limiting the
     * number of concurrent subscriptions to these Publishers.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/merge.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * You can combine the items emitted by multiple Publishers so that they appear as a single Publisher, by
     * using the {@code merge} method.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream. The source {@code Publisher}s are expected to honor
     *  backpressure; if violated, the operator &lt;em&gt;may&lt;/em&gt; signal {@code MissingBackpressureException}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code merge} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Error handling:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;If any of the source {@code Publisher}s signal a {@code Throwable} via {@code onError}, the resulting
     *  {@code Flowable} terminates with that {@code Throwable} and all other source {@code Publisher}s are canceled.
     *  If more than one {@code Publisher} signals an error, the resulting {@code Flowable} may terminate with the
     *  first one's error or, depending on the concurrency of the sources, may terminate with a
     *  {@code CompositeException} containing two or more of the various error signals.
     *  {@code Throwable}s that didn't make into the composite will be sent (individually) to the global error handler via
     *  {@link RxJavaPlugins#onError(Throwable)} method as {@code UndeliverableException} errors. Similarly, {@code Throwable}s
     *  signaled by source(s) after the returned {@code Flowable} has been canceled or terminated with a
     *  (composite) error will be sent to the same global error handler.
     *  Use {@link #mergeDelayError(Iterable, int, int)} to merge sources and terminate only when all source {@code Publisher}s
     *  have completed or failed with an error.
     *  &lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T&gt; the common element base type
     * @param sources
     *            the Iterable of Publishers
     * @param maxConcurrency
     *            the maximum number of Publishers that may be subscribed to concurrently
     * @param bufferSize
     *            the number of items to prefetch from each inner Publisher
     * @return a Flowable that emits items that are the result of flattening the items emitted by the
     *         Publishers in the Iterable
     * @throws IllegalArgumentException
     *             if {@code maxConcurrency} is less than or equal to 0
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/merge.html&quot;&gt;ReactiveX operators documentation: Merge&lt;/a&gt;
     * @see #mergeDelayError(Iterable, int, int)
     */
    @SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Flowable&lt;T&gt; merge(Iterable&lt;? extends Publisher&lt;? extends T&gt;&gt; sources, int maxConcurrency, int bufferSize) {
<span class="fc" id="L3082">        return fromIterable(sources).flatMap((Function)Functions.identity(), false, maxConcurrency, bufferSize);</span>
    }

    /**
     * Flattens an Iterable of Publishers into one Publisher, without any transformation, while limiting the
     * number of concurrent subscriptions to these Publishers.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/merge.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * You can combine the items emitted by multiple Publishers so that they appear as a single Publisher, by
     * using the {@code merge} method.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream. The source {@code Publisher}s are expected to honor
     *  backpressure; if violated, the operator &lt;em&gt;may&lt;/em&gt; signal {@code MissingBackpressureException}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code mergeArray} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Error handling:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;If any of the source {@code Publisher}s signal a {@code Throwable} via {@code onError}, the resulting
     *  {@code Flowable} terminates with that {@code Throwable} and all other source {@code Publisher}s are canceled.
     *  If more than one {@code Publisher} signals an error, the resulting {@code Flowable} may terminate with the
     *  first one's error or, depending on the concurrency of the sources, may terminate with a
     *  {@code CompositeException} containing two or more of the various error signals.
     *  {@code Throwable}s that didn't make into the composite will be sent (individually) to the global error handler via
     *  {@link RxJavaPlugins#onError(Throwable)} method as {@code UndeliverableException} errors. Similarly, {@code Throwable}s
     *  signaled by source(s) after the returned {@code Flowable} has been canceled or terminated with a
     *  (composite) error will be sent to the same global error handler.
     *  Use {@link #mergeArrayDelayError(int, int, Publisher[])} to merge sources and terminate only when all source {@code Publisher}s
     *  have completed or failed with an error.
     *  &lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T&gt; the common element base type
     * @param sources
     *            the array of Publishers
     * @param maxConcurrency
     *            the maximum number of Publishers that may be subscribed to concurrently
     * @param bufferSize
     *            the number of items to prefetch from each inner Publisher
     * @return a Flowable that emits items that are the result of flattening the items emitted by the
     *         Publishers in the Iterable
     * @throws IllegalArgumentException
     *             if {@code maxConcurrency} is less than or equal to 0
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/merge.html&quot;&gt;ReactiveX operators documentation: Merge&lt;/a&gt;
     * @see #mergeArrayDelayError(int, int, Publisher...)
     */
    @SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Flowable&lt;T&gt; mergeArray(int maxConcurrency, int bufferSize, Publisher&lt;? extends T&gt;... sources) {
<span class="fc" id="L3133">        return fromArray(sources).flatMap((Function)Functions.identity(), false, maxConcurrency, bufferSize);</span>
    }

    /**
     * Flattens an Iterable of Publishers into one Publisher, without any transformation.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/merge.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * You can combine the items emitted by multiple Publishers so that they appear as a single Publisher, by
     * using the {@code merge} method.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream. The source {@code Publisher}s are expected to honor
     *  backpressure; if violated, the operator &lt;em&gt;may&lt;/em&gt; signal {@code MissingBackpressureException}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code merge} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Error handling:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;If any of the source {@code Publisher}s signal a {@code Throwable} via {@code onError}, the resulting
     *  {@code Flowable} terminates with that {@code Throwable} and all other source {@code Publisher}s are canceled.
     *  If more than one {@code Publisher} signals an error, the resulting {@code Flowable} may terminate with the
     *  first one's error or, depending on the concurrency of the sources, may terminate with a
     *  {@code CompositeException} containing two or more of the various error signals.
     *  {@code Throwable}s that didn't make into the composite will be sent (individually) to the global error handler via
     *  {@link RxJavaPlugins#onError(Throwable)} method as {@code UndeliverableException} errors. Similarly, {@code Throwable}s
     *  signaled by source(s) after the returned {@code Flowable} has been canceled or terminated with a
     *  (composite) error will be sent to the same global error handler.
     *  Use {@link #mergeDelayError(Iterable)} to merge sources and terminate only when all source {@code Publisher}s
     *  have completed or failed with an error.
     *  &lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T&gt; the common element base type
     * @param sources
     *            the Iterable of Publishers
     * @return a Flowable that emits items that are the result of flattening the items emitted by the
     *         Publishers in the Iterable
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/merge.html&quot;&gt;ReactiveX operators documentation: Merge&lt;/a&gt;
     * @see #mergeDelayError(Iterable)
     */
    @SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Flowable&lt;T&gt; merge(Iterable&lt;? extends Publisher&lt;? extends T&gt;&gt; sources) {
<span class="fc" id="L3177">        return fromIterable(sources).flatMap((Function)Functions.identity());</span>
    }

    /**
     * Flattens an Iterable of Publishers into one Publisher, without any transformation, while limiting the
     * number of concurrent subscriptions to these Publishers.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/merge.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * You can combine the items emitted by multiple Publishers so that they appear as a single Publisher, by
     * using the {@code merge} method.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream. The source {@code Publisher}s are expected to honor
     *  backpressure; if violated, the operator &lt;em&gt;may&lt;/em&gt; signal {@code MissingBackpressureException}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code merge} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Error handling:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;If any of the source {@code Publisher}s signal a {@code Throwable} via {@code onError}, the resulting
     *  {@code Flowable} terminates with that {@code Throwable} and all other source {@code Publisher}s are canceled.
     *  If more than one {@code Publisher} signals an error, the resulting {@code Flowable} may terminate with the
     *  first one's error or, depending on the concurrency of the sources, may terminate with a
     *  {@code CompositeException} containing two or more of the various error signals.
     *  {@code Throwable}s that didn't make into the composite will be sent (individually) to the global error handler via
     *  {@link RxJavaPlugins#onError(Throwable)} method as {@code UndeliverableException} errors. Similarly, {@code Throwable}s
     *  signaled by source(s) after the returned {@code Flowable} has been canceled or terminated with a
     *  (composite) error will be sent to the same global error handler.
     *  Use {@link #mergeDelayError(Iterable, int)} to merge sources and terminate only when all source {@code Publisher}s
     *  have completed or failed with an error.
     *  &lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T&gt; the common element base type
     * @param sources
     *            the Iterable of Publishers
     * @param maxConcurrency
     *            the maximum number of Publishers that may be subscribed to concurrently
     * @return a Flowable that emits items that are the result of flattening the items emitted by the
     *         Publishers in the Iterable
     * @throws IllegalArgumentException
     *             if {@code maxConcurrency} is less than or equal to 0
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/merge.html&quot;&gt;ReactiveX operators documentation: Merge&lt;/a&gt;
     * @see #mergeDelayError(Iterable, int)
     */
    @SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Flowable&lt;T&gt; merge(Iterable&lt;? extends Publisher&lt;? extends T&gt;&gt; sources, int maxConcurrency) {
<span class="fc" id="L3226">        return fromIterable(sources).flatMap((Function)Functions.identity(), maxConcurrency);</span>
    }

    /**
     * Flattens a Publisher that emits Publishers into a single Publisher that emits the items emitted by
     * those Publishers, without any transformation.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;370&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/merge.oo.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * You can combine the items emitted by multiple Publishers so that they appear as a single Publisher, by
     * using the {@code merge} method.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream. The outer {@code Publisher} is consumed
     *  in unbounded mode (i.e., no backpressure is applied to it). The inner {@code Publisher}s are expected to honor
     *  backpressure; if violated, the operator &lt;em&gt;may&lt;/em&gt; signal {@code MissingBackpressureException}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code merge} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Error handling:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;If any of the source {@code Publisher}s signal a {@code Throwable} via {@code onError}, the resulting
     *  {@code Flowable} terminates with that {@code Throwable} and all other source {@code Publisher}s are canceled.
     *  If more than one {@code Publisher} signals an error, the resulting {@code Flowable} may terminate with the
     *  first one's error or, depending on the concurrency of the sources, may terminate with a
     *  {@code CompositeException} containing two or more of the various error signals.
     *  {@code Throwable}s that didn't make into the composite will be sent (individually) to the global error handler via
     *  {@link RxJavaPlugins#onError(Throwable)} method as {@code UndeliverableException} errors. Similarly, {@code Throwable}s
     *  signaled by source(s) after the returned {@code Flowable} has been canceled or terminated with a
     *  (composite) error will be sent to the same global error handler.
     *  Use {@link #mergeDelayError(Publisher)} to merge sources and terminate only when all source {@code Publisher}s
     *  have completed or failed with an error.
     *  &lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T&gt; the common element base type
     * @param sources
     *            a Publisher that emits Publishers
     * @return a Flowable that emits items that are the result of flattening the Publishers emitted by the
     *         {@code source} Publisher
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/merge.html&quot;&gt;ReactiveX operators documentation: Merge&lt;/a&gt;
     * @see #mergeDelayError(Publisher)
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Flowable&lt;T&gt; merge(Publisher&lt;? extends Publisher&lt;? extends T&gt;&gt; sources) {
<span class="fc" id="L3271">        return merge(sources, bufferSize());</span>
    }

    /**
     * Flattens a Publisher that emits Publishers into a single Publisher that emits the items emitted by
     * those Publishers, without any transformation, while limiting the maximum number of concurrent
     * subscriptions to these Publishers.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;370&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/merge.oo.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * You can combine the items emitted by multiple Publishers so that they appear as a single Publisher, by
     * using the {@code merge} method.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream. Both the outer and inner {@code Publisher}s are expected to honor
     *  backpressure; if violated, the operator &lt;em&gt;may&lt;/em&gt; signal {@code MissingBackpressureException}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code merge} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Error handling:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;If any of the source {@code Publisher}s signal a {@code Throwable} via {@code onError}, the resulting
     *  {@code Flowable} terminates with that {@code Throwable} and all other source {@code Publisher}s are canceled.
     *  If more than one {@code Publisher} signals an error, the resulting {@code Flowable} may terminate with the
     *  first one's error or, depending on the concurrency of the sources, may terminate with a
     *  {@code CompositeException} containing two or more of the various error signals.
     *  {@code Throwable}s that didn't make into the composite will be sent (individually) to the global error handler via
     *  {@link RxJavaPlugins#onError(Throwable)} method as {@code UndeliverableException} errors. Similarly, {@code Throwable}s
     *  signaled by source(s) after the returned {@code Flowable} has been canceled or terminated with a
     *  (composite) error will be sent to the same global error handler.
     *  Use {@link #mergeDelayError(Publisher, int)} to merge sources and terminate only when all source {@code Publisher}s
     *  have completed or failed with an error.
     *  &lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T&gt; the common element base type
     * @param sources
     *            a Publisher that emits Publishers
     * @param maxConcurrency
     *            the maximum number of Publishers that may be subscribed to concurrently
     * @return a Flowable that emits items that are the result of flattening the Publishers emitted by the
     *         {@code source} Publisher
     * @throws IllegalArgumentException
     *             if {@code maxConcurrency} is less than or equal to 0
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/merge.html&quot;&gt;ReactiveX operators documentation: Merge&lt;/a&gt;
     * @see #mergeDelayError(Publisher, int)
     * @since 1.1.0
     */
    @SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Flowable&lt;T&gt; merge(Publisher&lt;? extends Publisher&lt;? extends T&gt;&gt; sources, int maxConcurrency) {
<span class="fc" id="L3322">        return fromPublisher(sources).flatMap((Function)Functions.identity(), maxConcurrency);</span>
    }

    /**
     * Flattens an Array of Publishers into one Publisher, without any transformation.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;370&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/merge.io.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * You can combine items emitted by multiple Publishers so that they appear as a single Publisher, by
     * using the {@code merge} method.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream. The source {@code Publisher}s are expected to honor
     *  backpressure; if violated, the operator &lt;em&gt;may&lt;/em&gt; signal {@code MissingBackpressureException}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code mergeArray} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Error handling:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;If any of the source {@code Publisher}s signal a {@code Throwable} via {@code onError}, the resulting
     *  {@code Flowable} terminates with that {@code Throwable} and all other source {@code Publisher}s are canceled.
     *  If more than one {@code Publisher} signals an error, the resulting {@code Flowable} may terminate with the
     *  first one's error or, depending on the concurrency of the sources, may terminate with a
     *  {@code CompositeException} containing two or more of the various error signals.
     *  {@code Throwable}s that didn't make into the composite will be sent (individually) to the global error handler via
     *  {@link RxJavaPlugins#onError(Throwable)} method as {@code UndeliverableException} errors. Similarly, {@code Throwable}s
     *  signaled by source(s) after the returned {@code Flowable} has been canceled or terminated with a
     *  (composite) error will be sent to the same global error handler.
     *  Use {@link #mergeArrayDelayError(Publisher...)} to merge sources and terminate only when all source {@code Publisher}s
     *  have completed or failed with an error.
     *  &lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T&gt; the common element base type
     * @param sources
     *            the array of Publishers
     * @return a Flowable that emits all of the items emitted by the Publishers in the Array
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/merge.html&quot;&gt;ReactiveX operators documentation: Merge&lt;/a&gt;
     * @see #mergeArrayDelayError(Publisher...)
     */
    @SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Flowable&lt;T&gt; mergeArray(Publisher&lt;? extends T&gt;... sources) {
<span class="fc" id="L3365">        return fromArray(sources).flatMap((Function)Functions.identity(), sources.length);</span>
    }

    /**
     * Flattens two Publishers into a single Publisher, without any transformation.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/merge.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * You can combine items emitted by multiple Publishers so that they appear as a single Publisher, by
     * using the {@code merge} method.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream. The source {@code Publisher}s are expected to honor
     *  backpressure; if violated, the operator &lt;em&gt;may&lt;/em&gt; signal {@code MissingBackpressureException}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code merge} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Error handling:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;If any of the source {@code Publisher}s signal a {@code Throwable} via {@code onError}, the resulting
     *  {@code Flowable} terminates with that {@code Throwable} and all other source {@code Publisher}s are canceled.
     *  If more than one {@code Publisher} signals an error, the resulting {@code Flowable} may terminate with the
     *  first one's error or, depending on the concurrency of the sources, may terminate with a
     *  {@code CompositeException} containing two or more of the various error signals.
     *  {@code Throwable}s that didn't make into the composite will be sent (individually) to the global error handler via
     *  {@link RxJavaPlugins#onError(Throwable)} method as {@code UndeliverableException} errors. Similarly, {@code Throwable}s
     *  signaled by source(s) after the returned {@code Flowable} has been canceled or terminated with a
     *  (composite) error will be sent to the same global error handler.
     *  Use {@link #mergeDelayError(Publisher, Publisher)} to merge sources and terminate only when all source {@code Publisher}s
     *  have completed or failed with an error.
     *  &lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T&gt; the common element base type
     * @param source1
     *            a Publisher to be merged
     * @param source2
     *            a Publisher to be merged
     * @return a Flowable that emits all of the items emitted by the source Publishers
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/merge.html&quot;&gt;ReactiveX operators documentation: Merge&lt;/a&gt;
     * @see #mergeDelayError(Publisher, Publisher)
     */
    @SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Flowable&lt;T&gt; merge(Publisher&lt;? extends T&gt; source1, Publisher&lt;? extends T&gt; source2) {
<span class="fc" id="L3411">        ObjectHelper.requireNonNull(source1, &quot;source1 is null&quot;);</span>
<span class="fc" id="L3412">        ObjectHelper.requireNonNull(source2, &quot;source2 is null&quot;);</span>
<span class="fc" id="L3413">        return fromArray(source1, source2).flatMap((Function)Functions.identity(), false, 2);</span>
    }

    /**
     * Flattens three Publishers into a single Publisher, without any transformation.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/merge.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * You can combine items emitted by multiple Publishers so that they appear as a single Publisher, by
     * using the {@code merge} method.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream. The source {@code Publisher}s are expected to honor
     *  backpressure; if violated, the operator &lt;em&gt;may&lt;/em&gt; signal {@code MissingBackpressureException}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code merge} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Error handling:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;If any of the source {@code Publisher}s signal a {@code Throwable} via {@code onError}, the resulting
     *  {@code Flowable} terminates with that {@code Throwable} and all other source {@code Publisher}s are canceled.
     *  If more than one {@code Publisher} signals an error, the resulting {@code Flowable} may terminate with the
     *  first one's error or, depending on the concurrency of the sources, may terminate with a
     *  {@code CompositeException} containing two or more of the various error signals.
     *  {@code Throwable}s that didn't make into the composite will be sent (individually) to the global error handler via
     *  {@link RxJavaPlugins#onError(Throwable)} method as {@code UndeliverableException} errors. Similarly, {@code Throwable}s
     *  signaled by source(s) after the returned {@code Flowable} has been canceled or terminated with a
     *  (composite) error will be sent to the same global error handler.
     *  Use {@link #mergeDelayError(Publisher, Publisher, Publisher)} to merge sources and terminate only when all source {@code Publisher}s
     *  have completed or failed with an error.
     *  &lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T&gt; the common element base type
     * @param source1
     *            a Publisher to be merged
     * @param source2
     *            a Publisher to be merged
     * @param source3
     *            a Publisher to be merged
     * @return a Flowable that emits all of the items emitted by the source Publishers
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/merge.html&quot;&gt;ReactiveX operators documentation: Merge&lt;/a&gt;
     * @see #mergeDelayError(Publisher, Publisher, Publisher)
     */
    @SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Flowable&lt;T&gt; merge(Publisher&lt;? extends T&gt; source1, Publisher&lt;? extends T&gt; source2, Publisher&lt;? extends T&gt; source3) {
<span class="fc" id="L3461">        ObjectHelper.requireNonNull(source1, &quot;source1 is null&quot;);</span>
<span class="fc" id="L3462">        ObjectHelper.requireNonNull(source2, &quot;source2 is null&quot;);</span>
<span class="fc" id="L3463">        ObjectHelper.requireNonNull(source3, &quot;source3 is null&quot;);</span>
<span class="fc" id="L3464">        return fromArray(source1, source2, source3).flatMap((Function)Functions.identity(), false, 3);</span>
    }

    /**
     * Flattens four Publishers into a single Publisher, without any transformation.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/merge.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * You can combine items emitted by multiple Publishers so that they appear as a single Publisher, by
     * using the {@code merge} method.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream. The source {@code Publisher}s are expected to honor
     *  backpressure; if violated, the operator &lt;em&gt;may&lt;/em&gt; signal {@code MissingBackpressureException}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code merge} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Error handling:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;If any of the source {@code Publisher}s signal a {@code Throwable} via {@code onError}, the resulting
     *  {@code Flowable} terminates with that {@code Throwable} and all other source {@code Publisher}s are canceled.
     *  If more than one {@code Publisher} signals an error, the resulting {@code Flowable} may terminate with the
     *  first one's error or, depending on the concurrency of the sources, may terminate with a
     *  {@code CompositeException} containing two or more of the various error signals.
     *  {@code Throwable}s that didn't make into the composite will be sent (individually) to the global error handler via
     *  {@link RxJavaPlugins#onError(Throwable)} method as {@code UndeliverableException} errors. Similarly, {@code Throwable}s
     *  signaled by source(s) after the returned {@code Flowable} has been canceled or terminated with a
     *  (composite) error will be sent to the same global error handler.
     *  Use {@link #mergeDelayError(Publisher, Publisher, Publisher, Publisher)} to merge sources and terminate only when all source {@code Publisher}s
     *  have completed or failed with an error.
     *  &lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T&gt; the common element base type
     * @param source1
     *            a Publisher to be merged
     * @param source2
     *            a Publisher to be merged
     * @param source3
     *            a Publisher to be merged
     * @param source4
     *            a Publisher to be merged
     * @return a Flowable that emits all of the items emitted by the source Publishers
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/merge.html&quot;&gt;ReactiveX operators documentation: Merge&lt;/a&gt;
     * @see #mergeDelayError(Publisher, Publisher, Publisher, Publisher)
     */
    @SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Flowable&lt;T&gt; merge(
            Publisher&lt;? extends T&gt; source1, Publisher&lt;? extends T&gt; source2,
            Publisher&lt;? extends T&gt; source3, Publisher&lt;? extends T&gt; source4) {
<span class="fc" id="L3516">        ObjectHelper.requireNonNull(source1, &quot;source1 is null&quot;);</span>
<span class="fc" id="L3517">        ObjectHelper.requireNonNull(source2, &quot;source2 is null&quot;);</span>
<span class="fc" id="L3518">        ObjectHelper.requireNonNull(source3, &quot;source3 is null&quot;);</span>
<span class="fc" id="L3519">        ObjectHelper.requireNonNull(source4, &quot;source4 is null&quot;);</span>
<span class="fc" id="L3520">        return fromArray(source1, source2, source3, source4).flatMap((Function)Functions.identity(), false, 4);</span>
    }

    /**
     * Flattens an Iterable of Publishers into one Publisher, in a way that allows a Subscriber to receive all
     * successfully emitted items from each of the source Publishers without being interrupted by an error
     * notification from one of them.
     * &lt;p&gt;
     * This behaves like {@link #merge(Publisher)} except that if any of the merged Publishers notify of an
     * error via {@link Subscriber#onError onError}, {@code mergeDelayError} will refrain from propagating that
     * error notification until all of the merged Publishers have finished emitting items.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/mergeDelayError.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * Even if multiple merged Publishers send {@code onError} notifications, {@code mergeDelayError} will only
     * invoke the {@code onError} method of its Subscribers once.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream. All inner {@code Publisher}s are expected to honor
     *  backpressure; if violated, the operator &lt;em&gt;may&lt;/em&gt; signal {@code MissingBackpressureException}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code mergeDelayError} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T&gt; the common element base type
     * @param sources
     *            the Iterable of Publishers
     * @return a Flowable that emits items that are the result of flattening the items emitted by the
     *         Publishers in the Iterable
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/merge.html&quot;&gt;ReactiveX operators documentation: Merge&lt;/a&gt;
     */
    @SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Flowable&lt;T&gt; mergeDelayError(Iterable&lt;? extends Publisher&lt;? extends T&gt;&gt; sources) {
<span class="fc" id="L3556">        return fromIterable(sources).flatMap((Function)Functions.identity(), true);</span>
    }

    /**
     * Flattens an Iterable of Publishers into one Publisher, in a way that allows a Subscriber to receive all
     * successfully emitted items from each of the source Publishers without being interrupted by an error
     * notification from one of them, while limiting the number of concurrent subscriptions to these Publishers.
     * &lt;p&gt;
     * This behaves like {@link #merge(Publisher)} except that if any of the merged Publishers notify of an
     * error via {@link Subscriber#onError onError}, {@code mergeDelayError} will refrain from propagating that
     * error notification until all of the merged Publishers have finished emitting items.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/mergeDelayError.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * Even if multiple merged Publishers send {@code onError} notifications, {@code mergeDelayError} will only
     * invoke the {@code onError} method of its Subscribers once.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream. All inner {@code Publisher}s are expected to honor
     *  backpressure; if violated, the operator &lt;em&gt;may&lt;/em&gt; signal {@code MissingBackpressureException}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code mergeDelayError} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T&gt; the common element base type
     * @param sources
     *            the Iterable of Publishers
     * @param maxConcurrency
     *            the maximum number of Publishers that may be subscribed to concurrently
     * @param bufferSize
     *            the number of items to prefetch from each inner Publisher
     * @return a Flowable that emits items that are the result of flattening the items emitted by the
     *         Publishers in the Iterable
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/merge.html&quot;&gt;ReactiveX operators documentation: Merge&lt;/a&gt;
     */
    @SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Flowable&lt;T&gt; mergeDelayError(Iterable&lt;? extends Publisher&lt;? extends T&gt;&gt; sources, int maxConcurrency, int bufferSize) {
<span class="fc" id="L3596">        return fromIterable(sources).flatMap((Function)Functions.identity(), true, maxConcurrency, bufferSize);</span>
    }

    /**
     * Flattens an array of Publishers into one Publisher, in a way that allows a Subscriber to receive all
     * successfully emitted items from each of the source Publishers without being interrupted by an error
     * notification from one of them, while limiting the number of concurrent subscriptions to these Publishers.
     * &lt;p&gt;
     * This behaves like {@link #merge(Publisher)} except that if any of the merged Publishers notify of an
     * error via {@link Subscriber#onError onError}, {@code mergeDelayError} will refrain from propagating that
     * error notification until all of the merged Publishers have finished emitting items.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/mergeDelayError.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * Even if multiple merged Publishers send {@code onError} notifications, {@code mergeDelayError} will only
     * invoke the {@code onError} method of its Subscribers once.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream. All source {@code Publisher}s are expected to honor
     *  backpressure; if violated, the operator &lt;em&gt;may&lt;/em&gt; signal {@code MissingBackpressureException}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code mergeArrayDelayError} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T&gt; the common element base type
     * @param sources
     *            the array of Publishers
     * @param maxConcurrency
     *            the maximum number of Publishers that may be subscribed to concurrently
     * @param bufferSize
     *            the number of items to prefetch from each inner Publisher
     * @return a Flowable that emits items that are the result of flattening the items emitted by the
     *         Publishers in the Iterable
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/merge.html&quot;&gt;ReactiveX operators documentation: Merge&lt;/a&gt;
     */
    @SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Flowable&lt;T&gt; mergeArrayDelayError(int maxConcurrency, int bufferSize, Publisher&lt;? extends T&gt;... sources) {
<span class="fc" id="L3636">        return fromArray(sources).flatMap((Function)Functions.identity(), true, maxConcurrency, bufferSize);</span>
    }

    /**
     * Flattens an Iterable of Publishers into one Publisher, in a way that allows a Subscriber to receive all
     * successfully emitted items from each of the source Publishers without being interrupted by an error
     * notification from one of them, while limiting the number of concurrent subscriptions to these Publishers.
     * &lt;p&gt;
     * This behaves like {@link #merge(Publisher)} except that if any of the merged Publishers notify of an
     * error via {@link Subscriber#onError onError}, {@code mergeDelayError} will refrain from propagating that
     * error notification until all of the merged Publishers have finished emitting items.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/mergeDelayError.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * Even if multiple merged Publishers send {@code onError} notifications, {@code mergeDelayError} will only
     * invoke the {@code onError} method of its Subscribers once.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream. All inner {@code Publisher}s are expected to honor
     *  backpressure; if violated, the operator &lt;em&gt;may&lt;/em&gt; signal {@code MissingBackpressureException}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code mergeDelayError} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T&gt; the common element base type
     * @param sources
     *            the Iterable of Publishers
     * @param maxConcurrency
     *            the maximum number of Publishers that may be subscribed to concurrently
     * @return a Flowable that emits items that are the result of flattening the items emitted by the
     *         Publishers in the Iterable
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/merge.html&quot;&gt;ReactiveX operators documentation: Merge&lt;/a&gt;
     */
    @SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Flowable&lt;T&gt; mergeDelayError(Iterable&lt;? extends Publisher&lt;? extends T&gt;&gt; sources, int maxConcurrency) {
<span class="fc" id="L3674">        return fromIterable(sources).flatMap((Function)Functions.identity(), true, maxConcurrency);</span>
    }

    /**
     * Flattens a Publisher that emits Publishers into one Publisher, in a way that allows a Subscriber to
     * receive all successfully emitted items from all of the source Publishers without being interrupted by
     * an error notification from one of them.
     * &lt;p&gt;
     * This behaves like {@link #merge(Publisher)} except that if any of the merged Publishers notify of an
     * error via {@link Subscriber#onError onError}, {@code mergeDelayError} will refrain from propagating that
     * error notification until all of the merged Publishers have finished emitting items.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/mergeDelayError.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * Even if multiple merged Publishers send {@code onError} notifications, {@code mergeDelayError} will only
     * invoke the {@code onError} method of its Subscribers once.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream. The outer {@code Publisher} is consumed
     *  in unbounded mode (i.e., no backpressure is applied to it). The inner {@code Publisher}s are expected to honor
     *  backpressure; if violated, the operator &lt;em&gt;may&lt;/em&gt; signal {@code MissingBackpressureException}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code mergeDelayError} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T&gt; the common element base type
     * @param sources
     *            a Publisher that emits Publishers
     * @return a Flowable that emits all of the items emitted by the Publishers emitted by the
     *         {@code source} Publisher
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/merge.html&quot;&gt;ReactiveX operators documentation: Merge&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Flowable&lt;T&gt; mergeDelayError(Publisher&lt;? extends Publisher&lt;? extends T&gt;&gt; sources) {
<span class="fc" id="L3710">        return mergeDelayError(sources, bufferSize());</span>
    }

    /**
     * Flattens a Publisher that emits Publishers into one Publisher, in a way that allows a Subscriber to
     * receive all successfully emitted items from all of the source Publishers without being interrupted by
     * an error notification from one of them, while limiting the
     * number of concurrent subscriptions to these Publishers.
     * &lt;p&gt;
     * This behaves like {@link #merge(Publisher)} except that if any of the merged Publishers notify of an
     * error via {@link Subscriber#onError onError}, {@code mergeDelayError} will refrain from propagating that
     * error notification until all of the merged Publishers have finished emitting items.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/mergeDelayError.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * Even if multiple merged Publishers send {@code onError} notifications, {@code mergeDelayError} will only
     * invoke the {@code onError} method of its Subscribers once.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream. Both the outer and inner {@code Publisher}s are expected to honor
     *  backpressure; if violated, the operator &lt;em&gt;may&lt;/em&gt; signal {@code MissingBackpressureException}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code mergeDelayError} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T&gt; the common element base type
     * @param sources
     *            a Publisher that emits Publishers
     * @param maxConcurrency
     *            the maximum number of Publishers that may be subscribed to concurrently
     * @return a Flowable that emits all of the items emitted by the Publishers emitted by the
     *         {@code source} Publisher
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/merge.html&quot;&gt;ReactiveX operators documentation: Merge&lt;/a&gt;
     * @since 2.0
     */
    @SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Flowable&lt;T&gt; mergeDelayError(Publisher&lt;? extends Publisher&lt;? extends T&gt;&gt; sources, int maxConcurrency) {
<span class="fc" id="L3750">        return fromPublisher(sources).flatMap((Function)Functions.identity(), true, maxConcurrency);</span>
    }

    /**
     * Flattens an array of Publishers into one Flowable, in a way that allows a Subscriber to receive all
     * successfully emitted items from each of the source Publishers without being interrupted by an error
     * notification from one of them.
     * &lt;p&gt;
     * This behaves like {@link #merge(Publisher)} except that if any of the merged Publishers notify of an
     * error via {@link Subscriber#onError onError}, {@code mergeDelayError} will refrain from propagating that
     * error notification until all of the merged Publishers have finished emitting items.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/mergeDelayError.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * Even if multiple merged Publishers send {@code onError} notifications, {@code mergeDelayError} will only
     * invoke the {@code onError} method of its Subscribers once.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream. Both the outer and inner {@code Publisher}s are expected to honor
     *  backpressure; if violated, the operator &lt;em&gt;may&lt;/em&gt; signal {@code MissingBackpressureException}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code mergeArrayDelayError} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T&gt; the common element base type
     * @param sources
     *            the Iterable of Publishers
     * @return a Flowable that emits items that are the result of flattening the items emitted by the
     *         Publishers in the Iterable
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/merge.html&quot;&gt;ReactiveX operators documentation: Merge&lt;/a&gt;
     */
    @SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Flowable&lt;T&gt; mergeArrayDelayError(Publisher&lt;? extends T&gt;... sources) {
<span class="fc" id="L3786">        return fromArray(sources).flatMap((Function)Functions.identity(), true, sources.length);</span>
    }

    /**
     * Flattens two Publishers into one Publisher, in a way that allows a Subscriber to receive all
     * successfully emitted items from each of the source Publishers without being interrupted by an error
     * notification from one of them.
     * &lt;p&gt;
     * This behaves like {@link #merge(Publisher, Publisher)} except that if any of the merged Publishers
     * notify of an error via {@link Subscriber#onError onError}, {@code mergeDelayError} will refrain from
     * propagating that error notification until all of the merged Publishers have finished emitting items.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/mergeDelayError.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * Even if both merged Publishers send {@code onError} notifications, {@code mergeDelayError} will only
     * invoke the {@code onError} method of its Subscribers once.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream. The source {@code Publisher}s are expected to honor
     *  backpressure; if violated, the operator &lt;em&gt;may&lt;/em&gt; signal {@code MissingBackpressureException}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code mergeDelayError} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T&gt; the common element base type
     * @param source1
     *            a Publisher to be merged
     * @param source2
     *            a Publisher to be merged
     * @return a Flowable that emits all of the items that are emitted by the two source Publishers
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/merge.html&quot;&gt;ReactiveX operators documentation: Merge&lt;/a&gt;
     */
    @SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Flowable&lt;T&gt; mergeDelayError(Publisher&lt;? extends T&gt; source1, Publisher&lt;? extends T&gt; source2) {
<span class="fc" id="L3824">        ObjectHelper.requireNonNull(source1, &quot;source1 is null&quot;);</span>
<span class="fc" id="L3825">        ObjectHelper.requireNonNull(source2, &quot;source2 is null&quot;);</span>
<span class="fc" id="L3826">        return fromArray(source1, source2).flatMap((Function)Functions.identity(), true, 2);</span>
    }

    /**
     * Flattens three Publishers into one Publisher, in a way that allows a Subscriber to receive all
     * successfully emitted items from all of the source Publishers without being interrupted by an error
     * notification from one of them.
     * &lt;p&gt;
     * This behaves like {@link #merge(Publisher, Publisher, Publisher)} except that if any of the merged
     * Publishers notify of an error via {@link Subscriber#onError onError}, {@code mergeDelayError} will refrain
     * from propagating that error notification until all of the merged Publishers have finished emitting
     * items.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/mergeDelayError.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * Even if multiple merged Publishers send {@code onError} notifications, {@code mergeDelayError} will only
     * invoke the {@code onError} method of its Subscribers once.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream. The source {@code Publisher}s are expected to honor
     *  backpressure; if violated, the operator &lt;em&gt;may&lt;/em&gt; signal {@code MissingBackpressureException}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code mergeDelayError} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T&gt; the common element base type
     * @param source1
     *            a Publisher to be merged
     * @param source2
     *            a Publisher to be merged
     * @param source3
     *            a Publisher to be merged
     * @return a Flowable that emits all of the items that are emitted by the source Publishers
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/merge.html&quot;&gt;ReactiveX operators documentation: Merge&lt;/a&gt;
     */
    @SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Flowable&lt;T&gt; mergeDelayError(Publisher&lt;? extends T&gt; source1, Publisher&lt;? extends T&gt; source2, Publisher&lt;? extends T&gt; source3) {
<span class="fc" id="L3867">        ObjectHelper.requireNonNull(source1, &quot;source1 is null&quot;);</span>
<span class="fc" id="L3868">        ObjectHelper.requireNonNull(source2, &quot;source2 is null&quot;);</span>
<span class="fc" id="L3869">        ObjectHelper.requireNonNull(source3, &quot;source3 is null&quot;);</span>
<span class="fc" id="L3870">        return fromArray(source1, source2, source3).flatMap((Function)Functions.identity(), true, 3);</span>
    }

    /**
     * Flattens four Publishers into one Publisher, in a way that allows a Subscriber to receive all
     * successfully emitted items from all of the source Publishers without being interrupted by an error
     * notification from one of them.
     * &lt;p&gt;
     * This behaves like {@link #merge(Publisher, Publisher, Publisher, Publisher)} except that if any of
     * the merged Publishers notify of an error via {@link Subscriber#onError onError}, {@code mergeDelayError}
     * will refrain from propagating that error notification until all of the merged Publishers have finished
     * emitting items.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/mergeDelayError.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * Even if multiple merged Publishers send {@code onError} notifications, {@code mergeDelayError} will only
     * invoke the {@code onError} method of its Subscribers once.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream. The source {@code Publisher}s are expected to honor
     *  backpressure; if violated, the operator &lt;em&gt;may&lt;/em&gt; signal {@code MissingBackpressureException}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code mergeDelayError} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T&gt; the common element base type
     * @param source1
     *            a Publisher to be merged
     * @param source2
     *            a Publisher to be merged
     * @param source3
     *            a Publisher to be merged
     * @param source4
     *            a Publisher to be merged
     * @return a Flowable that emits all of the items that are emitted by the source Publishers
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/merge.html&quot;&gt;ReactiveX operators documentation: Merge&lt;/a&gt;
     */
    @SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Flowable&lt;T&gt; mergeDelayError(
            Publisher&lt;? extends T&gt; source1, Publisher&lt;? extends T&gt; source2,
            Publisher&lt;? extends T&gt; source3, Publisher&lt;? extends T&gt; source4) {
<span class="fc" id="L3915">        ObjectHelper.requireNonNull(source1, &quot;source1 is null&quot;);</span>
<span class="fc" id="L3916">        ObjectHelper.requireNonNull(source2, &quot;source2 is null&quot;);</span>
<span class="fc" id="L3917">        ObjectHelper.requireNonNull(source3, &quot;source3 is null&quot;);</span>
<span class="fc" id="L3918">        ObjectHelper.requireNonNull(source4, &quot;source4 is null&quot;);</span>
<span class="fc" id="L3919">        return fromArray(source1, source2, source3, source4).flatMap((Function)Functions.identity(), true, 4);</span>
    }

    /**
     * Returns a Flowable that never sends any items or notifications to a {@link Subscriber}.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;185&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/never.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * This Publisher is useful primarily for testing purposes.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This source doesn't produce any elements and effectively ignores downstream backpressure.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code never} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T&gt;
     *            the type of items (not) emitted by the Publisher
     * @return a Flowable that never emits any items or sends any notifications to a {@link Subscriber}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/empty-never-throw.html&quot;&gt;ReactiveX operators documentation: Never&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.NONE)
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; Flowable&lt;T&gt; never() {
<span class="fc" id="L3945">        return RxJavaPlugins.onAssembly((Flowable&lt;T&gt;) FlowableNever.INSTANCE);</span>
    }

    /**
     * Returns a Flowable that emits a sequence of Integers within a specified range.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;195&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/range.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream and signals values on-demand (i.e., when requested).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code range} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param start
     *            the value of the first Integer in the sequence
     * @param count
     *            the number of sequential Integers to generate
     * @return a Flowable that emits a range of sequential Integers
     * @throws IllegalArgumentException
     *             if {@code count} is less than zero, or if {@code start} + {@code count} &amp;minus; 1 exceeds
     *             {@code Integer.MAX_VALUE}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/range.html&quot;&gt;ReactiveX operators documentation: Range&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static Flowable&lt;Integer&gt; range(int start, int count) {
<span class="fc bfc" id="L3973" title="All 2 branches covered.">        if (count &lt; 0) {</span>
<span class="fc" id="L3974">            throw new IllegalArgumentException(&quot;count &gt;= 0 required but it was &quot; + count);</span>
        } else
<span class="fc bfc" id="L3976" title="All 2 branches covered.">        if (count == 0) {</span>
<span class="fc" id="L3977">            return empty();</span>
        } else
<span class="fc bfc" id="L3979" title="All 2 branches covered.">        if (count == 1) {</span>
<span class="fc" id="L3980">            return just(start);</span>
        } else
<span class="fc bfc" id="L3982" title="All 2 branches covered.">        if ((long)start + (count - 1) &gt; Integer.MAX_VALUE) {</span>
<span class="fc" id="L3983">            throw new IllegalArgumentException(&quot;Integer overflow&quot;);</span>
        }
<span class="fc" id="L3985">        return RxJavaPlugins.onAssembly(new FlowableRange(start, count));</span>
    }

    /**
     * Returns a Flowable that emits a sequence of Longs within a specified range.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;195&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/range.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream and signals values on-demand (i.e., when requested).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code rangeLong} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param start
     *            the value of the first Long in the sequence
     * @param count
     *            the number of sequential Longs to generate
     * @return a Flowable that emits a range of sequential Longs
     * @throws IllegalArgumentException
     *             if {@code count} is less than zero, or if {@code start} + {@code count} &amp;minus; 1 exceeds
     *             {@code Long.MAX_VALUE}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/range.html&quot;&gt;ReactiveX operators documentation: Range&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static Flowable&lt;Long&gt; rangeLong(long start, long count) {
<span class="fc bfc" id="L4013" title="All 2 branches covered.">        if (count &lt; 0) {</span>
<span class="fc" id="L4014">            throw new IllegalArgumentException(&quot;count &gt;= 0 required but it was &quot; + count);</span>
        }

<span class="fc bfc" id="L4017" title="All 2 branches covered.">        if (count == 0) {</span>
<span class="fc" id="L4018">            return empty();</span>
        }

<span class="fc bfc" id="L4021" title="All 2 branches covered.">        if (count == 1) {</span>
<span class="fc" id="L4022">            return just(start);</span>
        }

<span class="fc" id="L4025">        long end = start + (count - 1);</span>
<span class="fc bfc" id="L4026" title="All 4 branches covered.">        if (start &gt; 0 &amp;&amp; end &lt; 0) {</span>
<span class="fc" id="L4027">            throw new IllegalArgumentException(&quot;Overflow! start + count is bigger than Long.MAX_VALUE&quot;);</span>
        }

<span class="fc" id="L4030">        return RxJavaPlugins.onAssembly(new FlowableRangeLong(start, count));</span>
    }

    /**
     * Returns a Single that emits a Boolean value that indicates whether two Publisher sequences are the
     * same by comparing the items emitted by each Publisher pairwise.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;385&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/sequenceEqual.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator honors downstream backpressure and expects both of its sources
     *  to honor backpressure as well. If violated, the operator will emit a MissingBackpressureException.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code sequenceEqual} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param source1
     *            the first Publisher to compare
     * @param source2
     *            the second Publisher to compare
     * @param &lt;T&gt;
     *            the type of items emitted by each Publisher
     * @return a Flowable that emits a Boolean value that indicates whether the two sequences are the same
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/sequenceequal.html&quot;&gt;ReactiveX operators documentation: SequenceEqual&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Single&lt;Boolean&gt; sequenceEqual(Publisher&lt;? extends T&gt; source1, Publisher&lt;? extends T&gt; source2) {
<span class="fc" id="L4059">        return sequenceEqual(source1, source2, ObjectHelper.equalsPredicate(), bufferSize());</span>
    }

    /**
     * Returns a Single that emits a Boolean value that indicates whether two Publisher sequences are the
     * same by comparing the items emitted by each Publisher pairwise based on the results of a specified
     * equality function.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;385&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/sequenceEqual.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream. The source {@code Publisher}s are expected to honor
     *  backpressure; if violated, the operator signals a {@code MissingBackpressureException}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code sequenceEqual} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param source1
     *            the first Publisher to compare
     * @param source2
     *            the second Publisher to compare
     * @param isEqual
     *            a function used to compare items emitted by each Publisher
     * @param &lt;T&gt;
     *            the type of items emitted by each Publisher
     * @return a Single that emits a Boolean value that indicates whether the two Publisher sequences
     *         are the same according to the specified function
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/sequenceequal.html&quot;&gt;ReactiveX operators documentation: SequenceEqual&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Single&lt;Boolean&gt; sequenceEqual(Publisher&lt;? extends T&gt; source1, Publisher&lt;? extends T&gt; source2,
            BiPredicate&lt;? super T, ? super T&gt; isEqual) {
<span class="fc" id="L4093">        return sequenceEqual(source1, source2, isEqual, bufferSize());</span>
    }

    /**
     * Returns a Single that emits a Boolean value that indicates whether two Publisher sequences are the
     * same by comparing the items emitted by each Publisher pairwise based on the results of a specified
     * equality function.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;385&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/sequenceEqual.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream. The source {@code Publisher}s are expected to honor
     *  backpressure; if violated, the operator signals a {@code MissingBackpressureException}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code sequenceEqual} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param source1
     *            the first Publisher to compare
     * @param source2
     *            the second Publisher to compare
     * @param isEqual
     *            a function used to compare items emitted by each Publisher
     * @param bufferSize
     *            the number of items to prefetch from the first and second source Publisher
     * @param &lt;T&gt;
     *            the type of items emitted by each Publisher
     * @return a Single that emits a Boolean value that indicates whether the two Publisher sequences
     *         are the same according to the specified function
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/sequenceequal.html&quot;&gt;ReactiveX operators documentation: SequenceEqual&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Single&lt;Boolean&gt; sequenceEqual(Publisher&lt;? extends T&gt; source1, Publisher&lt;? extends T&gt; source2,
            BiPredicate&lt;? super T, ? super T&gt; isEqual, int bufferSize) {
<span class="fc" id="L4130">        ObjectHelper.requireNonNull(source1, &quot;source1 is null&quot;);</span>
<span class="fc" id="L4131">        ObjectHelper.requireNonNull(source2, &quot;source2 is null&quot;);</span>
<span class="fc" id="L4132">        ObjectHelper.requireNonNull(isEqual, &quot;isEqual is null&quot;);</span>
<span class="fc" id="L4133">        ObjectHelper.verifyPositive(bufferSize, &quot;bufferSize&quot;);</span>
<span class="fc" id="L4134">        return RxJavaPlugins.onAssembly(new FlowableSequenceEqualSingle&lt;T&gt;(source1, source2, isEqual, bufferSize));</span>
    }

    /**
     * Returns a Single that emits a Boolean value that indicates whether two Publisher sequences are the
     * same by comparing the items emitted by each Publisher pairwise.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;385&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/sequenceEqual.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator honors downstream backpressure and expects both of its sources
     *  to honor backpressure as well. If violated, the operator will emit a MissingBackpressureException.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code sequenceEqual} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param source1
     *            the first Publisher to compare
     * @param source2
     *            the second Publisher to compare
     * @param bufferSize
     *            the number of items to prefetch from the first and second source Publisher
     * @param &lt;T&gt;
     *            the type of items emitted by each Publisher
     * @return a Single that emits a Boolean value that indicates whether the two sequences are the same
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/sequenceequal.html&quot;&gt;ReactiveX operators documentation: SequenceEqual&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Single&lt;Boolean&gt; sequenceEqual(Publisher&lt;? extends T&gt; source1, Publisher&lt;? extends T&gt; source2, int bufferSize) {
<span class="fc" id="L4165">        return sequenceEqual(source1, source2, ObjectHelper.equalsPredicate(), bufferSize);</span>
    }

    /**
     * Converts a Publisher that emits Publishers into a Publisher that emits the items emitted by the
     * most recently emitted of those Publishers.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;370&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/switchDo.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * {@code switchOnNext} subscribes to a Publisher that emits Publishers. Each time it observes one of
     * these emitted Publishers, the Publisher returned by {@code switchOnNext} begins emitting the items
     * emitted by that Publisher. When a new Publisher is emitted, {@code switchOnNext} stops emitting items
     * from the earlier-emitted Publisher and begins emitting items from the new one.
     * &lt;p&gt;
     * The resulting Publisher completes if both the outer Publisher and the last inner Publisher, if any, complete.
     * If the outer Publisher signals an onError, the inner Publisher is canceled and the error delivered in-sequence.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream. The outer {@code Publisher} is consumed in an
     *  unbounded manner (i.e., without backpressure) and the inner {@code Publisher}s are expected to honor
     *  backpressure but it is not enforced; the operator won't signal a {@code MissingBackpressureException}
     *  but the violation &lt;em&gt;may&lt;/em&gt; lead to {@code OutOfMemoryError} due to internal buffer bloat.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code switchOnNext} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T&gt; the item type
     * @param sources
     *            the source Publisher that emits Publishers
     * @param bufferSize
     *            the number of items to prefetch from the inner Publishers
     * @return a Flowable that emits the items emitted by the Publisher most recently emitted by the source
     *         Publisher
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/switch.html&quot;&gt;ReactiveX operators documentation: Switch&lt;/a&gt;
     */
    @SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Flowable&lt;T&gt; switchOnNext(Publisher&lt;? extends Publisher&lt;? extends T&gt;&gt; sources, int bufferSize) {
<span class="fc" id="L4205">        return fromPublisher(sources).switchMap((Function)Functions.identity(), bufferSize);</span>
    }

    /**
     * Converts a Publisher that emits Publishers into a Publisher that emits the items emitted by the
     * most recently emitted of those Publishers.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;370&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/switchDo.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * {@code switchOnNext} subscribes to a Publisher that emits Publishers. Each time it observes one of
     * these emitted Publishers, the Publisher returned by {@code switchOnNext} begins emitting the items
     * emitted by that Publisher. When a new Publisher is emitted, {@code switchOnNext} stops emitting items
     * from the earlier-emitted Publisher and begins emitting items from the new one.
     * &lt;p&gt;
     * The resulting Publisher completes if both the outer Publisher and the last inner Publisher, if any, complete.
     * If the outer Publisher signals an onError, the inner Publisher is canceled and the error delivered in-sequence.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream. The outer {@code Publisher} is consumed in an
     *  unbounded manner (i.e., without backpressure) and the inner {@code Publisher}s are expected to honor
     *  backpressure but it is not enforced; the operator won't signal a {@code MissingBackpressureException}
     *  but the violation &lt;em&gt;may&lt;/em&gt; lead to {@code OutOfMemoryError} due to internal buffer bloat.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code switchOnNext} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T&gt; the item type
     * @param sources
     *            the source Publisher that emits Publishers
     * @return a Flowable that emits the items emitted by the Publisher most recently emitted by the source
     *         Publisher
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/switch.html&quot;&gt;ReactiveX operators documentation: Switch&lt;/a&gt;
     */
    @SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Flowable&lt;T&gt; switchOnNext(Publisher&lt;? extends Publisher&lt;? extends T&gt;&gt; sources) {
<span class="fc" id="L4243">        return fromPublisher(sources).switchMap((Function)Functions.identity());</span>
    }

    /**
     * Converts a Publisher that emits Publishers into a Publisher that emits the items emitted by the
     * most recently emitted of those Publishers and delays any exception until all Publishers terminate.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;370&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/switchDo.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * {@code switchOnNext} subscribes to a Publisher that emits Publishers. Each time it observes one of
     * these emitted Publishers, the Publisher returned by {@code switchOnNext} begins emitting the items
     * emitted by that Publisher. When a new Publisher is emitted, {@code switchOnNext} stops emitting items
     * from the earlier-emitted Publisher and begins emitting items from the new one.
     * &lt;p&gt;
     * The resulting Publisher completes if both the main Publisher and the last inner Publisher, if any, complete.
     * If the main Publisher signals an onError, the termination of the last inner Publisher will emit that error as is
     * or wrapped into a CompositeException along with the other possible errors the former inner Publishers signaled.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream. The outer {@code Publisher} is consumed in an
     *  unbounded manner (i.e., without backpressure) and the inner {@code Publisher}s are expected to honor
     *  backpressure but it is not enforced; the operator won't signal a {@code MissingBackpressureException}
     *  but the violation &lt;em&gt;may&lt;/em&gt; lead to {@code OutOfMemoryError} due to internal buffer bloat.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code switchOnNextDelayError} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T&gt; the item type
     * @param sources
     *            the source Publisher that emits Publishers
     * @return a Flowable that emits the items emitted by the Publisher most recently emitted by the source
     *         Publisher
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/switch.html&quot;&gt;ReactiveX operators documentation: Switch&lt;/a&gt;
     * @since 2.0
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Flowable&lt;T&gt; switchOnNextDelayError(Publisher&lt;? extends Publisher&lt;? extends T&gt;&gt; sources) {
<span class="fc" id="L4282">        return switchOnNextDelayError(sources, bufferSize());</span>
    }

    /**
     * Converts a Publisher that emits Publishers into a Publisher that emits the items emitted by the
     * most recently emitted of those Publishers and delays any exception until all Publishers terminate.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;370&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/switchDo.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * {@code switchOnNext} subscribes to a Publisher that emits Publishers. Each time it observes one of
     * these emitted Publishers, the Publisher returned by {@code switchOnNext} begins emitting the items
     * emitted by that Publisher. When a new Publisher is emitted, {@code switchOnNext} stops emitting items
     * from the earlier-emitted Publisher and begins emitting items from the new one.
     * &lt;p&gt;
     * The resulting Publisher completes if both the main Publisher and the last inner Publisher, if any, complete.
     * If the main Publisher signals an onError, the termination of the last inner Publisher will emit that error as is
     * or wrapped into a CompositeException along with the other possible errors the former inner Publishers signaled.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream. The outer {@code Publisher} is consumed in an
     *  unbounded manner (i.e., without backpressure) and the inner {@code Publisher}s are expected to honor
     *  backpressure but it is not enforced; the operator won't signal a {@code MissingBackpressureException}
     *  but the violation &lt;em&gt;may&lt;/em&gt; lead to {@code OutOfMemoryError} due to internal buffer bloat.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code switchOnNextDelayError} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T&gt; the item type
     * @param sources
     *            the source Publisher that emits Publishers
     * @param prefetch
     *            the number of items to prefetch from the inner Publishers
     * @return a Flowable that emits the items emitted by the Publisher most recently emitted by the source
     *         Publisher
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/switch.html&quot;&gt;ReactiveX operators documentation: Switch&lt;/a&gt;
     * @since 2.0
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Flowable&lt;T&gt; switchOnNextDelayError(Publisher&lt;? extends Publisher&lt;? extends T&gt;&gt; sources, int prefetch) {
<span class="fc" id="L4323">        return fromPublisher(sources).switchMapDelayError(Functions.&lt;Publisher&lt;? extends T&gt;&gt;identity(), prefetch);</span>
    }

    /**
     * Returns a Flowable that emits {@code 0L} after a specified delay, and then completes.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;200&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/timer.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not support backpressure as it uses time. If the downstream needs a slower rate
     *      it should slow the timer or use something like {@link #onBackpressureDrop}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code timer} operates by default on the {@code computation} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param delay
     *            the initial delay before emitting a single {@code 0L}
     * @param unit
     *            time units to use for {@code delay}
     * @return a Flowable that emits {@code 0L} after a specified delay, and then completes
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/timer.html&quot;&gt;ReactiveX operators documentation: Timer&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.COMPUTATION)
    public static Flowable&lt;Long&gt; timer(long delay, TimeUnit unit) {
<span class="fc" id="L4349">        return timer(delay, unit, Schedulers.computation());</span>
    }

    /**
     * Returns a Flowable that emits {@code 0L} after a specified delay, on a specified Scheduler, and then
     * completes.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;200&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/timer.s.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not support backpressure as it uses time. If the downstream needs a slower rate
     *      it should slow the timer or use something like {@link #onBackpressureDrop}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;You specify which {@link Scheduler} this operator will use.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param delay
     *            the initial delay before emitting a single 0L
     * @param unit
     *            time units to use for {@code delay}
     * @param scheduler
     *            the {@link Scheduler} to use for scheduling the item
     * @return a Flowable that emits {@code 0L} after a specified delay, on a specified Scheduler, and then
     *         completes
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/timer.html&quot;&gt;ReactiveX operators documentation: Timer&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public static Flowable&lt;Long&gt; timer(long delay, TimeUnit unit, Scheduler scheduler) {
<span class="fc" id="L4380">        ObjectHelper.requireNonNull(unit, &quot;unit is null&quot;);</span>
<span class="fc" id="L4381">        ObjectHelper.requireNonNull(scheduler, &quot;scheduler is null&quot;);</span>

<span class="fc" id="L4383">        return RxJavaPlugins.onAssembly(new FlowableTimer(Math.max(0L, delay), unit, scheduler));</span>
    }

    /**
     * Create a Flowable by wrapping a Publisher &lt;em&gt;which has to be implemented according
     * to the Reactive-Streams specification by handling backpressure and
     * cancellation correctly; no safeguards are provided by the Flowable itself&lt;/em&gt;.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator is a pass-through for backpressure and the behavior is determined by the
     *  provided Publisher implementation.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code unsafeCreate} by default doesn't operate on any particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;T&gt; the value type emitted
     * @param onSubscribe the Publisher instance to wrap
     * @return the new Flowable instance
     * @throws IllegalArgumentException if {@code onSubscribe} is a subclass of {@code Flowable}; such
     * instances don't need conversion and is possibly a port remnant from 1.x or one should use {@link #hide()}
     * instead.
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.NONE)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Flowable&lt;T&gt; unsafeCreate(Publisher&lt;T&gt; onSubscribe) {
<span class="fc" id="L4409">        ObjectHelper.requireNonNull(onSubscribe, &quot;onSubscribe is null&quot;);</span>
<span class="fc bfc" id="L4410" title="All 2 branches covered.">        if (onSubscribe instanceof Flowable) {</span>
<span class="fc" id="L4411">            throw new IllegalArgumentException(&quot;unsafeCreate(Flowable) should be upgraded&quot;);</span>
        }
<span class="fc" id="L4413">        return RxJavaPlugins.onAssembly(new FlowableFromPublisher&lt;T&gt;(onSubscribe));</span>
    }

    /**
     * Constructs a Publisher that creates a dependent resource object which is disposed of on cancellation.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;400&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/using.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator is a pass-through for backpressure and otherwise depends on the
     *  backpressure support of the Publisher returned by the {@code resourceFactory}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code using} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T&gt; the element type of the generated Publisher
     * @param &lt;D&gt; the type of the resource associated with the output sequence
     * @param resourceSupplier
     *            the factory function to create a resource object that depends on the Publisher
     * @param sourceSupplier
     *            the factory function to create a Publisher
     * @param resourceDisposer
     *            the function that will dispose of the resource
     * @return the Publisher whose lifetime controls the lifetime of the dependent resource object
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/using.html&quot;&gt;ReactiveX operators documentation: Using&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T, D&gt; Flowable&lt;T&gt; using(Callable&lt;? extends D&gt; resourceSupplier,
            Function&lt;? super D, ? extends Publisher&lt;? extends T&gt;&gt; sourceSupplier, Consumer&lt;? super D&gt; resourceDisposer) {
<span class="fc" id="L4444">        return using(resourceSupplier, sourceSupplier, resourceDisposer, true);</span>
    }

    /**
     * Constructs a Publisher that creates a dependent resource object which is disposed of just before
     * termination if you have set {@code disposeEagerly} to {@code true} and cancellation does not occur
     * before termination. Otherwise, resource disposal will occur on cancellation.  Eager disposal is
     * particularly appropriate for a synchronous Publisher that reuses resources. {@code disposeAction} will
     * only be called once per subscription.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;400&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/using.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator is a pass-through for backpressure and otherwise depends on the
     *  backpressure support of the Publisher returned by the {@code resourceFactory}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code using} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T&gt; the element type of the generated Publisher
     * @param &lt;D&gt; the type of the resource associated with the output sequence
     * @param resourceSupplier
     *            the factory function to create a resource object that depends on the Publisher
     * @param sourceSupplier
     *            the factory function to create a Publisher
     * @param resourceDisposer
     *            the function that will dispose of the resource
     * @param eager
     *            if {@code true} then disposal will happen either on cancellation or just before emission of
     *            a terminal event ({@code onComplete} or {@code onError}).
     * @return the Publisher whose lifetime controls the lifetime of the dependent resource object
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/using.html&quot;&gt;ReactiveX operators documentation: Using&lt;/a&gt;
     * @since 2.0
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T, D&gt; Flowable&lt;T&gt; using(Callable&lt;? extends D&gt; resourceSupplier,
            Function&lt;? super D, ? extends Publisher&lt;? extends T&gt;&gt; sourceSupplier,
                    Consumer&lt;? super D&gt; resourceDisposer, boolean eager) {
<span class="fc" id="L4485">        ObjectHelper.requireNonNull(resourceSupplier, &quot;resourceSupplier is null&quot;);</span>
<span class="fc" id="L4486">        ObjectHelper.requireNonNull(sourceSupplier, &quot;sourceSupplier is null&quot;);</span>
<span class="fc" id="L4487">        ObjectHelper.requireNonNull(resourceDisposer, &quot;resourceDisposer is null&quot;);</span>
<span class="fc" id="L4488">        return RxJavaPlugins.onAssembly(new FlowableUsing&lt;T, D&gt;(resourceSupplier, sourceSupplier, resourceDisposer, eager));</span>
    }

    /**
     * Returns a Flowable that emits the results of a specified combiner function applied to combinations of
     * items emitted, in sequence, by an Iterable of other Publishers.
     * &lt;p&gt;
     * {@code zip} applies this function in strict sequence, so the first item emitted by the new Publisher
     * will be the result of the function applied to the first item emitted by each of the source Publishers;
     * the second item emitted by the new Publisher will be the result of the function applied to the second
     * item emitted by each of those Publishers; and so forth.
     * &lt;p&gt;
     * The resulting {@code Publisher&lt;R&gt;} returned from {@code zip} will invoke {@code onNext} as many times as
     * the number of {@code onNext} invocations of the source Publisher that emits the fewest items.
     * &lt;p&gt;
     * The operator subscribes to its sources in the order they are specified and completes eagerly if
     * one of the sources is shorter than the rest while canceling the other sources. Therefore, it
     * is possible those other sources will never be able to run to completion (and thus not calling
     * {@code doOnComplete()}). This can also happen if the sources are exactly the same length; if
     * source A completes and B has been consumed and is about to complete, the operator detects A won't
     * be sending further values and it will cancel B immediately. For example:
     * &lt;pre&gt;&lt;code&gt;zip(Arrays.asList(range(1, 5).doOnComplete(action1), range(6, 5).doOnComplete(action2)), (a) -&amp;gt; a)&lt;/code&gt;&lt;/pre&gt;
     * {@code action1} will be called but {@code action2} won't.
     * &lt;br&gt;To work around this termination property,
     * use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completion
     * or cancellation.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/zip.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator expects backpressure from the sources and honors backpressure from the downstream.
     *  (I.e., zipping with {@link #interval(long, TimeUnit)} may result in MissingBackpressureException, use
     *  one of the {@code onBackpressureX} to handle similar, backpressure-ignoring sources.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code zip} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T&gt; the common value type
     * @param &lt;R&gt; the zipped result type
     * @param sources
     *            an Iterable of source Publishers
     * @param zipper
     *            a function that, when applied to an item emitted by each of the source Publishers, results in
     *            an item that will be emitted by the resulting Publisher
     * @return a Flowable that emits the zipped results
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/zip.html&quot;&gt;ReactiveX operators documentation: Zip&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T, R&gt; Flowable&lt;R&gt; zip(Iterable&lt;? extends Publisher&lt;? extends T&gt;&gt; sources, Function&lt;? super Object[], ? extends R&gt; zipper) {
<span class="fc" id="L4540">        ObjectHelper.requireNonNull(zipper, &quot;zipper is null&quot;);</span>
<span class="fc" id="L4541">        ObjectHelper.requireNonNull(sources, &quot;sources is null&quot;);</span>
<span class="fc" id="L4542">        return RxJavaPlugins.onAssembly(new FlowableZip&lt;T, R&gt;(null, sources, zipper, bufferSize(), false));</span>
    }

    /**
     * Returns a Flowable that emits the results of a specified combiner function applied to combinations of
     * &lt;i&gt;n&lt;/i&gt; items emitted, in sequence, by the &lt;i&gt;n&lt;/i&gt; Publishers emitted by a specified Publisher.
     * &lt;p&gt;
     * {@code zip} applies this function in strict sequence, so the first item emitted by the new Publisher
     * will be the result of the function applied to the first item emitted by each of the Publishers emitted
     * by the source Publisher; the second item emitted by the new Publisher will be the result of the
     * function applied to the second item emitted by each of those Publishers; and so forth.
     * &lt;p&gt;
     * The resulting {@code Publisher&lt;R&gt;} returned from {@code zip} will invoke {@code onNext} as many times as
     * the number of {@code onNext} invocations of the source Publisher that emits the fewest items.
     * &lt;p&gt;
     * The operator subscribes to its sources in the order they are specified and completes eagerly if
     * one of the sources is shorter than the rest while cancel the other sources. Therefore, it
     * is possible those other sources will never be able to run to completion (and thus not calling
     * {@code doOnComplete()}). This can also happen if the sources are exactly the same length; if
     * source A completes and B has been consumed and is about to complete, the operator detects A won't
     * be sending further values and it will cancel B immediately. For example:
     * &lt;pre&gt;&lt;code&gt;zip(just(range(1, 5).doOnComplete(action1), range(6, 5).doOnComplete(action2)), (a) -&amp;gt; a)&lt;/code&gt;&lt;/pre&gt;
     * {@code action1} will be called but {@code action2} won't.
     * &lt;br&gt;To work around this termination property,
     * use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completion
     * or cancellation.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;370&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/zip.o.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator expects backpressure from the sources and honors backpressure from the downstream.
     *  (I.e., zipping with {@link #interval(long, TimeUnit)} may result in MissingBackpressureException, use
     *  one of the {@code onBackpressureX} to handle similar, backpressure-ignoring sources.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code zip} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T&gt; the value type of the inner Publishers
     * @param &lt;R&gt; the zipped result type
     * @param sources
     *            a Publisher of source Publishers
     * @param zipper
     *            a function that, when applied to an item emitted by each of the Publishers emitted by
     *            {@code ws}, results in an item that will be emitted by the resulting Publisher
     * @return a Flowable that emits the zipped results
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/zip.html&quot;&gt;ReactiveX operators documentation: Zip&lt;/a&gt;
     */
    @SuppressWarnings({ &quot;rawtypes&quot;, &quot;unchecked&quot;, &quot;cast&quot; })
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T, R&gt; Flowable&lt;R&gt; zip(Publisher&lt;? extends Publisher&lt;? extends T&gt;&gt; sources,
            final Function&lt;? super Object[], ? extends R&gt; zipper) {
<span class="fc" id="L4596">        ObjectHelper.requireNonNull(zipper, &quot;zipper is null&quot;);</span>
<span class="fc" id="L4597">        return fromPublisher(sources).toList().flatMapPublisher((Function)FlowableInternalHelper.&lt;T, R&gt;zipIterable(zipper));</span>
    }

    /**
     * Returns a Flowable that emits the results of a specified combiner function applied to combinations of
     * two items emitted, in sequence, by two other Publishers.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/zip.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * {@code zip} applies this function in strict sequence, so the first item emitted by the new Publisher
     * will be the result of the function applied to the first item emitted by {@code o1} and the first item
     * emitted by {@code o2}; the second item emitted by the new Publisher will be the result of the function
     * applied to the second item emitted by {@code o1} and the second item emitted by {@code o2}; and so forth.
     * &lt;p&gt;
     * The resulting {@code Publisher&lt;R&gt;} returned from {@code zip} will invoke {@link Subscriber#onNext onNext}
     * as many times as the number of {@code onNext} invocations of the source Publisher that emits the fewest
     * items.
     * &lt;p&gt;
     * The operator subscribes to its sources in the order they are specified and completes eagerly if
     * one of the sources is shorter than the rest while canceling the other sources. Therefore, it
     * is possible those other sources will never be able to run to completion (and thus not calling
     * {@code doOnComplete()}). This can also happen if the sources are exactly the same length; if
     * source A completes and B has been consumed and is about to complete, the operator detects A won't
     * be sending further values and it will cancel B immediately. For example:
     * &lt;pre&gt;&lt;code&gt;zip(range(1, 5).doOnComplete(action1), range(6, 5).doOnComplete(action2), (a, b) -&amp;gt; a + b)&lt;/code&gt;&lt;/pre&gt;
     * {@code action1} will be called but {@code action2} won't.
     * &lt;br&gt;To work around this termination property,
     * use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completion
     * or cancellation.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator expects backpressure from the sources and honors backpressure from the downstream.
     *  (I.e., zipping with {@link #interval(long, TimeUnit)} may result in MissingBackpressureException, use
     *  one of the {@code onBackpressureX} to handle similar, backpressure-ignoring sources.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code zip} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T1&gt; the value type of the first source
     * @param &lt;T2&gt; the value type of the second source
     * @param &lt;R&gt; the zipped result type
     * @param source1
     *            the first source Publisher
     * @param source2
     *            a second source Publisher
     * @param zipper
     *            a function that, when applied to an item emitted by each of the source Publishers, results
     *            in an item that will be emitted by the resulting Publisher
     * @return a Flowable that emits the zipped results
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/zip.html&quot;&gt;ReactiveX operators documentation: Zip&lt;/a&gt;
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T1, T2, R&gt; Flowable&lt;R&gt; zip(
            Publisher&lt;? extends T1&gt; source1, Publisher&lt;? extends T2&gt; source2,
            BiFunction&lt;? super T1, ? super T2, ? extends R&gt; zipper) {
<span class="fc" id="L4656">        ObjectHelper.requireNonNull(source1, &quot;source1 is null&quot;);</span>
<span class="fc" id="L4657">        ObjectHelper.requireNonNull(source2, &quot;source2 is null&quot;);</span>
<span class="fc" id="L4658">        return zipArray(Functions.toFunction(zipper), false, bufferSize(), source1, source2);</span>
    }

    /**
     * Returns a Flowable that emits the results of a specified combiner function applied to combinations of
     * two items emitted, in sequence, by two other Publishers.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/zip.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * {@code zip} applies this function in strict sequence, so the first item emitted by the new Publisher
     * will be the result of the function applied to the first item emitted by {@code o1} and the first item
     * emitted by {@code o2}; the second item emitted by the new Publisher will be the result of the function
     * applied to the second item emitted by {@code o1} and the second item emitted by {@code o2}; and so forth.
     * &lt;p&gt;
     * The resulting {@code Publisher&lt;R&gt;} returned from {@code zip} will invoke {@link Subscriber#onNext onNext}
     * as many times as the number of {@code onNext} invocations of the source Publisher that emits the fewest
     * items.
     * &lt;p&gt;
     * The operator subscribes to its sources in the order they are specified and completes eagerly if
     * one of the sources is shorter than the rest while canceling the other sources. Therefore, it
     * is possible those other sources will never be able to run to completion (and thus not calling
     * {@code doOnComplete()}). This can also happen if the sources are exactly the same length; if
     * source A completes and B has been consumed and is about to complete, the operator detects A won't
     * be sending further values and it will cancel B immediately. For example:
     * &lt;pre&gt;&lt;code&gt;zip(range(1, 5).doOnComplete(action1), range(6, 5).doOnComplete(action2), (a, b) -&amp;gt; a + b)&lt;/code&gt;&lt;/pre&gt;
     * {@code action1} will be called but {@code action2} won't.
     * &lt;br&gt;To work around this termination property,
     * use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completion
     * or cancellation.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator expects backpressure from the sources and honors backpressure from the downstream.
     *  (I.e., zipping with {@link #interval(long, TimeUnit)} may result in MissingBackpressureException, use
     *  one of the {@code onBackpressureX} to handle similar, backpressure-ignoring sources.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code zip} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T1&gt; the value type of the first source
     * @param &lt;T2&gt; the value type of the second source
     * @param &lt;R&gt; the zipped result type
     * @param source1
     *            the first source Publisher
     * @param source2
     *            a second source Publisher
     * @param zipper
     *            a function that, when applied to an item emitted by each of the source Publishers, results
     *            in an item that will be emitted by the resulting Publisher
     * @param delayError delay errors from any of the source Publishers till the other terminates
     * @return a Flowable that emits the zipped results
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/zip.html&quot;&gt;ReactiveX operators documentation: Zip&lt;/a&gt;
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T1, T2, R&gt; Flowable&lt;R&gt; zip(
            Publisher&lt;? extends T1&gt; source1, Publisher&lt;? extends T2&gt; source2,
            BiFunction&lt;? super T1, ? super T2, ? extends R&gt; zipper, boolean delayError) {
<span class="fc" id="L4718">        ObjectHelper.requireNonNull(source1, &quot;source1 is null&quot;);</span>
<span class="fc" id="L4719">        ObjectHelper.requireNonNull(source2, &quot;source2 is null&quot;);</span>
<span class="fc" id="L4720">        return zipArray(Functions.toFunction(zipper), delayError, bufferSize(), source1, source2);</span>
    }

    /**
     * Returns a Flowable that emits the results of a specified combiner function applied to combinations of
     * two items emitted, in sequence, by two other Publishers.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/zip.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * {@code zip} applies this function in strict sequence, so the first item emitted by the new Publisher
     * will be the result of the function applied to the first item emitted by {@code o1} and the first item
     * emitted by {@code o2}; the second item emitted by the new Publisher will be the result of the function
     * applied to the second item emitted by {@code o1} and the second item emitted by {@code o2}; and so forth.
     * &lt;p&gt;
     * The resulting {@code Publisher&lt;R&gt;} returned from {@code zip} will invoke {@link Subscriber#onNext onNext}
     * as many times as the number of {@code onNext} invocations of the source Publisher that emits the fewest
     * items.
     * &lt;p&gt;
     * The operator subscribes to its sources in the order they are specified and completes eagerly if
     * one of the sources is shorter than the rest while canceling the other sources. Therefore, it
     * is possible those other sources will never be able to run to completion (and thus not calling
     * {@code doOnComplete()}). This can also happen if the sources are exactly the same length; if
     * source A completes and B has been consumed and is about to complete, the operator detects A won't
     * be sending further values and it will cancel B immediately. For example:
     * &lt;pre&gt;&lt;code&gt;zip(range(1, 5).doOnComplete(action1), range(6, 5).doOnComplete(action2), (a, b) -&amp;gt; a + b)&lt;/code&gt;&lt;/pre&gt;
     * {@code action1} will be called but {@code action2} won't.
     * &lt;br&gt;To work around this termination property,
     * use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completion
     * or cancellation.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator expects backpressure from the sources and honors backpressure from the downstream.
     *  (I.e., zipping with {@link #interval(long, TimeUnit)} may result in MissingBackpressureException, use
     *  one of the {@code onBackpressureX} to handle similar, backpressure-ignoring sources.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code zip} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T1&gt; the value type of the first source
     * @param &lt;T2&gt; the value type of the second source
     * @param &lt;R&gt; the zipped result type
     * @param source1
     *            the first source Publisher
     * @param source2
     *            a second source Publisher
     * @param zipper
     *            a function that, when applied to an item emitted by each of the source Publishers, results
     *            in an item that will be emitted by the resulting Publisher
     * @param delayError delay errors from any of the source Publishers till the other terminates
     * @param bufferSize the number of elements to prefetch from each source Publisher
     * @return a Flowable that emits the zipped results
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/zip.html&quot;&gt;ReactiveX operators documentation: Zip&lt;/a&gt;
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T1, T2, R&gt; Flowable&lt;R&gt; zip(
            Publisher&lt;? extends T1&gt; source1, Publisher&lt;? extends T2&gt; source2,
            BiFunction&lt;? super T1, ? super T2, ? extends R&gt; zipper, boolean delayError, int bufferSize) {
<span class="fc" id="L4781">        ObjectHelper.requireNonNull(source1, &quot;source1 is null&quot;);</span>
<span class="fc" id="L4782">        ObjectHelper.requireNonNull(source2, &quot;source2 is null&quot;);</span>
<span class="fc" id="L4783">        return zipArray(Functions.toFunction(zipper), delayError, bufferSize, source1, source2);</span>
    }

    /**
     * Returns a Flowable that emits the results of a specified combiner function applied to combinations of
     * three items emitted, in sequence, by three other Publishers.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/zip.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * {@code zip} applies this function in strict sequence, so the first item emitted by the new Publisher
     * will be the result of the function applied to the first item emitted by {@code o1}, the first item
     * emitted by {@code o2}, and the first item emitted by {@code o3}; the second item emitted by the new
     * Publisher will be the result of the function applied to the second item emitted by {@code o1}, the
     * second item emitted by {@code o2}, and the second item emitted by {@code o3}; and so forth.
     * &lt;p&gt;
     * The resulting {@code Publisher&lt;R&gt;} returned from {@code zip} will invoke {@link Subscriber#onNext onNext}
     * as many times as the number of {@code onNext} invocations of the source Publisher that emits the fewest
     * items.
     * &lt;p&gt;
     * The operator subscribes to its sources in the order they are specified and completes eagerly if
     * one of the sources is shorter than the rest while canceling the other sources. Therefore, it
     * is possible those other sources will never be able to run to completion (and thus not calling
     * {@code doOnComplete()}). This can also happen if the sources are exactly the same length; if
     * source A completes and B has been consumed and is about to complete, the operator detects A won't
     * be sending further values and it will cancel B immediately. For example:
     * &lt;pre&gt;&lt;code&gt;zip(range(1, 5).doOnComplete(action1), range(6, 5).doOnComplete(action2), ..., (a, b, c) -&amp;gt; a + b)&lt;/code&gt;&lt;/pre&gt;
     * {@code action1} will be called but {@code action2} won't.
     * &lt;br&gt;To work around this termination property,
     * use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completion
     * or cancellation.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator expects backpressure from the sources and honors backpressure from the downstream.
     *  (I.e., zipping with {@link #interval(long, TimeUnit)} may result in MissingBackpressureException, use
     *  one of the {@code onBackpressureX} to handle similar, backpressure-ignoring sources.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code zip} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T1&gt; the value type of the first source
     * @param &lt;T2&gt; the value type of the second source
     * @param &lt;T3&gt; the value type of the third source
     * @param &lt;R&gt; the zipped result type
     * @param source1
     *            the first source Publisher
     * @param source2
     *            a second source Publisher
     * @param source3
     *            a third source Publisher
     * @param zipper
     *            a function that, when applied to an item emitted by each of the source Publishers, results in
     *            an item that will be emitted by the resulting Publisher
     * @return a Flowable that emits the zipped results
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/zip.html&quot;&gt;ReactiveX operators documentation: Zip&lt;/a&gt;
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T1, T2, T3, R&gt; Flowable&lt;R&gt; zip(
            Publisher&lt;? extends T1&gt; source1, Publisher&lt;? extends T2&gt; source2, Publisher&lt;? extends T3&gt; source3,
            Function3&lt;? super T1, ? super T2, ? super T3, ? extends R&gt; zipper) {
<span class="fc" id="L4846">        ObjectHelper.requireNonNull(source1, &quot;source1 is null&quot;);</span>
<span class="fc" id="L4847">        ObjectHelper.requireNonNull(source2, &quot;source2 is null&quot;);</span>
<span class="fc" id="L4848">        ObjectHelper.requireNonNull(source3, &quot;source3 is null&quot;);</span>
<span class="fc" id="L4849">        return zipArray(Functions.toFunction(zipper), false, bufferSize(), source1, source2, source3);</span>
    }

    /**
     * Returns a Flowable that emits the results of a specified combiner function applied to combinations of
     * four items emitted, in sequence, by four other Publishers.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/zip.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * {@code zip} applies this function in strict sequence, so the first item emitted by the new Publisher
     * will be the result of the function applied to the first item emitted by {@code o1}, the first item
     * emitted by {@code o2}, the first item emitted by {@code o3}, and the first item emitted by {@code 04};
     * the second item emitted by the new Publisher will be the result of the function applied to the second
     * item emitted by each of those Publishers; and so forth.
     * &lt;p&gt;
     * The resulting {@code Publisher&lt;R&gt;} returned from {@code zip} will invoke {@link Subscriber#onNext onNext}
     * as many times as the number of {@code onNext} invocations of the source Publisher that emits the fewest
     * items.
     * &lt;p&gt;
     * The operator subscribes to its sources in the order they are specified and completes eagerly if
     * one of the sources is shorter than the rest while canceling the other sources. Therefore, it
     * is possible those other sources will never be able to run to completion (and thus not calling
     * {@code doOnComplete()}). This can also happen if the sources are exactly the same length; if
     * source A completes and B has been consumed and is about to complete, the operator detects A won't
     * be sending further values and it will cancel B immediately. For example:
     * &lt;pre&gt;&lt;code&gt;zip(range(1, 5).doOnComplete(action1), range(6, 5).doOnComplete(action2), ..., (a, b, c, d) -&amp;gt; a + b)&lt;/code&gt;&lt;/pre&gt;
     * {@code action1} will be called but {@code action2} won't.
     * &lt;br&gt;To work around this termination property,
     * use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completion
     * or cancellation.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator expects backpressure from the sources and honors backpressure from the downstream.
     *  (I.e., zipping with {@link #interval(long, TimeUnit)} may result in MissingBackpressureException, use
     *  one of the {@code onBackpressureX} to handle similar, backpressure-ignoring sources.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code zip} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T1&gt; the value type of the first source
     * @param &lt;T2&gt; the value type of the second source
     * @param &lt;T3&gt; the value type of the third source
     * @param &lt;T4&gt; the value type of the fourth source
     * @param &lt;R&gt; the zipped result type
     * @param source1
     *            the first source Publisher
     * @param source2
     *            a second source Publisher
     * @param source3
     *            a third source Publisher
     * @param source4
     *            a fourth source Publisher
     * @param zipper
     *            a function that, when applied to an item emitted by each of the source Publishers, results in
     *            an item that will be emitted by the resulting Publisher
     * @return a Flowable that emits the zipped results
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/zip.html&quot;&gt;ReactiveX operators documentation: Zip&lt;/a&gt;
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T1, T2, T3, T4, R&gt; Flowable&lt;R&gt; zip(
            Publisher&lt;? extends T1&gt; source1, Publisher&lt;? extends T2&gt; source2, Publisher&lt;? extends T3&gt; source3,
            Publisher&lt;? extends T4&gt; source4,
            Function4&lt;? super T1, ? super T2, ? super T3, ? super T4, ? extends R&gt; zipper) {
<span class="fc" id="L4916">        ObjectHelper.requireNonNull(source1, &quot;source1 is null&quot;);</span>
<span class="fc" id="L4917">        ObjectHelper.requireNonNull(source2, &quot;source2 is null&quot;);</span>
<span class="fc" id="L4918">        ObjectHelper.requireNonNull(source3, &quot;source3 is null&quot;);</span>
<span class="fc" id="L4919">        ObjectHelper.requireNonNull(source4, &quot;source4 is null&quot;);</span>
<span class="fc" id="L4920">        return zipArray(Functions.toFunction(zipper), false, bufferSize(), source1, source2, source3, source4);</span>
    }

    /**
     * Returns a Flowable that emits the results of a specified combiner function applied to combinations of
     * five items emitted, in sequence, by five other Publishers.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/zip.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * {@code zip} applies this function in strict sequence, so the first item emitted by the new Publisher
     * will be the result of the function applied to the first item emitted by {@code o1}, the first item
     * emitted by {@code o2}, the first item emitted by {@code o3}, the first item emitted by {@code o4}, and
     * the first item emitted by {@code o5}; the second item emitted by the new Publisher will be the result of
     * the function applied to the second item emitted by each of those Publishers; and so forth.
     * &lt;p&gt;
     * The resulting {@code Publisher&lt;R&gt;} returned from {@code zip} will invoke {@link Subscriber#onNext onNext}
     * as many times as the number of {@code onNext} invocations of the source Publisher that emits the fewest
     * items.
     * &lt;p&gt;
     * The operator subscribes to its sources in the order they are specified and completes eagerly if
     * one of the sources is shorter than the rest while canceling the other sources. Therefore, it
     * is possible those other sources will never be able to run to completion (and thus not calling
     * {@code doOnComplete()}). This can also happen if the sources are exactly the same length; if
     * source A completes and B has been consumed and is about to complete, the operator detects A won't
     * be sending further values and it will cancel B immediately. For example:
     * &lt;pre&gt;&lt;code&gt;zip(range(1, 5).doOnComplete(action1), range(6, 5).doOnComplete(action2), ..., (a, b, c, d, e) -&amp;gt; a + b)&lt;/code&gt;&lt;/pre&gt;
     * {@code action1} will be called but {@code action2} won't.
     * &lt;br&gt;To work around this termination property,
     * use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completion
     * or cancellation.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator expects backpressure from the sources and honors backpressure from the downstream.
     *  (I.e., zipping with {@link #interval(long, TimeUnit)} may result in MissingBackpressureException, use
     *  one of the {@code onBackpressureX} to handle similar, backpressure-ignoring sources.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code zip} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T1&gt; the value type of the first source
     * @param &lt;T2&gt; the value type of the second source
     * @param &lt;T3&gt; the value type of the third source
     * @param &lt;T4&gt; the value type of the fourth source
     * @param &lt;T5&gt; the value type of the fifth source
     * @param &lt;R&gt; the zipped result type
     * @param source1
     *            the first source Publisher
     * @param source2
     *            a second source Publisher
     * @param source3
     *            a third source Publisher
     * @param source4
     *            a fourth source Publisher
     * @param source5
     *            a fifth source Publisher
     * @param zipper
     *            a function that, when applied to an item emitted by each of the source Publishers, results in
     *            an item that will be emitted by the resulting Publisher
     * @return a Flowable that emits the zipped results
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/zip.html&quot;&gt;ReactiveX operators documentation: Zip&lt;/a&gt;
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T1, T2, T3, T4, T5, R&gt; Flowable&lt;R&gt; zip(
            Publisher&lt;? extends T1&gt; source1, Publisher&lt;? extends T2&gt; source2, Publisher&lt;? extends T3&gt; source3,
            Publisher&lt;? extends T4&gt; source4, Publisher&lt;? extends T5&gt; source5,
            Function5&lt;? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? extends R&gt; zipper) {
<span class="fc" id="L4990">        ObjectHelper.requireNonNull(source1, &quot;source1 is null&quot;);</span>
<span class="fc" id="L4991">        ObjectHelper.requireNonNull(source2, &quot;source2 is null&quot;);</span>
<span class="fc" id="L4992">        ObjectHelper.requireNonNull(source3, &quot;source3 is null&quot;);</span>
<span class="fc" id="L4993">        ObjectHelper.requireNonNull(source4, &quot;source4 is null&quot;);</span>
<span class="fc" id="L4994">        ObjectHelper.requireNonNull(source5, &quot;source5 is null&quot;);</span>
<span class="fc" id="L4995">        return zipArray(Functions.toFunction(zipper), false, bufferSize(), source1, source2, source3, source4, source5);</span>
    }

    /**
     * Returns a Flowable that emits the results of a specified combiner function applied to combinations of
     * six items emitted, in sequence, by six other Publishers.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/zip.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * {@code zip} applies this function in strict sequence, so the first item emitted by the new Publisher
     * will be the result of the function applied to the first item emitted by each source Publisher, the
     * second item emitted by the new Publisher will be the result of the function applied to the second item
     * emitted by each of those Publishers, and so forth.
     * &lt;p&gt;
     * The resulting {@code Publisher&lt;R&gt;} returned from {@code zip} will invoke {@link Subscriber#onNext onNext}
     * as many times as the number of {@code onNext} invocations of the source Publisher that emits the fewest
     * items.
     * &lt;p&gt;
     * The operator subscribes to its sources in the order they are specified and completes eagerly if
     * one of the sources is shorter than the rest while canceling the other sources. Therefore, it
     * is possible those other sources will never be able to run to completion (and thus not calling
     * {@code doOnComplete()}). This can also happen if the sources are exactly the same length; if
     * source A completes and B has been consumed and is about to complete, the operator detects A won't
     * be sending further values and it will cancel B immediately. For example:
     * &lt;pre&gt;&lt;code&gt;zip(range(1, 5).doOnComplete(action1), range(6, 5).doOnComplete(action2), ..., (a, b, c, d, e, f) -&amp;gt; a + b)&lt;/code&gt;&lt;/pre&gt;
     * {@code action1} will be called but {@code action2} won't.
     * &lt;br&gt;To work around this termination property,
     * use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completion
     * or cancellation.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator expects backpressure from the sources and honors backpressure from the downstream.
     *  (I.e., zipping with {@link #interval(long, TimeUnit)} may result in MissingBackpressureException, use
     *  one of the {@code onBackpressureX} to handle similar, backpressure-ignoring sources.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code zip} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T1&gt; the value type of the first source
     * @param &lt;T2&gt; the value type of the second source
     * @param &lt;T3&gt; the value type of the third source
     * @param &lt;T4&gt; the value type of the fourth source
     * @param &lt;T5&gt; the value type of the fifth source
     * @param &lt;T6&gt; the value type of the sixth source
     * @param &lt;R&gt; the zipped result type
     * @param source1
     *            the first source Publisher
     * @param source2
     *            a second source Publisher
     * @param source3
     *            a third source Publisher
     * @param source4
     *            a fourth source Publisher
     * @param source5
     *            a fifth source Publisher
     * @param source6
     *            a sixth source Publisher
     * @param zipper
     *            a function that, when applied to an item emitted by each of the source Publishers, results in
     *            an item that will be emitted by the resulting Publisher
     * @return a Flowable that emits the zipped results
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/zip.html&quot;&gt;ReactiveX operators documentation: Zip&lt;/a&gt;
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T1, T2, T3, T4, T5, T6, R&gt; Flowable&lt;R&gt; zip(
            Publisher&lt;? extends T1&gt; source1, Publisher&lt;? extends T2&gt; source2, Publisher&lt;? extends T3&gt; source3,
            Publisher&lt;? extends T4&gt; source4, Publisher&lt;? extends T5&gt; source5, Publisher&lt;? extends T6&gt; source6,
            Function6&lt;? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? extends R&gt; zipper) {
<span class="fc" id="L5067">        ObjectHelper.requireNonNull(source1, &quot;source1 is null&quot;);</span>
<span class="fc" id="L5068">        ObjectHelper.requireNonNull(source2, &quot;source2 is null&quot;);</span>
<span class="fc" id="L5069">        ObjectHelper.requireNonNull(source3, &quot;source3 is null&quot;);</span>
<span class="fc" id="L5070">        ObjectHelper.requireNonNull(source4, &quot;source4 is null&quot;);</span>
<span class="fc" id="L5071">        ObjectHelper.requireNonNull(source5, &quot;source5 is null&quot;);</span>
<span class="fc" id="L5072">        ObjectHelper.requireNonNull(source6, &quot;source6 is null&quot;);</span>
<span class="fc" id="L5073">        return zipArray(Functions.toFunction(zipper), false, bufferSize(), source1, source2, source3, source4, source5, source6);</span>
    }

    /**
     * Returns a Flowable that emits the results of a specified combiner function applied to combinations of
     * seven items emitted, in sequence, by seven other Publishers.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/zip.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * {@code zip} applies this function in strict sequence, so the first item emitted by the new Publisher
     * will be the result of the function applied to the first item emitted by each source Publisher, the
     * second item emitted by the new Publisher will be the result of the function applied to the second item
     * emitted by each of those Publishers, and so forth.
     * &lt;p&gt;
     * The resulting {@code Publisher&lt;R&gt;} returned from {@code zip} will invoke {@link Subscriber#onNext onNext}
     * as many times as the number of {@code onNext} invocations of the source Publisher that emits the fewest
     * items.
     * &lt;p&gt;
     * The operator subscribes to its sources in the order they are specified and completes eagerly if
     * one of the sources is shorter than the rest while canceling the other sources. Therefore, it
     * is possible those other sources will never be able to run to completion (and thus not calling
     * {@code doOnComplete()}). This can also happen if the sources are exactly the same length; if
     * source A completes and B has been consumed and is about to complete, the operator detects A won't
     * be sending further values and it will cancel B immediately. For example:
     * &lt;pre&gt;&lt;code&gt;zip(range(1, 5).doOnComplete(action1), range(6, 5).doOnComplete(action2), ..., (a, b, c, d, e, f, g) -&amp;gt; a + b)&lt;/code&gt;&lt;/pre&gt;
     * {@code action1} will be called but {@code action2} won't.
     * &lt;br&gt;To work around this termination property,
     * use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completion
     * or cancellation.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator expects backpressure from the sources and honors backpressure from the downstream.
     *  (I.e., zipping with {@link #interval(long, TimeUnit)} may result in MissingBackpressureException, use
     *  one of the {@code onBackpressureX} to handle similar, backpressure-ignoring sources.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code zip} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T1&gt; the value type of the first source
     * @param &lt;T2&gt; the value type of the second source
     * @param &lt;T3&gt; the value type of the third source
     * @param &lt;T4&gt; the value type of the fourth source
     * @param &lt;T5&gt; the value type of the fifth source
     * @param &lt;T6&gt; the value type of the sixth source
     * @param &lt;T7&gt; the value type of the seventh source
     * @param &lt;R&gt; the zipped result type
     * @param source1
     *            the first source Publisher
     * @param source2
     *            a second source Publisher
     * @param source3
     *            a third source Publisher
     * @param source4
     *            a fourth source Publisher
     * @param source5
     *            a fifth source Publisher
     * @param source6
     *            a sixth source Publisher
     * @param source7
     *            a seventh source Publisher
     * @param zipper
     *            a function that, when applied to an item emitted by each of the source Publishers, results in
     *            an item that will be emitted by the resulting Publisher
     * @return a Flowable that emits the zipped results
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/zip.html&quot;&gt;ReactiveX operators documentation: Zip&lt;/a&gt;
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T1, T2, T3, T4, T5, T6, T7, R&gt; Flowable&lt;R&gt; zip(
            Publisher&lt;? extends T1&gt; source1, Publisher&lt;? extends T2&gt; source2, Publisher&lt;? extends T3&gt; source3,
            Publisher&lt;? extends T4&gt; source4, Publisher&lt;? extends T5&gt; source5, Publisher&lt;? extends T6&gt; source6,
            Publisher&lt;? extends T7&gt; source7,
            Function7&lt;? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? extends R&gt; zipper) {
<span class="fc" id="L5149">        ObjectHelper.requireNonNull(source1, &quot;source1 is null&quot;);</span>
<span class="fc" id="L5150">        ObjectHelper.requireNonNull(source2, &quot;source2 is null&quot;);</span>
<span class="fc" id="L5151">        ObjectHelper.requireNonNull(source3, &quot;source3 is null&quot;);</span>
<span class="fc" id="L5152">        ObjectHelper.requireNonNull(source4, &quot;source4 is null&quot;);</span>
<span class="fc" id="L5153">        ObjectHelper.requireNonNull(source5, &quot;source5 is null&quot;);</span>
<span class="fc" id="L5154">        ObjectHelper.requireNonNull(source6, &quot;source6 is null&quot;);</span>
<span class="fc" id="L5155">        ObjectHelper.requireNonNull(source7, &quot;source7 is null&quot;);</span>
<span class="fc" id="L5156">        return zipArray(Functions.toFunction(zipper), false, bufferSize(), source1, source2, source3, source4, source5, source6, source7);</span>
    }

    /**
     * Returns a Flowable that emits the results of a specified combiner function applied to combinations of
     * eight items emitted, in sequence, by eight other Publishers.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/zip.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * {@code zip} applies this function in strict sequence, so the first item emitted by the new Publisher
     * will be the result of the function applied to the first item emitted by each source Publisher, the
     * second item emitted by the new Publisher will be the result of the function applied to the second item
     * emitted by each of those Publishers, and so forth.
     * &lt;p&gt;
     * The resulting {@code Publisher&lt;R&gt;} returned from {@code zip} will invoke {@link Subscriber#onNext onNext}
     * as many times as the number of {@code onNext} invocations of the source Publisher that emits the fewest
     * items.
     * &lt;p&gt;
     * The operator subscribes to its sources in the order they are specified and completes eagerly if
     * one of the sources is shorter than the rest while canceling the other sources. Therefore, it
     * is possible those other sources will never be able to run to completion (and thus not calling
     * {@code doOnComplete()}). This can also happen if the sources are exactly the same length; if
     * source A completes and B has been consumed and is about to complete, the operator detects A won't
     * be sending further values and it will cancel B immediately. For example:
     * &lt;pre&gt;&lt;code&gt;zip(range(1, 5).doOnComplete(action1), range(6, 5).doOnComplete(action2), ..., (a, b, c, d, e, f, g, h) -&amp;gt; a + b)&lt;/code&gt;&lt;/pre&gt;
     * {@code action1} will be called but {@code action2} won't.
     * &lt;br&gt;To work around this termination property,
     * use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completion
     * or cancellation.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator expects backpressure from the sources and honors backpressure from the downstream.
     *  (I.e., zipping with {@link #interval(long, TimeUnit)} may result in MissingBackpressureException, use
     *  one of the {@code onBackpressureX} to handle similar, backpressure-ignoring sources.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code zip} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T1&gt; the value type of the first source
     * @param &lt;T2&gt; the value type of the second source
     * @param &lt;T3&gt; the value type of the third source
     * @param &lt;T4&gt; the value type of the fourth source
     * @param &lt;T5&gt; the value type of the fifth source
     * @param &lt;T6&gt; the value type of the sixth source
     * @param &lt;T7&gt; the value type of the seventh source
     * @param &lt;T8&gt; the value type of the eighth source
     * @param &lt;R&gt; the zipped result type
     * @param source1
     *            the first source Publisher
     * @param source2
     *            a second source Publisher
     * @param source3
     *            a third source Publisher
     * @param source4
     *            a fourth source Publisher
     * @param source5
     *            a fifth source Publisher
     * @param source6
     *            a sixth source Publisher
     * @param source7
     *            a seventh source Publisher
     * @param source8
     *            an eighth source Publisher
     * @param zipper
     *            a function that, when applied to an item emitted by each of the source Publishers, results in
     *            an item that will be emitted by the resulting Publisher
     * @return a Flowable that emits the zipped results
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/zip.html&quot;&gt;ReactiveX operators documentation: Zip&lt;/a&gt;
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T1, T2, T3, T4, T5, T6, T7, T8, R&gt; Flowable&lt;R&gt; zip(
            Publisher&lt;? extends T1&gt; source1, Publisher&lt;? extends T2&gt; source2, Publisher&lt;? extends T3&gt; source3,
            Publisher&lt;? extends T4&gt; source4, Publisher&lt;? extends T5&gt; source5, Publisher&lt;? extends T6&gt; source6,
            Publisher&lt;? extends T7&gt; source7, Publisher&lt;? extends T8&gt; source8,
            Function8&lt;? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? super T8, ? extends R&gt; zipper) {
<span class="fc" id="L5235">        ObjectHelper.requireNonNull(source1, &quot;source1 is null&quot;);</span>
<span class="fc" id="L5236">        ObjectHelper.requireNonNull(source2, &quot;source2 is null&quot;);</span>
<span class="fc" id="L5237">        ObjectHelper.requireNonNull(source3, &quot;source3 is null&quot;);</span>
<span class="fc" id="L5238">        ObjectHelper.requireNonNull(source4, &quot;source4 is null&quot;);</span>
<span class="fc" id="L5239">        ObjectHelper.requireNonNull(source5, &quot;source5 is null&quot;);</span>
<span class="fc" id="L5240">        ObjectHelper.requireNonNull(source6, &quot;source6 is null&quot;);</span>
<span class="fc" id="L5241">        ObjectHelper.requireNonNull(source7, &quot;source7 is null&quot;);</span>
<span class="fc" id="L5242">        ObjectHelper.requireNonNull(source8, &quot;source8 is null&quot;);</span>
<span class="fc" id="L5243">        return zipArray(Functions.toFunction(zipper), false, bufferSize(), source1, source2, source3, source4, source5, source6, source7, source8);</span>
    }

    /**
     * Returns a Flowable that emits the results of a specified combiner function applied to combinations of
     * nine items emitted, in sequence, by nine other Publishers.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/zip.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * {@code zip} applies this function in strict sequence, so the first item emitted by the new Publisher
     * will be the result of the function applied to the first item emitted by each source Publisher, the
     * second item emitted by the new Publisher will be the result of the function applied to the second item
     * emitted by each of those Publishers, and so forth.
     * &lt;p&gt;
     * The resulting {@code Publisher&lt;R&gt;} returned from {@code zip} will invoke {@link Subscriber#onNext onNext}
     * as many times as the number of {@code onNext} invocations of the source Publisher that emits the fewest
     * items.
     * &lt;p&gt;
     * The operator subscribes to its sources in the order they are specified and completes eagerly if
     * one of the sources is shorter than the rest while canceling the other sources. Therefore, it
     * is possible those other sources will never be able to run to completion (and thus not calling
     * {@code doOnComplete()}). This can also happen if the sources are exactly the same length; if
     * source A completes and B has been consumed and is about to complete, the operator detects A won't
     * be sending further values and it will cancel B immediately. For example:
     * &lt;pre&gt;&lt;code&gt;zip(range(1, 5).doOnComplete(action1), range(6, 5).doOnComplete(action2), ..., (a, b, c, d, e, f, g, h, i) -&amp;gt; a + b)&lt;/code&gt;&lt;/pre&gt;
     * {@code action1} will be called but {@code action2} won't.
     * &lt;br&gt;To work around this termination property,
     * use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completion
     * or cancellation.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator expects backpressure from the sources and honors backpressure from the downstream.
     *  (I.e., zipping with {@link #interval(long, TimeUnit)} may result in MissingBackpressureException, use
     *  one of the {@code onBackpressureX} to handle similar, backpressure-ignoring sources.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code zip} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T1&gt; the value type of the first source
     * @param &lt;T2&gt; the value type of the second source
     * @param &lt;T3&gt; the value type of the third source
     * @param &lt;T4&gt; the value type of the fourth source
     * @param &lt;T5&gt; the value type of the fifth source
     * @param &lt;T6&gt; the value type of the sixth source
     * @param &lt;T7&gt; the value type of the seventh source
     * @param &lt;T8&gt; the value type of the eighth source
     * @param &lt;T9&gt; the value type of the ninth source
     * @param &lt;R&gt; the zipped result type
     * @param source1
     *            the first source Publisher
     * @param source2
     *            a second source Publisher
     * @param source3
     *            a third source Publisher
     * @param source4
     *            a fourth source Publisher
     * @param source5
     *            a fifth source Publisher
     * @param source6
     *            a sixth source Publisher
     * @param source7
     *            a seventh source Publisher
     * @param source8
     *            an eighth source Publisher
     * @param source9
     *            a ninth source Publisher
     * @param zipper
     *            a function that, when applied to an item emitted by each of the source Publishers, results in
     *            an item that will be emitted by the resulting Publisher
     * @return a Flowable that emits the zipped results
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/zip.html&quot;&gt;ReactiveX operators documentation: Zip&lt;/a&gt;
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T1, T2, T3, T4, T5, T6, T7, T8, T9, R&gt; Flowable&lt;R&gt; zip(
            Publisher&lt;? extends T1&gt; source1, Publisher&lt;? extends T2&gt; source2, Publisher&lt;? extends T3&gt; source3,
            Publisher&lt;? extends T4&gt; source4, Publisher&lt;? extends T5&gt; source5, Publisher&lt;? extends T6&gt; source6,
            Publisher&lt;? extends T7&gt; source7, Publisher&lt;? extends T8&gt; source8, Publisher&lt;? extends T9&gt; source9,
            Function9&lt;? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? super T8, ? super T9, ? extends R&gt; zipper) {

<span class="fc" id="L5326">        ObjectHelper.requireNonNull(source1, &quot;source1 is null&quot;);</span>
<span class="fc" id="L5327">        ObjectHelper.requireNonNull(source2, &quot;source2 is null&quot;);</span>
<span class="fc" id="L5328">        ObjectHelper.requireNonNull(source3, &quot;source3 is null&quot;);</span>
<span class="fc" id="L5329">        ObjectHelper.requireNonNull(source4, &quot;source4 is null&quot;);</span>
<span class="fc" id="L5330">        ObjectHelper.requireNonNull(source5, &quot;source5 is null&quot;);</span>
<span class="fc" id="L5331">        ObjectHelper.requireNonNull(source6, &quot;source6 is null&quot;);</span>
<span class="fc" id="L5332">        ObjectHelper.requireNonNull(source7, &quot;source7 is null&quot;);</span>
<span class="fc" id="L5333">        ObjectHelper.requireNonNull(source8, &quot;source8 is null&quot;);</span>
<span class="fc" id="L5334">        ObjectHelper.requireNonNull(source9, &quot;source9 is null&quot;);</span>
<span class="fc" id="L5335">        return zipArray(Functions.toFunction(zipper), false, bufferSize(), source1, source2, source3, source4, source5, source6, source7, source8, source9);</span>
    }

    /**
     * Returns a Flowable that emits the results of a specified combiner function applied to combinations of
     * items emitted, in sequence, by an array of other Publishers.
     * &lt;p&gt;
     * {@code zip} applies this function in strict sequence, so the first item emitted by the new Publisher
     * will be the result of the function applied to the first item emitted by each of the source Publishers;
     * the second item emitted by the new Publisher will be the result of the function applied to the second
     * item emitted by each of those Publishers; and so forth.
     * &lt;p&gt;
     * The resulting {@code Publisher&lt;R&gt;} returned from {@code zip} will invoke {@code onNext} as many times as
     * the number of {@code onNext} invocations of the source Publisher that emits the fewest items.
     * &lt;p&gt;
     * The operator subscribes to its sources in the order they are specified and completes eagerly if
     * one of the sources is shorter than the rest while canceling the other sources. Therefore, it
     * is possible those other sources will never be able to run to completion (and thus not calling
     * {@code doOnComplete()}). This can also happen if the sources are exactly the same length; if
     * source A completes and B has been consumed and is about to complete, the operator detects A won't
     * be sending further values and it will cancel B immediately. For example:
     * &lt;pre&gt;&lt;code&gt;zip(new Publisher[]{range(1, 5).doOnComplete(action1), range(6, 5).doOnComplete(action2)}, (a) -&amp;gt;
     * a)&lt;/code&gt;&lt;/pre&gt;
     * {@code action1} will be called but {@code action2} won't.
     * &lt;br&gt;To work around this termination property,
     * use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completion
     * or cancellation.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/zip.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator expects backpressure from the sources and honors backpressure from the downstream.
     *  (I.e., zipping with {@link #interval(long, TimeUnit)} may result in MissingBackpressureException, use
     *  one of the {@code onBackpressureX} to handle similar, backpressure-ignoring sources.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code zipArray} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T&gt; the common element type
     * @param &lt;R&gt; the result type
     * @param sources
     *            an array of source Publishers
     * @param zipper
     *            a function that, when applied to an item emitted by each of the source Publishers, results in
     *            an item that will be emitted by the resulting Publisher
     * @param delayError
     *            delay errors signaled by any of the source Publisher until all Publishers terminate
     * @param bufferSize
     *            the number of elements to prefetch from each source Publisher
     * @return a Flowable that emits the zipped results
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/zip.html&quot;&gt;ReactiveX operators documentation: Zip&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T, R&gt; Flowable&lt;R&gt; zipArray(Function&lt;? super Object[], ? extends R&gt; zipper,
            boolean delayError, int bufferSize, Publisher&lt;? extends T&gt;... sources) {
<span class="fc bfc" id="L5393" title="All 2 branches covered.">        if (sources.length == 0) {</span>
<span class="fc" id="L5394">            return empty();</span>
        }
<span class="fc" id="L5396">        ObjectHelper.requireNonNull(zipper, &quot;zipper is null&quot;);</span>
<span class="fc" id="L5397">        ObjectHelper.verifyPositive(bufferSize, &quot;bufferSize&quot;);</span>
<span class="fc" id="L5398">        return RxJavaPlugins.onAssembly(new FlowableZip&lt;T, R&gt;(sources, null, zipper, bufferSize, delayError));</span>
    }

    /**
     * Returns a Flowable that emits the results of a specified combiner function applied to combinations of
     * items emitted, in sequence, by an Iterable of other Publishers.
     * &lt;p&gt;
     * {@code zip} applies this function in strict sequence, so the first item emitted by the new Publisher
     * will be the result of the function applied to the first item emitted by each of the source Publishers;
     * the second item emitted by the new Publisher will be the result of the function applied to the second
     * item emitted by each of those Publishers; and so forth.
     * &lt;p&gt;
     * The resulting {@code Publisher&lt;R&gt;} returned from {@code zip} will invoke {@code onNext} as many times as
     * the number of {@code onNext} invocations of the source Publisher that emits the fewest items.
     * &lt;p&gt;
     * The operator subscribes to its sources in the order they are specified and completes eagerly if
     * one of the sources is shorter than the rest while canceling the other sources. Therefore, it
     * is possible those other sources will never be able to run to completion (and thus not calling
     * {@code doOnComplete()}). This can also happen if the sources are exactly the same length; if
     * source A completes and B has been consumed and is about to complete, the operator detects A won't
     * be sending further values and it will cancel B immediately. For example:
     * &lt;pre&gt;&lt;code&gt;zip(Arrays.asList(range(1, 5).doOnComplete(action1), range(6, 5).doOnComplete(action2)), (a) -&amp;gt; a)&lt;/code&gt;&lt;/pre&gt;
     * {@code action1} will be called but {@code action2} won't.
     * &lt;br&gt;To work around this termination property,
     * use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completion
     * or cancellation.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/zip.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator expects backpressure from the sources and honors backpressure from the downstream.
     *  (I.e., zipping with {@link #interval(long, TimeUnit)} may result in MissingBackpressureException, use
     *  one of the {@code onBackpressureX} to handle similar, backpressure-ignoring sources.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code zipIterable} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     *
     * @param sources
     *            an Iterable of source Publishers
     * @param zipper
     *            a function that, when applied to an item emitted by each of the source Publishers, results in
     *            an item that will be emitted by the resulting Publisher
     * @param delayError
     *            delay errors signaled by any of the source Publisher until all Publishers terminate
     * @param bufferSize
     *            the number of elements to prefetch from each source Publisher
     * @param &lt;T&gt; the common source value type
     * @param &lt;R&gt; the zipped result type
     * @return a Flowable that emits the zipped results
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/zip.html&quot;&gt;ReactiveX operators documentation: Zip&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T, R&gt; Flowable&lt;R&gt; zipIterable(Iterable&lt;? extends Publisher&lt;? extends T&gt;&gt; sources,
            Function&lt;? super Object[], ? extends R&gt; zipper, boolean delayError,
            int bufferSize) {
<span class="fc" id="L5457">        ObjectHelper.requireNonNull(zipper, &quot;zipper is null&quot;);</span>
<span class="fc" id="L5458">        ObjectHelper.requireNonNull(sources, &quot;sources is null&quot;);</span>
<span class="fc" id="L5459">        ObjectHelper.verifyPositive(bufferSize, &quot;bufferSize&quot;);</span>
<span class="fc" id="L5460">        return RxJavaPlugins.onAssembly(new FlowableZip&lt;T, R&gt;(null, sources, zipper, bufferSize, delayError));</span>
    }

    // ***************************************************************************************************
    // Instance operators
    // ***************************************************************************************************

    /**
     * Returns a Single that emits a Boolean that indicates whether all of the items emitted by the source
     * Publisher satisfy a condition.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;315&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/all.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream and consumes the source {@code Publisher} in an unbounded
     *  manner (i.e., without applying backpressure).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code all} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param predicate
     *            a function that evaluates an item and returns a Boolean
     * @return a Single that emits {@code true} if all items emitted by the source Publisher satisfy the
     *         predicate; otherwise, {@code false}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/all.html&quot;&gt;ReactiveX operators documentation: All&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Single&lt;Boolean&gt; all(Predicate&lt;? super T&gt; predicate) {
<span class="fc" id="L5491">        ObjectHelper.requireNonNull(predicate, &quot;predicate is null&quot;);</span>
<span class="fc" id="L5492">        return RxJavaPlugins.onAssembly(new FlowableAllSingle&lt;T&gt;(this, predicate));</span>
    }

    /**
     * Mirrors the Publisher (current or provided) that first either emits an item or sends a termination
     * notification.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;385&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/amb.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator itself doesn't interfere with backpressure which is determined by the winning
     *  {@code Publisher}'s backpressure behavior.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code ambWith} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param other
     *            a Publisher competing to react first. A subscription to this provided Publisher will occur after subscribing
     *            to the current Publisher.
     * @return a Flowable that emits the same sequence as whichever of the source Publishers first
     *         emitted an item or sent a termination notification
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/amb.html&quot;&gt;ReactiveX operators documentation: Amb&lt;/a&gt;
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;T&gt; ambWith(Publisher&lt;? extends T&gt; other) {
<span class="fc" id="L5521">        ObjectHelper.requireNonNull(other, &quot;other is null&quot;);</span>
<span class="fc" id="L5522">        return ambArray(this, other);</span>
    }

    /**
     * Returns a Single that emits {@code true} if any item emitted by the source Publisher satisfies a
     * specified condition, otherwise {@code false}. &lt;em&gt;Note:&lt;/em&gt; this always emits {@code false} if the
     * source Publisher is empty.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;320&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/exists.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * In Rx.Net this is the {@code any} operator but we renamed it in RxJava to better match Java naming
     * idioms.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream and consumes the source {@code Publisher} in an unbounded manner
     *  (i.e., no backpressure applied to it).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code any} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param predicate
     *            the condition to test items emitted by the source Publisher
     * @return a Single that emits a Boolean that indicates whether any item emitted by the source
     *         Publisher satisfies the {@code predicate}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/contains.html&quot;&gt;ReactiveX operators documentation: Contains&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Single&lt;Boolean&gt; any(Predicate&lt;? super T&gt; predicate) {
<span class="fc" id="L5553">        ObjectHelper.requireNonNull(predicate, &quot;predicate is null&quot;);</span>
<span class="fc" id="L5554">        return RxJavaPlugins.onAssembly(new FlowableAnySingle&lt;T&gt;(this, predicate));</span>
    }

    /**
     * Calls the specified converter function during assembly time and returns its resulting value.
     * &lt;p&gt;
     * This allows fluent conversion to any other type.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The backpressure behavior depends on what happens in the {@code converter} function.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code as} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * &lt;p&gt;History: 2.1.7 - experimental
     * @param &lt;R&gt; the resulting object type
     * @param converter the function that receives the current Flowable instance and returns a value
     * @return the converted value
     * @throws NullPointerException if converter is null
     * @since 2.2
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.SPECIAL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;R&gt; R as(@NonNull FlowableConverter&lt;T, ? extends R&gt; converter) {
<span class="fc" id="L5578">        return ObjectHelper.requireNonNull(converter, &quot;converter is null&quot;).apply(this);</span>
    }

    /**
     * Returns the first item emitted by this {@code Flowable}, or throws
     * {@code NoSuchElementException} if it emits no items.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator consumes the source {@code Flowable} in an unbounded manner
     *  (i.e., no backpressure applied to it).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code blockingFirst} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Error handling:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;If the source signals an error, the operator wraps a checked {@link Exception}
     *  into {@link RuntimeException} and throws that. Otherwise, {@code RuntimeException}s and
     *  {@link Error}s are rethrown as they are.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @return the first item emitted by this {@code Flowable}
     * @throws NoSuchElementException
     *             if this {@code Flowable} emits no items
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/first.html&quot;&gt;ReactiveX documentation: First&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final T blockingFirst() {
<span class="fc" id="L5605">        BlockingFirstSubscriber&lt;T&gt; s = new BlockingFirstSubscriber&lt;T&gt;();</span>
<span class="fc" id="L5606">        subscribe(s);</span>
<span class="fc" id="L5607">        T v = s.blockingGet();</span>
<span class="fc bfc" id="L5608" title="All 2 branches covered.">        if (v != null) {</span>
<span class="fc" id="L5609">            return v;</span>
        }
<span class="fc" id="L5611">        throw new NoSuchElementException();</span>
    }

    /**
     * Returns the first item emitted by this {@code Flowable}, or a default value if it emits no
     * items.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator consumes the source {@code Flowable} in an unbounded manner
     *  (i.e., no backpressure applied to it).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code blockingFirst} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Error handling:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;If the source signals an error, the operator wraps a checked {@link Exception}
     *  into {@link RuntimeException} and throws that. Otherwise, {@code RuntimeException}s and
     *  {@link Error}s are rethrown as they are.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param defaultItem
     *            a default value to return if this {@code Flowable} emits no items
     * @return the first item emitted by this {@code Flowable}, or the default value if it emits no
     *         items
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/first.html&quot;&gt;ReactiveX documentation: First&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final T blockingFirst(T defaultItem) {
<span class="fc" id="L5639">        BlockingFirstSubscriber&lt;T&gt; s = new BlockingFirstSubscriber&lt;T&gt;();</span>
<span class="fc" id="L5640">        subscribe(s);</span>
<span class="fc" id="L5641">        T v = s.blockingGet();</span>
<span class="fc bfc" id="L5642" title="All 2 branches covered.">        return v != null ? v : defaultItem;</span>
    }

    /**
     * Consumes the upstream {@code Flowable} in a blocking fashion and invokes the given
     * {@code Consumer} with each upstream item on the &lt;em&gt;current thread&lt;/em&gt; until the
     * upstream terminates.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;330&quot; src=&quot;https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/B.forEach.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * &lt;em&gt;Note:&lt;/em&gt; the method will only return if the upstream terminates or the current
     * thread is interrupted.
     * &lt;p&gt;
     * This method executes the {@code Consumer} on the current thread while
     * {@link #subscribe(Consumer)} executes the consumer on the original caller thread of the
     * sequence.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator consumes the source {@code Flowable} in an unbounded manner
     *  (i.e., no backpressure applied to it).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code blockingForEach} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Error handling:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;If the source signals an error, the operator wraps a checked {@link Exception}
     *  into {@link RuntimeException} and throws that. Otherwise, {@code RuntimeException}s and
     *  {@link Error}s are rethrown as they are.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param onNext
     *            the {@link Consumer} to invoke for each item emitted by the {@code Flowable}
     * @throws RuntimeException
     *             if an error occurs
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/subscribe.html&quot;&gt;ReactiveX documentation: Subscribe&lt;/a&gt;
     * @see #subscribe(Consumer)
     */
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final void blockingForEach(Consumer&lt;? super T&gt; onNext) {
<span class="fc" id="L5680">        Iterator&lt;T&gt; it = blockingIterable().iterator();</span>
<span class="fc bfc" id="L5681" title="All 2 branches covered.">        while (it.hasNext()) {</span>
            try {
<span class="fc" id="L5683">                onNext.accept(it.next());</span>
<span class="fc" id="L5684">            } catch (Throwable e) {</span>
<span class="fc" id="L5685">                Exceptions.throwIfFatal(e);</span>
<span class="fc" id="L5686">                ((Disposable)it).dispose();</span>
<span class="fc" id="L5687">                throw ExceptionHelper.wrapOrThrow(e);</span>
<span class="fc" id="L5688">            }</span>
        }
<span class="fc" id="L5690">    }</span>

    /**
     * Converts this {@code Flowable} into an {@link Iterable}.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;315&quot; src=&quot;https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/B.toIterable.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator expects the upstream to honor backpressure otherwise the returned
     *  Iterable's iterator will throw a {@code MissingBackpressureException}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code blockingIterable} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @return an {@link Iterable} version of this {@code Flowable}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/to.html&quot;&gt;ReactiveX documentation: To&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Iterable&lt;T&gt; blockingIterable() {
<span class="fc" id="L5711">        return blockingIterable(bufferSize());</span>
    }

    /**
     * Converts this {@code Flowable} into an {@link Iterable}.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;315&quot; src=&quot;https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/B.toIterable.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator expects the upstream to honor backpressure otherwise the returned
     *  Iterable's iterator will throw a {@code MissingBackpressureException}.
     *  &lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code blockingIterable} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param bufferSize the number of items to prefetch from the current Flowable
     * @return an {@link Iterable} version of this {@code Flowable}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/to.html&quot;&gt;ReactiveX documentation: To&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Iterable&lt;T&gt; blockingIterable(int bufferSize) {
<span class="fc" id="L5735">        ObjectHelper.verifyPositive(bufferSize, &quot;bufferSize&quot;);</span>
<span class="fc" id="L5736">        return new BlockingFlowableIterable&lt;T&gt;(this, bufferSize);</span>
    }

    /**
     * Returns the last item emitted by this {@code Flowable}, or throws
     * {@code NoSuchElementException} if this {@code Flowable} emits no items.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;315&quot; src=&quot;https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/B.last.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator consumes the source {@code Flowable} in an unbounded manner
     *  (i.e., no backpressure applied to it).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code blockingLast} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Error handling:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;If the source signals an error, the operator wraps a checked {@link Exception}
     *  into {@link RuntimeException} and throws that. Otherwise, {@code RuntimeException}s and
     *  {@link Error}s are rethrown as they are.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @return the last item emitted by this {@code Flowable}
     * @throws NoSuchElementException
     *             if this {@code Flowable} emits no items
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/last.html&quot;&gt;ReactiveX documentation: Last&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final T blockingLast() {
<span class="fc" id="L5765">        BlockingLastSubscriber&lt;T&gt; s = new BlockingLastSubscriber&lt;T&gt;();</span>
<span class="fc" id="L5766">        subscribe(s);</span>
<span class="fc" id="L5767">        T v = s.blockingGet();</span>
<span class="fc bfc" id="L5768" title="All 2 branches covered.">        if (v != null) {</span>
<span class="fc" id="L5769">            return v;</span>
        }
<span class="fc" id="L5771">        throw new NoSuchElementException();</span>
    }

    /**
     * Returns the last item emitted by this {@code Flowable}, or a default value if it emits no
     * items.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/B.lastOrDefault.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator consumes the source {@code Flowable} in an unbounded manner
     *  (i.e., no backpressure applied to it).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code blockingLast} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Error handling:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;If the source signals an error, the operator wraps a checked {@link Exception}
     *  into {@link RuntimeException} and throws that. Otherwise, {@code RuntimeException}s and
     *  {@link Error}s are rethrown as they are.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param defaultItem
     *            a default value to return if this {@code Flowable} emits no items
     * @return the last item emitted by the {@code Flowable}, or the default value if it emits no
     *         items
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/last.html&quot;&gt;ReactiveX documentation: Last&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final T blockingLast(T defaultItem) {
<span class="fc" id="L5801">        BlockingLastSubscriber&lt;T&gt; s = new BlockingLastSubscriber&lt;T&gt;();</span>
<span class="fc" id="L5802">        subscribe(s);</span>
<span class="fc" id="L5803">        T v = s.blockingGet();</span>
<span class="fc bfc" id="L5804" title="All 2 branches covered.">        return v != null ? v : defaultItem;</span>
    }

    /**
     * Returns an {@link Iterable} that returns the latest item emitted by this {@code Flowable},
     * waiting if necessary for one to become available.
     * &lt;p&gt;
     * If this {@code Flowable} produces items faster than {@code Iterator.next} takes them,
     * {@code onNext} events might be skipped, but {@code onError} or {@code onComplete} events are not.
     * &lt;p&gt;
     * Note also that an {@code onNext} directly followed by {@code onComplete} might hide the {@code onNext}
     * event.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator consumes the source {@code Flowable} in an unbounded manner
     *  (i.e., no backpressure applied to it).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code blockingLatest} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @return an Iterable that always returns the latest item emitted by this {@code Flowable}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/first.html&quot;&gt;ReactiveX documentation: First&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Iterable&lt;T&gt; blockingLatest() {
<span class="fc" id="L5831">        return new BlockingFlowableLatest&lt;T&gt;(this);</span>
    }

    /**
     * Returns an {@link Iterable} that always returns the item most recently emitted by this
     * {@code Flowable}.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;490&quot; src=&quot;https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/B.mostRecent.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator consumes the source {@code Flowable} in an unbounded manner
     *  (i.e., no backpressure applied to it).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code blockingMostRecent} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param initialItem
     *            the initial item that the {@link Iterable} sequence will yield if this
     *            {@code Flowable} has not yet emitted an item
     * @return an {@link Iterable} that on each iteration returns the item that this {@code Flowable}
     *         has most recently emitted
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/first.html&quot;&gt;ReactiveX documentation: First&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Iterable&lt;T&gt; blockingMostRecent(T initialItem) {
<span class="fc" id="L5858">        return new BlockingFlowableMostRecent&lt;T&gt;(this, initialItem);</span>
    }

    /**
     * Returns an {@link Iterable} that blocks until this {@code Flowable} emits another item, then
     * returns that item.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;490&quot; src=&quot;https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/B.next.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator consumes the source {@code Flowable} in an unbounded manner
     *  (i.e., no backpressure applied to it).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code blockingNext} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @return an {@link Iterable} that blocks upon each iteration until this {@code Flowable} emits
     *         a new item, whereupon the Iterable returns that item
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/takelast.html&quot;&gt;ReactiveX documentation: TakeLast&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Iterable&lt;T&gt; blockingNext() {
<span class="fc" id="L5882">        return new BlockingFlowableNext&lt;T&gt;(this);</span>
    }

    /**
     * If this {@code Flowable} completes after emitting a single item, return that item, otherwise
     * throw a {@code NoSuchElementException}.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;315&quot; src=&quot;https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/B.single.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator consumes the source {@code Flowable} in an unbounded manner
     *  (i.e., no backpressure applied to it).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code blockingSingle} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Error handling:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;If the source signals an error, the operator wraps a checked {@link Exception}
     *  into {@link RuntimeException} and throws that. Otherwise, {@code RuntimeException}s and
     *  {@link Error}s are rethrown as they are.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @return the single item emitted by this {@code Flowable}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/first.html&quot;&gt;ReactiveX documentation: First&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final T blockingSingle() {
<span class="fc" id="L5909">        return singleOrError().blockingGet();</span>
    }

    /**
     * If this {@code Flowable} completes after emitting a single item, return that item; if it emits
     * more than one item, throw an {@code IllegalArgumentException}; if it emits no items, return a default
     * value.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;315&quot; src=&quot;https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/B.singleOrDefault.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator consumes the source {@code Flowable} in an unbounded manner
     *  (i.e., no backpressure applied to it).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code blockingSingle} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Error handling:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;If the source signals an error, the operator wraps a checked {@link Exception}
     *  into {@link RuntimeException} and throws that. Otherwise, {@code RuntimeException}s and
     *  {@link Error}s are rethrown as they are.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param defaultItem
     *            a default value to return if this {@code Flowable} emits no items
     * @return the single item emitted by this {@code Flowable}, or the default value if it emits no
     *         items
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/first.html&quot;&gt;ReactiveX documentation: First&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final T blockingSingle(T defaultItem) {
<span class="fc" id="L5940">        return single(defaultItem).blockingGet();</span>
    }

    /**
     * Returns a {@link Future} representing the only value emitted by this {@code Flowable}.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;324&quot; src=&quot;https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/Flowable.toFuture.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * If the {@link Flowable} emits more than one item, {@link java.util.concurrent.Future} will receive an
     * {@link java.lang.IndexOutOfBoundsException}. If the {@link Flowable} is empty, {@link java.util.concurrent.Future}
     * will receive a {@link java.util.NoSuchElementException}. The {@code Flowable} source has to terminate in order
     * for the returned {@code Future} to terminate as well.
     * &lt;p&gt;
     * If the {@code Flowable} may emit more than one item, use {@code Flowable.toList().toFuture()}.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator consumes the source {@code Flowable} in an unbounded manner
     *  (i.e., no backpressure applied to it).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code toFuture} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @return a {@link Future} that expects a single item to be emitted by this {@code Flowable}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/to.html&quot;&gt;ReactiveX documentation: To&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Future&lt;T&gt; toFuture() {
<span class="fc" id="L5969">        return subscribeWith(new FutureSubscriber&lt;T&gt;());</span>
    }

    /**
     * Runs the source Flowable to a terminal event, ignoring any values and rethrowing any exception.
     * &lt;p&gt;
     * Note that calling this method will block the caller thread until the upstream terminates
     * normally or with an error. Therefore, calling this method from special threads such as the
     * Android Main Thread or the Swing Event Dispatch Thread is not recommended.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator consumes the source {@code Flowable} in an unbounded manner
     *  (i.e., no backpressure applied to it).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code blockingSubscribe} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @since 2.0
     * @see #blockingSubscribe(Consumer)
     * @see #blockingSubscribe(Consumer, Consumer)
     * @see #blockingSubscribe(Consumer, Consumer, Action)
     */
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final void blockingSubscribe() {
<span class="fc" id="L5993">        FlowableBlockingSubscribe.subscribe(this);</span>
<span class="fc" id="L5994">    }</span>

    /**
     * Subscribes to the source and calls the given callbacks &lt;strong&gt;on the current thread&lt;/strong&gt;.
     * &lt;p&gt;
     * If the Flowable emits an error, it is wrapped into an
     * {@link io.reactivex.exceptions.OnErrorNotImplementedException OnErrorNotImplementedException}
     * and routed to the RxJavaPlugins.onError handler.
     * Using the overloads {@link #blockingSubscribe(Consumer, Consumer)}
     * or {@link #blockingSubscribe(Consumer, Consumer, Action)} instead is recommended.
     * &lt;p&gt;
     * Note that calling this method will block the caller thread until the upstream terminates
     * normally or with an error. Therefore, calling this method from special threads such as the
     * Android Main Thread or the Swing Event Dispatch Thread is not recommended.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator consumes the source {@code Flowable} in an unbounded manner
     *  (i.e., no backpressure applied to it).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code blockingSubscribe} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param onNext the callback action for each source value
     * @since 2.0
     * @see #blockingSubscribe(Consumer, Consumer)
     * @see #blockingSubscribe(Consumer, Consumer, Action)
     */
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final void blockingSubscribe(Consumer&lt;? super T&gt; onNext) {
<span class="fc" id="L6023">        FlowableBlockingSubscribe.subscribe(this, onNext, Functions.ON_ERROR_MISSING, Functions.EMPTY_ACTION);</span>
<span class="fc" id="L6024">    }</span>

    /**
     * Subscribes to the source and calls the given callbacks &lt;strong&gt;on the current thread&lt;/strong&gt;.
     * &lt;p&gt;
     * If the Flowable emits an error, it is wrapped into an
     * {@link io.reactivex.exceptions.OnErrorNotImplementedException OnErrorNotImplementedException}
     * and routed to the RxJavaPlugins.onError handler.
     * Using the overloads {@link #blockingSubscribe(Consumer, Consumer)}
     * or {@link #blockingSubscribe(Consumer, Consumer, Action)} instead is recommended.
     * &lt;p&gt;
     * Note that calling this method will block the caller thread until the upstream terminates
     * normally or with an error. Therefore, calling this method from special threads such as the
     * Android Main Thread or the Swing Event Dispatch Thread is not recommended.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator consumes the source {@code Flowable} in an bounded manner (up to bufferSize
     *  outstanding request amount for items).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code blockingSubscribe} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * &lt;p&gt;History: 2.1.15 - experimental
     * @param onNext the callback action for each source value
     * @param bufferSize the size of the buffer
     * @see #blockingSubscribe(Consumer, Consumer)
     * @see #blockingSubscribe(Consumer, Consumer, Action)
     * @since 2.2
     */
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final void blockingSubscribe(Consumer&lt;? super T&gt; onNext, int bufferSize) {
<span class="fc" id="L6055">        FlowableBlockingSubscribe.subscribe(this, onNext, Functions.ON_ERROR_MISSING, Functions.EMPTY_ACTION, bufferSize);</span>
<span class="fc" id="L6056">    }</span>

    /**
     * Subscribes to the source and calls the given callbacks &lt;strong&gt;on the current thread&lt;/strong&gt;.
     * &lt;p&gt;
     * Note that calling this method will block the caller thread until the upstream terminates
     * normally or with an error. Therefore, calling this method from special threads such as the
     * Android Main Thread or the Swing Event Dispatch Thread is not recommended.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator consumes the source {@code Flowable} in an unbounded manner
     *  (i.e., no backpressure applied to it).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code blockingSubscribe} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param onNext the callback action for each source value
     * @param onError the callback action for an error event
     * @since 2.0
     * @see #blockingSubscribe(Consumer, Consumer, Action)
     */
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final void blockingSubscribe(Consumer&lt;? super T&gt; onNext, Consumer&lt;? super Throwable&gt; onError) {
<span class="fc" id="L6079">        FlowableBlockingSubscribe.subscribe(this, onNext, onError, Functions.EMPTY_ACTION);</span>
<span class="fc" id="L6080">    }</span>

    /**
     * Subscribes to the source and calls the given callbacks &lt;strong&gt;on the current thread&lt;/strong&gt;.
     * &lt;p&gt;
     * Note that calling this method will block the caller thread until the upstream terminates
     * normally or with an error. Therefore, calling this method from special threads such as the
     * Android Main Thread or the Swing Event Dispatch Thread is not recommended.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator consumes the source {@code Flowable} in an bounded manner (up to bufferSize
     *  outstanding request amount for items).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code blockingSubscribe} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * &lt;p&gt;History: 2.1.15 - experimental
     * @param onNext the callback action for each source value
     * @param onError the callback action for an error event
     * @param bufferSize the size of the buffer
     * @since 2.2
     * @see #blockingSubscribe(Consumer, Consumer, Action)
     */
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final void blockingSubscribe(Consumer&lt;? super T&gt; onNext, Consumer&lt;? super Throwable&gt; onError,
        int bufferSize) {
<span class="fc" id="L6106">        FlowableBlockingSubscribe.subscribe(this, onNext, onError, Functions.EMPTY_ACTION, bufferSize);</span>
<span class="fc" id="L6107">    }</span>

    /**
     * Subscribes to the source and calls the given callbacks &lt;strong&gt;on the current thread&lt;/strong&gt;.
     * &lt;p&gt;
     * Note that calling this method will block the caller thread until the upstream terminates
     * normally or with an error. Therefore, calling this method from special threads such as the
     * Android Main Thread or the Swing Event Dispatch Thread is not recommended.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator consumes the source {@code Flowable} in an unbounded manner
     *  (i.e., no backpressure applied to it).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code blockingSubscribe} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param onNext the callback action for each source value
     * @param onError the callback action for an error event
     * @param onComplete the callback action for the completion event.
     * @since 2.0
     */
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final void blockingSubscribe(Consumer&lt;? super T&gt; onNext, Consumer&lt;? super Throwable&gt; onError, Action onComplete) {
<span class="fc" id="L6130">        FlowableBlockingSubscribe.subscribe(this, onNext, onError, onComplete);</span>
<span class="fc" id="L6131">    }</span>

    /**
     * Subscribes to the source and calls the given callbacks &lt;strong&gt;on the current thread&lt;/strong&gt;.
     * &lt;p&gt;
     * Note that calling this method will block the caller thread until the upstream terminates
     * normally or with an error. Therefore, calling this method from special threads such as the
     * Android Main Thread or the Swing Event Dispatch Thread is not recommended.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator consumes the source {@code Flowable} in an bounded manner (up to bufferSize
     *  outstanding request amount for items).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code blockingSubscribe} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * &lt;p&gt;History: 2.1.15 - experimental
     * @param onNext the callback action for each source value
     * @param onError the callback action for an error event
     * @param onComplete the callback action for the completion event.
     * @param bufferSize the size of the buffer
     * @since 2.2
     */
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final void blockingSubscribe(Consumer&lt;? super T&gt; onNext, Consumer&lt;? super Throwable&gt; onError, Action onComplete,
        int bufferSize) {
<span class="fc" id="L6157">        FlowableBlockingSubscribe.subscribe(this, onNext, onError, onComplete, bufferSize);</span>
<span class="fc" id="L6158">    }</span>

    /**
     * Subscribes to the source and calls the {@link Subscriber} methods &lt;strong&gt;on the current thread&lt;/strong&gt;.
     * &lt;p&gt;
     * Note that calling this method will block the caller thread until the upstream terminates
     * normally, with an error or the {@code Subscriber} cancels the {@link Subscription} it receives via
     * {@link Subscriber#onSubscribe(Subscription)}.
     * Therefore, calling this method from special threads such as the
     * Android Main Thread or the Swing Event Dispatch Thread is not recommended.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The supplied {@code Subscriber} determines how backpressure is applied.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code blockingSubscribe} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * The cancellation and backpressure is composed through.
     * @param subscriber the subscriber to forward events and calls to in the current thread
     * @since 2.0
     */
    @BackpressureSupport(BackpressureKind.SPECIAL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final void blockingSubscribe(Subscriber&lt;? super T&gt; subscriber) {
<span class="fc" id="L6181">        FlowableBlockingSubscribe.subscribe(this, subscriber);</span>
<span class="fc" id="L6182">    }</span>

    /**
     * Returns a Flowable that emits buffers of items it collects from the source Publisher. The resulting
     * Publisher emits connected, non-overlapping buffers, each containing {@code count} items. When the source
     * Publisher completes, the resulting Publisher emits the current buffer and propagates the notification from the
     * source Publisher. Note that if the source Publisher issues an onError notification the event is passed on
     * immediately without first emitting the buffer it is in the process of assembling.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;320&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/buffer3.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream and expects the source {@code Publisher} to honor it as
     *  well, although not enforced; violation &lt;em&gt;may&lt;/em&gt; lead to {@code MissingBackpressureException} somewhere
     *  downstream.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code buffer} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param count
     *            the maximum number of items in each buffer before it should be emitted
     * @return a Flowable that emits connected, non-overlapping buffers, each containing at most
     *         {@code count} items from the source Publisher
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/buffer.html&quot;&gt;ReactiveX operators documentation: Buffer&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;List&lt;T&gt;&gt; buffer(int count) {
<span class="fc" id="L6211">        return buffer(count, count);</span>
    }

    /**
     * Returns a Flowable that emits buffers of items it collects from the source Publisher. The resulting
     * Publisher emits buffers every {@code skip} items, each containing {@code count} items. When the source
     * Publisher completes, the resulting Publisher emits the current buffer and propagates the notification from the
     * source Publisher. Note that if the source Publisher issues an onError notification the event is passed on
     * immediately without first emitting the buffer it is in the process of assembling.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;320&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/buffer4.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream and expects the source {@code Publisher} to honor it as
     *  well, although not enforced; violation &lt;em&gt;may&lt;/em&gt; lead to {@code MissingBackpressureException} somewhere
     *  downstream.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code buffer} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param count
     *            the maximum size of each buffer before it should be emitted
     * @param skip
     *            how many items emitted by the source Publisher should be skipped before starting a new
     *            buffer. Note that when {@code skip} and {@code count} are equal, this is the same operation as
     *            {@link #buffer(int)}.
     * @return a Flowable that emits buffers for every {@code skip} item from the source Publisher and
     *         containing at most {@code count} items
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/buffer.html&quot;&gt;ReactiveX operators documentation: Buffer&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;List&lt;T&gt;&gt; buffer(int count, int skip) {
<span class="fc" id="L6245">        return buffer(count, skip, ArrayListSupplier.&lt;T&gt;asCallable());</span>
    }

    /**
     * Returns a Flowable that emits buffers of items it collects from the source Publisher. The resulting
     * Publisher emits buffers every {@code skip} items, each containing {@code count} items. When the source
     * Publisher completes, the resulting Publisher emits the current buffer and propagates the notification from the
     * source Publisher. Note that if the source Publisher issues an onError notification the event is passed on
     * immediately without first emitting the buffer it is in the process of assembling.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;320&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/buffer4.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream and expects the source {@code Publisher} to honor it as
     *  well, although not enforced; violation &lt;em&gt;may&lt;/em&gt; lead to {@code MissingBackpressureException} somewhere
     *  downstream.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code buffer} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;U&gt; the collection subclass type to buffer into
     * @param count
     *            the maximum size of each buffer before it should be emitted
     * @param skip
     *            how many items emitted by the source Publisher should be skipped before starting a new
     *            buffer. Note that when {@code skip} and {@code count} are equal, this is the same operation as
     *            {@link #buffer(int)}.
     * @param bufferSupplier
     *            a factory function that returns an instance of the collection subclass to be used and returned
     *            as the buffer
     * @return a Flowable that emits buffers for every {@code skip} item from the source Publisher and
     *         containing at most {@code count} items
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/buffer.html&quot;&gt;ReactiveX operators documentation: Buffer&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;U extends Collection&lt;? super T&gt;&gt; Flowable&lt;U&gt; buffer(int count, int skip, Callable&lt;U&gt; bufferSupplier) {
<span class="fc" id="L6284">        ObjectHelper.verifyPositive(count, &quot;count&quot;);</span>
<span class="fc" id="L6285">        ObjectHelper.verifyPositive(skip, &quot;skip&quot;);</span>
<span class="fc" id="L6286">        ObjectHelper.requireNonNull(bufferSupplier, &quot;bufferSupplier is null&quot;);</span>
<span class="fc" id="L6287">        return RxJavaPlugins.onAssembly(new FlowableBuffer&lt;T, U&gt;(this, count, skip, bufferSupplier));</span>
    }

    /**
     * Returns a Flowable that emits buffers of items it collects from the source Publisher. The resulting
     * Publisher emits connected, non-overlapping buffers, each containing {@code count} items. When the source
     * Publisher completes, the resulting Publisher emits the current buffer and propagates the notification from the
     * source Publisher. Note that if the source Publisher issues an onError notification the event is passed on
     * immediately without first emitting the buffer it is in the process of assembling.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;320&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/buffer3.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream and expects the source {@code Publisher} to honor it as
     *  well, although not enforced; violation &lt;em&gt;may&lt;/em&gt; lead to {@code MissingBackpressureException} somewhere
     *  downstream.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code buffer} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;U&gt; the collection subclass type to buffer into
     * @param count
     *            the maximum number of items in each buffer before it should be emitted
     * @param bufferSupplier
     *            a factory function that returns an instance of the collection subclass to be used and returned
     *            as the buffer
     * @return a Flowable that emits connected, non-overlapping buffers, each containing at most
     *         {@code count} items from the source Publisher
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/buffer.html&quot;&gt;ReactiveX operators documentation: Buffer&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;U extends Collection&lt;? super T&gt;&gt; Flowable&lt;U&gt; buffer(int count, Callable&lt;U&gt; bufferSupplier) {
<span class="fc" id="L6321">        return buffer(count, count, bufferSupplier);</span>
    }

    /**
     * Returns a Flowable that emits buffers of items it collects from the source Publisher. The resulting
     * Publisher starts a new buffer periodically, as determined by the {@code timeskip} argument. It emits
     * each buffer after a fixed timespan, specified by the {@code timespan} argument. When the source
     * Publisher completes, the resulting Publisher emits the current buffer and propagates the notification from the
     * source Publisher. Note that if the source Publisher issues an onError notification the event is passed on
     * immediately without first emitting the buffer it is in the process of assembling.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;320&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/buffer7.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not support backpressure as it uses time. It requests {@code Long.MAX_VALUE}
     *      upstream and does not obey downstream requests.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code buffer} operates by default on the {@code computation} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param timespan
     *            the period of time each buffer collects items before it is emitted
     * @param timeskip
     *            the period of time after which a new buffer will be created
     * @param unit
     *            the unit of time that applies to the {@code timespan} and {@code timeskip} arguments
     * @return a Flowable that emits new buffers of items emitted by the source Publisher periodically after
     *         a fixed timespan has elapsed
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/buffer.html&quot;&gt;ReactiveX operators documentation: Buffer&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.COMPUTATION)
    public final Flowable&lt;List&lt;T&gt;&gt; buffer(long timespan, long timeskip, TimeUnit unit) {
<span class="fc" id="L6355">        return buffer(timespan, timeskip, unit, Schedulers.computation(), ArrayListSupplier.&lt;T&gt;asCallable());</span>
    }

    /**
     * Returns a Flowable that emits buffers of items it collects from the source Publisher. The resulting
     * Publisher starts a new buffer periodically, as determined by the {@code timeskip} argument, and on the
     * specified {@code scheduler}. It emits each buffer after a fixed timespan, specified by the
     * {@code timespan} argument. When the source Publisher completes, the resulting Publisher emits the current buffer
     * and propagates the notification from the source Publisher. Note that if the source Publisher issues an onError
     * notification the event is passed on immediately without first emitting the buffer it is in the process of
     * assembling.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;320&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/buffer7.s.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not support backpressure as it uses time. It requests {@code Long.MAX_VALUE}
     *      upstream and does not obey downstream requests.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;You specify which {@link Scheduler} this operator will use.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param timespan
     *            the period of time each buffer collects items before it is emitted
     * @param timeskip
     *            the period of time after which a new buffer will be created
     * @param unit
     *            the unit of time that applies to the {@code timespan} and {@code timeskip} arguments
     * @param scheduler
     *            the {@link Scheduler} to use when determining the end and start of a buffer
     * @return a Flowable that emits new buffers of items emitted by the source Publisher periodically after
     *         a fixed timespan has elapsed
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/buffer.html&quot;&gt;ReactiveX operators documentation: Buffer&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Flowable&lt;List&lt;T&gt;&gt; buffer(long timespan, long timeskip, TimeUnit unit, Scheduler scheduler) {
<span class="fc" id="L6392">        return buffer(timespan, timeskip, unit, scheduler, ArrayListSupplier.&lt;T&gt;asCallable());</span>
    }

    /**
     * Returns a Flowable that emits buffers of items it collects from the source Publisher. The resulting
     * Publisher starts a new buffer periodically, as determined by the {@code timeskip} argument, and on the
     * specified {@code scheduler}. It emits each buffer after a fixed timespan, specified by the
     * {@code timespan} argument. When the source Publisher completes, the resulting Publisher emits the current buffer
     * and propagates the notification from the source Publisher. Note that if the source Publisher issues an onError
     * notification the event is passed on immediately without first emitting the buffer it is in the process of
     * assembling.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;320&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/buffer7.s.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not support backpressure as it uses time. It requests {@code Long.MAX_VALUE}
     *      upstream and does not obey downstream requests.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;You specify which {@link Scheduler} this operator will use.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;U&gt; the collection subclass type to buffer into
     * @param timespan
     *            the period of time each buffer collects items before it is emitted
     * @param timeskip
     *            the period of time after which a new buffer will be created
     * @param unit
     *            the unit of time that applies to the {@code timespan} and {@code timeskip} arguments
     * @param scheduler
     *            the {@link Scheduler} to use when determining the end and start of a buffer
     * @param bufferSupplier
     *            a factory function that returns an instance of the collection subclass to be used and returned
     *            as the buffer
     * @return a Flowable that emits new buffers of items emitted by the source Publisher periodically after
     *         a fixed timespan has elapsed
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/buffer.html&quot;&gt;ReactiveX operators documentation: Buffer&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final &lt;U extends Collection&lt;? super T&gt;&gt; Flowable&lt;U&gt; buffer(long timespan, long timeskip, TimeUnit unit,
            Scheduler scheduler, Callable&lt;U&gt; bufferSupplier) {
<span class="fc" id="L6435">        ObjectHelper.requireNonNull(unit, &quot;unit is null&quot;);</span>
<span class="fc" id="L6436">        ObjectHelper.requireNonNull(scheduler, &quot;scheduler is null&quot;);</span>
<span class="fc" id="L6437">        ObjectHelper.requireNonNull(bufferSupplier, &quot;bufferSupplier is null&quot;);</span>
<span class="fc" id="L6438">        return RxJavaPlugins.onAssembly(new FlowableBufferTimed&lt;T, U&gt;(this, timespan, timeskip, unit, scheduler, bufferSupplier, Integer.MAX_VALUE, false));</span>
    }

    /**
     * Returns a Flowable that emits buffers of items it collects from the source Publisher. The resulting
     * Publisher emits connected, non-overlapping buffers, each of a fixed duration specified by the
     * {@code timespan} argument. When the source Publisher completes, the resulting Publisher emits the current buffer
     * and propagates the notification from the source Publisher. Note that if the source Publisher issues an onError
     * notification the event is passed on immediately without first emitting the buffer it is in the process of
     * assembling.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;320&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/buffer5.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not support backpressure as it uses time. It requests {@code Long.MAX_VALUE}
     *      upstream and does not obey downstream requests.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code buffer} operates by default on the {@code computation} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param timespan
     *            the period of time each buffer collects items before it is emitted and replaced with a new
     *            buffer
     * @param unit
     *            the unit of time that applies to the {@code timespan} argument
     * @return a Flowable that emits connected, non-overlapping buffers of items emitted by the source
     *         Publisher within a fixed duration
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/buffer.html&quot;&gt;ReactiveX operators documentation: Buffer&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.COMPUTATION)
    public final Flowable&lt;List&lt;T&gt;&gt; buffer(long timespan, TimeUnit unit) {
<span class="fc" id="L6471">        return buffer(timespan, unit, Schedulers.computation(), Integer.MAX_VALUE);</span>
    }

    /**
     * Returns a Flowable that emits buffers of items it collects from the source Publisher. The resulting
     * Publisher emits connected, non-overlapping buffers, each of a fixed duration specified by the
     * {@code timespan} argument or a maximum size specified by the {@code count} argument (whichever is reached
     * first). When the source Publisher completes, the resulting Publisher emits the current buffer and propagates the
     * notification from the source Publisher. Note that if the source Publisher issues an onError notification the event
     * is passed on immediately without first emitting the buffer it is in the process of assembling.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;320&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/buffer6.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not support backpressure as it uses time. It requests {@code Long.MAX_VALUE}
     *      upstream and does not obey downstream requests.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code buffer} operates by default on the {@code computation} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param timespan
     *            the period of time each buffer collects items before it is emitted and replaced with a new
     *            buffer
     * @param unit
     *            the unit of time which applies to the {@code timespan} argument
     * @param count
     *            the maximum size of each buffer before it is emitted
     * @return a Flowable that emits connected, non-overlapping buffers of items emitted by the source
     *         Publisher, after a fixed duration or when the buffer reaches maximum capacity (whichever occurs
     *         first)
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/buffer.html&quot;&gt;ReactiveX operators documentation: Buffer&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.COMPUTATION)
    public final Flowable&lt;List&lt;T&gt;&gt; buffer(long timespan, TimeUnit unit, int count) {
<span class="fc" id="L6507">        return buffer(timespan, unit, Schedulers.computation(), count);</span>
    }

    /**
     * Returns a Flowable that emits buffers of items it collects from the source Publisher. The resulting
     * Publisher emits connected, non-overlapping buffers, each of a fixed duration specified by the
     * {@code timespan} argument as measured on the specified {@code scheduler}, or a maximum size specified by
     * the {@code count} argument (whichever is reached first). When the source Publisher completes, the resulting
     * Publisher emits the current buffer and propagates the notification from the source Publisher. Note that if the
     * source Publisher issues an onError notification the event is passed on immediately without first emitting the
     * buffer it is in the process of assembling.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;320&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/buffer6.s.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not support backpressure as it uses time. It requests {@code Long.MAX_VALUE}
     *      upstream and does not obey downstream requests.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;You specify which {@link Scheduler} this operator will use.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param timespan
     *            the period of time each buffer collects items before it is emitted and replaced with a new
     *            buffer
     * @param unit
     *            the unit of time which applies to the {@code timespan} argument
     * @param scheduler
     *            the {@link Scheduler} to use when determining the end and start of a buffer
     * @param count
     *            the maximum size of each buffer before it is emitted
     * @return a Flowable that emits connected, non-overlapping buffers of items emitted by the source
     *         Publisher after a fixed duration or when the buffer reaches maximum capacity (whichever occurs
     *         first)
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/buffer.html&quot;&gt;ReactiveX operators documentation: Buffer&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Flowable&lt;List&lt;T&gt;&gt; buffer(long timespan, TimeUnit unit, Scheduler scheduler, int count) {
<span class="fc" id="L6546">        return buffer(timespan, unit, scheduler, count, ArrayListSupplier.&lt;T&gt;asCallable(), false);</span>
    }

    /**
     * Returns a Flowable that emits buffers of items it collects from the source Publisher. The resulting
     * Publisher emits connected, non-overlapping buffers, each of a fixed duration specified by the
     * {@code timespan} argument as measured on the specified {@code scheduler}, or a maximum size specified by
     * the {@code count} argument (whichever is reached first). When the source Publisher completes, the resulting
     * Publisher emits the current buffer and propagates the notification from the source Publisher. Note that if the
     * source Publisher issues an onError notification the event is passed on immediately without first emitting the
     * buffer it is in the process of assembling.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;320&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/buffer6.s.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not support backpressure as it uses time. It requests {@code Long.MAX_VALUE}
     *      upstream and does not obey downstream requests.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;You specify which {@link Scheduler} this operator will use.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;U&gt; the collection subclass type to buffer into
     * @param timespan
     *            the period of time each buffer collects items before it is emitted and replaced with a new
     *            buffer
     * @param unit
     *            the unit of time which applies to the {@code timespan} argument
     * @param scheduler
     *            the {@link Scheduler} to use when determining the end and start of a buffer
     * @param count
     *            the maximum size of each buffer before it is emitted
     * @param bufferSupplier
     *            a factory function that returns an instance of the collection subclass to be used and returned
     *            as the buffer
     * @param restartTimerOnMaxSize if true the time window is restarted when the max capacity of the current buffer
     *            is reached
     * @return a Flowable that emits connected, non-overlapping buffers of items emitted by the source
     *         Publisher after a fixed duration or when the buffer reaches maximum capacity (whichever occurs
     *         first)
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/buffer.html&quot;&gt;ReactiveX operators documentation: Buffer&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final &lt;U extends Collection&lt;? super T&gt;&gt; Flowable&lt;U&gt; buffer(
            long timespan, TimeUnit unit,
            Scheduler scheduler, int count,
            Callable&lt;U&gt; bufferSupplier,
            boolean restartTimerOnMaxSize) {
<span class="fc" id="L6595">        ObjectHelper.requireNonNull(unit, &quot;unit is null&quot;);</span>
<span class="fc" id="L6596">        ObjectHelper.requireNonNull(scheduler, &quot;scheduler is null&quot;);</span>
<span class="fc" id="L6597">        ObjectHelper.requireNonNull(bufferSupplier, &quot;bufferSupplier is null&quot;);</span>
<span class="fc" id="L6598">        ObjectHelper.verifyPositive(count, &quot;count&quot;);</span>
<span class="fc" id="L6599">        return RxJavaPlugins.onAssembly(new FlowableBufferTimed&lt;T, U&gt;(this, timespan, timespan, unit, scheduler, bufferSupplier, count, restartTimerOnMaxSize));</span>
    }

    /**
     * Returns a Flowable that emits buffers of items it collects from the source Publisher. The resulting
     * Publisher emits connected, non-overlapping buffers, each of a fixed duration specified by the
     * {@code timespan} argument and on the specified {@code scheduler}. When the source Publisher completes, the
     * resulting Publisher emits the current buffer and propagates the notification from the source Publisher. Note that
     * if the source Publisher issues an onError notification the event is passed on immediately without first emitting
     * the buffer it is in the process of assembling.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;320&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/buffer5.s.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not support backpressure as it uses time. It requests {@code Long.MAX_VALUE}
     *      upstream and does not obey downstream requests.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;You specify which {@link Scheduler} this operator will use.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param timespan
     *            the period of time each buffer collects items before it is emitted and replaced with a new
     *            buffer
     * @param unit
     *            the unit of time which applies to the {@code timespan} argument
     * @param scheduler
     *            the {@link Scheduler} to use when determining the end and start of a buffer
     * @return a Flowable that emits connected, non-overlapping buffers of items emitted by the source
     *         Publisher within a fixed duration
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/buffer.html&quot;&gt;ReactiveX operators documentation: Buffer&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Flowable&lt;List&lt;T&gt;&gt; buffer(long timespan, TimeUnit unit, Scheduler scheduler) {
<span class="fc" id="L6634">        return buffer(timespan, unit, scheduler, Integer.MAX_VALUE, ArrayListSupplier.&lt;T&gt;asCallable(), false);</span>
    }

    /**
     * Returns a Flowable that emits buffers of items it collects from the source Publisher. The resulting
     * Publisher emits buffers that it creates when the specified {@code openingIndicator} Publisher emits an
     * item, and closes when the Publisher returned from {@code closingIndicator} emits an item. If any of the source
     * Publisher, {@code openingIndicator} or {@code closingIndicator} issues an onError notification the event is passed
     * on immediately without first emitting the buffer it is in the process of assembling.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;470&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/buffer2.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not support backpressure as it is instead controlled by the given Publishers and
     *      buffers data. It requests {@code Long.MAX_VALUE} upstream and does not obey downstream requests.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code buffer} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;TOpening&gt; the element type of the buffer-opening Publisher
     * @param &lt;TClosing&gt; the element type of the individual buffer-closing Publishers
     * @param openingIndicator
     *            the Publisher that, when it emits an item, causes a new buffer to be created
     * @param closingIndicator
     *            the {@link Function} that is used to produce a Publisher for every buffer created. When this
     *            Publisher emits an item, the associated buffer is emitted.
     * @return a Flowable that emits buffers, containing items from the source Publisher, that are created
     *         and closed when the specified Publishers emit items
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/buffer.html&quot;&gt;ReactiveX operators documentation: Buffer&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;TOpening, TClosing&gt; Flowable&lt;List&lt;T&gt;&gt; buffer(
            Flowable&lt;? extends TOpening&gt; openingIndicator,
            Function&lt;? super TOpening, ? extends Publisher&lt;? extends TClosing&gt;&gt; closingIndicator) {
<span class="fc" id="L6670">        return buffer(openingIndicator, closingIndicator, ArrayListSupplier.&lt;T&gt;asCallable());</span>
    }

    /**
     * Returns a Flowable that emits buffers of items it collects from the source Publisher. The resulting
     * Publisher emits buffers that it creates when the specified {@code openingIndicator} Publisher emits an
     * item, and closes when the Publisher returned from {@code closingIndicator} emits an item. If any of the source
     * Publisher, {@code openingIndicator} or {@code closingIndicator} issues an onError notification the event is passed
     * on immediately without first emitting the buffer it is in the process of assembling.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;470&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/buffer2.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not support backpressure as it is instead controlled by the given Publishers and
     *      buffers data. It requests {@code Long.MAX_VALUE} upstream and does not obey downstream requests.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code buffer} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;U&gt; the collection subclass type to buffer into
     * @param &lt;TOpening&gt; the element type of the buffer-opening Publisher
     * @param &lt;TClosing&gt; the element type of the individual buffer-closing Publishers
     * @param openingIndicator
     *            the Publisher that, when it emits an item, causes a new buffer to be created
     * @param closingIndicator
     *            the {@link Function} that is used to produce a Publisher for every buffer created. When this
     *            Publisher emits an item, the associated buffer is emitted.
     * @param bufferSupplier
     *            a factory function that returns an instance of the collection subclass to be used and returned
     *            as the buffer
     * @return a Flowable that emits buffers, containing items from the source Publisher, that are created
     *         and closed when the specified Publishers emit items
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/buffer.html&quot;&gt;ReactiveX operators documentation: Buffer&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;TOpening, TClosing, U extends Collection&lt;? super T&gt;&gt; Flowable&lt;U&gt; buffer(
            Flowable&lt;? extends TOpening&gt; openingIndicator,
            Function&lt;? super TOpening, ? extends Publisher&lt;? extends TClosing&gt;&gt; closingIndicator,
            Callable&lt;U&gt; bufferSupplier) {
<span class="fc" id="L6711">        ObjectHelper.requireNonNull(openingIndicator, &quot;openingIndicator is null&quot;);</span>
<span class="fc" id="L6712">        ObjectHelper.requireNonNull(closingIndicator, &quot;closingIndicator is null&quot;);</span>
<span class="fc" id="L6713">        ObjectHelper.requireNonNull(bufferSupplier, &quot;bufferSupplier is null&quot;);</span>
<span class="fc" id="L6714">        return RxJavaPlugins.onAssembly(new FlowableBufferBoundary&lt;T, U, TOpening, TClosing&gt;(this, openingIndicator, closingIndicator, bufferSupplier));</span>
    }

    /**
     * Returns a Flowable that emits non-overlapping buffered items from the source Publisher each time the
     * specified boundary Publisher emits an item.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;395&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/buffer8.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * Completion of either the source or the boundary Publisher causes the returned Publisher to emit the
     * latest buffer and complete. If either the source Publisher or the boundary Publisher issues an onError notification
     * the event is passed on immediately without first emitting the buffer it is in the process of assembling.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not support backpressure as it is instead controlled by the {@code Publisher}
     *      {@code boundary} and buffers data. It requests {@code Long.MAX_VALUE} upstream and does not obey
     *      downstream requests.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code buffer} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;B&gt;
     *            the boundary value type (ignored)
     * @param boundaryIndicator
     *            the boundary Publisher
     * @return a Flowable that emits buffered items from the source Publisher when the boundary Publisher
     *         emits an item
     * @see #buffer(Publisher, int)
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/buffer.html&quot;&gt;ReactiveX operators documentation: Buffer&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;B&gt; Flowable&lt;List&lt;T&gt;&gt; buffer(Publisher&lt;B&gt; boundaryIndicator) {
<span class="fc" id="L6748">        return buffer(boundaryIndicator, ArrayListSupplier.&lt;T&gt;asCallable());</span>
    }

    /**
     * Returns a Flowable that emits non-overlapping buffered items from the source Publisher each time the
     * specified boundary Publisher emits an item.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;395&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/buffer8.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * Completion of either the source or the boundary Publisher causes the returned Publisher to emit the
     * latest buffer and complete. If either the source Publisher or the boundary Publisher issues an onError notification
     * the event is passed on immediately without first emitting the buffer it is in the process of assembling.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not support backpressure as it is instead controlled by the {@code Publisher}
     *      {@code boundary} and buffers data. It requests {@code Long.MAX_VALUE} upstream and does not obey
     *      downstream requests.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code buffer} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;B&gt;
     *            the boundary value type (ignored)
     * @param boundaryIndicator
     *            the boundary Publisher
     * @param initialCapacity
     *            the initial capacity of each buffer chunk
     * @return a Flowable that emits buffered items from the source Publisher when the boundary Publisher
     *         emits an item
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/buffer.html&quot;&gt;ReactiveX operators documentation: Buffer&lt;/a&gt;
     * @see #buffer(Publisher)
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;B&gt; Flowable&lt;List&lt;T&gt;&gt; buffer(Publisher&lt;B&gt; boundaryIndicator, final int initialCapacity) {
<span class="fc" id="L6784">        ObjectHelper.verifyPositive(initialCapacity, &quot;initialCapacity&quot;);</span>
<span class="fc" id="L6785">        return buffer(boundaryIndicator, Functions.&lt;T&gt;createArrayList(initialCapacity));</span>
    }

    /**
     * Returns a Flowable that emits non-overlapping buffered items from the source Publisher each time the
     * specified boundary Publisher emits an item.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;395&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/buffer8.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * Completion of either the source or the boundary Publisher causes the returned Publisher to emit the
     * latest buffer and complete. If either the source Publisher or the boundary Publisher issues an onError notification
     * the event is passed on immediately without first emitting the buffer it is in the process of assembling.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not support backpressure as it is instead controlled by the {@code Publisher}
     *      {@code boundary} and buffers data. It requests {@code Long.MAX_VALUE} upstream and does not obey
     *      downstream requests.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code buffer} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;U&gt; the collection subclass type to buffer into
     * @param &lt;B&gt;
     *            the boundary value type (ignored)
     * @param boundaryIndicator
     *            the boundary Publisher
     * @param bufferSupplier
     *            a factory function that returns an instance of the collection subclass to be used and returned
     *            as the buffer
     * @return a Flowable that emits buffered items from the source Publisher when the boundary Publisher
     *         emits an item
     * @see #buffer(Publisher, int)
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/buffer.html&quot;&gt;ReactiveX operators documentation: Buffer&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;B, U extends Collection&lt;? super T&gt;&gt; Flowable&lt;U&gt; buffer(Publisher&lt;B&gt; boundaryIndicator, Callable&lt;U&gt; bufferSupplier) {
<span class="fc" id="L6823">        ObjectHelper.requireNonNull(boundaryIndicator, &quot;boundaryIndicator is null&quot;);</span>
<span class="fc" id="L6824">        ObjectHelper.requireNonNull(bufferSupplier, &quot;bufferSupplier is null&quot;);</span>
<span class="fc" id="L6825">        return RxJavaPlugins.onAssembly(new FlowableBufferExactBoundary&lt;T, U, B&gt;(this, boundaryIndicator, bufferSupplier));</span>
    }

    /**
     * Returns a Flowable that emits buffers of items it collects from the source Publisher. The resulting
     * Publisher emits connected, non-overlapping buffers. It emits the current buffer and replaces it with a
     * new buffer whenever the Publisher produced by the specified {@code boundaryIndicatorSupplier} emits an item.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;395&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/buffer1.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * If either the source {@code Publisher} or the boundary {@code Publisher} issues an {@code onError} notification the event is passed on
     * immediately without first emitting the buffer it is in the process of assembling.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not support backpressure as it is instead controlled by the given Publishers and
     *      buffers data. It requests {@code Long.MAX_VALUE} upstream and does not obey downstream requests.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code buffer} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;B&gt; the value type of the boundary-providing Publisher
     * @param boundaryIndicatorSupplier
     *            a {@link Callable} that produces a Publisher that governs the boundary between buffers.
     *            Whenever the supplied {@code Publisher} emits an item, {@code buffer} emits the current buffer and
     *            begins to fill a new one
     * @return a Flowable that emits a connected, non-overlapping buffer of items from the source Publisher
     *         each time the Publisher created with the {@code closingIndicator} argument emits an item
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/buffer.html&quot;&gt;ReactiveX operators documentation: Buffer&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;B&gt; Flowable&lt;List&lt;T&gt;&gt; buffer(Callable&lt;? extends Publisher&lt;B&gt;&gt; boundaryIndicatorSupplier) {
<span class="fc" id="L6858">        return buffer(boundaryIndicatorSupplier, ArrayListSupplier.&lt;T&gt;asCallable());</span>
    }

    /**
     * Returns a Flowable that emits buffers of items it collects from the source Publisher. The resulting
     * Publisher emits connected, non-overlapping buffers. It emits the current buffer and replaces it with a
     * new buffer whenever the Publisher produced by the specified {@code boundaryIndicatorSupplier} emits an item.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;395&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/buffer1.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * If either the source {@code Publisher} or the boundary {@code Publisher} issues an {@code onError} notification the event is passed on
     * immediately without first emitting the buffer it is in the process of assembling.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not support backpressure as it is instead controlled by the given Publishers and
     *      buffers data. It requests {@code Long.MAX_VALUE} upstream and does not obey downstream requests.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code buffer} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;U&gt; the collection subclass type to buffer into
     * @param &lt;B&gt; the value type of the boundary-providing Publisher
     * @param boundaryIndicatorSupplier
     *            a {@link Callable} that produces a Publisher that governs the boundary between buffers.
     *            Whenever the supplied {@code Publisher} emits an item, {@code buffer} emits the current buffer and
     *            begins to fill a new one
     * @param bufferSupplier
     *            a factory function that returns an instance of the collection subclass to be used and returned
     *            as the buffer
     * @return a Flowable that emits a connected, non-overlapping buffer of items from the source Publisher
     *         each time the Publisher created with the {@code closingIndicator} argument emits an item
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/buffer.html&quot;&gt;ReactiveX operators documentation: Buffer&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;B, U extends Collection&lt;? super T&gt;&gt; Flowable&lt;U&gt; buffer(Callable&lt;? extends Publisher&lt;B&gt;&gt; boundaryIndicatorSupplier,
            Callable&lt;U&gt; bufferSupplier) {
<span class="fc" id="L6896">        ObjectHelper.requireNonNull(boundaryIndicatorSupplier, &quot;boundaryIndicatorSupplier is null&quot;);</span>
<span class="fc" id="L6897">        ObjectHelper.requireNonNull(bufferSupplier, &quot;bufferSupplier is null&quot;);</span>
<span class="fc" id="L6898">        return RxJavaPlugins.onAssembly(new FlowableBufferBoundarySupplier&lt;T, U, B&gt;(this, boundaryIndicatorSupplier, bufferSupplier));</span>
    }

    /**
     * Returns a Flowable that subscribes to this Publisher lazily, caches all of its events
     * and replays them, in the same order as received, to all the downstream subscribers.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;410&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/cache.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * This is useful when you want a Publisher to cache responses and you can't control the
     * subscribe/cancel behavior of all the {@link Subscriber}s.
     * &lt;p&gt;
     * The operator subscribes only when the first downstream subscriber subscribes and maintains
     * a single subscription towards this Publisher. In contrast, the operator family of {@link #replay()}
     * that return a {@link ConnectableFlowable} require an explicit call to {@link ConnectableFlowable#connect()}.
     * &lt;p&gt;
     * &lt;em&gt;Note:&lt;/em&gt; You sacrifice the ability to cancel the origin when you use the {@code cache}
     * Subscriber so be careful not to use this Subscriber on Publishers that emit an infinite or very large number
     * of items that will use up memory.
     * A possible workaround is to apply `takeUntil` with a predicate or
     * another source before (and perhaps after) the application of cache().
     * &lt;pre&gt;&lt;code&gt;
     * AtomicBoolean shouldStop = new AtomicBoolean();
     *
     * source.takeUntil(v -&amp;gt; shouldStop.get())
     *       .cache()
     *       .takeUntil(v -&amp;gt; shouldStop.get())
     *       .subscribe(...);
     * &lt;/code&gt;&lt;/pre&gt;
     * Since the operator doesn't allow clearing the cached values either, the possible workaround is
     * to forget all references to it via {@link #onTerminateDetach()} applied along with the previous
     * workaround:
     * &lt;pre&gt;&lt;code&gt;
     * AtomicBoolean shouldStop = new AtomicBoolean();
     *
     * source.takeUntil(v -&amp;gt; shouldStop.get())
     *       .onTerminateDetach()
     *       .cache()
     *       .takeUntil(v -&amp;gt; shouldStop.get())
     *       .onTerminateDetach()
     *       .subscribe(...);
     * &lt;/code&gt;&lt;/pre&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator consumes this Publisher in an unbounded fashion but respects the backpressure
     *  of each downstream Subscriber individually.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code cache} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @return a Flowable that, when first subscribed to, caches all of its items and notifications for the
     *         benefit of subsequent subscribers
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/replay.html&quot;&gt;ReactiveX operators documentation: Replay&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;T&gt; cache() {
<span class="fc" id="L6956">        return cacheWithInitialCapacity(16);</span>
    }

    /**
     * Returns a Flowable that subscribes to this Publisher lazily, caches all of its events
     * and replays them, in the same order as received, to all the downstream subscribers.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;410&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/cache.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * This is useful when you want a Publisher to cache responses and you can't control the
     * subscribe/cancel behavior of all the {@link Subscriber}s.
     * &lt;p&gt;
     * The operator subscribes only when the first downstream subscriber subscribes and maintains
     * a single subscription towards this Publisher. In contrast, the operator family of {@link #replay()}
     * that return a {@link ConnectableFlowable} require an explicit call to {@link ConnectableFlowable#connect()}.
     * &lt;p&gt;
     * &lt;em&gt;Note:&lt;/em&gt; You sacrifice the ability to cancel the origin when you use the {@code cache}
     * Subscriber so be careful not to use this Subscriber on Publishers that emit an infinite or very large number
     * of items that will use up memory.
     * A possible workaround is to apply `takeUntil` with a predicate or
     * another source before (and perhaps after) the application of cache().
     * &lt;pre&gt;&lt;code&gt;
     * AtomicBoolean shouldStop = new AtomicBoolean();
     *
     * source.takeUntil(v -&amp;gt; shouldStop.get())
     *       .cache()
     *       .takeUntil(v -&amp;gt; shouldStop.get())
     *       .subscribe(...);
     * &lt;/code&gt;&lt;/pre&gt;
     * Since the operator doesn't allow clearing the cached values either, the possible workaround is
     * to forget all references to it via {@link #onTerminateDetach()} applied along with the previous
     * workaround:
     * &lt;pre&gt;&lt;code&gt;
     * AtomicBoolean shouldStop = new AtomicBoolean();
     *
     * source.takeUntil(v -&amp;gt; shouldStop.get())
     *       .onTerminateDetach()
     *       .cache()
     *       .takeUntil(v -&amp;gt; shouldStop.get())
     *       .onTerminateDetach()
     *       .subscribe(...);
     * &lt;/code&gt;&lt;/pre&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator consumes this Publisher in an unbounded fashion but respects the backpressure
     *  of each downstream Subscriber individually.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code cacheWithInitialCapacity} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * &lt;p&gt;
     * &lt;em&gt;Note:&lt;/em&gt; The capacity hint is not an upper bound on cache size. For that, consider
     * {@link #replay(int)} in combination with {@link ConnectableFlowable#autoConnect()} or similar.
     *
     * @param initialCapacity hint for number of items to cache (for optimizing underlying data structure)
     * @return a Flowable that, when first subscribed to, caches all of its items and notifications for the
     *         benefit of subsequent subscribers
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/replay.html&quot;&gt;ReactiveX operators documentation: Replay&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;T&gt; cacheWithInitialCapacity(int initialCapacity) {
<span class="fc" id="L7018">        ObjectHelper.verifyPositive(initialCapacity, &quot;initialCapacity&quot;);</span>
<span class="fc" id="L7019">        return RxJavaPlugins.onAssembly(new FlowableCache&lt;T&gt;(this, initialCapacity));</span>
    }

    /**
     * Returns a Flowable that emits the items emitted by the source Publisher, converted to the specified
     * type.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/cast.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s
     *  backpressure behavior.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code cast} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;U&gt; the output value type cast to
     * @param clazz
     *            the target class type that {@code cast} will cast the items emitted by the source Publisher
     *            into before emitting them from the resulting Publisher
     * @return a Flowable that emits each item from the source Publisher after converting it to the
     *         specified type
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/map.html&quot;&gt;ReactiveX operators documentation: Map&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;U&gt; Flowable&lt;U&gt; cast(final Class&lt;U&gt; clazz) {
<span class="fc" id="L7048">        ObjectHelper.requireNonNull(clazz, &quot;clazz is null&quot;);</span>
<span class="fc" id="L7049">        return map(Functions.castFunction(clazz));</span>
    }

    /**
     * Collects items emitted by the finite source Publisher into a single mutable data structure and returns
     * a Single that emits this structure.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;330&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/collect.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * This is a simplified version of {@code reduce} that does not need to return the state on each pass.
     * &lt;p&gt;
     * Note that this operator requires the upstream to signal {@code onComplete} for the accumulator object to
     * be emitted. Sources that are infinite and never complete will never emit anything through this
     * operator and an infinite source may lead to a fatal {@code OutOfMemoryError}.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not support backpressure because by intent it will receive all values and reduce
     *      them to a single {@code onNext}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code collect} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;U&gt; the accumulator and output type
     * @param initialItemSupplier
     *           the mutable data structure that will collect the items
     * @param collector
     *           a function that accepts the {@code state} and an emitted item, and modifies {@code state}
     *           accordingly
     * @return a Single that emits the result of collecting the values emitted by the source Publisher
     *         into a single mutable data structure
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/reduce.html&quot;&gt;ReactiveX operators documentation: Reduce&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;U&gt; Single&lt;U&gt; collect(Callable&lt;? extends U&gt; initialItemSupplier, BiConsumer&lt;? super U, ? super T&gt; collector) {
<span class="fc" id="L7086">        ObjectHelper.requireNonNull(initialItemSupplier, &quot;initialItemSupplier is null&quot;);</span>
<span class="fc" id="L7087">        ObjectHelper.requireNonNull(collector, &quot;collector is null&quot;);</span>
<span class="fc" id="L7088">        return RxJavaPlugins.onAssembly(new FlowableCollectSingle&lt;T, U&gt;(this, initialItemSupplier, collector));</span>
    }

    /**
     * Collects items emitted by the finite source Publisher into a single mutable data structure and returns
     * a Single that emits this structure.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;330&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/collect.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * This is a simplified version of {@code reduce} that does not need to return the state on each pass.
     * &lt;p&gt;
     * Note that this operator requires the upstream to signal {@code onComplete} for the accumulator object to
     * be emitted. Sources that are infinite and never complete will never emit anything through this
     * operator and an infinite source may lead to a fatal {@code OutOfMemoryError}.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not support backpressure because by intent it will receive all values and reduce
     *      them to a single {@code onNext}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code collectInto} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;U&gt; the accumulator and output type
     * @param initialItem
     *           the mutable data structure that will collect the items
     * @param collector
     *           a function that accepts the {@code state} and an emitted item, and modifies {@code state}
     *           accordingly
     * @return a Single that emits the result of collecting the values emitted by the source Publisher
     *         into a single mutable data structure
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/reduce.html&quot;&gt;ReactiveX operators documentation: Reduce&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;U&gt; Single&lt;U&gt; collectInto(final U initialItem, BiConsumer&lt;? super U, ? super T&gt; collector) {
<span class="fc" id="L7125">        ObjectHelper.requireNonNull(initialItem, &quot;initialItem is null&quot;);</span>
<span class="fc" id="L7126">        return collect(Functions.justCallable(initialItem), collector);</span>
    }

    /**
     * Transform a Publisher by applying a particular Transformer function to it.
     * &lt;p&gt;
     * This method operates on the Publisher itself whereas {@link #lift} operates on the Publisher's
     * Subscribers or Subscribers.
     * &lt;p&gt;
     * If the operator you are creating is designed to act on the individual items emitted by a source
     * Publisher, use {@link #lift}. If your operator is designed to transform the source Publisher as a whole
     * (for instance, by applying a particular set of existing RxJava operators to it) use {@code compose}.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator itself doesn't interfere with the backpressure behavior which only depends
     *  on what kind of {@code Publisher} the transformer returns.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code compose} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;R&gt; the value type of the output Publisher
     * @param composer implements the function that transforms the source Publisher
     * @return the source Publisher, transformed by the transformer function
     * @see &lt;a href=&quot;https://github.com/ReactiveX/RxJava/wiki/Implementing-Your-Own-Operators&quot;&gt;RxJava wiki: Implementing Your Own Operators&lt;/a&gt;
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;R&gt; Flowable&lt;R&gt; compose(FlowableTransformer&lt;? super T, ? extends R&gt; composer) {
<span class="fc" id="L7156">        return fromPublisher(((FlowableTransformer&lt;T, R&gt;) ObjectHelper.requireNonNull(composer, &quot;composer is null&quot;)).apply(this));</span>
    }

    /**
     * Returns a new Flowable that emits items resulting from applying a function that you supply to each item
     * emitted by the source Publisher, where that function returns a Publisher, and then emitting the items
     * that result from concatenating those resulting Publishers.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatMap.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream. Both this and the inner {@code Publisher}s are
     *  expected to honor backpressure as well. If the source {@code Publisher} violates the rule, the operator will
     *  signal a {@code MissingBackpressureException}. If any of the inner {@code Publisher}s doesn't honor
     *  backpressure, that &lt;em&gt;may&lt;/em&gt; throw an {@code IllegalStateException} when that
     *  {@code Publisher} completes.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code concatMap} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;R&gt; the type of the inner Publisher sources and thus the output type
     * @param mapper
     *            a function that, when applied to an item emitted by the source Publisher, returns a
     *            Publisher
     * @return a Flowable that emits the result of applying the transformation function to each item emitted
     *         by the source Publisher and concatenating the Publishers obtained from this transformation
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/flatmap.html&quot;&gt;ReactiveX operators documentation: FlatMap&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;R&gt; Flowable&lt;R&gt; concatMap(Function&lt;? super T, ? extends Publisher&lt;? extends R&gt;&gt; mapper) {
<span class="fc" id="L7188">        return concatMap(mapper, 2);</span>
    }

    /**
     * Returns a new Flowable that emits items resulting from applying a function that you supply to each item
     * emitted by the source Publisher, where that function returns a Publisher, and then emitting the items
     * that result from concatenating those resulting Publishers.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatMap.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream. Both this and the inner {@code Publisher}s are
     *  expected to honor backpressure as well. If the source {@code Publisher} violates the rule, the operator will
     *  signal a {@code MissingBackpressureException}. If any of the inner {@code Publisher}s doesn't honor
     *  backpressure, that &lt;em&gt;may&lt;/em&gt; throw an {@code IllegalStateException} when that
     *  {@code Publisher} completes.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code concatMap} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;R&gt; the type of the inner Publisher sources and thus the output type
     * @param mapper
     *            a function that, when applied to an item emitted by the source Publisher, returns a
     *            Publisher
     * @param prefetch
     *            the number of elements to prefetch from the current Flowable
     * @return a Flowable that emits the result of applying the transformation function to each item emitted
     *         by the source Publisher and concatenating the Publishers obtained from this transformation
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/flatmap.html&quot;&gt;ReactiveX operators documentation: FlatMap&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;R&gt; Flowable&lt;R&gt; concatMap(Function&lt;? super T, ? extends Publisher&lt;? extends R&gt;&gt; mapper, int prefetch) {
<span class="fc" id="L7223">        ObjectHelper.requireNonNull(mapper, &quot;mapper is null&quot;);</span>
<span class="fc" id="L7224">        ObjectHelper.verifyPositive(prefetch, &quot;prefetch&quot;);</span>
<span class="fc bfc" id="L7225" title="All 2 branches covered.">        if (this instanceof ScalarCallable) {</span>
            @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L7227">            T v = ((ScalarCallable&lt;T&gt;)this).call();</span>
<span class="fc bfc" id="L7228" title="All 2 branches covered.">            if (v == null) {</span>
<span class="fc" id="L7229">                return empty();</span>
            }
<span class="fc" id="L7231">            return FlowableScalarXMap.scalarXMap(v, mapper);</span>
        }
<span class="fc" id="L7233">        return RxJavaPlugins.onAssembly(new FlowableConcatMap&lt;T, R&gt;(this, mapper, prefetch, ErrorMode.IMMEDIATE));</span>
    }

    /**
     * Maps the upstream items into {@link CompletableSource}s and subscribes to them one after the
     * other completes.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatMap.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator expects the upstream to support backpressure. If this {@code Flowable} violates the rule, the operator will
     *  signal a {@code MissingBackpressureException}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code concatMapCompletable} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * &lt;p&gt;History: 2.1.11 - experimental
     * @param mapper the function called with the upstream item and should return
     *               a {@code CompletableSource} to become the next source to
     *               be subscribed to
     * @return a new Completable instance
     * @see #concatMapCompletableDelayError(Function)
     * @since 2.2
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    @BackpressureSupport(BackpressureKind.FULL)
    public final Completable concatMapCompletable(Function&lt;? super T, ? extends CompletableSource&gt; mapper) {
<span class="fc" id="L7260">        return concatMapCompletable(mapper, 2);</span>
    }

    /**
     * Maps the upstream items into {@link CompletableSource}s and subscribes to them one after the
     * other completes.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatMap.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator expects the upstream to support backpressure. If this {@code Flowable} violates the rule, the operator will
     *  signal a {@code MissingBackpressureException}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code concatMapCompletable} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * &lt;p&gt;History: 2.1.11 - experimental
     * @param mapper the function called with the upstream item and should return
     *               a {@code CompletableSource} to become the next source to
     *               be subscribed to
     * @param prefetch The number of upstream items to prefetch so that fresh items are
     *                 ready to be mapped when a previous {@code CompletableSource} terminates.
     *                 The operator replenishes after half of the prefetch amount has been consumed
     *                 and turned into {@code CompletableSource}s.
     * @return a new Completable instance
     * @see #concatMapCompletableDelayError(Function, boolean, int)
     * @since 2.2
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    @BackpressureSupport(BackpressureKind.FULL)
    public final Completable concatMapCompletable(Function&lt;? super T, ? extends CompletableSource&gt; mapper, int prefetch) {
<span class="fc" id="L7292">        ObjectHelper.requireNonNull(mapper, &quot;mapper is null&quot;);</span>
<span class="fc" id="L7293">        ObjectHelper.verifyPositive(prefetch, &quot;prefetch&quot;);</span>
<span class="fc" id="L7294">        return RxJavaPlugins.onAssembly(new FlowableConcatMapCompletable&lt;T&gt;(this, mapper, ErrorMode.IMMEDIATE, prefetch));</span>
    }

    /**
     * Maps the upstream items into {@link CompletableSource}s and subscribes to them one after the
     * other terminates, delaying all errors till both this {@code Flowable} and all
     * inner {@code CompletableSource}s terminate.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatMap.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator expects the upstream to support backpressure. If this {@code Flowable} violates the rule, the operator will
     *  signal a {@code MissingBackpressureException}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code concatMapCompletableDelayError} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * &lt;p&gt;History: 2.1.11 - experimental
     * @param mapper the function called with the upstream item and should return
     *               a {@code CompletableSource} to become the next source to
     *               be subscribed to
     * @return a new Completable instance
     * @see #concatMapCompletable(Function, int)
     * @since 2.2
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    @BackpressureSupport(BackpressureKind.FULL)
    public final Completable concatMapCompletableDelayError(Function&lt;? super T, ? extends CompletableSource&gt; mapper) {
<span class="fc" id="L7322">        return concatMapCompletableDelayError(mapper, true, 2);</span>
    }

    /**
     * Maps the upstream items into {@link CompletableSource}s and subscribes to them one after the
     * other terminates, optionally delaying all errors till both this {@code Flowable} and all
     * inner {@code CompletableSource}s terminate.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatMap.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator expects the upstream to support backpressure. If this {@code Flowable} violates the rule, the operator will
     *  signal a {@code MissingBackpressureException}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code concatMapCompletableDelayError} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * &lt;p&gt;History: 2.1.11 - experimental
     * @param mapper the function called with the upstream item and should return
     *               a {@code CompletableSource} to become the next source to
     *               be subscribed to
     * @param tillTheEnd If {@code true}, errors from this {@code Flowable} or any of the
     *                   inner {@code CompletableSource}s are delayed until all
     *                   of them terminate. If {@code false}, an error from this
     *                   {@code Flowable} is delayed until the current inner
     *                   {@code CompletableSource} terminates and only then is
     *                   it emitted to the downstream.
     * @return a new Completable instance
     * @see #concatMapCompletable(Function)
     * @since 2.2
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    @BackpressureSupport(BackpressureKind.FULL)
    public final Completable concatMapCompletableDelayError(Function&lt;? super T, ? extends CompletableSource&gt; mapper, boolean tillTheEnd) {
<span class="fc" id="L7356">        return concatMapCompletableDelayError(mapper, tillTheEnd, 2);</span>
    }

    /**
     * Maps the upstream items into {@link CompletableSource}s and subscribes to them one after the
     * other terminates, optionally delaying all errors till both this {@code Flowable} and all
     * inner {@code CompletableSource}s terminate.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatMap.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator expects the upstream to support backpressure. If this {@code Flowable} violates the rule, the operator will
     *  signal a {@code MissingBackpressureException}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code concatMapCompletableDelayError} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * &lt;p&gt;History: 2.1.11 - experimental
     * @param mapper the function called with the upstream item and should return
     *               a {@code CompletableSource} to become the next source to
     *               be subscribed to
     * @param tillTheEnd If {@code true}, errors from this {@code Flowable} or any of the
     *                   inner {@code CompletableSource}s are delayed until all
     *                   of them terminate. If {@code false}, an error from this
     *                   {@code Flowable} is delayed until the current inner
     *                   {@code CompletableSource} terminates and only then is
     *                   it emitted to the downstream.
     * @param prefetch The number of upstream items to prefetch so that fresh items are
     *                 ready to be mapped when a previous {@code CompletableSource} terminates.
     *                 The operator replenishes after half of the prefetch amount has been consumed
     *                 and turned into {@code CompletableSource}s.
     * @return a new Completable instance
     * @see #concatMapCompletable(Function, int)
     * @since 2.2
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    @BackpressureSupport(BackpressureKind.FULL)
    public final Completable concatMapCompletableDelayError(Function&lt;? super T, ? extends CompletableSource&gt; mapper, boolean tillTheEnd, int prefetch) {
<span class="fc" id="L7395">        ObjectHelper.requireNonNull(mapper, &quot;mapper is null&quot;);</span>
<span class="fc" id="L7396">        ObjectHelper.verifyPositive(prefetch, &quot;prefetch&quot;);</span>
<span class="fc bfc" id="L7397" title="All 2 branches covered.">        return RxJavaPlugins.onAssembly(new FlowableConcatMapCompletable&lt;T&gt;(this, mapper, tillTheEnd ? ErrorMode.END : ErrorMode.BOUNDARY, prefetch));</span>
    }

    /**
     * Maps each of the items into a Publisher, subscribes to them one after the other,
     * one at a time and emits their values in order
     * while delaying any error from either this or any of the inner Publishers
     * till all of them terminate.
     *
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream. Both this and the inner {@code Publisher}s are
     *  expected to honor backpressure as well. If the source {@code Publisher} violates the rule, the operator will
     *  signal a {@code MissingBackpressureException}. If any of the inner {@code Publisher}s doesn't honor
     *  backpressure, that &lt;em&gt;may&lt;/em&gt; throw an {@code IllegalStateException} when that
     *  {@code Publisher} completes.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code concatMapDelayError} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;R&gt; the result value type
     * @param mapper the function that maps the items of this Publisher into the inner Publishers.
     * @return the new Publisher instance with the concatenation behavior
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;R&gt; Flowable&lt;R&gt; concatMapDelayError(Function&lt;? super T, ? extends Publisher&lt;? extends R&gt;&gt; mapper) {
<span class="fc" id="L7425">        return concatMapDelayError(mapper, 2, true);</span>
    }

    /**
     * Maps each of the items into a Publisher, subscribes to them one after the other,
     * one at a time and emits their values in order
     * while delaying any error from either this or any of the inner Publishers
     * till all of them terminate.
     *
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream. Both this and the inner {@code Publisher}s are
     *  expected to honor backpressure as well. If the source {@code Publisher} violates the rule, the operator will
     *  signal a {@code MissingBackpressureException}. If any of the inner {@code Publisher}s doesn't honor
     *  backpressure, that &lt;em&gt;may&lt;/em&gt; throw an {@code IllegalStateException} when that
     *  {@code Publisher} completes.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code concatMapDelayError} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;R&gt; the result value type
     * @param mapper the function that maps the items of this Publisher into the inner Publishers.
     * @param prefetch
     *            the number of elements to prefetch from the current Flowable
     * @param tillTheEnd
     *            if true, all errors from the outer and inner Publisher sources are delayed until the end,
     *            if false, an error from the main source is signaled when the current Publisher source terminates
     * @return the new Publisher instance with the concatenation behavior
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;R&gt; Flowable&lt;R&gt; concatMapDelayError(Function&lt;? super T, ? extends Publisher&lt;? extends R&gt;&gt; mapper,
            int prefetch, boolean tillTheEnd) {
<span class="fc" id="L7460">        ObjectHelper.requireNonNull(mapper, &quot;mapper is null&quot;);</span>
<span class="fc" id="L7461">        ObjectHelper.verifyPositive(prefetch, &quot;prefetch&quot;);</span>
<span class="fc bfc" id="L7462" title="All 2 branches covered.">        if (this instanceof ScalarCallable) {</span>
            @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L7464">            T v = ((ScalarCallable&lt;T&gt;)this).call();</span>
<span class="fc bfc" id="L7465" title="All 2 branches covered.">            if (v == null) {</span>
<span class="fc" id="L7466">                return empty();</span>
            }
<span class="fc" id="L7468">            return FlowableScalarXMap.scalarXMap(v, mapper);</span>
        }
<span class="fc bfc" id="L7470" title="All 2 branches covered.">        return RxJavaPlugins.onAssembly(new FlowableConcatMap&lt;T, R&gt;(this, mapper, prefetch, tillTheEnd ? ErrorMode.END : ErrorMode.BOUNDARY));</span>
    }

    /**
     * Maps a sequence of values into Publishers and concatenates these Publishers eagerly into a single
     * Publisher.
     * &lt;p&gt;
     * Eager concatenation means that once a subscriber subscribes, this operator subscribes to all of the
     * source Publishers. The operator buffers the values emitted by these Publishers and then drains them in
     * order, each one after the previous one completes.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;Backpressure is honored towards the downstream, however, due to the eagerness requirement, sources
     *      are subscribed to in unbounded mode and their values are queued up in an unbounded buffer.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This method does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;R&gt; the value type
     * @param mapper the function that maps a sequence of values into a sequence of Publishers that will be
     *               eagerly concatenated
     * @return the new Publisher instance with the specified concatenation behavior
     * @since 2.0
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;R&gt; Flowable&lt;R&gt; concatMapEager(Function&lt;? super T, ? extends Publisher&lt;? extends R&gt;&gt; mapper) {
<span class="fc" id="L7497">        return concatMapEager(mapper, bufferSize(), bufferSize());</span>
    }

    /**
     * Maps a sequence of values into Publishers and concatenates these Publishers eagerly into a single
     * Publisher.
     * &lt;p&gt;
     * Eager concatenation means that once a subscriber subscribes, this operator subscribes to all of the
     * source Publishers. The operator buffers the values emitted by these Publishers and then drains them in
     * order, each one after the previous one completes.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;Backpressure is honored towards the downstream, however, due to the eagerness requirement, sources
     *      are subscribed to in unbounded mode and their values are queued up in an unbounded buffer.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This method does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;R&gt; the value type
     * @param mapper the function that maps a sequence of values into a sequence of Publishers that will be
     *               eagerly concatenated
     * @param maxConcurrency the maximum number of concurrent subscribed Publishers
     * @param prefetch hints about the number of expected values from each inner Publisher, must be positive
     * @return the new Publisher instance with the specified concatenation behavior
     * @since 2.0
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;R&gt; Flowable&lt;R&gt; concatMapEager(Function&lt;? super T, ? extends Publisher&lt;? extends R&gt;&gt; mapper,
            int maxConcurrency, int prefetch) {
<span class="fc" id="L7528">        ObjectHelper.requireNonNull(mapper, &quot;mapper is null&quot;);</span>
<span class="fc" id="L7529">        ObjectHelper.verifyPositive(maxConcurrency, &quot;maxConcurrency&quot;);</span>
<span class="fc" id="L7530">        ObjectHelper.verifyPositive(prefetch, &quot;prefetch&quot;);</span>
<span class="fc" id="L7531">        return RxJavaPlugins.onAssembly(new FlowableConcatMapEager&lt;T, R&gt;(this, mapper, maxConcurrency, prefetch, ErrorMode.IMMEDIATE));</span>
    }

    /**
     * Maps a sequence of values into Publishers and concatenates these Publishers eagerly into a single
     * Publisher.
     * &lt;p&gt;
     * Eager concatenation means that once a subscriber subscribes, this operator subscribes to all of the
     * source Publishers. The operator buffers the values emitted by these Publishers and then drains them in
     * order, each one after the previous one completes.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;Backpressure is honored towards the downstream, however, due to the eagerness requirement, sources
     *      are subscribed to in unbounded mode and their values are queued up in an unbounded buffer.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This method does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;R&gt; the value type
     * @param mapper the function that maps a sequence of values into a sequence of Publishers that will be
     *               eagerly concatenated
     * @param tillTheEnd
     *            if true, all errors from the outer and inner Publisher sources are delayed until the end,
     *            if false, an error from the main source is signaled when the current Publisher source terminates
     * @return the new Publisher instance with the specified concatenation behavior
     * @since 2.0
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;R&gt; Flowable&lt;R&gt; concatMapEagerDelayError(Function&lt;? super T, ? extends Publisher&lt;? extends R&gt;&gt; mapper,
            boolean tillTheEnd) {
<span class="fc" id="L7562">        return concatMapEagerDelayError(mapper, bufferSize(), bufferSize(), tillTheEnd);</span>
    }

    /**
     * Maps a sequence of values into Publishers and concatenates these Publishers eagerly into a single
     * Publisher.
     * &lt;p&gt;
     * Eager concatenation means that once a subscriber subscribes, this operator subscribes to all of the
     * source Publishers. The operator buffers the values emitted by these Publishers and then drains them in
     * order, each one after the previous one completes.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;Backpressure is honored towards the downstream, however, due to the eagerness requirement, sources
     *      are subscribed to in unbounded mode and their values are queued up in an unbounded buffer.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This method does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;R&gt; the value type
     * @param mapper the function that maps a sequence of values into a sequence of Publishers that will be
     *               eagerly concatenated
     * @param maxConcurrency the maximum number of concurrent subscribed Publishers
     * @param prefetch
     *               the number of elements to prefetch from each source Publisher
     * @param tillTheEnd
     *               if true, exceptions from the current Flowable and all the inner Publishers are delayed until
     *               all of them terminate, if false, exception from the current Flowable is delayed until the
     *               currently running Publisher terminates
     * @return the new Publisher instance with the specified concatenation behavior
     * @since 2.0
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;R&gt; Flowable&lt;R&gt; concatMapEagerDelayError(Function&lt;? super T, ? extends Publisher&lt;? extends R&gt;&gt; mapper,
            int maxConcurrency, int prefetch, boolean tillTheEnd) {
<span class="fc" id="L7598">        ObjectHelper.requireNonNull(mapper, &quot;mapper is null&quot;);</span>
<span class="fc" id="L7599">        ObjectHelper.verifyPositive(maxConcurrency, &quot;maxConcurrency&quot;);</span>
<span class="fc" id="L7600">        ObjectHelper.verifyPositive(prefetch, &quot;prefetch&quot;);</span>
<span class="fc bfc" id="L7601" title="All 2 branches covered.">        return RxJavaPlugins.onAssembly(new FlowableConcatMapEager&lt;T, R&gt;(this, mapper, maxConcurrency, prefetch, tillTheEnd ? ErrorMode.END : ErrorMode.BOUNDARY));</span>
    }

    /**
     * Returns a Flowable that concatenate each item emitted by the source Publisher with the values in an
     * Iterable corresponding to that item that is generated by a selector.
     *
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream. The source {@code Publisher}s is
     *  expected to honor backpressure as well. If the source {@code Publisher} violates the rule, the operator will
     *  signal a {@code MissingBackpressureException}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code concatMapIterable} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;U&gt;
     *            the type of item emitted by the resulting Publisher
     * @param mapper
     *            a function that returns an Iterable sequence of values for when given an item emitted by the
     *            source Publisher
     * @return a Flowable that emits the results of concatenating the items emitted by the source Publisher with
     *         the values in the Iterables corresponding to those items, as generated by {@code collectionSelector}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/flatmap.html&quot;&gt;ReactiveX operators documentation: FlatMap&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;U&gt; Flowable&lt;U&gt; concatMapIterable(Function&lt;? super T, ? extends Iterable&lt;? extends U&gt;&gt; mapper) {
<span class="fc" id="L7630">        return concatMapIterable(mapper, 2);</span>
    }

    /**
     * Returns a Flowable that concatenate each item emitted by the source Publisher with the values in an
     * Iterable corresponding to that item that is generated by a selector.
     *
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream. The source {@code Publisher}s is
     *  expected to honor backpressure as well. If the source {@code Publisher} violates the rule, the operator will
     *  signal a {@code MissingBackpressureException}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code concatMapIterable} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;U&gt;
     *            the type of item emitted by the resulting Publisher
     * @param mapper
     *            a function that returns an Iterable sequence of values for when given an item emitted by the
     *            source Publisher
     * @param prefetch
     *            the number of elements to prefetch from the current Flowable
     * @return a Flowable that emits the results of concatenating the items emitted by the source Publisher with
     *         the values in the Iterables corresponding to those items, as generated by {@code collectionSelector}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/flatmap.html&quot;&gt;ReactiveX operators documentation: FlatMap&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;U&gt; Flowable&lt;U&gt; concatMapIterable(final Function&lt;? super T, ? extends Iterable&lt;? extends U&gt;&gt; mapper, int prefetch) {
<span class="fc" id="L7662">        ObjectHelper.requireNonNull(mapper, &quot;mapper is null&quot;);</span>
<span class="fc" id="L7663">        ObjectHelper.verifyPositive(prefetch, &quot;prefetch&quot;);</span>
<span class="fc" id="L7664">        return RxJavaPlugins.onAssembly(new FlowableFlattenIterable&lt;T, U&gt;(this, mapper, prefetch));</span>
    }

    /**
     * Maps the upstream items into {@link MaybeSource}s and subscribes to them one after the
     * other succeeds or completes, emits their success value if available or terminates immediately if
     * either this {@code Flowable} or the current inner {@code MaybeSource} fail.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatMap.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator expects the upstream to support backpressure and honors
     *  the backpressure from downstream. If this {@code Flowable} violates the rule, the operator will
     *  signal a {@code MissingBackpressureException}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code concatMapMaybe} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * &lt;p&gt;History: 2.1.11 - experimental
     * @param &lt;R&gt; the result type of the inner {@code MaybeSource}s
     * @param mapper the function called with the upstream item and should return
     *               a {@code MaybeSource} to become the next source to
     *               be subscribed to
     * @return a new Flowable instance
     * @see #concatMapMaybeDelayError(Function)
     * @see #concatMapMaybe(Function, int)
     * @since 2.2
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;R&gt; Flowable&lt;R&gt; concatMapMaybe(Function&lt;? super T, ? extends MaybeSource&lt;? extends R&gt;&gt; mapper) {
<span class="fc" id="L7695">        return concatMapMaybe(mapper, 2);</span>
    }

    /**
     * Maps the upstream items into {@link MaybeSource}s and subscribes to them one after the
     * other succeeds or completes, emits their success value if available or terminates immediately if
     * either this {@code Flowable} or the current inner {@code MaybeSource} fail.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatMap.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator expects the upstream to support backpressure and honors
     *  the backpressure from downstream. If this {@code Flowable} violates the rule, the operator will
     *  signal a {@code MissingBackpressureException}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code concatMapMaybe} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * &lt;p&gt;History: 2.1.11 - experimental
     * @param &lt;R&gt; the result type of the inner {@code MaybeSource}s
     * @param mapper the function called with the upstream item and should return
     *               a {@code MaybeSource} to become the next source to
     *               be subscribed to
     * @param prefetch The number of upstream items to prefetch so that fresh items are
     *                 ready to be mapped when a previous {@code MaybeSource} terminates.
     *                 The operator replenishes after half of the prefetch amount has been consumed
     *                 and turned into {@code MaybeSource}s.
     * @return a new Flowable instance
     * @see #concatMapMaybe(Function)
     * @see #concatMapMaybeDelayError(Function, boolean, int)
     * @since 2.2
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;R&gt; Flowable&lt;R&gt; concatMapMaybe(Function&lt;? super T, ? extends MaybeSource&lt;? extends R&gt;&gt; mapper, int prefetch) {
<span class="fc" id="L7731">        ObjectHelper.requireNonNull(mapper, &quot;mapper is null&quot;);</span>
<span class="fc" id="L7732">        ObjectHelper.verifyPositive(prefetch, &quot;prefetch&quot;);</span>
<span class="fc" id="L7733">        return RxJavaPlugins.onAssembly(new FlowableConcatMapMaybe&lt;T, R&gt;(this, mapper, ErrorMode.IMMEDIATE, prefetch));</span>
    }

    /**
     * Maps the upstream items into {@link MaybeSource}s and subscribes to them one after the
     * other terminates, emits their success value if available and delaying all errors
     * till both this {@code Flowable} and all inner {@code MaybeSource}s terminate.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatMap.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator expects the upstream to support backpressure and honors
     *  the backpressure from downstream. If this {@code Flowable} violates the rule, the operator will
     *  signal a {@code MissingBackpressureException}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code concatMapMaybeDelayError} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * &lt;p&gt;History: 2.1.11 - experimental
     * @param &lt;R&gt; the result type of the inner {@code MaybeSource}s
     * @param mapper the function called with the upstream item and should return
     *               a {@code MaybeSource} to become the next source to
     *               be subscribed to
     * @return a new Flowable instance
     * @see #concatMapMaybe(Function)
     * @see #concatMapMaybeDelayError(Function, boolean)
     * @since 2.2
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;R&gt; Flowable&lt;R&gt; concatMapMaybeDelayError(Function&lt;? super T, ? extends MaybeSource&lt;? extends R&gt;&gt; mapper) {
<span class="fc" id="L7764">        return concatMapMaybeDelayError(mapper, true, 2);</span>
    }

    /**
     * Maps the upstream items into {@link MaybeSource}s and subscribes to them one after the
     * other terminates, emits their success value if available and optionally delaying all errors
     * till both this {@code Flowable} and all inner {@code MaybeSource}s terminate.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatMap.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator expects the upstream to support backpressure and honors
     *  the backpressure from downstream. If this {@code Flowable} violates the rule, the operator will
     *  signal a {@code MissingBackpressureException}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code concatMapMaybeDelayError} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * &lt;p&gt;History: 2.1.11 - experimental
     * @param &lt;R&gt; the result type of the inner {@code MaybeSource}s
     * @param mapper the function called with the upstream item and should return
     *               a {@code MaybeSource} to become the next source to
     *               be subscribed to
     * @param tillTheEnd If {@code true}, errors from this {@code Flowable} or any of the
     *                   inner {@code MaybeSource}s are delayed until all
     *                   of them terminate. If {@code false}, an error from this
     *                   {@code Flowable} is delayed until the current inner
     *                   {@code MaybeSource} terminates and only then is
     *                   it emitted to the downstream.
     * @return a new Flowable instance
     * @see #concatMapMaybe(Function, int)
     * @see #concatMapMaybeDelayError(Function, boolean, int)
     * @since 2.2
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;R&gt; Flowable&lt;R&gt; concatMapMaybeDelayError(Function&lt;? super T, ? extends MaybeSource&lt;? extends R&gt;&gt; mapper, boolean tillTheEnd) {
<span class="fc" id="L7801">        return concatMapMaybeDelayError(mapper, tillTheEnd, 2);</span>
    }

    /**
     * Maps the upstream items into {@link MaybeSource}s and subscribes to them one after the
     * other terminates, emits their success value if available and optionally delaying all errors
     * till both this {@code Flowable} and all inner {@code MaybeSource}s terminate.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatMap.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator expects the upstream to support backpressure and honors
     *  the backpressure from downstream. If this {@code Flowable} violates the rule, the operator will
     *  signal a {@code MissingBackpressureException}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code concatMapMaybeDelayError} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * &lt;p&gt;History: 2.1.11 - experimental
     * @param &lt;R&gt; the result type of the inner {@code MaybeSource}s
     * @param mapper the function called with the upstream item and should return
     *               a {@code MaybeSource} to become the next source to
     *               be subscribed to
     * @param tillTheEnd If {@code true}, errors from this {@code Flowable} or any of the
     *                   inner {@code MaybeSource}s are delayed until all
     *                   of them terminate. If {@code false}, an error from this
     *                   {@code Flowable} is delayed until the current inner
     *                   {@code MaybeSource} terminates and only then is
     *                   it emitted to the downstream.
     * @param prefetch The number of upstream items to prefetch so that fresh items are
     *                 ready to be mapped when a previous {@code MaybeSource} terminates.
     *                 The operator replenishes after half of the prefetch amount has been consumed
     *                 and turned into {@code MaybeSource}s.
     * @return a new Flowable instance
     * @see #concatMapMaybe(Function, int)
     * @since 2.2
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;R&gt; Flowable&lt;R&gt; concatMapMaybeDelayError(Function&lt;? super T, ? extends MaybeSource&lt;? extends R&gt;&gt; mapper, boolean tillTheEnd, int prefetch) {
<span class="fc" id="L7842">        ObjectHelper.requireNonNull(mapper, &quot;mapper is null&quot;);</span>
<span class="fc" id="L7843">        ObjectHelper.verifyPositive(prefetch, &quot;prefetch&quot;);</span>
<span class="fc bfc" id="L7844" title="All 2 branches covered.">        return RxJavaPlugins.onAssembly(new FlowableConcatMapMaybe&lt;T, R&gt;(this, mapper, tillTheEnd ? ErrorMode.END : ErrorMode.BOUNDARY, prefetch));</span>
    }

    /**
     * Maps the upstream items into {@link SingleSource}s and subscribes to them one after the
     * other succeeds, emits their success values or terminates immediately if
     * either this {@code Flowable} or the current inner {@code SingleSource} fail.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatMap.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator expects the upstream to support backpressure and honors
     *  the backpressure from downstream. If this {@code Flowable} violates the rule, the operator will
     *  signal a {@code MissingBackpressureException}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code concatMapSingle} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * &lt;p&gt;History: 2.1.11 - experimental
     * @param &lt;R&gt; the result type of the inner {@code SingleSource}s
     * @param mapper the function called with the upstream item and should return
     *               a {@code SingleSource} to become the next source to
     *               be subscribed to
     * @return a new Flowable instance
     * @see #concatMapSingleDelayError(Function)
     * @see #concatMapSingle(Function, int)
     * @since 2.2
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;R&gt; Flowable&lt;R&gt; concatMapSingle(Function&lt;? super T, ? extends SingleSource&lt;? extends R&gt;&gt; mapper) {
<span class="fc" id="L7875">        return concatMapSingle(mapper, 2);</span>
    }

    /**
     * Maps the upstream items into {@link SingleSource}s and subscribes to them one after the
     * other succeeds, emits their success values or terminates immediately if
     * either this {@code Flowable} or the current inner {@code SingleSource} fail.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatMap.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator expects the upstream to support backpressure and honors
     *  the backpressure from downstream. If this {@code Flowable} violates the rule, the operator will
     *  signal a {@code MissingBackpressureException}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code concatMapSingle} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * &lt;p&gt;History: 2.1.11 - experimental
     * @param &lt;R&gt; the result type of the inner {@code SingleSource}s
     * @param mapper the function called with the upstream item and should return
     *               a {@code SingleSource} to become the next source to
     *               be subscribed to
     * @param prefetch The number of upstream items to prefetch so that fresh items are
     *                 ready to be mapped when a previous {@code SingleSource} terminates.
     *                 The operator replenishes after half of the prefetch amount has been consumed
     *                 and turned into {@code SingleSource}s.
     * @return a new Flowable instance
     * @see #concatMapSingle(Function)
     * @see #concatMapSingleDelayError(Function, boolean, int)
     * @since 2.2
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;R&gt; Flowable&lt;R&gt; concatMapSingle(Function&lt;? super T, ? extends SingleSource&lt;? extends R&gt;&gt; mapper, int prefetch) {
<span class="fc" id="L7911">        ObjectHelper.requireNonNull(mapper, &quot;mapper is null&quot;);</span>
<span class="fc" id="L7912">        ObjectHelper.verifyPositive(prefetch, &quot;prefetch&quot;);</span>
<span class="fc" id="L7913">        return RxJavaPlugins.onAssembly(new FlowableConcatMapSingle&lt;T, R&gt;(this, mapper, ErrorMode.IMMEDIATE, prefetch));</span>
    }

    /**
     * Maps the upstream items into {@link SingleSource}s and subscribes to them one after the
     * other succeeds or fails, emits their success values and delays all errors
     * till both this {@code Flowable} and all inner {@code SingleSource}s terminate.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatMap.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator expects the upstream to support backpressure and honors
     *  the backpressure from downstream. If this {@code Flowable} violates the rule, the operator will
     *  signal a {@code MissingBackpressureException}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code concatMapSingleDelayError} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * &lt;p&gt;History: 2.1.11 - experimental
     * @param &lt;R&gt; the result type of the inner {@code SingleSource}s
     * @param mapper the function called with the upstream item and should return
     *               a {@code SingleSource} to become the next source to
     *               be subscribed to
     * @return a new Flowable instance
     * @see #concatMapSingle(Function)
     * @see #concatMapSingleDelayError(Function, boolean)
     * @since 2.2
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;R&gt; Flowable&lt;R&gt; concatMapSingleDelayError(Function&lt;? super T, ? extends SingleSource&lt;? extends R&gt;&gt; mapper) {
<span class="fc" id="L7944">        return concatMapSingleDelayError(mapper, true, 2);</span>
    }

    /**
     * Maps the upstream items into {@link SingleSource}s and subscribes to them one after the
     * other succeeds or fails, emits their success values and optionally delays all errors
     * till both this {@code Flowable} and all inner {@code SingleSource}s terminate.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatMap.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator expects the upstream to support backpressure and honors
     *  the backpressure from downstream. If this {@code Flowable} violates the rule, the operator will
     *  signal a {@code MissingBackpressureException}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code concatMapSingleDelayError} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * &lt;p&gt;History: 2.1.11 - experimental
     * @param &lt;R&gt; the result type of the inner {@code SingleSource}s
     * @param mapper the function called with the upstream item and should return
     *               a {@code SingleSource} to become the next source to
     *               be subscribed to
     * @param tillTheEnd If {@code true}, errors from this {@code Flowable} or any of the
     *                   inner {@code SingleSource}s are delayed until all
     *                   of them terminate. If {@code false}, an error from this
     *                   {@code Flowable} is delayed until the current inner
     *                   {@code SingleSource} terminates and only then is
     *                   it emitted to the downstream.
     * @return a new Flowable instance
     * @see #concatMapSingle(Function, int)
     * @see #concatMapSingleDelayError(Function, boolean, int)
     * @since 2.2
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;R&gt; Flowable&lt;R&gt; concatMapSingleDelayError(Function&lt;? super T, ? extends SingleSource&lt;? extends R&gt;&gt; mapper, boolean tillTheEnd) {
<span class="fc" id="L7981">        return concatMapSingleDelayError(mapper, tillTheEnd, 2);</span>
    }

    /**
     * Maps the upstream items into {@link SingleSource}s and subscribes to them one after the
     * other succeeds or fails, emits their success values and optionally delays errors
     * till both this {@code Flowable} and all inner {@code SingleSource}s terminate.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatMap.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator expects the upstream to support backpressure and honors
     *  the backpressure from downstream. If this {@code Flowable} violates the rule, the operator will
     *  signal a {@code MissingBackpressureException}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code concatMapSingleDelayError} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * &lt;p&gt;History: 2.1.11 - experimental
     * @param &lt;R&gt; the result type of the inner {@code SingleSource}s
     * @param mapper the function called with the upstream item and should return
     *               a {@code SingleSource} to become the next source to
     *               be subscribed to
     * @param tillTheEnd If {@code true}, errors from this {@code Flowable} or any of the
     *                   inner {@code SingleSource}s are delayed until all
     *                   of them terminate. If {@code false}, an error from this
     *                   {@code Flowable} is delayed until the current inner
     *                   {@code SingleSource} terminates and only then is
     *                   it emitted to the downstream.
     * @param prefetch The number of upstream items to prefetch so that fresh items are
     *                 ready to be mapped when a previous {@code SingleSource} terminates.
     *                 The operator replenishes after half of the prefetch amount has been consumed
     *                 and turned into {@code SingleSource}s.
     * @return a new Flowable instance
     * @see #concatMapSingle(Function, int)
     * @since 2.2
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;R&gt; Flowable&lt;R&gt; concatMapSingleDelayError(Function&lt;? super T, ? extends SingleSource&lt;? extends R&gt;&gt; mapper, boolean tillTheEnd, int prefetch) {
<span class="fc" id="L8022">        ObjectHelper.requireNonNull(mapper, &quot;mapper is null&quot;);</span>
<span class="fc" id="L8023">        ObjectHelper.verifyPositive(prefetch, &quot;prefetch&quot;);</span>
<span class="fc bfc" id="L8024" title="All 2 branches covered.">        return RxJavaPlugins.onAssembly(new FlowableConcatMapSingle&lt;T, R&gt;(this, mapper, tillTheEnd ? ErrorMode.END : ErrorMode.BOUNDARY, prefetch));</span>
    }

    /**
     * Returns a Flowable that emits the items emitted from the current Publisher, then the next, one after
     * the other, without interleaving them.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concat.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream. Both this and the {@code other} {@code Publisher}s
     *  are expected to honor backpressure as well. If any of then violates this rule, it &lt;em&gt;may&lt;/em&gt; throw an
     *  {@code IllegalStateException} when the source {@code Publisher} completes.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code concatWith} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param other
     *            a Publisher to be concatenated after the current
     * @return a Flowable that emits items emitted by the two source Publishers, one after the other,
     *         without interleaving them
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/concat.html&quot;&gt;ReactiveX operators documentation: Concat&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;T&gt; concatWith(Publisher&lt;? extends T&gt; other) {
<span class="fc" id="L8052">        ObjectHelper.requireNonNull(other, &quot;other is null&quot;);</span>
<span class="fc" id="L8053">        return concat(this, other);</span>
    }

    /**
     * Returns a {@code Flowable} that emits the items from this {@code Flowable} followed by the success item or error event
     * of the other {@link SingleSource}.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concat.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator supports backpressure and makes sure the success item of the other {@code SingleSource}
     *  is only emitted when there is a demand for it.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code concatWith} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * &lt;p&gt;History: 2.1.10 - experimental
     * @param other the SingleSource whose signal should be emitted after this {@code Flowable} completes normally.
     * @return the new Flowable instance
     * @since 2.2
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;T&gt; concatWith(@NonNull SingleSource&lt;? extends T&gt; other) {
<span class="fc" id="L8077">        ObjectHelper.requireNonNull(other, &quot;other is null&quot;);</span>
<span class="fc" id="L8078">        return RxJavaPlugins.onAssembly(new FlowableConcatWithSingle&lt;T&gt;(this, other));</span>
    }

    /**
     * Returns a {@code Flowable} that emits the items from this {@code Flowable} followed by the success item or terminal events
     * of the other {@link MaybeSource}.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concat.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator supports backpressure and makes sure the success item of the other {@code MaybeSource}
     *  is only emitted when there is a demand for it.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code concatWith} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * &lt;p&gt;History: 2.1.10 - experimental
     * @param other the MaybeSource whose signal should be emitted after this Flowable completes normally.
     * @return the new Flowable instance
     * @since 2.2
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;T&gt; concatWith(@NonNull MaybeSource&lt;? extends T&gt; other) {
<span class="fc" id="L8102">        ObjectHelper.requireNonNull(other, &quot;other is null&quot;);</span>
<span class="fc" id="L8103">        return RxJavaPlugins.onAssembly(new FlowableConcatWithMaybe&lt;T&gt;(this, other));</span>
    }

    /**
     * Returns a {@code Flowable} that emits items from this {@code Flowable} and when it completes normally, the
     * other {@link CompletableSource} is subscribed to and the returned {@code Flowable} emits its terminal events.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concat.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator does not interfere with backpressure between the current Flowable and the
     *  downstream consumer (i.e., acts as pass-through). When the operator switches to the
     *  {@code Completable}, backpressure is no longer present because {@code Completable} doesn't
     *  have items to apply backpressure to.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code concatWith} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * &lt;p&gt;History: 2.1.10 - experimental
     * @param other the {@code CompletableSource} to subscribe to once the current {@code Flowable} completes normally
     * @return the new Flowable instance
     * @since 2.2
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;T&gt; concatWith(@NonNull CompletableSource other) {
<span class="fc" id="L8129">        ObjectHelper.requireNonNull(other, &quot;other is null&quot;);</span>
<span class="fc" id="L8130">        return RxJavaPlugins.onAssembly(new FlowableConcatWithCompletable&lt;T&gt;(this, other));</span>
    }

    /**
     * Returns a Single that emits a Boolean that indicates whether the source Publisher emitted a
     * specified item.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;320&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/contains.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream and consumes the source {@code Publisher} in an
     *  unbounded manner (i.e., without applying backpressure).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code contains} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param item
     *            the item to search for in the emissions from the source Publisher
     * @return a Flowable that emits {@code true} if the specified item is emitted by the source Publisher,
     *         or {@code false} if the source Publisher completes without emitting that item
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/contains.html&quot;&gt;ReactiveX operators documentation: Contains&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Single&lt;Boolean&gt; contains(final Object item) {
<span class="fc" id="L8157">        ObjectHelper.requireNonNull(item, &quot;item is null&quot;);</span>
<span class="fc" id="L8158">        return any(Functions.equalsWith(item));</span>
    }

    /**
     * Returns a Single that counts the total number of items emitted by the source Publisher and emits
     * this count as a 64-bit Long.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/longCount.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream and consumes the source {@code Publisher} in an
     *  unbounded manner (i.e., without applying backpressure).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code count} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @return a Single that emits a single item: the number of items emitted by the source Publisher as a
     *         64-bit Long item
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/count.html&quot;&gt;ReactiveX operators documentation: Count&lt;/a&gt;
     * @see #count()
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Single&lt;Long&gt; count() {
<span class="fc" id="L8183">        return RxJavaPlugins.onAssembly(new FlowableCountSingle&lt;T&gt;(this));</span>
    }

    /**
     * Returns a Flowable that mirrors the source Publisher, except that it drops items emitted by the
     * source Publisher that are followed by another item within a computed debounce duration.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;425&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/debounce.f.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * The delivery of the item happens on the thread of the first {@code onNext} or {@code onComplete}
     * signal of the generated {@code Publisher} sequence,
     * which if takes too long, a newer item may arrive from the upstream, causing the
     * generated sequence to get cancelled, which may also interrupt any downstream blocking operation
     * (yielding an {@code InterruptedException}). It is recommended processing items
     * that may take long time to be moved to another thread via {@link #observeOn} applied after
     * {@code debounce} itself.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not support backpressure as it uses the {@code debounceSelector} to mark
     *      boundaries.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code debounce} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;U&gt;
     *            the debounce value type (ignored)
     * @param debounceIndicator
     *            function to retrieve a sequence that indicates the throttle duration for each item
     * @return a Flowable that omits items emitted by the source Publisher that are followed by another item
     *         within a computed debounce duration
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/debounce.html&quot;&gt;ReactiveX operators documentation: Debounce&lt;/a&gt;
     * @see &lt;a href=&quot;https://github.com/ReactiveX/RxJava/wiki/Backpressure&quot;&gt;RxJava wiki: Backpressure&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;U&gt; Flowable&lt;T&gt; debounce(Function&lt;? super T, ? extends Publisher&lt;U&gt;&gt; debounceIndicator) {
<span class="fc" id="L8221">        ObjectHelper.requireNonNull(debounceIndicator, &quot;debounceIndicator is null&quot;);</span>
<span class="fc" id="L8222">        return RxJavaPlugins.onAssembly(new FlowableDebounce&lt;T, U&gt;(this, debounceIndicator));</span>
    }

    /**
     * Returns a Flowable that mirrors the source Publisher, except that it drops items emitted by the
     * source Publisher that are followed by newer items before a timeout value expires. The timer resets on
     * each emission.
     * &lt;p&gt;
     * &lt;em&gt;Note:&lt;/em&gt; If items keep being emitted by the source Publisher faster than the timeout then no items
     * will be emitted by the resulting Publisher.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/debounce.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * Delivery of the item after the grace period happens on the {@code computation} {@code Scheduler}'s
     * {@code Worker} which if takes too long, a newer item may arrive from the upstream, causing the
     * {@code Worker}'s task to get disposed, which may also interrupt any downstream blocking operation
     * (yielding an {@code InterruptedException}). It is recommended processing items
     * that may take long time to be moved to another thread via {@link #observeOn} applied after
     * {@code debounce} itself.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not support backpressure as it uses time to control data flow.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code debounce} operates by default on the {@code computation} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param timeout
     *            the length of the window of time that must pass after the emission of an item from the source
     *            Publisher in which that Publisher emits no items in order for the item to be emitted by the
     *            resulting Publisher
     * @param unit
     *            the unit of time for the specified {@code timeout}
     * @return a Flowable that filters out items from the source Publisher that are too quickly followed by
     *         newer items
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/debounce.html&quot;&gt;ReactiveX operators documentation: Debounce&lt;/a&gt;
     * @see &lt;a href=&quot;https://github.com/ReactiveX/RxJava/wiki/Backpressure&quot;&gt;RxJava wiki: Backpressure&lt;/a&gt;
     * @see #throttleWithTimeout(long, TimeUnit)
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.COMPUTATION)
    public final Flowable&lt;T&gt; debounce(long timeout, TimeUnit unit) {
<span class="fc" id="L8264">        return debounce(timeout, unit, Schedulers.computation());</span>
    }

    /**
     * Returns a Flowable that mirrors the source Publisher, except that it drops items emitted by the
     * source Publisher that are followed by newer items before a timeout value expires on a specified
     * Scheduler. The timer resets on each emission.
     * &lt;p&gt;
     * &lt;em&gt;Note:&lt;/em&gt; If items keep being emitted by the source Publisher faster than the timeout then no items
     * will be emitted by the resulting Publisher.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/debounce.s.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * Delivery of the item after the grace period happens on the given {@code Scheduler}'s
     * {@code Worker} which if takes too long, a newer item may arrive from the upstream, causing the
     * {@code Worker}'s task to get disposed, which may also interrupt any downstream blocking operation
     * (yielding an {@code InterruptedException}). It is recommended processing items
     * that may take long time to be moved to another thread via {@link #observeOn} applied after
     * {@code debounce} itself.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not support backpressure as it uses time to control data flow.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;You specify which {@link Scheduler} this operator will use.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param timeout
     *            the time each item has to be &quot;the most recent&quot; of those emitted by the source Publisher to
     *            ensure that it's not dropped
     * @param unit
     *            the unit of time for the specified {@code timeout}
     * @param scheduler
     *            the {@link Scheduler} to use internally to manage the timers that handle the timeout for each
     *            item
     * @return a Flowable that filters out items from the source Publisher that are too quickly followed by
     *         newer items
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/debounce.html&quot;&gt;ReactiveX operators documentation: Debounce&lt;/a&gt;
     * @see &lt;a href=&quot;https://github.com/ReactiveX/RxJava/wiki/Backpressure&quot;&gt;RxJava wiki: Backpressure&lt;/a&gt;
     * @see #throttleWithTimeout(long, TimeUnit, Scheduler)
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Flowable&lt;T&gt; debounce(long timeout, TimeUnit unit, Scheduler scheduler) {
<span class="fc" id="L8309">        ObjectHelper.requireNonNull(unit, &quot;unit is null&quot;);</span>
<span class="fc" id="L8310">        ObjectHelper.requireNonNull(scheduler, &quot;scheduler is null&quot;);</span>
<span class="fc" id="L8311">        return RxJavaPlugins.onAssembly(new FlowableDebounceTimed&lt;T&gt;(this, timeout, unit, scheduler));</span>
    }

    /**
     * Returns a Flowable that emits the items emitted by the source Publisher or a specified default item
     * if the source Publisher is empty.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/defaultIfEmpty.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;If the source {@code Publisher} is empty, this operator is guaranteed to honor backpressure from downstream.
     *  If the source {@code Publisher} is non-empty, it is expected to honor backpressure as well; if the rule is violated,
     *  a {@code MissingBackpressureException} &lt;em&gt;may&lt;/em&gt; get signaled somewhere downstream.
     *  &lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code defaultIfEmpty} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param defaultItem
     *            the item to emit if the source Publisher emits no items
     * @return a Flowable that emits either the specified default item if the source Publisher emits no
     *         items, or the items emitted by the source Publisher
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/defaultifempty.html&quot;&gt;ReactiveX operators documentation: DefaultIfEmpty&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;T&gt; defaultIfEmpty(T defaultItem) {
<span class="fc" id="L8340">        ObjectHelper.requireNonNull(defaultItem, &quot;defaultItem is null&quot;);</span>
<span class="fc" id="L8341">        return switchIfEmpty(just(defaultItem));</span>
    }

    /**
     * Returns a Flowable that delays the emissions of the source Publisher via another Publisher on a
     * per-item basis.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;450&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/delay.o.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * &lt;em&gt;Note:&lt;/em&gt; the resulting Publisher will immediately propagate any {@code onError} notification
     * from the source Publisher.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator doesn't interfere with the backpressure behavior which is determined by the source {@code Publisher}.
     *  All of the other {@code Publisher}s supplied by the function are consumed
     *  in an unbounded manner (i.e., no backpressure applied to them).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code delay} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;U&gt;
     *            the item delay value type (ignored)
     * @param itemDelayIndicator
     *            a function that returns a Publisher for each item emitted by the source Publisher, which is
     *            then used to delay the emission of that item by the resulting Publisher until the Publisher
     *            returned from {@code itemDelay} emits an item
     * @return a Flowable that delays the emissions of the source Publisher via another Publisher on a
     *         per-item basis
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/delay.html&quot;&gt;ReactiveX operators documentation: Delay&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;U&gt; Flowable&lt;T&gt; delay(final Function&lt;? super T, ? extends Publisher&lt;U&gt;&gt; itemDelayIndicator) {
<span class="fc" id="L8376">        ObjectHelper.requireNonNull(itemDelayIndicator, &quot;itemDelayIndicator is null&quot;);</span>
<span class="fc" id="L8377">        return flatMap(FlowableInternalHelper.itemDelay(itemDelayIndicator));</span>
    }

    /**
     * Returns a Flowable that emits the items emitted by the source Publisher shifted forward in time by a
     * specified delay. Error notifications from the source Publisher are not delayed.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/delay.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator doesn't interfere with the backpressure behavior which is determined by the source {@code Publisher}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code delay} operates by default on the {@code computation} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param delay
     *            the delay to shift the source by
     * @param unit
     *            the {@link TimeUnit} in which {@code period} is defined
     * @return the source Publisher shifted in time by the specified delay
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/delay.html&quot;&gt;ReactiveX operators documentation: Delay&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.COMPUTATION)
    public final Flowable&lt;T&gt; delay(long delay, TimeUnit unit) {
<span class="fc" id="L8403">        return delay(delay, unit, Schedulers.computation(), false);</span>
    }

    /**
     * Returns a Flowable that emits the items emitted by the source Publisher shifted forward in time by a
     * specified delay. If {@code delayError} is true, error notifications will also be delayed.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/delay.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator doesn't interfere with the backpressure behavior which is determined by the source {@code Publisher}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code delay} operates by default on the {@code computation} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param delay
     *            the delay to shift the source by
     * @param unit
     *            the {@link TimeUnit} in which {@code period} is defined
     * @param delayError
     *            if true, the upstream exception is signaled with the given delay, after all preceding normal elements,
     *            if false, the upstream exception is signaled immediately
     * @return the source Publisher shifted in time by the specified delay
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/delay.html&quot;&gt;ReactiveX operators documentation: Delay&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.COMPUTATION)
    public final Flowable&lt;T&gt; delay(long delay, TimeUnit unit, boolean delayError) {
<span class="fc" id="L8432">        return delay(delay, unit, Schedulers.computation(), delayError);</span>
    }

    /**
     * Returns a Flowable that emits the items emitted by the source Publisher shifted forward in time by a
     * specified delay. Error notifications from the source Publisher are not delayed.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/delay.s.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator doesn't interfere with the backpressure behavior which is determined by the source {@code Publisher}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;You specify which {@link Scheduler} this operator will use.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param delay
     *            the delay to shift the source by
     * @param unit
     *            the time unit of {@code delay}
     * @param scheduler
     *            the {@link Scheduler} to use for delaying
     * @return the source Publisher shifted in time by the specified delay
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/delay.html&quot;&gt;ReactiveX operators documentation: Delay&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Flowable&lt;T&gt; delay(long delay, TimeUnit unit, Scheduler scheduler) {
<span class="fc" id="L8460">        return delay(delay, unit, scheduler, false);</span>
    }

    /**
     * Returns a Flowable that emits the items emitted by the source Publisher shifted forward in time by a
     * specified delay. If {@code delayError} is true, error notifications will also be delayed.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/delay.s.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator doesn't interfere with the backpressure behavior which is determined by the source {@code Publisher}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;You specify which {@link Scheduler} this operator will use.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param delay
     *            the delay to shift the source by
     * @param unit
     *            the time unit of {@code delay}
     * @param scheduler
     *            the {@link Scheduler} to use for delaying
     * @param delayError
     *            if true, the upstream exception is signaled with the given delay, after all preceding normal elements,
     *            if false, the upstream exception is signaled immediately
     * @return the source Publisher shifted in time by the specified delay
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/delay.html&quot;&gt;ReactiveX operators documentation: Delay&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Flowable&lt;T&gt; delay(long delay, TimeUnit unit, Scheduler scheduler, boolean delayError) {
<span class="fc" id="L8492">        ObjectHelper.requireNonNull(unit, &quot;unit is null&quot;);</span>
<span class="fc" id="L8493">        ObjectHelper.requireNonNull(scheduler, &quot;scheduler is null&quot;);</span>

<span class="fc" id="L8495">        return RxJavaPlugins.onAssembly(new FlowableDelay&lt;T&gt;(this, Math.max(0L, delay), unit, scheduler, delayError));</span>
    }

    /**
     * Returns a Flowable that delays the subscription to and emissions from the source Publisher via another
     * Publisher on a per-item basis.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;450&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/delay.oo.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * &lt;em&gt;Note:&lt;/em&gt; the resulting Publisher will immediately propagate any {@code onError} notification
     * from the source Publisher.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator doesn't interfere with the backpressure behavior which is determined by the source {@code Publisher}.
     *  All of the other {@code Publisher}s supplied by the functions are consumed
     *  in an unbounded manner (i.e., no backpressure applied to them).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code delay} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;U&gt;
     *            the subscription delay value type (ignored)
     * @param &lt;V&gt;
     *            the item delay value type (ignored)
     * @param subscriptionIndicator
     *            a function that returns a Publisher that triggers the subscription to the source Publisher
     *            once it emits any item
     * @param itemDelayIndicator
     *            a function that returns a Publisher for each item emitted by the source Publisher, which is
     *            then used to delay the emission of that item by the resulting Publisher until the Publisher
     *            returned from {@code itemDelay} emits an item
     * @return a Flowable that delays the subscription and emissions of the source Publisher via another
     *         Publisher on a per-item basis
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/delay.html&quot;&gt;ReactiveX operators documentation: Delay&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;U, V&gt; Flowable&lt;T&gt; delay(Publisher&lt;U&gt; subscriptionIndicator,
            Function&lt;? super T, ? extends Publisher&lt;V&gt;&gt; itemDelayIndicator) {
<span class="fc" id="L8535">        return delaySubscription(subscriptionIndicator).delay(itemDelayIndicator);</span>
    }

    /**
     * Returns a Flowable that delays the subscription to this Publisher
     * until the other Publisher emits an element or completes normally.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator forwards the backpressure requests to this Publisher once
     *  the subscription happens and requests Long.MAX_VALUE from the other Publisher&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This method does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;U&gt; the value type of the other Publisher, irrelevant
     * @param subscriptionIndicator the other Publisher that should trigger the subscription
     *        to this Publisher.
     * @return a Flowable that delays the subscription to this Publisher
     *         until the other Publisher emits an element or completes normally.
     * @since 2.0
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;U&gt; Flowable&lt;T&gt; delaySubscription(Publisher&lt;U&gt; subscriptionIndicator) {
<span class="fc" id="L8561">        ObjectHelper.requireNonNull(subscriptionIndicator, &quot;subscriptionIndicator is null&quot;);</span>
<span class="fc" id="L8562">        return RxJavaPlugins.onAssembly(new FlowableDelaySubscriptionOther&lt;T, U&gt;(this, subscriptionIndicator));</span>
    }

    /**
     * Returns a Flowable that delays the subscription to the source Publisher by a given amount of time.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/delaySubscription.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator doesn't interfere with the backpressure behavior which is determined by the source {@code Publisher}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code delaySubscription} operates by default on the {@code computation} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param delay
     *            the time to delay the subscription
     * @param unit
     *            the time unit of {@code delay}
     * @return a Flowable that delays the subscription to the source Publisher by the given amount
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/delay.html&quot;&gt;ReactiveX operators documentation: Delay&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.COMPUTATION)
    public final Flowable&lt;T&gt; delaySubscription(long delay, TimeUnit unit) {
<span class="fc" id="L8587">        return delaySubscription(delay, unit, Schedulers.computation());</span>
    }

    /**
     * Returns a Flowable that delays the subscription to the source Publisher by a given amount of time,
     * both waiting and subscribing on a given Scheduler.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/delaySubscription.s.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator doesn't interfere with the backpressure behavior which is determined by the source {@code Publisher}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;You specify which {@link Scheduler} this operator will use.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param delay
     *            the time to delay the subscription
     * @param unit
     *            the time unit of {@code delay}
     * @param scheduler
     *            the Scheduler on which the waiting and subscription will happen
     * @return a Flowable that delays the subscription to the source Publisher by a given
     *         amount, waiting and subscribing on the given Scheduler
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/delay.html&quot;&gt;ReactiveX operators documentation: Delay&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Flowable&lt;T&gt; delaySubscription(long delay, TimeUnit unit, Scheduler scheduler) {
<span class="fc" id="L8616">        return delaySubscription(timer(delay, unit, scheduler));</span>
    }

    /**
     * Returns a Flowable that reverses the effect of {@link #materialize materialize} by transforming the
     * {@link Notification} objects emitted by the source Publisher into the items or notifications they
     * represent.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;335&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/dematerialize.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * When the upstream signals an {@link Notification#createOnError(Throwable) onError} or
     * {@link Notification#createOnComplete() onComplete} item, the
     * returned Flowable cancels the flow and terminates with that type of terminal event:
     * &lt;pre&gt;&lt;code&gt;
     * Flowable.just(createOnNext(1), createOnComplete(), createOnNext(2))
     * .doOnCancel(() -&amp;gt; System.out.println(&quot;Cancelled!&quot;));
     * .dematerialize()
     * .test()
     * .assertResult(1);
     * &lt;/code&gt;&lt;/pre&gt;
     * If the upstream signals {@code onError} or {@code onComplete} directly, the flow is terminated
     * with the same event.
     * &lt;pre&gt;&lt;code&gt;
     * Flowable.just(createOnNext(1), createOnNext(2))
     * .dematerialize()
     * .test()
     * .assertResult(1, 2);
     * &lt;/code&gt;&lt;/pre&gt;
     * If this behavior is not desired, the completion can be suppressed by applying {@link #concatWith(Publisher)}
     * with a {@link #never()} source.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s
     *  backpressure behavior.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code dematerialize} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T2&gt; the output value type
     * @return a Flowable that emits the items and notifications embedded in the {@link Notification} objects
     *         emitted by the source Publisher
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/materialize-dematerialize.html&quot;&gt;ReactiveX operators documentation: Dematerialize&lt;/a&gt;
     * @see #dematerialize(Function)
     * @deprecated in 2.2.4; inherently type-unsafe as it overrides the output generic type. Use {@link #dematerialize(Function)} instead.
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @Deprecated
    @SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
    public final &lt;T2&gt; Flowable&lt;T2&gt; dematerialize() {
<span class="fc" id="L8667">        return RxJavaPlugins.onAssembly(new FlowableDematerialize(this, Functions.identity()));</span>
    }

    /**
     * Returns a Flowable that reverses the effect of {@link #materialize materialize} by transforming the
     * {@link Notification} objects extracted from the source items via a selector function
     * into their respective {@code Subscriber} signal types.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;335&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/dematerialize.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * The intended use of the {@code selector} function is to perform a
     * type-safe identity mapping (see example) on a source that is already of type
     * {@code Notification&lt;T&gt;}. The Java language doesn't allow
     * limiting instance methods to a certain generic argument shape, therefore,
     * a function is used to ensure the conversion remains type safe.
     * &lt;p&gt;
     * When the upstream signals an {@link Notification#createOnError(Throwable) onError} or
     * {@link Notification#createOnComplete() onComplete} item, the
     * returned Flowable cancels of the flow and terminates with that type of terminal event:
     * &lt;pre&gt;&lt;code&gt;
     * Flowable.just(createOnNext(1), createOnComplete(), createOnNext(2))
     * .doOnCancel(() -&amp;gt; System.out.println(&quot;Canceled!&quot;));
     * .dematerialize(notification -&amp;gt; notification)
     * .test()
     * .assertResult(1);
     * &lt;/code&gt;&lt;/pre&gt;
     * If the upstream signals {@code onError} or {@code onComplete} directly, the flow is terminated
     * with the same event.
     * &lt;pre&gt;&lt;code&gt;
     * Flowable.just(createOnNext(1), createOnNext(2))
     * .dematerialize(notification -&amp;gt; notification)
     * .test()
     * .assertResult(1, 2);
     * &lt;/code&gt;&lt;/pre&gt;
     * If this behavior is not desired, the completion can be suppressed by applying {@link #concatWith(Publisher)}
     * with a {@link #never()} source.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s
     *  backpressure behavior.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code dematerialize} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;R&gt; the output value type
     * @param selector function that returns the upstream item and should return a Notification to signal
     * the corresponding {@code Subscriber} event to the downstream.
     * @return a Flowable that emits the items and notifications embedded in the {@link Notification} objects
     *         selected from the items emitted by the source Flowable
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/materialize-dematerialize.html&quot;&gt;ReactiveX operators documentation: Dematerialize&lt;/a&gt;
     * @since 2.2.4 - experimental
     */
    @Experimental
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    public final &lt;R&gt; Flowable&lt;R&gt; dematerialize(Function&lt;? super T, Notification&lt;R&gt;&gt; selector) {
<span class="fc" id="L8725">        ObjectHelper.requireNonNull(selector, &quot;selector is null&quot;);</span>
<span class="fc" id="L8726">        return RxJavaPlugins.onAssembly(new FlowableDematerialize&lt;T, R&gt;(this, selector));</span>
    }

    /**
     * Returns a Flowable that emits all items emitted by the source Publisher that are distinct
     * based on {@link Object#equals(Object)} comparison.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/distinct.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * It is recommended the elements' class {@code T} in the flow overrides the default {@code Object.equals()} and {@link Object#hashCode()} to provide
     * a meaningful comparison between items as the default Java implementation only considers reference equivalence.
     * &lt;p&gt;
     * By default, {@code distinct()} uses an internal {@link java.util.HashSet} per Subscriber to remember
     * previously seen items and uses {@link java.util.Set#add(Object)} returning {@code false} as the
     * indicator for duplicates.
     * &lt;p&gt;
     * Note that this internal {@code HashSet} may grow unbounded as items won't be removed from it by
     * the operator. Therefore, using very long or infinite upstream (with very distinct elements) may lead
     * to {@code OutOfMemoryError}.
     * &lt;p&gt;
     * Customizing the retention policy can happen only by providing a custom {@link java.util.Collection} implementation
     * to the {@link #distinct(Function, Callable)} overload.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s
     *  backpressure behavior.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code distinct} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @return a Flowable that emits only those items emitted by the source Publisher that are distinct from
     *         each other
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/distinct.html&quot;&gt;ReactiveX operators documentation: Distinct&lt;/a&gt;
     * @see #distinct(Function)
     * @see #distinct(Function, Callable)
     */
    @SuppressWarnings({ &quot;rawtypes&quot;, &quot;unchecked&quot; })
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;T&gt; distinct() {
<span class="fc" id="L8767">        return distinct((Function)Functions.identity(), Functions.&lt;T&gt;createHashSet());</span>
    }

    /**
     * Returns a Flowable that emits all items emitted by the source Publisher that are distinct according
     * to a key selector function and based on {@link Object#equals(Object)} comparison of the objects
     * returned by the key selector function.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/distinct.key.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * It is recommended the keys' class {@code K} overrides the default {@code Object.equals()} and {@link Object#hashCode()} to provide
     * a meaningful comparison between the key objects as the default Java implementation only considers reference equivalence.
     * &lt;p&gt;
     * By default, {@code distinct()} uses an internal {@link java.util.HashSet} per Subscriber to remember
     * previously seen keys and uses {@link java.util.Set#add(Object)} returning {@code false} as the
     * indicator for duplicates.
     * &lt;p&gt;
     * Note that this internal {@code HashSet} may grow unbounded as keys won't be removed from it by
     * the operator. Therefore, using very long or infinite upstream (with very distinct keys) may lead
     * to {@code OutOfMemoryError}.
     * &lt;p&gt;
     * Customizing the retention policy can happen only by providing a custom {@link java.util.Collection} implementation
     * to the {@link #distinct(Function, Callable)} overload.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s
     *  backpressure behavior.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code distinct} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;K&gt; the key type
     * @param keySelector
     *            a function that projects an emitted item to a key value that is used to decide whether an item
     *            is distinct from another one or not
     * @return a Flowable that emits those items emitted by the source Publisher that have distinct keys
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/distinct.html&quot;&gt;ReactiveX operators documentation: Distinct&lt;/a&gt;
     * @see #distinct(Function, Callable)
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;K&gt; Flowable&lt;T&gt; distinct(Function&lt;? super T, K&gt; keySelector) {
<span class="fc" id="L8810">        return distinct(keySelector, Functions.&lt;K&gt;createHashSet());</span>
    }

    /**
     * Returns a Flowable that emits all items emitted by the source Publisher that are distinct according
     * to a key selector function and based on {@link Object#equals(Object)} comparison of the objects
     * returned by the key selector function.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/distinct.key.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * It is recommended the keys' class {@code K} overrides the default {@code Object.equals()} and {@link Object#hashCode()} to provide
     * a meaningful comparison between the key objects as the default Java implementation only considers reference equivalence.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s
     *  backpressure behavior.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code distinct} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;K&gt; the key type
     * @param keySelector
     *            a function that projects an emitted item to a key value that is used to decide whether an item
     *            is distinct from another one or not
     * @param collectionSupplier
     *            function called for each individual Subscriber to return a Collection subtype for holding the extracted
     *            keys and whose add() method's return indicates uniqueness.
     * @return a Flowable that emits those items emitted by the source Publisher that have distinct keys
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/distinct.html&quot;&gt;ReactiveX operators documentation: Distinct&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;K&gt; Flowable&lt;T&gt; distinct(Function&lt;? super T, K&gt; keySelector,
            Callable&lt;? extends Collection&lt;? super K&gt;&gt; collectionSupplier) {
<span class="fc" id="L8845">        ObjectHelper.requireNonNull(keySelector, &quot;keySelector is null&quot;);</span>
<span class="fc" id="L8846">        ObjectHelper.requireNonNull(collectionSupplier, &quot;collectionSupplier is null&quot;);</span>
<span class="fc" id="L8847">        return RxJavaPlugins.onAssembly(new FlowableDistinct&lt;T, K&gt;(this, keySelector, collectionSupplier));</span>
    }

    /**
     * Returns a Flowable that emits all items emitted by the source Publisher that are distinct from their
     * immediate predecessors based on {@link Object#equals(Object)} comparison.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/distinctUntilChanged.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * It is recommended the elements' class {@code T} in the flow overrides the default {@code Object.equals()} to provide
     * a meaningful comparison between items as the default Java implementation only considers reference equivalence.
     * Alternatively, use the {@link #distinctUntilChanged(BiPredicate)} overload and provide a comparison function
     * in case the class {@code T} can't be overridden with custom {@code equals()} or the comparison itself
     * should happen on different terms or properties of the class {@code T}.
     * &lt;p&gt;
     * Note that the operator always retains the latest item from upstream regardless of the comparison result
     * and uses it in the next comparison with the next upstream item.
     * &lt;p&gt;
     * Note that if element type {@code T} in the flow is mutable, the comparison of the previous and current
     * item may yield unexpected results if the items are mutated externally. Common cases are mutable
     * {@code CharSequence}s or {@code List}s where the objects will actually have the same
     * references when they are modified and {@code distinctUntilChanged} will evaluate subsequent items as same.
     * To avoid such situation, it is recommended that mutable data is converted to an immutable one,
     * for example using {@code map(CharSequence::toString)} or {@code map(list -&gt; Collections.unmodifiableList(new ArrayList&lt;&gt;(list)))}.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s
     *  backpressure behavior.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code distinctUntilChanged} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @return a Flowable that emits those items from the source Publisher that are distinct from their
     *         immediate predecessors
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/distinct.html&quot;&gt;ReactiveX operators documentation: Distinct&lt;/a&gt;
     * @see #distinctUntilChanged(BiPredicate)
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;T&gt; distinctUntilChanged() {
<span class="fc" id="L8888">        return distinctUntilChanged(Functions.identity());</span>
    }

    /**
     * Returns a Flowable that emits all items emitted by the source Publisher that are distinct from their
     * immediate predecessors, according to a key selector function and based on {@link Object#equals(Object)} comparison
     * of those objects returned by the key selector function.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/distinctUntilChanged.key.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * It is recommended the keys' class {@code K} overrides the default {@code Object.equals()} to provide
     * a meaningful comparison between the key objects as the default Java implementation only considers reference equivalence.
     * Alternatively, use the {@link #distinctUntilChanged(BiPredicate)} overload and provide a comparison function
     * in case the class {@code K} can't be overridden with custom {@code equals()} or the comparison itself
     * should happen on different terms or properties of the item class {@code T} (for which the keys can be
     * derived via a similar selector).
     * &lt;p&gt;
     * Note that the operator always retains the latest key from upstream regardless of the comparison result
     * and uses it in the next comparison with the next key derived from the next upstream item.
     * &lt;p&gt;
     * Note that if element type {@code T} in the flow is mutable, the comparison of the previous and current
     * item may yield unexpected results if the items are mutated externally. Common cases are mutable
     * {@code CharSequence}s or {@code List}s where the objects will actually have the same
     * references when they are modified and {@code distinctUntilChanged} will evaluate subsequent items as same.
     * To avoid such situation, it is recommended that mutable data is converted to an immutable one,
     * for example using {@code map(CharSequence::toString)} or {@code map(list -&gt; Collections.unmodifiableList(new ArrayList&lt;&gt;(list)))}.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s
     *  backpressure behavior.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code distinctUntilChanged} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;K&gt; the key type
     * @param keySelector
     *            a function that projects an emitted item to a key value that is used to decide whether an item
     *            is distinct from another one or not
     * @return a Flowable that emits those items from the source Publisher whose keys are distinct from
     *         those of their immediate predecessors
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/distinct.html&quot;&gt;ReactiveX operators documentation: Distinct&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;K&gt; Flowable&lt;T&gt; distinctUntilChanged(Function&lt;? super T, K&gt; keySelector) {
<span class="fc" id="L8934">        ObjectHelper.requireNonNull(keySelector, &quot;keySelector is null&quot;);</span>
<span class="fc" id="L8935">        return RxJavaPlugins.onAssembly(new FlowableDistinctUntilChanged&lt;T, K&gt;(this, keySelector, ObjectHelper.equalsPredicate()));</span>
    }

    /**
     * Returns a Flowable that emits all items emitted by the source Publisher that are distinct from their
     * immediate predecessors when compared with each other via the provided comparator function.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/distinctUntilChanged.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * Note that the operator always retains the latest item from upstream regardless of the comparison result
     * and uses it in the next comparison with the next upstream item.
     * &lt;p&gt;
     * Note that if element type {@code T} in the flow is mutable, the comparison of the previous and current
     * item may yield unexpected results if the items are mutated externally. Common cases are mutable
     * {@code CharSequence}s or {@code List}s where the objects will actually have the same
     * references when they are modified and {@code distinctUntilChanged} will evaluate subsequent items as same.
     * To avoid such situation, it is recommended that mutable data is converted to an immutable one,
     * for example using {@code map(CharSequence::toString)} or {@code map(list -&gt; Collections.unmodifiableList(new ArrayList&lt;&gt;(list)))}.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s
     *  backpressure behavior.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code distinctUntilChanged} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param comparer the function that receives the previous item and the current item and is
     *                   expected to return true if the two are equal, thus skipping the current value.
     * @return a Flowable that emits those items from the source Publisher that are distinct from their
     *         immediate predecessors
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/distinct.html&quot;&gt;ReactiveX operators documentation: Distinct&lt;/a&gt;
     * @since 2.0
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;T&gt; distinctUntilChanged(BiPredicate&lt;? super T, ? super T&gt; comparer) {
<span class="fc" id="L8972">        ObjectHelper.requireNonNull(comparer, &quot;comparer is null&quot;);</span>
<span class="fc" id="L8973">        return RxJavaPlugins.onAssembly(new FlowableDistinctUntilChanged&lt;T, T&gt;(this, Functions.&lt;T&gt;identity(), comparer));</span>
    }

    /**
     * Calls the specified action after this Flowable signals onError or onCompleted or gets canceled by
     * the downstream.
     * &lt;p&gt;In case of a race between a terminal event and a cancellation, the provided {@code onFinally} action
     * is executed once per subscription.
     * &lt;p&gt;Note that the {@code onFinally} action is shared between subscriptions and as such
     * should be thread-safe.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure
     *  behavior.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code doFinally} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Operator-fusion:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator supports normal and conditional Subscribers as well as boundary-limited
     *  synchronous or asynchronous queue-fusion.&lt;/dd&gt;
     * &lt;/dl&gt;
     * &lt;p&gt;History: 2.0.1 - experimental
     * @param onFinally the action called when this Flowable terminates or gets canceled
     * @return the new Flowable instance
     * @since 2.1
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;T&gt; doFinally(Action onFinally) {
<span class="fc" id="L9002">        ObjectHelper.requireNonNull(onFinally, &quot;onFinally is null&quot;);</span>
<span class="fc" id="L9003">        return RxJavaPlugins.onAssembly(new FlowableDoFinally&lt;T&gt;(this, onFinally));</span>
    }

    /**
     * Calls the specified consumer with the current item after this item has been emitted to the downstream.
     * &lt;p&gt;Note that the {@code onAfterNext} action is shared between subscriptions and as such
     * should be thread-safe.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure
     *  behavior.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code doAfterNext} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Operator-fusion:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator supports normal and conditional Subscribers as well as boundary-limited
     *  synchronous or asynchronous queue-fusion.&lt;/dd&gt;
     * &lt;/dl&gt;
     * &lt;p&gt;History: 2.0.1 - experimental
     * @param onAfterNext the Consumer that will be called after emitting an item from upstream to the downstream
     * @return the new Flowable instance
     * @since 2.1
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;T&gt; doAfterNext(Consumer&lt;? super T&gt; onAfterNext) {
<span class="fc" id="L9029">        ObjectHelper.requireNonNull(onAfterNext, &quot;onAfterNext is null&quot;);</span>
<span class="fc" id="L9030">        return RxJavaPlugins.onAssembly(new FlowableDoAfterNext&lt;T&gt;(this, onAfterNext));</span>
    }

    /**
     * Registers an {@link Action} to be called when this Publisher invokes either
     * {@link Subscriber#onComplete onComplete} or {@link Subscriber#onError onError}.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/finallyDo.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure
     *  behavior.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code doAfterTerminate} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param onAfterTerminate
     *            an {@link Action} to be invoked when the source Publisher finishes
     * @return a Flowable that emits the same items as the source Publisher, then invokes the
     *         {@link Action}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/do.html&quot;&gt;ReactiveX operators documentation: Do&lt;/a&gt;
     * @see #doOnTerminate(Action)
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;T&gt; doAfterTerminate(Action onAfterTerminate) {
<span class="fc" id="L9057">        return doOnEach(Functions.emptyConsumer(), Functions.emptyConsumer(),</span>
                Functions.EMPTY_ACTION, onAfterTerminate);
    }

    /**
     * Calls the cancel {@code Action} if the downstream cancels the sequence.
     * &lt;p&gt;
     * The action is shared between subscriptions and thus may be called concurrently from multiple
     * threads; the action must be thread-safe.
     * &lt;p&gt;
     * If the action throws a runtime exception, that exception is rethrown by the {@code onCancel()} call,
     * sometimes as a {@code CompositeException} if there were multiple exceptions along the way.
     * &lt;p&gt;
     * Note that terminal events trigger the action unless the {@code Publisher} is subscribed to via {@code unsafeSubscribe()}.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnUnsubscribe.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code doOnCancel} does not interact with backpressure requests or value delivery; backpressure
     *  behavior is preserved between its upstream and its downstream.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code doOnCancel} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param onCancel
     *            the action that gets called when the source {@code Publisher}'s Subscription is canceled
     * @return the source {@code Publisher} modified so as to call this Action when appropriate
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/do.html&quot;&gt;ReactiveX operators documentation: Do&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;T&gt; doOnCancel(Action onCancel) {
<span class="fc" id="L9090">        return doOnLifecycle(Functions.emptyConsumer(), Functions.EMPTY_LONG_CONSUMER, onCancel);</span>
    }

    /**
     * Modifies the source Publisher so that it invokes an action when it calls {@code onComplete}.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnComplete.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s
     *  backpressure behavior.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code doOnComplete} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param onComplete
     *            the action to invoke when the source Publisher calls {@code onComplete}
     * @return the source Publisher with the side-effecting behavior applied
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/do.html&quot;&gt;ReactiveX operators documentation: Do&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;T&gt; doOnComplete(Action onComplete) {
<span class="fc" id="L9114">        return doOnEach(Functions.emptyConsumer(), Functions.emptyConsumer(),</span>
                onComplete, Functions.EMPTY_ACTION);
    }

    /**
     * Calls the appropriate onXXX consumer (shared between all subscribers) whenever a signal with the same type
     * passes through, before forwarding them to downstream.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnEach.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s
     *  backpressure behavior.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code doOnEach} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @return the source Publisher with the side-effecting behavior applied
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/do.html&quot;&gt;ReactiveX operators documentation: Do&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.NONE)
    private Flowable&lt;T&gt; doOnEach(Consumer&lt;? super T&gt; onNext, Consumer&lt;? super Throwable&gt; onError,
            Action onComplete, Action onAfterTerminate) {
<span class="fc" id="L9140">        ObjectHelper.requireNonNull(onNext, &quot;onNext is null&quot;);</span>
<span class="fc" id="L9141">        ObjectHelper.requireNonNull(onError, &quot;onError is null&quot;);</span>
<span class="fc" id="L9142">        ObjectHelper.requireNonNull(onComplete, &quot;onComplete is null&quot;);</span>
<span class="fc" id="L9143">        ObjectHelper.requireNonNull(onAfterTerminate, &quot;onAfterTerminate is null&quot;);</span>
<span class="fc" id="L9144">        return RxJavaPlugins.onAssembly(new FlowableDoOnEach&lt;T&gt;(this, onNext, onError, onComplete, onAfterTerminate));</span>
    }

    /**
     * Modifies the source Publisher so that it invokes an action for each item it emits.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnEach.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s
     *  backpressure behavior.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code doOnEach} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param onNotification
     *            the action to invoke for each item emitted by the source Publisher
     * @return the source Publisher with the side-effecting behavior applied
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/do.html&quot;&gt;ReactiveX operators documentation: Do&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;T&gt; doOnEach(final Consumer&lt;? super Notification&lt;T&gt;&gt; onNotification) {
<span class="fc" id="L9169">        ObjectHelper.requireNonNull(onNotification, &quot;onNotification is null&quot;);</span>
<span class="fc" id="L9170">        return doOnEach(</span>
<span class="fc" id="L9171">                Functions.notificationOnNext(onNotification),</span>
<span class="fc" id="L9172">                Functions.notificationOnError(onNotification),</span>
<span class="fc" id="L9173">                Functions.notificationOnComplete(onNotification),</span>
                Functions.EMPTY_ACTION
            );
    }

    /**
     * Modifies the source Publisher so that it notifies a Subscriber for each item and terminal event it emits.
     * &lt;p&gt;
     * In case the {@code onError} of the supplied Subscriber throws, the downstream will receive a composite
     * exception containing the original exception and the exception thrown by {@code onError}. If either the
     * {@code onNext} or the {@code onComplete} method of the supplied Subscriber throws, the downstream will be
     * terminated and will receive this thrown exception.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnEach.o.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s
     *  backpressure behavior.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code doOnEach} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param subscriber
     *            the Subscriber to be notified about onNext, onError and onComplete events on its
     *            respective methods before the actual downstream Subscriber gets notified.
     * @return the source Publisher with the side-effecting behavior applied
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/do.html&quot;&gt;ReactiveX operators documentation: Do&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;T&gt; doOnEach(final Subscriber&lt;? super T&gt; subscriber) {
<span class="fc" id="L9206">        ObjectHelper.requireNonNull(subscriber, &quot;subscriber is null&quot;);</span>
<span class="fc" id="L9207">        return doOnEach(</span>
<span class="fc" id="L9208">                FlowableInternalHelper.subscriberOnNext(subscriber),</span>
<span class="fc" id="L9209">                FlowableInternalHelper.subscriberOnError(subscriber),</span>
<span class="fc" id="L9210">                FlowableInternalHelper.subscriberOnComplete(subscriber),</span>
                Functions.EMPTY_ACTION);
    }

    /**
     * Modifies the source Publisher so that it invokes an action if it calls {@code onError}.
     * &lt;p&gt;
     * In case the {@code onError} action throws, the downstream will receive a composite exception containing
     * the original exception and the exception thrown by {@code onError}.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnError.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s
     *  backpressure behavior.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code doOnError} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param onError
     *            the action to invoke if the source Publisher calls {@code onError}
     * @return the source Publisher with the side-effecting behavior applied
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/do.html&quot;&gt;ReactiveX operators documentation: Do&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;T&gt; doOnError(Consumer&lt;? super Throwable&gt; onError) {
<span class="fc" id="L9238">        return doOnEach(Functions.emptyConsumer(), onError,</span>
                Functions.EMPTY_ACTION, Functions.EMPTY_ACTION);
    }

    /**
     * Calls the appropriate onXXX method (shared between all Subscribers) for the lifecycle events of
     * the sequence (subscription, cancellation, requesting).
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnNext.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s
     *  backpressure behavior.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code doOnLifecycle} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param onSubscribe
     *              a Consumer called with the Subscription sent via Subscriber.onSubscribe()
     * @param onRequest
     *              a LongConsumer called with the request amount sent via Subscription.request()
     * @param onCancel
     *              called when the downstream cancels the Subscription via cancel()
     * @return the source Publisher with the side-effecting behavior applied
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/do.html&quot;&gt;ReactiveX operators documentation: Do&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;T&gt; doOnLifecycle(final Consumer&lt;? super Subscription&gt; onSubscribe,
            final LongConsumer onRequest, final Action onCancel) {
<span class="fc" id="L9270">        ObjectHelper.requireNonNull(onSubscribe, &quot;onSubscribe is null&quot;);</span>
<span class="fc" id="L9271">        ObjectHelper.requireNonNull(onRequest, &quot;onRequest is null&quot;);</span>
<span class="fc" id="L9272">        ObjectHelper.requireNonNull(onCancel, &quot;onCancel is null&quot;);</span>
<span class="fc" id="L9273">        return RxJavaPlugins.onAssembly(new FlowableDoOnLifecycle&lt;T&gt;(this, onSubscribe, onRequest, onCancel));</span>
    }

    /**
     * Modifies the source Publisher so that it invokes an action when it calls {@code onNext}.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnNext.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s
     *  backpressure behavior.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code doOnNext} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param onNext
     *            the action to invoke when the source Publisher calls {@code onNext}
     * @return the source Publisher with the side-effecting behavior applied
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/do.html&quot;&gt;ReactiveX operators documentation: Do&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;T&gt; doOnNext(Consumer&lt;? super T&gt; onNext) {
<span class="fc" id="L9297">        return doOnEach(onNext, Functions.emptyConsumer(),</span>
                Functions.EMPTY_ACTION, Functions.EMPTY_ACTION);
    }

    /**
     * Modifies the source {@code Publisher} so that it invokes the given action when it receives a
     * request for more items.
     * &lt;p&gt;
     * &lt;b&gt;Note:&lt;/b&gt; This operator is for tracing the internal behavior of back-pressure request
     * patterns and generally intended for debugging use.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s
     *  backpressure behavior.&lt;/dd&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code doOnRequest} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param onRequest
     *            the action that gets called when a Subscriber requests items from this
     *            {@code Publisher}
     * @return the source {@code Publisher} modified so as to call this Action when appropriate
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/do.html&quot;&gt;ReactiveX operators
     *      documentation: Do&lt;/a&gt;
     * @since 2.0
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;T&gt; doOnRequest(LongConsumer onRequest) {
<span class="fc" id="L9327">        return doOnLifecycle(Functions.emptyConsumer(), onRequest, Functions.EMPTY_ACTION);</span>
    }

    /**
     * Modifies the source {@code Publisher} so that it invokes the given action when it is subscribed from
     * its subscribers. Each subscription will result in an invocation of the given action except when the
     * source {@code Publisher} is reference counted, in which case the source {@code Publisher} will invoke
     * the given action for the first subscription.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;390&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnSubscribe.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s
     *  backpressure behavior.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code doOnSubscribe} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param onSubscribe
     *            the Consumer that gets called when a Subscriber subscribes to the current {@code Flowable}
     * @return the source {@code Publisher} modified so as to call this Consumer when appropriate
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/do.html&quot;&gt;ReactiveX operators documentation: Do&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;T&gt; doOnSubscribe(Consumer&lt;? super Subscription&gt; onSubscribe) {
<span class="fc" id="L9354">        return doOnLifecycle(onSubscribe, Functions.EMPTY_LONG_CONSUMER, Functions.EMPTY_ACTION);</span>
    }

    /**
     * Modifies the source Publisher so that it invokes an action when it calls {@code onComplete} or
     * {@code onError}.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnTerminate.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * This differs from {@code doAfterTerminate} in that this happens &lt;em&gt;before&lt;/em&gt; the {@code onComplete} or
     * {@code onError} notification.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s
     *  backpressure behavior.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code doOnTerminate} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param onTerminate
     *            the action to invoke when the source Publisher calls {@code onComplete} or {@code onError}
     * @return the source Publisher with the side-effecting behavior applied
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/do.html&quot;&gt;ReactiveX operators documentation: Do&lt;/a&gt;
     * @see #doAfterTerminate(Action)
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;T&gt; doOnTerminate(final Action onTerminate) {
<span class="fc" id="L9383">        return doOnEach(Functions.emptyConsumer(), Functions.actionConsumer(onTerminate),</span>
                onTerminate, Functions.EMPTY_ACTION);
    }

    /**
     * Returns a Maybe that emits the single item at a specified index in a sequence of emissions from
     * this Flowable or completes if this Flowable sequence has fewer elements than index.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/elementAt.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream and consumes the source {@code Publisher} in an unbounded manner
     *  (i.e., no backpressure applied to it).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code elementAt} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param index
     *            the zero-based index of the item to retrieve
     * @return a Maybe that emits a single item: the item at the specified position in the sequence of
     *         those emitted by the source Publisher
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/elementat.html&quot;&gt;ReactiveX operators documentation: ElementAt&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Maybe&lt;T&gt; elementAt(long index) {
<span class="fc bfc" id="L9410" title="All 2 branches covered.">        if (index &lt; 0) {</span>
<span class="fc" id="L9411">            throw new IndexOutOfBoundsException(&quot;index &gt;= 0 required but it was &quot; + index);</span>
        }
<span class="fc" id="L9413">        return RxJavaPlugins.onAssembly(new FlowableElementAtMaybe&lt;T&gt;(this, index));</span>
    }

    /**
     * Returns a Single that emits the item found at a specified index in a sequence of emissions from
     * this Flowable, or a default item if that index is out of range.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/elementAtOrDefault.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream and consumes the source {@code Publisher} in an unbounded manner
     *  (i.e., no backpressure applied to it).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code elementAt} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param index
     *            the zero-based index of the item to retrieve
     * @param defaultItem
     *            the default item
     * @return a Single that emits the item at the specified position in the sequence emitted by the source
     *         Publisher, or the default item if that index is outside the bounds of the source sequence
     * @throws IndexOutOfBoundsException
     *             if {@code index} is less than 0
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/elementat.html&quot;&gt;ReactiveX operators documentation: ElementAt&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Single&lt;T&gt; elementAt(long index, T defaultItem) {
<span class="fc bfc" id="L9444" title="All 2 branches covered.">        if (index &lt; 0) {</span>
<span class="fc" id="L9445">            throw new IndexOutOfBoundsException(&quot;index &gt;= 0 required but it was &quot; + index);</span>
        }
<span class="fc" id="L9447">        ObjectHelper.requireNonNull(defaultItem, &quot;defaultItem is null&quot;);</span>
<span class="fc" id="L9448">        return RxJavaPlugins.onAssembly(new FlowableElementAtSingle&lt;T&gt;(this, index, defaultItem));</span>
    }

    /**
     * Returns a Single that emits the item found at a specified index in a sequence of emissions from
     * this Flowable or signals a {@link NoSuchElementException} if this Flowable has fewer elements than index.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/elementAtOrDefault.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream and consumes the source {@code Publisher} in an unbounded manner
     *  (i.e., no backpressure applied to it).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code elementAtOrError} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param index
     *            the zero-based index of the item to retrieve
     * @return a Single that emits the item at the specified position in the sequence emitted by the source
     *         Publisher, or the default item if that index is outside the bounds of the source sequence
     * @throws IndexOutOfBoundsException
     *             if {@code index} is less than 0
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/elementat.html&quot;&gt;ReactiveX operators documentation: ElementAt&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Single&lt;T&gt; elementAtOrError(long index) {
<span class="fc bfc" id="L9476" title="All 2 branches covered.">        if (index &lt; 0) {</span>
<span class="fc" id="L9477">            throw new IndexOutOfBoundsException(&quot;index &gt;= 0 required but it was &quot; + index);</span>
        }
<span class="fc" id="L9479">        return RxJavaPlugins.onAssembly(new FlowableElementAtSingle&lt;T&gt;(this, index, null));</span>
    }

    /**
     * Filters items emitted by a Publisher by only emitting those that satisfy a specified predicate.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/filter.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure
     *  behavior.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code filter} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param predicate
     *            a function that evaluates each item emitted by the source Publisher, returning {@code true}
     *            if it passes the filter
     * @return a Flowable that emits only those items emitted by the source Publisher that the filter
     *         evaluates as {@code true}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/filter.html&quot;&gt;ReactiveX operators documentation: Filter&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate) {
<span class="fc" id="L9506">        ObjectHelper.requireNonNull(predicate, &quot;predicate is null&quot;);</span>
<span class="fc" id="L9507">        return RxJavaPlugins.onAssembly(new FlowableFilter&lt;T&gt;(this, predicate));</span>
    }

    /**
     * Returns a Maybe that emits only the very first item emitted by this Flowable or
     * completes if this Flowable is empty.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;237&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/firstElement.m.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream and consumes the source {@code Publisher} in an
     *  unbounded manner (i.e., without applying backpressure).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code firstElement} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @return the new Maybe instance
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/first.html&quot;&gt;ReactiveX operators documentation: First&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.SPECIAL) // take may trigger UNBOUNDED_IN
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Maybe&lt;T&gt; firstElement() {
<span class="fc" id="L9530">        return elementAt(0);</span>
    }

    /**
     * Returns a Single that emits only the very first item emitted by this Flowable, or a default
     * item if this Flowable completes without emitting anything.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/first.s.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream and consumes the source {@code Publisher} in an
     *  unbounded manner (i.e., without applying backpressure).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code first} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param defaultItem
     *            the default item to emit if the source Publisher doesn't emit anything
     * @return a Single that emits only the very first item from the source, or a default item if the
     *         source Publisher completes without emitting any items
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/first.html&quot;&gt;ReactiveX operators documentation: First&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.SPECIAL) // take may trigger UNBOUNDED_IN
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Single&lt;T&gt; first(T defaultItem) {
<span class="fc" id="L9556">        return elementAt(0, defaultItem);</span>
    }

    /**
     * Returns a Single that emits only the very first item emitted by this Flowable or
     * signals a {@link NoSuchElementException} if this Flowable is empty.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;237&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/firstOrError.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream and consumes the source {@code Publisher} in an
     *  unbounded manner (i.e., without applying backpressure).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code firstOrError} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @return the new Single instance
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/first.html&quot;&gt;ReactiveX operators documentation: First&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.SPECIAL) // take may trigger UNBOUNDED_IN
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Single&lt;T&gt; firstOrError() {
<span class="fc" id="L9579">        return elementAtOrError(0);</span>
    }

    /**
     * Returns a Flowable that emits items based on applying a function that you supply to each item emitted
     * by the source Publisher, where that function returns a Publisher, and then merging those resulting
     * Publishers and emitting the results of this merger.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flatMap.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream. The upstream Flowable is consumed
     *  in a bounded manner (up to {@link #bufferSize()} outstanding request amount for items).
     *  The inner {@code Publisher}s are expected to honor backpressure; if violated,
     *  the operator &lt;em&gt;may&lt;/em&gt; signal {@code MissingBackpressureException}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code flatMap} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;R&gt; the value type of the inner Publishers and the output type
     * @param mapper
     *            a function that, when applied to an item emitted by the source Publisher, returns a
     *            Publisher
     * @return a Flowable that emits the result of applying the transformation function to each item emitted
     *         by the source Publisher and merging the results of the Publishers obtained from this
     *         transformation
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/flatmap.html&quot;&gt;ReactiveX operators documentation: FlatMap&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;R&gt; Flowable&lt;R&gt; flatMap(Function&lt;? super T, ? extends Publisher&lt;? extends R&gt;&gt; mapper) {
<span class="fc" id="L9611">        return flatMap(mapper, false, bufferSize(), bufferSize());</span>
    }

    /**
     * Returns a Flowable that emits items based on applying a function that you supply to each item emitted
     * by the source Publisher, where that function returns a Publisher, and then merging those resulting
     * Publishers and emitting the results of this merger.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flatMap.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream. The upstream Flowable is consumed
     *  in a bounded manner (up to {@link #bufferSize()} outstanding request amount for items).
     *  The inner {@code Publisher}s are expected to honor backpressure; if violated,
     *  the operator &lt;em&gt;may&lt;/em&gt; signal {@code MissingBackpressureException}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code flatMap} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;R&gt; the value type of the inner Publishers and the output type
     * @param mapper
     *            a function that, when applied to an item emitted by the source Publisher, returns a
     *            Publisher
     * @param delayErrors
     *            if true, exceptions from the current Flowable and all inner Publishers are delayed until all of them terminate
     *            if false, the first one signaling an exception will terminate the whole sequence immediately
     * @return a Flowable that emits the result of applying the transformation function to each item emitted
     *         by the source Publisher and merging the results of the Publishers obtained from this
     *         transformation
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/flatmap.html&quot;&gt;ReactiveX operators documentation: FlatMap&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;R&gt; Flowable&lt;R&gt; flatMap(Function&lt;? super T, ? extends Publisher&lt;? extends R&gt;&gt; mapper, boolean delayErrors) {
<span class="fc" id="L9646">        return flatMap(mapper, delayErrors, bufferSize(), bufferSize());</span>
    }

    /**
     * Returns a Flowable that emits items based on applying a function that you supply to each item emitted
     * by the source Publisher, where that function returns a Publisher, and then merging those resulting
     * Publishers and emitting the results of this merger, while limiting the maximum number of concurrent
     * subscriptions to these Publishers.
     * &lt;!-- &lt;p&gt; --&gt;
     * &lt;!-- &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flatMap.png&quot; alt=&quot;&quot;&gt; --&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream. The upstream Flowable is consumed
     *  in a bounded manner (up to {@code maxConcurrency} outstanding request amount for items).
     *  The inner {@code Publisher}s are expected to honor backpressure; if violated,
     *  the operator &lt;em&gt;may&lt;/em&gt; signal {@code MissingBackpressureException}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code flatMap} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;R&gt; the value type of the inner Publishers and the output type
     * @param mapper
     *            a function that, when applied to an item emitted by the source Publisher, returns a
     *            Publisher
     * @param maxConcurrency
     *         the maximum number of Publishers that may be subscribed to concurrently
     * @return a Flowable that emits the result of applying the transformation function to each item emitted
     *         by the source Publisher and merging the results of the Publishers obtained from this
     *         transformation
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/flatmap.html&quot;&gt;ReactiveX operators documentation: FlatMap&lt;/a&gt;
     * @since 2.0
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;R&gt; Flowable&lt;R&gt; flatMap(Function&lt;? super T, ? extends Publisher&lt;? extends R&gt;&gt; mapper, int maxConcurrency) {
<span class="fc" id="L9682">        return flatMap(mapper, false, maxConcurrency, bufferSize());</span>
    }

    /**
     * Returns a Flowable that emits items based on applying a function that you supply to each item emitted
     * by the source Publisher, where that function returns a Publisher, and then merging those resulting
     * Publishers and emitting the results of this merger, while limiting the maximum number of concurrent
     * subscriptions to these Publishers.
     * &lt;!-- &lt;p&gt; --&gt;
     * &lt;!-- &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flatMap.png&quot; alt=&quot;&quot;&gt; --&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream. The upstream Flowable is consumed
     *  in a bounded manner (up to {@code maxConcurrency} outstanding request amount for items).
     *  The inner {@code Publisher}s are expected to honor backpressure; if violated,
     *  the operator &lt;em&gt;may&lt;/em&gt; signal {@code MissingBackpressureException}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code flatMap} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;R&gt; the value type of the inner Publishers and the output type
     * @param mapper
     *            a function that, when applied to an item emitted by the source Publisher, returns a
     *            Publisher
     * @param maxConcurrency
     *         the maximum number of Publishers that may be subscribed to concurrently
     * @param delayErrors
     *            if true, exceptions from the current Flowable and all inner Publishers are delayed until all of them terminate
     *            if false, the first one signaling an exception will terminate the whole sequence immediately
     * @return a Flowable that emits the result of applying the transformation function to each item emitted
     *         by the source Publisher and merging the results of the Publishers obtained from this
     *         transformation
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/flatmap.html&quot;&gt;ReactiveX operators documentation: FlatMap&lt;/a&gt;
     * @since 2.0
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;R&gt; Flowable&lt;R&gt; flatMap(Function&lt;? super T, ? extends Publisher&lt;? extends R&gt;&gt; mapper, boolean delayErrors, int maxConcurrency) {
<span class="fc" id="L9721">        return flatMap(mapper, delayErrors, maxConcurrency, bufferSize());</span>
    }

    /**
     * Returns a Flowable that emits items based on applying a function that you supply to each item emitted
     * by the source Publisher, where that function returns a Publisher, and then merging those resulting
     * Publishers and emitting the results of this merger, while limiting the maximum number of concurrent
     * subscriptions to these Publishers.
     * &lt;!-- &lt;p&gt; --&gt;
     * &lt;!-- &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flatMap.png&quot; alt=&quot;&quot;&gt; --&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream. The upstream Flowable is consumed
     *  in a bounded manner (up to {@code maxConcurrency} outstanding request amount for items).
     *  The inner {@code Publisher}s are expected to honor backpressure; if violated,
     *  the operator &lt;em&gt;may&lt;/em&gt; signal {@code MissingBackpressureException}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code flatMap} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;R&gt; the value type of the inner Publishers and the output type
     * @param mapper
     *            a function that, when applied to an item emitted by the source Publisher, returns a
     *            Publisher
     * @param maxConcurrency
     *         the maximum number of Publishers that may be subscribed to concurrently
     * @param delayErrors
     *            if true, exceptions from the current Flowable and all inner Publishers are delayed until all of them terminate
     *            if false, the first one signaling an exception will terminate the whole sequence immediately
     * @param bufferSize
     *            the number of elements to prefetch from each inner Publisher
     * @return a Flowable that emits the result of applying the transformation function to each item emitted
     *         by the source Publisher and merging the results of the Publishers obtained from this
     *         transformation
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/flatmap.html&quot;&gt;ReactiveX operators documentation: FlatMap&lt;/a&gt;
     * @since 2.0
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;R&gt; Flowable&lt;R&gt; flatMap(Function&lt;? super T, ? extends Publisher&lt;? extends R&gt;&gt; mapper,
            boolean delayErrors, int maxConcurrency, int bufferSize) {
<span class="fc" id="L9764">        ObjectHelper.requireNonNull(mapper, &quot;mapper is null&quot;);</span>
<span class="fc" id="L9765">        ObjectHelper.verifyPositive(maxConcurrency, &quot;maxConcurrency&quot;);</span>
<span class="fc" id="L9766">        ObjectHelper.verifyPositive(bufferSize, &quot;bufferSize&quot;);</span>
<span class="fc bfc" id="L9767" title="All 2 branches covered.">        if (this instanceof ScalarCallable) {</span>
            @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L9769">            T v = ((ScalarCallable&lt;T&gt;)this).call();</span>
<span class="fc bfc" id="L9770" title="All 2 branches covered.">            if (v == null) {</span>
<span class="fc" id="L9771">                return empty();</span>
            }
<span class="fc" id="L9773">            return FlowableScalarXMap.scalarXMap(v, mapper);</span>
        }
<span class="fc" id="L9775">        return RxJavaPlugins.onAssembly(new FlowableFlatMap&lt;T, R&gt;(this, mapper, delayErrors, maxConcurrency, bufferSize));</span>
    }

    /**
     * Returns a Flowable that applies a function to each item emitted or notification raised by the source
     * Publisher and then flattens the Publishers returned from these functions and emits the resulting items.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;410&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/mergeMap.nce.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream. The upstream Flowable is consumed
     *  in a bounded manner (up to {@link #bufferSize()} outstanding request amount for items).
     *  The inner {@code Publisher}s are expected to honor backpressure; if violated,
     *  the operator &lt;em&gt;may&lt;/em&gt; signal {@code MissingBackpressureException}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code flatMap} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;R&gt;
     *            the result type
     * @param onNextMapper
     *            a function that returns a Publisher to merge for each item emitted by the source Publisher
     * @param onErrorMapper
     *            a function that returns a Publisher to merge for an onError notification from the source
     *            Publisher
     * @param onCompleteSupplier
     *            a function that returns a Publisher to merge for an onComplete notification from the source
     *            Publisher
     * @return a Flowable that emits the results of merging the Publishers returned from applying the
     *         specified functions to the emissions and notifications of the source Publisher
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/flatmap.html&quot;&gt;ReactiveX operators documentation: FlatMap&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;R&gt; Flowable&lt;R&gt; flatMap(
            Function&lt;? super T, ? extends Publisher&lt;? extends R&gt;&gt; onNextMapper,
            Function&lt;? super Throwable, ? extends Publisher&lt;? extends R&gt;&gt; onErrorMapper,
            Callable&lt;? extends Publisher&lt;? extends R&gt;&gt; onCompleteSupplier) {
<span class="fc" id="L9815">        ObjectHelper.requireNonNull(onNextMapper, &quot;onNextMapper is null&quot;);</span>
<span class="fc" id="L9816">        ObjectHelper.requireNonNull(onErrorMapper, &quot;onErrorMapper is null&quot;);</span>
<span class="fc" id="L9817">        ObjectHelper.requireNonNull(onCompleteSupplier, &quot;onCompleteSupplier is null&quot;);</span>
<span class="fc" id="L9818">        return merge(new FlowableMapNotification&lt;T, Publisher&lt;? extends R&gt;&gt;(this, onNextMapper, onErrorMapper, onCompleteSupplier));</span>
    }

    /**
     * Returns a Flowable that applies a function to each item emitted or notification raised by the source
     * Publisher and then flattens the Publishers returned from these functions and emits the resulting items,
     * while limiting the maximum number of concurrent subscriptions to these Publishers.
     * &lt;!-- &lt;p&gt; --&gt;
     * &lt;!-- &lt;img width=&quot;640&quot; height=&quot;410&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/mergeMap.nce.png&quot; alt=&quot;&quot;&gt; --&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream. The upstream Flowable is consumed
     *  in a bounded manner (up to {@code maxConcurrency} outstanding request amount for items).
     *  The inner {@code Publisher}s are expected to honor backpressure; if violated,
     *  the operator &lt;em&gt;may&lt;/em&gt; signal {@code MissingBackpressureException}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code flatMap} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;R&gt;
     *            the result type
     * @param onNextMapper
     *            a function that returns a Publisher to merge for each item emitted by the source Publisher
     * @param onErrorMapper
     *            a function that returns a Publisher to merge for an onError notification from the source
     *            Publisher
     * @param onCompleteSupplier
     *            a function that returns a Publisher to merge for an onComplete notification from the source
     *            Publisher
     * @param maxConcurrency
     *         the maximum number of Publishers that may be subscribed to concurrently
     * @return a Flowable that emits the results of merging the Publishers returned from applying the
     *         specified functions to the emissions and notifications of the source Publisher
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/flatmap.html&quot;&gt;ReactiveX operators documentation: FlatMap&lt;/a&gt;
     * @since 2.0
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;R&gt; Flowable&lt;R&gt; flatMap(
            Function&lt;? super T, ? extends Publisher&lt;? extends R&gt;&gt; onNextMapper,
            Function&lt;Throwable, ? extends Publisher&lt;? extends R&gt;&gt; onErrorMapper,
            Callable&lt;? extends Publisher&lt;? extends R&gt;&gt; onCompleteSupplier,
            int maxConcurrency) {
<span class="fc" id="L9863">        ObjectHelper.requireNonNull(onNextMapper, &quot;onNextMapper is null&quot;);</span>
<span class="fc" id="L9864">        ObjectHelper.requireNonNull(onErrorMapper, &quot;onErrorMapper is null&quot;);</span>
<span class="fc" id="L9865">        ObjectHelper.requireNonNull(onCompleteSupplier, &quot;onCompleteSupplier is null&quot;);</span>
<span class="fc" id="L9866">        return merge(new FlowableMapNotification&lt;T, Publisher&lt;? extends R&gt;&gt;(</span>
                this, onNextMapper, onErrorMapper, onCompleteSupplier), maxConcurrency);
    }

    /**
     * Returns a Flowable that emits the results of a specified function to the pair of values emitted by the
     * source Publisher and a specified collection Publisher.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;390&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/mergeMap.r.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream. The upstream Flowable is consumed
     *  in a bounded manner (up to {@code maxConcurrency} outstanding request amount for items).
     *  The inner {@code Publisher}s are expected to honor backpressure; if violated,
     *  the operator &lt;em&gt;may&lt;/em&gt; signal {@code MissingBackpressureException}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code flatMap} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;U&gt;
     *            the type of items emitted by the inner Publishers
     * @param &lt;R&gt;
     *            the type of items emitted by the combiner function
     * @param mapper
     *            a function that returns a Publisher for each item emitted by the source Publisher
     * @param combiner
     *            a function that combines one item emitted by each of the source and collection Publishers and
     *            returns an item to be emitted by the resulting Publisher
     * @return a Flowable that emits the results of applying a function to a pair of values emitted by the
     *         source Publisher and the collection Publisher
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/flatmap.html&quot;&gt;ReactiveX operators documentation: FlatMap&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;U, R&gt; Flowable&lt;R&gt; flatMap(Function&lt;? super T, ? extends Publisher&lt;? extends U&gt;&gt; mapper,
            BiFunction&lt;? super T, ? super U, ? extends R&gt; combiner) {
<span class="fc" id="L9903">        return flatMap(mapper, combiner, false, bufferSize(), bufferSize());</span>
    }

    /**
     * Returns a Flowable that emits the results of a specified function to the pair of values emitted by the
     * source Publisher and a specified collection Publisher.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;390&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/mergeMap.r.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream. The upstream Flowable is consumed
     *  in a bounded manner (up to {@link #bufferSize()} outstanding request amount for items).
     *  The inner {@code Publisher}s are expected to honor backpressure; if violated,
     *  the operator &lt;em&gt;may&lt;/em&gt; signal {@code MissingBackpressureException}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code flatMap} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;U&gt;
     *            the type of items emitted by the inner Publishers
     * @param &lt;R&gt;
     *            the type of items emitted by the combiner functions
     * @param mapper
     *            a function that returns a Publisher for each item emitted by the source Publisher
     * @param combiner
     *            a function that combines one item emitted by each of the source and collection Publishers and
     *            returns an item to be emitted by the resulting Publisher
     * @param delayErrors
     *            if true, exceptions from the current Flowable and all inner Publishers are delayed until all of them terminate
     *            if false, the first one signaling an exception will terminate the whole sequence immediately
     * @return a Flowable that emits the results of applying a function to a pair of values emitted by the
     *         source Publisher and the collection Publisher
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/flatmap.html&quot;&gt;ReactiveX operators documentation: FlatMap&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;U, R&gt; Flowable&lt;R&gt; flatMap(Function&lt;? super T, ? extends Publisher&lt;? extends U&gt;&gt; mapper,
            BiFunction&lt;? super T, ? super U, ? extends R&gt; combiner, boolean delayErrors) {
<span class="fc" id="L9942">        return flatMap(mapper, combiner, delayErrors, bufferSize(), bufferSize());</span>
    }

    /**
     * Returns a Flowable that emits the results of a specified function to the pair of values emitted by the
     * source Publisher and a specified collection Publisher, while limiting the maximum number of concurrent
     * subscriptions to these Publishers.
     * &lt;!-- &lt;p&gt; --&gt;
     * &lt;!-- &lt;img width=&quot;640&quot; height=&quot;390&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/mergeMap.r.png&quot; alt=&quot;&quot;&gt; --&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream. The upstream Flowable is consumed
     *  in a bounded manner (up to {@code maxConcurrency} outstanding request amount for items).
     *  The inner {@code Publisher}s are expected to honor backpressure; if violated,
     *  the operator &lt;em&gt;may&lt;/em&gt; signal {@code MissingBackpressureException}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code flatMap} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;U&gt;
     *            the type of items emitted by the inner Publishers
     * @param &lt;R&gt;
     *            the type of items emitted by the combiner function
     * @param mapper
     *            a function that returns a Publisher for each item emitted by the source Publisher
     * @param combiner
     *            a function that combines one item emitted by each of the source and collection Publishers and
     *            returns an item to be emitted by the resulting Publisher
     * @param maxConcurrency
     *         the maximum number of Publishers that may be subscribed to concurrently
     * @param delayErrors
     *            if true, exceptions from the current Flowable and all inner Publishers are delayed until all of them terminate
     *            if false, the first one signaling an exception will terminate the whole sequence immediately
     * @return a Flowable that emits the results of applying a function to a pair of values emitted by the
     *         source Publisher and the collection Publisher
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/flatmap.html&quot;&gt;ReactiveX operators documentation: FlatMap&lt;/a&gt;
     * @since 2.0
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;U, R&gt; Flowable&lt;R&gt; flatMap(Function&lt;? super T, ? extends Publisher&lt;? extends U&gt;&gt; mapper,
            BiFunction&lt;? super T, ? super U, ? extends R&gt; combiner, boolean delayErrors, int maxConcurrency) {
<span class="fc" id="L9985">        return flatMap(mapper, combiner, delayErrors, maxConcurrency, bufferSize());</span>
    }

    /**
     * Returns a Flowable that emits the results of a specified function to the pair of values emitted by the
     * source Publisher and a specified collection Publisher, while limiting the maximum number of concurrent
     * subscriptions to these Publishers.
     * &lt;!-- &lt;p&gt; --&gt;
     * &lt;!-- &lt;img width=&quot;640&quot; height=&quot;390&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/mergeMap.r.png&quot; alt=&quot;&quot;&gt; --&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream. The upstream Flowable is consumed
     *  in a bounded manner (up to {@code maxConcurrency} outstanding request amount for items).
     *  The inner {@code Publisher}s are expected to honor backpressure; if violated,
     *  the operator &lt;em&gt;may&lt;/em&gt; signal {@code MissingBackpressureException}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code flatMap} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;U&gt;
     *            the type of items emitted by the inner Publishers
     * @param &lt;R&gt;
     *            the type of items emitted by the combiner function
     * @param mapper
     *            a function that returns a Publisher for each item emitted by the source Publisher
     * @param combiner
     *            a function that combines one item emitted by each of the source and collection Publishers and
     *            returns an item to be emitted by the resulting Publisher
     * @param maxConcurrency
     *         the maximum number of Publishers that may be subscribed to concurrently
     * @param delayErrors
     *            if true, exceptions from the current Flowable and all inner Publishers are delayed until all of them terminate
     *            if false, the first one signaling an exception will terminate the whole sequence immediately
     * @param bufferSize
     *            the number of elements to prefetch from the inner Publishers.
     * @return a Flowable that emits the results of applying a function to a pair of values emitted by the
     *         source Publisher and the collection Publisher
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/flatmap.html&quot;&gt;ReactiveX operators documentation: FlatMap&lt;/a&gt;
     * @since 2.0
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;U, R&gt; Flowable&lt;R&gt; flatMap(final Function&lt;? super T, ? extends Publisher&lt;? extends U&gt;&gt; mapper,
            final BiFunction&lt;? super T, ? super U, ? extends R&gt; combiner, boolean delayErrors, int maxConcurrency, int bufferSize) {
<span class="fc" id="L10031">        ObjectHelper.requireNonNull(mapper, &quot;mapper is null&quot;);</span>
<span class="fc" id="L10032">        ObjectHelper.requireNonNull(combiner, &quot;combiner is null&quot;);</span>
<span class="fc" id="L10033">        ObjectHelper.verifyPositive(maxConcurrency, &quot;maxConcurrency&quot;);</span>
<span class="fc" id="L10034">        ObjectHelper.verifyPositive(bufferSize, &quot;bufferSize&quot;);</span>
<span class="fc" id="L10035">        return flatMap(FlowableInternalHelper.flatMapWithCombiner(mapper, combiner), delayErrors, maxConcurrency, bufferSize);</span>
    }

    /**
     * Returns a Flowable that emits the results of a specified function to the pair of values emitted by the
     * source Publisher and a specified collection Publisher, while limiting the maximum number of concurrent
     * subscriptions to these Publishers.
     * &lt;!-- &lt;p&gt; --&gt;
     * &lt;!-- &lt;img width=&quot;640&quot; height=&quot;390&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/mergeMap.r.png&quot; alt=&quot;&quot;&gt; --&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream. The upstream Flowable is consumed
     *  in a bounded manner (up to {@link #bufferSize()} outstanding request amount for items).
     *  The inner {@code Publisher}s are expected to honor backpressure; if violated,
     *  the operator &lt;em&gt;may&lt;/em&gt; signal {@code MissingBackpressureException}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code flatMap} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;U&gt;
     *            the type of items emitted by the inner Publishers
     * @param &lt;R&gt;
     *            the type of items emitted by the combiner function
     * @param mapper
     *            a function that returns a Publisher for each item emitted by the source Publisher
     * @param combiner
     *            a function that combines one item emitted by each of the source and collection Publishers and
     *            returns an item to be emitted by the resulting Publisher
     * @param maxConcurrency
     *         the maximum number of Publishers that may be subscribed to concurrently
     * @return a Flowable that emits the results of applying a function to a pair of values emitted by the
     *         source Publisher and the collection Publisher
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/flatmap.html&quot;&gt;ReactiveX operators documentation: FlatMap&lt;/a&gt;
     * @since 2.0
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;U, R&gt; Flowable&lt;R&gt; flatMap(Function&lt;? super T, ? extends Publisher&lt;? extends U&gt;&gt; mapper,
            BiFunction&lt;? super T, ? super U, ? extends R&gt; combiner, int maxConcurrency) {
<span class="fc" id="L10075">        return flatMap(mapper, combiner, false, maxConcurrency, bufferSize());</span>
    }

    /**
     * Maps each element of the upstream Flowable into CompletableSources, subscribes to them and
     * waits until the upstream and all CompletableSources complete.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator consumes the upstream in an unbounded manner.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code flatMapCompletable} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param mapper the function that received each source value and transforms them into CompletableSources.
     * @return the new Completable instance
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Completable flatMapCompletable(Function&lt;? super T, ? extends CompletableSource&gt; mapper) {
<span class="fc" id="L10094">        return flatMapCompletable(mapper, false, Integer.MAX_VALUE);</span>
    }

    /**
     * Maps each element of the upstream Flowable into CompletableSources, subscribes to them and
     * waits until the upstream and all CompletableSources complete, optionally delaying all errors.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;If {@code maxConcurrency == Integer.MAX_VALUE} the operator consumes the upstream in an unbounded manner.
     *  Otherwise, the operator expects the upstream to honor backpressure. If the upstream doesn't support backpressure
     *  the operator behaves as if {@code maxConcurrency == Integer.MAX_VALUE} was used.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code flatMapCompletable} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param mapper the function that received each source value and transforms them into CompletableSources.
     * @param delayErrors if true errors from the upstream and inner CompletableSources are delayed until each of them
     * terminates.
     * @param maxConcurrency the maximum number of active subscriptions to the CompletableSources.
     * @return the new Completable instance
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Completable flatMapCompletable(Function&lt;? super T, ? extends CompletableSource&gt; mapper, boolean delayErrors, int maxConcurrency) {
<span class="fc" id="L10119">        ObjectHelper.requireNonNull(mapper, &quot;mapper is null&quot;);</span>
<span class="fc" id="L10120">        ObjectHelper.verifyPositive(maxConcurrency, &quot;maxConcurrency&quot;);</span>
<span class="fc" id="L10121">        return RxJavaPlugins.onAssembly(new FlowableFlatMapCompletableCompletable&lt;T&gt;(this, mapper, delayErrors, maxConcurrency));</span>
    }

    /**
     * Returns a Flowable that merges each item emitted by the source Publisher with the values in an
     * Iterable corresponding to that item that is generated by a selector.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flatMapIterable.f.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream. The source {@code Publisher}s is
     *  expected to honor backpressure as well. If the source {@code Publisher} violates the rule, the operator will
     *  signal a {@code MissingBackpressureException}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code flatMapIterable} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;U&gt;
     *            the type of item emitted by the resulting Iterable
     * @param mapper
     *            a function that returns an Iterable sequence of values for when given an item emitted by the
     *            source Publisher
     * @return a Flowable that emits the results of merging the items emitted by the source Publisher with
     *         the values in the Iterables corresponding to those items, as generated by {@code collectionSelector}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/flatmap.html&quot;&gt;ReactiveX operators documentation: FlatMap&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;U&gt; Flowable&lt;U&gt; flatMapIterable(final Function&lt;? super T, ? extends Iterable&lt;? extends U&gt;&gt; mapper) {
<span class="fc" id="L10151">        return flatMapIterable(mapper, bufferSize());</span>
    }

    /**
     * Returns a Flowable that merges each item emitted by the source Publisher with the values in an
     * Iterable corresponding to that item that is generated by a selector.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flatMapIterable.f.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream. The source {@code Publisher}s is
     *  expected to honor backpressure as well. If the source {@code Publisher} violates the rule, the operator will
     *  signal a {@code MissingBackpressureException}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code flatMapIterable} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;U&gt;
     *            the type of item emitted by the resulting Iterable
     * @param mapper
     *            a function that returns an Iterable sequence of values for when given an item emitted by the
     *            source Publisher
     * @param bufferSize
     *            the number of elements to prefetch from the current Flowable
     * @return a Flowable that emits the results of merging the items emitted by the source Publisher with
     *         the values in the Iterables corresponding to those items, as generated by {@code collectionSelector}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/flatmap.html&quot;&gt;ReactiveX operators documentation: FlatMap&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;U&gt; Flowable&lt;U&gt; flatMapIterable(final Function&lt;? super T, ? extends Iterable&lt;? extends U&gt;&gt; mapper, int bufferSize) {
<span class="fc" id="L10184">        ObjectHelper.requireNonNull(mapper, &quot;mapper is null&quot;);</span>
<span class="fc" id="L10185">        ObjectHelper.verifyPositive(bufferSize, &quot;bufferSize&quot;);</span>
<span class="fc" id="L10186">        return RxJavaPlugins.onAssembly(new FlowableFlattenIterable&lt;T, U&gt;(this, mapper, bufferSize));</span>
    }

    /**
     * Returns a Flowable that emits the results of applying a function to the pair of values from the source
     * Publisher and an Iterable corresponding to that item that is generated by a selector.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;410&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flatMapIterable.f.r.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream and the source {@code Publisher}s is
     *  consumed in an unbounded manner (i.e., no backpressure is applied to it).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code flatMapIterable} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;U&gt;
     *            the collection element type
     * @param &lt;V&gt;
     *            the type of item emitted by the resulting Iterable
     * @param mapper
     *            a function that returns an Iterable sequence of values for each item emitted by the source
     *            Publisher
     * @param resultSelector
     *            a function that returns an item based on the item emitted by the source Publisher and the
     *            Iterable returned for that item by the {@code collectionSelector}
     * @return a Flowable that emits the items returned by {@code resultSelector} for each item in the source
     *         Publisher
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/flatmap.html&quot;&gt;ReactiveX operators documentation: FlatMap&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;U, V&gt; Flowable&lt;V&gt; flatMapIterable(final Function&lt;? super T, ? extends Iterable&lt;? extends U&gt;&gt; mapper,
            final BiFunction&lt;? super T, ? super U, ? extends V&gt; resultSelector) {
<span class="fc" id="L10222">        ObjectHelper.requireNonNull(mapper, &quot;mapper is null&quot;);</span>
<span class="fc" id="L10223">        ObjectHelper.requireNonNull(resultSelector, &quot;resultSelector is null&quot;);</span>
<span class="fc" id="L10224">        return flatMap(FlowableInternalHelper.flatMapIntoIterable(mapper), resultSelector, false, bufferSize(), bufferSize());</span>
    }

    /**
     * Returns a Flowable that merges each item emitted by the source Publisher with the values in an
     * Iterable corresponding to that item that is generated by a selector, while limiting the number of concurrent
     * subscriptions to these Publishers.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;410&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flatMapIterable.f.r.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream. The source {@code Publisher}s is
     *  expected to honor backpressure as well. If the source {@code Publisher} violates the rule, the operator will
     *  signal a {@code MissingBackpressureException}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code flatMapIterable} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;U&gt;
     *            the element type of the inner Iterable sequences
     * @param &lt;V&gt;
     *            the type of item emitted by the resulting Publisher
     * @param mapper
     *            a function that returns an Iterable sequence of values for when given an item emitted by the
     *            source Publisher
     * @param resultSelector
     *            a function that returns an item based on the item emitted by the source Publisher and the
     *            Iterable returned for that item by the {@code collectionSelector}
     * @param prefetch
     *            the number of elements to prefetch from the current Flowable
     * @return a Flowable that emits the results of merging the items emitted by the source Publisher with
     *         the values in the Iterables corresponding to those items, as generated by {@code collectionSelector}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/flatmap.html&quot;&gt;ReactiveX operators documentation: FlatMap&lt;/a&gt;
     * @since 2.0
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;U, V&gt; Flowable&lt;V&gt; flatMapIterable(final Function&lt;? super T, ? extends Iterable&lt;? extends U&gt;&gt; mapper,
            final BiFunction&lt;? super T, ? super U, ? extends V&gt; resultSelector, int prefetch) {
<span class="fc" id="L10265">        ObjectHelper.requireNonNull(mapper, &quot;mapper is null&quot;);</span>
<span class="fc" id="L10266">        ObjectHelper.requireNonNull(resultSelector, &quot;resultSelector is null&quot;);</span>
<span class="fc" id="L10267">        return flatMap(FlowableInternalHelper.flatMapIntoIterable(mapper), resultSelector, false, bufferSize(), prefetch);</span>
    }

    /**
     * Maps each element of the upstream Flowable into MaybeSources, subscribes to all of them
     * and merges their onSuccess values, in no particular order, into a single Flowable sequence.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator consumes the upstream in an unbounded manner.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code flatMapMaybe} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;R&gt; the result value type
     * @param mapper the function that received each source value and transforms them into MaybeSources.
     * @return the new Flowable instance
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;R&gt; Flowable&lt;R&gt; flatMapMaybe(Function&lt;? super T, ? extends MaybeSource&lt;? extends R&gt;&gt; mapper) {
<span class="fc" id="L10287">        return flatMapMaybe(mapper, false, Integer.MAX_VALUE);</span>
    }

    /**
     * Maps each element of the upstream Flowable into MaybeSources, subscribes to at most
     * {@code maxConcurrency} MaybeSources at a time and merges their onSuccess values,
     * in no particular order, into a single Flowable sequence, optionally delaying all errors.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;If {@code maxConcurrency == Integer.MAX_VALUE} the operator consumes the upstream in an unbounded manner.
     *  Otherwise, the operator expects the upstream to honor backpressure. If the upstream doesn't support backpressure
     *  the operator behaves as if {@code maxConcurrency == Integer.MAX_VALUE} was used.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code flatMapMaybe} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;R&gt; the result value type
     * @param mapper the function that received each source value and transforms them into MaybeSources.
     * @param delayErrors if true errors from the upstream and inner MaybeSources are delayed until each of them
     * terminates.
     * @param maxConcurrency the maximum number of active subscriptions to the MaybeSources.
     * @return the new Flowable instance
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;R&gt; Flowable&lt;R&gt; flatMapMaybe(Function&lt;? super T, ? extends MaybeSource&lt;? extends R&gt;&gt; mapper, boolean delayErrors, int maxConcurrency) {
<span class="fc" id="L10314">        ObjectHelper.requireNonNull(mapper, &quot;mapper is null&quot;);</span>
<span class="fc" id="L10315">        ObjectHelper.verifyPositive(maxConcurrency, &quot;maxConcurrency&quot;);</span>
<span class="fc" id="L10316">        return RxJavaPlugins.onAssembly(new FlowableFlatMapMaybe&lt;T, R&gt;(this, mapper, delayErrors, maxConcurrency));</span>
    }

    /**
     * Maps each element of the upstream Flowable into SingleSources, subscribes to all of them
     * and merges their onSuccess values, in no particular order, into a single Flowable sequence.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator consumes the upstream in an unbounded manner.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code flatMapSingle} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;R&gt; the result value type
     * @param mapper the function that received each source value and transforms them into SingleSources.
     * @return the new Flowable instance
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;R&gt; Flowable&lt;R&gt; flatMapSingle(Function&lt;? super T, ? extends SingleSource&lt;? extends R&gt;&gt; mapper) {
<span class="fc" id="L10336">        return flatMapSingle(mapper, false, Integer.MAX_VALUE);</span>
    }

    /**
     * Maps each element of the upstream Flowable into SingleSources, subscribes to at most
     * {@code maxConcurrency} SingleSources at a time and merges their onSuccess values,
     * in no particular order, into a single Flowable sequence, optionally delaying all errors.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;If {@code maxConcurrency == Integer.MAX_VALUE} the operator consumes the upstream in an unbounded manner.
     *  Otherwise, the operator expects the upstream to honor backpressure. If the upstream doesn't support backpressure
     *  the operator behaves as if {@code maxConcurrency == Integer.MAX_VALUE} was used.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code flatMapSingle} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;R&gt; the result value type
     * @param mapper the function that received each source value and transforms them into SingleSources.
     * @param delayErrors if true errors from the upstream and inner SingleSources are delayed until each of them
     * terminates.
     * @param maxConcurrency the maximum number of active subscriptions to the SingleSources.
     * @return the new Flowable instance
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;R&gt; Flowable&lt;R&gt; flatMapSingle(Function&lt;? super T, ? extends SingleSource&lt;? extends R&gt;&gt; mapper, boolean delayErrors, int maxConcurrency) {
<span class="fc" id="L10363">        ObjectHelper.requireNonNull(mapper, &quot;mapper is null&quot;);</span>
<span class="fc" id="L10364">        ObjectHelper.verifyPositive(maxConcurrency, &quot;maxConcurrency&quot;);</span>
<span class="fc" id="L10365">        return RxJavaPlugins.onAssembly(new FlowableFlatMapSingle&lt;T, R&gt;(this, mapper, delayErrors, maxConcurrency));</span>
    }

    /**
     * Subscribes to the {@link Publisher} and receives notifications for each element.
     * &lt;p&gt;
     * Alias to {@link #subscribe(Consumer)}
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator consumes the source {@code Publisher} in an unbounded manner (i.e., no
     *  backpressure is applied to it).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code forEach} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param onNext
     *            {@link Consumer} to execute for each item.
     * @return
     *            a Disposable that allows canceling an asynchronous sequence
     * @throws NullPointerException
     *             if {@code onNext} is null
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/subscribe.html&quot;&gt;ReactiveX operators documentation: Subscribe&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.NONE)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Disposable forEach(Consumer&lt;? super T&gt; onNext) {
<span class="fc" id="L10392">        return subscribe(onNext);</span>
    }

    /**
     * Subscribes to the {@link Publisher} and receives notifications for each element until the
     * onNext Predicate returns false.
     * &lt;p&gt;
     * If the Flowable emits an error, it is wrapped into an
     * {@link io.reactivex.exceptions.OnErrorNotImplementedException OnErrorNotImplementedException}
     * and routed to the RxJavaPlugins.onError handler.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator consumes the source {@code Publisher} in an unbounded manner (i.e., no
     *  backpressure is applied to it).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code forEachWhile} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param onNext
     *            {@link Predicate} to execute for each item.
     * @return
     *            a {@link Disposable} that allows canceling an asynchronous sequence
     * @throws NullPointerException
     *             if {@code onNext} is null
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/subscribe.html&quot;&gt;ReactiveX operators documentation: Subscribe&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.NONE)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Disposable forEachWhile(Predicate&lt;? super T&gt; onNext) {
<span class="fc" id="L10422">        return forEachWhile(onNext, Functions.ON_ERROR_MISSING, Functions.EMPTY_ACTION);</span>
    }

    /**
     * Subscribes to the {@link Publisher} and receives notifications for each element and error events until the
     * onNext Predicate returns false.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator consumes the source {@code Publisher} in an unbounded manner (i.e., no
     *  backpressure is applied to it).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code forEachWhile} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param onNext
     *            {@link Predicate} to execute for each item.
     * @param onError
     *            {@link Consumer} to execute when an error is emitted.
     * @return
     *            a {@link Disposable} that allows canceling an asynchronous sequence
     * @throws NullPointerException
     *             if {@code onNext} is null, or
     *             if {@code onError} is null
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/subscribe.html&quot;&gt;ReactiveX operators documentation: Subscribe&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.NONE)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Disposable forEachWhile(Predicate&lt;? super T&gt; onNext, Consumer&lt;? super Throwable&gt; onError) {
<span class="fc" id="L10451">        return forEachWhile(onNext, onError, Functions.EMPTY_ACTION);</span>
    }

    /**
     * Subscribes to the {@link Publisher} and receives notifications for each element and the terminal events until the
     * onNext Predicate returns false.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator consumes the source {@code Publisher} in an unbounded manner (i.e., no
     *  backpressure is applied to it).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code forEachWhile} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param onNext
     *            {@link Predicate} to execute for each item.
     * @param onError
     *            {@link Consumer} to execute when an error is emitted.
     * @param onComplete
     *            {@link Action} to execute when completion is signaled.
     * @return
     *            a {@link Disposable} that allows canceling an asynchronous sequence
     * @throws NullPointerException
     *             if {@code onNext} is null, or
     *             if {@code onError} is null, or
     *             if {@code onComplete} is null
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/subscribe.html&quot;&gt;ReactiveX operators documentation: Subscribe&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.NONE)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Disposable forEachWhile(final Predicate&lt;? super T&gt; onNext, final Consumer&lt;? super Throwable&gt; onError,
            final Action onComplete) {
<span class="fc" id="L10485">        ObjectHelper.requireNonNull(onNext, &quot;onNext is null&quot;);</span>
<span class="fc" id="L10486">        ObjectHelper.requireNonNull(onError, &quot;onError is null&quot;);</span>
<span class="fc" id="L10487">        ObjectHelper.requireNonNull(onComplete, &quot;onComplete is null&quot;);</span>

<span class="fc" id="L10489">        ForEachWhileSubscriber&lt;T&gt; s = new ForEachWhileSubscriber&lt;T&gt;(onNext, onError, onComplete);</span>
<span class="fc" id="L10490">        subscribe(s);</span>
<span class="fc" id="L10491">        return s;</span>
    }

    /**
     * Groups the items emitted by a {@code Publisher} according to a specified criterion, and emits these
     * grouped items as {@link GroupedFlowable}s. The emitted {@code GroupedPublisher} allows only a single
     * {@link Subscriber} during its lifetime and if this {@code Subscriber} cancels before the
     * source terminates, the next emission by the source having the same key will trigger a new
     * {@code GroupedPublisher} emission.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;360&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/groupBy.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * &lt;em&gt;Note:&lt;/em&gt; A {@link GroupedFlowable} will cache the items it is to emit until such time as it
     * is subscribed to. For this reason, in order to avoid memory leaks, you should not simply ignore those
     * {@code GroupedPublisher}s that do not concern you. Instead, you can signal to them that they may
     * discard their buffers by applying an operator like {@link #ignoreElements} to them.
     * &lt;p&gt;
     * Note that the {@link GroupedFlowable}s should be subscribed to as soon as possible, otherwise,
     * the unconsumed groups may starve other groups due to the internal backpressure
     * coordination of the {@code groupBy} operator. Such hangs can be usually avoided by using
     * {@link #flatMap(Function, int)} or {@link #concatMapEager(Function, int, int)} and overriding the default maximum concurrency
     * value to be greater or equal to the expected number of groups, possibly using
     * {@code Integer.MAX_VALUE} if the number of expected groups is unknown.
     *
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;Both the returned and its inner {@code Publisher}s honor backpressure and the source {@code Publisher}
     *  is consumed in a bounded mode (i.e., requested a fixed amount upfront and replenished based on
     *  downstream consumption). Note that both the returned and its inner {@code Publisher}s use
     *  unbounded internal buffers and if the source {@code Publisher} doesn't honor backpressure, that &lt;em&gt;may&lt;/em&gt;
     *  lead to {@code OutOfMemoryError}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code groupBy} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param keySelector
     *            a function that extracts the key for each item
     * @param &lt;K&gt;
     *            the key type
     * @return a {@code Publisher} that emits {@link GroupedFlowable}s, each of which corresponds to a
     *         unique key value and each of which emits those items from the source Publisher that share that
     *         key value
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/groupby.html&quot;&gt;ReactiveX operators documentation: GroupBy&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;K&gt; Flowable&lt;GroupedFlowable&lt;K, T&gt;&gt; groupBy(Function&lt;? super T, ? extends K&gt; keySelector) {
<span class="fc" id="L10539">        return groupBy(keySelector, Functions.&lt;T&gt;identity(), false, bufferSize());</span>
    }

    /**
     * Groups the items emitted by a {@code Publisher} according to a specified criterion, and emits these
     * grouped items as {@link GroupedFlowable}s. The emitted {@code GroupedPublisher} allows only a single
     * {@link Subscriber} during its lifetime and if this {@code Subscriber} cancels before the
     * source terminates, the next emission by the source having the same key will trigger a new
     * {@code GroupedPublisher} emission.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;360&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/groupBy.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * &lt;em&gt;Note:&lt;/em&gt; A {@link GroupedFlowable} will cache the items it is to emit until such time as it
     * is subscribed to. For this reason, in order to avoid memory leaks, you should not simply ignore those
     * {@code GroupedPublisher}s that do not concern you. Instead, you can signal to them that they may
     * discard their buffers by applying an operator like {@link #ignoreElements} to them.
     * &lt;p&gt;
     * Note that the {@link GroupedFlowable}s should be subscribed to as soon as possible, otherwise,
     * the unconsumed groups may starve other groups due to the internal backpressure
     * coordination of the {@code groupBy} operator. Such hangs can be usually avoided by using
     * {@link #flatMap(Function, int)} or {@link #concatMapEager(Function, int, int)} and overriding the default maximum concurrency
     * value to be greater or equal to the expected number of groups, possibly using
     * {@code Integer.MAX_VALUE} if the number of expected groups is unknown.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;Both the returned and its inner {@code Publisher}s honor backpressure and the source {@code Publisher}
     *  is consumed in a bounded mode (i.e., requested a fixed amount upfront and replenished based on
     *  downstream consumption). Note that both the returned and its inner {@code Publisher}s use
     *  unbounded internal buffers and if the source {@code Publisher} doesn't honor backpressure, that &lt;em&gt;may&lt;/em&gt;
     *  lead to {@code OutOfMemoryError}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code groupBy} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param keySelector
     *            a function that extracts the key for each item
     * @param &lt;K&gt;
     *            the key type
     * @param delayError
     *            if true, the exception from the current Flowable is delayed in each group until that specific group emitted
     *            the normal values; if false, the exception bypasses values in the groups and is reported immediately.
     * @return a {@code Publisher} that emits {@link GroupedFlowable}s, each of which corresponds to a
     *         unique key value and each of which emits those items from the source Publisher that share that
     *         key value
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/groupby.html&quot;&gt;ReactiveX operators documentation: GroupBy&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;K&gt; Flowable&lt;GroupedFlowable&lt;K, T&gt;&gt; groupBy(Function&lt;? super T, ? extends K&gt; keySelector, boolean delayError) {
<span class="fc" id="L10589">        return groupBy(keySelector, Functions.&lt;T&gt;identity(), delayError, bufferSize());</span>
    }

    /**
     * Groups the items emitted by a {@code Publisher} according to a specified criterion, and emits these
     * grouped items as {@link GroupedFlowable}s. The emitted {@code GroupedPublisher} allows only a single
     * {@link Subscriber} during its lifetime and if this {@code Subscriber} cancels before the
     * source terminates, the next emission by the source having the same key will trigger a new
     * {@code GroupedPublisher} emission.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;360&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/groupBy.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * &lt;em&gt;Note:&lt;/em&gt; A {@link GroupedFlowable} will cache the items it is to emit until such time as it
     * is subscribed to. For this reason, in order to avoid memory leaks, you should not simply ignore those
     * {@code GroupedPublisher}s that do not concern you. Instead, you can signal to them that they may
     * discard their buffers by applying an operator like {@link #ignoreElements} to them.
     * &lt;p&gt;
     * Note that the {@link GroupedFlowable}s should be subscribed to as soon as possible, otherwise,
     * the unconsumed groups may starve other groups due to the internal backpressure
     * coordination of the {@code groupBy} operator. Such hangs can be usually avoided by using
     * {@link #flatMap(Function, int)} or {@link #concatMapEager(Function, int, int)} and overriding the default maximum concurrency
     * value to be greater or equal to the expected number of groups, possibly using
     * {@code Integer.MAX_VALUE} if the number of expected groups is unknown.
     *
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;Both the returned and its inner {@code Publisher}s honor backpressure and the source {@code Publisher}
     *  is consumed in a bounded mode (i.e., requested a fixed amount upfront and replenished based on
     *  downstream consumption). Note that both the returned and its inner {@code Publisher}s use
     *  unbounded internal buffers and if the source {@code Publisher} doesn't honor backpressure, that &lt;em&gt;may&lt;/em&gt;
     *  lead to {@code OutOfMemoryError}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code groupBy} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param keySelector
     *            a function that extracts the key for each item
     * @param valueSelector
     *            a function that extracts the return element for each item
     * @param &lt;K&gt;
     *            the key type
     * @param &lt;V&gt;
     *            the element type
     * @return a {@code Publisher} that emits {@link GroupedFlowable}s, each of which corresponds to a
     *         unique key value and each of which emits those items from the source Publisher that share that
     *         key value
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/groupby.html&quot;&gt;ReactiveX operators documentation: GroupBy&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;K, V&gt; Flowable&lt;GroupedFlowable&lt;K, V&gt;&gt; groupBy(Function&lt;? super T, ? extends K&gt; keySelector,
            Function&lt;? super T, ? extends V&gt; valueSelector) {
<span class="fc" id="L10642">        return groupBy(keySelector, valueSelector, false, bufferSize());</span>
    }

    /**
     * Groups the items emitted by a {@code Publisher} according to a specified criterion, and emits these
     * grouped items as {@link GroupedFlowable}s. The emitted {@code GroupedPublisher} allows only a single
     * {@link Subscriber} during its lifetime and if this {@code Subscriber} cancels before the
     * source terminates, the next emission by the source having the same key will trigger a new
     * {@code GroupedPublisher} emission.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;360&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/groupBy.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * &lt;em&gt;Note:&lt;/em&gt; A {@link GroupedFlowable} will cache the items it is to emit until such time as it
     * is subscribed to. For this reason, in order to avoid memory leaks, you should not simply ignore those
     * {@code GroupedPublisher}s that do not concern you. Instead, you can signal to them that they may
     * discard their buffers by applying an operator like {@link #ignoreElements} to them.
     * &lt;p&gt;
     * Note that the {@link GroupedFlowable}s should be subscribed to as soon as possible, otherwise,
     * the unconsumed groups may starve other groups due to the internal backpressure
     * coordination of the {@code groupBy} operator. Such hangs can be usually avoided by using
     * {@link #flatMap(Function, int)} or {@link #concatMapEager(Function, int, int)} and overriding the default maximum concurrency
     * value to be greater or equal to the expected number of groups, possibly using
     * {@code Integer.MAX_VALUE} if the number of expected groups is unknown.
     *
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;Both the returned and its inner {@code Publisher}s honor backpressure and the source {@code Publisher}
     *  is consumed in a bounded mode (i.e., requested a fixed amount upfront and replenished based on
     *  downstream consumption). Note that both the returned and its inner {@code Publisher}s use
     *  unbounded internal buffers and if the source {@code Publisher} doesn't honor backpressure, that &lt;em&gt;may&lt;/em&gt;
     *  lead to {@code OutOfMemoryError}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code groupBy} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param keySelector
     *            a function that extracts the key for each item
     * @param valueSelector
     *            a function that extracts the return element for each item
     * @param &lt;K&gt;
     *            the key type
     * @param &lt;V&gt;
     *            the element type
     * @param delayError
     *            if true, the exception from the current Flowable is delayed in each group until that specific group emitted
     *            the normal values; if false, the exception bypasses values in the groups and is reported immediately.
     * @return a {@code Publisher} that emits {@link GroupedFlowable}s, each of which corresponds to a
     *         unique key value and each of which emits those items from the source Publisher that share that
     *         key value
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/groupby.html&quot;&gt;ReactiveX operators documentation: GroupBy&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;K, V&gt; Flowable&lt;GroupedFlowable&lt;K, V&gt;&gt; groupBy(Function&lt;? super T, ? extends K&gt; keySelector,
            Function&lt;? super T, ? extends V&gt; valueSelector, boolean delayError) {
<span class="fc" id="L10698">        return groupBy(keySelector, valueSelector, delayError, bufferSize());</span>
    }

    /**
     * Groups the items emitted by a {@code Publisher} according to a specified criterion, and emits these
     * grouped items as {@link GroupedFlowable}s. The emitted {@code GroupedPublisher} allows only a single
     * {@link Subscriber} during its lifetime and if this {@code Subscriber} cancels before the
     * source terminates, the next emission by the source having the same key will trigger a new
     * {@code GroupedPublisher} emission.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;360&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/groupBy.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * &lt;em&gt;Note:&lt;/em&gt; A {@link GroupedFlowable} will cache the items it is to emit until such time as it
     * is subscribed to. For this reason, in order to avoid memory leaks, you should not simply ignore those
     * {@code GroupedPublisher}s that do not concern you. Instead, you can signal to them that they may
     * discard their buffers by applying an operator like {@link #ignoreElements} to them.
     * &lt;p&gt;
     * Note that the {@link GroupedFlowable}s should be subscribed to as soon as possible, otherwise,
     * the unconsumed groups may starve other groups due to the internal backpressure
     * coordination of the {@code groupBy} operator. Such hangs can be usually avoided by using
     * {@link #flatMap(Function, int)} or {@link #concatMapEager(Function, int, int)} and overriding the default maximum concurrency
     * value to be greater or equal to the expected number of groups, possibly using
     * {@code Integer.MAX_VALUE} if the number of expected groups is unknown.
     *
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;Both the returned and its inner {@code Publisher}s honor backpressure and the source {@code Publisher}
     *  is consumed in a bounded mode (i.e., requested a fixed amount upfront and replenished based on
     *  downstream consumption). Note that both the returned and its inner {@code Publisher}s use
     *  unbounded internal buffers and if the source {@code Publisher} doesn't honor backpressure, that &lt;em&gt;may&lt;/em&gt;
     *  lead to {@code OutOfMemoryError}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code groupBy} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param keySelector
     *            a function that extracts the key for each item
     * @param valueSelector
     *            a function that extracts the return element for each item
     * @param delayError
     *            if true, the exception from the current Flowable is delayed in each group until that specific group emitted
     *            the normal values; if false, the exception bypasses values in the groups and is reported immediately.
     * @param bufferSize
     *            the hint for how many {@link GroupedFlowable}s and element in each {@link GroupedFlowable} should be buffered
     * @param &lt;K&gt;
     *            the key type
     * @param &lt;V&gt;
     *            the element type
     * @return a {@code Publisher} that emits {@link GroupedFlowable}s, each of which corresponds to a
     *         unique key value and each of which emits those items from the source Publisher that share that
     *         key value
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/groupby.html&quot;&gt;ReactiveX operators documentation: GroupBy&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;K, V&gt; Flowable&lt;GroupedFlowable&lt;K, V&gt;&gt; groupBy(Function&lt;? super T, ? extends K&gt; keySelector,
            Function&lt;? super T, ? extends V&gt; valueSelector,
            boolean delayError, int bufferSize) {
<span class="fc" id="L10758">        ObjectHelper.requireNonNull(keySelector, &quot;keySelector is null&quot;);</span>
<span class="fc" id="L10759">        ObjectHelper.requireNonNull(valueSelector, &quot;valueSelector is null&quot;);</span>
<span class="fc" id="L10760">        ObjectHelper.verifyPositive(bufferSize, &quot;bufferSize&quot;);</span>

<span class="fc" id="L10762">        return RxJavaPlugins.onAssembly(new FlowableGroupBy&lt;T, K, V&gt;(this, keySelector, valueSelector, bufferSize, delayError, null));</span>
    }

    /**
     * Groups the items emitted by a {@code Publisher} according to a specified criterion, and emits these
     * grouped items as {@link GroupedFlowable}s. The emitted {@code GroupedFlowable} allows only a single
     * {@link Subscriber} during its lifetime and if this {@code Subscriber} cancels before the
     * source terminates, the next emission by the source having the same key will trigger a new
     * {@code GroupedPublisher} emission. The {@code evictingMapFactory} is used to create a map that will
     * be used to hold the {@link GroupedFlowable}s by key. The evicting map created by this factory must
     * notify the provided {@code Consumer&lt;Object&gt;} with the entry value (not the key!) when an entry in this
     * map has been evicted. The next source emission will bring about the completion of the evicted
     * {@link GroupedFlowable}s and the arrival of an item with the same key as a completed {@link GroupedFlowable}
     * will prompt the creation and emission of a new {@link GroupedFlowable} with that key.
     * 
     * &lt;p&gt;A use case for specifying an {@code evictingMapFactory} is where the source is infinite and fast and
     * over time the number of keys grows enough to be a concern in terms of the memory footprint of the
     * internal hash map containing the {@link GroupedFlowable}s.
     * 
     * &lt;p&gt;The map created by an {@code evictingMapFactory} must be thread-safe.
     * 
     * &lt;p&gt;An example of an {@code evictingMapFactory} using &lt;a href=&quot;https://google.github.io/guava/releases/24.0-jre/api/docs/com/google/common/cache/CacheBuilder.html&quot;&gt;CacheBuilder&lt;/a&gt; from the Guava library is below:
     * 
     * &lt;pre&gt;&lt;code&gt;
     * Function&amp;lt;Consumer&amp;lt;Object&amp;gt;, Map&amp;lt;Integer, Object&amp;gt;&amp;gt; evictingMapFactory =
     *   notify -&amp;gt;
     *       CacheBuilder
     *         .newBuilder()
     *         .maximumSize(3)
     *         .removalListener(entry -&amp;gt; {
     *              try {
     *                  // emit the value not the key!
     *                  notify.accept(entry.getValue());
     *              } catch (Exception e) {
     *                  throw new RuntimeException(e);
     *              }
     *            })
     *         .&amp;lt;Integer, Object&amp;gt; build()
     *         .asMap();
     *
     * // Emit 1000 items but ensure that the
     * // internal map never has more than 3 items in it
     * Flowable
     *   .range(1, 1000)
     *   // note that number of keys is 10
     *   .groupBy(x -&amp;gt; x % 10, x -&amp;gt; x, true, 16, evictingMapFactory)
     *   .flatMap(g -&amp;gt; g)
     *   .forEach(System.out::println);
     * &lt;/code&gt;&lt;/pre&gt;
     * 
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;360&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/groupBy.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * &lt;em&gt;Note:&lt;/em&gt; A {@link GroupedFlowable} will cache the items it is to emit until such time as it
     * is subscribed to. For this reason, in order to avoid memory leaks, you should not simply ignore those
     * {@code GroupedFlowable}s that do not concern you. Instead, you can signal to them that they may
     * discard their buffers by applying an operator like {@link #ignoreElements} to them.
     * &lt;p&gt;
     * Note that the {@link GroupedFlowable}s should be subscribed to as soon as possible, otherwise,
     * the unconsumed groups may starve other groups due to the internal backpressure
     * coordination of the {@code groupBy} operator. Such hangs can be usually avoided by using
     * {@link #flatMap(Function, int)} or {@link #concatMapEager(Function, int, int)} and overriding the default maximum concurrency
     * value to be greater or equal to the expected number of groups, possibly using
     * {@code Integer.MAX_VALUE} if the number of expected groups is unknown.
     *
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;Both the returned and its inner {@code GroupedFlowable}s honor backpressure and the source {@code Publisher}
     *  is consumed in a bounded mode (i.e., requested a fixed amount upfront and replenished based on
     *  downstream consumption). Note that both the returned and its inner {@code GroupedFlowable}s use
     *  unbounded internal buffers and if the source {@code Publisher} doesn't honor backpressure, that &lt;em&gt;may&lt;/em&gt;
     *  lead to {@code OutOfMemoryError}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code groupBy} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * &lt;p&gt;History: 2.1.10 - beta
     * @param keySelector
     *            a function that extracts the key for each item
     * @param valueSelector
     *            a function that extracts the return element for each item
     * @param delayError
     *            if true, the exception from the current Flowable is delayed in each group until that specific group emitted
     *            the normal values; if false, the exception bypasses values in the groups and is reported immediately.
     * @param bufferSize
     *            the hint for how many {@link GroupedFlowable}s and element in each {@link GroupedFlowable} should be buffered
     * @param evictingMapFactory
     *            The factory used to create a map that will be used by the implementation to hold the
     *            {@link GroupedFlowable}s. The evicting map created by this factory must
     *            notify the provided {@code Consumer&lt;Object&gt;} with the entry value (not the key!) when
     *            an entry in this map has been evicted. The next source emission will bring about the
     *            completion of the evicted {@link GroupedFlowable}s. See example above.
     * @param &lt;K&gt;
     *            the key type
     * @param &lt;V&gt;
     *            the element type
     * @return a {@code Publisher} that emits {@link GroupedFlowable}s, each of which corresponds to a
     *         unique key value and each of which emits those items from the source Publisher that share that
     *         key value
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/groupby.html&quot;&gt;ReactiveX operators documentation: GroupBy&lt;/a&gt;
     *
     * @since 2.2
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;K, V&gt; Flowable&lt;GroupedFlowable&lt;K, V&gt;&gt; groupBy(Function&lt;? super T, ? extends K&gt; keySelector,
            Function&lt;? super T, ? extends V&gt; valueSelector,
            boolean delayError, int bufferSize,
            Function&lt;? super Consumer&lt;Object&gt;, ? extends Map&lt;K, Object&gt;&gt; evictingMapFactory) {
<span class="fc" id="L10872">        ObjectHelper.requireNonNull(keySelector, &quot;keySelector is null&quot;);</span>
<span class="fc" id="L10873">        ObjectHelper.requireNonNull(valueSelector, &quot;valueSelector is null&quot;);</span>
<span class="fc" id="L10874">        ObjectHelper.verifyPositive(bufferSize, &quot;bufferSize&quot;);</span>
<span class="fc" id="L10875">        ObjectHelper.requireNonNull(evictingMapFactory, &quot;evictingMapFactory is null&quot;);</span>

<span class="fc" id="L10877">        return RxJavaPlugins.onAssembly(new FlowableGroupBy&lt;T, K, V&gt;(this, keySelector, valueSelector, bufferSize, delayError, evictingMapFactory));</span>
    }

    /**
     * Returns a Flowable that correlates two Publishers when they overlap in time and groups the results.
     * &lt;p&gt;
     * There are no guarantees in what order the items get combined when multiple
     * items from one or both source Publishers overlap.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/groupJoin.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator doesn't support backpressure and consumes all participating {@code Publisher}s in
     *  an unbounded mode (i.e., not applying any backpressure to them).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code groupJoin} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;TRight&gt; the value type of the right Publisher source
     * @param &lt;TLeftEnd&gt; the element type of the left duration Publishers
     * @param &lt;TRightEnd&gt; the element type of the right duration Publishers
     * @param &lt;R&gt; the result type
     * @param other
     *            the other Publisher to correlate items from the source Publisher with
     * @param leftEnd
     *            a function that returns a Publisher whose emissions indicate the duration of the values of
     *            the source Publisher
     * @param rightEnd
     *            a function that returns a Publisher whose emissions indicate the duration of the values of
     *            the {@code right} Publisher
     * @param resultSelector
     *            a function that takes an item emitted by each Publisher and returns the value to be emitted
     *            by the resulting Publisher
     * @return a Flowable that emits items based on combining those items emitted by the source Publishers
     *         whose durations overlap
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/join.html&quot;&gt;ReactiveX operators documentation: Join&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;TRight, TLeftEnd, TRightEnd, R&gt; Flowable&lt;R&gt; groupJoin(
            Publisher&lt;? extends TRight&gt; other,
            Function&lt;? super T, ? extends Publisher&lt;TLeftEnd&gt;&gt; leftEnd,
            Function&lt;? super TRight, ? extends Publisher&lt;TRightEnd&gt;&gt; rightEnd,
            BiFunction&lt;? super T, ? super Flowable&lt;TRight&gt;, ? extends R&gt; resultSelector) {
<span class="fc" id="L10923">        ObjectHelper.requireNonNull(other, &quot;other is null&quot;);</span>
<span class="fc" id="L10924">        ObjectHelper.requireNonNull(leftEnd, &quot;leftEnd is null&quot;);</span>
<span class="fc" id="L10925">        ObjectHelper.requireNonNull(rightEnd, &quot;rightEnd is null&quot;);</span>
<span class="fc" id="L10926">        ObjectHelper.requireNonNull(resultSelector, &quot;resultSelector is null&quot;);</span>
<span class="fc" id="L10927">        return RxJavaPlugins.onAssembly(new FlowableGroupJoin&lt;T, TRight, TLeftEnd, TRightEnd, R&gt;(</span>
                this, other, leftEnd, rightEnd, resultSelector));
    }

    /**
     * Hides the identity of this Flowable and its Subscription.
     * &lt;p&gt;Allows hiding extra features such as {@link Processor}'s
     * {@link Subscriber} methods or preventing certain identity-based
     * optimizations (fusion).
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator is a pass-through for backpressure, the behavior is determined by the upstream's
     *  backpressure behavior.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code hide} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @return the new Flowable instance
     *
     * @since 2.0
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;T&gt; hide() {
<span class="fc" id="L10951">        return RxJavaPlugins.onAssembly(new FlowableHide&lt;T&gt;(this));</span>
    }

    /**
     * Ignores all items emitted by the source Publisher and only calls {@code onComplete} or {@code onError}.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/ignoreElements.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator ignores backpressure as it doesn't emit any elements and consumes the source {@code Publisher}
     *  in an unbounded manner (i.e., no backpressure is applied to it).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code ignoreElements} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @return a Completable that only calls {@code onComplete} or {@code onError}, based on which one is
     *         called by the source Publisher
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/ignoreelements.html&quot;&gt;ReactiveX operators documentation: IgnoreElements&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Completable ignoreElements() {
<span class="fc" id="L10974">        return RxJavaPlugins.onAssembly(new FlowableIgnoreElementsCompletable&lt;T&gt;(this));</span>
    }

    /**
     * Returns a Single that emits {@code true} if the source Publisher is empty, otherwise {@code false}.
     * &lt;p&gt;
     * In Rx.Net this is negated as the {@code any} Subscriber but we renamed this in RxJava to better match Java
     * naming idioms.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;320&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/isEmpty.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream and consumes the source {@code Publisher} in an
     *  unbounded manner (i.e., without applying backpressure).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code isEmpty} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @return a Flowable that emits a Boolean
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/contains.html&quot;&gt;ReactiveX operators documentation: Contains&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Single&lt;Boolean&gt; isEmpty() {
<span class="fc" id="L10999">        return all(Functions.alwaysFalse());</span>
    }

    /**
     * Correlates the items emitted by two Publishers based on overlapping durations.
     * &lt;p&gt;
     * There are no guarantees in what order the items get combined when multiple
     * items from one or both source Publishers overlap.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/join_.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator doesn't support backpressure and consumes all participating {@code Publisher}s in
     *  an unbounded mode (i.e., not applying any backpressure to them).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code join} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;TRight&gt; the value type of the right Publisher source
     * @param &lt;TLeftEnd&gt; the element type of the left duration Publishers
     * @param &lt;TRightEnd&gt; the element type of the right duration Publishers
     * @param &lt;R&gt; the result type
     * @param other
     *            the second Publisher to join items from
     * @param leftEnd
     *            a function to select a duration for each item emitted by the source Publisher, used to
     *            determine overlap
     * @param rightEnd
     *            a function to select a duration for each item emitted by the {@code right} Publisher, used to
     *            determine overlap
     * @param resultSelector
     *            a function that computes an item to be emitted by the resulting Publisher for any two
     *            overlapping items emitted by the two Publishers
     * @return a Flowable that emits items correlating to items emitted by the source Publishers that have
     *         overlapping durations
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/join.html&quot;&gt;ReactiveX operators documentation: Join&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;TRight, TLeftEnd, TRightEnd, R&gt; Flowable&lt;R&gt; join(
            Publisher&lt;? extends TRight&gt; other,
            Function&lt;? super T, ? extends Publisher&lt;TLeftEnd&gt;&gt; leftEnd,
            Function&lt;? super TRight, ? extends Publisher&lt;TRightEnd&gt;&gt; rightEnd,
            BiFunction&lt;? super T, ? super TRight, ? extends R&gt; resultSelector) {
<span class="fc" id="L11045">        ObjectHelper.requireNonNull(other, &quot;other is null&quot;);</span>
<span class="fc" id="L11046">        ObjectHelper.requireNonNull(leftEnd, &quot;leftEnd is null&quot;);</span>
<span class="fc" id="L11047">        ObjectHelper.requireNonNull(rightEnd, &quot;rightEnd is null&quot;);</span>
<span class="fc" id="L11048">        ObjectHelper.requireNonNull(resultSelector, &quot;resultSelector is null&quot;);</span>
<span class="fc" id="L11049">        return RxJavaPlugins.onAssembly(new FlowableJoin&lt;T, TRight, TLeftEnd, TRightEnd, R&gt;(</span>
                this, other, leftEnd, rightEnd, resultSelector));
    }

    /**
     * Returns a Maybe that emits the last item emitted by this Flowable or completes if
     * this Flowable is empty.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/last.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream and consumes the source {@code Publisher} in an
     *  unbounded manner (i.e., without applying backpressure).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code lastElement} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @return a new Maybe instance
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/last.html&quot;&gt;ReactiveX operators documentation: Last&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Maybe&lt;T&gt; lastElement() {
<span class="fc" id="L11073">        return RxJavaPlugins.onAssembly(new FlowableLastMaybe&lt;T&gt;(this));</span>
    }

    /**
     * Returns a Single that emits only the last item emitted by this Flowable, or a default item
     * if this Flowable completes without emitting any items.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/lastOrDefault.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream and consumes the source {@code Publisher} in an
     *  unbounded manner (i.e., without applying backpressure).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code last} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param defaultItem
     *            the default item to emit if the source Publisher is empty
     * @return the new Single instance
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/last.html&quot;&gt;ReactiveX operators documentation: Last&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Single&lt;T&gt; last(T defaultItem) {
<span class="fc" id="L11099">        ObjectHelper.requireNonNull(defaultItem, &quot;defaultItem&quot;);</span>
<span class="fc" id="L11100">        return RxJavaPlugins.onAssembly(new FlowableLastSingle&lt;T&gt;(this, defaultItem));</span>
    }

    /**
     * Returns a Single that emits only the last item emitted by this Flowable or signals
     * a {@link NoSuchElementException} if this Flowable is empty.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;236&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/lastOrError.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream and consumes the source {@code Publisher} in an
     *  unbounded manner (i.e., without applying backpressure).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code lastOrError} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @return the new Single instance
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/last.html&quot;&gt;ReactiveX operators documentation: Last&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Single&lt;T&gt; lastOrError() {
<span class="fc" id="L11123">        return RxJavaPlugins.onAssembly(new FlowableLastSingle&lt;T&gt;(this, null));</span>
    }

    /**
     * &lt;strong&gt;This method requires advanced knowledge about building operators, please consider
     * other standard composition methods first;&lt;/strong&gt;
     * Returns a {@code Flowable} which, when subscribed to, invokes the {@link FlowableOperator#apply(Subscriber) apply(Subscriber)} method
     * of the provided {@link FlowableOperator} for each individual downstream {@link Subscriber} and allows the
     * insertion of a custom operator by accessing the downstream's {@link Subscriber} during this subscription phase
     * and providing a new {@code Subscriber}, containing the custom operator's intended business logic, that will be
     * used in the subscription process going further upstream.
     * &lt;p&gt;
     * Generally, such a new {@code Subscriber} will wrap the downstream's {@code Subscriber} and forwards the
     * {@code onNext}, {@code onError} and {@code onComplete} events from the upstream directly or according to the
     * emission pattern the custom operator's business logic requires. In addition, such operator can intercept the
     * flow control calls of {@code cancel} and {@code request} that would have traveled upstream and perform
     * additional actions depending on the same business logic requirements.
     * &lt;p&gt;
     * Example:
     * &lt;pre&gt;&lt;code&gt;
     * // Step 1: Create the consumer type that will be returned by the FlowableOperator.apply():
     * 
     * public final class CustomSubscriber&amp;lt;T&amp;gt; implements FlowableSubscriber&amp;lt;T&amp;gt;, Subscription {
     *
     *     // The downstream's Subscriber that will receive the onXXX events
     *     final Subscriber&amp;lt;? super String&amp;gt; downstream;
     *
     *     // The connection to the upstream source that will call this class' onXXX methods
     *     Subscription upstream;
     *
     *     // The constructor takes the downstream subscriber and usually any other parameters
     *     public CustomSubscriber(Subscriber&amp;lt;? super String&amp;gt; downstream) {
     *         this.downstream = downstream;
     *     }
     *
     *     // In the subscription phase, the upstream sends a Subscription to this class
     *     // and subsequently this class has to send a Subscription to the downstream.
     *     // Note that relaying the upstream's Subscription instance directly is not allowed in RxJava
     *     &amp;#64;Override
     *     public void onSubscribe(Subscription s) {
     *         if (upstream != null) {
     *             s.cancel();
     *         } else {
     *             upstream = s;
     *             downstream.onSubscribe(this);
     *         }
     *     }
     *
     *     // The upstream calls this with the next item and the implementation's
     *     // responsibility is to emit an item to the downstream based on the intended
     *     // business logic, or if it can't do so for the particular item,
     *     // request more from the upstream
     *     &amp;#64;Override
     *     public void onNext(T item) {
     *         String str = item.toString();
     *         if (str.length() &amp;lt; 2) {
     *             downstream.onNext(str);
     *         } else {
     *             upstream.request(1);
     *         }
     *     }
     *
     *     // Some operators may handle the upstream's error while others
     *     // could just forward it to the downstream.
     *     &amp;#64;Override
     *     public void onError(Throwable throwable) {
     *         downstream.onError(throwable);
     *     }
     *
     *     // When the upstream completes, usually the downstream should complete as well.
     *     &amp;#64;Override
     *     public void onComplete() {
     *         downstream.onComplete();
     *     }
     *
     *     // Some operators have to intercept the downstream's request calls to trigger
     *     // the emission of queued items while others can simply forward the request
     *     // amount as is.
     *     &amp;#64;Override
     *     public void request(long n) {
     *         upstream.request(n);
     *     }
     *
     *     // Some operators may use their own resources which should be cleaned up if
     *     // the downstream cancels the flow before it completed. Operators without
     *     // resources can simply forward the cancellation to the upstream.
     *     // In some cases, a canceled flag may be set by this method so that other parts
     *     // of this class may detect the cancellation and stop sending events
     *     // to the downstream.
     *     &amp;#64;Override
     *     public void cancel() {
     *         upstream.cancel();
     *     }
     * }
     *
     * // Step 2: Create a class that implements the FlowableOperator interface and
     * //         returns the custom consumer type from above in its apply() method.
     * //         Such class may define additional parameters to be submitted to
     * //         the custom consumer type.
     *
     * final class CustomOperator&amp;lt;T&amp;gt; implements FlowableOperator&amp;lt;String&amp;gt; {
     *     &amp;#64;Override
     *     public Subscriber&amp;lt;? super String&amp;gt; apply(Subscriber&amp;lt;? super T&amp;gt; upstream) {
     *         return new CustomSubscriber&amp;lt;T&amp;gt;(upstream);
     *     }
     * }
     *
     * // Step 3: Apply the custom operator via lift() in a flow by creating an instance of it
     * //         or reusing an existing one.
     *
     * Flowable.range(5, 10)
     * .lift(new CustomOperator&amp;lt;Integer&amp;gt;())
     * .test()
     * .assertResult(&quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;);
     * &lt;/code&gt;&lt;/pre&gt;
     * &lt;p&gt;
     * Creating custom operators can be complicated and it is recommended one consults the
     * &lt;a href=&quot;https://github.com/ReactiveX/RxJava/wiki/Writing-operators-for-2.0&quot;&gt;RxJava wiki: Writing operators&lt;/a&gt; page about
     * the tools, requirements, rules, considerations and pitfalls of implementing them.
     * &lt;p&gt;
     * Note that implementing custom operators via this {@code lift()} method adds slightly more overhead by requiring
     * an additional allocation and indirection per assembled flows. Instead, extending the abstract {@code Flowable}
     * class and creating a {@link FlowableTransformer} with it is recommended.
     * &lt;p&gt;
     * Note also that it is not possible to stop the subscription phase in {@code lift()} as the {@code apply()} method
     * requires a non-null {@code Subscriber} instance to be returned, which is then unconditionally subscribed to
     * the upstream {@code Flowable}. For example, if the operator decided there is no reason to subscribe to the
     * upstream source because of some optimization possibility or a failure to prepare the operator, it still has to
     * return a {@code Subscriber} that should immediately cancel the upstream's {@code Subscription} in its
     * {@code onSubscribe} method. Again, using a {@code FlowableTransformer} and extending the {@code Flowable} is
     * a better option as {@link #subscribeActual} can decide to not subscribe to its upstream after all.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The {@code Subscriber} instance returned by the {@link FlowableOperator} is responsible to be
     *  backpressure-aware or document the fact that the consumer of the returned {@code Publisher} has to apply one of
     *  the {@code onBackpressureXXX} operators.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code lift} does not operate by default on a particular {@link Scheduler}, however, the
     *  {@link FlowableOperator} may use a {@code Scheduler} to support its own asynchronous behavior.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;R&gt; the output value type
     * @param lifter the {@link FlowableOperator} that receives the downstream's {@code Subscriber} and should return
     *               a {@code Subscriber} with custom behavior to be used as the consumer for the current
     *               {@code Flowable}.
     * @return the new Flowable instance
     * @see &lt;a href=&quot;https://github.com/ReactiveX/RxJava/wiki/Writing-operators-for-2.0&quot;&gt;RxJava wiki: Writing operators&lt;/a&gt;
     * @see #compose(FlowableTransformer)
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.SPECIAL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;R&gt; Flowable&lt;R&gt; lift(FlowableOperator&lt;? extends R, ? super T&gt; lifter) {
<span class="fc" id="L11277">        ObjectHelper.requireNonNull(lifter, &quot;lifter is null&quot;);</span>
<span class="fc" id="L11278">        return RxJavaPlugins.onAssembly(new FlowableLift&lt;R, T&gt;(this, lifter));</span>
    }

    /**
     * Limits both the number of upstream items (after which the sequence completes)
     * and the total downstream request amount requested from the upstream to
     * possibly prevent the creation of excess items by the upstream.
     * &lt;p&gt;
     * The operator requests at most the given {@code count} of items from upstream even
     * if the downstream requests more than that. For example, given a {@code limit(5)},
     * if the downstream requests 1, a request of 1 is submitted to the upstream
     * and the operator remembers that only 4 items can be requested now on. A request
     * of 5 at this point will request 4 from the upstream and any subsequent requests will
     * be ignored.
     * &lt;p&gt;
     * Note that requests are negotiated on an operator boundary and {@code limit}'s amount
     * may not be preserved further upstream. For example,
     * {@code source.observeOn(Schedulers.computation()).limit(5)} will still request the
     * default (128) elements from the given {@code source}.
     * &lt;p&gt;
     * The main use of this operator is with sources that are async boundaries that
     * don't interfere with request amounts, such as certain {@code Flowable}-based
     * network endpoints that relay downstream request amounts unchanged and are, therefore,
     * prone to trigger excessive item creation/transmission over the network.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator requests a total of the given {@code count} items from the upstream.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code limit} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * &lt;p&gt;History: 2.1.6 - experimental
     * @param count the maximum number of items and the total request amount, non-negative.
     *              Zero will immediately cancel the upstream on subscription and complete
     *              the downstream.
     * @return the new Flowable instance
     * @see #take(long)
     * @see #rebatchRequests(int)
     * @since 2.2
     */
    @BackpressureSupport(BackpressureKind.SPECIAL)
    @SchedulerSupport(SchedulerSupport.NONE)
    @CheckReturnValue
    public final Flowable&lt;T&gt; limit(long count) {
<span class="fc bfc" id="L11321" title="All 2 branches covered.">        if (count &lt; 0) {</span>
<span class="fc" id="L11322">            throw new IllegalArgumentException(&quot;count &gt;= 0 required but it was &quot; + count);</span>
        }
<span class="fc" id="L11324">        return RxJavaPlugins.onAssembly(new FlowableLimit&lt;T&gt;(this, count));</span>
    }

    /**
     * Returns a Flowable that applies a specified function to each item emitted by the source Publisher and
     * emits the results of these function applications.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/map.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure
     *  behavior.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code map} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;R&gt; the output type
     * @param mapper
     *            a function to apply to each item emitted by the Publisher
     * @return a Flowable that emits the items from the source Publisher, transformed by the specified
     *         function
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/map.html&quot;&gt;ReactiveX operators documentation: Map&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;R&gt; Flowable&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper) {
<span class="fc" id="L11352">        ObjectHelper.requireNonNull(mapper, &quot;mapper is null&quot;);</span>
<span class="fc" id="L11353">        return RxJavaPlugins.onAssembly(new FlowableMap&lt;T, R&gt;(this, mapper));</span>
    }

    /**
     * Returns a Flowable that represents all of the emissions &lt;em&gt;and&lt;/em&gt; notifications from the source
     * Publisher into emissions marked with their original types within {@link Notification} objects.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;315&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/materialize.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream and expects it from the source {@code Publisher}.
     *  If this expectation is violated, the operator &lt;em&gt;may&lt;/em&gt; throw an {@code IllegalStateException}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code materialize} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @return a Flowable that emits items that are the result of materializing the items and notifications
     *         of the source Publisher
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/materialize-dematerialize.html&quot;&gt;ReactiveX operators documentation: Materialize&lt;/a&gt;
     * @see #dematerialize(Function)
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;Notification&lt;T&gt;&gt; materialize() {
<span class="fc" id="L11378">        return RxJavaPlugins.onAssembly(new FlowableMaterialize&lt;T&gt;(this));</span>
    }

    /**
     * Flattens this and another Publisher into a single Publisher, without any transformation.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/merge.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * You can combine items emitted by multiple Publishers so that they appear as a single Publisher, by
     * using the {@code mergeWith} method.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream. This and the other {@code Publisher}s are expected to honor
     *  backpressure; if violated, the operator &lt;em&gt;may&lt;/em&gt; signal {@code MissingBackpressureException}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code mergeWith} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param other
     *            a Publisher to be merged
     * @return a Flowable that emits all of the items emitted by the source Publishers
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/merge.html&quot;&gt;ReactiveX operators documentation: Merge&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;T&gt; mergeWith(Publisher&lt;? extends T&gt; other) {
<span class="fc" id="L11406">        ObjectHelper.requireNonNull(other, &quot;other is null&quot;);</span>
<span class="fc" id="L11407">        return merge(this, other);</span>
    }

    /**
     * Merges the sequence of items of this Flowable with the success value of the other SingleSource.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/merge.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * The success value of the other {@code SingleSource} can get interleaved at any point of this
     * {@code Flowable} sequence.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream and ensures the success item from the
     *  {@code SingleSource} is emitted only when there is a downstream demand.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code mergeWith} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * &lt;p&gt;History: 2.1.10 - experimental
     * @param other the {@code SingleSource} whose success value to merge with
     * @return the new Flowable instance
     * @since 2.2
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;T&gt; mergeWith(@NonNull SingleSource&lt;? extends T&gt; other) {
<span class="fc" id="L11434">        ObjectHelper.requireNonNull(other, &quot;other is null&quot;);</span>
<span class="fc" id="L11435">        return RxJavaPlugins.onAssembly(new FlowableMergeWithSingle&lt;T&gt;(this, other));</span>
    }

    /**
     * Merges the sequence of items of this Flowable with the success value of the other MaybeSource
     * or waits for both to complete normally if the MaybeSource is empty.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/merge.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * The success value of the other {@code MaybeSource} can get interleaved at any point of this
     * {@code Flowable} sequence.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream and ensures the success item from the
     *  {@code MaybeSource} is emitted only when there is a downstream demand.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code mergeWith} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * &lt;p&gt;History: 2.1.10 - experimental
     * @param other the {@code MaybeSource} which provides a success value to merge with or completes
     * @return the new Flowable instance
     * @since 2.2
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;T&gt; mergeWith(@NonNull MaybeSource&lt;? extends T&gt; other) {
<span class="fc" id="L11463">        ObjectHelper.requireNonNull(other, &quot;other is null&quot;);</span>
<span class="fc" id="L11464">        return RxJavaPlugins.onAssembly(new FlowableMergeWithMaybe&lt;T&gt;(this, other));</span>
    }

    /**
     * Relays the items of this Flowable and completes only when the other CompletableSource completes
     * as well.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/merge.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure
     *  behavior.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code mergeWith} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * &lt;p&gt;History: 2.1.10 - experimental
     * @param other the {@code CompletableSource} to await for completion
     * @return the new Flowable instance
     * @since 2.2
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;T&gt; mergeWith(@NonNull CompletableSource other) {
<span class="fc" id="L11489">        ObjectHelper.requireNonNull(other, &quot;other is null&quot;);</span>
<span class="fc" id="L11490">        return RxJavaPlugins.onAssembly(new FlowableMergeWithCompletable&lt;T&gt;(this, other));</span>
    }

    /**
     * Modifies a Publisher to perform its emissions and notifications on a specified {@link Scheduler},
     * asynchronously with a bounded buffer of {@link #bufferSize()} slots.
     *
     * &lt;p&gt;Note that onError notifications will cut ahead of onNext notifications on the emission thread if Scheduler is truly
     * asynchronous. If strict event ordering is required, consider using the {@link #observeOn(Scheduler, boolean)} overload.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;308&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/observeOn.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator honors backpressure from downstream and expects it from the source {@code Publisher}. Violating this
     *  expectation will lead to {@code MissingBackpressureException}. This is the most common operator where the exception
     *  pops up; look for sources up the chain that don't support backpressure,
     *  such as {@code interval}, {@code timer}, {code PublishSubject} or {@code BehaviorSubject} and apply any
     *  of the {@code onBackpressureXXX} operators &lt;strong&gt;before&lt;/strong&gt; applying {@code observeOn} itself.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;You specify which {@link Scheduler} this operator will use.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param scheduler
     *            the {@link Scheduler} to notify {@link Subscriber}s on
     * @return the source Publisher modified so that its {@link Subscriber}s are notified on the specified
     *         {@link Scheduler}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/observeon.html&quot;&gt;ReactiveX operators documentation: ObserveOn&lt;/a&gt;
     * @see &lt;a href=&quot;http://www.grahamlea.com/2014/07/rxjava-threading-examples/&quot;&gt;RxJava Threading Examples&lt;/a&gt;
     * @see #subscribeOn
     * @see #observeOn(Scheduler, boolean)
     * @see #observeOn(Scheduler, boolean, int)
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Flowable&lt;T&gt; observeOn(Scheduler scheduler) {
<span class="fc" id="L11526">        return observeOn(scheduler, false, bufferSize());</span>
    }

    /**
     * Modifies a Publisher to perform its emissions and notifications on a specified {@link Scheduler},
     * asynchronously with a bounded buffer and optionally delays onError notifications.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;308&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/observeOn.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator honors backpressure from downstream and expects it from the source {@code Publisher}. Violating this
     *  expectation will lead to {@code MissingBackpressureException}. This is the most common operator where the exception
     *  pops up; look for sources up the chain that don't support backpressure,
     *  such as {@code interval}, {@code timer}, {code PublishSubject} or {@code BehaviorSubject} and apply any
     *  of the {@code onBackpressureXXX} operators &lt;strong&gt;before&lt;/strong&gt; applying {@code observeOn} itself.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;You specify which {@link Scheduler} this operator will use.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param scheduler
     *            the {@link Scheduler} to notify {@link Subscriber}s on
     * @param delayError
     *            indicates if the onError notification may not cut ahead of onNext notification on the other side of the
     *            scheduling boundary. If true a sequence ending in onError will be replayed in the same order as was received
     *            from upstream
     * @return the source Publisher modified so that its {@link Subscriber}s are notified on the specified
     *         {@link Scheduler}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/observeon.html&quot;&gt;ReactiveX operators documentation: ObserveOn&lt;/a&gt;
     * @see &lt;a href=&quot;http://www.grahamlea.com/2014/07/rxjava-threading-examples/&quot;&gt;RxJava Threading Examples&lt;/a&gt;
     * @see #subscribeOn
     * @see #observeOn(Scheduler)
     * @see #observeOn(Scheduler, boolean, int)
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Flowable&lt;T&gt; observeOn(Scheduler scheduler, boolean delayError) {
<span class="fc" id="L11563">        return observeOn(scheduler, delayError, bufferSize());</span>
    }

    /**
     * Modifies a Publisher to perform its emissions and notifications on a specified {@link Scheduler},
     * asynchronously with a bounded buffer of configurable size and optionally delays onError notifications.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;308&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/observeOn.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator honors backpressure from downstream and expects it from the source {@code Publisher}. Violating this
     *  expectation will lead to {@code MissingBackpressureException}. This is the most common operator where the exception
     *  pops up; look for sources up the chain that don't support backpressure,
     *  such as {@code interval}, {@code timer}, {code PublishSubject} or {@code BehaviorSubject} and apply any
     *  of the {@code onBackpressureXXX} operators &lt;strong&gt;before&lt;/strong&gt; applying {@code observeOn} itself.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;You specify which {@link Scheduler} this operator will use.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param scheduler
     *            the {@link Scheduler} to notify {@link Subscriber}s on
     * @param delayError
     *            indicates if the onError notification may not cut ahead of onNext notification on the other side of the
     *            scheduling boundary. If true a sequence ending in onError will be replayed in the same order as was received
     *            from upstream
     * @param bufferSize the size of the buffer.
     * @return the source Publisher modified so that its {@link Subscriber}s are notified on the specified
     *         {@link Scheduler}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/observeon.html&quot;&gt;ReactiveX operators documentation: ObserveOn&lt;/a&gt;
     * @see &lt;a href=&quot;http://www.grahamlea.com/2014/07/rxjava-threading-examples/&quot;&gt;RxJava Threading Examples&lt;/a&gt;
     * @see #subscribeOn
     * @see #observeOn(Scheduler)
     * @see #observeOn(Scheduler, boolean)
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Flowable&lt;T&gt; observeOn(Scheduler scheduler, boolean delayError, int bufferSize) {
<span class="fc" id="L11602">        ObjectHelper.requireNonNull(scheduler, &quot;scheduler is null&quot;);</span>
<span class="fc" id="L11603">        ObjectHelper.verifyPositive(bufferSize, &quot;bufferSize&quot;);</span>
<span class="fc" id="L11604">        return RxJavaPlugins.onAssembly(new FlowableObserveOn&lt;T&gt;(this, scheduler, delayError, bufferSize));</span>
    }

    /**
     * Filters the items emitted by a Publisher, only emitting those of the specified type.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/ofClass.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure
     *  behavior.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code ofType} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;U&gt; the output type
     * @param clazz
     *            the class type to filter the items emitted by the source Publisher
     * @return a Flowable that emits items from the source Publisher of type {@code clazz}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/filter.html&quot;&gt;ReactiveX operators documentation: Filter&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;U&gt; Flowable&lt;U&gt; ofType(final Class&lt;U&gt; clazz) {
<span class="fc" id="L11630">        ObjectHelper.requireNonNull(clazz, &quot;clazz is null&quot;);</span>
<span class="fc" id="L11631">        return filter(Functions.isInstanceOf(clazz)).cast(clazz);</span>
    }

    /**
     * Instructs a Publisher that is emitting items faster than its Subscriber can consume them to buffer these
     * items indefinitely until they can be emitted.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;300&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/bp.obp.buffer.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream and consumes the source {@code Publisher} in an unbounded
     *  manner (i.e., not applying backpressure to it).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code onBackpressureBuffer} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @return the source Publisher modified to buffer items to the extent system resources allow
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/backpressure.html&quot;&gt;ReactiveX operators documentation: backpressure operators&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;T&gt; onBackpressureBuffer() {
<span class="fc" id="L11654">        return onBackpressureBuffer(bufferSize(), false, true);</span>
    }

    /**
     * Instructs a Publisher that is emitting items faster than its Subscriber can consume them to buffer these
     * items indefinitely until they can be emitted.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;300&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/bp.obp.buffer.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream and consumes the source {@code Publisher} in an unbounded
     *  manner (i.e., not applying backpressure to it).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code onBackpressureBuffer} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param delayError
     *                if true, an exception from the current Flowable is delayed until all buffered elements have been
     *                consumed by the downstream; if false, an exception is immediately signaled to the downstream, skipping
     *                any buffered element
     * @return the source Publisher modified to buffer items to the extent system resources allow
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/backpressure.html&quot;&gt;ReactiveX operators documentation: backpressure operators&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;T&gt; onBackpressureBuffer(boolean delayError) {
<span class="fc" id="L11680">        return onBackpressureBuffer(bufferSize(), delayError, true);</span>
    }

    /**
     * Instructs a Publisher that is emitting items faster than its Subscriber can consume them to buffer up to
     * a given amount of items until they can be emitted. The resulting Publisher will signal
     * a {@code BufferOverflowException} via {@code onError} as soon as the buffer's capacity is exceeded, dropping all undelivered
     * items, and canceling the source.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;300&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/bp.obp.buffer.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream and consumes the source {@code Publisher} in an unbounded
     *  manner (i.e., not applying backpressure to it).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code onBackpressureBuffer} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param capacity number of slots available in the buffer.
     * @return the source {@code Publisher} modified to buffer items up to the given capacity.
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/backpressure.html&quot;&gt;ReactiveX operators documentation: backpressure operators&lt;/a&gt;
     * @since 1.1.0
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;T&gt; onBackpressureBuffer(int capacity) {
<span class="fc" id="L11707">        return onBackpressureBuffer(capacity, false, false);</span>
    }

    /**
     * Instructs a Publisher that is emitting items faster than its Subscriber can consume them to buffer up to
     * a given amount of items until they can be emitted. The resulting Publisher will signal
     * a {@code BufferOverflowException} via {@code onError} as soon as the buffer's capacity is exceeded, dropping all undelivered
     * items, and canceling the source.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;300&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/bp.obp.buffer.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream and consumes the source {@code Publisher} in an unbounded
     *  manner (i.e., not applying backpressure to it).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code onBackpressureBuffer} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param capacity number of slots available in the buffer.
     * @param delayError
     *                if true, an exception from the current Flowable is delayed until all buffered elements have been
     *                consumed by the downstream; if false, an exception is immediately signaled to the downstream, skipping
     *                any buffered element
     * @return the source {@code Publisher} modified to buffer items up to the given capacity.
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/backpressure.html&quot;&gt;ReactiveX operators documentation: backpressure operators&lt;/a&gt;
     * @since 1.1.0
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;T&gt; onBackpressureBuffer(int capacity, boolean delayError) {
<span class="fc" id="L11738">        return onBackpressureBuffer(capacity, delayError, false);</span>
    }

    /**
     * Instructs a Publisher that is emitting items faster than its Subscriber can consume them to buffer up to
     * a given amount of items until they can be emitted. The resulting Publisher will signal
     * a {@code BufferOverflowException} via {@code onError} as soon as the buffer's capacity is exceeded, dropping all undelivered
     * items, and canceling the source.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;300&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/bp.obp.buffer.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream and consumes the source {@code Publisher} in an unbounded
     *  manner (i.e., not applying backpressure to it).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code onBackpressureBuffer} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param capacity number of slots available in the buffer.
     * @param delayError
     *                if true, an exception from the current Flowable is delayed until all buffered elements have been
     *                consumed by the downstream; if false, an exception is immediately signaled to the downstream, skipping
     *                any buffered element
     * @param unbounded
     *                if true, the capacity value is interpreted as the internal &quot;island&quot; size of the unbounded buffer
     * @return the source {@code Publisher} modified to buffer items up to the given capacity.
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/backpressure.html&quot;&gt;ReactiveX operators documentation: backpressure operators&lt;/a&gt;
     * @since 1.1.0
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.SPECIAL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;T&gt; onBackpressureBuffer(int capacity, boolean delayError, boolean unbounded) {
<span class="fc" id="L11771">        ObjectHelper.verifyPositive(capacity, &quot;capacity&quot;);</span>
<span class="fc" id="L11772">        return RxJavaPlugins.onAssembly(new FlowableOnBackpressureBuffer&lt;T&gt;(this, capacity, unbounded, delayError, Functions.EMPTY_ACTION));</span>
    }

    /**
     * Instructs a Publisher that is emitting items faster than its Subscriber can consume them to buffer up to
     * a given amount of items until they can be emitted. The resulting Publisher will signal
     * a {@code BufferOverflowException} via {@code onError} as soon as the buffer's capacity is exceeded, dropping all undelivered
     * items, canceling the source, and notifying the producer with {@code onOverflow}.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;300&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/bp.obp.buffer.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream and consumes the source {@code Publisher} in an unbounded
     *  manner (i.e., not applying backpressure to it).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code onBackpressureBuffer} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param capacity number of slots available in the buffer.
     * @param delayError
     *                if true, an exception from the current Flowable is delayed until all buffered elements have been
     *                consumed by the downstream; if false, an exception is immediately signaled to the downstream, skipping
     *                any buffered element
     * @param unbounded
     *                if true, the capacity value is interpreted as the internal &quot;island&quot; size of the unbounded buffer
     * @param onOverflow action to execute if an item needs to be buffered, but there are no available slots.  Null is allowed.
     * @return the source {@code Publisher} modified to buffer items up to the given capacity
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/backpressure.html&quot;&gt;ReactiveX operators documentation: backpressure operators&lt;/a&gt;
     * @since 1.1.0
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.SPECIAL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;T&gt; onBackpressureBuffer(int capacity, boolean delayError, boolean unbounded,
            Action onOverflow) {
<span class="fc" id="L11808">        ObjectHelper.requireNonNull(onOverflow, &quot;onOverflow is null&quot;);</span>
<span class="fc" id="L11809">        ObjectHelper.verifyPositive(capacity, &quot;capacity&quot;);</span>
<span class="fc" id="L11810">        return RxJavaPlugins.onAssembly(new FlowableOnBackpressureBuffer&lt;T&gt;(this, capacity, unbounded, delayError, onOverflow));</span>
    }

    /**
     * Instructs a Publisher that is emitting items faster than its Subscriber can consume them to buffer up to
     * a given amount of items until they can be emitted. The resulting Publisher will signal
     * a {@code BufferOverflowException} via {@code onError} as soon as the buffer's capacity is exceeded, dropping all undelivered
     * items, canceling the source, and notifying the producer with {@code onOverflow}.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;300&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/bp.obp.buffer.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream and consumes the source {@code Publisher} in an unbounded
     *  manner (i.e., not applying backpressure to it).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code onBackpressureBuffer} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param capacity number of slots available in the buffer.
     * @param onOverflow action to execute if an item needs to be buffered, but there are no available slots.  Null is allowed.
     * @return the source {@code Publisher} modified to buffer items up to the given capacity
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/backpressure.html&quot;&gt;ReactiveX operators documentation: backpressure operators&lt;/a&gt;
     * @since 1.1.0
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;T&gt; onBackpressureBuffer(int capacity, Action onOverflow) {
<span class="fc" id="L11838">        return onBackpressureBuffer(capacity, false, false, onOverflow);</span>
    }

    /**
     * Instructs a Publisher that is emitting items faster than its Subscriber can consume them to buffer up to
     * a given amount of items until they can be emitted. The resulting Publisher will behave as determined
     * by {@code overflowStrategy} if the buffer capacity is exceeded.
     *
     * &lt;ul&gt;
     *     &lt;li&gt;{@code BackpressureOverflow.Strategy.ON_OVERFLOW_ERROR} (default) will call {@code onError} dropping all undelivered items,
     *     canceling the source, and notifying the producer with {@code onOverflow}. &lt;/li&gt;
     *     &lt;li&gt;{@code BackpressureOverflow.Strategy.ON_OVERFLOW_DROP_LATEST} will drop any new items emitted by the producer while
     *     the buffer is full, without generating any {@code onError}.  Each drop will, however, invoke {@code onOverflow}
     *     to signal the overflow to the producer.&lt;/li&gt;
     *     &lt;li&gt;{@code BackpressureOverflow.Strategy.ON_OVERFLOW_DROP_OLDEST} will drop the oldest items in the buffer in order to make
     *     room for newly emitted ones. Overflow will not generate an{@code onError}, but each drop will invoke
     *     {@code onOverflow} to signal the overflow to the producer.&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;300&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/bp.obp.buffer.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream and consumes the source {@code Publisher} in an unbounded
     *  manner (i.e., not applying backpressure to it).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code onBackpressureBuffer} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param capacity number of slots available in the buffer.
     * @param onOverflow action to execute if an item needs to be buffered, but there are no available slots.  Null is allowed.
     * @param overflowStrategy how should the {@code Publisher} react to buffer overflows.  Null is not allowed.
     * @return the source {@code Flowable} modified to buffer items up to the given capacity
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/backpressure.html&quot;&gt;ReactiveX operators documentation: backpressure operators&lt;/a&gt;
     * @since 2.0
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.SPECIAL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;T&gt; onBackpressureBuffer(long capacity, Action onOverflow, BackpressureOverflowStrategy overflowStrategy) {
<span class="fc" id="L11879">        ObjectHelper.requireNonNull(overflowStrategy, &quot;overflowStrategy is null&quot;);</span>
<span class="fc" id="L11880">        ObjectHelper.verifyPositive(capacity, &quot;capacity&quot;);</span>
<span class="fc" id="L11881">        return RxJavaPlugins.onAssembly(new FlowableOnBackpressureBufferStrategy&lt;T&gt;(this, capacity, onOverflow, overflowStrategy));</span>
    }

    /**
     * Instructs a Publisher that is emitting items faster than its Subscriber can consume them to discard,
     * rather than emit, those items that its Subscriber is not prepared to observe.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;245&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/bp.obp.drop.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * If the downstream request count hits 0 then the Publisher will refrain from calling {@code onNext} until
     * the Subscriber invokes {@code request(n)} again to increase the request count.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream and consumes the source {@code Publisher} in an unbounded
     *  manner (i.e., not applying backpressure to it).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code onBackpressureDrop} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @return the source Publisher modified to drop {@code onNext} notifications on overflow
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/backpressure.html&quot;&gt;ReactiveX operators documentation: backpressure operators&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;T&gt; onBackpressureDrop() {
<span class="fc" id="L11907">        return RxJavaPlugins.onAssembly(new FlowableOnBackpressureDrop&lt;T&gt;(this));</span>
    }

    /**
     * Instructs a Publisher that is emitting items faster than its Subscriber can consume them to discard,
     * rather than emit, those items that its Subscriber is not prepared to observe.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;245&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/bp.obp.drop.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * If the downstream request count hits 0 then the Publisher will refrain from calling {@code onNext} until
     * the Subscriber invokes {@code request(n)} again to increase the request count.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream and consumes the source {@code Publisher} in an unbounded
     *  manner (i.e., not applying backpressure to it).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code onBackpressureDrop} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param onDrop the action to invoke for each item dropped. onDrop action should be fast and should never block.
     * @return the source Publisher modified to drop {@code onNext} notifications on overflow
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/backpressure.html&quot;&gt;ReactiveX operators documentation: backpressure operators&lt;/a&gt;
     * @since 1.1.0
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;T&gt; onBackpressureDrop(Consumer&lt;? super T&gt; onDrop) {
<span class="fc" id="L11936">        ObjectHelper.requireNonNull(onDrop, &quot;onDrop is null&quot;);</span>
<span class="fc" id="L11937">        return RxJavaPlugins.onAssembly(new FlowableOnBackpressureDrop&lt;T&gt;(this, onDrop));</span>
    }

    /**
     * Instructs a Publisher that is emitting items faster than its Subscriber can consume them to
     * hold onto the latest value and emit that on request.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;245&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/bp.obp.latest.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * Its behavior is logically equivalent to {@code blockingLatest()} with the exception that
     * the downstream is not blocking while requesting more values.
     * &lt;p&gt;
     * Note that if the upstream Publisher does support backpressure, this operator ignores that capability
     * and doesn't propagate any backpressure requests from downstream.
     * &lt;p&gt;
     * Note that due to the nature of how backpressure requests are propagated through subscribeOn/observeOn,
     * requesting more than 1 from downstream doesn't guarantee a continuous delivery of onNext events.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream and consumes the source {@code Publisher} in an unbounded
     *  manner (i.e., not applying backpressure to it).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code onBackpressureLatest} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @return the source Publisher modified so that it emits the most recently-received item upon request
     * @since 1.1.0
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;T&gt; onBackpressureLatest() {
<span class="fc" id="L11969">        return RxJavaPlugins.onAssembly(new FlowableOnBackpressureLatest&lt;T&gt;(this));</span>
    }

    /**
     * Instructs a Publisher to pass control to another Publisher rather than invoking
     * {@link Subscriber#onError onError} if it encounters an error.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/onErrorResumeNext.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * By default, when a Publisher encounters an error that prevents it from emitting the expected item to
     * its {@link Subscriber}, the Publisher invokes its Subscriber's {@code onError} method, and then quits
     * without invoking any more of its Subscriber's methods. The {@code onErrorResumeNext} method changes this
     * behavior. If you pass a function that returns a Publisher ({@code resumeFunction}) to
     * {@code onErrorResumeNext}, if the original Publisher encounters an error, instead of invoking its
     * Subscriber's {@code onError} method, it will instead relinquish control to the Publisher returned from
     * {@code resumeFunction}, which will invoke the Subscriber's {@link Subscriber#onNext onNext} method if it is
     * able to do so. In such a case, because no Publisher necessarily invokes {@code onError}, the Subscriber
     * may never know that an error happened.
     * &lt;p&gt;
     * You can use this to prevent errors from propagating or to supply fallback data should errors be
     * encountered.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream. This and the resuming {@code Publisher}s
     *  are expected to honor backpressure as well.
     *  If any of them violate this expectation, the operator &lt;em&gt;may&lt;/em&gt; throw an
     *  {@code IllegalStateException} when the source {@code Publisher} completes or
     *  a {@code MissingBackpressureException} is signaled somewhere downstream.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code onErrorResumeNext} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param resumeFunction
     *            a function that returns a Publisher that will take over if the source Publisher encounters
     *            an error
     * @return the original Publisher, with appropriately modified behavior
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/catch.html&quot;&gt;ReactiveX operators documentation: Catch&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;T&gt; onErrorResumeNext(Function&lt;? super Throwable, ? extends Publisher&lt;? extends T&gt;&gt; resumeFunction) {
<span class="fc" id="L12012">        ObjectHelper.requireNonNull(resumeFunction, &quot;resumeFunction is null&quot;);</span>
<span class="fc" id="L12013">        return RxJavaPlugins.onAssembly(new FlowableOnErrorNext&lt;T&gt;(this, resumeFunction, false));</span>
    }

    /**
     * Instructs a Publisher to pass control to another Publisher rather than invoking
     * {@link Subscriber#onError onError} if it encounters an error.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/onErrorResumeNext.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * By default, when a Publisher encounters an error that prevents it from emitting the expected item to
     * its {@link Subscriber}, the Publisher invokes its Subscriber's {@code onError} method, and then quits
     * without invoking any more of its Subscriber's methods. The {@code onErrorResumeNext} method changes this
     * behavior. If you pass another Publisher ({@code resumeSequence}) to a Publisher's
     * {@code onErrorResumeNext} method, if the original Publisher encounters an error, instead of invoking its
     * Subscriber's {@code onError} method, it will instead relinquish control to {@code resumeSequence} which
     * will invoke the Subscriber's {@link Subscriber#onNext onNext} method if it is able to do so. In such a case,
     * because no Publisher necessarily invokes {@code onError}, the Subscriber may never know that an error
     * happened.
     * &lt;p&gt;
     * You can use this to prevent errors from propagating or to supply fallback data should errors be
     * encountered.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream. This and the resuming {@code Publisher}s
     *  are expected to honor backpressure as well.
     *  If any of them violate this expectation, the operator &lt;em&gt;may&lt;/em&gt; throw an
     *  {@code IllegalStateException} when the source {@code Publisher} completes or
     *  {@code MissingBackpressureException} is signaled somewhere downstream.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code onErrorResumeNext} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param next
     *            the next Publisher source that will take over if the source Publisher encounters
     *            an error
     * @return the original Publisher, with appropriately modified behavior
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/catch.html&quot;&gt;ReactiveX operators documentation: Catch&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;T&gt; onErrorResumeNext(final Publisher&lt;? extends T&gt; next) {
<span class="fc" id="L12056">        ObjectHelper.requireNonNull(next, &quot;next is null&quot;);</span>
<span class="fc" id="L12057">        return onErrorResumeNext(Functions.justFunction(next));</span>
    }

    /**
     * Instructs a Publisher to emit an item (returned by a specified function) rather than invoking
     * {@link Subscriber#onError onError} if it encounters an error.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/onErrorReturn.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * By default, when a Publisher encounters an error that prevents it from emitting the expected item to
     * its {@link Subscriber}, the Publisher invokes its Subscriber's {@code onError} method, and then quits
     * without invoking any more of its Subscriber's methods. The {@code onErrorReturn} method changes this
     * behavior. If you pass a function ({@code resumeFunction}) to a Publisher's {@code onErrorReturn}
     * method, if the original Publisher encounters an error, instead of invoking its Subscriber's
     * {@code onError} method, it will instead emit the return value of {@code resumeFunction}.
     * &lt;p&gt;
     * You can use this to prevent errors from propagating or to supply fallback data should errors be
     * encountered.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream. The source {@code Publisher}s is expected to honor
     *  backpressure as well. If it this expectation is violated, the operator &lt;em&gt;may&lt;/em&gt; throw
     *  {@code IllegalStateException} when the source {@code Publisher} completes or
     *  {@code MissingBackpressureException} is signaled somewhere downstream.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code onErrorReturn} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param valueSupplier
     *            a function that returns a single value that will be emitted along with a regular onComplete in case
     *            the current Flowable signals an onError event
     * @return the original Publisher with appropriately modified behavior
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/catch.html&quot;&gt;ReactiveX operators documentation: Catch&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;T&gt; onErrorReturn(Function&lt;? super Throwable, ? extends T&gt; valueSupplier) {
<span class="fc" id="L12096">        ObjectHelper.requireNonNull(valueSupplier, &quot;valueSupplier is null&quot;);</span>
<span class="fc" id="L12097">        return RxJavaPlugins.onAssembly(new FlowableOnErrorReturn&lt;T&gt;(this, valueSupplier));</span>
    }

    /**
     * Instructs a Publisher to emit an item (returned by a specified function) rather than invoking
     * {@link Subscriber#onError onError} if it encounters an error.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/onErrorReturn.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * By default, when a Publisher encounters an error that prevents it from emitting the expected item to
     * its {@link Subscriber}, the Publisher invokes its Subscriber's {@code onError} method, and then quits
     * without invoking any more of its Subscriber's methods. The {@code onErrorReturn} method changes this
     * behavior. If you pass a function ({@code resumeFunction}) to a Publisher's {@code onErrorReturn}
     * method, if the original Publisher encounters an error, instead of invoking its Subscriber's
     * {@code onError} method, it will instead emit the return value of {@code resumeFunction}.
     * &lt;p&gt;
     * You can use this to prevent errors from propagating or to supply fallback data should errors be
     * encountered.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream. The source {@code Publisher}s is expected to honor
     *  backpressure as well. If it this expectation is violated, the operator &lt;em&gt;may&lt;/em&gt; throw
     *  {@code IllegalStateException} when the source {@code Publisher} completes or
     *  {@code MissingBackpressureException} is signaled somewhere downstream.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code onErrorReturnItem} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param item
     *            the value that is emitted along with a regular onComplete in case the current
     *            Flowable signals an exception
     * @return the original Publisher with appropriately modified behavior
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/catch.html&quot;&gt;ReactiveX operators documentation: Catch&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;T&gt; onErrorReturnItem(final T item) {
<span class="fc" id="L12136">        ObjectHelper.requireNonNull(item, &quot;item is null&quot;);</span>
<span class="fc" id="L12137">        return onErrorReturn(Functions.justFunction(item));</span>
    }

    /**
     * Instructs a Publisher to pass control to another Publisher rather than invoking
     * {@link Subscriber#onError onError} if it encounters an {@link java.lang.Exception}.
     * &lt;p&gt;
     * This differs from {@link #onErrorResumeNext} in that this one does not handle {@link java.lang.Throwable}
     * or {@link java.lang.Error} but lets those continue through.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/onExceptionResumeNextViaPublisher.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * By default, when a Publisher encounters an exception that prevents it from emitting the expected item
     * to its {@link Subscriber}, the Publisher invokes its Subscriber's {@code onError} method, and then quits
     * without invoking any more of its Subscriber's methods. The {@code onExceptionResumeNext} method changes
     * this behavior. If you pass another Publisher ({@code resumeSequence}) to a Publisher's
     * {@code onExceptionResumeNext} method, if the original Publisher encounters an exception, instead of
     * invoking its Subscriber's {@code onError} method, it will instead relinquish control to
     * {@code resumeSequence} which will invoke the Subscriber's {@link Subscriber#onNext onNext} method if it is
     * able to do so. In such a case, because no Publisher necessarily invokes {@code onError}, the Subscriber
     * may never know that an exception happened.
     * &lt;p&gt;
     * You can use this to prevent exceptions from propagating or to supply fallback data should exceptions be
     * encountered.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream. This and the resuming {@code Publisher}s
     *  are expected to honor backpressure as well.
     *  If any of them violate this expectation, the operator &lt;em&gt;may&lt;/em&gt; throw an
     *  {@code IllegalStateException} when the source {@code Publisher} completes or
     *  {@code MissingBackpressureException} is signaled somewhere downstream.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code onExceptionResumeNext} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param next
     *            the next Publisher that will take over if the source Publisher encounters
     *            an exception
     * @return the original Publisher, with appropriately modified behavior
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/catch.html&quot;&gt;ReactiveX operators documentation: Catch&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;T&gt; onExceptionResumeNext(final Publisher&lt;? extends T&gt; next) {
<span class="fc" id="L12183">        ObjectHelper.requireNonNull(next, &quot;next is null&quot;);</span>
<span class="fc" id="L12184">        return RxJavaPlugins.onAssembly(new FlowableOnErrorNext&lt;T&gt;(this, Functions.justFunction(next), true));</span>
    }

    /**
     * Nulls out references to the upstream producer and downstream Subscriber if
     * the sequence is terminated or downstream cancels.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure
     *  behavior.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code onTerminateDetach} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @return a Flowable which nulls out references to the upstream producer and downstream Subscriber if
     * the sequence is terminated or downstream cancels
     * @since 2.0
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;T&gt; onTerminateDetach() {
<span class="fc" id="L12205">        return RxJavaPlugins.onAssembly(new FlowableDetach&lt;T&gt;(this));</span>
    }

    /**
     * Parallelizes the flow by creating multiple 'rails' (equal to the number of CPUs)
     * and dispatches the upstream items to them in a round-robin fashion.
     * &lt;p&gt;
     * Note that the rails don't execute in parallel on their own and one needs to
     * apply {@link ParallelFlowable#runOn(Scheduler)} to specify the Scheduler where
     * each rail will execute.
     * &lt;p&gt;
     * To merge the parallel 'rails' back into a single sequence, use {@link ParallelFlowable#sequential()}.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;547&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flowable.parallel.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator requires the upstream to honor backpressure and each 'rail' honors backpressure
     *  as well.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code parallel} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * &lt;p&gt;History: 2.0.5 - experimental; 2.1 - beta
     * @return the new ParallelFlowable instance
     * @since 2.2
     */
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    @CheckReturnValue
    public final ParallelFlowable&lt;T&gt; parallel() {
<span class="fc" id="L12234">        return ParallelFlowable.from(this);</span>
    }

    /**
     * Parallelizes the flow by creating the specified number of 'rails'
     * and dispatches the upstream items to them in a round-robin fashion.
     * &lt;p&gt;
     * Note that the rails don't execute in parallel on their own and one needs to
     * apply {@link ParallelFlowable#runOn(Scheduler)} to specify the Scheduler where
     * each rail will execute.
     * &lt;p&gt;
     * To merge the parallel 'rails' back into a single sequence, use {@link ParallelFlowable#sequential()}.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;547&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flowable.parallel.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator requires the upstream to honor backpressure and each 'rail' honors backpressure
     *  as well.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code parallel} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * &lt;p&gt;History: 2.0.5 - experimental; 2.1 - beta
     * @param parallelism the number of 'rails' to use
     * @return the new ParallelFlowable instance
     * @since 2.2
     */
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    @CheckReturnValue
    public final ParallelFlowable&lt;T&gt; parallel(int parallelism) {
<span class="fc" id="L12264">        ObjectHelper.verifyPositive(parallelism, &quot;parallelism&quot;);</span>
<span class="fc" id="L12265">        return ParallelFlowable.from(this, parallelism);</span>
    }

    /**
     * Parallelizes the flow by creating the specified number of 'rails'
     * and dispatches the upstream items to them in a round-robin fashion and
     * uses the defined per-'rail' prefetch amount.
     * &lt;p&gt;
     * Note that the rails don't execute in parallel on their own and one needs to
     * apply {@link ParallelFlowable#runOn(Scheduler)} to specify the Scheduler where
     * each rail will execute.
     * &lt;p&gt;
     * To merge the parallel 'rails' back into a single sequence, use {@link ParallelFlowable#sequential()}.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;547&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flowable.parallel.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator requires the upstream to honor backpressure and each 'rail' honors backpressure
     *  as well.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code parallel} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * &lt;p&gt;History: 2.0.5 - experimental; 2.1 - beta
     * @param parallelism the number of 'rails' to use
     * @param prefetch the number of items each 'rail' should prefetch
     * @return the new ParallelFlowable instance
     * @since 2.2
     */
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    @CheckReturnValue
    public final ParallelFlowable&lt;T&gt; parallel(int parallelism, int prefetch) {
<span class="fc" id="L12297">        ObjectHelper.verifyPositive(parallelism, &quot;parallelism&quot;);</span>
<span class="fc" id="L12298">        ObjectHelper.verifyPositive(prefetch, &quot;prefetch&quot;);</span>
<span class="fc" id="L12299">        return ParallelFlowable.from(this, parallelism, prefetch);</span>
    }

    /**
     * Returns a {@link ConnectableFlowable}, which is a variety of Publisher that waits until its
     * {@link ConnectableFlowable#connect connect} method is called before it begins emitting items to those
     * {@link Subscriber}s that have subscribed to it.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;510&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/publishConnect.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The returned {@code ConnectableFlowable} honors backpressure for each of its {@code Subscriber}s
     *  and expects the source {@code Publisher} to honor backpressure as well. If this expectation is violated,
     *  the operator will signal a {@code MissingBackpressureException} to its {@code Subscriber}s and disconnect.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code publish} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @return a {@link ConnectableFlowable} that upon connection causes the source Publisher to emit items
     *         to its {@link Subscriber}s
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/publish.html&quot;&gt;ReactiveX operators documentation: Publish&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final ConnectableFlowable&lt;T&gt; publish() {
<span class="fc" id="L12325">        return publish(bufferSize());</span>
    }

    /**
     * Returns a Flowable that emits the results of invoking a specified selector on items emitted by a
     * {@link ConnectableFlowable} that shares a single subscription to the underlying sequence.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;510&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/publishConnect.f.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator expects the source {@code Publisher} to honor backpressure and if this expectation is
     *  violated, the operator will signal a {@code MissingBackpressureException} through the {@code Publisher}
     *  provided to the function. Since the {@code Publisher} returned by the {@code selector} may be
     *  independent of the provided {@code Publisher} to the function, the output's backpressure behavior
     *  is determined by this returned {@code Publisher}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code publish} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;R&gt;
     *            the type of items emitted by the resulting Publisher
     * @param selector
     *            a function that can use the multicasted source sequence as many times as needed, without
     *            causing multiple subscriptions to the source sequence. Subscribers to the given source will
     *            receive all notifications of the source from the time of the subscription forward.
     * @return a Flowable that emits the results of invoking the selector on the items emitted by a {@link ConnectableFlowable} that shares a single subscription to the underlying sequence
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/publish.html&quot;&gt;ReactiveX operators documentation: Publish&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;R&gt; Flowable&lt;R&gt; publish(Function&lt;? super Flowable&lt;T&gt;, ? extends Publisher&lt;R&gt;&gt; selector) {
<span class="fc" id="L12357">        return publish(selector, bufferSize());</span>
    }

    /**
     * Returns a Flowable that emits the results of invoking a specified selector on items emitted by a
     * {@link ConnectableFlowable} that shares a single subscription to the underlying sequence.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;510&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/publishConnect.f.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator expects the source {@code Publisher} to honor backpressure and if this expectation is
     *  violated, the operator will signal a {@code MissingBackpressureException} through the {@code Publisher}
     *  provided to the function. Since the {@code Publisher} returned by the {@code selector} may be
     *  independent of the provided {@code Publisher} to the function, the output's backpressure behavior
     *  is determined by this returned {@code Publisher}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code publish} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;R&gt;
     *            the type of items emitted by the resulting Publisher
     * @param selector
     *            a function that can use the multicasted source sequence as many times as needed, without
     *            causing multiple subscriptions to the source sequence. Subscribers to the given source will
     *            receive all notifications of the source from the time of the subscription forward.
     * @param prefetch
     *            the number of elements to prefetch from the current Flowable
     * @return a Flowable that emits the results of invoking the selector on the items emitted by a {@link ConnectableFlowable} that shares a single subscription to the underlying sequence
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/publish.html&quot;&gt;ReactiveX operators documentation: Publish&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;R&gt; Flowable&lt;R&gt; publish(Function&lt;? super Flowable&lt;T&gt;, ? extends Publisher&lt;? extends R&gt;&gt; selector, int prefetch) {
<span class="fc" id="L12392">        ObjectHelper.requireNonNull(selector, &quot;selector is null&quot;);</span>
<span class="fc" id="L12393">        ObjectHelper.verifyPositive(prefetch, &quot;prefetch&quot;);</span>
<span class="fc" id="L12394">        return RxJavaPlugins.onAssembly(new FlowablePublishMulticast&lt;T, R&gt;(this, selector, prefetch, false));</span>
    }

    /**
     * Returns a {@link ConnectableFlowable}, which is a variety of Publisher that waits until its
     * {@link ConnectableFlowable#connect connect} method is called before it begins emitting items to those
     * {@link Subscriber}s that have subscribed to it.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;510&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/publishConnect.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The returned {@code ConnectableFlowable} honors backpressure for each of its {@code Subscriber}s
     *  and expects the source {@code Publisher} to honor backpressure as well. If this expectation is violated,
     *  the operator will signal a {@code MissingBackpressureException} to its {@code Subscriber}s and disconnect.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code publish} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param bufferSize
     *            the number of elements to prefetch from the current Flowable
     * @return a {@link ConnectableFlowable} that upon connection causes the source Publisher to emit items
     *         to its {@link Subscriber}s
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/publish.html&quot;&gt;ReactiveX operators documentation: Publish&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final ConnectableFlowable&lt;T&gt; publish(int bufferSize) {
<span class="fc" id="L12422">        ObjectHelper.verifyPositive(bufferSize, &quot;bufferSize&quot;);</span>
<span class="fc" id="L12423">        return FlowablePublish.create(this, bufferSize);</span>
    }

    /**
     * Requests {@code n} initially from the upstream and then 75% of {@code n} subsequently
     * after 75% of {@code n} values have been emitted to the downstream.
     *
     * &lt;p&gt;This operator allows preventing the downstream to trigger unbounded mode via {@code request(Long.MAX_VALUE)}
     * or compensate for the per-item overhead of small and frequent requests.
     *
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator expects backpressure from upstream and honors backpressure from downstream.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code rebatchRequests} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param n the initial request amount, further request will happen after 75% of this value
     * @return the Publisher that rebatches request amounts from downstream
     * @since 2.0
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;T&gt; rebatchRequests(int n) {
<span class="fc" id="L12448">        return observeOn(ImmediateThinScheduler.INSTANCE, true, n);</span>
    }

    /**
     * Returns a Maybe that applies a specified accumulator function to the first item emitted by a source
     * Publisher, then feeds the result of that function along with the second item emitted by the source
     * Publisher into the same function, and so on until all items have been emitted by the finite source Publisher,
     * and emits the final result from the final call to your function as its sole item.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;320&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/reduce.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * This technique, which is called &quot;reduce&quot; here, is sometimes called &quot;aggregate,&quot; &quot;fold,&quot; &quot;accumulate,&quot;
     * &quot;compress,&quot; or &quot;inject&quot; in other programming contexts. Groovy, for instance, has an {@code inject} method
     * that does a similar operation on lists.
     * &lt;p&gt;
     * Note that this operator requires the upstream to signal {@code onComplete} for the accumulator object to
     * be emitted. Sources that are infinite and never complete will never emit anything through this
     * operator and an infinite source may lead to a fatal {@code OutOfMemoryError}.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure of its downstream consumer and consumes the
     *  upstream source in unbounded mode.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code reduce} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param reducer
     *            an accumulator function to be invoked on each item emitted by the source Publisher, whose
     *            result will be used in the next accumulator call
     * @return a Maybe that emits a single item that is the result of accumulating the items emitted by
     *         the source Flowable
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/reduce.html&quot;&gt;ReactiveX operators documentation: Reduce&lt;/a&gt;
     * @see &lt;a href=&quot;http://en.wikipedia.org/wiki/Fold_(higher-order_function)&quot;&gt;Wikipedia: Fold (higher-order function)&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Maybe&lt;T&gt; reduce(BiFunction&lt;T, T, T&gt; reducer) {
<span class="fc" id="L12487">        ObjectHelper.requireNonNull(reducer, &quot;reducer is null&quot;);</span>
<span class="fc" id="L12488">        return RxJavaPlugins.onAssembly(new FlowableReduceMaybe&lt;T&gt;(this, reducer));</span>
    }

    /**
     * Returns a Single that applies a specified accumulator function to the first item emitted by a source
     * Publisher and a specified seed value, then feeds the result of that function along with the second item
     * emitted by a Publisher into the same function, and so on until all items have been emitted by the
     * finite source Publisher, emitting the final result from the final call to your function as its sole item.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;325&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/reduceSeed.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * This technique, which is called &quot;reduce&quot; here, is sometimes called &quot;aggregate,&quot; &quot;fold,&quot; &quot;accumulate,&quot;
     * &quot;compress,&quot; or &quot;inject&quot; in other programming contexts. Groovy, for instance, has an {@code inject} method
     * that does a similar operation on lists.
     * &lt;p&gt;
     * Note that the {@code seed} is shared among all subscribers to the resulting Publisher
     * and may cause problems if it is mutable. To make sure each subscriber gets its own value, defer
     * the application of this operator via {@link #defer(Callable)}:
     * &lt;pre&gt;&lt;code&gt;
     * Publisher&amp;lt;T&amp;gt; source = ...
     * Single.defer(() -&amp;gt; source.reduce(new ArrayList&amp;lt;&amp;gt;(), (list, item) -&amp;gt; list.add(item)));
     *
     * // alternatively, by using compose to stay fluent
     *
     * source.compose(o -&amp;gt;
     *     Flowable.defer(() -&amp;gt; o.reduce(new ArrayList&amp;lt;&amp;gt;(), (list, item) -&amp;gt; list.add(item)).toFlowable())
     * ).firstOrError();
     *
     * // or, by using reduceWith instead of reduce
     *
     * source.reduceWith(() -&amp;gt; new ArrayList&amp;lt;&amp;gt;(), (list, item) -&amp;gt; list.add(item)));
     * &lt;/code&gt;&lt;/pre&gt;
     * &lt;p&gt;
     * Note that this operator requires the upstream to signal {@code onComplete} for the accumulator object to
     * be emitted. Sources that are infinite and never complete will never emit anything through this
     * operator and an infinite source may lead to a fatal {@code OutOfMemoryError}.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure of its downstream consumer and consumes the
     *  upstream source in unbounded mode.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code reduce} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;R&gt; the accumulator and output value type
     * @param seed
     *            the initial (seed) accumulator value
     * @param reducer
     *            an accumulator function to be invoked on each item emitted by the source Publisher, the
     *            result of which will be used in the next accumulator call
     * @return a Single that emits a single item that is the result of accumulating the output from the
     *         items emitted by the source Publisher
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/reduce.html&quot;&gt;ReactiveX operators documentation: Reduce&lt;/a&gt;
     * @see &lt;a href=&quot;http://en.wikipedia.org/wiki/Fold_(higher-order_function)&quot;&gt;Wikipedia: Fold (higher-order function)&lt;/a&gt;
     * @see #reduceWith(Callable, BiFunction)
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;R&gt; Single&lt;R&gt; reduce(R seed, BiFunction&lt;R, ? super T, R&gt; reducer) {
<span class="fc" id="L12549">        ObjectHelper.requireNonNull(seed, &quot;seed is null&quot;);</span>
<span class="fc" id="L12550">        ObjectHelper.requireNonNull(reducer, &quot;reducer is null&quot;);</span>
<span class="fc" id="L12551">        return RxJavaPlugins.onAssembly(new FlowableReduceSeedSingle&lt;T, R&gt;(this, seed, reducer));</span>
    }

    /**
     * Returns a Single that applies a specified accumulator function to the first item emitted by a source
     * Publisher and a seed value derived from calling a specified seedSupplier, then feeds the result
     * of that function along with the second item emitted by a Publisher into the same function, and so on until
     * all items have been emitted by the finite source Publisher, emitting the final result from the final call to your
     * function as its sole item.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;325&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/reduceSeed.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * This technique, which is called &quot;reduce&quot; here, is sometimes called &quot;aggregate,&quot; &quot;fold,&quot; &quot;accumulate,&quot;
     * &quot;compress,&quot; or &quot;inject&quot; in other programming contexts. Groovy, for instance, has an {@code inject} method
     * that does a similar operation on lists.
     * &lt;p&gt;
     * Note that this operator requires the upstream to signal {@code onComplete} for the accumulator object to
     * be emitted. Sources that are infinite and never complete will never emit anything through this
     * operator and an infinite source may lead to a fatal {@code OutOfMemoryError}.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure of its downstream consumer and consumes the
     *  upstream source in unbounded mode.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code reduceWith} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;R&gt; the accumulator and output value type
     * @param seedSupplier
     *            the Callable that provides the initial (seed) accumulator value for each individual Subscriber
     * @param reducer
     *            an accumulator function to be invoked on each item emitted by the source Publisher, the
     *            result of which will be used in the next accumulator call
     * @return a Single that emits a single item that is the result of accumulating the output from the
     *         items emitted by the source Publisher
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/reduce.html&quot;&gt;ReactiveX operators documentation: Reduce&lt;/a&gt;
     * @see &lt;a href=&quot;http://en.wikipedia.org/wiki/Fold_(higher-order_function)&quot;&gt;Wikipedia: Fold (higher-order function)&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;R&gt; Single&lt;R&gt; reduceWith(Callable&lt;R&gt; seedSupplier, BiFunction&lt;R, ? super T, R&gt; reducer) {
<span class="fc" id="L12594">        ObjectHelper.requireNonNull(seedSupplier, &quot;seedSupplier is null&quot;);</span>
<span class="fc" id="L12595">        ObjectHelper.requireNonNull(reducer, &quot;reducer is null&quot;);</span>
<span class="fc" id="L12596">        return RxJavaPlugins.onAssembly(new FlowableReduceWithSingle&lt;T, R&gt;(this, seedSupplier, reducer));</span>
    }

    /**
     * Returns a Flowable that repeats the sequence of items emitted by the source Publisher indefinitely.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;309&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/repeat.o.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors downstream backpressure and expects the source {@code Publisher} to honor backpressure as well.
     *  If this expectation is violated, the operator &lt;em&gt;may&lt;/em&gt; throw an {@code IllegalStateException}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code repeat} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @return a Flowable that emits the items emitted by the source Publisher repeatedly and in sequence
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/repeat.html&quot;&gt;ReactiveX operators documentation: Repeat&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;T&gt; repeat() {
<span class="fc" id="L12618">        return repeat(Long.MAX_VALUE);</span>
    }

    /**
     * Returns a Flowable that repeats the sequence of items emitted by the source Publisher at most
     * {@code count} times.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/repeat.on.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors downstream backpressure and expects the source {@code Publisher} to honor backpressure as well.
     *  If this expectation is violated, the operator &lt;em&gt;may&lt;/em&gt; throw an {@code IllegalStateException}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code repeat} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param times
     *            the number of times the source Publisher items are repeated, a count of 0 will yield an empty
     *            sequence
     * @return a Flowable that repeats the sequence of items emitted by the source Publisher at most
     *         {@code count} times
     * @throws IllegalArgumentException
     *             if {@code count} is less than zero
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/repeat.html&quot;&gt;ReactiveX operators documentation: Repeat&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;T&gt; repeat(long times) {
<span class="fc bfc" id="L12647" title="All 2 branches covered.">        if (times &lt; 0) {</span>
<span class="fc" id="L12648">            throw new IllegalArgumentException(&quot;times &gt;= 0 required but it was &quot; + times);</span>
        }
<span class="fc bfc" id="L12650" title="All 2 branches covered.">        if (times == 0) {</span>
<span class="fc" id="L12651">            return empty();</span>
        }
<span class="fc" id="L12653">        return RxJavaPlugins.onAssembly(new FlowableRepeat&lt;T&gt;(this, times));</span>
    }

    /**
     * Returns a Flowable that repeats the sequence of items emitted by the source Publisher until
     * the provided stop function returns true.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/repeat.on.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors downstream backpressure and expects the source {@code Publisher} to honor backpressure as well.
     *  If this expectation is violated, the operator &lt;em&gt;may&lt;/em&gt; throw an {@code IllegalStateException}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code repeatUntil} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param stop
     *                a boolean supplier that is called when the current Flowable completes and unless it returns
     *                false, the current Flowable is resubscribed
     * @return the new Flowable instance
     * @throws NullPointerException
     *             if {@code stop} is null
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/repeat.html&quot;&gt;ReactiveX operators documentation: Repeat&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;T&gt; repeatUntil(BooleanSupplier stop) {
<span class="fc" id="L12682">        ObjectHelper.requireNonNull(stop, &quot;stop is null&quot;);</span>
<span class="fc" id="L12683">        return RxJavaPlugins.onAssembly(new FlowableRepeatUntil&lt;T&gt;(this, stop));</span>
    }

    /**
     * Returns a Flowable that emits the same values as the source Publisher with the exception of an
     * {@code onComplete}. An {@code onComplete} notification from the source will result in the emission of
     * a {@code void} item to the Publisher provided as an argument to the {@code notificationHandler}
     * function. If that Publisher calls {@code onComplete} or {@code onError} then {@code repeatWhen} will
     * call {@code onComplete} or {@code onError} on the child subscription. Otherwise, this Publisher will
     * resubscribe to the source Publisher.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;430&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/repeatWhen.f.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors downstream backpressure and expects the source {@code Publisher} to honor backpressure as well.
     *  If this expectation is violated, the operator &lt;em&gt;may&lt;/em&gt; throw an {@code IllegalStateException}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code repeatWhen} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param handler
     *            receives a Publisher of notifications with which a user can complete or error, aborting the repeat.
     * @return the source Publisher modified with repeat logic
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/repeat.html&quot;&gt;ReactiveX operators documentation: Repeat&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;T&gt; repeatWhen(final Function&lt;? super Flowable&lt;Object&gt;, ? extends Publisher&lt;?&gt;&gt; handler) {
<span class="fc" id="L12713">        ObjectHelper.requireNonNull(handler, &quot;handler is null&quot;);</span>
<span class="fc" id="L12714">        return RxJavaPlugins.onAssembly(new FlowableRepeatWhen&lt;T&gt;(this, handler));</span>
    }

    /**
     * Returns a {@link ConnectableFlowable} that shares a single subscription to the underlying Publisher
     * that will replay all of its items and notifications to any future {@link Subscriber}. A Connectable
     * Publisher resembles an ordinary Publisher, except that it does not begin emitting items when it is
     * subscribed to, but only when its {@code connect} method is called.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;515&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator supports backpressure. Note that the upstream requests are determined by the child
     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will
     *  request 100 elements from the underlying Publisher sequence.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code replay} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @return a {@link ConnectableFlowable} that upon connection causes the source Publisher to emit its
     *         items to its {@link Subscriber}s
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/replay.html&quot;&gt;ReactiveX operators documentation: Replay&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final ConnectableFlowable&lt;T&gt; replay() {
<span class="fc" id="L12741">        return FlowableReplay.createFrom(this);</span>
    }

    /**
     * Returns a Flowable that emits items that are the results of invoking a specified selector on the items
     * emitted by a {@link ConnectableFlowable} that shares a single subscription to the source Publisher.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;450&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.f.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator supports backpressure. Note that the upstream requests are determined by the child
     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will
     *  request 100 elements from the underlying Publisher sequence.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code replay} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;R&gt;
     *            the type of items emitted by the resulting Publisher
     * @param selector
     *            the selector function, which can use the multicasted sequence as many times as needed, without
     *            causing multiple subscriptions to the Publisher
     * @return a Flowable that emits items that are the results of invoking the selector on a
     *         {@link ConnectableFlowable} that shares a single subscription to the source Publisher
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/replay.html&quot;&gt;ReactiveX operators documentation: Replay&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;R&gt; Flowable&lt;R&gt; replay(Function&lt;? super Flowable&lt;T&gt;, ? extends Publisher&lt;R&gt;&gt; selector) {
<span class="fc" id="L12772">        ObjectHelper.requireNonNull(selector, &quot;selector is null&quot;);</span>
<span class="fc" id="L12773">        return FlowableReplay.multicastSelector(FlowableInternalHelper.replayCallable(this), selector);</span>
    }

    /**
     * Returns a Flowable that emits items that are the results of invoking a specified selector on items
     * emitted by a {@link ConnectableFlowable} that shares a single subscription to the source Publisher,
     * replaying {@code bufferSize} notifications.
     * &lt;p&gt;
     * Note that due to concurrency requirements, {@code replay(bufferSize)} may hold strong references to more than
     * {@code bufferSize} source emissions.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;440&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.fn.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator supports backpressure. Note that the upstream requests are determined by the child
     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will
     *  request 100 elements from the underlying Publisher sequence.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code replay} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;R&gt;
     *            the type of items emitted by the resulting Publisher
     * @param selector
     *            the selector function, which can use the multicasted sequence as many times as needed, without
     *            causing multiple subscriptions to the Publisher
     * @param bufferSize
     *            the buffer size that limits the number of items the connectable Publisher can replay
     * @return a Flowable that emits items that are the results of invoking the selector on items emitted by
     *         a {@link ConnectableFlowable} that shares a single subscription to the source Publisher
     *         replaying no more than {@code bufferSize} items
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/replay.html&quot;&gt;ReactiveX operators documentation: Replay&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;R&gt; Flowable&lt;R&gt; replay(Function&lt;? super Flowable&lt;T&gt;, ? extends Publisher&lt;R&gt;&gt; selector, final int bufferSize) {
<span class="fc" id="L12811">        ObjectHelper.requireNonNull(selector, &quot;selector is null&quot;);</span>
<span class="fc" id="L12812">        ObjectHelper.verifyPositive(bufferSize, &quot;bufferSize&quot;);</span>
<span class="fc" id="L12813">        return FlowableReplay.multicastSelector(FlowableInternalHelper.replayCallable(this, bufferSize), selector);</span>
    }

    /**
     * Returns a Flowable that emits items that are the results of invoking a specified selector on items
     * emitted by a {@link ConnectableFlowable} that shares a single subscription to the source Publisher,
     * replaying no more than {@code bufferSize} items that were emitted within a specified time window.
     * &lt;p&gt;
     * Note that due to concurrency requirements, {@code replay(bufferSize)} may hold strong references to more than
     * {@code bufferSize} source emissions.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;445&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.fnt.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator supports backpressure. Note that the upstream requests are determined by the child
     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will
     *  request 100 elements from the underlying Publisher sequence.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code replay} operates by default on the {@code computation} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;R&gt;
     *            the type of items emitted by the resulting Publisher
     * @param selector
     *            a selector function, which can use the multicasted sequence as many times as needed, without
     *            causing multiple subscriptions to the Publisher
     * @param bufferSize
     *            the buffer size that limits the number of items the connectable Publisher can replay
     * @param time
     *            the duration of the window in which the replayed items must have been emitted
     * @param unit
     *            the time unit of {@code time}
     * @return a Flowable that emits items that are the results of invoking the selector on items emitted by
     *         a {@link ConnectableFlowable} that shares a single subscription to the source Publisher, and
     *         replays no more than {@code bufferSize} items that were emitted within the window defined by
     *         {@code time}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/replay.html&quot;&gt;ReactiveX operators documentation: Replay&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.COMPUTATION)
    public final &lt;R&gt; Flowable&lt;R&gt; replay(Function&lt;? super Flowable&lt;T&gt;, ? extends Publisher&lt;R&gt;&gt; selector, int bufferSize, long time, TimeUnit unit) {
<span class="fc" id="L12855">        return replay(selector, bufferSize, time, unit, Schedulers.computation());</span>
    }

    /**
     * Returns a Flowable that emits items that are the results of invoking a specified selector on items
     * emitted by a {@link ConnectableFlowable} that shares a single subscription to the source Publisher,
     * replaying no more than {@code bufferSize} items that were emitted within a specified time window.
     * &lt;p&gt;
     * Note that due to concurrency requirements, {@code replay(bufferSize)} may hold strong references to more than
     * {@code bufferSize} source emissions.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;445&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.fnts.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator supports backpressure. Note that the upstream requests are determined by the child
     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will
     *  request 100 elements from the underlying Publisher sequence.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;You specify which {@link Scheduler} this operator will use.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;R&gt;
     *            the type of items emitted by the resulting Publisher
     * @param selector
     *            a selector function, which can use the multicasted sequence as many times as needed, without
     *            causing multiple subscriptions to the Publisher
     * @param bufferSize
     *            the buffer size that limits the number of items the connectable Publisher can replay
     * @param time
     *            the duration of the window in which the replayed items must have been emitted
     * @param unit
     *            the time unit of {@code time}
     * @param scheduler
     *            the Scheduler that is the time source for the window
     * @return a Flowable that emits items that are the results of invoking the selector on items emitted by
     *         a {@link ConnectableFlowable} that shares a single subscription to the source Publisher, and
     *         replays no more than {@code bufferSize} items that were emitted within the window defined by
     *         {@code time}
     * @throws IllegalArgumentException
     *             if {@code bufferSize} is less than zero
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/replay.html&quot;&gt;ReactiveX operators documentation: Replay&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final &lt;R&gt; Flowable&lt;R&gt; replay(Function&lt;? super Flowable&lt;T&gt;, ? extends Publisher&lt;R&gt;&gt; selector, final int bufferSize, final long time, final TimeUnit unit, final Scheduler scheduler) {
<span class="fc" id="L12902">        ObjectHelper.requireNonNull(selector, &quot;selector is null&quot;);</span>
<span class="fc" id="L12903">        ObjectHelper.requireNonNull(unit, &quot;unit is null&quot;);</span>
<span class="fc" id="L12904">        ObjectHelper.verifyPositive(bufferSize, &quot;bufferSize&quot;);</span>
<span class="fc" id="L12905">        ObjectHelper.requireNonNull(scheduler, &quot;scheduler is null&quot;);</span>
<span class="fc" id="L12906">        return FlowableReplay.multicastSelector(</span>
<span class="fc" id="L12907">                FlowableInternalHelper.replayCallable(this, bufferSize, time, unit, scheduler), selector);</span>
    }

    /**
     * Returns a Flowable that emits items that are the results of invoking a specified selector on items
     * emitted by a {@link ConnectableFlowable} that shares a single subscription to the source Publisher,
     * replaying a maximum of {@code bufferSize} items.
     * &lt;p&gt;
     * Note that due to concurrency requirements, {@code replay(bufferSize)} may hold strong references to more than
     * {@code bufferSize} source emissions.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;440&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.fns.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator supports backpressure. Note that the upstream requests are determined by the child
     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will
     *  request 100 elements from the underlying Publisher sequence.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;You specify which {@link Scheduler} this operator will use.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;R&gt;
     *            the type of items emitted by the resulting Publisher
     * @param selector
     *            a selector function, which can use the multicasted sequence as many times as needed, without
     *            causing multiple subscriptions to the Publisher
     * @param bufferSize
     *            the buffer size that limits the number of items the connectable Publisher can replay
     * @param scheduler
     *            the Scheduler on which the replay is observed
     * @return a Flowable that emits items that are the results of invoking the selector on items emitted by
     *         a {@link ConnectableFlowable} that shares a single subscription to the source Publisher,
     *         replaying no more than {@code bufferSize} notifications
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/replay.html&quot;&gt;ReactiveX operators documentation: Replay&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final &lt;R&gt; Flowable&lt;R&gt; replay(final Function&lt;? super Flowable&lt;T&gt;, ? extends Publisher&lt;R&gt;&gt; selector, final int bufferSize, final Scheduler scheduler) {
<span class="fc" id="L12947">        ObjectHelper.requireNonNull(selector, &quot;selector is null&quot;);</span>
<span class="fc" id="L12948">        ObjectHelper.requireNonNull(scheduler, &quot;scheduler is null&quot;);</span>
<span class="fc" id="L12949">        ObjectHelper.verifyPositive(bufferSize, &quot;bufferSize&quot;);</span>
<span class="fc" id="L12950">        return FlowableReplay.multicastSelector(FlowableInternalHelper.replayCallable(this, bufferSize),</span>
<span class="fc" id="L12951">                FlowableInternalHelper.replayFunction(selector, scheduler)</span>
        );
    }

    /**
     * Returns a Flowable that emits items that are the results of invoking a specified selector on items
     * emitted by a {@link ConnectableFlowable} that shares a single subscription to the source Publisher,
     * replaying all items that were emitted within a specified time window.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;435&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.ft.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator supports backpressure. Note that the upstream requests are determined by the child
     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will
     *  request 100 elements from the underlying Publisher sequence.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code replay} operates by default on the {@code computation} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;R&gt;
     *            the type of items emitted by the resulting Publisher
     * @param selector
     *            a selector function, which can use the multicasted sequence as many times as needed, without
     *            causing multiple subscriptions to the Publisher
     * @param time
     *            the duration of the window in which the replayed items must have been emitted
     * @param unit
     *            the time unit of {@code time}
     * @return a Flowable that emits items that are the results of invoking the selector on items emitted by
     *         a {@link ConnectableFlowable} that shares a single subscription to the source Publisher,
     *         replaying all items that were emitted within the window defined by {@code time}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/replay.html&quot;&gt;ReactiveX operators documentation: Replay&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.COMPUTATION)
    public final &lt;R&gt; Flowable&lt;R&gt; replay(Function&lt;? super Flowable&lt;T&gt;, ? extends Publisher&lt;R&gt;&gt; selector, long time, TimeUnit unit) {
<span class="fc" id="L12988">        return replay(selector, time, unit, Schedulers.computation());</span>
    }

    /**
     * Returns a Flowable that emits items that are the results of invoking a specified selector on items
     * emitted by a {@link ConnectableFlowable} that shares a single subscription to the source Publisher,
     * replaying all items that were emitted within a specified time window.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;440&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.fts.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator supports backpressure. Note that the upstream requests are determined by the child
     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will
     *  request 100 elements from the underlying Publisher sequence.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;You specify which {@link Scheduler} this operator will use.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;R&gt;
     *            the type of items emitted by the resulting Publisher
     * @param selector
     *            a selector function, which can use the multicasted sequence as many times as needed, without
     *            causing multiple subscriptions to the Publisher
     * @param time
     *            the duration of the window in which the replayed items must have been emitted
     * @param unit
     *            the time unit of {@code time}
     * @param scheduler
     *            the scheduler that is the time source for the window
     * @return a Flowable that emits items that are the results of invoking the selector on items emitted by
     *         a {@link ConnectableFlowable} that shares a single subscription to the source Publisher,
     *         replaying all items that were emitted within the window defined by {@code time}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/replay.html&quot;&gt;ReactiveX operators documentation: Replay&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final &lt;R&gt; Flowable&lt;R&gt; replay(Function&lt;? super Flowable&lt;T&gt;, ? extends Publisher&lt;R&gt;&gt; selector, final long time, final TimeUnit unit, final Scheduler scheduler) {
<span class="fc" id="L13027">        ObjectHelper.requireNonNull(selector, &quot;selector is null&quot;);</span>
<span class="fc" id="L13028">        ObjectHelper.requireNonNull(unit, &quot;unit is null&quot;);</span>
<span class="fc" id="L13029">        ObjectHelper.requireNonNull(scheduler, &quot;scheduler is null&quot;);</span>
<span class="fc" id="L13030">        return FlowableReplay.multicastSelector(FlowableInternalHelper.replayCallable(this, time, unit, scheduler), selector);</span>
    }

    /**
     * Returns a Flowable that emits items that are the results of invoking a specified selector on items
     * emitted by a {@link ConnectableFlowable} that shares a single subscription to the source Publisher.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;445&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.fs.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator supports backpressure. Note that the upstream requests are determined by the child
     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will
     *  request 100 elements from the underlying Publisher sequence.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;You specify which {@link Scheduler} this operator will use.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;R&gt;
     *            the type of items emitted by the resulting Publisher
     * @param selector
     *            a selector function, which can use the multicasted sequence as many times as needed, without
     *            causing multiple subscriptions to the Publisher
     * @param scheduler
     *            the Scheduler where the replay is observed
     * @return a Flowable that emits items that are the results of invoking the selector on items emitted by
     *         a {@link ConnectableFlowable} that shares a single subscription to the source Publisher,
     *         replaying all items
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/replay.html&quot;&gt;ReactiveX operators documentation: Replay&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final &lt;R&gt; Flowable&lt;R&gt; replay(final Function&lt;? super Flowable&lt;T&gt;, ? extends Publisher&lt;R&gt;&gt; selector, final Scheduler scheduler) {
<span class="fc" id="L13064">        ObjectHelper.requireNonNull(selector, &quot;selector is null&quot;);</span>
<span class="fc" id="L13065">        ObjectHelper.requireNonNull(scheduler, &quot;scheduler is null&quot;);</span>
<span class="fc" id="L13066">        return FlowableReplay.multicastSelector(FlowableInternalHelper.replayCallable(this),</span>
<span class="fc" id="L13067">                FlowableInternalHelper.replayFunction(selector, scheduler));</span>
    }

    /**
     * Returns a {@link ConnectableFlowable} that shares a single subscription to the source Publisher that
     * replays at most {@code bufferSize} items emitted by that Publisher. A Connectable Publisher resembles
     * an ordinary Publisher, except that it does not begin emitting items when it is subscribed to, but only
     * when its {@code connect} method is called.
     * &lt;p&gt;
     * Note that due to concurrency requirements, {@code replay(bufferSize)} may hold strong references to more than
     * {@code bufferSize} source emissions.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;515&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.n.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator supports backpressure. Note that the upstream requests are determined by the child
     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will
     *  request 100 elements from the underlying Publisher sequence.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code replay} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param bufferSize
     *            the buffer size that limits the number of items that can be replayed
     * @return a {@link ConnectableFlowable} that shares a single subscription to the source Publisher and
     *         replays at most {@code bufferSize} items emitted by that Publisher
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/replay.html&quot;&gt;ReactiveX operators documentation: Replay&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final ConnectableFlowable&lt;T&gt; replay(final int bufferSize) {
<span class="fc" id="L13099">        ObjectHelper.verifyPositive(bufferSize, &quot;bufferSize&quot;);</span>
<span class="fc" id="L13100">        return FlowableReplay.create(this, bufferSize);</span>
    }

    /**
     * Returns a {@link ConnectableFlowable} that shares a single subscription to the source Publisher and
     * replays at most {@code bufferSize} items that were emitted during a specified time window. A Connectable
     * Publisher resembles an ordinary Publisher, except that it does not begin emitting items when it is
     * subscribed to, but only when its {@code connect} method is called.
     * &lt;p&gt;
     * Note that due to concurrency requirements, {@code replay(bufferSize)} may hold strong references to more than
     * {@code bufferSize} source emissions.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;515&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.nt.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator supports backpressure. Note that the upstream requests are determined by the child
     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will
     *  request 100 elements from the underlying Publisher sequence.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code replay} operates by default on the {@code computation} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param bufferSize
     *            the buffer size that limits the number of items that can be replayed
     * @param time
     *            the duration of the window in which the replayed items must have been emitted
     * @param unit
     *            the time unit of {@code time}
     * @return a {@link ConnectableFlowable} that shares a single subscription to the source Publisher and
     *         replays at most {@code bufferSize} items that were emitted during the window defined by
     *         {@code time}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/replay.html&quot;&gt;ReactiveX operators documentation: Replay&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.COMPUTATION)
    public final ConnectableFlowable&lt;T&gt; replay(int bufferSize, long time, TimeUnit unit) {
<span class="fc" id="L13137">        return replay(bufferSize, time, unit, Schedulers.computation());</span>
    }

    /**
     * Returns a {@link ConnectableFlowable} that shares a single subscription to the source Publisher and
     * that replays a maximum of {@code bufferSize} items that are emitted within a specified time window. A
     * Connectable Publisher resembles an ordinary Publisher, except that it does not begin emitting items
     * when it is subscribed to, but only when its {@code connect} method is called.
     * &lt;p&gt;
     * Note that due to concurrency requirements, {@code replay(bufferSize)} may hold strong references to more than
     * {@code bufferSize} source emissions.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;515&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.nts.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator supports backpressure. Note that the upstream requests are determined by the child
     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will
     *  request 100 elements from the underlying Publisher sequence.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;You specify which {@link Scheduler} this operator will use.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param bufferSize
     *            the buffer size that limits the number of items that can be replayed
     * @param time
     *            the duration of the window in which the replayed items must have been emitted
     * @param unit
     *            the time unit of {@code time}
     * @param scheduler
     *            the scheduler that is used as a time source for the window
     * @return a {@link ConnectableFlowable} that shares a single subscription to the source Publisher and
     *         replays at most {@code bufferSize} items that were emitted during the window defined by
     *         {@code time}
     * @throws IllegalArgumentException
     *             if {@code bufferSize} is less than zero
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/replay.html&quot;&gt;ReactiveX operators documentation: Replay&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final ConnectableFlowable&lt;T&gt; replay(final int bufferSize, final long time, final TimeUnit unit, final Scheduler scheduler) {
<span class="fc" id="L13178">        ObjectHelper.verifyPositive(bufferSize, &quot;bufferSize&quot;);</span>
<span class="fc" id="L13179">        ObjectHelper.requireNonNull(unit, &quot;unit is null&quot;);</span>
<span class="fc" id="L13180">        ObjectHelper.requireNonNull(scheduler, &quot;scheduler is null&quot;);</span>
<span class="fc" id="L13181">        ObjectHelper.verifyPositive(bufferSize, &quot;bufferSize&quot;);</span>
<span class="fc" id="L13182">        return FlowableReplay.create(this, time, unit, scheduler, bufferSize);</span>
    }

    /**
     * Returns a {@link ConnectableFlowable} that shares a single subscription to the source Publisher and
     * replays at most {@code bufferSize} items emitted by that Publisher. A Connectable Publisher resembles
     * an ordinary Publisher, except that it does not begin emitting items when it is subscribed to, but only
     * when its {@code connect} method is called.
     * &lt;p&gt;
     * Note that due to concurrency requirements, {@code replay(bufferSize)} may hold strong references to more than
     * {@code bufferSize} source emissions.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;515&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.ns.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator supports backpressure. Note that the upstream requests are determined by the child
     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will
     *  request 100 elements from the underlying Publisher sequence.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;You specify which {@link Scheduler} this operator will use.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param bufferSize
     *            the buffer size that limits the number of items that can be replayed
     * @param scheduler
     *            the scheduler on which the Subscribers will observe the emitted items
     * @return a {@link ConnectableFlowable} that shares a single subscription to the source Publisher and
     *         replays at most {@code bufferSize} items that were emitted by the Publisher
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/replay.html&quot;&gt;ReactiveX operators documentation: Replay&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final ConnectableFlowable&lt;T&gt; replay(final int bufferSize, final Scheduler scheduler) {
<span class="fc" id="L13216">        ObjectHelper.requireNonNull(scheduler, &quot;scheduler is null&quot;);</span>
<span class="fc" id="L13217">        return FlowableReplay.observeOn(replay(bufferSize), scheduler);</span>
    }

    /**
     * Returns a {@link ConnectableFlowable} that shares a single subscription to the source Publisher and
     * replays all items emitted by that Publisher within a specified time window. A Connectable Publisher
     * resembles an ordinary Publisher, except that it does not begin emitting items when it is subscribed to,
     * but only when its {@code connect} method is called.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;515&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.t.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator supports backpressure. Note that the upstream requests are determined by the child
     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will
     *  request 100 elements from the underlying Publisher sequence.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code replay} operates by default on the {@code computation} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param time
     *            the duration of the window in which the replayed items must have been emitted
     * @param unit
     *            the time unit of {@code time}
     * @return a {@link ConnectableFlowable} that shares a single subscription to the source Publisher and
     *         replays the items that were emitted during the window defined by {@code time}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/replay.html&quot;&gt;ReactiveX operators documentation: Replay&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.COMPUTATION)
    public final ConnectableFlowable&lt;T&gt; replay(long time, TimeUnit unit) {
<span class="fc" id="L13248">        return replay(time, unit, Schedulers.computation());</span>
    }

    /**
     * Returns a {@link ConnectableFlowable} that shares a single subscription to the source Publisher and
     * replays all items emitted by that Publisher within a specified time window. A Connectable Publisher
     * resembles an ordinary Publisher, except that it does not begin emitting items when it is subscribed to,
     * but only when its {@code connect} method is called.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;515&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.ts.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator supports backpressure. Note that the upstream requests are determined by the child
     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will
     *  request 100 elements from the underlying Publisher sequence.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;You specify which {@link Scheduler} this operator will use.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param time
     *            the duration of the window in which the replayed items must have been emitted
     * @param unit
     *            the time unit of {@code time}
     * @param scheduler
     *            the Scheduler that is the time source for the window
     * @return a {@link ConnectableFlowable} that shares a single subscription to the source Publisher and
     *         replays the items that were emitted during the window defined by {@code time}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/replay.html&quot;&gt;ReactiveX operators documentation: Replay&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final ConnectableFlowable&lt;T&gt; replay(final long time, final TimeUnit unit, final Scheduler scheduler) {
<span class="fc" id="L13281">        ObjectHelper.requireNonNull(unit, &quot;unit is null&quot;);</span>
<span class="fc" id="L13282">        ObjectHelper.requireNonNull(scheduler, &quot;scheduler is null&quot;);</span>
<span class="fc" id="L13283">        return FlowableReplay.create(this, time, unit, scheduler);</span>
    }

    /**
     * Returns a {@link ConnectableFlowable} that shares a single subscription to the source Publisher that
     * will replay all of its items and notifications to any future {@link Subscriber} on the given
     * {@link Scheduler}. A Connectable Publisher resembles an ordinary Publisher, except that it does not
     * begin emitting items when it is subscribed to, but only when its {@code connect} method is called.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;515&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.s.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator supports backpressure. Note that the upstream requests are determined by the child
     *  Subscriber which requests the largest amount: i.e., two child Subscribers with requests of 10 and 100 will
     *  request 100 elements from the underlying Publisher sequence.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;You specify which {@link Scheduler} this operator will use.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param scheduler
     *            the Scheduler on which the Subscribers will observe the emitted items
     * @return a {@link ConnectableFlowable} that shares a single subscription to the source Publisher that
     *         will replay all of its items and notifications to any future {@link Subscriber} on the given
     *         {@link Scheduler}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/replay.html&quot;&gt;ReactiveX operators documentation: Replay&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final ConnectableFlowable&lt;T&gt; replay(final Scheduler scheduler) {
<span class="fc" id="L13313">        ObjectHelper.requireNonNull(scheduler, &quot;scheduler is null&quot;);</span>
<span class="fc" id="L13314">        return FlowableReplay.observeOn(replay(), scheduler);</span>
    }

    /**
     * Returns a Flowable that mirrors the source Publisher, resubscribing to it if it calls {@code onError}
     * (infinite retry count).
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;315&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/retry.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * If the source Publisher calls {@link Subscriber#onError}, this method will resubscribe to the source
     * Publisher rather than propagating the {@code onError} call.
     * &lt;p&gt;
     * Any and all items emitted by the source Publisher will be emitted by the resulting Publisher, even
     * those emitted during failed subscriptions. For example, if a Publisher fails at first but emits
     * {@code [1, 2]} then succeeds the second time and emits {@code [1, 2, 3, 4, 5]} then the complete sequence
     * of emissions and notifications would be {@code [1, 2, 1, 2, 3, 4, 5, onComplete]}.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors downstream backpressure and expects the source {@code Publisher} to honor backpressure as well.
     *  If this expectation is violated, the operator &lt;em&gt;may&lt;/em&gt; throw an {@code IllegalStateException}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code retry} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @return the source Publisher modified with retry logic
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/retry.html&quot;&gt;ReactiveX operators documentation: Retry&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;T&gt; retry() {
<span class="fc" id="L13345">        return retry(Long.MAX_VALUE, Functions.alwaysTrue());</span>
    }

    /**
     * Returns a Flowable that mirrors the source Publisher, resubscribing to it if it calls {@code onError}
     * and the predicate returns true for that specific exception and retry count.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;315&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/retry.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors downstream backpressure and expects the source {@code Publisher} to honor backpressure as well.
     *  If this expectation is violated, the operator &lt;em&gt;may&lt;/em&gt; throw an {@code IllegalStateException}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code retry} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param predicate
     *            the predicate that determines if a resubscription may happen in case of a specific exception
     *            and retry count
     * @return the source Publisher modified with retry logic
     * @see #retry()
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/retry.html&quot;&gt;ReactiveX operators documentation: Retry&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;T&gt; retry(BiPredicate&lt;? super Integer, ? super Throwable&gt; predicate) {
<span class="fc" id="L13373">        ObjectHelper.requireNonNull(predicate, &quot;predicate is null&quot;);</span>

<span class="fc" id="L13375">        return RxJavaPlugins.onAssembly(new FlowableRetryBiPredicate&lt;T&gt;(this, predicate));</span>
    }

    /**
     * Returns a Flowable that mirrors the source Publisher, resubscribing to it if it calls {@code onError}
     * up to a specified number of retries.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;315&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/retry.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * If the source Publisher calls {@link Subscriber#onError}, this method will resubscribe to the source
     * Publisher for a maximum of {@code count} resubscriptions rather than propagating the
     * {@code onError} call.
     * &lt;p&gt;
     * Any and all items emitted by the source Publisher will be emitted by the resulting Publisher, even
     * those emitted during failed subscriptions. For example, if a Publisher fails at first but emits
     * {@code [1, 2]} then succeeds the second time and emits {@code [1, 2, 3, 4, 5]} then the complete sequence
     * of emissions and notifications would be {@code [1, 2, 1, 2, 3, 4, 5, onComplete]}.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors downstream backpressure and expects the source {@code Publisher} to honor backpressure as well.
     *  If this expectation is violated, the operator &lt;em&gt;may&lt;/em&gt; throw an {@code IllegalStateException}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code retry} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param count
     *            the number of times to resubscribe if the current Flowable fails
     * @return the source Publisher modified with retry logic
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/retry.html&quot;&gt;ReactiveX operators documentation: Retry&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;T&gt; retry(long count) {
<span class="fc" id="L13409">        return retry(count, Functions.alwaysTrue());</span>
    }

    /**
     * Retries at most times or until the predicate returns false, whichever happens first.
     *
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors downstream backpressure and expects the source {@code Publisher} to honor backpressure as well.
     *  If this expectation is violated, the operator &lt;em&gt;may&lt;/em&gt; throw an {@code IllegalStateException}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code retry} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param times the number of times to resubscribe if the current Flowable fails
     * @param predicate the predicate called with the failure Throwable and should return true to trigger a retry.
     * @return the new Flowable instance
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;T&gt; retry(long times, Predicate&lt;? super Throwable&gt; predicate) {
<span class="fc bfc" id="L13431" title="All 2 branches covered.">        if (times &lt; 0) {</span>
<span class="fc" id="L13432">            throw new IllegalArgumentException(&quot;times &gt;= 0 required but it was &quot; + times);</span>
        }
<span class="fc" id="L13434">        ObjectHelper.requireNonNull(predicate, &quot;predicate is null&quot;);</span>

<span class="fc" id="L13436">        return RxJavaPlugins.onAssembly(new FlowableRetryPredicate&lt;T&gt;(this, times, predicate));</span>
    }

    /**
     * Retries the current Flowable if the predicate returns true.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors downstream backpressure and expects the source {@code Publisher} to honor backpressure as well.
     *  If this expectation is violated, the operator &lt;em&gt;may&lt;/em&gt; throw an {@code IllegalStateException}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code retry} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param predicate the predicate that receives the failure Throwable and should return true to trigger a retry.
     * @return the new Flowable instance
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;T&gt; retry(Predicate&lt;? super Throwable&gt; predicate) {
<span class="fc" id="L13456">        return retry(Long.MAX_VALUE, predicate);</span>
    }

    /**
     * Retries until the given stop function returns true.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors downstream backpressure and expects the source {@code Publisher} to honor backpressure as well.
     *  If this expectation is violated, the operator &lt;em&gt;may&lt;/em&gt; throw an {@code IllegalStateException}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code retryUntil} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param stop the function that should return true to stop retrying
     * @return the new Flowable instance
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;T&gt; retryUntil(final BooleanSupplier stop) {
<span class="fc" id="L13476">        ObjectHelper.requireNonNull(stop, &quot;stop is null&quot;);</span>
<span class="fc" id="L13477">        return retry(Long.MAX_VALUE, Functions.predicateReverseFor(stop));</span>
    }

    /**
     * Returns a Flowable that emits the same values as the source Publisher with the exception of an
     * {@code onError}. An {@code onError} notification from the source will result in the emission of a
     * {@link Throwable} item to the Publisher provided as an argument to the {@code notificationHandler}
     * function. If that Publisher calls {@code onComplete} or {@code onError} then {@code retry} will call
     * {@code onComplete} or {@code onError} on the child subscription. Otherwise, this Publisher will
     * resubscribe to the source Publisher.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;430&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/retryWhen.f.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * Example:
     *
     * This retries 3 times, each time incrementing the number of seconds it waits.
     *
     * &lt;pre&gt;&lt;code&gt;
     *  Flowable.create((FlowableEmitter&amp;lt;? super String&amp;gt; s) -&amp;gt; {
     *      System.out.println(&quot;subscribing&quot;);
     *      s.onError(new RuntimeException(&quot;always fails&quot;));
     *  }, BackpressureStrategy.BUFFER).retryWhen(attempts -&amp;gt; {
     *      return attempts.zipWith(Flowable.range(1, 3), (n, i) -&amp;gt; i).flatMap(i -&amp;gt; {
     *          System.out.println(&quot;delay retry by &quot; + i + &quot; second(s)&quot;);
     *          return Flowable.timer(i, TimeUnit.SECONDS);
     *      });
     *  }).blockingForEach(System.out::println);
     * &lt;/code&gt;&lt;/pre&gt;
     *
     * Output is:
     *
     * &lt;pre&gt; {@code
     * subscribing
     * delay retry by 1 second(s)
     * subscribing
     * delay retry by 2 second(s)
     * subscribing
     * delay retry by 3 second(s)
     * subscribing
     * } &lt;/pre&gt;
     * &lt;p&gt;
     * Note that the inner {@code Publisher} returned by the handler function should signal
     * either {@code onNext}, {@code onError} or {@code onComplete} in response to the received
     * {@code Throwable} to indicate the operator should retry or terminate. If the upstream to
     * the operator is asynchronous, signaling onNext followed by onComplete immediately may
     * result in the sequence to be completed immediately. Similarly, if this inner
     * {@code Publisher} signals {@code onError} or {@code onComplete} while the upstream is
     * active, the sequence is terminated with the same signal immediately.
     * &lt;p&gt;
     * The following example demonstrates how to retry an asynchronous source with a delay:
     * &lt;pre&gt;&lt;code&gt;
     * Flowable.timer(1, TimeUnit.SECONDS)
     *     .doOnSubscribe(s -&amp;gt; System.out.println(&quot;subscribing&quot;))
     *     .map(v -&amp;gt; { throw new RuntimeException(); })
     *     .retryWhen(errors -&amp;gt; {
     *         AtomicInteger counter = new AtomicInteger();
     *         return errors
     *                   .takeWhile(e -&amp;gt; counter.getAndIncrement() != 3)
     *                   .flatMap(e -&amp;gt; {
     *                       System.out.println(&quot;delay retry by &quot; + counter.get() + &quot; second(s)&quot;);
     *                       return Flowable.timer(counter.get(), TimeUnit.SECONDS);
     *                   });
     *     })
     *     .blockingSubscribe(System.out::println, System.out::println);
     * &lt;/code&gt;&lt;/pre&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors downstream backpressure and expects both the source
     *  and inner {@code Publisher}s to honor backpressure as well.
     *  If this expectation is violated, the operator &lt;em&gt;may&lt;/em&gt; throw an {@code IllegalStateException}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code retryWhen} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param handler
     *            receives a Publisher of notifications with which a user can complete or error, aborting the
     *            retry
     * @return the source Publisher modified with retry logic
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/retry.html&quot;&gt;ReactiveX operators documentation: Retry&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;T&gt; retryWhen(
            final Function&lt;? super Flowable&lt;Throwable&gt;, ? extends Publisher&lt;?&gt;&gt; handler) {
<span class="fc" id="L13563">        ObjectHelper.requireNonNull(handler, &quot;handler is null&quot;);</span>

<span class="fc" id="L13565">        return RxJavaPlugins.onAssembly(new FlowableRetryWhen&lt;T&gt;(this, handler));</span>
    }

    /**
     * Subscribes to the current Flowable and wraps the given Subscriber into a SafeSubscriber
     * (if not already a SafeSubscriber) that
     * deals with exceptions thrown by a misbehaving Subscriber (that doesn't follow the
     * Reactive-Streams specification).
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator leaves the reactive world and the backpressure behavior depends on the Subscriber's behavior.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code safeSubscribe} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param s the incoming Subscriber instance
     * @throws NullPointerException if s is null
     */
    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final void safeSubscribe(Subscriber&lt;? super T&gt; s) {
<span class="fc" id="L13585">        ObjectHelper.requireNonNull(s, &quot;s is null&quot;);</span>
<span class="fc bfc" id="L13586" title="All 2 branches covered.">        if (s instanceof SafeSubscriber) {</span>
<span class="fc" id="L13587">            subscribe((SafeSubscriber&lt;? super T&gt;)s);</span>
        } else {
<span class="fc" id="L13589">            subscribe(new SafeSubscriber&lt;T&gt;(s));</span>
        }
<span class="fc" id="L13591">    }</span>

    /**
     * Returns a Flowable that emits the most recently emitted item (if any) emitted by the source Publisher
     * within periodic time intervals.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/sample.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not support backpressure as it uses time to control data flow.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code sample} operates by default on the {@code computation} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param period
     *            the sampling rate
     * @param unit
     *            the {@link TimeUnit} in which {@code period} is defined
     * @return a Flowable that emits the results of sampling the items emitted by the source Publisher at
     *         the specified time interval
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/sample.html&quot;&gt;ReactiveX operators documentation: Sample&lt;/a&gt;
     * @see &lt;a href=&quot;https://github.com/ReactiveX/RxJava/wiki/Backpressure&quot;&gt;RxJava wiki: Backpressure&lt;/a&gt;
     * @see #throttleLast(long, TimeUnit)
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.COMPUTATION)
    public final Flowable&lt;T&gt; sample(long period, TimeUnit unit) {
<span class="fc" id="L13619">        return sample(period, unit, Schedulers.computation());</span>
    }

    /**
     * Returns a Flowable that emits the most recently emitted item (if any) emitted by the source Publisher
     * within periodic time intervals and optionally emit the very last upstream item when the upstream completes.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;276&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/sample.emitlast.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not support backpressure as it uses time to control data flow.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code sample} operates by default on the {@code computation} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * &lt;p&gt;History: 2.0.5 - experimental
     * @param period
     *            the sampling rate
     * @param unit
     *            the {@link TimeUnit} in which {@code period} is defined
     * @param emitLast
     *            if true and the upstream completes while there is still an unsampled item available,
     *            that item is emitted to downstream before completion
     *            if false, an unsampled last item is ignored.
     * @return a Flowable that emits the results of sampling the items emitted by the source Publisher at
     *         the specified time interval
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/sample.html&quot;&gt;ReactiveX operators documentation: Sample&lt;/a&gt;
     * @see &lt;a href=&quot;https://github.com/ReactiveX/RxJava/wiki/Backpressure&quot;&gt;RxJava wiki: Backpressure&lt;/a&gt;
     * @see #throttleLast(long, TimeUnit)
     * @since 2.1
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.COMPUTATION)
    public final Flowable&lt;T&gt; sample(long period, TimeUnit unit, boolean emitLast) {
<span class="fc" id="L13654">        return sample(period, unit, Schedulers.computation(), emitLast);</span>
    }

    /**
     * Returns a Flowable that emits the most recently emitted item (if any) emitted by the source Publisher
     * within periodic time intervals, where the intervals are defined on a particular Scheduler.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/sample.s.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not support backpressure as it uses time to control data flow.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;You specify which {@link Scheduler} this operator will use.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param period
     *            the sampling rate
     * @param unit
     *            the {@link TimeUnit} in which {@code period} is defined
     * @param scheduler
     *            the {@link Scheduler} to use when sampling
     * @return a Flowable that emits the results of sampling the items emitted by the source Publisher at
     *         the specified time interval
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/sample.html&quot;&gt;ReactiveX operators documentation: Sample&lt;/a&gt;
     * @see &lt;a href=&quot;https://github.com/ReactiveX/RxJava/wiki/Backpressure&quot;&gt;RxJava wiki: Backpressure&lt;/a&gt;
     * @see #throttleLast(long, TimeUnit, Scheduler)
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Flowable&lt;T&gt; sample(long period, TimeUnit unit, Scheduler scheduler) {
<span class="fc" id="L13686">        ObjectHelper.requireNonNull(unit, &quot;unit is null&quot;);</span>
<span class="fc" id="L13687">        ObjectHelper.requireNonNull(scheduler, &quot;scheduler is null&quot;);</span>
<span class="fc" id="L13688">        return RxJavaPlugins.onAssembly(new FlowableSampleTimed&lt;T&gt;(this, period, unit, scheduler, false));</span>
    }

    /**
     * Returns a Flowable that emits the most recently emitted item (if any) emitted by the source Publisher
     * within periodic time intervals, where the intervals are defined on a particular Scheduler
     * and optionally emit the very last upstream item when the upstream completes.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;276&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/sample.s.emitlast.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not support backpressure as it uses time to control data flow.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;You specify which {@link Scheduler} this operator will use.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * &lt;p&gt;History: 2.0.5 - experimental
     * @param period
     *            the sampling rate
     * @param unit
     *            the {@link TimeUnit} in which {@code period} is defined
     * @param scheduler
     *            the {@link Scheduler} to use when sampling
     * @param emitLast
     *            if true and the upstream completes while there is still an unsampled item available,
     *            that item is emitted to downstream before completion
     *            if false, an unsampled last item is ignored.
     * @return a Flowable that emits the results of sampling the items emitted by the source Publisher at
     *         the specified time interval
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/sample.html&quot;&gt;ReactiveX operators documentation: Sample&lt;/a&gt;
     * @see &lt;a href=&quot;https://github.com/ReactiveX/RxJava/wiki/Backpressure&quot;&gt;RxJava wiki: Backpressure&lt;/a&gt;
     * @see #throttleLast(long, TimeUnit, Scheduler)
     * @since 2.1
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Flowable&lt;T&gt; sample(long period, TimeUnit unit, Scheduler scheduler, boolean emitLast) {
<span class="fc" id="L13727">        ObjectHelper.requireNonNull(unit, &quot;unit is null&quot;);</span>
<span class="fc" id="L13728">        ObjectHelper.requireNonNull(scheduler, &quot;scheduler is null&quot;);</span>
<span class="fc" id="L13729">        return RxJavaPlugins.onAssembly(new FlowableSampleTimed&lt;T&gt;(this, period, unit, scheduler, emitLast));</span>
    }

    /**
     * Returns a Flowable that, when the specified {@code sampler} Publisher emits an item or completes,
     * emits the most recently emitted item (if any) emitted by the source Publisher since the previous
     * emission from the {@code sampler} Publisher.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;289&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/sample.o.nolast.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not support backpressure as it uses the emissions of the {@code sampler}
     *      Publisher to control data flow.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code sample} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;U&gt; the element type of the sampler Publisher
     * @param sampler
     *            the Publisher to use for sampling the source Publisher
     * @return a Flowable that emits the results of sampling the items emitted by this Publisher whenever
     *         the {@code sampler} Publisher emits an item or completes
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/sample.html&quot;&gt;ReactiveX operators documentation: Sample&lt;/a&gt;
     * @see &lt;a href=&quot;https://github.com/ReactiveX/RxJava/wiki/Backpressure&quot;&gt;RxJava wiki: Backpressure&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;U&gt; Flowable&lt;T&gt; sample(Publisher&lt;U&gt; sampler) {
<span class="fc" id="L13759">        ObjectHelper.requireNonNull(sampler, &quot;sampler is null&quot;);</span>
<span class="fc" id="L13760">        return RxJavaPlugins.onAssembly(new FlowableSamplePublisher&lt;T&gt;(this, sampler, false));</span>
    }

    /**
     * Returns a Flowable that, when the specified {@code sampler} Publisher emits an item or completes,
     * emits the most recently emitted item (if any) emitted by the source Publisher since the previous
     * emission from the {@code sampler} Publisher
     * and optionally emit the very last upstream item when the upstream or other Publisher complete.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;289&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/sample.o.emitlast.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not support backpressure as it uses the emissions of the {@code sampler}
     *      Publisher to control data flow.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code sample} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * &lt;p&gt;History: 2.0.5 - experimental
     * @param &lt;U&gt; the element type of the sampler Publisher
     * @param sampler
     *            the Publisher to use for sampling the source Publisher
     * @param emitLast
     *            if true and the upstream completes while there is still an unsampled item available,
     *            that item is emitted to downstream before completion
     *            if false, an unsampled last item is ignored.
     * @return a Flowable that emits the results of sampling the items emitted by this Publisher whenever
     *         the {@code sampler} Publisher emits an item or completes
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/sample.html&quot;&gt;ReactiveX operators documentation: Sample&lt;/a&gt;
     * @see &lt;a href=&quot;https://github.com/ReactiveX/RxJava/wiki/Backpressure&quot;&gt;RxJava wiki: Backpressure&lt;/a&gt;
     * @since 2.1
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;U&gt; Flowable&lt;T&gt; sample(Publisher&lt;U&gt; sampler, boolean emitLast) {
<span class="fc" id="L13797">        ObjectHelper.requireNonNull(sampler, &quot;sampler is null&quot;);</span>
<span class="fc" id="L13798">        return RxJavaPlugins.onAssembly(new FlowableSamplePublisher&lt;T&gt;(this, sampler, emitLast));</span>
    }

    /**
     * Returns a Flowable that applies a specified accumulator function to the first item emitted by a source
     * Publisher, then feeds the result of that function along with the second item emitted by the source
     * Publisher into the same function, and so on until all items have been emitted by the source Publisher,
     * emitting the result of each of these iterations.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;320&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/scan.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * This sort of function is sometimes called an accumulator.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors downstream backpressure and expects the source {@code Publisher} to honor backpressure as well.
     *  Violating this expectation, a {@code MissingBackpressureException} &lt;em&gt;may&lt;/em&gt; get signaled somewhere downstream.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code scan} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param accumulator
     *            an accumulator function to be invoked on each item emitted by the source Publisher, whose
     *            result will be emitted to {@link Subscriber}s via {@link Subscriber#onNext onNext} and used in the
     *            next accumulator call
     * @return a Flowable that emits the results of each call to the accumulator function
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/scan.html&quot;&gt;ReactiveX operators documentation: Scan&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;T&gt; scan(BiFunction&lt;T, T, T&gt; accumulator) {
<span class="fc" id="L13830">        ObjectHelper.requireNonNull(accumulator, &quot;accumulator is null&quot;);</span>
<span class="fc" id="L13831">        return RxJavaPlugins.onAssembly(new FlowableScan&lt;T&gt;(this, accumulator));</span>
    }

    /**
     * Returns a Flowable that applies a specified accumulator function to the first item emitted by a source
     * Publisher and a seed value, then feeds the result of that function along with the second item emitted by
     * the source Publisher into the same function, and so on until all items have been emitted by the source
     * Publisher, emitting the result of each of these iterations.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;320&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/scanSeed.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * This sort of function is sometimes called an accumulator.
     * &lt;p&gt;
     * Note that the Publisher that results from this method will emit {@code initialValue} as its first
     * emitted item.
     * &lt;p&gt;
     * Note that the {@code initialValue} is shared among all subscribers to the resulting Publisher
     * and may cause problems if it is mutable. To make sure each subscriber gets its own value, defer
     * the application of this operator via {@link #defer(Callable)}:
     * &lt;pre&gt;&lt;code&gt;
     * Publisher&amp;lt;T&amp;gt; source = ...
     * Flowable.defer(() -&amp;gt; source.scan(new ArrayList&amp;lt;&amp;gt;(), (list, item) -&amp;gt; list.add(item)));
     *
     * // alternatively, by using compose to stay fluent
     *
     * source.compose(o -&amp;gt;
     *     Flowable.defer(() -&amp;gt; o.scan(new ArrayList&amp;lt;&amp;gt;(), (list, item) -&amp;gt; list.add(item)))
     * );
     * &lt;/code&gt;&lt;/pre&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors downstream backpressure and expects the source {@code Publisher} to honor backpressure as well.
     *  Violating this expectation, a {@code MissingBackpressureException} &lt;em&gt;may&lt;/em&gt; get signaled somewhere downstream.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code scan} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;R&gt; the initial, accumulator and result type
     * @param initialValue
     *            the initial (seed) accumulator item
     * @param accumulator
     *            an accumulator function to be invoked on each item emitted by the source Publisher, whose
     *            result will be emitted to {@link Subscriber}s via {@link Subscriber#onNext onNext} and used in the
     *            next accumulator call
     * @return a Flowable that emits {@code initialValue} followed by the results of each call to the
     *         accumulator function
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/scan.html&quot;&gt;ReactiveX operators documentation: Scan&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;R&gt; Flowable&lt;R&gt; scan(final R initialValue, BiFunction&lt;R, ? super T, R&gt; accumulator) {
<span class="fc" id="L13884">        ObjectHelper.requireNonNull(initialValue, &quot;initialValue is null&quot;);</span>
<span class="fc" id="L13885">        return scanWith(Functions.justCallable(initialValue), accumulator);</span>
    }

    /**
     * Returns a Flowable that applies a specified accumulator function to the first item emitted by a source
     * Publisher and a seed value, then feeds the result of that function along with the second item emitted by
     * the source Publisher into the same function, and so on until all items have been emitted by the source
     * Publisher, emitting the result of each of these iterations.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;320&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/scanSeed.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * This sort of function is sometimes called an accumulator.
     * &lt;p&gt;
     * Note that the Publisher that results from this method will emit the value returned by
     * the {@code seedSupplier} as its first item.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors downstream backpressure and expects the source {@code Publisher} to honor backpressure as well.
     *  Violating this expectation, a {@code MissingBackpressureException} &lt;em&gt;may&lt;/em&gt; get signaled somewhere downstream.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code scanWith} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;R&gt; the initial, accumulator and result type
     * @param seedSupplier
     *            a Callable that returns the initial (seed) accumulator item for each individual Subscriber
     * @param accumulator
     *            an accumulator function to be invoked on each item emitted by the source Publisher, whose
     *            result will be emitted to {@link Subscriber}s via {@link Subscriber#onNext onNext} and used in the
     *            next accumulator call
     * @return a Flowable that emits {@code initialValue} followed by the results of each call to the
     *         accumulator function
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/scan.html&quot;&gt;ReactiveX operators documentation: Scan&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;R&gt; Flowable&lt;R&gt; scanWith(Callable&lt;R&gt; seedSupplier, BiFunction&lt;R, ? super T, R&gt; accumulator) {
<span class="fc" id="L13924">        ObjectHelper.requireNonNull(seedSupplier, &quot;seedSupplier is null&quot;);</span>
<span class="fc" id="L13925">        ObjectHelper.requireNonNull(accumulator, &quot;accumulator is null&quot;);</span>
<span class="fc" id="L13926">        return RxJavaPlugins.onAssembly(new FlowableScanSeed&lt;T, R&gt;(this, seedSupplier, accumulator));</span>
    }

    /**
     * Forces a Publisher's emissions and notifications to be serialized and for it to obey
     * &lt;a href=&quot;http://reactivex.io/documentation/contract.html&quot;&gt;the Publisher contract&lt;/a&gt; in other ways.
     * &lt;p&gt;
     * It is possible for a Publisher to invoke its Subscribers' methods asynchronously, perhaps from
     * different threads. This could make such a Publisher poorly-behaved, in that it might try to invoke
     * {@code onComplete} or {@code onError} before one of its {@code onNext} invocations, or it might call
     * {@code onNext} from two different threads concurrently. You can force such a Publisher to be
     * well-behaved and sequential by applying the {@code serialize} method to it.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;400&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/synchronize.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure
     *  behavior.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code serialize} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @return a {@link Publisher} that is guaranteed to be well-behaved and to make only serialized calls to
     *         its Subscribers
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/serialize.html&quot;&gt;ReactiveX operators documentation: Serialize&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;T&gt; serialize() {
<span class="fc" id="L13956">        return RxJavaPlugins.onAssembly(new FlowableSerialized&lt;T&gt;(this));</span>
    }

    /**
     * Returns a new {@link Publisher} that multicasts (and shares a single subscription to) the original {@link Publisher}. As long as
     * there is at least one {@link Subscriber} this {@link Publisher} will be subscribed and emitting data.
     * When all subscribers have canceled it will cancel the source {@link Publisher}.
     * &lt;p&gt;
     * This is an alias for {@link #publish()}.{@link ConnectableFlowable#refCount() refCount()}.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;510&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/publishRefCount.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure and expects the source {@code Publisher} to honor backpressure as well.
     *  If this expectation is violated, the operator will signal a {@code MissingBackpressureException} to
     *  its {@code Subscriber}s.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code share} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @return a {@code Publisher} that upon connection causes the source {@code Publisher} to emit items
     *         to its {@link Subscriber}s
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/refcount.html&quot;&gt;ReactiveX operators documentation: RefCount&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;T&gt; share() {
<span class="fc" id="L13984">        return publish().refCount();</span>
    }

    /**
     * Returns a Maybe that completes if this Flowable is empty, signals one item if this Flowable
     * signals exactly one item or signals an {@code IllegalArgumentException} if this Flowable signals
     * more than one item.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;315&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/single.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream and consumes the source {@code Publisher} in an
     *  unbounded manner (i.e., without applying backpressure).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code singleElement} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @return a Maybe that emits the single item emitted by the source Publisher
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/first.html&quot;&gt;ReactiveX operators documentation: First&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Maybe&lt;T&gt; singleElement() {
<span class="fc" id="L14008">        return RxJavaPlugins.onAssembly(new FlowableSingleMaybe&lt;T&gt;(this));</span>
    }

    /**
     * Returns a Single that emits the single item emitted by the source Publisher, if that Publisher
     * emits only a single item, or a default item if the source Publisher emits no items. If the source
     * Publisher emits more than one item, an {@code IllegalArgumentException} is signaled instead.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;315&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/singleOrDefault.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream and consumes the source {@code Publisher} in an
     *  unbounded manner (i.e., without applying backpressure).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code single} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param defaultItem
     *            a default value to emit if the source Publisher emits no item
     * @return a Single that emits the single item emitted by the source Publisher, or a default item if
     *         the source Publisher is empty
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/first.html&quot;&gt;ReactiveX operators documentation: First&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Single&lt;T&gt; single(T defaultItem) {
<span class="fc" id="L14036">        ObjectHelper.requireNonNull(defaultItem, &quot;defaultItem is null&quot;);</span>
<span class="fc" id="L14037">        return RxJavaPlugins.onAssembly(new FlowableSingleSingle&lt;T&gt;(this, defaultItem));</span>
    }

    /**
     * Returns a Single that emits the single item emitted by this Flowable, if this Flowable
     * emits only a single item, otherwise
     * if this Flowable completes without emitting any items a {@link NoSuchElementException} will be signaled and
     * if this Flowable emits more than one item, an {@code IllegalArgumentException} will be signaled.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;205&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/singleOrError.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream and consumes the source {@code Publisher} in an
     *  unbounded manner (i.e., without applying backpressure).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code singleOrError} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @return the new Single instance
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/first.html&quot;&gt;ReactiveX operators documentation: First&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Single&lt;T&gt; singleOrError() {
<span class="fc" id="L14062">        return RxJavaPlugins.onAssembly(new FlowableSingleSingle&lt;T&gt;(this, null));</span>
    }

    /**
     * Returns a Flowable that skips the first {@code count} items emitted by the source Publisher and emits
     * the remainder.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/skip.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure
     *  behavior.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code skip} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param count
     *            the number of items to skip
     * @return a Flowable that is identical to the source Publisher except that it does not emit the first
     *         {@code count} items that the source Publisher emits
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/skip.html&quot;&gt;ReactiveX operators documentation: Skip&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;T&gt; skip(long count) {
<span class="fc bfc" id="L14088" title="All 2 branches covered.">        if (count &lt;= 0L) {</span>
<span class="fc" id="L14089">            return RxJavaPlugins.onAssembly(this);</span>
        }
<span class="fc" id="L14091">        return RxJavaPlugins.onAssembly(new FlowableSkip&lt;T&gt;(this, count));</span>
    }

    /**
     * Returns a Flowable that skips values emitted by the source Publisher before a specified time window
     * elapses.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/skip.t.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator doesn't support backpressure as it uses time to skip an arbitrary number of elements and
     *  thus has to consume the source {@code Publisher} in an unbounded manner (i.e., no backpressure applied to it).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code skip} does not operate on any particular scheduler but uses the current time
     *  from the {@code computation} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param time
     *            the length of the time window to skip
     * @param unit
     *            the time unit of {@code time}
     * @return a Flowable that skips values emitted by the source Publisher before the time window defined
     *         by {@code time} elapses and the emits the remainder
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/skip.html&quot;&gt;ReactiveX operators documentation: Skip&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;T&gt; skip(long time, TimeUnit unit) {
<span class="fc" id="L14120">        return skipUntil(timer(time, unit));</span>
    }

    /**
     * Returns a Flowable that skips values emitted by the source Publisher before a specified time window
     * on a specified {@link Scheduler} elapses.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/skip.ts.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator doesn't support backpressure as it uses time to skip an arbitrary number of elements and
     *  thus has to consume the source {@code Publisher} in an unbounded manner (i.e., no backpressure applied to it).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;You specify which {@link Scheduler} this operator will use for the timed skipping&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param time
     *            the length of the time window to skip
     * @param unit
     *            the time unit of {@code time}
     * @param scheduler
     *            the {@link Scheduler} on which the timed wait happens
     * @return a Flowable that skips values emitted by the source Publisher before the time window defined
     *         by {@code time} and {@code scheduler} elapses, and then emits the remainder
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/skip.html&quot;&gt;ReactiveX operators documentation: Skip&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Flowable&lt;T&gt; skip(long time, TimeUnit unit, Scheduler scheduler) {
<span class="fc" id="L14150">        return skipUntil(timer(time, unit, scheduler));</span>
    }

    /**
     * Returns a Flowable that drops a specified number of items from the end of the sequence emitted by the
     * source Publisher.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/skipLast.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * This Subscriber accumulates a queue long enough to store the first {@code count} items. As more items are
     * received, items are taken from the front of the queue and emitted by the returned Publisher. This causes
     * such items to be delayed.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure
     *  behavior.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code skipLast} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param count
     *            number of items to drop from the end of the source sequence
     * @return a Flowable that emits the items emitted by the source Publisher except for the dropped ones
     *         at the end
     * @throws IndexOutOfBoundsException
     *             if {@code count} is less than zero
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/skiplast.html&quot;&gt;ReactiveX operators documentation: SkipLast&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;T&gt; skipLast(int count) {
<span class="fc bfc" id="L14182" title="All 2 branches covered.">        if (count &lt; 0) {</span>
<span class="fc" id="L14183">            throw new IndexOutOfBoundsException(&quot;count &gt;= 0 required but it was &quot; + count);</span>
        }
<span class="fc bfc" id="L14185" title="All 2 branches covered.">        if (count == 0) {</span>
<span class="fc" id="L14186">            return RxJavaPlugins.onAssembly(this);</span>
        }
<span class="fc" id="L14188">        return RxJavaPlugins.onAssembly(new FlowableSkipLast&lt;T&gt;(this, count));</span>
    }

    /**
     * Returns a Flowable that drops items emitted by the source Publisher during a specified time window
     * before the source completes.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/skipLast.t.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * Note: this action will cache the latest items arriving in the specified time window.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator doesn't support backpressure as it uses time to skip an arbitrary number of elements and
     *  thus has to consume the source {@code Publisher} in an unbounded manner (i.e., no backpressure applied to it).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code skipLast} does not operate on any particular scheduler but uses the current time
     *  from the {@code computation} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param time
     *            the length of the time window
     * @param unit
     *            the time unit of {@code time}
     * @return a Flowable that drops those items emitted by the source Publisher in a time window before the
     *         source completes defined by {@code time}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/skiplast.html&quot;&gt;ReactiveX operators documentation: SkipLast&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;T&gt; skipLast(long time, TimeUnit unit) {
<span class="fc" id="L14219">        return skipLast(time, unit, Schedulers.computation(), false, bufferSize());</span>
    }

    /**
     * Returns a Flowable that drops items emitted by the source Publisher during a specified time window
     * before the source completes.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/skipLast.t.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * Note: this action will cache the latest items arriving in the specified time window.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator doesn't support backpressure as it uses time to skip an arbitrary number of elements and
     *  thus has to consume the source {@code Publisher} in an unbounded manner (i.e., no backpressure applied to it).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code skipLast} does not operate on any particular scheduler but uses the current time
     *  from the {@code computation} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param time
     *            the length of the time window
     * @param unit
     *            the time unit of {@code time}
     * @param delayError
     *            if true, an exception signaled by the current Flowable is delayed until the regular elements are consumed
     *            by the downstream; if false, an exception is immediately signaled and all regular elements dropped
     * @return a Flowable that drops those items emitted by the source Publisher in a time window before the
     *         source completes defined by {@code time}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/skiplast.html&quot;&gt;ReactiveX operators documentation: SkipLast&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;T&gt; skipLast(long time, TimeUnit unit, boolean delayError) {
<span class="fc" id="L14253">        return skipLast(time, unit, Schedulers.computation(), delayError, bufferSize());</span>
    }

    /**
     * Returns a Flowable that drops items emitted by the source Publisher during a specified time window
     * (defined on a specified scheduler) before the source completes.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;340&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/skipLast.ts.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * Note: this action will cache the latest items arriving in the specified time window.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator doesn't support backpressure as it uses time to skip an arbitrary number of elements and
     *  thus has to consume the source {@code Publisher} in an unbounded manner (i.e., no backpressure applied to it).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;You specify which {@link Scheduler} this operator will use for tracking the current time&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param time
     *            the length of the time window
     * @param unit
     *            the time unit of {@code time}
     * @param scheduler
     *            the scheduler used as the time source
     * @return a Flowable that drops those items emitted by the source Publisher in a time window before the
     *         source completes defined by {@code time} and {@code scheduler}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/skiplast.html&quot;&gt;ReactiveX operators documentation: SkipLast&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Flowable&lt;T&gt; skipLast(long time, TimeUnit unit, Scheduler scheduler) {
<span class="fc" id="L14285">        return skipLast(time, unit, scheduler, false, bufferSize());</span>
    }

    /**
     * Returns a Flowable that drops items emitted by the source Publisher during a specified time window
     * (defined on a specified scheduler) before the source completes.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;340&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/skipLast.ts.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * Note: this action will cache the latest items arriving in the specified time window.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator doesn't support backpressure as it uses time to skip an arbitrary number of elements and
     *  thus has to consume the source {@code Publisher} in an unbounded manner (i.e., no backpressure applied to it).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;You specify which {@link Scheduler} this operator will use to track the current time&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param time
     *            the length of the time window
     * @param unit
     *            the time unit of {@code time}
     * @param scheduler
     *            the scheduler used as the time source
     * @param delayError
     *            if true, an exception signaled by the current Flowable is delayed until the regular elements are consumed
     *            by the downstream; if false, an exception is immediately signaled and all regular elements dropped
     * @return a Flowable that drops those items emitted by the source Publisher in a time window before the
     *         source completes defined by {@code time} and {@code scheduler}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/skiplast.html&quot;&gt;ReactiveX operators documentation: SkipLast&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Flowable&lt;T&gt; skipLast(long time, TimeUnit unit, Scheduler scheduler, boolean delayError) {
<span class="fc" id="L14320">        return skipLast(time, unit, scheduler, delayError, bufferSize());</span>
    }

    /**
     * Returns a Flowable that drops items emitted by the source Publisher during a specified time window
     * (defined on a specified scheduler) before the source completes.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;340&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/skipLast.ts.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * Note: this action will cache the latest items arriving in the specified time window.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator doesn't support backpressure as it uses time to skip an arbitrary number of elements and
     *  thus has to consume the source {@code Publisher} in an unbounded manner (i.e., no backpressure applied to it).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;You specify which {@link Scheduler} this operator will use.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param time
     *            the length of the time window
     * @param unit
     *            the time unit of {@code time}
     * @param scheduler
     *            the scheduler used as the time source
     * @param delayError
     *            if true, an exception signaled by the current Flowable is delayed until the regular elements are consumed
     *            by the downstream; if false, an exception is immediately signaled and all regular elements dropped
     * @param bufferSize
     *            the hint about how many elements to expect to be skipped
     * @return a Flowable that drops those items emitted by the source Publisher in a time window before the
     *         source completes defined by {@code time} and {@code scheduler}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/skiplast.html&quot;&gt;ReactiveX operators documentation: SkipLast&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Flowable&lt;T&gt; skipLast(long time, TimeUnit unit, Scheduler scheduler, boolean delayError, int bufferSize) {
<span class="fc" id="L14358">        ObjectHelper.requireNonNull(unit, &quot;unit is null&quot;);</span>
<span class="fc" id="L14359">        ObjectHelper.requireNonNull(scheduler, &quot;scheduler is null&quot;);</span>
<span class="fc" id="L14360">        ObjectHelper.verifyPositive(bufferSize, &quot;bufferSize&quot;);</span>
        // the internal buffer holds pairs of (timestamp, value) so double the default buffer size
<span class="fc" id="L14362">        int s = bufferSize &lt;&lt; 1;</span>
<span class="fc" id="L14363">        return RxJavaPlugins.onAssembly(new FlowableSkipLastTimed&lt;T&gt;(this, time, unit, scheduler, s, delayError));</span>
    }

    /**
     * Returns a Flowable that skips items emitted by the source Publisher until a second Publisher emits
     * an item.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;375&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/skipUntil.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure
     *  behavior.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code skipUntil} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;U&gt; the element type of the other Publisher
     * @param other
     *            the second Publisher that has to emit an item before the source Publisher's elements begin
     *            to be mirrored by the resulting Publisher
     * @return a Flowable that skips items from the source Publisher until the second Publisher emits an
     *         item, then emits the remaining items
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/skipuntil.html&quot;&gt;ReactiveX operators documentation: SkipUntil&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;U&gt; Flowable&lt;T&gt; skipUntil(Publisher&lt;U&gt; other) {
<span class="fc" id="L14392">        ObjectHelper.requireNonNull(other, &quot;other is null&quot;);</span>
<span class="fc" id="L14393">        return RxJavaPlugins.onAssembly(new FlowableSkipUntil&lt;T, U&gt;(this, other));</span>
    }

    /**
     * Returns a Flowable that skips all items emitted by the source Publisher as long as a specified
     * condition holds true, but emits all further source items as soon as the condition becomes false.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/skipWhile.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure
     *  behavior.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code skipWhile} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param predicate
     *            a function to test each item emitted from the source Publisher
     * @return a Flowable that begins emitting items emitted by the source Publisher when the specified
     *         predicate becomes false
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/skipwhile.html&quot;&gt;ReactiveX operators documentation: SkipWhile&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;T&gt; skipWhile(Predicate&lt;? super T&gt; predicate) {
<span class="fc" id="L14420">        ObjectHelper.requireNonNull(predicate, &quot;predicate is null&quot;);</span>
<span class="fc" id="L14421">        return RxJavaPlugins.onAssembly(new FlowableSkipWhile&lt;T&gt;(this, predicate));</span>
    }
    /**
     * Returns a Flowable that emits the events emitted by source Publisher, in a
     * sorted order. Each item emitted by the Publisher must implement {@link Comparable} with respect to all
     * other items in the sequence.
     *
     * &lt;p&gt;If any item emitted by this Flowable does not implement {@link Comparable} with respect to
     *             all other items emitted by this Flowable, no items will be emitted and the
     *             sequence is terminated with a {@link ClassCastException}.
     * &lt;p&gt;Note that calling {@code sorted} with long, non-terminating or infinite sources
     * might cause {@link OutOfMemoryError}
     *
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream and consumes the source {@code Publisher} in an
     *  unbounded manner (i.e., without applying backpressure to it).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code sorted} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @return a Flowable that emits the items emitted by the source Publisher in sorted order
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;T&gt; sorted() {
<span class="fc" id="L14448">        return toList().toFlowable().map(Functions.listSorter(Functions.&lt;T&gt;naturalComparator())).flatMapIterable(Functions.&lt;List&lt;T&gt;&gt;identity());</span>
    }

    /**
     * Returns a Flowable that emits the events emitted by source Publisher, in a
     * sorted order based on a specified comparison function.
     *
     * &lt;p&gt;Note that calling {@code sorted} with long, non-terminating or infinite sources
     * might cause {@link OutOfMemoryError}
     *
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream and consumes the source {@code Publisher} in an
     *  unbounded manner (i.e., without applying backpressure to it).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code sorted} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param sortFunction
     *            a function that compares two items emitted by the source Publisher and returns an Integer
     *            that indicates their sort order
     * @return a Flowable that emits the items emitted by the source Publisher in sorted order
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;T&gt; sorted(Comparator&lt;? super T&gt; sortFunction) {
<span class="fc" id="L14476">        ObjectHelper.requireNonNull(sortFunction, &quot;sortFunction&quot;);</span>
<span class="fc" id="L14477">        return toList().toFlowable().map(Functions.listSorter(sortFunction)).flatMapIterable(Functions.&lt;List&lt;T&gt;&gt;identity());</span>
    }

    /**
     * Returns a Flowable that emits the items in a specified {@link Iterable} before it begins to emit items
     * emitted by the source Publisher.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;315&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/startWith.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream. The source {@code Publisher}
     *  is expected to honor backpressure as well. If it violates this rule, it &lt;em&gt;may&lt;/em&gt; throw an
     *  {@code IllegalStateException} when the source {@code Publisher} completes.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code startWith} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param items
     *            an Iterable that contains the items you want the modified Publisher to emit first
     * @return a Flowable that emits the items in the specified {@link Iterable} and then emits the items
     *         emitted by the source Publisher
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/startwith.html&quot;&gt;ReactiveX operators documentation: StartWith&lt;/a&gt;
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;T&gt; startWith(Iterable&lt;? extends T&gt; items) {
<span class="fc" id="L14505">        return concatArray(fromIterable(items), this);</span>
    }

    /**
     * Returns a Flowable that emits the items in a specified {@link Publisher} before it begins to emit
     * items emitted by the source Publisher.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;315&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/startWith.o.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream. Both this and the {@code other} {@code Publisher}s
     *  are expected to honor backpressure as well. If any of then violates this rule, it &lt;em&gt;may&lt;/em&gt; throw an
     *  {@code IllegalStateException} when the source {@code Publisher} completes.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code startWith} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param other
     *            a Publisher that contains the items you want the modified Publisher to emit first
     * @return a Flowable that emits the items in the specified {@link Publisher} and then emits the items
     *         emitted by the source Publisher
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/startwith.html&quot;&gt;ReactiveX operators documentation: StartWith&lt;/a&gt;
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;T&gt; startWith(Publisher&lt;? extends T&gt; other) {
<span class="fc" id="L14534">        ObjectHelper.requireNonNull(other, &quot;other is null&quot;);</span>
<span class="fc" id="L14535">        return concatArray(other, this);</span>
    }

    /**
     * Returns a Flowable that emits a specified item before it begins to emit items emitted by the source
     * Publisher.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;315&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/startWith.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream. The source {@code Publisher}
     *  is expected to honor backpressure as well. If it violates this rule, it &lt;em&gt;may&lt;/em&gt; throw an
     *  {@code IllegalStateException} when the source {@code Publisher} completes.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code startWith} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param value
     *            the item to emit first
     * @return a Flowable that emits the specified item before it begins to emit items emitted by the source
     *         Publisher
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/startwith.html&quot;&gt;ReactiveX operators documentation: StartWith&lt;/a&gt;
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;T&gt; startWith(T value) {
<span class="fc" id="L14564">        ObjectHelper.requireNonNull(value, &quot;value is null&quot;);</span>
<span class="fc" id="L14565">        return concatArray(just(value), this);</span>
    }

    /**
     * Returns a Flowable that emits the specified items before it begins to emit items emitted by the source
     * Publisher.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;315&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/startWith.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream. The source {@code Publisher}
     *  is expected to honor backpressure as well. If it violates this rule, it &lt;em&gt;may&lt;/em&gt; throw an
     *  {@code IllegalStateException} when the source {@code Publisher} completes.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code startWithArray} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param items
     *            the array of values to emit first
     * @return a Flowable that emits the specified items before it begins to emit items emitted by the source
     *         Publisher
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/startwith.html&quot;&gt;ReactiveX operators documentation: StartWith&lt;/a&gt;
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;T&gt; startWithArray(T... items) {
<span class="fc" id="L14593">        Flowable&lt;T&gt; fromArray = fromArray(items);</span>
<span class="fc bfc" id="L14594" title="All 2 branches covered.">        if (fromArray == empty()) {</span>
<span class="fc" id="L14595">            return RxJavaPlugins.onAssembly(this);</span>
        }
<span class="fc" id="L14597">        return concatArray(fromArray, this);</span>
    }

    /**
     * Subscribes to a Publisher and ignores {@code onNext} and {@code onComplete} emissions.
     * &lt;p&gt;
     * If the Flowable emits an error, it is wrapped into an
     * {@link io.reactivex.exceptions.OnErrorNotImplementedException OnErrorNotImplementedException}
     * and routed to the RxJavaPlugins.onError handler.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator consumes the source {@code Publisher} in an unbounded manner (i.e., no
     *  backpressure is applied to it).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code subscribe} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @return a {@link Disposable} reference with which the caller can stop receiving items before
     *         the Publisher has finished sending them
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/subscribe.html&quot;&gt;ReactiveX operators documentation: Subscribe&lt;/a&gt;
     */
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Disposable subscribe() {
<span class="fc" id="L14621">        return subscribe(Functions.emptyConsumer(), Functions.ON_ERROR_MISSING,</span>
                Functions.EMPTY_ACTION, FlowableInternalHelper.RequestMax.INSTANCE);
    }

    /**
     * Subscribes to a Publisher and provides a callback to handle the items it emits.
     * &lt;p&gt;
     * If the Flowable emits an error, it is wrapped into an
     * {@link io.reactivex.exceptions.OnErrorNotImplementedException OnErrorNotImplementedException}
     * and routed to the RxJavaPlugins.onError handler.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator consumes the source {@code Publisher} in an unbounded manner (i.e., no
     *  backpressure is applied to it).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code subscribe} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param onNext
     *             the {@code Consumer&lt;T&gt;} you have designed to accept emissions from the Publisher
     * @return a {@link Disposable} reference with which the caller can stop receiving items before
     *         the Publisher has finished sending them
     * @throws NullPointerException
     *             if {@code onNext} is null
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/subscribe.html&quot;&gt;ReactiveX operators documentation: Subscribe&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Disposable subscribe(Consumer&lt;? super T&gt; onNext) {
<span class="fc" id="L14651">        return subscribe(onNext, Functions.ON_ERROR_MISSING,</span>
                Functions.EMPTY_ACTION, FlowableInternalHelper.RequestMax.INSTANCE);
    }

    /**
     * Subscribes to a Publisher and provides callbacks to handle the items it emits and any error
     * notification it issues.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator consumes the source {@code Publisher} in an unbounded manner (i.e., no
     *  backpressure is applied to it).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code subscribe} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param onNext
     *             the {@code Consumer&lt;T&gt;} you have designed to accept emissions from the Publisher
     * @param onError
     *             the {@code Consumer&lt;Throwable&gt;} you have designed to accept any error notification from the
     *             Publisher
     * @return a {@link Disposable} reference with which the caller can stop receiving items before
     *         the Publisher has finished sending them
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/subscribe.html&quot;&gt;ReactiveX operators documentation: Subscribe&lt;/a&gt;
     * @throws NullPointerException
     *             if {@code onNext} is null, or
     *             if {@code onError} is null
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Disposable subscribe(Consumer&lt;? super T&gt; onNext, Consumer&lt;? super Throwable&gt; onError) {
<span class="fc" id="L14682">        return subscribe(onNext, onError, Functions.EMPTY_ACTION, FlowableInternalHelper.RequestMax.INSTANCE);</span>
    }

    /**
     * Subscribes to a Publisher and provides callbacks to handle the items it emits and any error or
     * completion notification it issues.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator consumes the source {@code Publisher} in an unbounded manner (i.e., no
     *  backpressure is applied to it).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code subscribe} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param onNext
     *             the {@code Consumer&lt;T&gt;} you have designed to accept emissions from the Publisher
     * @param onError
     *             the {@code Consumer&lt;Throwable&gt;} you have designed to accept any error notification from the
     *             Publisher
     * @param onComplete
     *             the {@code Action} you have designed to accept a completion notification from the
     *             Publisher
     * @return a {@link Disposable} reference with which the caller can stop receiving items before
     *         the Publisher has finished sending them
     * @throws NullPointerException
     *             if {@code onNext} is null, or
     *             if {@code onError} is null, or
     *             if {@code onComplete} is null
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/subscribe.html&quot;&gt;ReactiveX operators documentation: Subscribe&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Disposable subscribe(Consumer&lt;? super T&gt; onNext, Consumer&lt;? super Throwable&gt; onError,
            Action onComplete) {
<span class="fc" id="L14717">        return subscribe(onNext, onError, onComplete, FlowableInternalHelper.RequestMax.INSTANCE);</span>
    }

    /**
     * Subscribes to a Publisher and provides callbacks to handle the items it emits and any error or
     * completion notification it issues.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator consumes the source {@code Publisher} in an unbounded manner (i.e., no
     *  backpressure is applied to it).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code subscribe} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param onNext
     *             the {@code Consumer&lt;T&gt;} you have designed to accept emissions from the Publisher
     * @param onError
     *             the {@code Consumer&lt;Throwable&gt;} you have designed to accept any error notification from the
     *             Publisher
     * @param onComplete
     *             the {@code Action} you have designed to accept a completion notification from the
     *             Publisher
     * @param onSubscribe
     *             the {@code Consumer} that receives the upstream's Subscription
     * @return a {@link Disposable} reference with which the caller can stop receiving items before
     *         the Publisher has finished sending them
     * @throws NullPointerException
     *             if {@code onNext} is null, or
     *             if {@code onError} is null, or
     *             if {@code onComplete} is null, or
     *             if {@code onSubscribe} is null
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/subscribe.html&quot;&gt;ReactiveX operators documentation: Subscribe&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.SPECIAL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Disposable subscribe(Consumer&lt;? super T&gt; onNext, Consumer&lt;? super Throwable&gt; onError,
            Action onComplete, Consumer&lt;? super Subscription&gt; onSubscribe) {
<span class="fc" id="L14756">        ObjectHelper.requireNonNull(onNext, &quot;onNext is null&quot;);</span>
<span class="fc" id="L14757">        ObjectHelper.requireNonNull(onError, &quot;onError is null&quot;);</span>
<span class="fc" id="L14758">        ObjectHelper.requireNonNull(onComplete, &quot;onComplete is null&quot;);</span>
<span class="fc" id="L14759">        ObjectHelper.requireNonNull(onSubscribe, &quot;onSubscribe is null&quot;);</span>

<span class="fc" id="L14761">        LambdaSubscriber&lt;T&gt; ls = new LambdaSubscriber&lt;T&gt;(onNext, onError, onComplete, onSubscribe);</span>

<span class="fc" id="L14763">        subscribe(ls);</span>

<span class="fc" id="L14765">        return ls;</span>
    }

    @BackpressureSupport(BackpressureKind.SPECIAL)
    @SchedulerSupport(SchedulerSupport.NONE)
    @Override
    public final void subscribe(Subscriber&lt;? super T&gt; s) {
<span class="fc bfc" id="L14772" title="All 2 branches covered.">        if (s instanceof FlowableSubscriber) {</span>
<span class="fc" id="L14773">            subscribe((FlowableSubscriber&lt;? super T&gt;)s);</span>
        } else {
<span class="fc" id="L14775">            ObjectHelper.requireNonNull(s, &quot;s is null&quot;);</span>
<span class="fc" id="L14776">            subscribe(new StrictSubscriber&lt;T&gt;(s));</span>
        }
<span class="fc" id="L14778">    }</span>

    /**
     * Establish a connection between this Flowable and the given FlowableSubscriber and
     * start streaming events based on the demand of the FlowableSubscriber.
     * &lt;p&gt;
     * This is a &quot;factory method&quot; and can be called multiple times, each time starting a new {@link Subscription}.
     * &lt;p&gt;
     * Each {@link Subscription} will work for only a single {@link FlowableSubscriber}.
     * &lt;p&gt;
     * If the same {@link FlowableSubscriber} instance is subscribed to multiple {@link Flowable}s and/or the
     * same {@link Flowable} multiple times, it must ensure the serialization over its {@code onXXX}
     * methods manually.
     * &lt;p&gt;
     * If the {@link Flowable} rejects the subscription attempt or otherwise fails it will signal
     * the error via {@link FlowableSubscriber#onError(Throwable)}.
     * &lt;p&gt;
     * This subscribe method relaxes the following Reactive-Streams rules:
     * &lt;ul&gt;
     * &lt;li&gt;1.3: onNext should not be called concurrently until onSubscribe returns.
     *     &lt;b&gt;FlowableSubscriber.onSubscribe should make sure a sync or async call triggered by request() is safe.&lt;/b&gt;&lt;/li&gt;
     * &lt;li&gt;2.3: onError or onComplete must not call cancel.
     *     &lt;b&gt;Calling request() or cancel() is NOP at this point.&lt;/b&gt;&lt;/li&gt;
     * &lt;li&gt;2.12: onSubscribe must be called at most once on the same instance.
     *     &lt;b&gt;FlowableSubscriber reuse is not checked and if happens, it is the responsibility of
     *     the FlowableSubscriber to ensure proper serialization of its onXXX methods.&lt;/b&gt;&lt;/li&gt;
     * &lt;li&gt;3.9: negative requests should emit an onError(IllegalArgumentException).
     *     &lt;b&gt;Non-positive requests signal via RxJavaPlugins.onError and the stream is not affected.&lt;/b&gt;&lt;/li&gt;
     * &lt;/ul&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The backpressure behavior/expectation is determined by the supplied {@code FlowableSubscriber}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code subscribe} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * &lt;p&gt;History: 2.0.7 - experimental; 2.1 - beta
     * @param s the FlowableSubscriber that will consume signals from this Flowable
     * @since 2.2
     */
    @BackpressureSupport(BackpressureKind.SPECIAL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final void subscribe(FlowableSubscriber&lt;? super T&gt; s) {
<span class="fc" id="L14820">        ObjectHelper.requireNonNull(s, &quot;s is null&quot;);</span>
        try {
<span class="fc" id="L14822">            Subscriber&lt;? super T&gt; z = RxJavaPlugins.onSubscribe(this, s);</span>

<span class="fc" id="L14824">            ObjectHelper.requireNonNull(z, &quot;The RxJavaPlugins.onSubscribe hook returned a null FlowableSubscriber. Please check the handler provided to RxJavaPlugins.setOnFlowableSubscribe for invalid null returns. Further reading: https://github.com/ReactiveX/RxJava/wiki/Plugins&quot;);</span>

<span class="fc" id="L14826">            subscribeActual(z);</span>
<span class="fc" id="L14827">        } catch (NullPointerException e) { // NOPMD</span>
<span class="fc" id="L14828">            throw e;</span>
<span class="fc" id="L14829">        } catch (Throwable e) {</span>
<span class="fc" id="L14830">            Exceptions.throwIfFatal(e);</span>
            // can't call onError because no way to know if a Subscription has been set or not
            // can't call onSubscribe because the call might have set a Subscription already
<span class="fc" id="L14833">            RxJavaPlugins.onError(e);</span>

<span class="fc" id="L14835">            NullPointerException npe = new NullPointerException(&quot;Actually not, but can't throw other exceptions due to RS&quot;);</span>
<span class="fc" id="L14836">            npe.initCause(e);</span>
<span class="fc" id="L14837">            throw npe;</span>
<span class="fc" id="L14838">        }</span>
<span class="fc" id="L14839">    }</span>

    /**
     * Operator implementations (both source and intermediate) should implement this method that
     * performs the necessary business logic and handles the incoming {@link Subscriber}s.
     * &lt;p&gt;There is no need to call any of the plugin hooks on the current {@code Flowable} instance or
     * the {@code Subscriber}; all hooks and basic safeguards have been
     * applied by {@link #subscribe(Subscriber)} before this method gets called.
     * @param s the incoming Subscriber, never null
     */
    protected abstract void subscribeActual(Subscriber&lt;? super T&gt; s);

    /**
     * Subscribes a given Subscriber (subclass) to this Flowable and returns the given
     * Subscriber as is.
     * &lt;p&gt;Usage example:
     * &lt;pre&gt;&lt;code&gt;
     * Flowable&amp;lt;Integer&amp;gt; source = Flowable.range(1, 10);
     * CompositeDisposable composite = new CompositeDisposable();
     *
     * ResourceSubscriber&amp;lt;Integer&amp;gt; rs = new ResourceSubscriber&amp;lt;&amp;gt;() {
     *     // ...
     * };
     *
     * composite.add(source.subscribeWith(rs));
     * &lt;/code&gt;&lt;/pre&gt;
     *
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The backpressure behavior/expectation is determined by the supplied {@code Subscriber}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code subscribeWith} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;E&gt; the type of the Subscriber to use and return
     * @param subscriber the Subscriber (subclass) to use and return, not null
     * @return the input {@code subscriber}
     * @throws NullPointerException if {@code subscriber} is null
     * @since 2.0
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.SPECIAL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;E extends Subscriber&lt;? super T&gt;&gt; E subscribeWith(E subscriber) {
<span class="fc" id="L14882">        subscribe(subscriber);</span>
<span class="fc" id="L14883">        return subscriber;</span>
    }

    /**
     * Asynchronously subscribes Subscribers to this Publisher on the specified {@link Scheduler}.
     * &lt;p&gt;
     * If there is a {@link #create(FlowableOnSubscribe, BackpressureStrategy)} type source up in the
     * chain, it is recommended to use {@code subscribeOn(scheduler, false)} instead
     * to avoid same-pool deadlock because requests may pile up behind an eager/blocking emitter.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/subscribeOn.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure
     *  behavior.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;You specify which {@link Scheduler} this operator will use.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param scheduler
     *            the {@link Scheduler} to perform subscription actions on
     * @return the source Publisher modified so that its subscriptions happen on the
     *         specified {@link Scheduler}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/subscribeon.html&quot;&gt;ReactiveX operators documentation: SubscribeOn&lt;/a&gt;
     * @see &lt;a href=&quot;http://www.grahamlea.com/2014/07/rxjava-threading-examples/&quot;&gt;RxJava Threading Examples&lt;/a&gt;
     * @see #observeOn
     * @see #subscribeOn(Scheduler, boolean)
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Flowable&lt;T&gt; subscribeOn(@NonNull Scheduler scheduler) {
<span class="fc" id="L14916">        ObjectHelper.requireNonNull(scheduler, &quot;scheduler is null&quot;);</span>
<span class="fc bfc" id="L14917" title="All 2 branches covered.">        return subscribeOn(scheduler, !(this instanceof FlowableCreate));</span>
    }

    /**
     * Asynchronously subscribes Subscribers to this Publisher on the specified {@link Scheduler}
     * optionally reroutes requests from other threads to the same {@link Scheduler} thread.
     * &lt;p&gt;
     * If there is a {@link #create(FlowableOnSubscribe, BackpressureStrategy)} type source up in the
     * chain, it is recommended to have {@code requestOn} false to avoid same-pool deadlock
     * because requests may pile up behind an eager/blocking emitter.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/subscribeOn.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure
     *  behavior.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;You specify which {@link Scheduler} this operator will use.&lt;/dd&gt;
     * &lt;/dl&gt;
     * &lt;p&gt;History: 2.1.1 - experimental
     * @param scheduler
     *            the {@link Scheduler} to perform subscription actions on
     * @param requestOn if true, requests are rerouted to the given Scheduler as well (strong pipelining)
     *                  if false, requests coming from any thread are simply forwarded to
     *                  the upstream on the same thread (weak pipelining)
     * @return the source Publisher modified so that its subscriptions happen on the
     *         specified {@link Scheduler}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/subscribeon.html&quot;&gt;ReactiveX operators documentation: SubscribeOn&lt;/a&gt;
     * @see &lt;a href=&quot;http://www.grahamlea.com/2014/07/rxjava-threading-examples/&quot;&gt;RxJava Threading Examples&lt;/a&gt;
     * @see #observeOn
     * @since 2.2
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Flowable&lt;T&gt; subscribeOn(@NonNull Scheduler scheduler, boolean requestOn) {
<span class="fc" id="L14954">        ObjectHelper.requireNonNull(scheduler, &quot;scheduler is null&quot;);</span>
<span class="fc" id="L14955">        return RxJavaPlugins.onAssembly(new FlowableSubscribeOn&lt;T&gt;(this, scheduler, requestOn));</span>
    }

    /**
     * Returns a Flowable that emits the items emitted by the source Publisher or the items of an alternate
     * Publisher if the source Publisher is empty.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;255&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/switchifempty.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;If the source {@code Publisher} is empty, the alternate {@code Publisher} is expected to honor backpressure.
     *  If the source {@code Publisher} is non-empty, it is expected to honor backpressure as instead.
     *  In either case, if violated, a {@code MissingBackpressureException} &lt;em&gt;may&lt;/em&gt; get
     *  signaled somewhere downstream.
     *  &lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code switchIfEmpty} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param other
     *              the alternate Publisher to subscribe to if the source does not emit any items
     * @return  a Publisher that emits the items emitted by the source Publisher or the items of an
     *          alternate Publisher if the source Publisher is empty.
     * @since 1.1.0
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;T&gt; switchIfEmpty(Publisher&lt;? extends T&gt; other) {
<span class="fc" id="L14985">        ObjectHelper.requireNonNull(other, &quot;other is null&quot;);</span>
<span class="fc" id="L14986">        return RxJavaPlugins.onAssembly(new FlowableSwitchIfEmpty&lt;T&gt;(this, other));</span>
    }

    /**
     * Returns a new Publisher by applying a function that you supply to each item emitted by the source
     * Publisher that returns a Publisher, and then emitting the items emitted by the most recently emitted
     * of these Publishers.
     * &lt;p&gt;
     * The resulting Publisher completes if both the upstream Publisher and the last inner Publisher, if any, complete.
     * If the upstream Publisher signals an onError, the inner Publisher is canceled and the error delivered in-sequence.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;350&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/switchMap.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream. The outer {@code Publisher} is consumed in an
     *  unbounded manner (i.e., without backpressure) and the inner {@code Publisher}s are expected to honor
     *  backpressure but it is not enforced; the operator won't signal a {@code MissingBackpressureException}
     *  but the violation &lt;em&gt;may&lt;/em&gt; lead to {@code OutOfMemoryError} due to internal buffer bloat.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code switchMap} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;R&gt; the element type of the inner Publishers and the output
     * @param mapper
     *            a function that, when applied to an item emitted by the source Publisher, returns a
     *            Publisher
     * @return a Flowable that emits the items emitted by the Publisher returned from applying {@code func} to the most recently emitted item emitted by the source Publisher
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/flatmap.html&quot;&gt;ReactiveX operators documentation: FlatMap&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;R&gt; Flowable&lt;R&gt; switchMap(Function&lt;? super T, ? extends Publisher&lt;? extends R&gt;&gt; mapper) {
<span class="fc" id="L15019">        return switchMap(mapper, bufferSize());</span>
    }

    /**
     * Returns a new Publisher by applying a function that you supply to each item emitted by the source
     * Publisher that returns a Publisher, and then emitting the items emitted by the most recently emitted
     * of these Publishers.
     * &lt;p&gt;
     * The resulting Publisher completes if both the upstream Publisher and the last inner Publisher, if any, complete.
     * If the upstream Publisher signals an onError, the inner Publisher is canceled and the error delivered in-sequence.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;350&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/switchMap.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream. The outer {@code Publisher} is consumed in an
     *  unbounded manner (i.e., without backpressure) and the inner {@code Publisher}s are expected to honor
     *  backpressure but it is not enforced; the operator won't signal a {@code MissingBackpressureException}
     *  but the violation &lt;em&gt;may&lt;/em&gt; lead to {@code OutOfMemoryError} due to internal buffer bloat.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code switchMap} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;R&gt; the element type of the inner Publishers and the output
     * @param mapper
     *            a function that, when applied to an item emitted by the source Publisher, returns a
     *            Publisher
     * @param bufferSize
     *            the number of elements to prefetch from the current active inner Publisher
     * @return a Flowable that emits the items emitted by the Publisher returned from applying {@code func} to the most recently emitted item emitted by the source Publisher
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/flatmap.html&quot;&gt;ReactiveX operators documentation: FlatMap&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;R&gt; Flowable&lt;R&gt; switchMap(Function&lt;? super T, ? extends Publisher&lt;? extends R&gt;&gt; mapper, int bufferSize) {
<span class="fc" id="L15054">        return switchMap0(mapper, bufferSize, false);</span>
    }

    /**
     * Maps the upstream values into {@link CompletableSource}s, subscribes to the newer one while
     * disposing the subscription to the previous {@code CompletableSource}, thus keeping at most one
     * active {@code CompletableSource} running.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;521&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/switchMapCompletable.f.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * Since a {@code CompletableSource} doesn't produce any items, the resulting reactive type of
     * this operator is a {@link Completable} that can only indicate successful completion or
     * a failure in any of the inner {@code CompletableSource}s or the failure of the current
     * {@link Flowable}.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator consumes the current {@link Flowable} in an unbounded manner and otherwise
     *  does not have backpressure in its return type because no items are ever produced.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code switchMapCompletable} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Error handling:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;If either this {@code Flowable} or the active {@code CompletableSource} signals an {@code onError},
     *  the resulting {@code Completable} is terminated immediately with that {@code Throwable}.
     *  Use the {@link #switchMapCompletableDelayError(Function)} to delay such inner failures until
     *  every inner {@code CompletableSource}s and the main {@code Flowable} terminates in some fashion.
     *  If they fail concurrently, the operator may combine the {@code Throwable}s into a
     *  {@link io.reactivex.exceptions.CompositeException CompositeException}
     *  and signal it to the downstream instead. If any inactivated (switched out) {@code CompletableSource}
     *  signals an {@code onError} late, the {@code Throwable}s will be signaled to the global error handler via
     *  {@link RxJavaPlugins#onError(Throwable)} method as {@code UndeliverableException} errors.
     *  &lt;/dd&gt;
     * &lt;/dl&gt;
     * &lt;p&gt;History: 2.1.11 - experimental
     * @param mapper the function called with each upstream item and should return a
     *               {@link CompletableSource} to be subscribed to and awaited for
     *               (non blockingly) for its terminal event
     * @return the new Completable instance
     * @see #switchMapCompletableDelayError(Function)
     * @since 2.2
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Completable switchMapCompletable(@NonNull Function&lt;? super T, ? extends CompletableSource&gt; mapper) {
<span class="fc" id="L15099">        ObjectHelper.requireNonNull(mapper, &quot;mapper is null&quot;);</span>
<span class="fc" id="L15100">        return RxJavaPlugins.onAssembly(new FlowableSwitchMapCompletable&lt;T&gt;(this, mapper, false));</span>
    }

    /**
     * Maps the upstream values into {@link CompletableSource}s, subscribes to the newer one while
     * disposing the subscription to the previous {@code CompletableSource}, thus keeping at most one
     * active {@code CompletableSource} running and delaying any main or inner errors until all
     * of them terminate.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;453&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/switchMapCompletableDelayError.f.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * Since a {@code CompletableSource} doesn't produce any items, the resulting reactive type of
     * this operator is a {@link Completable} that can only indicate successful completion or
     * a failure in any of the inner {@code CompletableSource}s or the failure of the current
     * {@link Flowable}.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator consumes the current {@link Flowable} in an unbounded manner and otherwise
     *  does not have backpressure in its return type because no items are ever produced.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code switchMapCompletableDelayError} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Error handling:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;Errors of this {@code Flowable} and all the {@code CompletableSource}s, who had the chance
     *  to run to their completion, are delayed until
     *  all of them terminate in some fashion. At this point, if there was only one failure, the respective
     *  {@code Throwable} is emitted to the downstream. If there was more than one failure, the
     *  operator combines all {@code Throwable}s into a {@link io.reactivex.exceptions.CompositeException CompositeException}
     *  and signals that to the downstream.
     *  If any inactivated (switched out) {@code CompletableSource}
     *  signals an {@code onError} late, the {@code Throwable}s will be signaled to the global error handler via
     *  {@link RxJavaPlugins#onError(Throwable)} method as {@code UndeliverableException} errors.
     *  &lt;/dd&gt;
     * &lt;/dl&gt;
     * &lt;p&gt;History: 2.1.11 - experimental
     * @param mapper the function called with each upstream item and should return a
     *               {@link CompletableSource} to be subscribed to and awaited for
     *               (non blockingly) for its terminal event
     * @return the new Completable instance
     * @see #switchMapCompletableDelayError(Function)
     * @since 2.2
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Completable switchMapCompletableDelayError(@NonNull Function&lt;? super T, ? extends CompletableSource&gt; mapper) {
<span class="fc" id="L15146">        ObjectHelper.requireNonNull(mapper, &quot;mapper is null&quot;);</span>
<span class="fc" id="L15147">        return RxJavaPlugins.onAssembly(new FlowableSwitchMapCompletable&lt;T&gt;(this, mapper, true));</span>
    }

    /**
     * Returns a new Publisher by applying a function that you supply to each item emitted by the source
     * Publisher that returns a Publisher, and then emitting the items emitted by the most recently emitted
     * of these Publishers and delays any error until all Publishers terminate.
     * &lt;p&gt;
     * The resulting Publisher completes if both the upstream Publisher and the last inner Publisher, if any, complete.
     * If the upstream Publisher signals an onError, the termination of the last inner Publisher will emit that error as is
     * or wrapped into a CompositeException along with the other possible errors the former inner Publishers signaled.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;350&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/switchMap.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream. The outer {@code Publisher} is consumed in an
     *  unbounded manner (i.e., without backpressure) and the inner {@code Publisher}s are expected to honor
     *  backpressure but it is not enforced; the operator won't signal a {@code MissingBackpressureException}
     *  but the violation &lt;em&gt;may&lt;/em&gt; lead to {@code OutOfMemoryError} due to internal buffer bloat.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code switchMapDelayError} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;R&gt; the element type of the inner Publishers and the output
     * @param mapper
     *            a function that, when applied to an item emitted by the source Publisher, returns a
     *            Publisher
     * @return a Flowable that emits the items emitted by the Publisher returned from applying {@code func} to the most recently emitted item emitted by the source Publisher
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/flatmap.html&quot;&gt;ReactiveX operators documentation: FlatMap&lt;/a&gt;
     * @since 2.0
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.SPECIAL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;R&gt; Flowable&lt;R&gt; switchMapDelayError(Function&lt;? super T, ? extends Publisher&lt;? extends R&gt;&gt; mapper) {
<span class="fc" id="L15182">        return switchMapDelayError(mapper, bufferSize());</span>
    }

    /**
     * Returns a new Publisher by applying a function that you supply to each item emitted by the source
     * Publisher that returns a Publisher, and then emitting the items emitted by the most recently emitted
     * of these Publishers and delays any error until all Publishers terminate.
     * &lt;p&gt;
     * The resulting Publisher completes if both the upstream Publisher and the last inner Publisher, if any, complete.
     * If the upstream Publisher signals an onError, the termination of the last inner Publisher will emit that error as is
     * or wrapped into a CompositeException along with the other possible errors the former inner Publishers signaled.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;350&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/switchMap.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream. The outer {@code Publisher} is consumed in an
     *  unbounded manner (i.e., without backpressure) and the inner {@code Publisher}s are expected to honor
     *  backpressure but it is not enforced; the operator won't signal a {@code MissingBackpressureException}
     *  but the violation &lt;em&gt;may&lt;/em&gt; lead to {@code OutOfMemoryError} due to internal buffer bloat.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code switchMapDelayError} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;R&gt; the element type of the inner Publishers and the output
     * @param mapper
     *            a function that, when applied to an item emitted by the source Publisher, returns a
     *            Publisher
     * @param bufferSize
     *            the number of elements to prefetch from the current active inner Publisher
     * @return a Flowable that emits the items emitted by the Publisher returned from applying {@code func} to the most recently emitted item emitted by the source Publisher
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/flatmap.html&quot;&gt;ReactiveX operators documentation: FlatMap&lt;/a&gt;
     * @since 2.0
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.SPECIAL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;R&gt; Flowable&lt;R&gt; switchMapDelayError(Function&lt;? super T, ? extends Publisher&lt;? extends R&gt;&gt; mapper, int bufferSize) {
<span class="fc" id="L15219">        return switchMap0(mapper, bufferSize, true);</span>
    }

    &lt;R&gt; Flowable&lt;R&gt; switchMap0(Function&lt;? super T, ? extends Publisher&lt;? extends R&gt;&gt; mapper, int bufferSize, boolean delayError) {
<span class="fc" id="L15223">        ObjectHelper.requireNonNull(mapper, &quot;mapper is null&quot;);</span>
<span class="fc" id="L15224">        ObjectHelper.verifyPositive(bufferSize, &quot;bufferSize&quot;);</span>
<span class="fc bfc" id="L15225" title="All 2 branches covered.">        if (this instanceof ScalarCallable) {</span>
            @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L15227">            T v = ((ScalarCallable&lt;T&gt;)this).call();</span>
<span class="fc bfc" id="L15228" title="All 2 branches covered.">            if (v == null) {</span>
<span class="fc" id="L15229">                return empty();</span>
            }
<span class="fc" id="L15231">            return FlowableScalarXMap.scalarXMap(v, mapper);</span>
        }
<span class="fc" id="L15233">        return RxJavaPlugins.onAssembly(new FlowableSwitchMap&lt;T, R&gt;(this, mapper, bufferSize, delayError));</span>
    }

    /**
     * Maps the upstream items into {@link MaybeSource}s and switches (subscribes) to the newer ones
     * while disposing the older ones (and ignoring their signals) and emits the latest success value of the current one if
     * available while failing immediately if this {@code Flowable} or any of the
     * active inner {@code MaybeSource}s fail.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;350&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/switchMap.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream. The main {@code Flowable} is consumed in an
     *  unbounded manner (i.e., without backpressure).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code switchMapMaybe} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Error handling:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator terminates with an {@code onError} if this {@code Flowable} or any of
     *  the inner {@code MaybeSource}s fail while they are active. When this happens concurrently, their
     *  individual {@code Throwable} errors may get combined and emitted as a single
     *  {@link io.reactivex.exceptions.CompositeException CompositeException}. Otherwise, a late
     *  (i.e., inactive or switched out) {@code onError} from this {@code Flowable} or from any of
     *  the inner {@code MaybeSource}s will be forwarded to the global error handler via
     *  {@link io.reactivex.plugins.RxJavaPlugins#onError(Throwable)} as
     *  {@link io.reactivex.exceptions.UndeliverableException UndeliverableException}&lt;/dd&gt;
     * &lt;/dl&gt;
     * &lt;p&gt;History: 2.1.11 - experimental
     * @param &lt;R&gt; the output value type
     * @param mapper the function called with the current upstream event and should
     *               return a {@code MaybeSource} to replace the current active inner source
     *               and get subscribed to.
     * @return the new Flowable instance
     * @see #switchMapMaybe(Function)
     * @since 2.2
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;R&gt; Flowable&lt;R&gt; switchMapMaybe(@NonNull Function&lt;? super T, ? extends MaybeSource&lt;? extends R&gt;&gt; mapper) {
<span class="fc" id="L15273">        ObjectHelper.requireNonNull(mapper, &quot;mapper is null&quot;);</span>
<span class="fc" id="L15274">        return RxJavaPlugins.onAssembly(new FlowableSwitchMapMaybe&lt;T, R&gt;(this, mapper, false));</span>
    }

    /**
     * Maps the upstream items into {@link MaybeSource}s and switches (subscribes) to the newer ones
     * while disposing the older ones  (and ignoring their signals) and emits the latest success value of the current one if
     * available, delaying errors from this {@code Flowable} or the inner {@code MaybeSource}s until all terminate.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;350&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/switchMap.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream. The main {@code Flowable} is consumed in an
     *  unbounded manner (i.e., without backpressure).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code switchMapMaybeDelayError} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * &lt;p&gt;History: 2.1.11 - experimental
     * @param &lt;R&gt; the output value type
     * @param mapper the function called with the current upstream event and should
     *               return a {@code MaybeSource} to replace the current active inner source
     *               and get subscribed to.
     * @return the new Flowable instance
     * @see #switchMapMaybe(Function)
     * @since 2.2
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;R&gt; Flowable&lt;R&gt; switchMapMaybeDelayError(@NonNull Function&lt;? super T, ? extends MaybeSource&lt;? extends R&gt;&gt; mapper) {
<span class="fc" id="L15304">        ObjectHelper.requireNonNull(mapper, &quot;mapper is null&quot;);</span>
<span class="fc" id="L15305">        return RxJavaPlugins.onAssembly(new FlowableSwitchMapMaybe&lt;T, R&gt;(this, mapper, true));</span>
    }

    /**
     * Maps the upstream items into {@link SingleSource}s and switches (subscribes) to the newer ones
     * while disposing the older ones (and ignoring their signals) and emits the latest success value of the current one
     * while failing immediately if this {@code Flowable} or any of the
     * active inner {@code SingleSource}s fail.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;350&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/switchMap.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream. The main {@code Flowable} is consumed in an
     *  unbounded manner (i.e., without backpressure).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code switchMapSingle} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Error handling:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator terminates with an {@code onError} if this {@code Flowable} or any of
     *  the inner {@code SingleSource}s fail while they are active. When this happens concurrently, their
     *  individual {@code Throwable} errors may get combined and emitted as a single
     *  {@link io.reactivex.exceptions.CompositeException CompositeException}. Otherwise, a late
     *  (i.e., inactive or switched out) {@code onError} from this {@code Flowable} or from any of
     *  the inner {@code SingleSource}s will be forwarded to the global error handler via
     *  {@link io.reactivex.plugins.RxJavaPlugins#onError(Throwable)} as
     *  {@link io.reactivex.exceptions.UndeliverableException UndeliverableException}&lt;/dd&gt;
     * &lt;/dl&gt;
     * &lt;p&gt;History: 2.1.11 - experimental
     * @param &lt;R&gt; the output value type
     * @param mapper the function called with the current upstream event and should
     *               return a {@code SingleSource} to replace the current active inner source
     *               and get subscribed to.
     * @return the new Flowable instance
     * @see #switchMapSingle(Function)
     * @since 2.2
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;R&gt; Flowable&lt;R&gt; switchMapSingle(@NonNull Function&lt;? super T, ? extends SingleSource&lt;? extends R&gt;&gt; mapper) {
<span class="fc" id="L15345">        ObjectHelper.requireNonNull(mapper, &quot;mapper is null&quot;);</span>
<span class="fc" id="L15346">        return RxJavaPlugins.onAssembly(new FlowableSwitchMapSingle&lt;T, R&gt;(this, mapper, false));</span>
    }

    /**
     * Maps the upstream items into {@link SingleSource}s and switches (subscribes) to the newer ones
     * while disposing the older ones  (and ignoring their signals) and emits the latest success value of the current one,
     * delaying errors from this {@code Flowable} or the inner {@code SingleSource}s until all terminate.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;350&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/switchMap.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream. The main {@code Flowable} is consumed in an
     *  unbounded manner (i.e., without backpressure).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code switchMapSingleDelayError} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * &lt;p&gt;History: 2.1.11 - experimental
     * @param &lt;R&gt; the output value type
     * @param mapper the function called with the current upstream event and should
     *               return a {@code SingleSource} to replace the current active inner source
     *               and get subscribed to.
     * @return the new Flowable instance
     * @see #switchMapSingle(Function)
     * @since 2.2
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;R&gt; Flowable&lt;R&gt; switchMapSingleDelayError(@NonNull Function&lt;? super T, ? extends SingleSource&lt;? extends R&gt;&gt; mapper) {
<span class="fc" id="L15376">        ObjectHelper.requireNonNull(mapper, &quot;mapper is null&quot;);</span>
<span class="fc" id="L15377">        return RxJavaPlugins.onAssembly(new FlowableSwitchMapSingle&lt;T, R&gt;(this, mapper, true));</span>
    }

    /**
     * Returns a Flowable that emits only the first {@code count} items emitted by the source Publisher. If the source emits fewer than
     * {@code count} items then all of its items are emitted.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/take.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * This method returns a Publisher that will invoke a subscribing {@link Subscriber}'s
     * {@link Subscriber#onNext onNext} function a maximum of {@code count} times before invoking
     * {@link Subscriber#onComplete onComplete}.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure
     *  behavior in case the first request is smaller than the {@code count}. Otherwise, the source {@code Publisher}
     *  is consumed in an unbounded manner (i.e., without applying backpressure to it).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code take} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param count
     *            the maximum number of items to emit
     * @return a Flowable that emits only the first {@code count} items emitted by the source Publisher, or
     *         all of the items from the source Publisher if that Publisher emits fewer than {@code count} items
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/take.html&quot;&gt;ReactiveX operators documentation: Take&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.SPECIAL) // may trigger UNBOUNDED_IN
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;T&gt; take(long count) {
<span class="fc bfc" id="L15408" title="All 2 branches covered.">        if (count &lt; 0) {</span>
<span class="fc" id="L15409">            throw new IllegalArgumentException(&quot;count &gt;= 0 required but it was &quot; + count);</span>
        }
<span class="fc" id="L15411">        return RxJavaPlugins.onAssembly(new FlowableTake&lt;T&gt;(this, count));</span>
    }

    /**
     * Returns a Flowable that emits those items emitted by source Publisher before a specified time runs
     * out.
     * &lt;p&gt;
     * If time runs out before the {@code Flowable} completes normally, the {@code onComplete} event will be
     * signaled on the default {@code computation} {@link Scheduler}.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/take.t.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure
     *  behavior.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code take} operates by default on the {@code computation} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param time
     *            the length of the time window
     * @param unit
     *            the time unit of {@code time}
     * @return a Flowable that emits those items emitted by the source Publisher before the time runs out
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/take.html&quot;&gt;ReactiveX operators documentation: Take&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.COMPUTATION)
    public final Flowable&lt;T&gt; take(long time, TimeUnit unit) {
<span class="fc" id="L15441">        return takeUntil(timer(time, unit));</span>
    }

    /**
     * Returns a Flowable that emits those items emitted by source Publisher before a specified time (on a
     * specified Scheduler) runs out.
     * &lt;p&gt;
     * If time runs out before the {@code Flowable} completes normally, the {@code onComplete} event will be
     * signaled on the provided {@link Scheduler}.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/take.ts.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure
     *  behavior.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;You specify which {@link Scheduler} this operator will use.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param time
     *            the length of the time window
     * @param unit
     *            the time unit of {@code time}
     * @param scheduler
     *            the Scheduler used for time source
     * @return a Flowable that emits those items emitted by the source Publisher before the time runs out,
     *         according to the specified Scheduler
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/take.html&quot;&gt;ReactiveX operators documentation: Take&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Flowable&lt;T&gt; take(long time, TimeUnit unit, Scheduler scheduler) {
<span class="fc" id="L15474">        return takeUntil(timer(time, unit, scheduler));</span>
    }

    /**
     * Returns a Flowable that emits at most the last {@code count} items emitted by the source Publisher. If the source emits fewer than
     * {@code count} items then all of its items are emitted.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/takeLast.n.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream if the {@code count} is non-zero; ignores
     *  backpressure if the {@code count} is zero as it doesn't signal any values.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code takeLast} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param count
     *            the maximum number of items to emit from the end of the sequence of items emitted by the source
     *            Publisher
     * @return a Flowable that emits at most the last {@code count} items emitted by the source Publisher
     * @throws IndexOutOfBoundsException
     *             if {@code count} is less than zero
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/takelast.html&quot;&gt;ReactiveX operators documentation: TakeLast&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;T&gt; takeLast(int count) {
<span class="fc bfc" id="L15502" title="All 2 branches covered.">        if (count &lt; 0) {</span>
<span class="fc" id="L15503">            throw new IndexOutOfBoundsException(&quot;count &gt;= 0 required but it was &quot; + count);</span>
        } else
<span class="fc bfc" id="L15505" title="All 2 branches covered.">        if (count == 0) {</span>
<span class="fc" id="L15506">            return RxJavaPlugins.onAssembly(new FlowableIgnoreElements&lt;T&gt;(this));</span>
        } else
<span class="fc bfc" id="L15508" title="All 2 branches covered.">        if (count == 1) {</span>
<span class="fc" id="L15509">            return RxJavaPlugins.onAssembly(new FlowableTakeLastOne&lt;T&gt;(this));</span>
        }
<span class="fc" id="L15511">        return RxJavaPlugins.onAssembly(new FlowableTakeLast&lt;T&gt;(this, count));</span>
    }

    /**
     * Returns a Flowable that emits at most a specified number of items from the source Publisher that were
     * emitted in a specified window of time before the Publisher completed.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/takeLast.tn.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream and consumes the source {@code Publisher} in an
     *  unbounded manner (i.e., no backpressure is applied to it).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code takeLast} does not operate on any particular scheduler but uses the current time
     *  from the {@code computation} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param count
     *            the maximum number of items to emit
     * @param time
     *            the length of the time window
     * @param unit
     *            the time unit of {@code time}
     * @return a Flowable that emits at most {@code count} items from the source Publisher that were emitted
     *         in a specified window of time before the Publisher completed
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/takelast.html&quot;&gt;ReactiveX operators documentation: TakeLast&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;T&gt; takeLast(long count, long time, TimeUnit unit) {
<span class="fc" id="L15542">        return takeLast(count, time, unit, Schedulers.computation(), false, bufferSize());</span>
    }

    /**
     * Returns a Flowable that emits at most a specified number of items from the source Publisher that were
     * emitted in a specified window of time before the Publisher completed, where the timing information is
     * provided by a given Scheduler.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/takeLast.tns.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream and consumes the source {@code Publisher} in an
     *  unbounded manner (i.e., no backpressure is applied to it).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;You specify which {@link Scheduler} this operator will use for tracking the current time&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param count
     *            the maximum number of items to emit
     * @param time
     *            the length of the time window
     * @param unit
     *            the time unit of {@code time}
     * @param scheduler
     *            the {@link Scheduler} that provides the timestamps for the observed items
     * @return a Flowable that emits at most {@code count} items from the source Publisher that were emitted
     *         in a specified window of time before the Publisher completed, where the timing information is
     *         provided by the given {@code scheduler}
     * @throws IndexOutOfBoundsException
     *             if {@code count} is less than zero
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/takelast.html&quot;&gt;ReactiveX operators documentation: TakeLast&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Flowable&lt;T&gt; takeLast(long count, long time, TimeUnit unit, Scheduler scheduler) {
<span class="fc" id="L15578">        return takeLast(count, time, unit, scheduler, false, bufferSize());</span>
    }

    /**
     * Returns a Flowable that emits at most a specified number of items from the source Publisher that were
     * emitted in a specified window of time before the Publisher completed, where the timing information is
     * provided by a given Scheduler.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/takeLast.tns.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream and consumes the source {@code Publisher} in an
     *  unbounded manner (i.e., no backpressure is applied to it).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;You specify which {@link Scheduler} this operator will use for tracking the current time&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param count
     *            the maximum number of items to emit
     * @param time
     *            the length of the time window
     * @param unit
     *            the time unit of {@code time}
     * @param scheduler
     *            the {@link Scheduler} that provides the timestamps for the observed items
     * @param delayError
     *            if true, an exception signaled by the current Flowable is delayed until the regular elements are consumed
     *            by the downstream; if false, an exception is immediately signaled and all regular elements dropped
     * @param bufferSize
     *            the hint about how many elements to expect to be last
     * @return a Flowable that emits at most {@code count} items from the source Publisher that were emitted
     *         in a specified window of time before the Publisher completed, where the timing information is
     *         provided by the given {@code scheduler}
     * @throws IndexOutOfBoundsException
     *             if {@code count} is less than zero
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/takelast.html&quot;&gt;ReactiveX operators documentation: TakeLast&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Flowable&lt;T&gt; takeLast(long count, long time, TimeUnit unit, Scheduler scheduler, boolean delayError, int bufferSize) {
<span class="fc" id="L15620">        ObjectHelper.requireNonNull(unit, &quot;unit is null&quot;);</span>
<span class="fc" id="L15621">        ObjectHelper.requireNonNull(scheduler, &quot;scheduler is null&quot;);</span>
<span class="fc" id="L15622">        ObjectHelper.verifyPositive(bufferSize, &quot;bufferSize&quot;);</span>
<span class="fc bfc" id="L15623" title="All 2 branches covered.">        if (count &lt; 0) {</span>
<span class="fc" id="L15624">            throw new IndexOutOfBoundsException(&quot;count &gt;= 0 required but it was &quot; + count);</span>
        }
<span class="fc" id="L15626">        return RxJavaPlugins.onAssembly(new FlowableTakeLastTimed&lt;T&gt;(this, count, time, unit, scheduler, bufferSize, delayError));</span>
    }

    /**
     * Returns a Flowable that emits the items from the source Publisher that were emitted in a specified
     * window of time before the Publisher completed.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/takeLast.t.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream and consumes the source {@code Publisher} in an
     *  unbounded manner (i.e., no backpressure is applied to it) but note that this &lt;em&gt;may&lt;/em&gt;
     *  lead to {@code OutOfMemoryError} due to internal buffer bloat.
     *  Consider using {@link #takeLast(long, long, TimeUnit)} in this case.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code takeLast} operates by default on the {@code computation} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param time
     *            the length of the time window
     * @param unit
     *            the time unit of {@code time}
     * @return a Flowable that emits the items from the source Publisher that were emitted in the window of
     *         time before the Publisher completed specified by {@code time}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/takelast.html&quot;&gt;ReactiveX operators documentation: TakeLast&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.COMPUTATION)
    public final Flowable&lt;T&gt; takeLast(long time, TimeUnit unit) {
<span class="fc" id="L15656">        return takeLast(time, unit, Schedulers.computation(), false, bufferSize());</span>
    }

    /**
     * Returns a Flowable that emits the items from the source Publisher that were emitted in a specified
     * window of time before the Publisher completed.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/takeLast.t.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream and consumes the source {@code Publisher} in an
     *  unbounded manner (i.e., no backpressure is applied to it) but note that this &lt;em&gt;may&lt;/em&gt;
     *  lead to {@code OutOfMemoryError} due to internal buffer bloat.
     *  Consider using {@link #takeLast(long, long, TimeUnit)} in this case.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code takeLast} operates by default on the {@code computation} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param time
     *            the length of the time window
     * @param unit
     *            the time unit of {@code time}
     * @param delayError
     *            if true, an exception signaled by the current Flowable is delayed until the regular elements are consumed
     *            by the downstream; if false, an exception is immediately signaled and all regular elements dropped
     * @return a Flowable that emits the items from the source Publisher that were emitted in the window of
     *         time before the Publisher completed specified by {@code time}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/takelast.html&quot;&gt;ReactiveX operators documentation: TakeLast&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.COMPUTATION)
    public final Flowable&lt;T&gt; takeLast(long time, TimeUnit unit, boolean delayError) {
<span class="fc" id="L15689">        return takeLast(time, unit, Schedulers.computation(), delayError, bufferSize());</span>
    }

    /**
     * Returns a Flowable that emits the items from the source Publisher that were emitted in a specified
     * window of time before the Publisher completed, where the timing information is provided by a specified
     * Scheduler.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/takeLast.ts.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream and consumes the source {@code Publisher} in an
     *  unbounded manner (i.e., no backpressure is applied to it) but note that this &lt;em&gt;may&lt;/em&gt;
     *  lead to {@code OutOfMemoryError} due to internal buffer bloat.
     *  Consider using {@link #takeLast(long, long, TimeUnit, Scheduler)} in this case.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;You specify which {@link Scheduler} this operator will use.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param time
     *            the length of the time window
     * @param unit
     *            the time unit of {@code time}
     * @param scheduler
     *            the Scheduler that provides the timestamps for the Observed items
     * @return a Flowable that emits the items from the source Publisher that were emitted in the window of
     *         time before the Publisher completed specified by {@code time}, where the timing information is
     *         provided by {@code scheduler}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/takelast.html&quot;&gt;ReactiveX operators documentation: TakeLast&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Flowable&lt;T&gt; takeLast(long time, TimeUnit unit, Scheduler scheduler) {
<span class="fc" id="L15723">        return takeLast(time, unit, scheduler, false, bufferSize());</span>
    }

    /**
     * Returns a Flowable that emits the items from the source Publisher that were emitted in a specified
     * window of time before the Publisher completed, where the timing information is provided by a specified
     * Scheduler.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/takeLast.ts.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream and consumes the source {@code Publisher} in an
     *  unbounded manner (i.e., no backpressure is applied to it) but note that this &lt;em&gt;may&lt;/em&gt;
     *  lead to {@code OutOfMemoryError} due to internal buffer bloat.
     *  Consider using {@link #takeLast(long, long, TimeUnit, Scheduler)} in this case.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;You specify which {@link Scheduler} this operator will use.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param time
     *            the length of the time window
     * @param unit
     *            the time unit of {@code time}
     * @param scheduler
     *            the Scheduler that provides the timestamps for the Observed items
     * @param delayError
     *            if true, an exception signaled by the current Flowable is delayed until the regular elements are consumed
     *            by the downstream; if false, an exception is immediately signaled and all regular elements dropped
     * @return a Flowable that emits the items from the source Publisher that were emitted in the window of
     *         time before the Publisher completed specified by {@code time}, where the timing information is
     *         provided by {@code scheduler}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/takelast.html&quot;&gt;ReactiveX operators documentation: TakeLast&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Flowable&lt;T&gt; takeLast(long time, TimeUnit unit, Scheduler scheduler, boolean delayError) {
<span class="fc" id="L15760">        return takeLast(time, unit, scheduler, delayError, bufferSize());</span>
    }

    /**
     * Returns a Flowable that emits the items from the source Publisher that were emitted in a specified
     * window of time before the Publisher completed, where the timing information is provided by a specified
     * Scheduler.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/takeLast.ts.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream and consumes the source {@code Publisher} in an
     *  unbounded manner (i.e., no backpressure is applied to it) but note that this &lt;em&gt;may&lt;/em&gt;
     *  lead to {@code OutOfMemoryError} due to internal buffer bloat.
     *  Consider using {@link #takeLast(long, long, TimeUnit, Scheduler)} in this case.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;You specify which {@link Scheduler} this operator will use.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param time
     *            the length of the time window
     * @param unit
     *            the time unit of {@code time}
     * @param scheduler
     *            the Scheduler that provides the timestamps for the Observed items
     * @param delayError
     *            if true, an exception signaled by the current Flowable is delayed until the regular elements are consumed
     *            by the downstream; if false, an exception is immediately signaled and all regular elements dropped
     * @param bufferSize
     *            the hint about how many elements to expect to be last
     * @return a Flowable that emits the items from the source Publisher that were emitted in the window of
     *         time before the Publisher completed specified by {@code time}, where the timing information is
     *         provided by {@code scheduler}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/takelast.html&quot;&gt;ReactiveX operators documentation: TakeLast&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Flowable&lt;T&gt; takeLast(long time, TimeUnit unit, Scheduler scheduler, boolean delayError, int bufferSize) {
<span class="fc" id="L15799">        return takeLast(Long.MAX_VALUE, time, unit, scheduler, delayError, bufferSize);</span>
    }

    /**
     * Returns a Flowable that emits items emitted by the source Publisher, checks the specified predicate
     * for each item, and then completes when the condition is satisfied.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/takeUntil.p.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * The difference between this operator and {@link #takeWhile(Predicate)} is that here, the condition is
     * evaluated &lt;em&gt;after&lt;/em&gt; the item is emitted.
     *
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator is a pass-through for backpressure; the backpressure behavior is determined by the upstream
     *  source and the downstream consumer.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code takeUntil} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param stopPredicate
     *            a function that evaluates an item emitted by the source Publisher and returns a Boolean
     * @return a Flowable that first emits items emitted by the source Publisher, checks the specified
     *         condition after each item, and then completes when the condition is satisfied.
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/takeuntil.html&quot;&gt;ReactiveX operators documentation: TakeUntil&lt;/a&gt;
     * @see Flowable#takeWhile(Predicate)
     * @since 1.1.0
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;T&gt; takeUntil(Predicate&lt;? super T&gt; stopPredicate) {
<span class="fc" id="L15832">        ObjectHelper.requireNonNull(stopPredicate, &quot;stopPredicate is null&quot;);</span>
<span class="fc" id="L15833">        return RxJavaPlugins.onAssembly(new FlowableTakeUntilPredicate&lt;T&gt;(this, stopPredicate));</span>
    }

    /**
     * Returns a Flowable that emits the items emitted by the source Publisher until a second Publisher
     * emits an item.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/takeUntil.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure
     *  behavior.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code takeUntil} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param other
     *            the Publisher whose first emitted item will cause {@code takeUntil} to stop emitting items
     *            from the source Publisher
     * @param &lt;U&gt;
     *            the type of items emitted by {@code other}
     * @return a Flowable that emits the items emitted by the source Publisher until such time as {@code other} emits its first item
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/takeuntil.html&quot;&gt;ReactiveX operators documentation: TakeUntil&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;U&gt; Flowable&lt;T&gt; takeUntil(Publisher&lt;U&gt; other) {
<span class="fc" id="L15862">        ObjectHelper.requireNonNull(other, &quot;other is null&quot;);</span>
<span class="fc" id="L15863">        return RxJavaPlugins.onAssembly(new FlowableTakeUntil&lt;T, U&gt;(this, other));</span>
    }

    /**
     * Returns a Flowable that emits items emitted by the source Publisher so long as each item satisfied a
     * specified condition, and then completes as soon as this condition is not satisfied.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/takeWhile.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure
     *  behavior.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code takeWhile} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param predicate
     *            a function that evaluates an item emitted by the source Publisher and returns a Boolean
     * @return a Flowable that emits the items from the source Publisher so long as each item satisfies the
     *         condition defined by {@code predicate}, then completes
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/takewhile.html&quot;&gt;ReactiveX operators documentation: TakeWhile&lt;/a&gt;
     * @see Flowable#takeUntil(Predicate)
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;T&gt; takeWhile(Predicate&lt;? super T&gt; predicate) {
<span class="fc" id="L15891">        ObjectHelper.requireNonNull(predicate, &quot;predicate is null&quot;);</span>
<span class="fc" id="L15892">        return RxJavaPlugins.onAssembly(new FlowableTakeWhile&lt;T&gt;(this, predicate));</span>
    }

    /**
     * Returns a Flowable that emits only the first item emitted by the source Publisher during sequential
     * time windows of a specified duration.
     * &lt;p&gt;
     * This differs from {@link #throttleLast} in that this only tracks the passage of time whereas
     * {@link #throttleLast} ticks at scheduled intervals.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/throttleFirst.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not support backpressure as it uses time to control data flow.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code throttleFirst} operates by default on the {@code computation} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param windowDuration
     *            time to wait before emitting another item after emitting the last item
     * @param unit
     *            the unit of time of {@code windowDuration}
     * @return a Flowable that performs the throttle operation
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/sample.html&quot;&gt;ReactiveX operators documentation: Sample&lt;/a&gt;
     * @see &lt;a href=&quot;https://github.com/ReactiveX/RxJava/wiki/Backpressure&quot;&gt;RxJava wiki: Backpressure&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.COMPUTATION)
    public final Flowable&lt;T&gt; throttleFirst(long windowDuration, TimeUnit unit) {
<span class="fc" id="L15922">        return throttleFirst(windowDuration, unit, Schedulers.computation());</span>
    }

    /**
     * Returns a Flowable that emits only the first item emitted by the source Publisher during sequential
     * time windows of a specified duration, where the windows are managed by a specified Scheduler.
     * &lt;p&gt;
     * This differs from {@link #throttleLast} in that this only tracks the passage of time whereas
     * {@link #throttleLast} ticks at scheduled intervals.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/throttleFirst.s.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not support backpressure as it uses time to control data flow.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;You specify which {@link Scheduler} this operator will use.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param skipDuration
     *            time to wait before emitting another item after emitting the last item
     * @param unit
     *            the unit of time of {@code skipDuration}
     * @param scheduler
     *            the {@link Scheduler} to use internally to manage the timers that handle timeout for each
     *            event
     * @return a Flowable that performs the throttle operation
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/sample.html&quot;&gt;ReactiveX operators documentation: Sample&lt;/a&gt;
     * @see &lt;a href=&quot;https://github.com/ReactiveX/RxJava/wiki/Backpressure&quot;&gt;RxJava wiki: Backpressure&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Flowable&lt;T&gt; throttleFirst(long skipDuration, TimeUnit unit, Scheduler scheduler) {
<span class="fc" id="L15956">        ObjectHelper.requireNonNull(unit, &quot;unit is null&quot;);</span>
<span class="fc" id="L15957">        ObjectHelper.requireNonNull(scheduler, &quot;scheduler is null&quot;);</span>
<span class="fc" id="L15958">        return RxJavaPlugins.onAssembly(new FlowableThrottleFirstTimed&lt;T&gt;(this, skipDuration, unit, scheduler));</span>
    }

    /**
     * Returns a Flowable that emits only the last item emitted by the source Publisher during sequential
     * time windows of a specified duration.
     * &lt;p&gt;
     * This differs from {@link #throttleFirst} in that this ticks along at a scheduled interval whereas
     * {@link #throttleFirst} does not tick, it just tracks the passage of time.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/throttleLast.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not support backpressure as it uses time to control data flow.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code throttleLast} operates by default on the {@code computation} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param intervalDuration
     *            duration of windows within which the last item emitted by the source Publisher will be
     *            emitted
     * @param unit
     *            the unit of time of {@code intervalDuration}
     * @return a Flowable that performs the throttle operation
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/sample.html&quot;&gt;ReactiveX operators documentation: Sample&lt;/a&gt;
     * @see &lt;a href=&quot;https://github.com/ReactiveX/RxJava/wiki/Backpressure&quot;&gt;RxJava wiki: Backpressure&lt;/a&gt;
     * @see #sample(long, TimeUnit)
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.COMPUTATION)
    public final Flowable&lt;T&gt; throttleLast(long intervalDuration, TimeUnit unit) {
<span class="fc" id="L15990">        return sample(intervalDuration, unit);</span>
    }

    /**
     * Returns a Flowable that emits only the last item emitted by the source Publisher during sequential
     * time windows of a specified duration, where the duration is governed by a specified Scheduler.
     * &lt;p&gt;
     * This differs from {@link #throttleFirst} in that this ticks along at a scheduled interval whereas
     * {@link #throttleFirst} does not tick, it just tracks the passage of time.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/throttleLast.s.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not support backpressure as it uses time to control data flow.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;You specify which {@link Scheduler} this operator will use.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param intervalDuration
     *            duration of windows within which the last item emitted by the source Publisher will be
     *            emitted
     * @param unit
     *            the unit of time of {@code intervalDuration}
     * @param scheduler
     *            the {@link Scheduler} to use internally to manage the timers that handle timeout for each
     *            event
     * @return a Flowable that performs the throttle operation
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/sample.html&quot;&gt;ReactiveX operators documentation: Sample&lt;/a&gt;
     * @see &lt;a href=&quot;https://github.com/ReactiveX/RxJava/wiki/Backpressure&quot;&gt;RxJava wiki: Backpressure&lt;/a&gt;
     * @see #sample(long, TimeUnit, Scheduler)
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Flowable&lt;T&gt; throttleLast(long intervalDuration, TimeUnit unit, Scheduler scheduler) {
<span class="fc" id="L16025">        return sample(intervalDuration, unit, scheduler);</span>
    }

    /**
     * Throttles items from the upstream {@code Flowable} by first emitting the next
     * item from upstream, then periodically emitting the latest item (if any) when
     * the specified timeout elapses between them.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;325&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/throttleLatest.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * Unlike the option with {@link #throttleLatest(long, TimeUnit, boolean)}, the very last item being held back
     * (if any) is not emitted when the upstream completes.
     * &lt;p&gt;
     * If no items were emitted from the upstream during this timeout phase, the next
     * upstream item is emitted immediately and the timeout window starts from then.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not support backpressure as it uses time to control data flow.
     *  If the downstream is not ready to receive items, a
     *  {@link io.reactivex.exceptions.MissingBackpressureException MissingBackpressureException}
     *  will be signaled.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code throttleLatest} operates by default on the {@code computation} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * &lt;p&gt;History: 2.1.14 - experimental
     * @param timeout the time to wait after an item emission towards the downstream
     *                before trying to emit the latest item from upstream again
     * @param unit    the time unit
     * @return the new Flowable instance
     * @since 2.2
     * @see #throttleLatest(long, TimeUnit, boolean)
     * @see #throttleLatest(long, TimeUnit, Scheduler)
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.COMPUTATION)
    public final Flowable&lt;T&gt; throttleLatest(long timeout, TimeUnit unit) {
<span class="fc" id="L16062">        return throttleLatest(timeout, unit, Schedulers.computation(), false);</span>
    }

    /**
     * Throttles items from the upstream {@code Flowable} by first emitting the next
     * item from upstream, then periodically emitting the latest item (if any) when
     * the specified timeout elapses between them.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;325&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/throttleLatest.e.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * If no items were emitted from the upstream during this timeout phase, the next
     * upstream item is emitted immediately and the timeout window starts from then.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not support backpressure as it uses time to control data flow.
     *  If the downstream is not ready to receive items, a
     *  {@link io.reactivex.exceptions.MissingBackpressureException MissingBackpressureException}
     *  will be signaled.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code throttleLatest} operates by default on the {@code computation} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * &lt;p&gt;History: 2.1.14 - experimental
     * @param timeout the time to wait after an item emission towards the downstream
     *                before trying to emit the latest item from upstream again
     * @param unit    the time unit
     * @param emitLast If {@code true}, the very last item from the upstream will be emitted
     *                 immediately when the upstream completes, regardless if there is
     *                 a timeout window active or not. If {@code false}, the very last
     *                 upstream item is ignored and the flow terminates.
     * @return the new Flowable instance
     * @see #throttleLatest(long, TimeUnit, Scheduler, boolean)
     * @since 2.2
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.COMPUTATION)
    public final Flowable&lt;T&gt; throttleLatest(long timeout, TimeUnit unit, boolean emitLast) {
<span class="fc" id="L16099">        return throttleLatest(timeout, unit, Schedulers.computation(), emitLast);</span>
    }

    /**
     * Throttles items from the upstream {@code Flowable} by first emitting the next
     * item from upstream, then periodically emitting the latest item (if any) when
     * the specified timeout elapses between them.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;325&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/throttleLatest.s.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * Unlike the option with {@link #throttleLatest(long, TimeUnit, Scheduler, boolean)}, the very last item being held back
     * (if any) is not emitted when the upstream completes.
     * &lt;p&gt;
     * If no items were emitted from the upstream during this timeout phase, the next
     * upstream item is emitted immediately and the timeout window starts from then.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not support backpressure as it uses time to control data flow.
     *  If the downstream is not ready to receive items, a
     *  {@link io.reactivex.exceptions.MissingBackpressureException MissingBackpressureException}
     *  will be signaled.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;You specify which {@link Scheduler} this operator will use.&lt;/dd&gt;
     * &lt;/dl&gt;
     * &lt;p&gt;History: 2.1.14 - experimental
     * @param timeout the time to wait after an item emission towards the downstream
     *                before trying to emit the latest item from upstream again
     * @param unit    the time unit
     * @param scheduler the {@link Scheduler} where the timed wait and latest item
     *                  emission will be performed
     * @return the new Flowable instance
     * @see #throttleLatest(long, TimeUnit, Scheduler, boolean)
     * @since 2.2
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Flowable&lt;T&gt; throttleLatest(long timeout, TimeUnit unit, Scheduler scheduler) {
<span class="fc" id="L16137">        return throttleLatest(timeout, unit, scheduler, false);</span>
    }

    /**
     * Throttles items from the upstream {@code Flowable} by first emitting the next
     * item from upstream, then periodically emitting the latest item (if any) when
     * the specified timeout elapses between them.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;325&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/throttleLatest.se.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * If no items were emitted from the upstream during this timeout phase, the next
     * upstream item is emitted immediately and the timeout window starts from then.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not support backpressure as it uses time to control data flow.
     *  If the downstream is not ready to receive items, a
     *  {@link io.reactivex.exceptions.MissingBackpressureException MissingBackpressureException}
     *  will be signaled.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;You specify which {@link Scheduler} this operator will use.&lt;/dd&gt;
     * &lt;/dl&gt;
     * &lt;p&gt;History: 2.1.14 - experimental
     * @param timeout the time to wait after an item emission towards the downstream
     *                before trying to emit the latest item from upstream again
     * @param unit    the time unit
     * @param scheduler the {@link Scheduler} where the timed wait and latest item
     *                  emission will be performed
     * @param emitLast If {@code true}, the very last item from the upstream will be emitted
     *                 immediately when the upstream completes, regardless if there is
     *                 a timeout window active or not. If {@code false}, the very last
     *                 upstream item is ignored and the flow terminates.
     * @return the new Flowable instance
     * @since 2.2
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Flowable&lt;T&gt; throttleLatest(long timeout, TimeUnit unit, Scheduler scheduler, boolean emitLast) {
<span class="fc" id="L16176">        ObjectHelper.requireNonNull(unit, &quot;unit is null&quot;);</span>
<span class="fc" id="L16177">        ObjectHelper.requireNonNull(scheduler, &quot;scheduler is null&quot;);</span>
<span class="fc" id="L16178">        return RxJavaPlugins.onAssembly(new FlowableThrottleLatest&lt;T&gt;(this, timeout, unit, scheduler, emitLast));</span>
    }

    /**
     * Returns a Flowable that mirrors the source Publisher, except that it drops items emitted by the
     * source Publisher that are followed by newer items before a timeout value expires. The timer resets on
     * each emission (alias to {@link #debounce(long, TimeUnit)}).
     * &lt;p&gt;
     * &lt;em&gt;Note:&lt;/em&gt; If items keep being emitted by the source Publisher faster than the timeout then no items
     * will be emitted by the resulting Publisher.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/throttleWithTimeout.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not support backpressure as it uses time to control data flow.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code throttleWithTimeout} operates by default on the {@code computation} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param timeout
     *            the length of the window of time that must pass after the emission of an item from the source
     *            Publisher in which that Publisher emits no items in order for the item to be emitted by the
     *            resulting Publisher
     * @param unit
     *            the unit of time for the specified {@code timeout}
     * @return a Flowable that filters out items from the source Publisher that are too quickly followed by
     *         newer items
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/debounce.html&quot;&gt;ReactiveX operators documentation: Debounce&lt;/a&gt;
     * @see &lt;a href=&quot;https://github.com/ReactiveX/RxJava/wiki/Backpressure&quot;&gt;RxJava wiki: Backpressure&lt;/a&gt;
     * @see #debounce(long, TimeUnit)
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.COMPUTATION)
    public final Flowable&lt;T&gt; throttleWithTimeout(long timeout, TimeUnit unit) {
<span class="fc" id="L16213">        return debounce(timeout, unit);</span>
    }

    /**
     * Returns a Flowable that mirrors the source Publisher, except that it drops items emitted by the
     * source Publisher that are followed by newer items before a timeout value expires on a specified
     * Scheduler. The timer resets on each emission (alias to {@link #debounce(long, TimeUnit, Scheduler)}).
     * &lt;p&gt;
     * &lt;em&gt;Note:&lt;/em&gt; If items keep being emitted by the source Publisher faster than the timeout then no items
     * will be emitted by the resulting Publisher.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/throttleWithTimeout.s.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not support backpressure as it uses time to control data flow.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;You specify which {@link Scheduler} this operator will use.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param timeout
     *            the length of the window of time that must pass after the emission of an item from the source
     *            Publisher in which that Publisher emits no items in order for the item to be emitted by the
     *            resulting Publisher
     * @param unit
     *            the unit of time for the specified {@code timeout}
     * @param scheduler
     *            the {@link Scheduler} to use internally to manage the timers that handle the timeout for each
     *            item
     * @return a Flowable that filters out items from the source Publisher that are too quickly followed by
     *         newer items
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/debounce.html&quot;&gt;ReactiveX operators documentation: Debounce&lt;/a&gt;
     * @see &lt;a href=&quot;https://github.com/ReactiveX/RxJava/wiki/Backpressure&quot;&gt;RxJava wiki: Backpressure&lt;/a&gt;
     * @see #debounce(long, TimeUnit, Scheduler)
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Flowable&lt;T&gt; throttleWithTimeout(long timeout, TimeUnit unit, Scheduler scheduler) {
<span class="fc" id="L16251">        return debounce(timeout, unit, scheduler);</span>
    }

    /**
     * Returns a Flowable that emits records of the time interval between consecutive items emitted by the
     * source Publisher.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/timeInterval.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure
     *  behavior.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code timeInterval} does not operate on any particular scheduler but uses the current time
     *  from the {@code computation} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @return a Flowable that emits time interval information items
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/timeinterval.html&quot;&gt;ReactiveX operators documentation: TimeInterval&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;Timed&lt;T&gt;&gt; timeInterval() {
<span class="fc" id="L16275">        return timeInterval(TimeUnit.MILLISECONDS, Schedulers.computation());</span>
    }

    /**
     * Returns a Flowable that emits records of the time interval between consecutive items emitted by the
     * source Publisher, where this interval is computed on a specified Scheduler.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;315&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/timeInterval.s.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure
     *  behavior.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator does not operate on any particular scheduler but uses the current time
     *  from the specified {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param scheduler
     *            the {@link Scheduler} used to compute time intervals
     * @return a Flowable that emits time interval information items
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/timeinterval.html&quot;&gt;ReactiveX operators documentation: TimeInterval&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.NONE) // Supplied scheduler is only used for creating timestamps.
    public final Flowable&lt;Timed&lt;T&gt;&gt; timeInterval(Scheduler scheduler) {
<span class="fc" id="L16301">        return timeInterval(TimeUnit.MILLISECONDS, scheduler);</span>
    }

    /**
     * Returns a Flowable that emits records of the time interval between consecutive items emitted by the
     * source Publisher.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/timeInterval.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure
     *  behavior.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code timeInterval} does not operate on any particular scheduler but uses the current time
     *  from the {@code computation} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param unit the time unit for the current time
     * @return a Flowable that emits time interval information items
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/timeinterval.html&quot;&gt;ReactiveX operators documentation: TimeInterval&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;Timed&lt;T&gt;&gt; timeInterval(TimeUnit unit) {
<span class="fc" id="L16326">        return timeInterval(unit, Schedulers.computation());</span>
    }

    /**
     * Returns a Flowable that emits records of the time interval between consecutive items emitted by the
     * source Publisher, where this interval is computed on a specified Scheduler.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;315&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/timeInterval.s.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure
     *  behavior.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator does not operate on any particular scheduler but uses the current time
     *  from the specified {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param unit the time unit for the current time
     * @param scheduler
     *            the {@link Scheduler} used to compute time intervals
     * @return a Flowable that emits time interval information items
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/timeinterval.html&quot;&gt;ReactiveX operators documentation: TimeInterval&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.NONE) // Supplied scheduler is only used for creating timestamps.
    public final Flowable&lt;Timed&lt;T&gt;&gt; timeInterval(TimeUnit unit, Scheduler scheduler) {
<span class="fc" id="L16353">        ObjectHelper.requireNonNull(unit, &quot;unit is null&quot;);</span>
<span class="fc" id="L16354">        ObjectHelper.requireNonNull(scheduler, &quot;scheduler is null&quot;);</span>
<span class="fc" id="L16355">        return RxJavaPlugins.onAssembly(new FlowableTimeInterval&lt;T&gt;(this, unit, scheduler));</span>
    }

    /**
     * Returns a Flowable that mirrors the source Publisher, but notifies Subscribers of a
     * {@code TimeoutException} if an item emitted by the source Publisher doesn't arrive within a window of
     * time after the emission of the previous item, where that period of time is measured by a Publisher that
     * is a function of the previous item.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;400&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/timeout3.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * Note: The arrival of the first source item is never timed out.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream. The {@code Publisher}
     *  sources are expected to honor backpressure as well.
     *  If any of the source {@code Publisher}s violate this, it &lt;em&gt;may&lt;/em&gt; throw an
     *  {@code IllegalStateException} when the source {@code Publisher} completes.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code timeout} operates by default on the {@code immediate} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;V&gt;
     *            the timeout value type (ignored)
     * @param itemTimeoutIndicator
     *            a function that returns a Publisher for each item emitted by the source
     *            Publisher and that determines the timeout window for the subsequent item
     * @return a Flowable that mirrors the source Publisher, but notifies Subscribers of a
     *         {@code TimeoutException} if an item emitted by the source Publisher takes longer to arrive than
     *         the time window defined by the selector for the previously emitted item
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/timeout.html&quot;&gt;ReactiveX operators documentation: Timeout&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;V&gt; Flowable&lt;T&gt; timeout(Function&lt;? super T, ? extends Publisher&lt;V&gt;&gt; itemTimeoutIndicator) {
<span class="fc" id="L16391">        return timeout0(null, itemTimeoutIndicator, null);</span>
    }

    /**
     * Returns a Flowable that mirrors the source Publisher, but that switches to a fallback Publisher if
     * an item emitted by the source Publisher doesn't arrive within a window of time after the emission of the
     * previous item, where that period of time is measured by a Publisher that is a function of the previous
     * item.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;400&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/timeout4.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * Note: The arrival of the first source item is never timed out.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream. The {@code Publisher}
     *  sources are expected to honor backpressure as well.
     *  If any of the source {@code Publisher}s violate this, it &lt;em&gt;may&lt;/em&gt; throw an
     *  {@code IllegalStateException} when the source {@code Publisher} completes.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code timeout} operates by default on the {@code immediate} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;V&gt;
     *            the timeout value type (ignored)
     * @param itemTimeoutIndicator
     *            a function that returns a Publisher, for each item emitted by the source Publisher, that
     *            determines the timeout window for the subsequent item
     * @param other
     *            the fallback Publisher to switch to if the source Publisher times out
     * @return a Flowable that mirrors the source Publisher, but switches to mirroring a fallback Publisher
     *         if an item emitted by the source Publisher takes longer to arrive than the time window defined
     *         by the selector for the previously emitted item
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/timeout.html&quot;&gt;ReactiveX operators documentation: Timeout&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;V&gt; Flowable&lt;T&gt; timeout(Function&lt;? super T, ? extends Publisher&lt;V&gt;&gt; itemTimeoutIndicator, Flowable&lt;? extends T&gt; other) {
<span class="fc" id="L16430">        ObjectHelper.requireNonNull(other, &quot;other is null&quot;);</span>
<span class="fc" id="L16431">        return timeout0(null, itemTimeoutIndicator, other);</span>
    }

    /**
     * Returns a Flowable that mirrors the source Publisher but applies a timeout policy for each emitted
     * item. If the next item isn't emitted within the specified timeout duration starting from its predecessor,
     * the resulting Publisher terminates and notifies Subscribers of a {@code TimeoutException}.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/timeout.1.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure
     *  behavior.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code timeout} operates by default on the {@code computation} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param timeout
     *            maximum duration between emitted items before a timeout occurs
     * @param timeUnit
     *            the unit of time that applies to the {@code timeout} argument.
     * @return the source Publisher modified to notify Subscribers of a {@code TimeoutException} in case of a
     *         timeout
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/timeout.html&quot;&gt;ReactiveX operators documentation: Timeout&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.COMPUTATION)
    public final Flowable&lt;T&gt; timeout(long timeout, TimeUnit timeUnit) {
<span class="fc" id="L16460">        return timeout0(timeout, timeUnit, null, Schedulers.computation());</span>
    }

    /**
     * Returns a Flowable that mirrors the source Publisher but applies a timeout policy for each emitted
     * item. If the next item isn't emitted within the specified timeout duration starting from its predecessor,
     * the source Publisher is disposed and resulting Publisher begins instead to mirror a fallback Publisher.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/timeout.2.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream. The {@code Publisher}
     *  sources are expected to honor backpressure as well.
     *  If any of the source {@code Publisher}s violate this, it &lt;em&gt;may&lt;/em&gt; throw an
     *  {@code IllegalStateException} when the source {@code Publisher} completes.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code timeout} operates by default on the {@code computation} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param timeout
     *            maximum duration between items before a timeout occurs
     * @param timeUnit
     *            the unit of time that applies to the {@code timeout} argument
     * @param other
     *            the fallback Publisher to use in case of a timeout
     * @return the source Publisher modified to switch to the fallback Publisher in case of a timeout
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/timeout.html&quot;&gt;ReactiveX operators documentation: Timeout&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.COMPUTATION)
    public final Flowable&lt;T&gt; timeout(long timeout, TimeUnit timeUnit, Publisher&lt;? extends T&gt; other) {
<span class="fc" id="L16493">        ObjectHelper.requireNonNull(other, &quot;other is null&quot;);</span>
<span class="fc" id="L16494">        return timeout0(timeout, timeUnit, other, Schedulers.computation());</span>
    }

    /**
     * Returns a Flowable that mirrors the source Publisher but applies a timeout policy for each emitted
     * item using a specified Scheduler. If the next item isn't emitted within the specified timeout duration
     * starting from its predecessor, the source Publisher is disposed and resulting Publisher begins
     * instead to mirror a fallback Publisher.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/timeout.2s.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream. The {@code Publisher}
     *  sources are expected to honor backpressure as well.
     *  If any of the source {@code Publisher}s violate this, it &lt;em&gt;may&lt;/em&gt; throw an
     *  {@code IllegalStateException} when the source {@code Publisher} completes.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;You specify which {@link Scheduler} this operator will use.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param timeout
     *            maximum duration between items before a timeout occurs
     * @param timeUnit
     *            the unit of time that applies to the {@code timeout} argument
     * @param scheduler
     *            the {@link Scheduler} to run the timeout timers on
     * @param other
     *            the Publisher to use as the fallback in case of a timeout
     * @return the source Publisher modified so that it will switch to the fallback Publisher in case of a
     *         timeout
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/timeout.html&quot;&gt;ReactiveX operators documentation: Timeout&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Flowable&lt;T&gt; timeout(long timeout, TimeUnit timeUnit, Scheduler scheduler, Publisher&lt;? extends T&gt; other) {
<span class="fc" id="L16531">        ObjectHelper.requireNonNull(other, &quot;other is null&quot;);</span>
<span class="fc" id="L16532">        return timeout0(timeout, timeUnit, other, scheduler);</span>
    }

    /**
     * Returns a Flowable that mirrors the source Publisher but applies a timeout policy for each emitted
     * item, where this policy is governed by a specified Scheduler. If the next item isn't emitted within the
     * specified timeout duration starting from its predecessor, the resulting Publisher terminates and
     * notifies Subscribers of a {@code TimeoutException}.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/timeout.1s.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure
     *  behavior.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;You specify which {@link Scheduler} this operator will use.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param timeout
     *            maximum duration between items before a timeout occurs
     * @param timeUnit
     *            the unit of time that applies to the {@code timeout} argument
     * @param scheduler
     *            the Scheduler to run the timeout timers on
     * @return the source Publisher modified to notify Subscribers of a {@code TimeoutException} in case of a
     *         timeout
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/timeout.html&quot;&gt;ReactiveX operators documentation: Timeout&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Flowable&lt;T&gt; timeout(long timeout, TimeUnit timeUnit, Scheduler scheduler) {
<span class="fc" id="L16564">        return timeout0(timeout, timeUnit, null, scheduler);</span>
    }

    /**
     * Returns a Flowable that mirrors the source Publisher, but notifies Subscribers of a
     * {@code TimeoutException} if either the first item emitted by the source Publisher or any subsequent item
     * doesn't arrive within time windows defined by other Publishers.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;400&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/timeout5.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream. Both this and the returned {@code Publisher}s
     *  are expected to honor backpressure as well. If any of then violates this rule, it &lt;em&gt;may&lt;/em&gt; throw an
     *  {@code IllegalStateException} when the {@code Publisher} completes.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code timeout} does not operate by default on any {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;U&gt;
     *            the first timeout value type (ignored)
     * @param &lt;V&gt;
     *            the subsequent timeout value type (ignored)
     * @param firstTimeoutIndicator
     *            a function that returns a Publisher that determines the timeout window for the first source
     *            item
     * @param itemTimeoutIndicator
     *            a function that returns a Publisher for each item emitted by the source Publisher and that
     *            determines the timeout window in which the subsequent source item must arrive in order to
     *            continue the sequence
     * @return a Flowable that mirrors the source Publisher, but notifies Subscribers of a
     *         {@code TimeoutException} if either the first item or any subsequent item doesn't arrive within
     *         the time windows specified by the timeout selectors
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/timeout.html&quot;&gt;ReactiveX operators documentation: Timeout&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;U, V&gt; Flowable&lt;T&gt; timeout(Publisher&lt;U&gt; firstTimeoutIndicator,
            Function&lt;? super T, ? extends Publisher&lt;V&gt;&gt; itemTimeoutIndicator) {
<span class="fc" id="L16604">        ObjectHelper.requireNonNull(firstTimeoutIndicator, &quot;firstTimeoutIndicator is null&quot;);</span>
<span class="fc" id="L16605">        return timeout0(firstTimeoutIndicator, itemTimeoutIndicator, null);</span>
    }

    /**
     * Returns a Flowable that mirrors the source Publisher, but switches to a fallback Publisher if either
     * the first item emitted by the source Publisher or any subsequent item doesn't arrive within time windows
     * defined by other Publishers.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;400&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/timeout6.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream. The {@code Publisher}
     *  sources are expected to honor backpressure as well.
     *  If any of the source {@code Publisher}s violate this, it &lt;em&gt;may&lt;/em&gt; throw an
     *  {@code IllegalStateException} when the source {@code Publisher} completes.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code timeout} does not operate by default on any {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;U&gt;
     *            the first timeout value type (ignored)
     * @param &lt;V&gt;
     *            the subsequent timeout value type (ignored)
     * @param firstTimeoutIndicator
     *            a function that returns a Publisher which determines the timeout window for the first source
     *            item
     * @param itemTimeoutIndicator
     *            a function that returns a Publisher for each item emitted by the source Publisher and that
     *            determines the timeout window in which the subsequent source item must arrive in order to
     *            continue the sequence
     * @param other
     *            the fallback Publisher to switch to if the source Publisher times out
     * @return a Flowable that mirrors the source Publisher, but switches to the {@code other} Publisher if
     *         either the first item emitted by the source Publisher or any subsequent item doesn't arrive
     *         within time windows defined by the timeout selectors
     * @throws NullPointerException
     *             if {@code itemTimeoutIndicator} is null
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/timeout.html&quot;&gt;ReactiveX operators documentation: Timeout&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;U, V&gt; Flowable&lt;T&gt; timeout(
            Publisher&lt;U&gt; firstTimeoutIndicator,
            Function&lt;? super T, ? extends Publisher&lt;V&gt;&gt; itemTimeoutIndicator,
                    Publisher&lt;? extends T&gt; other) {
<span class="fc" id="L16652">        ObjectHelper.requireNonNull(firstTimeoutIndicator, &quot;firstTimeoutSelector is null&quot;);</span>
<span class="fc" id="L16653">        ObjectHelper.requireNonNull(other, &quot;other is null&quot;);</span>
<span class="fc" id="L16654">        return timeout0(firstTimeoutIndicator, itemTimeoutIndicator, other);</span>
    }

    private Flowable&lt;T&gt; timeout0(long timeout, TimeUnit timeUnit, Publisher&lt;? extends T&gt; other,
            Scheduler scheduler) {
<span class="fc" id="L16659">        ObjectHelper.requireNonNull(timeUnit, &quot;timeUnit is null&quot;);</span>
<span class="fc" id="L16660">        ObjectHelper.requireNonNull(scheduler, &quot;scheduler is null&quot;);</span>
<span class="fc" id="L16661">        return RxJavaPlugins.onAssembly(new FlowableTimeoutTimed&lt;T&gt;(this, timeout, timeUnit, scheduler, other));</span>
    }

    private &lt;U, V&gt; Flowable&lt;T&gt; timeout0(
            Publisher&lt;U&gt; firstTimeoutIndicator,
            Function&lt;? super T, ? extends Publisher&lt;V&gt;&gt; itemTimeoutIndicator,
                    Publisher&lt;? extends T&gt; other) {
<span class="fc" id="L16668">        ObjectHelper.requireNonNull(itemTimeoutIndicator, &quot;itemTimeoutIndicator is null&quot;);</span>
<span class="fc" id="L16669">        return RxJavaPlugins.onAssembly(new FlowableTimeout&lt;T, U, V&gt;(this, firstTimeoutIndicator, itemTimeoutIndicator, other));</span>
    }

    /**
     * Returns a Flowable that emits each item emitted by the source Publisher, wrapped in a
     * {@link Timed} object.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/timestamp.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure
     *  behavior.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code timestamp} does not operate on any particular scheduler but uses the current time
     *  from the {@code computation} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @return a Flowable that emits timestamped items from the source Publisher
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/timestamp.html&quot;&gt;ReactiveX operators documentation: Timestamp&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;Timed&lt;T&gt;&gt; timestamp() {
<span class="fc" id="L16693">        return timestamp(TimeUnit.MILLISECONDS, Schedulers.computation());</span>
    }

    /**
     * Returns a Flowable that emits each item emitted by the source Publisher, wrapped in a
     * {@link Timed} object whose timestamps are provided by a specified Scheduler.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/timestamp.s.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure
     *  behavior.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not operate on any particular scheduler but uses the current time
     *  from the specified {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param scheduler
     *            the {@link Scheduler} to use as a time source
     * @return a Flowable that emits timestamped items from the source Publisher with timestamps provided by
     *         the {@code scheduler}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/timestamp.html&quot;&gt;ReactiveX operators documentation: Timestamp&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.NONE) // Supplied scheduler is only used for creating timestamps.
    public final Flowable&lt;Timed&lt;T&gt;&gt; timestamp(Scheduler scheduler) {
<span class="fc" id="L16720">        return timestamp(TimeUnit.MILLISECONDS, scheduler);</span>
    }

    /**
     * Returns a Flowable that emits each item emitted by the source Publisher, wrapped in a
     * {@link Timed} object.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/timestamp.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure
     *  behavior.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code timestamp} does not operate on any particular scheduler but uses the current time
     *  from the {@code computation} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param unit the time unit for the current time
     * @return a Flowable that emits timestamped items from the source Publisher
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/timestamp.html&quot;&gt;ReactiveX operators documentation: Timestamp&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;Timed&lt;T&gt;&gt; timestamp(TimeUnit unit) {
<span class="fc" id="L16745">        return timestamp(unit, Schedulers.computation());</span>
    }

    /**
     * Returns a Flowable that emits each item emitted by the source Publisher, wrapped in a
     * {@link Timed} object whose timestamps are provided by a specified Scheduler.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/timestamp.s.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure
     *  behavior.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not operate on any particular scheduler but uses the current time
     *  from the specified {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param unit the time unit for the current time
     * @param scheduler
     *            the {@link Scheduler} to use as a time source
     * @return a Flowable that emits timestamped items from the source Publisher with timestamps provided by
     *         the {@code scheduler}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/timestamp.html&quot;&gt;ReactiveX operators documentation: Timestamp&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.NONE) // Supplied scheduler is only used for creating timestamps.
    public final Flowable&lt;Timed&lt;T&gt;&gt; timestamp(final TimeUnit unit, final Scheduler scheduler) {
<span class="fc" id="L16774">        ObjectHelper.requireNonNull(unit, &quot;unit is null&quot;);</span>
<span class="fc" id="L16775">        ObjectHelper.requireNonNull(scheduler, &quot;scheduler is null&quot;);</span>
<span class="fc" id="L16776">        return map(Functions.&lt;T&gt;timestampWith(unit, scheduler));</span>
    }

    /**
     * Calls the specified converter function during assembly time and returns its resulting value.
     * &lt;p&gt;
     * This allows fluent conversion to any other type.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The backpressure behavior depends on what happens in the {@code converter} function.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code to} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;R&gt; the resulting object type
     * @param converter the function that receives the current Flowable instance and returns a value
     * @return the value returned by the function
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.SPECIAL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;R&gt; R to(Function&lt;? super Flowable&lt;T&gt;, R&gt; converter) {
        try {
<span class="fc" id="L16798">            return ObjectHelper.requireNonNull(converter, &quot;converter is null&quot;).apply(this);</span>
<span class="fc" id="L16799">        } catch (Throwable ex) {</span>
<span class="fc" id="L16800">            Exceptions.throwIfFatal(ex);</span>
<span class="fc" id="L16801">            throw ExceptionHelper.wrapOrThrow(ex);</span>
        }
    }

    /**
     * Returns a Single that emits a single item, a list composed of all the items emitted by the
     * finite upstream source Publisher.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toList.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * Normally, a Publisher that returns multiple items will do so by invoking its {@link Subscriber}'s
     * {@link Subscriber#onNext onNext} method for each such item. You can change this behavior, instructing the
     * Publisher to compose a list of all of these items and then to invoke the Subscriber's {@code onNext}
     * function once, passing it the entire list, by calling the Publisher's {@code toList} method prior to
     * calling its {@link #subscribe} method.
     * &lt;p&gt;
     * Note that this operator requires the upstream to signal {@code onComplete} for the accumulated list to
     * be emitted. Sources that are infinite and never complete will never emit anything through this
     * operator and an infinite source may lead to a fatal {@code OutOfMemoryError}.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream and consumes the source {@code Publisher} in an
     *  unbounded manner (i.e., without applying backpressure to it).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code toList} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @return a Single that emits a single item: a List containing all of the items emitted by the source
     *         Publisher
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/to.html&quot;&gt;ReactiveX operators documentation: To&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Single&lt;List&lt;T&gt;&gt; toList() {
<span class="fc" id="L16836">        return RxJavaPlugins.onAssembly(new FlowableToListSingle&lt;T, List&lt;T&gt;&gt;(this));</span>
    }

    /**
     * Returns a Single that emits a single item, a list composed of all the items emitted by the
     * finite source Publisher.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toList.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * Normally, a Publisher that returns multiple items will do so by invoking its {@link Subscriber}'s
     * {@link Subscriber#onNext onNext} method for each such item. You can change this behavior, instructing the
     * Publisher to compose a list of all of these items and then to invoke the Subscriber's {@code onNext}
     * function once, passing it the entire list, by calling the Publisher's {@code toList} method prior to
     * calling its {@link #subscribe} method.
     * &lt;p&gt;
     * Note that this operator requires the upstream to signal {@code onComplete} for the accumulated list to
     * be emitted. Sources that are infinite and never complete will never emit anything through this
     * operator and an infinite source may lead to a fatal {@code OutOfMemoryError}.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream and consumes the source {@code Publisher} in an
     *  unbounded manner (i.e., without applying backpressure to it).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code toList} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param capacityHint
     *         the number of elements expected from the current Flowable
     * @return a Flowable that emits a single item: a List containing all of the items emitted by the source
     *         Publisher
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/to.html&quot;&gt;ReactiveX operators documentation: To&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Single&lt;List&lt;T&gt;&gt; toList(final int capacityHint) {
<span class="fc" id="L16872">        ObjectHelper.verifyPositive(capacityHint, &quot;capacityHint&quot;);</span>
<span class="fc" id="L16873">        return RxJavaPlugins.onAssembly(new FlowableToListSingle&lt;T, List&lt;T&gt;&gt;(this, Functions.&lt;T&gt;createArrayList(capacityHint)));</span>
    }

    /**
     * Returns a Single that emits a single item, a list composed of all the items emitted by the
     * finite source Publisher.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toList.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * Normally, a Publisher that returns multiple items will do so by invoking its {@link Subscriber}'s
     * {@link Subscriber#onNext onNext} method for each such item. You can change this behavior, instructing the
     * Publisher to compose a list of all of these items and then to invoke the Subscriber's {@code onNext}
     * function once, passing it the entire list, by calling the Publisher's {@code toList} method prior to
     * calling its {@link #subscribe} method.
     * &lt;p&gt;
     * Note that this operator requires the upstream to signal {@code onComplete} for the accumulated collection to
     * be emitted. Sources that are infinite and never complete will never emit anything through this
     * operator and an infinite source may lead to a fatal {@code OutOfMemoryError}.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream and consumes the source {@code Publisher} in an
     *  unbounded manner (i.e., without applying backpressure to it).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code toList} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;U&gt; the subclass of a collection of Ts
     * @param collectionSupplier
     *               the Callable returning the collection (for each individual Subscriber) to be filled in
     * @return a Single that emits a single item: a List containing all of the items emitted by the source
     *         Publisher
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/to.html&quot;&gt;ReactiveX operators documentation: To&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;U extends Collection&lt;? super T&gt;&gt; Single&lt;U&gt; toList(Callable&lt;U&gt; collectionSupplier) {
<span class="fc" id="L16910">        ObjectHelper.requireNonNull(collectionSupplier, &quot;collectionSupplier is null&quot;);</span>
<span class="fc" id="L16911">        return RxJavaPlugins.onAssembly(new FlowableToListSingle&lt;T, U&gt;(this, collectionSupplier));</span>
    }

    /**
     * Returns a Single that emits a single HashMap containing all items emitted by the finite source Publisher,
     * mapped by the keys returned by a specified {@code keySelector} function.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toMap.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * If more than one source item maps to the same key, the HashMap will contain the latest of those items.
     * &lt;p&gt;
     * Note that this operator requires the upstream to signal {@code onComplete} for the accumulated map to
     * be emitted. Sources that are infinite and never complete will never emit anything through this
     * operator and an infinite source may lead to a fatal {@code OutOfMemoryError}.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream and consumes the source {@code Publisher} in an
     *  unbounded manner (i.e., without applying backpressure to it).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code toMap} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;K&gt; the key type of the Map
     * @param keySelector
     *            the function that extracts the key from a source item to be used in the HashMap
     * @return a Single that emits a single item: a HashMap containing the mapped items from the source
     *         Publisher
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/to.html&quot;&gt;ReactiveX operators documentation: To&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;K&gt; Single&lt;Map&lt;K, T&gt;&gt; toMap(final Function&lt;? super T, ? extends K&gt; keySelector) {
<span class="fc" id="L16945">        ObjectHelper.requireNonNull(keySelector, &quot;keySelector is null&quot;);</span>
<span class="fc" id="L16946">        return collect(HashMapSupplier.&lt;K, T&gt;asCallable(), Functions.toMapKeySelector(keySelector));</span>
    }

    /**
     * Returns a Single that emits a single HashMap containing values corresponding to items emitted by the
     * finite source Publisher, mapped by the keys returned by a specified {@code keySelector} function.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toMap.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * If more than one source item maps to the same key, the HashMap will contain a single entry that
     * corresponds to the latest of those items.
     * &lt;p&gt;
     * Note that this operator requires the upstream to signal {@code onComplete} for the accumulated map to
     * be emitted. Sources that are infinite and never complete will never emit anything through this
     * operator and an infinite source may lead to a fatal {@code OutOfMemoryError}.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream and consumes the source {@code Publisher} in an
     *  unbounded manner (i.e., without applying backpressure to it).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code toMap} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;K&gt; the key type of the Map
     * @param &lt;V&gt; the value type of the Map
     * @param keySelector
     *            the function that extracts the key from a source item to be used in the HashMap
     * @param valueSelector
     *            the function that extracts the value from a source item to be used in the HashMap
     * @return a Single that emits a single item: a HashMap containing the mapped items from the source
     *         Publisher
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/to.html&quot;&gt;ReactiveX operators documentation: To&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;K, V&gt; Single&lt;Map&lt;K, V&gt;&gt; toMap(final Function&lt;? super T, ? extends K&gt; keySelector, final Function&lt;? super T, ? extends V&gt; valueSelector) {
<span class="fc" id="L16984">        ObjectHelper.requireNonNull(keySelector, &quot;keySelector is null&quot;);</span>
<span class="fc" id="L16985">        ObjectHelper.requireNonNull(valueSelector, &quot;valueSelector is null&quot;);</span>
<span class="fc" id="L16986">        return collect(HashMapSupplier.&lt;K, V&gt;asCallable(), Functions.toMapKeyValueSelector(keySelector, valueSelector));</span>
    }

    /**
     * Returns a Single that emits a single Map, returned by a specified {@code mapFactory} function, that
     * contains keys and values extracted from the items emitted by the finite source Publisher.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toMap.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * Note that this operator requires the upstream to signal {@code onComplete} for the accumulated map to
     * be emitted. Sources that are infinite and never complete will never emit anything through this
     * operator and an infinite source may lead to a fatal {@code OutOfMemoryError}.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream and consumes the source {@code Publisher} in an
     *  unbounded manner (i.e., without applying backpressure to it).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code toMap} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;K&gt; the key type of the Map
     * @param &lt;V&gt; the value type of the Map
     * @param keySelector
     *            the function that extracts the key from a source item to be used in the Map
     * @param valueSelector
     *            the function that extracts the value from the source items to be used as value in the Map
     * @param mapSupplier
     *            the function that returns a Map instance to be used
     * @return a Flowable that emits a single item: a Map that contains the mapped items emitted by the
     *         source Publisher
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/to.html&quot;&gt;ReactiveX operators documentation: To&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;K, V&gt; Single&lt;Map&lt;K, V&gt;&gt; toMap(final Function&lt;? super T, ? extends K&gt; keySelector,
            final Function&lt;? super T, ? extends V&gt; valueSelector,
            final Callable&lt;? extends Map&lt;K, V&gt;&gt; mapSupplier) {
<span class="fc" id="L17025">        ObjectHelper.requireNonNull(keySelector, &quot;keySelector is null&quot;);</span>
<span class="fc" id="L17026">        ObjectHelper.requireNonNull(valueSelector, &quot;valueSelector is null&quot;);</span>
<span class="fc" id="L17027">        return collect(mapSupplier, Functions.toMapKeyValueSelector(keySelector, valueSelector));</span>
    }

    /**
     * Returns a Single that emits a single HashMap that contains an ArrayList of items emitted by the
     * finite source Publisher keyed by a specified {@code keySelector} function.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toMultiMap.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * Note that this operator requires the upstream to signal {@code onComplete} for the accumulated map to
     * be emitted. Sources that are infinite and never complete will never emit anything through this
     * operator and an infinite source may lead to a fatal {@code OutOfMemoryError}.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not support backpressure as by intent it is requesting and buffering everything.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code toMultimap} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;K&gt; the key type of the Map
     * @param keySelector
     *            the function that extracts the key from the source items to be used as key in the HashMap
     * @return a Single that emits a single item: a HashMap that contains an ArrayList of items mapped from
     *         the source Publisher
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/to.html&quot;&gt;ReactiveX operators documentation: To&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;K&gt; Single&lt;Map&lt;K, Collection&lt;T&gt;&gt;&gt; toMultimap(Function&lt;? super T, ? extends K&gt; keySelector) {
<span class="fc" id="L17057">        Function&lt;T, T&gt; valueSelector = Functions.identity();</span>
<span class="fc" id="L17058">        Callable&lt;Map&lt;K, Collection&lt;T&gt;&gt;&gt; mapSupplier = HashMapSupplier.asCallable();</span>
<span class="fc" id="L17059">        Function&lt;K, List&lt;T&gt;&gt; collectionFactory = ArrayListSupplier.asFunction();</span>
<span class="fc" id="L17060">        return toMultimap(keySelector, valueSelector, mapSupplier, collectionFactory);</span>
    }

    /**
     * Returns a Single that emits a single HashMap that contains an ArrayList of values extracted by a
     * specified {@code valueSelector} function from items emitted by the finite source Publisher, keyed by a
     * specified {@code keySelector} function.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toMultiMap.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * Note that this operator requires the upstream to signal {@code onComplete} for the accumulated map to
     * be emitted. Sources that are infinite and never complete will never emit anything through this
     * operator and an infinite source may lead to a fatal {@code OutOfMemoryError}.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream and consumes the source {@code Publisher} in an
     *  unbounded manner (i.e., without applying backpressure to it).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code toMultimap} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;K&gt; the key type of the Map
     * @param &lt;V&gt; the value type of the Map
     * @param keySelector
     *            the function that extracts a key from the source items to be used as key in the HashMap
     * @param valueSelector
     *            the function that extracts a value from the source items to be used as value in the HashMap
     * @return a Single that emits a single item: a HashMap that contains an ArrayList of items mapped from
     *         the source Publisher
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/to.html&quot;&gt;ReactiveX operators documentation: To&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;K, V&gt; Single&lt;Map&lt;K, Collection&lt;V&gt;&gt;&gt; toMultimap(Function&lt;? super T, ? extends K&gt; keySelector, Function&lt;? super T, ? extends V&gt; valueSelector) {
<span class="fc" id="L17095">        Callable&lt;Map&lt;K, Collection&lt;V&gt;&gt;&gt; mapSupplier = HashMapSupplier.asCallable();</span>
<span class="fc" id="L17096">        Function&lt;K, List&lt;V&gt;&gt; collectionFactory = ArrayListSupplier.asFunction();</span>
<span class="fc" id="L17097">        return toMultimap(keySelector, valueSelector, mapSupplier, collectionFactory);</span>
    }

    /**
     * Returns a Single that emits a single Map, returned by a specified {@code mapFactory} function, that
     * contains a custom collection of values, extracted by a specified {@code valueSelector} function from
     * items emitted by the finite source Publisher, and keyed by the {@code keySelector} function.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toMultiMap.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * Note that this operator requires the upstream to signal {@code onComplete} for the accumulated map to
     * be emitted. Sources that are infinite and never complete will never emit anything through this
     * operator and an infinite source may lead to a fatal {@code OutOfMemoryError}.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream and consumes the source {@code Publisher} in an
     *  unbounded manner (i.e., without applying backpressure to it).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code toMultimap} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;K&gt; the key type of the Map
     * @param &lt;V&gt; the value type of the Map
     * @param keySelector
     *            the function that extracts a key from the source items to be used as the key in the Map
     * @param valueSelector
     *            the function that extracts a value from the source items to be used as the value in the Map
     * @param mapSupplier
     *            the function that returns a Map instance to be used
     * @param collectionFactory
     *            the function that returns a Collection instance for a particular key to be used in the Map
     * @return a Single that emits a single item: a Map that contains the collection of mapped items from
     *         the source Publisher
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/to.html&quot;&gt;ReactiveX operators documentation: To&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;K, V&gt; Single&lt;Map&lt;K, Collection&lt;V&gt;&gt;&gt; toMultimap(
            final Function&lt;? super T, ? extends K&gt; keySelector,
            final Function&lt;? super T, ? extends V&gt; valueSelector,
            final Callable&lt;? extends Map&lt;K, Collection&lt;V&gt;&gt;&gt; mapSupplier,
            final Function&lt;? super K, ? extends Collection&lt;? super V&gt;&gt; collectionFactory) {
<span class="fc" id="L17141">        ObjectHelper.requireNonNull(keySelector, &quot;keySelector is null&quot;);</span>
<span class="fc" id="L17142">        ObjectHelper.requireNonNull(valueSelector, &quot;valueSelector is null&quot;);</span>
<span class="fc" id="L17143">        ObjectHelper.requireNonNull(mapSupplier, &quot;mapSupplier is null&quot;);</span>
<span class="fc" id="L17144">        ObjectHelper.requireNonNull(collectionFactory, &quot;collectionFactory is null&quot;);</span>
<span class="fc" id="L17145">        return collect(mapSupplier, Functions.toMultimapKeyValueSelector(keySelector, valueSelector, collectionFactory));</span>
    }

    /**
     * Returns a Single that emits a single Map, returned by a specified {@code mapFactory} function, that
     * contains an ArrayList of values, extracted by a specified {@code valueSelector} function from items
     * emitted by the finite source Publisher and keyed by the {@code keySelector} function.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toMultiMap.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * Note that this operator requires the upstream to signal {@code onComplete} for the accumulated map to
     * be emitted. Sources that are infinite and never complete will never emit anything through this
     * operator and an infinite source may lead to a fatal {@code OutOfMemoryError}.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream and consumes the source {@code Publisher} in an
     *  unbounded manner (i.e., without applying backpressure to it).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code toMultimap} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;K&gt; the key type of the Map
     * @param &lt;V&gt; the value type of the Map
     * @param keySelector
     *            the function that extracts a key from the source items to be used as the key in the Map
     * @param valueSelector
     *            the function that extracts a value from the source items to be used as the value in the Map
     * @param mapSupplier
     *            the function that returns a Map instance to be used
     * @return a Single that emits a single item: a Map that contains a list items mapped from the source
     *         Publisher
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/to.html&quot;&gt;ReactiveX operators documentation: To&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;K, V&gt; Single&lt;Map&lt;K, Collection&lt;V&gt;&gt;&gt; toMultimap(
            Function&lt;? super T, ? extends K&gt; keySelector,
            Function&lt;? super T, ? extends V&gt; valueSelector,
            Callable&lt;Map&lt;K, Collection&lt;V&gt;&gt;&gt; mapSupplier
            ) {
<span class="fc" id="L17186">        return toMultimap(keySelector, valueSelector, mapSupplier, ArrayListSupplier.&lt;V, K&gt;asFunction());</span>
    }

    /**
     * Converts the current Flowable into a non-backpressured {@link Observable}.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;Observables don't support backpressure thus the current Flowable is consumed in an unbounded
     *  manner (by requesting Long.MAX_VALUE).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code toObservable} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @return the new Observable instance
     * @since 2.0
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Observable&lt;T&gt; toObservable() {
<span class="fc" id="L17205">        return RxJavaPlugins.onAssembly(new ObservableFromPublisher&lt;T&gt;(this));</span>
    }

    /**
     * Returns a Single that emits a list that contains the items emitted by the finite source Publisher, in a
     * sorted order. Each item emitted by the Publisher must implement {@link Comparable} with respect to all
     * other items in the sequence.
     *
     * &lt;p&gt;If any item emitted by this Flowable does not implement {@link Comparable} with respect to
     *             all other items emitted by this Flowable, no items will be emitted and the
     *             sequence is terminated with a {@link ClassCastException}.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toSortedList.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * Note that this operator requires the upstream to signal {@code onComplete} for the accumulated list to
     * be emitted. Sources that are infinite and never complete will never emit anything through this
     * operator and an infinite source may lead to a fatal {@code OutOfMemoryError}.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream and consumes the source {@code Publisher} in an
     *  unbounded manner (i.e., without applying backpressure to it).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code toSortedList} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @return a Single that emits a list that contains the items emitted by the source Publisher in
     *         sorted order
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/to.html&quot;&gt;ReactiveX operators documentation: To&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Single&lt;List&lt;T&gt;&gt; toSortedList() {
<span class="fc" id="L17237">        return toSortedList(Functions.naturalComparator());</span>
    }

    /**
     * Returns a Single that emits a list that contains the items emitted by the finite source Publisher, in a
     * sorted order based on a specified comparison function.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toSortedList.f.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * Note that this operator requires the upstream to signal {@code onComplete} for the accumulated list to
     * be emitted. Sources that are infinite and never complete will never emit anything through this
     * operator and an infinite source may lead to a fatal {@code OutOfMemoryError}.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream and consumes the source {@code Publisher} in an
     *  unbounded manner (i.e., without applying backpressure to it).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code toSortedList} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param comparator
     *            a function that compares two items emitted by the source Publisher and returns an Integer
     *            that indicates their sort order
     * @return a Single that emits a list that contains the items emitted by the source Publisher in
     *         sorted order
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/to.html&quot;&gt;ReactiveX operators documentation: To&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Single&lt;List&lt;T&gt;&gt; toSortedList(final Comparator&lt;? super T&gt; comparator) {
<span class="fc" id="L17269">        ObjectHelper.requireNonNull(comparator, &quot;comparator is null&quot;);</span>
<span class="fc" id="L17270">        return toList().map(Functions.listSorter(comparator));</span>
    }

    /**
     * Returns a Single that emits a list that contains the items emitted by the finite source Publisher, in a
     * sorted order based on a specified comparison function.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toSortedList.f.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * Note that this operator requires the upstream to signal {@code onComplete} for the accumulated list to
     * be emitted. Sources that are infinite and never complete will never emit anything through this
     * operator and an infinite source may lead to a fatal {@code OutOfMemoryError}.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream and consumes the source {@code Publisher} in an
     *  unbounded manner (i.e., without applying backpressure to it).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code toSortedList} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param comparator
     *            a function that compares two items emitted by the source Publisher and returns an Integer
     *            that indicates their sort order
     * @param capacityHint
     *             the initial capacity of the ArrayList used to accumulate items before sorting
     * @return a Single that emits a list that contains the items emitted by the source Publisher in
     *         sorted order
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/to.html&quot;&gt;ReactiveX operators documentation: To&lt;/a&gt;
     * @since 2.0
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Single&lt;List&lt;T&gt;&gt; toSortedList(final Comparator&lt;? super T&gt; comparator, int capacityHint) {
<span class="fc" id="L17305">        ObjectHelper.requireNonNull(comparator, &quot;comparator is null&quot;);</span>
<span class="fc" id="L17306">        return toList(capacityHint).map(Functions.listSorter(comparator));</span>
    }

    /**
     * Returns a Flowable that emits a list that contains the items emitted by the finite source Publisher, in a
     * sorted order. Each item emitted by the Publisher must implement {@link Comparable} with respect to all
     * other items in the sequence.
     *
     * &lt;p&gt;If any item emitted by this Flowable does not implement {@link Comparable} with respect to
     *             all other items emitted by this Flowable, no items will be emitted and the
     *             sequence is terminated with a {@link ClassCastException}.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toSortedList.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * Note that this operator requires the upstream to signal {@code onComplete} for the accumulated list to
     * be emitted. Sources that are infinite and never complete will never emit anything through this
     * operator and an infinite source may lead to a fatal {@code OutOfMemoryError}.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream and consumes the source {@code Publisher} in an
     *  unbounded manner (i.e., without applying backpressure to it).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code toSortedList} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param capacityHint
     *             the initial capacity of the ArrayList used to accumulate items before sorting
     * @return a Flowable that emits a list that contains the items emitted by the source Publisher in
     *         sorted order
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/to.html&quot;&gt;ReactiveX operators documentation: To&lt;/a&gt;
     * @since 2.0
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Single&lt;List&lt;T&gt;&gt; toSortedList(int capacityHint) {
<span class="fc" id="L17342">        return toSortedList(Functions.naturalComparator(), capacityHint);</span>
    }

    /**
     * Modifies the source Publisher so that subscribers will cancel it on a specified
     * {@link Scheduler}.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure
     *  behavior.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;You specify which {@link Scheduler} this operator will use.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param scheduler
     *            the {@link Scheduler} to perform cancellation actions on
     * @return the source Publisher modified so that its cancellations happen on the specified
     *         {@link Scheduler}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/subscribeon.html&quot;&gt;ReactiveX operators documentation: SubscribeOn&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Flowable&lt;T&gt; unsubscribeOn(Scheduler scheduler) {
<span class="fc" id="L17367">        ObjectHelper.requireNonNull(scheduler, &quot;scheduler is null&quot;);</span>
<span class="fc" id="L17368">        return RxJavaPlugins.onAssembly(new FlowableUnsubscribeOn&lt;T&gt;(this, scheduler));</span>
    }

    /**
     * Returns a Flowable that emits windows of items it collects from the source Publisher. The resulting
     * Publisher emits connected, non-overlapping windows, each containing {@code count} items. When the source
     * Publisher completes or encounters an error, the resulting Publisher emits the current window and
     * propagates the notification from the source Publisher.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;400&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/window3.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure of its inner and outer subscribers, however, the inner Publisher uses an
     *  unbounded buffer that may hold at most {@code count} elements.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code window} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param count
     *            the maximum size of each window before it should be emitted
     * @return a Flowable that emits connected, non-overlapping windows, each containing at most
     *         {@code count} items from the source Publisher
     * @throws IllegalArgumentException if either count is non-positive
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/window.html&quot;&gt;ReactiveX operators documentation: Window&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;Flowable&lt;T&gt;&gt; window(long count) {
<span class="fc" id="L17397">        return window(count, count, bufferSize());</span>
    }

    /**
     * Returns a Flowable that emits windows of items it collects from the source Publisher. The resulting
     * Publisher emits windows every {@code skip} items, each containing no more than {@code count} items. When
     * the source Publisher completes or encounters an error, the resulting Publisher emits the current window
     * and propagates the notification from the source Publisher.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;365&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/window4.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure of its inner and outer subscribers, however, the inner Publisher uses an
     *  unbounded buffer that may hold at most {@code count} elements.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code window} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param count
     *            the maximum size of each window before it should be emitted
     * @param skip
     *            how many items need to be skipped before starting a new window. Note that if {@code skip} and
     *            {@code count} are equal this is the same operation as {@link #window(long)}.
     * @return a Flowable that emits windows every {@code skip} items containing at most {@code count} items
     *         from the source Publisher
     * @throws IllegalArgumentException if either count or skip is non-positive
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/window.html&quot;&gt;ReactiveX operators documentation: Window&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;Flowable&lt;T&gt;&gt; window(long count, long skip) {
<span class="fc" id="L17429">        return window(count, skip, bufferSize());</span>
    }

    /**
     * Returns a Flowable that emits windows of items it collects from the source Publisher. The resulting
     * Publisher emits windows every {@code skip} items, each containing no more than {@code count} items. When
     * the source Publisher completes or encounters an error, the resulting Publisher emits the current window
     * and propagates the notification from the source Publisher.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;365&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/window4.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure of its inner and outer subscribers, however, the inner Publisher uses an
     *  unbounded buffer that may hold at most {@code count} elements.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code window} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param count
     *            the maximum size of each window before it should be emitted
     * @param skip
     *            how many items need to be skipped before starting a new window. Note that if {@code skip} and
     *            {@code count} are equal this is the same operation as {@link #window(long)}.
     * @param bufferSize
     *            the capacity hint for the buffer in the inner windows
     * @return a Flowable that emits windows every {@code skip} items containing at most {@code count} items
     *         from the source Publisher
     * @throws IllegalArgumentException if either count or skip is non-positive
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/window.html&quot;&gt;ReactiveX operators documentation: Window&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;Flowable&lt;T&gt;&gt; window(long count, long skip, int bufferSize) {
<span class="fc" id="L17463">        ObjectHelper.verifyPositive(skip, &quot;skip&quot;);</span>
<span class="fc" id="L17464">        ObjectHelper.verifyPositive(count, &quot;count&quot;);</span>
<span class="fc" id="L17465">        ObjectHelper.verifyPositive(bufferSize, &quot;bufferSize&quot;);</span>
<span class="fc" id="L17466">        return RxJavaPlugins.onAssembly(new FlowableWindow&lt;T&gt;(this, count, skip, bufferSize));</span>
    }

    /**
     * Returns a Flowable that emits windows of items it collects from the source Publisher. The resulting
     * Publisher starts a new window periodically, as determined by the {@code timeskip} argument. It emits
     * each window after a fixed timespan, specified by the {@code timespan} argument. When the source
     * Publisher completes or Publisher completes or encounters an error, the resulting Publisher emits the
     * current window and propagates the notification from the source Publisher.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;335&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/window7.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator consumes the source {@code Publisher} in an unbounded manner.
     *  The returned {@code Publisher} doesn't support backpressure as it uses
     *  time to control the creation of windows. The returned inner {@code Publisher}s honor
     *  backpressure but have an unbounded inner buffer that &lt;em&gt;may&lt;/em&gt; lead to {@code OutOfMemoryError}
     *  if left unconsumed.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code window} operates by default on the {@code computation} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param timespan
     *            the period of time each window collects items before it should be emitted
     * @param timeskip
     *            the period of time after which a new window will be created
     * @param unit
     *            the unit of time that applies to the {@code timespan} and {@code timeskip} arguments
     * @return a Flowable that emits new windows periodically as a fixed timespan elapses
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/window.html&quot;&gt;ReactiveX operators documentation: Window&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.COMPUTATION)
    public final Flowable&lt;Flowable&lt;T&gt;&gt; window(long timespan, long timeskip, TimeUnit unit) {
<span class="fc" id="L17501">        return window(timespan, timeskip, unit, Schedulers.computation(), bufferSize());</span>
    }

    /**
     * Returns a Flowable that emits windows of items it collects from the source Publisher. The resulting
     * Publisher starts a new window periodically, as determined by the {@code timeskip} argument. It emits
     * each window after a fixed timespan, specified by the {@code timespan} argument. When the source
     * Publisher completes or Publisher completes or encounters an error, the resulting Publisher emits the
     * current window and propagates the notification from the source Publisher.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;335&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/window7.s.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator consumes the source {@code Publisher} in an unbounded manner.
     *  The returned {@code Publisher} doesn't support backpressure as it uses
     *  time to control the creation of windows. The returned inner {@code Publisher}s honor
     *  backpressure but have an unbounded inner buffer that &lt;em&gt;may&lt;/em&gt; lead to {@code OutOfMemoryError}
     *  if left unconsumed.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;You specify which {@link Scheduler} this operator will use.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param timespan
     *            the period of time each window collects items before it should be emitted
     * @param timeskip
     *            the period of time after which a new window will be created
     * @param unit
     *            the unit of time that applies to the {@code timespan} and {@code timeskip} arguments
     * @param scheduler
     *            the {@link Scheduler} to use when determining the end and start of a window
     * @return a Flowable that emits new windows periodically as a fixed timespan elapses
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/window.html&quot;&gt;ReactiveX operators documentation: Window&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Flowable&lt;Flowable&lt;T&gt;&gt; window(long timespan, long timeskip, TimeUnit unit, Scheduler scheduler) {
<span class="fc" id="L17538">        return window(timespan, timeskip, unit, scheduler, bufferSize());</span>
    }

    /**
     * Returns a Flowable that emits windows of items it collects from the source Publisher. The resulting
     * Publisher starts a new window periodically, as determined by the {@code timeskip} argument. It emits
     * each window after a fixed timespan, specified by the {@code timespan} argument. When the source
     * Publisher completes or Publisher completes or encounters an error, the resulting Publisher emits the
     * current window and propagates the notification from the source Publisher.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;335&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/window7.s.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator consumes the source {@code Publisher} in an unbounded manner.
     *  The returned {@code Publisher} doesn't support backpressure as it uses
     *  time to control the creation of windows. The returned inner {@code Publisher}s honor
     *  backpressure but have an unbounded inner buffer that &lt;em&gt;may&lt;/em&gt; lead to {@code OutOfMemoryError}
     *  if left unconsumed.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;You specify which {@link Scheduler} this operator will use.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param timespan
     *            the period of time each window collects items before it should be emitted
     * @param timeskip
     *            the period of time after which a new window will be created
     * @param unit
     *            the unit of time that applies to the {@code timespan} and {@code timeskip} arguments
     * @param scheduler
     *            the {@link Scheduler} to use when determining the end and start of a window
     * @param bufferSize
     *            the capacity hint for the buffer in the inner windows
     * @return a Flowable that emits new windows periodically as a fixed timespan elapses
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/window.html&quot;&gt;ReactiveX operators documentation: Window&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Flowable&lt;Flowable&lt;T&gt;&gt; window(long timespan, long timeskip, TimeUnit unit, Scheduler scheduler, int bufferSize) {
<span class="fc" id="L17578">        ObjectHelper.verifyPositive(bufferSize, &quot;bufferSize&quot;);</span>
<span class="fc" id="L17579">        ObjectHelper.verifyPositive(timespan, &quot;timespan&quot;);</span>
<span class="fc" id="L17580">        ObjectHelper.verifyPositive(timeskip, &quot;timeskip&quot;);</span>
<span class="fc" id="L17581">        ObjectHelper.requireNonNull(scheduler, &quot;scheduler is null&quot;);</span>
<span class="fc" id="L17582">        ObjectHelper.requireNonNull(unit, &quot;unit is null&quot;);</span>
<span class="fc" id="L17583">        return RxJavaPlugins.onAssembly(new FlowableWindowTimed&lt;T&gt;(this, timespan, timeskip, unit, scheduler, Long.MAX_VALUE, bufferSize, false));</span>
    }

    /**
     * Returns a Flowable that emits windows of items it collects from the source Publisher. The resulting
     * Publisher emits connected, non-overlapping windows, each of a fixed duration specified by the
     * {@code timespan} argument. When the source Publisher completes or encounters an error, the resulting
     * Publisher emits the current window and propagates the notification from the source Publisher.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;375&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/window5.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator consumes the source {@code Publisher} in an unbounded manner.
     *  The returned {@code Publisher} doesn't support backpressure as it uses
     *  time to control the creation of windows. The returned inner {@code Publisher}s honor
     *  backpressure and may hold up to {@code count} elements at most.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code window} operates by default on the {@code computation} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param timespan
     *            the period of time each window collects items before it should be emitted and replaced with a
     *            new window
     * @param unit
     *            the unit of time that applies to the {@code timespan} argument
     * @return a Flowable that emits connected, non-overlapping windows representing items emitted by the
     *         source Publisher during fixed, consecutive durations
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/window.html&quot;&gt;ReactiveX operators documentation: Window&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.COMPUTATION)
    public final Flowable&lt;Flowable&lt;T&gt;&gt; window(long timespan, TimeUnit unit) {
<span class="fc" id="L17616">        return window(timespan, unit, Schedulers.computation(), Long.MAX_VALUE, false);</span>
    }

    /**
     * Returns a Flowable that emits windows of items it collects from the source Publisher. The resulting
     * Publisher emits connected, non-overlapping windows, each of a fixed duration as specified by the
     * {@code timespan} argument or a maximum size as specified by the {@code count} argument (whichever is
     * reached first). When the source Publisher completes or encounters an error, the resulting Publisher
     * emits the current window and propagates the notification from the source Publisher.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;370&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/window6.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator consumes the source {@code Publisher} in an unbounded manner.
     *  The returned {@code Publisher} doesn't support backpressure as it uses
     *  time to control the creation of windows. The returned inner {@code Publisher}s honor
     *  backpressure and may hold up to {@code count} elements at most.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code window} operates by default on the {@code computation} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param timespan
     *            the period of time each window collects items before it should be emitted and replaced with a
     *            new window
     * @param unit
     *            the unit of time that applies to the {@code timespan} argument
     * @param count
     *            the maximum size of each window before it should be emitted
     * @return a Flowable that emits connected, non-overlapping windows of items from the source Publisher
     *         that were emitted during a fixed duration of time or when the window has reached maximum capacity
     *         (whichever occurs first)
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/window.html&quot;&gt;ReactiveX operators documentation: Window&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.COMPUTATION)
    public final Flowable&lt;Flowable&lt;T&gt;&gt; window(long timespan, TimeUnit unit,
            long count) {
<span class="fc" id="L17654">        return window(timespan, unit, Schedulers.computation(), count, false);</span>
    }

    /**
     * Returns a Flowable that emits windows of items it collects from the source Publisher. The resulting
     * Publisher emits connected, non-overlapping windows, each of a fixed duration as specified by the
     * {@code timespan} argument or a maximum size as specified by the {@code count} argument (whichever is
     * reached first). When the source Publisher completes or encounters an error, the resulting Publisher
     * emits the current window and propagates the notification from the source Publisher.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;370&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/window6.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator consumes the source {@code Publisher} in an unbounded manner.
     *  The returned {@code Publisher} doesn't support backpressure as it uses
     *  time to control the creation of windows. The returned inner {@code Publisher}s honor
     *  backpressure and may hold up to {@code count} elements at most.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code window} operates by default on the {@code computation} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param timespan
     *            the period of time each window collects items before it should be emitted and replaced with a
     *            new window
     * @param unit
     *            the unit of time that applies to the {@code timespan} argument
     * @param count
     *            the maximum size of each window before it should be emitted
     * @param restart
     *            if true, when a window reaches the capacity limit, the timer is restarted as well
     * @return a Flowable that emits connected, non-overlapping windows of items from the source Publisher
     *         that were emitted during a fixed duration of time or when the window has reached maximum capacity
     *         (whichever occurs first)
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/window.html&quot;&gt;ReactiveX operators documentation: Window&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.COMPUTATION)
    public final Flowable&lt;Flowable&lt;T&gt;&gt; window(long timespan, TimeUnit unit,
            long count, boolean restart) {
<span class="fc" id="L17694">        return window(timespan, unit, Schedulers.computation(), count, restart);</span>
    }

    /**
     * Returns a Flowable that emits windows of items it collects from the source Publisher. The resulting
     * Publisher emits connected, non-overlapping windows, each of a fixed duration as specified by the
     * {@code timespan} argument. When the source Publisher completes or encounters an error, the resulting
     * Publisher emits the current window and propagates the notification from the source Publisher.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;375&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/window5.s.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator consumes the source {@code Publisher} in an unbounded manner.
     *  The returned {@code Publisher} doesn't support backpressure as it uses
     *  time to control the creation of windows. The returned inner {@code Publisher}s honor
     *  backpressure but have an unbounded inner buffer that &lt;em&gt;may&lt;/em&gt; lead to {@code OutOfMemoryError}
     *  if left unconsumed.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;You specify which {@link Scheduler} this operator will use.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param timespan
     *            the period of time each window collects items before it should be emitted and replaced with a
     *            new window
     * @param unit
     *            the unit of time which applies to the {@code timespan} argument
     * @param scheduler
     *            the {@link Scheduler} to use when determining the end and start of a window
     * @return a Flowable that emits connected, non-overlapping windows containing items emitted by the
     *         source Publisher within a fixed duration
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/window.html&quot;&gt;ReactiveX operators documentation: Window&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Flowable&lt;Flowable&lt;T&gt;&gt; window(long timespan, TimeUnit unit,
            Scheduler scheduler) {
<span class="fc" id="L17731">        return window(timespan, unit, scheduler, Long.MAX_VALUE, false);</span>
    }

    /**
     * Returns a Flowable that emits windows of items it collects from the source Publisher. The resulting
     * Publisher emits connected, non-overlapping windows, each of a fixed duration specified by the
     * {@code timespan} argument or a maximum size specified by the {@code count} argument (whichever is reached
     * first). When the source Publisher completes or encounters an error, the resulting Publisher emits the
     * current window and propagates the notification from the source Publisher.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;370&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/window6.s.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator consumes the source {@code Publisher} in an unbounded manner.
     *  The returned {@code Publisher} doesn't support backpressure as it uses
     *  time to control the creation of windows. The returned inner {@code Publisher}s honor
     *  backpressure and may hold up to {@code count} elements at most.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;You specify which {@link Scheduler} this operator will use.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param timespan
     *            the period of time each window collects items before it should be emitted and replaced with a
     *            new window
     * @param unit
     *            the unit of time which applies to the {@code timespan} argument
     * @param count
     *            the maximum size of each window before it should be emitted
     * @param scheduler
     *            the {@link Scheduler} to use when determining the end and start of a window
     * @return a Flowable that emits connected, non-overlapping windows of items from the source Publisher
     *         that were emitted during a fixed duration of time or when the window has reached maximum capacity
     *         (whichever occurs first)
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/window.html&quot;&gt;ReactiveX operators documentation: Window&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Flowable&lt;Flowable&lt;T&gt;&gt; window(long timespan, TimeUnit unit,
            Scheduler scheduler, long count) {
<span class="fc" id="L17771">        return window(timespan, unit, scheduler, count, false);</span>
    }

    /**
     * Returns a Flowable that emits windows of items it collects from the source Publisher. The resulting
     * Publisher emits connected, non-overlapping windows, each of a fixed duration specified by the
     * {@code timespan} argument or a maximum size specified by the {@code count} argument (whichever is reached
     * first). When the source Publisher completes or encounters an error, the resulting Publisher emits the
     * current window and propagates the notification from the source Publisher.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;370&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/window6.s.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator consumes the source {@code Publisher} in an unbounded manner.
     *  The returned {@code Publisher} doesn't support backpressure as it uses
     *  time to control the creation of windows. The returned inner {@code Publisher}s honor
     *  backpressure and may hold up to {@code count} elements at most.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;You specify which {@link Scheduler} this operator will use.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param timespan
     *            the period of time each window collects items before it should be emitted and replaced with a
     *            new window
     * @param unit
     *            the unit of time which applies to the {@code timespan} argument
     * @param count
     *            the maximum size of each window before it should be emitted
     * @param scheduler
     *            the {@link Scheduler} to use when determining the end and start of a window
     * @param restart
     *            if true, when a window reaches the capacity limit, the timer is restarted as well
     * @return a Flowable that emits connected, non-overlapping windows of items from the source Publisher
     *         that were emitted during a fixed duration of time or when the window has reached maximum capacity
     *         (whichever occurs first)
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/window.html&quot;&gt;ReactiveX operators documentation: Window&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Flowable&lt;Flowable&lt;T&gt;&gt; window(long timespan, TimeUnit unit,
            Scheduler scheduler, long count, boolean restart) {
<span class="fc" id="L17813">        return window(timespan, unit, scheduler, count, restart, bufferSize());</span>
    }

    /**
     * Returns a Flowable that emits windows of items it collects from the source Publisher. The resulting
     * Publisher emits connected, non-overlapping windows, each of a fixed duration specified by the
     * {@code timespan} argument or a maximum size specified by the {@code count} argument (whichever is reached
     * first). When the source Publisher completes or encounters an error, the resulting Publisher emits the
     * current window and propagates the notification from the source Publisher.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;370&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/window6.s.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator consumes the source {@code Publisher} in an unbounded manner.
     *  The returned {@code Publisher} doesn't support backpressure as it uses
     *  time to control the creation of windows. The returned inner {@code Publisher}s honor
     *  backpressure and may hold up to {@code count} elements at most.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;You specify which {@link Scheduler} this operator will use.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param timespan
     *            the period of time each window collects items before it should be emitted and replaced with a
     *            new window
     * @param unit
     *            the unit of time which applies to the {@code timespan} argument
     * @param count
     *            the maximum size of each window before it should be emitted
     * @param scheduler
     *            the {@link Scheduler} to use when determining the end and start of a window
     * @param restart
     *            if true, when a window reaches the capacity limit, the timer is restarted as well
     * @param bufferSize
     *            the capacity hint for the buffer in the inner windows
     * @return a Flowable that emits connected, non-overlapping windows of items from the source Publisher
     *         that were emitted during a fixed duration of time or when the window has reached maximum capacity
     *         (whichever occurs first)
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/window.html&quot;&gt;ReactiveX operators documentation: Window&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Flowable&lt;Flowable&lt;T&gt;&gt; window(
            long timespan, TimeUnit unit, Scheduler scheduler,
            long count, boolean restart, int bufferSize) {
<span class="fc" id="L17859">        ObjectHelper.verifyPositive(bufferSize, &quot;bufferSize&quot;);</span>
<span class="fc" id="L17860">        ObjectHelper.requireNonNull(scheduler, &quot;scheduler is null&quot;);</span>
<span class="fc" id="L17861">        ObjectHelper.requireNonNull(unit, &quot;unit is null&quot;);</span>
<span class="fc" id="L17862">        ObjectHelper.verifyPositive(count, &quot;count&quot;);</span>
<span class="fc" id="L17863">        return RxJavaPlugins.onAssembly(new FlowableWindowTimed&lt;T&gt;(this, timespan, timespan, unit, scheduler, count, bufferSize, restart));</span>
    }

    /**
     * Returns a Flowable that emits non-overlapping windows of items it collects from the source Publisher
     * where the boundary of each window is determined by the items emitted from a specified boundary-governing
     * Publisher.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;475&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/window8.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The outer Publisher of this operator does not support backpressure as it uses a {@code boundary} Publisher to control data
     *      flow. The inner Publishers honor backpressure and buffer everything until the boundary signals the next element.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code window} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;B&gt;
     *            the window element type (ignored)
     * @param boundaryIndicator
     *            a Publisher whose emitted items close and open windows
     * @return a Flowable that emits non-overlapping windows of items it collects from the source Publisher
     *         where the boundary of each window is determined by the items emitted from the {@code boundary}
     *         Publisher
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/window.html&quot;&gt;ReactiveX operators documentation: Window&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;B&gt; Flowable&lt;Flowable&lt;T&gt;&gt; window(Publisher&lt;B&gt; boundaryIndicator) {
<span class="fc" id="L17893">        return window(boundaryIndicator, bufferSize());</span>
    }

    /**
     * Returns a Flowable that emits non-overlapping windows of items it collects from the source Publisher
     * where the boundary of each window is determined by the items emitted from a specified boundary-governing
     * Publisher.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;475&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/window8.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The outer Publisher of this operator does not support backpressure as it uses a {@code boundary} Publisher to control data
     *      flow. The inner Publishers honor backpressure and buffer everything until the boundary signals the next element.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code window} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;B&gt;
     *            the window element type (ignored)
     * @param boundaryIndicator
     *            a Publisher whose emitted items close and open windows
     * @param bufferSize
     *            the capacity hint for the buffer in the inner windows
     * @return a Flowable that emits non-overlapping windows of items it collects from the source Publisher
     *         where the boundary of each window is determined by the items emitted from the {@code boundary}
     *         Publisher
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/window.html&quot;&gt;ReactiveX operators documentation: Window&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;B&gt; Flowable&lt;Flowable&lt;T&gt;&gt; window(Publisher&lt;B&gt; boundaryIndicator, int bufferSize) {
<span class="fc" id="L17926">        ObjectHelper.requireNonNull(boundaryIndicator, &quot;boundaryIndicator is null&quot;);</span>
<span class="fc" id="L17927">        ObjectHelper.verifyPositive(bufferSize, &quot;bufferSize&quot;);</span>
<span class="fc" id="L17928">        return RxJavaPlugins.onAssembly(new FlowableWindowBoundary&lt;T, B&gt;(this, boundaryIndicator, bufferSize));</span>
    }

    /**
     * Returns a Flowable that emits windows of items it collects from the source Publisher. The resulting
     * Publisher emits windows that contain those items emitted by the source Publisher between the time when
     * the {@code windowOpenings} Publisher emits an item and when the Publisher returned by
     * {@code closingSelector} emits an item.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;550&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/window2.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The outer Publisher of this operator doesn't support backpressure because the emission of new
     *  inner Publishers are controlled by the {@code windowOpenings} Publisher.
     *  The inner Publishers honor backpressure and buffer everything until the associated closing
     *  Publisher signals or completes.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code window} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;U&gt; the element type of the window-opening Publisher
     * @param &lt;V&gt; the element type of the window-closing Publishers
     * @param openingIndicator
     *            a Publisher that, when it emits an item, causes another window to be created
     * @param closingIndicator
     *            a {@link Function} that produces a Publisher for every window created. When this Publisher
     *            emits an item, the associated window is closed and emitted
     * @return a Flowable that emits windows of items emitted by the source Publisher that are governed by
     *         the specified window-governing Publishers
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/window.html&quot;&gt;ReactiveX operators documentation: Window&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;U, V&gt; Flowable&lt;Flowable&lt;T&gt;&gt; window(
            Publisher&lt;U&gt; openingIndicator,
            Function&lt;? super U, ? extends Publisher&lt;V&gt;&gt; closingIndicator) {
<span class="fc" id="L17965">        return window(openingIndicator, closingIndicator, bufferSize());</span>
    }

    /**
     * Returns a Flowable that emits windows of items it collects from the source Publisher. The resulting
     * Publisher emits windows that contain those items emitted by the source Publisher between the time when
     * the {@code windowOpenings} Publisher emits an item and when the Publisher returned by
     * {@code closingSelector} emits an item.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;550&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/window2.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The outer Publisher of this operator doesn't support backpressure because the emission of new
     *  inner Publishers are controlled by the {@code windowOpenings} Publisher.
     *  The inner Publishers honor backpressure and buffer everything until the associated closing
     *  Publisher signals or completes.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code window} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;U&gt; the element type of the window-opening Publisher
     * @param &lt;V&gt; the element type of the window-closing Publishers
     * @param openingIndicator
     *            a Publisher that, when it emits an item, causes another window to be created
     * @param closingIndicator
     *            a {@link Function} that produces a Publisher for every window created. When this Publisher
     *            emits an item, the associated window is closed and emitted
     * @param bufferSize
     *            the capacity hint for the buffer in the inner windows
     * @return a Flowable that emits windows of items emitted by the source Publisher that are governed by
     *         the specified window-governing Publishers
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/window.html&quot;&gt;ReactiveX operators documentation: Window&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;U, V&gt; Flowable&lt;Flowable&lt;T&gt;&gt; window(
            Publisher&lt;U&gt; openingIndicator,
            Function&lt;? super U, ? extends Publisher&lt;V&gt;&gt; closingIndicator, int bufferSize) {
<span class="fc" id="L18005">        ObjectHelper.requireNonNull(openingIndicator, &quot;openingIndicator is null&quot;);</span>
<span class="fc" id="L18006">        ObjectHelper.requireNonNull(closingIndicator, &quot;closingIndicator is null&quot;);</span>
<span class="fc" id="L18007">        ObjectHelper.verifyPositive(bufferSize, &quot;bufferSize&quot;);</span>
<span class="fc" id="L18008">        return RxJavaPlugins.onAssembly(new FlowableWindowBoundarySelector&lt;T, U, V&gt;(this, openingIndicator, closingIndicator, bufferSize));</span>
    }

    /**
     * Returns a Flowable that emits windows of items it collects from the source Publisher. The resulting
     * Publisher emits connected, non-overlapping windows. It emits the current window and opens a new one
     * whenever the Publisher produced by the specified {@code closingSelector} emits an item.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;455&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/window1.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator consumes the source {@code Publisher} in an unbounded manner.
     *  The returned {@code Publisher} doesn't support backpressure as it uses
     *  the {@code closingSelector} to control the creation of windows. The returned inner {@code Publisher}s honor
     *  backpressure but have an unbounded inner buffer that &lt;em&gt;may&lt;/em&gt; lead to {@code OutOfMemoryError}
     *  if left unconsumed.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code window} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;B&gt; the element type of the boundary Publisher
     * @param boundaryIndicatorSupplier
     *            a {@link Callable} that returns a {@code Publisher} that governs the boundary between windows.
     *            When the source {@code Publisher} emits an item, {@code window} emits the current window and begins
     *            a new one.
     * @return a Flowable that emits connected, non-overlapping windows of items from the source Publisher
     *         whenever {@code closingSelector} emits an item
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/window.html&quot;&gt;ReactiveX operators documentation: Window&lt;/a&gt;
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;B&gt; Flowable&lt;Flowable&lt;T&gt;&gt; window(Callable&lt;? extends Publisher&lt;B&gt;&gt; boundaryIndicatorSupplier) {
<span class="fc" id="L18041">        return window(boundaryIndicatorSupplier, bufferSize());</span>
    }

    /**
     * Returns a Flowable that emits windows of items it collects from the source Publisher. The resulting
     * Publisher emits connected, non-overlapping windows. It emits the current window and opens a new one
     * whenever the Publisher produced by the specified {@code closingSelector} emits an item.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;455&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/window1.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator consumes the source {@code Publisher} in an unbounded manner.
     *  The returned {@code Publisher} doesn't support backpressure as it uses
     *  the {@code closingSelector} to control the creation of windows. The returned inner {@code Publisher}s honor
     *  backpressure but have an unbounded inner buffer that &lt;em&gt;may&lt;/em&gt; lead to {@code OutOfMemoryError}
     *  if left unconsumed.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code window} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;B&gt; the element type of the boundary Publisher
     * @param boundaryIndicatorSupplier
     *            a {@link Callable} that returns a {@code Publisher} that governs the boundary between windows.
     *            When the source {@code Publisher} emits an item, {@code window} emits the current window and begins
     *            a new one.
     * @param bufferSize
     *            the capacity hint for the buffer in the inner windows
     * @return a Flowable that emits connected, non-overlapping windows of items from the source Publisher
     *         whenever {@code closingSelector} emits an item
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/window.html&quot;&gt;ReactiveX operators documentation: Window&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.ERROR)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;B&gt; Flowable&lt;Flowable&lt;T&gt;&gt; window(Callable&lt;? extends Publisher&lt;B&gt;&gt; boundaryIndicatorSupplier, int bufferSize) {
<span class="fc" id="L18077">        ObjectHelper.requireNonNull(boundaryIndicatorSupplier, &quot;boundaryIndicatorSupplier is null&quot;);</span>
<span class="fc" id="L18078">        ObjectHelper.verifyPositive(bufferSize, &quot;bufferSize&quot;);</span>
<span class="fc" id="L18079">        return RxJavaPlugins.onAssembly(new FlowableWindowBoundarySupplier&lt;T, B&gt;(this, boundaryIndicatorSupplier, bufferSize));</span>
    }

    /**
     * Merges the specified Publisher into this Publisher sequence by using the {@code resultSelector}
     * function only when the source Publisher (this instance) emits an item.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/withLatestFrom.png&quot; alt=&quot;&quot;&gt;
     *
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator is a pass-through for backpressure: the backpressure support
     *  depends on the upstream and downstream's backpressure behavior. The other Publisher
     *  is consumed in an unbounded fashion.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator, by default, doesn't run any particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;U&gt; the element type of the other Publisher
     * @param &lt;R&gt; the result type of the combination
     * @param other
     *            the other Publisher
     * @param combiner
     *            the function to call when this Publisher emits an item and the other Publisher has already
     *            emitted an item, to generate the item to be emitted by the resulting Publisher
     * @return a Flowable that merges the specified Publisher into this Publisher by using the
     *         {@code resultSelector} function only when the source Publisher sequence (this instance) emits an
     *         item
     * @since 2.0
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/combinelatest.html&quot;&gt;ReactiveX operators documentation: CombineLatest&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;U, R&gt; Flowable&lt;R&gt; withLatestFrom(Publisher&lt;? extends U&gt; other,
            BiFunction&lt;? super T, ? super U, ? extends R&gt; combiner) {
<span class="fc" id="L18116">        ObjectHelper.requireNonNull(other, &quot;other is null&quot;);</span>
<span class="fc" id="L18117">        ObjectHelper.requireNonNull(combiner, &quot;combiner is null&quot;);</span>

<span class="fc" id="L18119">        return RxJavaPlugins.onAssembly(new FlowableWithLatestFrom&lt;T, U, R&gt;(this, combiner, other));</span>
    }

    /**
     * Combines the value emission from this Publisher with the latest emissions from the
     * other Publishers via a function to produce the output item.
     *
     * &lt;p&gt;Note that this operator doesn't emit anything until all other sources have produced at
     * least one value. The resulting emission only happens when this Publisher emits (and
     * not when any of the other sources emit, unlike combineLatest).
     * If a source doesn't produce any value and just completes, the sequence is completed immediately.
     *
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator is a pass-through for backpressure behavior between the source {@code Publisher}
     *  and the downstream Subscriber. The other {@code Publisher}s are consumed in an unbounded manner.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T1&gt; the first other source's value type
     * @param &lt;T2&gt; the second other source's value type
     * @param &lt;R&gt; the result value type
     * @param source1 the first other Publisher
     * @param source2 the second other Publisher
     * @param combiner the function called with an array of values from each participating Publisher
     * @return the new Publisher instance
     * @since 2.0
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;T1, T2, R&gt; Flowable&lt;R&gt; withLatestFrom(Publisher&lt;T1&gt; source1, Publisher&lt;T2&gt; source2,
            Function3&lt;? super T, ? super T1, ? super T2, R&gt; combiner) {
<span class="fc" id="L18154">        ObjectHelper.requireNonNull(source1, &quot;source1 is null&quot;);</span>
<span class="fc" id="L18155">        ObjectHelper.requireNonNull(source2, &quot;source2 is null&quot;);</span>
<span class="fc" id="L18156">        Function&lt;Object[], R&gt; f = Functions.toFunction(combiner);</span>
<span class="fc" id="L18157">        return withLatestFrom(new Publisher[] { source1, source2 }, f);</span>
    }

    /**
     * Combines the value emission from this Publisher with the latest emissions from the
     * other Publishers via a function to produce the output item.
     *
     * &lt;p&gt;Note that this operator doesn't emit anything until all other sources have produced at
     * least one value. The resulting emission only happens when this Publisher emits (and
     * not when any of the other sources emit, unlike combineLatest).
     * If a source doesn't produce any value and just completes, the sequence is completed immediately.
     *
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator is a pass-through for backpressure behavior between the source {@code Publisher}
     *  and the downstream Subscriber. The other {@code Publisher}s are consumed in an unbounded manner.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T1&gt; the first other source's value type
     * @param &lt;T2&gt; the second other source's value type
     * @param &lt;T3&gt; the third other source's value type
     * @param &lt;R&gt; the result value type
     * @param source1 the first other Publisher
     * @param source2 the second other Publisher
     * @param source3 the third other Publisher
     * @param combiner the function called with an array of values from each participating Publisher
     * @return the new Publisher instance
     * @since 2.0
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;T1, T2, T3, R&gt; Flowable&lt;R&gt; withLatestFrom(
            Publisher&lt;T1&gt; source1, Publisher&lt;T2&gt; source2,
            Publisher&lt;T3&gt; source3,
            Function4&lt;? super T, ? super T1, ? super T2, ? super T3, R&gt; combiner) {
<span class="fc" id="L18196">        ObjectHelper.requireNonNull(source1, &quot;source1 is null&quot;);</span>
<span class="fc" id="L18197">        ObjectHelper.requireNonNull(source2, &quot;source2 is null&quot;);</span>
<span class="fc" id="L18198">        ObjectHelper.requireNonNull(source3, &quot;source3 is null&quot;);</span>
<span class="fc" id="L18199">        Function&lt;Object[], R&gt; f = Functions.toFunction(combiner);</span>
<span class="fc" id="L18200">        return withLatestFrom(new Publisher[] { source1, source2, source3 }, f);</span>
    }

    /**
     * Combines the value emission from this Publisher with the latest emissions from the
     * other Publishers via a function to produce the output item.
     *
     * &lt;p&gt;Note that this operator doesn't emit anything until all other sources have produced at
     * least one value. The resulting emission only happens when this Publisher emits (and
     * not when any of the other sources emit, unlike combineLatest).
     * If a source doesn't produce any value and just completes, the sequence is completed immediately.
     *
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator is a pass-through for backpressure behavior between the source {@code Publisher}
     *  and the downstream Subscriber. The other {@code Publisher}s are consumed in an unbounded manner.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T1&gt; the first other source's value type
     * @param &lt;T2&gt; the second other source's value type
     * @param &lt;T3&gt; the third other source's value type
     * @param &lt;T4&gt; the fourth other source's value type
     * @param &lt;R&gt; the result value type
     * @param source1 the first other Publisher
     * @param source2 the second other Publisher
     * @param source3 the third other Publisher
     * @param source4 the fourth other Publisher
     * @param combiner the function called with an array of values from each participating Publisher
     * @return the new Publisher instance
     * @since 2.0
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;T1, T2, T3, T4, R&gt; Flowable&lt;R&gt; withLatestFrom(
            Publisher&lt;T1&gt; source1, Publisher&lt;T2&gt; source2,
            Publisher&lt;T3&gt; source3, Publisher&lt;T4&gt; source4,
            Function5&lt;? super T, ? super T1, ? super T2, ? super T3, ? super T4, R&gt; combiner) {
<span class="fc" id="L18241">        ObjectHelper.requireNonNull(source1, &quot;source1 is null&quot;);</span>
<span class="fc" id="L18242">        ObjectHelper.requireNonNull(source2, &quot;source2 is null&quot;);</span>
<span class="fc" id="L18243">        ObjectHelper.requireNonNull(source3, &quot;source3 is null&quot;);</span>
<span class="fc" id="L18244">        ObjectHelper.requireNonNull(source4, &quot;source4 is null&quot;);</span>
<span class="fc" id="L18245">        Function&lt;Object[], R&gt; f = Functions.toFunction(combiner);</span>
<span class="fc" id="L18246">        return withLatestFrom(new Publisher[] { source1, source2, source3, source4 }, f);</span>
    }

    /**
     * Combines the value emission from this Publisher with the latest emissions from the
     * other Publishers via a function to produce the output item.
     *
     * &lt;p&gt;Note that this operator doesn't emit anything until all other sources have produced at
     * least one value. The resulting emission only happens when this Publisher emits (and
     * not when any of the other sources emit, unlike combineLatest).
     * If a source doesn't produce any value and just completes, the sequence is completed immediately.
     *
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator is a pass-through for backpressure behavior between the source {@code Publisher}
     *  and the downstream Subscriber. The other {@code Publisher}s are consumed in an unbounded manner.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;R&gt; the result value type
     * @param others the array of other sources
     * @param combiner the function called with an array of values from each participating Publisher
     * @return the new Publisher instance
     * @since 2.0
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;R&gt; Flowable&lt;R&gt; withLatestFrom(Publisher&lt;?&gt;[] others, Function&lt;? super Object[], R&gt; combiner) {
<span class="fc" id="L18277">        ObjectHelper.requireNonNull(others, &quot;others is null&quot;);</span>
<span class="fc" id="L18278">        ObjectHelper.requireNonNull(combiner, &quot;combiner is null&quot;);</span>
<span class="fc" id="L18279">        return RxJavaPlugins.onAssembly(new FlowableWithLatestFromMany&lt;T, R&gt;(this, others, combiner));</span>
    }

    /**
     * Combines the value emission from this Publisher with the latest emissions from the
     * other Publishers via a function to produce the output item.
     *
     * &lt;p&gt;Note that this operator doesn't emit anything until all other sources have produced at
     * least one value. The resulting emission only happens when this Publisher emits (and
     * not when any of the other sources emit, unlike combineLatest).
     * If a source doesn't produce any value and just completes, the sequence is completed immediately.
     *
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator is a pass-through for backpressure behavior between the source {@code Publisher}
     *  and the downstream Subscriber. The other {@code Publisher}s are consumed in an unbounded manner.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;R&gt; the result value type
     * @param others the iterable of other sources
     * @param combiner the function called with an array of values from each participating Publisher
     * @return the new Publisher instance
     * @since 2.0
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.PASS_THROUGH)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;R&gt; Flowable&lt;R&gt; withLatestFrom(Iterable&lt;? extends Publisher&lt;?&gt;&gt; others, Function&lt;? super Object[], R&gt; combiner) {
<span class="fc" id="L18310">        ObjectHelper.requireNonNull(others, &quot;others is null&quot;);</span>
<span class="fc" id="L18311">        ObjectHelper.requireNonNull(combiner, &quot;combiner is null&quot;);</span>
<span class="fc" id="L18312">        return RxJavaPlugins.onAssembly(new FlowableWithLatestFromMany&lt;T, R&gt;(this, others, combiner));</span>
    }

    /**
     * Returns a Flowable that emits items that are the result of applying a specified function to pairs of
     * values, one each from the source Publisher and a specified Iterable sequence.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/zip.i.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * Note that the {@code other} Iterable is evaluated as items are observed from the source Publisher; it is
     * not pre-consumed. This allows you to zip infinite streams on either side.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator expects backpressure from the sources and honors backpressure from the downstream.
     *  (I.e., zipping with {@link #interval(long, TimeUnit)} may result in MissingBackpressureException, use
     *  one of the {@code onBackpressureX} to handle similar, backpressure-ignoring sources.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code zipWith} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;U&gt;
     *            the type of items in the {@code other} Iterable
     * @param &lt;R&gt;
     *            the type of items emitted by the resulting Publisher
     * @param other
     *            the Iterable sequence
     * @param zipper
     *            a function that combines the pairs of items from the Publisher and the Iterable to generate
     *            the items to be emitted by the resulting Publisher
     * @return a Flowable that pairs up values from the source Publisher and the {@code other} Iterable
     *         sequence and emits the results of {@code zipFunction} applied to these pairs
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/zip.html&quot;&gt;ReactiveX operators documentation: Zip&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;U, R&gt; Flowable&lt;R&gt; zipWith(Iterable&lt;U&gt; other,  BiFunction&lt;? super T, ? super U, ? extends R&gt; zipper) {
<span class="fc" id="L18350">        ObjectHelper.requireNonNull(other, &quot;other is null&quot;);</span>
<span class="fc" id="L18351">        ObjectHelper.requireNonNull(zipper, &quot;zipper is null&quot;);</span>
<span class="fc" id="L18352">        return RxJavaPlugins.onAssembly(new FlowableZipIterable&lt;T, U, R&gt;(this, other, zipper));</span>
    }

    /**
     * Returns a Flowable that emits items that are the result of applying a specified function to pairs of
     * values, one each from the source Publisher and another specified Publisher.
     * &lt;p&gt;
     * The operator subscribes to its sources in the order they are specified and completes eagerly if
     * one of the sources is shorter than the rest while canceling the other sources. Therefore, it
     * is possible those other sources will never be able to run to completion (and thus not calling
     * {@code doOnComplete()}). This can also happen if the sources are exactly the same length; if
     * source A completes and B has been consumed and is about to complete, the operator detects A won't
     * be sending further values and it will cancel B immediately. For example:
     * &lt;pre&gt;&lt;code&gt;range(1, 5).doOnComplete(action1).zipWith(range(6, 5).doOnComplete(action2), (a, b) -&amp;gt; a + b)&lt;/code&gt;&lt;/pre&gt;
     * {@code action1} will be called but {@code action2} won't.
     * &lt;br&gt;To work around this termination property,
     * use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completion
     * or cancellation.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/zip.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator expects backpressure from the sources and honors backpressure from the downstream.
     *  (I.e., zipping with {@link #interval(long, TimeUnit)} may result in MissingBackpressureException, use
     *  one of the {@code onBackpressureX} to handle similar, backpressure-ignoring sources.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code zipWith} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;U&gt;
     *            the type of items emitted by the {@code other} Publisher
     * @param &lt;R&gt;
     *            the type of items emitted by the resulting Publisher
     * @param other
     *            the other Publisher
     * @param zipper
     *            a function that combines the pairs of items from the two Publishers to generate the items to
     *            be emitted by the resulting Publisher
     * @return a Flowable that pairs up values from the source Publisher and the {@code other} Publisher
     *         and emits the results of {@code zipFunction} applied to these pairs
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/zip.html&quot;&gt;ReactiveX operators documentation: Zip&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;U, R&gt; Flowable&lt;R&gt; zipWith(Publisher&lt;? extends U&gt; other, BiFunction&lt;? super T, ? super U, ? extends R&gt; zipper) {
<span class="fc" id="L18399">        ObjectHelper.requireNonNull(other, &quot;other is null&quot;);</span>
<span class="fc" id="L18400">        return zip(this, other, zipper);</span>
    }

    /**
     * Returns a Flowable that emits items that are the result of applying a specified function to pairs of
     * values, one each from the source Publisher and another specified Publisher.
     * &lt;p&gt;
     * The operator subscribes to its sources in the order they are specified and completes eagerly if
     * one of the sources is shorter than the rest while canceling the other sources. Therefore, it
     * is possible those other sources will never be able to run to completion (and thus not calling
     * {@code doOnComplete()}). This can also happen if the sources are exactly the same length; if
     * source A completes and B has been consumed and is about to complete, the operator detects A won't
     * be sending further values and it will cancel B immediately. For example:
     * &lt;pre&gt;&lt;code&gt;range(1, 5).doOnComplete(action1).zipWith(range(6, 5).doOnComplete(action2), (a, b) -&amp;gt; a + b)&lt;/code&gt;&lt;/pre&gt;
     * {@code action1} will be called but {@code action2} won't.
     * &lt;br&gt;To work around this termination property,
     * use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completion
     * or cancellation.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/zip.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator expects backpressure from the sources and honors backpressure from the downstream.
     *  (I.e., zipping with {@link #interval(long, TimeUnit)} may result in MissingBackpressureException, use
     *  one of the {@code onBackpressureX} to handle similar, backpressure-ignoring sources.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code zipWith} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;U&gt;
     *            the type of items emitted by the {@code other} Publisher
     * @param &lt;R&gt;
     *            the type of items emitted by the resulting Publisher
     * @param other
     *            the other Publisher
     * @param zipper
     *            a function that combines the pairs of items from the two Publishers to generate the items to
     *            be emitted by the resulting Publisher
     * @param delayError
     *            if true, errors from the current Flowable or the other Publisher is delayed until both terminate
     * @return a Flowable that pairs up values from the source Publisher and the {@code other} Publisher
     *         and emits the results of {@code zipFunction} applied to these pairs
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/zip.html&quot;&gt;ReactiveX operators documentation: Zip&lt;/a&gt;
     * @since 2.0
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;U, R&gt; Flowable&lt;R&gt; zipWith(Publisher&lt;? extends U&gt; other,
            BiFunction&lt;? super T, ? super U, ? extends R&gt; zipper, boolean delayError) {
<span class="fc" id="L18450">        return zip(this, other, zipper, delayError);</span>
    }

    /**
     * Returns a Flowable that emits items that are the result of applying a specified function to pairs of
     * values, one each from the source Publisher and another specified Publisher.
     * &lt;p&gt;
     * The operator subscribes to its sources in the order they are specified and completes eagerly if
     * one of the sources is shorter than the rest while canceling the other sources. Therefore, it
     * is possible those other sources will never be able to run to completion (and thus not calling
     * {@code doOnComplete()}). This can also happen if the sources are exactly the same length; if
     * source A completes and B has been consumed and is about to complete, the operator detects A won't
     * be sending further values and it will cancel B immediately. For example:
     * &lt;pre&gt;&lt;code&gt;range(1, 5).doOnComplete(action1).zipWith(range(6, 5).doOnComplete(action2), (a, b) -&amp;gt; a + b)&lt;/code&gt;&lt;/pre&gt;
     * {@code action1} will be called but {@code action2} won't.
     * &lt;br&gt;To work around this termination property,
     * use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completion
     * or cancellation.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/zip.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator expects backpressure from the sources and honors backpressure from the downstream.
     *  (I.e., zipping with {@link #interval(long, TimeUnit)} may result in MissingBackpressureException, use
     *  one of the {@code onBackpressureX} to handle similar, backpressure-ignoring sources.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code zipWith} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;U&gt;
     *            the type of items emitted by the {@code other} Publisher
     * @param &lt;R&gt;
     *            the type of items emitted by the resulting Publisher
     * @param other
     *            the other Publisher
     * @param zipper
     *            a function that combines the pairs of items from the two Publishers to generate the items to
     *            be emitted by the resulting Publisher
     * @param bufferSize
     *            the capacity hint for the buffer in the inner windows
     * @param delayError
     *            if true, errors from the current Flowable or the other Publisher is delayed until both terminate
     * @return a Flowable that pairs up values from the source Publisher and the {@code other} Publisher
     *         and emits the results of {@code zipFunction} applied to these pairs
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/zip.html&quot;&gt;ReactiveX operators documentation: Zip&lt;/a&gt;
     * @since 2.0
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;U, R&gt; Flowable&lt;R&gt; zipWith(Publisher&lt;? extends U&gt; other,
            BiFunction&lt;? super T, ? super U, ? extends R&gt; zipper, boolean delayError, int bufferSize) {
<span class="fc" id="L18502">        return zip(this, other, zipper, delayError, bufferSize);</span>
    }

    // -------------------------------------------------------------------------
    // Fluent test support, super handy and reduces test preparation boilerplate
    // -------------------------------------------------------------------------
    /**
     * Creates a TestSubscriber that requests Long.MAX_VALUE and subscribes
     * it to this Flowable.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The returned TestSubscriber consumes this Flowable in an unbounded fashion.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code test} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @return the new TestSubscriber instance
     * @since 2.0
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final TestSubscriber&lt;T&gt; test() { // NoPMD
<span class="fc" id="L18524">        TestSubscriber&lt;T&gt; ts = new TestSubscriber&lt;T&gt;();</span>
<span class="fc" id="L18525">        subscribe(ts);</span>
<span class="fc" id="L18526">        return ts;</span>
    }

    /**
     * Creates a TestSubscriber with the given initial request amount and subscribes
     * it to this Flowable.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The returned TestSubscriber requests the given {@code initialRequest} amount upfront.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code test} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param initialRequest the initial request amount, positive
     * @return the new TestSubscriber instance
     * @since 2.0
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final TestSubscriber&lt;T&gt; test(long initialRequest) { // NoPMD
<span class="fc" id="L18546">        TestSubscriber&lt;T&gt; ts = new TestSubscriber&lt;T&gt;(initialRequest);</span>
<span class="fc" id="L18547">        subscribe(ts);</span>
<span class="fc" id="L18548">        return ts;</span>
    }

    /**
     * Creates a TestSubscriber with the given initial request amount,
     * optionally cancels it before the subscription and subscribes
     * it to this Flowable.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The returned TestSubscriber requests the given {@code initialRequest} amount upfront.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code test} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param initialRequest the initial request amount, positive
     * @param cancel should the TestSubscriber be canceled before the subscription?
     * @return the new TestSubscriber instance
     * @since 2.0
     */
    @CheckReturnValue
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public final TestSubscriber&lt;T&gt; test(long initialRequest, boolean cancel) { // NoPMD
<span class="fc" id="L18570">        TestSubscriber&lt;T&gt; ts = new TestSubscriber&lt;T&gt;(initialRequest);</span>
<span class="fc bfc" id="L18571" title="All 2 branches covered.">        if (cancel) {</span>
<span class="fc" id="L18572">            ts.cancel();</span>
        }
<span class="fc" id="L18574">        subscribe(ts);</span>
<span class="fc" id="L18575">        return ts;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>