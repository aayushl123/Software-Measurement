<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Maybe.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">RxJava_2_x$Unnamed.exec</a> &gt; <a href="index.source.html" class="el_package">io.reactivex</a> &gt; <span class="el_source">Maybe.java</span></div><h1>Maybe.java</h1><pre class="source lang-java linenums">/**
 * Copyright (c) 2016-present, RxJava Contributors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is
 * distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
 * the License for the specific language governing permissions and limitations under the License.
 */

package io.reactivex;

import java.util.NoSuchElementException;
import java.util.concurrent.*;

import org.reactivestreams.*;

import io.reactivex.annotations.*;
import io.reactivex.disposables.Disposable;
import io.reactivex.exceptions.Exceptions;
import io.reactivex.functions.*;
import io.reactivex.internal.functions.*;
import io.reactivex.internal.fuseable.*;
import io.reactivex.internal.observers.BlockingMultiObserver;
import io.reactivex.internal.operators.flowable.*;
import io.reactivex.internal.operators.maybe.*;
import io.reactivex.internal.operators.mixed.*;
import io.reactivex.internal.util.*;
import io.reactivex.observers.TestObserver;
import io.reactivex.plugins.RxJavaPlugins;
import io.reactivex.schedulers.Schedulers;

/**
 * The {@code Maybe} class represents a deferred computation and emission of a single value, no value at all or an exception.
 * &lt;p&gt;
 * The {@code Maybe} class implements the {@link MaybeSource} base interface and the default consumer
 * type it interacts with is the {@link MaybeObserver} via the {@link #subscribe(MaybeObserver)} method.
 * &lt;p&gt;
 * The {@code Maybe} operates with the following sequential protocol:
 * &lt;pre&gt;&lt;code&gt;
 *     onSubscribe (onSuccess | onError | onComplete)?
 * &lt;/code&gt;&lt;/pre&gt;
 * &lt;p&gt;
 * Note that {@code onSuccess}, {@code onError} and {@code onComplete} are mutually exclusive events; unlike {@code Observable},
 * {@code onSuccess} is never followed by {@code onError} or {@code onComplete}.
 * &lt;p&gt;
 * Like {@link Observable}, a running {@code Maybe} can be stopped through the {@link Disposable} instance
 * provided to consumers through {@link MaybeObserver#onSubscribe}.
 * &lt;p&gt;
 * Like an {@code Observable}, a {@code Maybe} is lazy, can be either &quot;hot&quot; or &quot;cold&quot;, synchronous or
 * asynchronous. {@code Maybe} instances returned by the methods of this class are &lt;em&gt;cold&lt;/em&gt;
 * and there is a standard &lt;em&gt;hot&lt;/em&gt; implementation in the form of a subject:
 * {@link io.reactivex.subjects.MaybeSubject MaybeSubject}.
 * &lt;p&gt;
 * The documentation for this class makes use of marble diagrams. The following legend explains these diagrams:
 * &lt;p&gt;
 * &lt;img width=&quot;640&quot; height=&quot;370&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/maybe.png&quot; alt=&quot;&quot;&gt;
 * &lt;p&gt;
 * See {@link Flowable} or {@link Observable} for the
 * implementation of the Reactive Pattern for a stream or vector of values.
 * &lt;p&gt;
 * Example:
 * &lt;pre&gt;&lt;code&gt;
 * Disposable d = Maybe.just(&quot;Hello World&quot;)
 *    .delay(10, TimeUnit.SECONDS, Schedulers.io())
 *    .subscribeWith(new DisposableMaybeObserver&amp;lt;String&amp;gt;() {
 *        &amp;#64;Override
 *        public void onStart() {
 *            System.out.println(&quot;Started&quot;);
 *        }
 *
 *        &amp;#64;Override
 *        public void onSuccess(String value) {
 *            System.out.println(&quot;Success: &quot; + value);
 *        }
 *
 *        &amp;#64;Override
 *        public void onError(Throwable error) {
 *            error.printStackTrace();
 *        }
 *
 *        &amp;#64;Override
 *        public void onComplete() {
 *            System.out.println(&quot;Done!&quot;);
 *        }
 *    });
 * 
 * Thread.sleep(5000);
 * 
 * d.dispose();
 * &lt;/code&gt;&lt;/pre&gt;
 * &lt;p&gt;
 * Note that by design, subscriptions via {@link #subscribe(MaybeObserver)} can't be disposed
 * from the outside (hence the
 * {@code void} return of the {@link #subscribe(MaybeObserver)} method) and it is the
 * responsibility of the implementor of the {@code MaybeObserver} to allow this to happen.
 * RxJava supports such usage with the standard
 * {@link io.reactivex.observers.DisposableMaybeObserver DisposableMaybeObserver} instance.
 * For convenience, the {@link #subscribeWith(MaybeObserver)} method is provided as well to
 * allow working with a {@code MaybeObserver} (or subclass) instance to be applied with in
 * a fluent manner (such as in the example above).
 *
 * @param &lt;T&gt; the value type
 * @since 2.0
 * @see io.reactivex.observers.DisposableMaybeObserver
 */
<span class="fc" id="L110">public abstract class Maybe&lt;T&gt; implements MaybeSource&lt;T&gt; {</span>

    /**
     * Runs multiple MaybeSources and signals the events of the first one that signals (disposing
     * the rest).
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;519&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.amb.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code amb} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;T&gt; the value type
     * @param sources the Iterable sequence of sources. A subscription to each source will
     *            occur in the same order as in the Iterable.
     * @return the new Maybe instance
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Maybe&lt;T&gt; amb(final Iterable&lt;? extends MaybeSource&lt;? extends T&gt;&gt; sources) {
<span class="fc" id="L130">        ObjectHelper.requireNonNull(sources, &quot;sources is null&quot;);</span>
<span class="fc" id="L131">        return RxJavaPlugins.onAssembly(new MaybeAmb&lt;T&gt;(null, sources));</span>
    }

    /**
     * Runs multiple MaybeSources and signals the events of the first one that signals (disposing
     * the rest).
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;519&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.ambArray.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code ambArray} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;T&gt; the value type
     * @param sources the array of sources. A subscription to each source will
     *            occur in the same order as in the array.
     * @return the new Maybe instance
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; Maybe&lt;T&gt; ambArray(final MaybeSource&lt;? extends T&gt;... sources) {
<span class="fc bfc" id="L152" title="All 2 branches covered.">        if (sources.length == 0) {</span>
<span class="fc" id="L153">            return empty();</span>
        }
<span class="fc bfc" id="L155" title="All 2 branches covered.">        if (sources.length == 1) {</span>
<span class="fc" id="L156">            return wrap((MaybeSource&lt;T&gt;)sources[0]);</span>
        }
<span class="fc" id="L158">        return RxJavaPlugins.onAssembly(new MaybeAmb&lt;T&gt;(sources, null));</span>
    }

    /**
     * Concatenate the single values, in a non-overlapping fashion, of the MaybeSource sources provided by
     * an Iterable sequence.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;526&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.concat.i.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The returned {@code Flowable} honors the backpressure of the downstream consumer.&lt;/dd&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code concat} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;T&gt; the value type
     * @param sources the Iterable sequence of MaybeSource instances
     * @return the new Flowable instance
     */
    @BackpressureSupport(BackpressureKind.FULL)
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Flowable&lt;T&gt; concat(Iterable&lt;? extends MaybeSource&lt;? extends T&gt;&gt; sources) {
<span class="fc" id="L181">        ObjectHelper.requireNonNull(sources, &quot;sources is null&quot;);</span>
<span class="fc" id="L182">        return RxJavaPlugins.onAssembly(new MaybeConcatIterable&lt;T&gt;(sources));</span>
    }

    /**
     * Returns a Flowable that emits the items emitted by two MaybeSources, one after the other.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;422&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.concat.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The returned {@code Flowable} honors the backpressure of the downstream consumer.&lt;/dd&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code concat} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T&gt; the common value type
     * @param source1
     *            a MaybeSource to be concatenated
     * @param source2
     *            a MaybeSource to be concatenated
     * @return a Flowable that emits items emitted by the two source MaybeSources, one after the other.
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/concat.html&quot;&gt;ReactiveX operators documentation: Concat&lt;/a&gt;
     */
    @BackpressureSupport(BackpressureKind.FULL)
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; Flowable&lt;T&gt; concat(MaybeSource&lt;? extends T&gt; source1, MaybeSource&lt;? extends T&gt; source2) {
<span class="fc" id="L210">        ObjectHelper.requireNonNull(source1, &quot;source1 is null&quot;);</span>
<span class="fc" id="L211">        ObjectHelper.requireNonNull(source2, &quot;source2 is null&quot;);</span>
<span class="fc" id="L212">        return concatArray(source1, source2);</span>
    }

    /**
     * Returns a Flowable that emits the items emitted by three MaybeSources, one after the other.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;422&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.concat.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The returned {@code Flowable} honors the backpressure of the downstream consumer.&lt;/dd&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code concat} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T&gt; the common value type
     * @param source1
     *            a MaybeSource to be concatenated
     * @param source2
     *            a MaybeSource to be concatenated
     * @param source3
     *            a MaybeSource to be concatenated
     * @return a Flowable that emits items emitted by the three source MaybeSources, one after the other.
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/concat.html&quot;&gt;ReactiveX operators documentation: Concat&lt;/a&gt;
     */
    @BackpressureSupport(BackpressureKind.FULL)
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; Flowable&lt;T&gt; concat(
            MaybeSource&lt;? extends T&gt; source1, MaybeSource&lt;? extends T&gt; source2, MaybeSource&lt;? extends T&gt; source3) {
<span class="fc" id="L243">        ObjectHelper.requireNonNull(source1, &quot;source1 is null&quot;);</span>
<span class="fc" id="L244">        ObjectHelper.requireNonNull(source2, &quot;source2 is null&quot;);</span>
<span class="fc" id="L245">        ObjectHelper.requireNonNull(source3, &quot;source3 is null&quot;);</span>
<span class="fc" id="L246">        return concatArray(source1, source2, source3);</span>
    }

    /**
     * Returns a Flowable that emits the items emitted by four MaybeSources, one after the other.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;422&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.concat.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The returned {@code Flowable} honors the backpressure of the downstream consumer.&lt;/dd&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code concat} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T&gt; the common value type
     * @param source1
     *            a MaybeSource to be concatenated
     * @param source2
     *            a MaybeSource to be concatenated
     * @param source3
     *            a MaybeSource to be concatenated
     * @param source4
     *            a MaybeSource to be concatenated
     * @return a Flowable that emits items emitted by the four source MaybeSources, one after the other.
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/concat.html&quot;&gt;ReactiveX operators documentation: Concat&lt;/a&gt;
     */
    @BackpressureSupport(BackpressureKind.FULL)
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; Flowable&lt;T&gt; concat(
            MaybeSource&lt;? extends T&gt; source1, MaybeSource&lt;? extends T&gt; source2, MaybeSource&lt;? extends T&gt; source3, MaybeSource&lt;? extends T&gt; source4) {
<span class="fc" id="L279">        ObjectHelper.requireNonNull(source1, &quot;source1 is null&quot;);</span>
<span class="fc" id="L280">        ObjectHelper.requireNonNull(source2, &quot;source2 is null&quot;);</span>
<span class="fc" id="L281">        ObjectHelper.requireNonNull(source3, &quot;source3 is null&quot;);</span>
<span class="fc" id="L282">        ObjectHelper.requireNonNull(source4, &quot;source4 is null&quot;);</span>
<span class="fc" id="L283">        return concatArray(source1, source2, source3, source4);</span>
    }

    /**
     * Concatenate the single values, in a non-overlapping fashion, of the MaybeSource sources provided by
     * a Publisher sequence.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;416&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.concat.p.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The returned {@code Flowable} honors the backpressure of the downstream consumer and
     *  expects the {@code Publisher} to honor backpressure as well. If the sources {@code Publisher}
     *  violates this, a {@link io.reactivex.exceptions.MissingBackpressureException} is signalled.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code concat} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;T&gt; the value type
     * @param sources the Publisher of MaybeSource instances
     * @return the new Flowable instance
     */
    @BackpressureSupport(BackpressureKind.FULL)
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Flowable&lt;T&gt; concat(Publisher&lt;? extends MaybeSource&lt;? extends T&gt;&gt; sources) {
<span class="fc" id="L307">        return concat(sources, 2);</span>
    }

    /**
     * Concatenate the single values, in a non-overlapping fashion, of the MaybeSource sources provided by
     * a Publisher sequence.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;416&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.concat.pn.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The returned {@code Flowable} honors the backpressure of the downstream consumer and
     *  expects the {@code Publisher} to honor backpressure as well. If the sources {@code Publisher}
     *  violates this, a {@link io.reactivex.exceptions.MissingBackpressureException} is signalled.&lt;/dd&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code concat} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;T&gt; the value type
     * @param sources the Publisher of MaybeSource instances
     * @param prefetch the number of MaybeSources to prefetch from the Publisher
     * @return the new Flowable instance
     */
    @BackpressureSupport(BackpressureKind.FULL)
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    @SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
    public static &lt;T&gt; Flowable&lt;T&gt; concat(Publisher&lt;? extends MaybeSource&lt;? extends T&gt;&gt; sources, int prefetch) {
<span class="fc" id="L334">        ObjectHelper.requireNonNull(sources, &quot;sources is null&quot;);</span>
<span class="fc" id="L335">        ObjectHelper.verifyPositive(prefetch, &quot;prefetch&quot;);</span>
<span class="fc" id="L336">        return RxJavaPlugins.onAssembly(new FlowableConcatMapPublisher(sources, MaybeToPublisher.instance(), prefetch, ErrorMode.IMMEDIATE));</span>
    }

    /**
     * Concatenate the single values, in a non-overlapping fashion, of the MaybeSource sources in the array.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;526&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.concatArray.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The returned {@code Flowable} honors the backpressure of the downstream consumer.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code concatArray} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;T&gt; the value type
     * @param sources the array of MaybeSource instances
     * @return the new Flowable instance
     */
    @BackpressureSupport(BackpressureKind.FULL)
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; Flowable&lt;T&gt; concatArray(MaybeSource&lt;? extends T&gt;... sources) {
<span class="fc" id="L359">        ObjectHelper.requireNonNull(sources, &quot;sources is null&quot;);</span>
<span class="fc bfc" id="L360" title="All 2 branches covered.">        if (sources.length == 0) {</span>
<span class="fc" id="L361">            return Flowable.empty();</span>
        }
<span class="fc bfc" id="L363" title="All 2 branches covered.">        if (sources.length == 1) {</span>
<span class="fc" id="L364">            return RxJavaPlugins.onAssembly(new MaybeToFlowable&lt;T&gt;((MaybeSource&lt;T&gt;)sources[0]));</span>
        }
<span class="fc" id="L366">        return RxJavaPlugins.onAssembly(new MaybeConcatArray&lt;T&gt;(sources));</span>
    }

    /**
     * Concatenates a variable number of MaybeSource sources and delays errors from any of them
     * till all terminate.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;425&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.concatArrayDelayError.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code concatArrayDelayError} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param sources the array of sources
     * @param &lt;T&gt; the common base value type
     * @return the new Flowable instance
     * @throws NullPointerException if sources is null
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    @BackpressureSupport(BackpressureKind.FULL)
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Flowable&lt;T&gt; concatArrayDelayError(MaybeSource&lt;? extends T&gt;... sources) {
<span class="fc bfc" id="L390" title="All 2 branches covered.">        if (sources.length == 0) {</span>
<span class="fc" id="L391">            return Flowable.empty();</span>
        } else
<span class="fc bfc" id="L393" title="All 2 branches covered.">        if (sources.length == 1) {</span>
<span class="fc" id="L394">            return RxJavaPlugins.onAssembly(new MaybeToFlowable&lt;T&gt;((MaybeSource&lt;T&gt;)sources[0]));</span>
        }
<span class="fc" id="L396">        return RxJavaPlugins.onAssembly(new MaybeConcatArrayDelayError&lt;T&gt;(sources));</span>
    }

    /**
     * Concatenates a sequence of MaybeSource eagerly into a single stream of values.
     * &lt;p&gt;
     * Eager concatenation means that once a subscriber subscribes, this operator subscribes to all of the
     * source MaybeSources. The operator buffers the value emitted by these MaybeSources and then drains them
     * in order, each one after the previous one completes.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;489&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.concatArrayEager.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This method does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;T&gt; the value type
     * @param sources a sequence of MaybeSources that need to be eagerly concatenated
     * @return the new Flowable instance with the specified concatenation behavior
     */
    @SuppressWarnings({ &quot;rawtypes&quot;, &quot;unchecked&quot; })
    @BackpressureSupport(BackpressureKind.FULL)
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Flowable&lt;T&gt; concatArrayEager(MaybeSource&lt;? extends T&gt;... sources) {
<span class="fc" id="L422">        return Flowable.fromArray(sources).concatMapEager((Function)MaybeToPublisher.instance());</span>
    }

    /**
     * Concatenates the Iterable sequence of MaybeSources into a single sequence by subscribing to each MaybeSource,
     * one after the other, one at a time and delays any errors till the all inner MaybeSources terminate.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;469&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.concatDelayError.i.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code concatDelayError} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T&gt; the common element base type
     * @param sources the Iterable sequence of MaybeSources
     * @return the new Flowable with the concatenating behavior
     */
    @SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
    @BackpressureSupport(BackpressureKind.FULL)
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Flowable&lt;T&gt; concatDelayError(Iterable&lt;? extends MaybeSource&lt;? extends T&gt;&gt; sources) {
<span class="fc" id="L447">        ObjectHelper.requireNonNull(sources, &quot;sources is null&quot;);</span>
<span class="fc" id="L448">        return Flowable.fromIterable(sources).concatMapDelayError((Function)MaybeToPublisher.instance());</span>
    }

    /**
     * Concatenates the Publisher sequence of Publishers into a single sequence by subscribing to each inner Publisher,
     * one after the other, one at a time and delays any errors till the all inner and the outer Publishers terminate.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;360&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.concatDelayError.p.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code concatDelayError} fully supports backpressure.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code concatDelayError} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T&gt; the common element base type
     * @param sources the Publisher sequence of Publishers
     * @return the new Publisher with the concatenating behavior
     */
    @SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
    @BackpressureSupport(BackpressureKind.FULL)
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Flowable&lt;T&gt; concatDelayError(Publisher&lt;? extends MaybeSource&lt;? extends T&gt;&gt; sources) {
<span class="fc" id="L472">        return Flowable.fromPublisher(sources).concatMapDelayError((Function)MaybeToPublisher.instance());</span>
    }

    /**
     * Concatenates a sequence of MaybeSources eagerly into a single stream of values.
     * &lt;p&gt;
     * Eager concatenation means that once a subscriber subscribes, this operator subscribes to all of the
     * source MaybeSources. The operator buffers the values emitted by these MaybeSources and then drains them
     * in order, each one after the previous one completes.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;526&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.concatEager.i.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;Backpressure is honored towards the downstream.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This method does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;T&gt; the value type
     * @param sources a sequence of MaybeSource that need to be eagerly concatenated
     * @return the new Flowable instance with the specified concatenation behavior
     */
    @SuppressWarnings({ &quot;rawtypes&quot;, &quot;unchecked&quot; })
    @BackpressureSupport(BackpressureKind.FULL)
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Flowable&lt;T&gt; concatEager(Iterable&lt;? extends MaybeSource&lt;? extends T&gt;&gt; sources) {
<span class="fc" id="L498">        return Flowable.fromIterable(sources).concatMapEager((Function)MaybeToPublisher.instance());</span>
    }

    /**
     * Concatenates a Publisher sequence of MaybeSources eagerly into a single stream of values.
     * &lt;p&gt;
     * Eager concatenation means that once a subscriber subscribes, this operator subscribes to all of the
     * emitted source Publishers as they are observed. The operator buffers the values emitted by these
     * Publishers and then drains them in order, each one after the previous one completes.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;511&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.concatEager.p.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;Backpressure is honored towards the downstream and the outer Publisher is
     *  expected to support backpressure. Violating this assumption, the operator will
     *  signal {@link io.reactivex.exceptions.MissingBackpressureException}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This method does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;T&gt; the value type
     * @param sources a sequence of Publishers that need to be eagerly concatenated
     * @return the new Publisher instance with the specified concatenation behavior
     */
    @SuppressWarnings({ &quot;rawtypes&quot;, &quot;unchecked&quot; })
    @BackpressureSupport(BackpressureKind.FULL)
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Flowable&lt;T&gt; concatEager(Publisher&lt;? extends MaybeSource&lt;? extends T&gt;&gt; sources) {
<span class="fc" id="L526">        return Flowable.fromPublisher(sources).concatMapEager((Function)MaybeToPublisher.instance());</span>
    }

    /**
     * Provides an API (via a cold Maybe) that bridges the reactive world with the callback-style world.
     * &lt;p&gt;
     * Example:
     * &lt;pre&gt;&lt;code&gt;
     * Maybe.&amp;lt;Event&amp;gt;create(emitter -&amp;gt; {
     *     Callback listener = new Callback() {
     *         &amp;#64;Override
     *         public void onEvent(Event e) {
     *             if (e.isNothing()) {
     *                 emitter.onComplete();
     *             } else {
     *                 emitter.onSuccess(e);
     *             }
     *         }
     *
     *         &amp;#64;Override
     *         public void onFailure(Exception e) {
     *             emitter.onError(e);
     *         }
     *     };
     *
     *     AutoCloseable c = api.someMethod(listener);
     *
     *     emitter.setCancellable(c::close);
     *
     * });
     * &lt;/code&gt;&lt;/pre&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code create} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;T&gt; the value type
     * @param onSubscribe the emitter that is called when a MaybeObserver subscribes to the returned {@code Maybe}
     * @return the new Maybe instance
     * @see MaybeOnSubscribe
     * @see Cancellable
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Maybe&lt;T&gt; create(MaybeOnSubscribe&lt;T&gt; onSubscribe) {
<span class="fc" id="L571">        ObjectHelper.requireNonNull(onSubscribe, &quot;onSubscribe is null&quot;);</span>
<span class="fc" id="L572">        return RxJavaPlugins.onAssembly(new MaybeCreate&lt;T&gt;(onSubscribe));</span>
    }

    /**
     * Calls a Callable for each individual MaybeObserver to return the actual MaybeSource source to
     * be subscribed to.
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code defer} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;T&gt; the value type
     * @param maybeSupplier the Callable that is called for each individual MaybeObserver and
     * returns a MaybeSource instance to subscribe to
     * @return the new Maybe instance
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Maybe&lt;T&gt; defer(final Callable&lt;? extends MaybeSource&lt;? extends T&gt;&gt; maybeSupplier) {
<span class="fc" id="L591">        ObjectHelper.requireNonNull(maybeSupplier, &quot;maybeSupplier is null&quot;);</span>
<span class="fc" id="L592">        return RxJavaPlugins.onAssembly(new MaybeDefer&lt;T&gt;(maybeSupplier));</span>
    }

    /**
     * Returns a (singleton) Maybe instance that calls {@link MaybeObserver#onComplete onComplete}
     * immediately.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;190&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/empty.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code empty} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;T&gt; the value type
     * @return the new Maybe instance
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; Maybe&lt;T&gt; empty() {
<span class="fc" id="L611">        return RxJavaPlugins.onAssembly((Maybe&lt;T&gt;)MaybeEmpty.INSTANCE);</span>
    }

    /**
     * Returns a Maybe that invokes a subscriber's {@link MaybeObserver#onError onError} method when the
     * subscriber subscribes to it.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;447&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.error.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code error} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param exception
     *            the particular Throwable to pass to {@link MaybeObserver#onError onError}
     * @param &lt;T&gt;
     *            the type of the item (ostensibly) emitted by the Maybe
     * @return a Maybe that invokes the subscriber's {@link MaybeObserver#onError onError} method when
     *         the subscriber subscribes to it
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/empty-never-throw.html&quot;&gt;ReactiveX operators documentation: Throw&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Maybe&lt;T&gt; error(Throwable exception) {
<span class="fc" id="L636">        ObjectHelper.requireNonNull(exception, &quot;exception is null&quot;);</span>
<span class="fc" id="L637">        return RxJavaPlugins.onAssembly(new MaybeError&lt;T&gt;(exception));</span>
    }

    /**
     * Returns a Maybe that invokes a {@link MaybeObserver}'s {@link MaybeObserver#onError onError} method when the
     * MaybeObserver subscribes to it.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;190&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/error.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code error} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param supplier
     *            a Callable factory to return a Throwable for each individual MaybeObserver
     * @param &lt;T&gt;
     *            the type of the items (ostensibly) emitted by the Maybe
     * @return a Maybe that invokes the {@link MaybeObserver}'s {@link MaybeObserver#onError onError} method when
     *         the MaybeObserver subscribes to it
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/empty-never-throw.html&quot;&gt;ReactiveX operators documentation: Throw&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Maybe&lt;T&gt; error(Callable&lt;? extends Throwable&gt; supplier) {
<span class="fc" id="L662">        ObjectHelper.requireNonNull(supplier, &quot;errorSupplier is null&quot;);</span>
<span class="fc" id="L663">        return RxJavaPlugins.onAssembly(new MaybeErrorCallable&lt;T&gt;(supplier));</span>
    }

    /**
     * Returns a Maybe instance that runs the given Action for each subscriber and
     * emits either its exception or simply completes.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code fromAction} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Error handling:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt; If the {@link Action} throws an exception, the respective {@link Throwable} is
     *  delivered to the downstream via {@link MaybeObserver#onError(Throwable)},
     *  except when the downstream has disposed this {@code Maybe} source.
     *  In this latter case, the {@code Throwable} is delivered to the global error handler via
     *  {@link RxJavaPlugins#onError(Throwable)} as an {@link io.reactivex.exceptions.UndeliverableException UndeliverableException}.
     *  &lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;T&gt; the target type
     * @param run the runnable to run for each subscriber
     * @return the new Maybe instance
     * @throws NullPointerException if run is null
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Maybe&lt;T&gt; fromAction(final Action run) {
<span class="fc" id="L689">        ObjectHelper.requireNonNull(run, &quot;run is null&quot;);</span>
<span class="fc" id="L690">        return RxJavaPlugins.onAssembly(new MaybeFromAction&lt;T&gt;(run));</span>
    }

    /**
     * Wraps a CompletableSource into a Maybe.
     *
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code fromCompletable} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;T&gt; the target type
     * @param completableSource the CompletableSource to convert from
     * @return the new Maybe instance
     * @throws NullPointerException if completable is null
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Maybe&lt;T&gt; fromCompletable(CompletableSource completableSource) {
<span class="fc" id="L709">        ObjectHelper.requireNonNull(completableSource, &quot;completableSource is null&quot;);</span>
<span class="fc" id="L710">        return RxJavaPlugins.onAssembly(new MaybeFromCompletable&lt;T&gt;(completableSource));</span>
    }

    /**
     * Wraps a SingleSource into a Maybe.
     *
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code fromSingle} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;T&gt; the target type
     * @param singleSource the SingleSource to convert from
     * @return the new Maybe instance
     * @throws NullPointerException if single is null
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Maybe&lt;T&gt; fromSingle(SingleSource&lt;T&gt; singleSource) {
<span class="fc" id="L729">        ObjectHelper.requireNonNull(singleSource, &quot;singleSource is null&quot;);</span>
<span class="fc" id="L730">        return RxJavaPlugins.onAssembly(new MaybeFromSingle&lt;T&gt;(singleSource));</span>
    }

    /**
     * Returns a {@link Maybe} that invokes the given {@link Callable} for each individual {@link MaybeObserver} that
     * subscribes and emits the resulting non-null item via {@code onSuccess} while
     * considering a {@code null} result from the {@code Callable} as indication for valueless completion
     * via {@code onComplete}.
     * &lt;p&gt;
     * This operator allows you to defer the execution of the given {@code Callable} until a {@code MaybeObserver}
     * subscribes to the  returned {@link Maybe}. In other terms, this source operator evaluates the given
     * {@code Callable} &quot;lazily&quot;.
     * &lt;p&gt;
     * Note that the {@code null} handling of this operator differs from the similar source operators in the other
     * {@link io.reactivex base reactive classes}. Those operators signal a {@code NullPointerException} if the value returned by their
     * {@code Callable} is {@code null} while this {@code fromCallable} considers it to indicate the
     * returned {@code Maybe} is empty.
     * &lt;dl&gt;
     *   &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *   &lt;dd&gt;{@code fromCallable} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     *   &lt;dt&gt;&lt;b&gt;Error handling:&lt;/b&gt;&lt;/dt&gt;
     *   &lt;dd&gt;Any non-fatal exception thrown by {@link Callable#call()} will be forwarded to {@code onError},
     *   except if the {@code MaybeObserver} disposed the subscription in the meantime. In this latter case,
     *   the exception is forwarded to the global error handler via
     *   {@link io.reactivex.plugins.RxJavaPlugins#onError(Throwable)} wrapped into a
     *   {@link io.reactivex.exceptions.UndeliverableException UndeliverableException}.
     *   Fatal exceptions are rethrown and usually will end up in the executing thread's
     *   {@link java.lang.Thread.UncaughtExceptionHandler#uncaughtException(Thread, Throwable)} handler.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param callable
     *         a {@link Callable} instance whose execution should be deferred and performed for each individual
     *         {@code MaybeObserver} that subscribes to the returned {@link Maybe}.
     * @param &lt;T&gt;
     *         the type of the item emitted by the {@link Maybe}.
     * @return a new Maybe instance
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Maybe&lt;T&gt; fromCallable(@NonNull final Callable&lt;? extends T&gt; callable) {
<span class="fc" id="L771">        ObjectHelper.requireNonNull(callable, &quot;callable is null&quot;);</span>
<span class="fc" id="L772">        return RxJavaPlugins.onAssembly(new MaybeFromCallable&lt;T&gt;(callable));</span>
    }

    /**
     * Converts a {@link Future} into a Maybe, treating a null result as an indication of emptiness.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;315&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/from.Future.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * You can convert any object that supports the {@link Future} interface into a Maybe that emits the
     * return value of the {@link Future#get} method of that object, by passing the object into the {@code from}
     * method.
     * &lt;p&gt;
     * &lt;em&gt;Important note:&lt;/em&gt; This Maybe is blocking; you cannot dispose it.
     * &lt;p&gt;
     * Unlike 1.x, disposing the Maybe won't cancel the future. If necessary, one can use composition to achieve the
     * cancellation effect: {@code futureMaybe.doOnDispose(() -&gt; future.cancel(true));}.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code fromFuture} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param future
     *            the source {@link Future}
     * @param &lt;T&gt;
     *            the type of object that the {@link Future} returns, and also the type of item to be emitted by
     *            the resulting Maybe
     * @return a Maybe that emits the item from the source {@link Future}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/from.html&quot;&gt;ReactiveX operators documentation: From&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Maybe&lt;T&gt; fromFuture(Future&lt;? extends T&gt; future) {
<span class="fc" id="L805">        ObjectHelper.requireNonNull(future, &quot;future is null&quot;);</span>
<span class="fc" id="L806">        return RxJavaPlugins.onAssembly(new MaybeFromFuture&lt;T&gt;(future, 0L, null));</span>
    }

    /**
     * Converts a {@link Future} into a Maybe, with a timeout on the Future.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;315&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/from.Future.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * You can convert any object that supports the {@link Future} interface into a Maybe that emits the
     * return value of the {@link Future#get} method of that object, by passing the object into the {@code fromFuture}
     * method.
     * &lt;p&gt;
     * Unlike 1.x, disposing the Maybe won't cancel the future. If necessary, one can use composition to achieve the
     * cancellation effect: {@code futureMaybe.doOnCancel(() -&gt; future.cancel(true));}.
     * &lt;p&gt;
     * &lt;em&gt;Important note:&lt;/em&gt; This Maybe is blocking on the thread it gets subscribed on; you cannot dispose it.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code fromFuture} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param future
     *            the source {@link Future}
     * @param timeout
     *            the maximum time to wait before calling {@code get}
     * @param unit
     *            the {@link TimeUnit} of the {@code timeout} argument
     * @param &lt;T&gt;
     *            the type of object that the {@link Future} returns, and also the type of item to be emitted by
     *            the resulting Maybe
     * @return a Maybe that emits the item from the source {@link Future}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/from.html&quot;&gt;ReactiveX operators documentation: From&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Maybe&lt;T&gt; fromFuture(Future&lt;? extends T&gt; future, long timeout, TimeUnit unit) {
<span class="fc" id="L843">        ObjectHelper.requireNonNull(future, &quot;future is null&quot;);</span>
<span class="fc" id="L844">        ObjectHelper.requireNonNull(unit, &quot;unit is null&quot;);</span>
<span class="fc" id="L845">        return RxJavaPlugins.onAssembly(new MaybeFromFuture&lt;T&gt;(future, timeout, unit));</span>
    }

    /**
     * Returns a Maybe instance that runs the given Action for each subscriber and
     * emits either its exception or simply completes.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code fromRunnable} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;T&gt; the target type
     * @param run the runnable to run for each subscriber
     * @return the new Maybe instance
     * @throws NullPointerException if run is null
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Maybe&lt;T&gt; fromRunnable(final Runnable run) {
<span class="fc" id="L864">        ObjectHelper.requireNonNull(run, &quot;run is null&quot;);</span>
<span class="fc" id="L865">        return RxJavaPlugins.onAssembly(new MaybeFromRunnable&lt;T&gt;(run));</span>
    }

    /**
     * Returns a {@code Maybe} that emits a specified item.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;485&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.just.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * To convert any object into a {@code Maybe} that emits that object, pass that object into the
     * {@code just} method.
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code just} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param item
     *            the item to emit
     * @param &lt;T&gt;
     *            the type of that item
     * @return a {@code Maybe} that emits {@code item}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/just.html&quot;&gt;ReactiveX operators documentation: Just&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Maybe&lt;T&gt; just(T item) {
<span class="fc" id="L891">        ObjectHelper.requireNonNull(item, &quot;item is null&quot;);</span>
<span class="fc" id="L892">        return RxJavaPlugins.onAssembly(new MaybeJust&lt;T&gt;(item));</span>
    }

    /**
     * Merges an Iterable sequence of MaybeSource instances into a single Flowable sequence,
     * running all MaybeSources at once.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream.&lt;/dd&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code merge} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Error handling:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;If any of the source {@code MaybeSource}s signal a {@code Throwable} via {@code onError}, the resulting
     *  {@code Flowable} terminates with that {@code Throwable} and all other source {@code MaybeSource}s are disposed.
     *  If more than one {@code MaybeSource} signals an error, the resulting {@code Flowable} may terminate with the
     *  first one's error or, depending on the concurrency of the sources, may terminate with a
     *  {@code CompositeException} containing two or more of the various error signals.
     *  {@code Throwable}s that didn't make into the composite will be sent (individually) to the global error handler via
     *  {@link RxJavaPlugins#onError(Throwable)} method as {@code UndeliverableException} errors. Similarly, {@code Throwable}s
     *  signaled by source(s) after the returned {@code Flowable} has been cancelled or terminated with a
     *  (composite) error will be sent to the same global error handler.
     *  Use {@link #mergeDelayError(Iterable)} to merge sources and terminate only when all source {@code MaybeSource}s
     *  have completed or failed with an error.
     *  &lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;T&gt; the common and resulting value type
     * @param sources the Iterable sequence of MaybeSource sources
     * @return the new Flowable instance
     * @see #mergeDelayError(Iterable)
     */
    @BackpressureSupport(BackpressureKind.FULL)
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Flowable&lt;T&gt; merge(Iterable&lt;? extends MaybeSource&lt;? extends T&gt;&gt; sources) {
<span class="fc" id="L926">        return merge(Flowable.fromIterable(sources));</span>
    }

    /**
     * Merges a Flowable sequence of MaybeSource instances into a single Flowable sequence,
     * running all MaybeSources at once.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream.&lt;/dd&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code merge} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Error handling:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;If any of the source {@code MaybeSource}s signal a {@code Throwable} via {@code onError}, the resulting
     *  {@code Flowable} terminates with that {@code Throwable} and all other source {@code MaybeSource}s are disposed.
     *  If more than one {@code MaybeSource} signals an error, the resulting {@code Flowable} may terminate with the
     *  first one's error or, depending on the concurrency of the sources, may terminate with a
     *  {@code CompositeException} containing two or more of the various error signals.
     *  {@code Throwable}s that didn't make into the composite will be sent (individually) to the global error handler via
     *  {@link RxJavaPlugins#onError(Throwable)} method as {@code UndeliverableException} errors. Similarly, {@code Throwable}s
     *  signaled by source(s) after the returned {@code Flowable} has been cancelled or terminated with a
     *  (composite) error will be sent to the same global error handler.
     *  Use {@link #mergeDelayError(Publisher)} to merge sources and terminate only when all source {@code MaybeSource}s
     *  have completed or failed with an error.
     *  &lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;T&gt; the common and resulting value type
     * @param sources the Flowable sequence of MaybeSource sources
     * @return the new Flowable instance
     * @see #mergeDelayError(Publisher)
     */
    @BackpressureSupport(BackpressureKind.FULL)
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Flowable&lt;T&gt; merge(Publisher&lt;? extends MaybeSource&lt;? extends T&gt;&gt; sources) {
<span class="fc" id="L960">        return merge(sources, Integer.MAX_VALUE);</span>
    }

    /**
     * Merges a Flowable sequence of MaybeSource instances into a single Flowable sequence,
     * running at most maxConcurrency MaybeSources at once.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream.&lt;/dd&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code merge} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Error handling:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;If any of the source {@code MaybeSource}s signal a {@code Throwable} via {@code onError}, the resulting
     *  {@code Flowable} terminates with that {@code Throwable} and all other source {@code MaybeSource}s are disposed.
     *  If more than one {@code MaybeSource} signals an error, the resulting {@code Flowable} may terminate with the
     *  first one's error or, depending on the concurrency of the sources, may terminate with a
     *  {@code CompositeException} containing two or more of the various error signals.
     *  {@code Throwable}s that didn't make into the composite will be sent (individually) to the global error handler via
     *  {@link RxJavaPlugins#onError(Throwable)} method as {@code UndeliverableException} errors. Similarly, {@code Throwable}s
     *  signaled by source(s) after the returned {@code Flowable} has been cancelled or terminated with a
     *  (composite) error will be sent to the same global error handler.
     *  Use {@link #mergeDelayError(Publisher, int)} to merge sources and terminate only when all source {@code MaybeSource}s
     *  have completed or failed with an error.
     *  &lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;T&gt; the common and resulting value type
     * @param sources the Flowable sequence of MaybeSource sources
     * @param maxConcurrency the maximum number of concurrently running MaybeSources
     * @return the new Flowable instance
     * @see #mergeDelayError(Publisher, int)
     */
    @BackpressureSupport(BackpressureKind.FULL)
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    @SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
    public static &lt;T&gt; Flowable&lt;T&gt; merge(Publisher&lt;? extends MaybeSource&lt;? extends T&gt;&gt; sources, int maxConcurrency) {
<span class="fc" id="L997">        ObjectHelper.requireNonNull(sources, &quot;source is null&quot;);</span>
<span class="fc" id="L998">        ObjectHelper.verifyPositive(maxConcurrency, &quot;maxConcurrency&quot;);</span>
<span class="fc" id="L999">        return RxJavaPlugins.onAssembly(new FlowableFlatMapPublisher(sources, MaybeToPublisher.instance(), false, maxConcurrency, 1));</span>
    }

    /**
     * Flattens a {@code MaybeSource} that emits a {@code MaybeSource} into a single {@code MaybeSource} that emits the item
     * emitted by the nested {@code MaybeSource}, without any transformation.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;393&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.merge.oo.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code merge} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;dt&gt;&lt;b&gt;Error handling:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;The resulting {@code Maybe} emits the outer source's or the inner {@code MaybeSource}'s {@code Throwable} as is.
     * Unlike the other {@code merge()} operators, this operator won't and can't produce a {@code CompositeException} because there is
     * only one possibility for the outer or the inner {@code MaybeSource} to emit an {@code onError} signal.
     * Therefore, there is no need for a {@code mergeDelayError(MaybeSource&lt;MaybeSource&lt;T&gt;&gt;)} operator.
     * &lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T&gt; the value type of the sources and the output
     * @param source
     *            a {@code MaybeSource} that emits a {@code MaybeSource}
     * @return a {@code Maybe} that emits the item that is the result of flattening the {@code MaybeSource} emitted
     *         by {@code source}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/merge.html&quot;&gt;ReactiveX operators documentation: Merge&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    @SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
    public static &lt;T&gt; Maybe&lt;T&gt; merge(MaybeSource&lt;? extends MaybeSource&lt;? extends T&gt;&gt; source) {
<span class="fc" id="L1030">        ObjectHelper.requireNonNull(source, &quot;source is null&quot;);</span>
<span class="fc" id="L1031">        return RxJavaPlugins.onAssembly(new MaybeFlatten(source, Functions.identity()));</span>
    }

    /**
     * Flattens two MaybeSources into a single Flowable, without any transformation.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;483&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.merge.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * You can combine items emitted by multiple MaybeSources so that they appear as a single Flowable, by
     * using the {@code merge} method.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream.&lt;/dd&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code merge} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Error handling:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;If any of the source {@code MaybeSource}s signal a {@code Throwable} via {@code onError}, the resulting
     *  {@code Flowable} terminates with that {@code Throwable} and all other source {@code MaybeSource}s are disposed.
     *  If more than one {@code MaybeSource} signals an error, the resulting {@code Flowable} may terminate with the
     *  first one's error or, depending on the concurrency of the sources, may terminate with a
     *  {@code CompositeException} containing two or more of the various error signals.
     *  {@code Throwable}s that didn't make into the composite will be sent (individually) to the global error handler via
     *  {@link RxJavaPlugins#onError(Throwable)} method as {@code UndeliverableException} errors. Similarly, {@code Throwable}s
     *  signaled by source(s) after the returned {@code Flowable} has been cancelled or terminated with a
     *  (composite) error will be sent to the same global error handler.
     *  Use {@link #mergeDelayError(MaybeSource, MaybeSource)} to merge sources and terminate only when all source {@code MaybeSource}s
     *  have completed or failed with an error.
     *  &lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T&gt; the common value type
     * @param source1
     *            a MaybeSource to be merged
     * @param source2
     *            a MaybeSource to be merged
     * @return a Flowable that emits all of the items emitted by the source MaybeSources
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/merge.html&quot;&gt;ReactiveX operators documentation: Merge&lt;/a&gt;
     * @see #mergeDelayError(MaybeSource, MaybeSource)
     */
    @BackpressureSupport(BackpressureKind.FULL)
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; Flowable&lt;T&gt; merge(
            MaybeSource&lt;? extends T&gt; source1, MaybeSource&lt;? extends T&gt; source2
     ) {
<span class="fc" id="L1078">        ObjectHelper.requireNonNull(source1, &quot;source1 is null&quot;);</span>
<span class="fc" id="L1079">        ObjectHelper.requireNonNull(source2, &quot;source2 is null&quot;);</span>
<span class="fc" id="L1080">        return mergeArray(source1, source2);</span>
    }

    /**
     * Flattens three MaybeSources into a single Flowable, without any transformation.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;483&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.merge.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * You can combine items emitted by multiple MaybeSources so that they appear as a single Flowable, by using
     * the {@code merge} method.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream.&lt;/dd&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code merge} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Error handling:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;If any of the source {@code MaybeSource}s signal a {@code Throwable} via {@code onError}, the resulting
     *  {@code Flowable} terminates with that {@code Throwable} and all other source {@code MaybeSource}s are disposed.
     *  If more than one {@code MaybeSource} signals an error, the resulting {@code Flowable} may terminate with the
     *  first one's error or, depending on the concurrency of the sources, may terminate with a
     *  {@code CompositeException} containing two or more of the various error signals.
     *  {@code Throwable}s that didn't make into the composite will be sent (individually) to the global error handler via
     *  {@link RxJavaPlugins#onError(Throwable)} method as {@code UndeliverableException} errors. Similarly, {@code Throwable}s
     *  signaled by source(s) after the returned {@code Flowable} has been cancelled or terminated with a
     *  (composite) error will be sent to the same global error handler.
     *  Use {@link #mergeDelayError(MaybeSource, MaybeSource, MaybeSource)} to merge sources and terminate only when all source {@code MaybeSource}s
     *  have completed or failed with an error.
     *  &lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T&gt; the common value type
     * @param source1
     *            a MaybeSource to be merged
     * @param source2
     *            a MaybeSource to be merged
     * @param source3
     *            a MaybeSource to be merged
     * @return a Flowable that emits all of the items emitted by the source MaybeSources
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/merge.html&quot;&gt;ReactiveX operators documentation: Merge&lt;/a&gt;
     * @see #mergeDelayError(MaybeSource, MaybeSource, MaybeSource)
     */
    @BackpressureSupport(BackpressureKind.FULL)
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; Flowable&lt;T&gt; merge(
            MaybeSource&lt;? extends T&gt; source1, MaybeSource&lt;? extends T&gt; source2,
            MaybeSource&lt;? extends T&gt; source3
     ) {
<span class="fc" id="L1130">        ObjectHelper.requireNonNull(source1, &quot;source1 is null&quot;);</span>
<span class="fc" id="L1131">        ObjectHelper.requireNonNull(source2, &quot;source2 is null&quot;);</span>
<span class="fc" id="L1132">        ObjectHelper.requireNonNull(source3, &quot;source3 is null&quot;);</span>
<span class="fc" id="L1133">        return mergeArray(source1, source2, source3);</span>
    }

    /**
     * Flattens four MaybeSources into a single Flowable, without any transformation.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;483&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.merge.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * You can combine items emitted by multiple MaybeSources so that they appear as a single Flowable, by using
     * the {@code merge} method.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream.&lt;/dd&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code merge} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Error handling:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;If any of the source {@code MaybeSource}s signal a {@code Throwable} via {@code onError}, the resulting
     *  {@code Flowable} terminates with that {@code Throwable} and all other source {@code MaybeSource}s are disposed.
     *  If more than one {@code MaybeSource} signals an error, the resulting {@code Flowable} may terminate with the
     *  first one's error or, depending on the concurrency of the sources, may terminate with a
     *  {@code CompositeException} containing two or more of the various error signals.
     *  {@code Throwable}s that didn't make into the composite will be sent (individually) to the global error handler via
     *  {@link RxJavaPlugins#onError(Throwable)} method as {@code UndeliverableException} errors. Similarly, {@code Throwable}s
     *  signaled by source(s) after the returned {@code Flowable} has been cancelled or terminated with a
     *  (composite) error will be sent to the same global error handler.
     *  Use {@link #mergeDelayError(MaybeSource, MaybeSource, MaybeSource, MaybeSource)} to merge sources and terminate only when all source {@code MaybeSource}s
     *  have completed or failed with an error.
     *  &lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T&gt; the common value type
     * @param source1
     *            a MaybeSource to be merged
     * @param source2
     *            a MaybeSource to be merged
     * @param source3
     *            a MaybeSource to be merged
     * @param source4
     *            a MaybeSource to be merged
     * @return a Flowable that emits all of the items emitted by the source MaybeSources
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/merge.html&quot;&gt;ReactiveX operators documentation: Merge&lt;/a&gt;
     * @see #mergeDelayError(MaybeSource, MaybeSource, MaybeSource, MaybeSource)
     */
    @BackpressureSupport(BackpressureKind.FULL)
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; Flowable&lt;T&gt; merge(
            MaybeSource&lt;? extends T&gt; source1, MaybeSource&lt;? extends T&gt; source2,
            MaybeSource&lt;? extends T&gt; source3, MaybeSource&lt;? extends T&gt; source4
     ) {
<span class="fc" id="L1185">        ObjectHelper.requireNonNull(source1, &quot;source1 is null&quot;);</span>
<span class="fc" id="L1186">        ObjectHelper.requireNonNull(source2, &quot;source2 is null&quot;);</span>
<span class="fc" id="L1187">        ObjectHelper.requireNonNull(source3, &quot;source3 is null&quot;);</span>
<span class="fc" id="L1188">        ObjectHelper.requireNonNull(source4, &quot;source4 is null&quot;);</span>
<span class="fc" id="L1189">        return mergeArray(source1, source2, source3, source4);</span>
    }

    /**
     * Merges an array sequence of MaybeSource instances into a single Flowable sequence,
     * running all MaybeSources at once.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream.&lt;/dd&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code mergeArray} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Error handling:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;If any of the source {@code MaybeSource}s signal a {@code Throwable} via {@code onError}, the resulting
     *  {@code Flowable} terminates with that {@code Throwable} and all other source {@code MaybeSource}s are disposed.
     *  If more than one {@code MaybeSource} signals an error, the resulting {@code Flowable} may terminate with the
     *  first one's error or, depending on the concurrency of the sources, may terminate with a
     *  {@code CompositeException} containing two or more of the various error signals.
     *  {@code Throwable}s that didn't make into the composite will be sent (individually) to the global error handler via
     *  {@link RxJavaPlugins#onError(Throwable)} method as {@code UndeliverableException} errors. Similarly, {@code Throwable}s
     *  signaled by source(s) after the returned {@code Flowable} has been cancelled or terminated with a
     *  (composite) error will be sent to the same global error handler.
     *  Use {@link #mergeArrayDelayError(MaybeSource...)} to merge sources and terminate only when all source {@code MaybeSource}s
     *  have completed or failed with an error.
     *  &lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;T&gt; the common and resulting value type
     * @param sources the array sequence of MaybeSource sources
     * @return the new Flowable instance
     * @see #mergeArrayDelayError(MaybeSource...)
     */
    @BackpressureSupport(BackpressureKind.FULL)
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; Flowable&lt;T&gt; mergeArray(MaybeSource&lt;? extends T&gt;... sources) {
<span class="fc" id="L1225">        ObjectHelper.requireNonNull(sources, &quot;sources is null&quot;);</span>
<span class="fc bfc" id="L1226" title="All 2 branches covered.">        if (sources.length == 0) {</span>
<span class="fc" id="L1227">            return Flowable.empty();</span>
        }
<span class="fc bfc" id="L1229" title="All 2 branches covered.">        if (sources.length == 1) {</span>
<span class="fc" id="L1230">            return RxJavaPlugins.onAssembly(new MaybeToFlowable&lt;T&gt;((MaybeSource&lt;T&gt;)sources[0]));</span>
        }
<span class="fc" id="L1232">        return RxJavaPlugins.onAssembly(new MaybeMergeArray&lt;T&gt;(sources));</span>
    }

    /**
     * Flattens an array of MaybeSources into one Flowable, in a way that allows a Subscriber to receive all
     * successfully emitted items from each of the source MaybeSources without being interrupted by an error
     * notification from one of them.
     * &lt;p&gt;
     * This behaves like {@link #merge(Publisher)} except that if any of the merged MaybeSources notify of an
     * error via {@link Subscriber#onError onError}, {@code mergeDelayError} will refrain from propagating that
     * error notification until all of the merged MaybeSources have finished emitting items.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/mergeDelayError.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * Even if multiple merged MaybeSources send {@code onError} notifications, {@code mergeDelayError} will only
     * invoke the {@code onError} method of its Subscribers once.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code mergeArrayDelayError} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T&gt; the common element base type
     * @param sources
     *            the Iterable of MaybeSources
     * @return a Flowable that emits items that are the result of flattening the items emitted by the
     *         MaybeSources in the Iterable
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/merge.html&quot;&gt;ReactiveX operators documentation: Merge&lt;/a&gt;
     */
    @SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
    @BackpressureSupport(BackpressureKind.FULL)
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Flowable&lt;T&gt; mergeArrayDelayError(MaybeSource&lt;? extends T&gt;... sources) {
<span class="fc bfc" id="L1267" title="All 2 branches covered.">        if (sources.length == 0) {</span>
<span class="fc" id="L1268">            return Flowable.empty();</span>
        }
<span class="fc" id="L1270">        return Flowable.fromArray(sources).flatMap((Function)MaybeToPublisher.instance(), true, sources.length);</span>
    }

    /**
     * Flattens an Iterable of MaybeSources into one Flowable, in a way that allows a Subscriber to receive all
     * successfully emitted items from each of the source MaybeSources without being interrupted by an error
     * notification from one of them.
     * &lt;p&gt;
     * This behaves like {@link #merge(Publisher)} except that if any of the merged MaybeSources notify of an
     * error via {@link Subscriber#onError onError}, {@code mergeDelayError} will refrain from propagating that
     * error notification until all of the merged MaybeSources have finished emitting items.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/mergeDelayError.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * Even if multiple merged MaybeSources send {@code onError} notifications, {@code mergeDelayError} will only
     * invoke the {@code onError} method of its Subscribers once.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code mergeDelayError} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T&gt; the common element base type
     * @param sources
     *            the Iterable of MaybeSources
     * @return a Flowable that emits items that are the result of flattening the items emitted by the
     *         MaybeSources in the Iterable
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/merge.html&quot;&gt;ReactiveX operators documentation: Merge&lt;/a&gt;
     */
    @SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
    @BackpressureSupport(BackpressureKind.FULL)
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Flowable&lt;T&gt; mergeDelayError(Iterable&lt;? extends MaybeSource&lt;? extends T&gt;&gt; sources) {
<span class="fc" id="L1305">        return Flowable.fromIterable(sources).flatMap((Function)MaybeToPublisher.instance(), true);</span>
    }

    /**
     * Flattens a Publisher that emits MaybeSources into one Publisher, in a way that allows a Subscriber to
     * receive all successfully emitted items from all of the source MaybeSources without being interrupted by
     * an error notification from one of them or even the main Publisher.
     * &lt;p&gt;
     * This behaves like {@link #merge(Publisher)} except that if any of the merged MaybeSources notify of an
     * error via {@link Subscriber#onError onError}, {@code mergeDelayError} will refrain from propagating that
     * error notification until all of the merged MaybeSources and the main Publisher have finished emitting items.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/mergeDelayError.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * Even if multiple merged Publishers send {@code onError} notifications, {@code mergeDelayError} will only
     * invoke the {@code onError} method of its Subscribers once.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream. The outer {@code Publisher} is consumed
     *  in unbounded mode (i.e., no backpressure is applied to it).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code mergeDelayError} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T&gt; the common element base type
     * @param sources
     *            a Publisher that emits MaybeSources
     * @return a Flowable that emits all of the items emitted by the Publishers emitted by the
     *         {@code source} Publisher
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/merge.html&quot;&gt;ReactiveX operators documentation: Merge&lt;/a&gt;
     */
    @BackpressureSupport(BackpressureKind.FULL)
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Flowable&lt;T&gt; mergeDelayError(Publisher&lt;? extends MaybeSource&lt;? extends T&gt;&gt; sources) {
<span class="fc" id="L1340">        return mergeDelayError(sources, Integer.MAX_VALUE);</span>
    }

    /**
     * Flattens a Publisher that emits MaybeSources into one Publisher, in a way that allows a Subscriber to
     * receive all successfully emitted items from all of the source MaybeSources without being interrupted by
     * an error notification from one of them or even the main Publisher as well as limiting the total number of active MaybeSources.
     * &lt;p&gt;
     * This behaves like {@link #merge(Publisher, int)} except that if any of the merged MaybeSources notify of an
     * error via {@link Subscriber#onError onError}, {@code mergeDelayError} will refrain from propagating that
     * error notification until all of the merged MaybeSources and the main Publisher have finished emitting items.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/mergeDelayError.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * Even if multiple merged Publishers send {@code onError} notifications, {@code mergeDelayError} will only
     * invoke the {@code onError} method of its Subscribers once.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream. The outer {@code Publisher} is consumed
     *  in unbounded mode (i.e., no backpressure is applied to it).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code mergeDelayError} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * &lt;p&gt;History: 2.1.9 - experimental
     * @param &lt;T&gt; the common element base type
     * @param sources
     *            a Publisher that emits MaybeSources
     * @param maxConcurrency the maximum number of active inner MaybeSources to be merged at a time
     * @return a Flowable that emits all of the items emitted by the Publishers emitted by the
     *         {@code source} Publisher
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/merge.html&quot;&gt;ReactiveX operators documentation: Merge&lt;/a&gt;
     * @since 2.2
     */
    @SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
    @BackpressureSupport(BackpressureKind.FULL)
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Flowable&lt;T&gt; mergeDelayError(Publisher&lt;? extends MaybeSource&lt;? extends T&gt;&gt; sources, int maxConcurrency) {
<span class="fc" id="L1379">        ObjectHelper.requireNonNull(sources, &quot;source is null&quot;);</span>
<span class="fc" id="L1380">        ObjectHelper.verifyPositive(maxConcurrency, &quot;maxConcurrency&quot;);</span>
<span class="fc" id="L1381">        return RxJavaPlugins.onAssembly(new FlowableFlatMapPublisher(sources, MaybeToPublisher.instance(), true, maxConcurrency, 1));</span>
    }

    /**
     * Flattens two MaybeSources into one Flowable, in a way that allows a Subscriber to receive all
     * successfully emitted items from each of the source MaybeSources without being interrupted by an error
     * notification from one of them.
     * &lt;p&gt;
     * This behaves like {@link #merge(MaybeSource, MaybeSource)} except that if any of the merged MaybeSources
     * notify of an error via {@link Subscriber#onError onError}, {@code mergeDelayError} will refrain from
     * propagating that error notification until all of the merged MaybeSources have finished emitting items.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/mergeDelayError.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * Even if both merged MaybeSources send {@code onError} notifications, {@code mergeDelayError} will only
     * invoke the {@code onError} method of its Subscribers once.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code mergeDelayError} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T&gt; the common element base type
     * @param source1
     *            a MaybeSource to be merged
     * @param source2
     *            a MaybeSource to be merged
     * @return a Flowable that emits all of the items that are emitted by the two source MaybeSources
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/merge.html&quot;&gt;ReactiveX operators documentation: Merge&lt;/a&gt;
     */
    @SuppressWarnings({ &quot;unchecked&quot; })
    @BackpressureSupport(BackpressureKind.FULL)
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Flowable&lt;T&gt; mergeDelayError(MaybeSource&lt;? extends T&gt; source1, MaybeSource&lt;? extends T&gt; source2) {
<span class="fc" id="L1418">        ObjectHelper.requireNonNull(source1, &quot;source1 is null&quot;);</span>
<span class="fc" id="L1419">        ObjectHelper.requireNonNull(source2, &quot;source2 is null&quot;);</span>
<span class="fc" id="L1420">        return mergeArrayDelayError(source1, source2);</span>
    }

    /**
     * Flattens three MaybeSource into one Flowable, in a way that allows a Subscriber to receive all
     * successfully emitted items from all of the source MaybeSources without being interrupted by an error
     * notification from one of them.
     * &lt;p&gt;
     * This behaves like {@link #merge(MaybeSource, MaybeSource, MaybeSource)} except that if any of the merged
     * MaybeSources notify of an error via {@link Subscriber#onError onError}, {@code mergeDelayError} will refrain
     * from propagating that error notification until all of the merged MaybeSources have finished emitting
     * items.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/mergeDelayError.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * Even if multiple merged MaybeSources send {@code onError} notifications, {@code mergeDelayError} will only
     * invoke the {@code onError} method of its Subscribers once.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code mergeDelayError} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T&gt; the common element base type
     * @param source1
     *            a MaybeSource to be merged
     * @param source2
     *            a MaybeSource to be merged
     * @param source3
     *            a MaybeSource to be merged
     * @return a Flowable that emits all of the items that are emitted by the source MaybeSources
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/merge.html&quot;&gt;ReactiveX operators documentation: Merge&lt;/a&gt;
     */
    @SuppressWarnings({ &quot;unchecked&quot; })
    @BackpressureSupport(BackpressureKind.FULL)
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Flowable&lt;T&gt; mergeDelayError(MaybeSource&lt;? extends T&gt; source1,
            MaybeSource&lt;? extends T&gt; source2, MaybeSource&lt;? extends T&gt; source3) {
<span class="fc" id="L1461">        ObjectHelper.requireNonNull(source1, &quot;source1 is null&quot;);</span>
<span class="fc" id="L1462">        ObjectHelper.requireNonNull(source2, &quot;source2 is null&quot;);</span>
<span class="fc" id="L1463">        ObjectHelper.requireNonNull(source3, &quot;source3 is null&quot;);</span>
<span class="fc" id="L1464">        return mergeArrayDelayError(source1, source2, source3);</span>
    }

    /**
     * Flattens four MaybeSources into one Flowable, in a way that allows a Subscriber to receive all
     * successfully emitted items from all of the source MaybeSources without being interrupted by an error
     * notification from one of them.
     * &lt;p&gt;
     * This behaves like {@link #merge(MaybeSource, MaybeSource, MaybeSource, MaybeSource)} except that if any of
     * the merged MaybeSources notify of an error via {@link Subscriber#onError onError}, {@code mergeDelayError}
     * will refrain from propagating that error notification until all of the merged MaybeSources have finished
     * emitting items.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/mergeDelayError.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * Even if multiple merged MaybeSources send {@code onError} notifications, {@code mergeDelayError} will only
     * invoke the {@code onError} method of its Subscribers once.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code mergeDelayError} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T&gt; the common element base type
     * @param source1
     *            a MaybeSource to be merged
     * @param source2
     *            a MaybeSource to be merged
     * @param source3
     *            a MaybeSource to be merged
     * @param source4
     *            a MaybeSource to be merged
     * @return a Flowable that emits all of the items that are emitted by the source MaybeSources
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/merge.html&quot;&gt;ReactiveX operators documentation: Merge&lt;/a&gt;
     */
    @SuppressWarnings({ &quot;unchecked&quot; })
    @BackpressureSupport(BackpressureKind.FULL)
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Flowable&lt;T&gt; mergeDelayError(
            MaybeSource&lt;? extends T&gt; source1, MaybeSource&lt;? extends T&gt; source2,
            MaybeSource&lt;? extends T&gt; source3, MaybeSource&lt;? extends T&gt; source4) {
<span class="fc" id="L1508">        ObjectHelper.requireNonNull(source1, &quot;source1 is null&quot;);</span>
<span class="fc" id="L1509">        ObjectHelper.requireNonNull(source2, &quot;source2 is null&quot;);</span>
<span class="fc" id="L1510">        ObjectHelper.requireNonNull(source3, &quot;source3 is null&quot;);</span>
<span class="fc" id="L1511">        ObjectHelper.requireNonNull(source4, &quot;source4 is null&quot;);</span>
<span class="fc" id="L1512">        return mergeArrayDelayError(source1, source2, source3, source4);</span>
    }

    /**
     * Returns a Maybe that never sends any items or notifications to a {@link MaybeObserver}.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;185&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/never.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * This Maybe is useful primarily for testing purposes.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code never} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T&gt;
     *            the type of items (not) emitted by the Maybe
     * @return a Maybe that never emits any items or sends any notifications to a {@link MaybeObserver}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/empty-never-throw.html&quot;&gt;ReactiveX operators documentation: Never&lt;/a&gt;
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; Maybe&lt;T&gt; never() {
<span class="fc" id="L1535">        return RxJavaPlugins.onAssembly((Maybe&lt;T&gt;)MaybeNever.INSTANCE);</span>
    }

    /**
     * Returns a Single that emits a Boolean value that indicates whether two MaybeSource sequences are the
     * same by comparing the items emitted by each MaybeSource pairwise.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;385&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/sequenceEqual.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code sequenceEqual} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param source1
     *            the first MaybeSource to compare
     * @param source2
     *            the second MaybeSource to compare
     * @param &lt;T&gt;
     *            the type of items emitted by each MaybeSource
     * @return a Single that emits a Boolean value that indicates whether the two sequences are the same
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/sequenceequal.html&quot;&gt;ReactiveX operators documentation: SequenceEqual&lt;/a&gt;
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Single&lt;Boolean&gt; sequenceEqual(MaybeSource&lt;? extends T&gt; source1, MaybeSource&lt;? extends T&gt; source2) {
<span class="fc" id="L1560">        return sequenceEqual(source1, source2, ObjectHelper.equalsPredicate());</span>
    }

    /**
     * Returns a Single that emits a Boolean value that indicates whether two MaybeSources are the
     * same by comparing the items emitted by each MaybeSource pairwise based on the results of a specified
     * equality function.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;385&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/sequenceEqual.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code sequenceEqual} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param source1
     *            the first MaybeSource to compare
     * @param source2
     *            the second MaybeSource to compare
     * @param isEqual
     *            a function used to compare items emitted by each MaybeSource
     * @param &lt;T&gt;
     *            the type of items emitted by each MaybeSource
     * @return a Single that emits a Boolean value that indicates whether the two MaybeSource sequences
     *         are the same according to the specified function
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/sequenceequal.html&quot;&gt;ReactiveX operators documentation: SequenceEqual&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Single&lt;Boolean&gt; sequenceEqual(MaybeSource&lt;? extends T&gt; source1, MaybeSource&lt;? extends T&gt; source2,
            BiPredicate&lt;? super T, ? super T&gt; isEqual) {
<span class="fc" id="L1591">        ObjectHelper.requireNonNull(source1, &quot;source1 is null&quot;);</span>
<span class="fc" id="L1592">        ObjectHelper.requireNonNull(source2, &quot;source2 is null&quot;);</span>
<span class="fc" id="L1593">        ObjectHelper.requireNonNull(isEqual, &quot;isEqual is null&quot;);</span>
<span class="fc" id="L1594">        return RxJavaPlugins.onAssembly(new MaybeEqualSingle&lt;T&gt;(source1, source2, isEqual));</span>
    }

    /**
     * Returns a Maybe that emits {@code 0L} after a specified delay.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;200&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/timer.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code timer} operates by default on the {@code computation} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param delay
     *            the initial delay before emitting a single {@code 0L}
     * @param unit
     *            time units to use for {@code delay}
     * @return a Maybe that emits {@code 0L} after a specified delay
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/timer.html&quot;&gt;ReactiveX operators documentation: Timer&lt;/a&gt;
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.COMPUTATION)
    public static Maybe&lt;Long&gt; timer(long delay, TimeUnit unit) {
<span class="fc" id="L1616">        return timer(delay, unit, Schedulers.computation());</span>
    }

    /**
     * Returns a Maybe that emits {@code 0L} after a specified delay on a specified Scheduler.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;200&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/timer.s.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;You specify which {@link Scheduler} this operator will use.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param delay
     *            the initial delay before emitting a single 0L
     * @param unit
     *            time units to use for {@code delay}
     * @param scheduler
     *            the {@link Scheduler} to use for scheduling the item
     * @return a Maybe that emits {@code 0L} after a specified delay, on a specified Scheduler
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/timer.html&quot;&gt;ReactiveX operators documentation: Timer&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public static Maybe&lt;Long&gt; timer(long delay, TimeUnit unit, Scheduler scheduler) {
<span class="fc" id="L1641">        ObjectHelper.requireNonNull(unit, &quot;unit is null&quot;);</span>
<span class="fc" id="L1642">        ObjectHelper.requireNonNull(scheduler, &quot;scheduler is null&quot;);</span>

<span class="fc" id="L1644">        return RxJavaPlugins.onAssembly(new MaybeTimer(Math.max(0L, delay), unit, scheduler));</span>
    }

    /**
     * &lt;strong&gt;Advanced use only:&lt;/strong&gt; creates a Maybe instance without
     * any safeguards by using a callback that is called with a MaybeObserver.
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code unsafeCreate} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;T&gt; the value type
     * @param onSubscribe the function that is called with the subscribing MaybeObserver
     * @return the new Maybe instance
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Maybe&lt;T&gt; unsafeCreate(MaybeSource&lt;T&gt; onSubscribe) {
<span class="fc bfc" id="L1662" title="All 2 branches covered.">        if (onSubscribe instanceof Maybe) {</span>
<span class="fc" id="L1663">            throw new IllegalArgumentException(&quot;unsafeCreate(Maybe) should be upgraded&quot;);</span>
        }
<span class="fc" id="L1665">        ObjectHelper.requireNonNull(onSubscribe, &quot;onSubscribe is null&quot;);</span>
<span class="fc" id="L1666">        return RxJavaPlugins.onAssembly(new MaybeUnsafeCreate&lt;T&gt;(onSubscribe));</span>
    }

    /**
     * Constructs a Maybe that creates a dependent resource object which is disposed of when the
     * upstream terminates or the downstream calls dispose().
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;400&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/using.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code using} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T&gt; the element type of the generated MaybeSource
     * @param &lt;D&gt; the type of the resource associated with the output sequence
     * @param resourceSupplier
     *            the factory function to create a resource object that depends on the Maybe
     * @param sourceSupplier
     *            the factory function to create a MaybeSource
     * @param resourceDisposer
     *            the function that will dispose of the resource
     * @return the Maybe whose lifetime controls the lifetime of the dependent resource object
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/using.html&quot;&gt;ReactiveX operators documentation: Using&lt;/a&gt;
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T, D&gt; Maybe&lt;T&gt; using(Callable&lt;? extends D&gt; resourceSupplier,
            Function&lt;? super D, ? extends MaybeSource&lt;? extends T&gt;&gt; sourceSupplier,
                    Consumer&lt;? super D&gt; resourceDisposer) {
<span class="fc" id="L1695">        return using(resourceSupplier, sourceSupplier, resourceDisposer, true);</span>
    }

    /**
     * Constructs a Maybe that creates a dependent resource object which is disposed of just before
     * termination if you have set {@code disposeEagerly} to {@code true} and a downstream dispose() does not occur
     * before termination. Otherwise resource disposal will occur on call to dispose().  Eager disposal is
     * particularly appropriate for a synchronous Maybe that reuses resources. {@code disposeAction} will
     * only be called once per subscription.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;400&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/using.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code using} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T&gt; the element type of the generated MaybeSource
     * @param &lt;D&gt; the type of the resource associated with the output sequence
     * @param resourceSupplier
     *            the factory function to create a resource object that depends on the Maybe
     * @param sourceSupplier
     *            the factory function to create a MaybeSource
     * @param resourceDisposer
     *            the function that will dispose of the resource
     * @param eager
     *            if {@code true} then disposal will happen either on a dispose() call or just before emission of
     *            a terminal event ({@code onComplete} or {@code onError}).
     * @return the Maybe whose lifetime controls the lifetime of the dependent resource object
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/using.html&quot;&gt;ReactiveX operators documentation: Using&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T, D&gt; Maybe&lt;T&gt; using(Callable&lt;? extends D&gt; resourceSupplier,
            Function&lt;? super D, ? extends MaybeSource&lt;? extends T&gt;&gt; sourceSupplier,
                    Consumer&lt;? super D&gt; resourceDisposer, boolean eager) {
<span class="fc" id="L1731">        ObjectHelper.requireNonNull(resourceSupplier, &quot;resourceSupplier is null&quot;);</span>
<span class="fc" id="L1732">        ObjectHelper.requireNonNull(sourceSupplier, &quot;sourceSupplier is null&quot;);</span>
<span class="fc" id="L1733">        ObjectHelper.requireNonNull(resourceDisposer, &quot;disposer is null&quot;);</span>
<span class="fc" id="L1734">        return RxJavaPlugins.onAssembly(new MaybeUsing&lt;T, D&gt;(resourceSupplier, sourceSupplier, resourceDisposer, eager));</span>
    }

    /**
     * Wraps a MaybeSource instance into a new Maybe instance if not already a Maybe
     * instance.
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code wrap} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;T&gt; the value type
     * @param source the source to wrap
     * @return the Maybe wrapper or the source cast to Maybe (if possible)
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Maybe&lt;T&gt; wrap(MaybeSource&lt;T&gt; source) {
<span class="fc bfc" id="L1752" title="All 2 branches covered.">        if (source instanceof Maybe) {</span>
<span class="fc" id="L1753">            return RxJavaPlugins.onAssembly((Maybe&lt;T&gt;)source);</span>
        }
<span class="fc" id="L1755">        ObjectHelper.requireNonNull(source, &quot;onSubscribe is null&quot;);</span>
<span class="fc" id="L1756">        return RxJavaPlugins.onAssembly(new MaybeUnsafeCreate&lt;T&gt;(source));</span>
    }

    /**
     * Returns a Maybe that emits the results of a specified combiner function applied to combinations of
     * items emitted, in sequence, by an Iterable of other MaybeSources.
     * &lt;p&gt;
     * Note on method signature: since Java doesn't allow creating a generic array with {@code new T[]}, the
     * implementation of this operator has to create an {@code Object[]} instead. Unfortunately, a
     * {@code Function&lt;Integer[], R&gt;} passed to the method would trigger a {@code ClassCastException}.
     *
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/zip.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;This operator terminates eagerly if any of the source MaybeSources signal an onError or onComplete. This
     * also means it is possible some sources may not get subscribed to at all.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code zip} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T&gt; the common value type
     * @param &lt;R&gt; the zipped result type
     * @param sources
     *            an Iterable of source MaybeSources
     * @param zipper
     *            a function that, when applied to an item emitted by each of the source MaybeSources, results in
     *            an item that will be emitted by the resulting Maybe
     * @return a Maybe that emits the zipped results
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/zip.html&quot;&gt;ReactiveX operators documentation: Zip&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T, R&gt; Maybe&lt;R&gt; zip(Iterable&lt;? extends MaybeSource&lt;? extends T&gt;&gt; sources, Function&lt;? super Object[], ? extends R&gt; zipper) {
<span class="fc" id="L1790">        ObjectHelper.requireNonNull(zipper, &quot;zipper is null&quot;);</span>
<span class="fc" id="L1791">        ObjectHelper.requireNonNull(sources, &quot;sources is null&quot;);</span>
<span class="fc" id="L1792">        return RxJavaPlugins.onAssembly(new MaybeZipIterable&lt;T, R&gt;(sources, zipper));</span>
    }

    /**
     * Returns a Maybe that emits the results of a specified combiner function applied to combinations of
     * two items emitted, in sequence, by two other MaybeSources.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/zip.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;This operator terminates eagerly if any of the source MaybeSources signal an onError or onComplete. This
     * also means it is possible some sources may not get subscribed to at all.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code zip} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T1&gt; the value type of the first source
     * @param &lt;T2&gt; the value type of the second source
     * @param &lt;R&gt; the zipped result type
     * @param source1
     *            the first source MaybeSource
     * @param source2
     *            a second source MaybeSource
     * @param zipper
     *            a function that, when applied to an item emitted by each of the source MaybeSources, results
     *            in an item that will be emitted by the resulting Maybe
     * @return a Maybe that emits the zipped results
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/zip.html&quot;&gt;ReactiveX operators documentation: Zip&lt;/a&gt;
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T1, T2, R&gt; Maybe&lt;R&gt; zip(
            MaybeSource&lt;? extends T1&gt; source1, MaybeSource&lt;? extends T2&gt; source2,
            BiFunction&lt;? super T1, ? super T2, ? extends R&gt; zipper) {
<span class="fc" id="L1827">        ObjectHelper.requireNonNull(source1, &quot;source1 is null&quot;);</span>
<span class="fc" id="L1828">        ObjectHelper.requireNonNull(source2, &quot;source2 is null&quot;);</span>
<span class="fc" id="L1829">        return zipArray(Functions.toFunction(zipper), source1, source2);</span>
    }

    /**
     * Returns a Maybe that emits the results of a specified combiner function applied to combinations of
     * three items emitted, in sequence, by three other MaybeSources.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/zip.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;This operator terminates eagerly if any of the source MaybeSources signal an onError or onComplete. This
     * also means it is possible some sources may not get subscribed to at all.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code zip} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T1&gt; the value type of the first source
     * @param &lt;T2&gt; the value type of the second source
     * @param &lt;T3&gt; the value type of the third source
     * @param &lt;R&gt; the zipped result type
     * @param source1
     *            the first source MaybeSource
     * @param source2
     *            a second source MaybeSource
     * @param source3
     *            a third source MaybeSource
     * @param zipper
     *            a function that, when applied to an item emitted by each of the source MaybeSources, results in
     *            an item that will be emitted by the resulting Maybe
     * @return a Maybe that emits the zipped results
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/zip.html&quot;&gt;ReactiveX operators documentation: Zip&lt;/a&gt;
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T1, T2, T3, R&gt; Maybe&lt;R&gt; zip(
            MaybeSource&lt;? extends T1&gt; source1, MaybeSource&lt;? extends T2&gt; source2, MaybeSource&lt;? extends T3&gt; source3,
            Function3&lt;? super T1, ? super T2, ? super T3, ? extends R&gt; zipper) {
<span class="fc" id="L1867">        ObjectHelper.requireNonNull(source1, &quot;source1 is null&quot;);</span>
<span class="fc" id="L1868">        ObjectHelper.requireNonNull(source2, &quot;source2 is null&quot;);</span>
<span class="fc" id="L1869">        ObjectHelper.requireNonNull(source3, &quot;source3 is null&quot;);</span>
<span class="fc" id="L1870">        return zipArray(Functions.toFunction(zipper), source1, source2, source3);</span>
    }

    /**
     * Returns a Maybe that emits the results of a specified combiner function applied to combinations of
     * four items emitted, in sequence, by four other MaybeSources.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/zip.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;This operator terminates eagerly if any of the source MaybeSources signal an onError or onComplete. This
     * also means it is possible some sources may not get subscribed to at all.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code zip} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T1&gt; the value type of the first source
     * @param &lt;T2&gt; the value type of the second source
     * @param &lt;T3&gt; the value type of the third source
     * @param &lt;T4&gt; the value type of the fourth source
     * @param &lt;R&gt; the zipped result type
     * @param source1
     *            the first source MaybeSource
     * @param source2
     *            a second source MaybeSource
     * @param source3
     *            a third source MaybeSource
     * @param source4
     *            a fourth source MaybeSource
     * @param zipper
     *            a function that, when applied to an item emitted by each of the source MaybeSources, results in
     *            an item that will be emitted by the resulting Maybe
     * @return a Maybe that emits the zipped results
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/zip.html&quot;&gt;ReactiveX operators documentation: Zip&lt;/a&gt;
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T1, T2, T3, T4, R&gt; Maybe&lt;R&gt; zip(
            MaybeSource&lt;? extends T1&gt; source1, MaybeSource&lt;? extends T2&gt; source2, MaybeSource&lt;? extends T3&gt; source3,
            MaybeSource&lt;? extends T4&gt; source4,
            Function4&lt;? super T1, ? super T2, ? super T3, ? super T4, ? extends R&gt; zipper) {
<span class="fc" id="L1912">        ObjectHelper.requireNonNull(source1, &quot;source1 is null&quot;);</span>
<span class="fc" id="L1913">        ObjectHelper.requireNonNull(source2, &quot;source2 is null&quot;);</span>
<span class="fc" id="L1914">        ObjectHelper.requireNonNull(source3, &quot;source3 is null&quot;);</span>
<span class="fc" id="L1915">        ObjectHelper.requireNonNull(source4, &quot;source4 is null&quot;);</span>
<span class="fc" id="L1916">        return zipArray(Functions.toFunction(zipper), source1, source2, source3, source4);</span>
    }

    /**
     * Returns a Maybe that emits the results of a specified combiner function applied to combinations of
     * five items emitted, in sequence, by five other MaybeSources.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/zip.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;This operator terminates eagerly if any of the source MaybeSources signal an onError or onComplete. This
     * also means it is possible some sources may not get subscribed to at all.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code zip} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T1&gt; the value type of the first source
     * @param &lt;T2&gt; the value type of the second source
     * @param &lt;T3&gt; the value type of the third source
     * @param &lt;T4&gt; the value type of the fourth source
     * @param &lt;T5&gt; the value type of the fifth source
     * @param &lt;R&gt; the zipped result type
     * @param source1
     *            the first source MaybeSource
     * @param source2
     *            a second source MaybeSource
     * @param source3
     *            a third source MaybeSource
     * @param source4
     *            a fourth source MaybeSource
     * @param source5
     *            a fifth source MaybeSource
     * @param zipper
     *            a function that, when applied to an item emitted by each of the source MaybeSources, results in
     *            an item that will be emitted by the resulting Maybe
     * @return a Maybe that emits the zipped results
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/zip.html&quot;&gt;ReactiveX operators documentation: Zip&lt;/a&gt;
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T1, T2, T3, T4, T5, R&gt; Maybe&lt;R&gt; zip(
            MaybeSource&lt;? extends T1&gt; source1, MaybeSource&lt;? extends T2&gt; source2, MaybeSource&lt;? extends T3&gt; source3,
            MaybeSource&lt;? extends T4&gt; source4, MaybeSource&lt;? extends T5&gt; source5,
            Function5&lt;? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? extends R&gt; zipper) {
<span class="fc" id="L1961">        ObjectHelper.requireNonNull(source1, &quot;source1 is null&quot;);</span>
<span class="fc" id="L1962">        ObjectHelper.requireNonNull(source2, &quot;source2 is null&quot;);</span>
<span class="fc" id="L1963">        ObjectHelper.requireNonNull(source3, &quot;source3 is null&quot;);</span>
<span class="fc" id="L1964">        ObjectHelper.requireNonNull(source4, &quot;source4 is null&quot;);</span>
<span class="fc" id="L1965">        ObjectHelper.requireNonNull(source5, &quot;source5 is null&quot;);</span>
<span class="fc" id="L1966">        return zipArray(Functions.toFunction(zipper), source1, source2, source3, source4, source5);</span>
    }

    /**
     * Returns a Maybe that emits the results of a specified combiner function applied to combinations of
     * six items emitted, in sequence, by six other MaybeSources.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/zip.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;This operator terminates eagerly if any of the source MaybeSources signal an onError or onComplete. This
     * also means it is possible some sources may not get subscribed to at all.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code zip} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T1&gt; the value type of the first source
     * @param &lt;T2&gt; the value type of the second source
     * @param &lt;T3&gt; the value type of the third source
     * @param &lt;T4&gt; the value type of the fourth source
     * @param &lt;T5&gt; the value type of the fifth source
     * @param &lt;T6&gt; the value type of the sixth source
     * @param &lt;R&gt; the zipped result type
     * @param source1
     *            the first source MaybeSource
     * @param source2
     *            a second source MaybeSource
     * @param source3
     *            a third source MaybeSource
     * @param source4
     *            a fourth source MaybeSource
     * @param source5
     *            a fifth source MaybeSource
     * @param source6
     *            a sixth source MaybeSource
     * @param zipper
     *            a function that, when applied to an item emitted by each of the source MaybeSources, results in
     *            an item that will be emitted by the resulting Maybe
     * @return a Maybe that emits the zipped results
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/zip.html&quot;&gt;ReactiveX operators documentation: Zip&lt;/a&gt;
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T1, T2, T3, T4, T5, T6, R&gt; Maybe&lt;R&gt; zip(
            MaybeSource&lt;? extends T1&gt; source1, MaybeSource&lt;? extends T2&gt; source2, MaybeSource&lt;? extends T3&gt; source3,
            MaybeSource&lt;? extends T4&gt; source4, MaybeSource&lt;? extends T5&gt; source5, MaybeSource&lt;? extends T6&gt; source6,
            Function6&lt;? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? extends R&gt; zipper) {
<span class="fc" id="L2014">        ObjectHelper.requireNonNull(source1, &quot;source1 is null&quot;);</span>
<span class="fc" id="L2015">        ObjectHelper.requireNonNull(source2, &quot;source2 is null&quot;);</span>
<span class="fc" id="L2016">        ObjectHelper.requireNonNull(source3, &quot;source3 is null&quot;);</span>
<span class="fc" id="L2017">        ObjectHelper.requireNonNull(source4, &quot;source4 is null&quot;);</span>
<span class="fc" id="L2018">        ObjectHelper.requireNonNull(source5, &quot;source5 is null&quot;);</span>
<span class="fc" id="L2019">        ObjectHelper.requireNonNull(source6, &quot;source6 is null&quot;);</span>
<span class="fc" id="L2020">        return zipArray(Functions.toFunction(zipper), source1, source2, source3, source4, source5, source6);</span>
    }

    /**
     * Returns a Maybe that emits the results of a specified combiner function applied to combinations of
     * seven items emitted, in sequence, by seven other MaybeSources.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/zip.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;This operator terminates eagerly if any of the source MaybeSources signal an onError or onComplete. This
     * also means it is possible some sources may not get subscribed to at all.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code zip} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T1&gt; the value type of the first source
     * @param &lt;T2&gt; the value type of the second source
     * @param &lt;T3&gt; the value type of the third source
     * @param &lt;T4&gt; the value type of the fourth source
     * @param &lt;T5&gt; the value type of the fifth source
     * @param &lt;T6&gt; the value type of the sixth source
     * @param &lt;T7&gt; the value type of the seventh source
     * @param &lt;R&gt; the zipped result type
     * @param source1
     *            the first source MaybeSource
     * @param source2
     *            a second source MaybeSource
     * @param source3
     *            a third source MaybeSource
     * @param source4
     *            a fourth source MaybeSource
     * @param source5
     *            a fifth source MaybeSource
     * @param source6
     *            a sixth source MaybeSource
     * @param source7
     *            a seventh source MaybeSource
     * @param zipper
     *            a function that, when applied to an item emitted by each of the source MaybeSources, results in
     *            an item that will be emitted by the resulting Maybe
     * @return a Maybe that emits the zipped results
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/zip.html&quot;&gt;ReactiveX operators documentation: Zip&lt;/a&gt;
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T1, T2, T3, T4, T5, T6, T7, R&gt; Maybe&lt;R&gt; zip(
            MaybeSource&lt;? extends T1&gt; source1, MaybeSource&lt;? extends T2&gt; source2, MaybeSource&lt;? extends T3&gt; source3,
            MaybeSource&lt;? extends T4&gt; source4, MaybeSource&lt;? extends T5&gt; source5, MaybeSource&lt;? extends T6&gt; source6,
            MaybeSource&lt;? extends T7&gt; source7,
            Function7&lt;? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? extends R&gt; zipper) {
<span class="fc" id="L2072">        ObjectHelper.requireNonNull(source1, &quot;source1 is null&quot;);</span>
<span class="fc" id="L2073">        ObjectHelper.requireNonNull(source2, &quot;source2 is null&quot;);</span>
<span class="fc" id="L2074">        ObjectHelper.requireNonNull(source3, &quot;source3 is null&quot;);</span>
<span class="fc" id="L2075">        ObjectHelper.requireNonNull(source4, &quot;source4 is null&quot;);</span>
<span class="fc" id="L2076">        ObjectHelper.requireNonNull(source5, &quot;source5 is null&quot;);</span>
<span class="fc" id="L2077">        ObjectHelper.requireNonNull(source6, &quot;source6 is null&quot;);</span>
<span class="fc" id="L2078">        ObjectHelper.requireNonNull(source7, &quot;source7 is null&quot;);</span>
<span class="fc" id="L2079">        return zipArray(Functions.toFunction(zipper), source1, source2, source3, source4, source5, source6, source7);</span>
    }

    /**
     * Returns a Maybe that emits the results of a specified combiner function applied to combinations of
     * eight items emitted, in sequence, by eight other MaybeSources.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/zip.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;This operator terminates eagerly if any of the source MaybeSources signal an onError or onComplete. This
     * also means it is possible some sources may not get subscribed to at all.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code zip} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T1&gt; the value type of the first source
     * @param &lt;T2&gt; the value type of the second source
     * @param &lt;T3&gt; the value type of the third source
     * @param &lt;T4&gt; the value type of the fourth source
     * @param &lt;T5&gt; the value type of the fifth source
     * @param &lt;T6&gt; the value type of the sixth source
     * @param &lt;T7&gt; the value type of the seventh source
     * @param &lt;T8&gt; the value type of the eighth source
     * @param &lt;R&gt; the zipped result type
     * @param source1
     *            the first source MaybeSource
     * @param source2
     *            a second source MaybeSource
     * @param source3
     *            a third source MaybeSource
     * @param source4
     *            a fourth source MaybeSource
     * @param source5
     *            a fifth source MaybeSource
     * @param source6
     *            a sixth source MaybeSource
     * @param source7
     *            a seventh source MaybeSource
     * @param source8
     *            an eighth source MaybeSource
     * @param zipper
     *            a function that, when applied to an item emitted by each of the source MaybeSources, results in
     *            an item that will be emitted by the resulting Maybe
     * @return a Maybe that emits the zipped results
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/zip.html&quot;&gt;ReactiveX operators documentation: Zip&lt;/a&gt;
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T1, T2, T3, T4, T5, T6, T7, T8, R&gt; Maybe&lt;R&gt; zip(
            MaybeSource&lt;? extends T1&gt; source1, MaybeSource&lt;? extends T2&gt; source2, MaybeSource&lt;? extends T3&gt; source3,
            MaybeSource&lt;? extends T4&gt; source4, MaybeSource&lt;? extends T5&gt; source5, MaybeSource&lt;? extends T6&gt; source6,
            MaybeSource&lt;? extends T7&gt; source7, MaybeSource&lt;? extends T8&gt; source8,
            Function8&lt;? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? super T8, ? extends R&gt; zipper) {
<span class="fc" id="L2134">        ObjectHelper.requireNonNull(source1, &quot;source1 is null&quot;);</span>
<span class="fc" id="L2135">        ObjectHelper.requireNonNull(source2, &quot;source2 is null&quot;);</span>
<span class="fc" id="L2136">        ObjectHelper.requireNonNull(source3, &quot;source3 is null&quot;);</span>
<span class="fc" id="L2137">        ObjectHelper.requireNonNull(source4, &quot;source4 is null&quot;);</span>
<span class="fc" id="L2138">        ObjectHelper.requireNonNull(source5, &quot;source5 is null&quot;);</span>
<span class="fc" id="L2139">        ObjectHelper.requireNonNull(source6, &quot;source6 is null&quot;);</span>
<span class="fc" id="L2140">        ObjectHelper.requireNonNull(source7, &quot;source7 is null&quot;);</span>
<span class="fc" id="L2141">        ObjectHelper.requireNonNull(source8, &quot;source8 is null&quot;);</span>
<span class="fc" id="L2142">        return zipArray(Functions.toFunction(zipper), source1, source2, source3, source4, source5, source6, source7, source8);</span>
    }

    /**
     * Returns a Maybe that emits the results of a specified combiner function applied to combinations of
     * nine items emitted, in sequence, by nine other MaybeSources.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/zip.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code zip} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * &lt;p&gt;This operator terminates eagerly if any of the source MaybeSources signal an onError or onComplete. This
     * also means it is possible some sources may not get subscribed to at all.
     *
     * @param &lt;T1&gt; the value type of the first source
     * @param &lt;T2&gt; the value type of the second source
     * @param &lt;T3&gt; the value type of the third source
     * @param &lt;T4&gt; the value type of the fourth source
     * @param &lt;T5&gt; the value type of the fifth source
     * @param &lt;T6&gt; the value type of the sixth source
     * @param &lt;T7&gt; the value type of the seventh source
     * @param &lt;T8&gt; the value type of the eighth source
     * @param &lt;T9&gt; the value type of the ninth source
     * @param &lt;R&gt; the zipped result type
     * @param source1
     *            the first source MaybeSource
     * @param source2
     *            a second source MaybeSource
     * @param source3
     *            a third source MaybeSource
     * @param source4
     *            a fourth source MaybeSource
     * @param source5
     *            a fifth source MaybeSource
     * @param source6
     *            a sixth source MaybeSource
     * @param source7
     *            a seventh source MaybeSource
     * @param source8
     *            an eighth source MaybeSource
     * @param source9
     *            a ninth source MaybeSource
     * @param zipper
     *            a function that, when applied to an item emitted by each of the source MaybeSources, results in
     *            an item that will be emitted by the resulting MaybeSource
     * @return a Maybe that emits the zipped results
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/zip.html&quot;&gt;ReactiveX operators documentation: Zip&lt;/a&gt;
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T1, T2, T3, T4, T5, T6, T7, T8, T9, R&gt; Maybe&lt;R&gt; zip(
            MaybeSource&lt;? extends T1&gt; source1, MaybeSource&lt;? extends T2&gt; source2, MaybeSource&lt;? extends T3&gt; source3,
            MaybeSource&lt;? extends T4&gt; source4, MaybeSource&lt;? extends T5&gt; source5, MaybeSource&lt;? extends T6&gt; source6,
            MaybeSource&lt;? extends T7&gt; source7, MaybeSource&lt;? extends T8&gt; source8, MaybeSource&lt;? extends T9&gt; source9,
            Function9&lt;? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? super T8, ? super T9, ? extends R&gt; zipper) {

<span class="fc" id="L2201">        ObjectHelper.requireNonNull(source1, &quot;source1 is null&quot;);</span>
<span class="fc" id="L2202">        ObjectHelper.requireNonNull(source2, &quot;source2 is null&quot;);</span>
<span class="fc" id="L2203">        ObjectHelper.requireNonNull(source3, &quot;source3 is null&quot;);</span>
<span class="fc" id="L2204">        ObjectHelper.requireNonNull(source4, &quot;source4 is null&quot;);</span>
<span class="fc" id="L2205">        ObjectHelper.requireNonNull(source5, &quot;source5 is null&quot;);</span>
<span class="fc" id="L2206">        ObjectHelper.requireNonNull(source6, &quot;source6 is null&quot;);</span>
<span class="fc" id="L2207">        ObjectHelper.requireNonNull(source7, &quot;source7 is null&quot;);</span>
<span class="fc" id="L2208">        ObjectHelper.requireNonNull(source8, &quot;source8 is null&quot;);</span>
<span class="fc" id="L2209">        ObjectHelper.requireNonNull(source9, &quot;source9 is null&quot;);</span>
<span class="fc" id="L2210">        return zipArray(Functions.toFunction(zipper), source1, source2, source3, source4, source5, source6, source7, source8, source9);</span>
    }

    /**
     * Returns a Maybe that emits the results of a specified combiner function applied to combinations of
     * items emitted, in sequence, by an array of other MaybeSources.
     * &lt;p&gt;
     * Note on method signature: since Java doesn't allow creating a generic array with {@code new T[]}, the
     * implementation of this operator has to create an {@code Object[]} instead. Unfortunately, a
     * {@code Function&lt;Integer[], R&gt;} passed to the method would trigger a {@code ClassCastException}.
     *
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/zip.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;This operator terminates eagerly if any of the source MaybeSources signal an onError or onComplete. This
     * also means it is possible some sources may not get subscribed to at all.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code zipArray} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T&gt; the common element type
     * @param &lt;R&gt; the result type
     * @param sources
     *            an array of source MaybeSources
     * @param zipper
     *            a function that, when applied to an item emitted by each of the source MaybeSources, results in
     *            an item that will be emitted by the resulting MaybeSource
     * @return a Maybe that emits the zipped results
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/zip.html&quot;&gt;ReactiveX operators documentation: Zip&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T, R&gt; Maybe&lt;R&gt; zipArray(Function&lt;? super Object[], ? extends R&gt; zipper,
            MaybeSource&lt;? extends T&gt;... sources) {
<span class="fc" id="L2245">        ObjectHelper.requireNonNull(sources, &quot;sources is null&quot;);</span>
<span class="fc bfc" id="L2246" title="All 2 branches covered.">        if (sources.length == 0) {</span>
<span class="fc" id="L2247">            return empty();</span>
        }
<span class="fc" id="L2249">        ObjectHelper.requireNonNull(zipper, &quot;zipper is null&quot;);</span>
<span class="fc" id="L2250">        return RxJavaPlugins.onAssembly(new MaybeZipArray&lt;T, R&gt;(sources, zipper));</span>
    }

    // ------------------------------------------------------------------
    // Instance methods
    // ------------------------------------------------------------------

    /**
     * Mirrors the MaybeSource (current or provided) that first signals an event.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;385&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/amb.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code ambWith} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param other
     *            a MaybeSource competing to react first. A subscription to this provided source will occur after
     *            subscribing to the current source.
     * @return a Maybe that emits the same sequence as whichever of the source MaybeSources first
     *         signalled
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/amb.html&quot;&gt;ReactiveX operators documentation: Amb&lt;/a&gt;
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Maybe&lt;T&gt; ambWith(MaybeSource&lt;? extends T&gt; other) {
<span class="fc" id="L2278">        ObjectHelper.requireNonNull(other, &quot;other is null&quot;);</span>
<span class="fc" id="L2279">        return ambArray(this, other);</span>
    }

    /**
     * Calls the specified converter function during assembly time and returns its resulting value.
     * &lt;p&gt;
     * This allows fluent conversion to any other type.
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code as} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * &lt;p&gt;History: 2.1.7 - experimental
     * @param &lt;R&gt; the resulting object type
     * @param converter the function that receives the current Maybe instance and returns a value
     * @return the converted value
     * @throws NullPointerException if converter is null
     * @since 2.2
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;R&gt; R as(@NonNull MaybeConverter&lt;T, ? extends R&gt; converter) {
<span class="fc" id="L2300">        return ObjectHelper.requireNonNull(converter, &quot;converter is null&quot;).apply(this);</span>
    }

    /**
     * Waits in a blocking fashion until the current Maybe signals a success value (which is returned),
     * null if completed or an exception (which is propagated).
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code blockingGet} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;dt&gt;&lt;b&gt;Error handling:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;If the source signals an error, the operator wraps a checked {@link Exception}
     * into {@link RuntimeException} and throws that. Otherwise, {@code RuntimeException}s and
     * {@link Error}s are rethrown as they are.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @return the success value
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public final T blockingGet() {
<span class="fc" id="L2319">        BlockingMultiObserver&lt;T&gt; observer = new BlockingMultiObserver&lt;T&gt;();</span>
<span class="fc" id="L2320">        subscribe(observer);</span>
<span class="fc" id="L2321">        return observer.blockingGet();</span>
    }

    /**
     * Waits in a blocking fashion until the current Maybe signals a success value (which is returned),
     * defaultValue if completed or an exception (which is propagated).
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code blockingGet} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;dt&gt;&lt;b&gt;Error handling:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;If the source signals an error, the operator wraps a checked {@link Exception}
     * into {@link RuntimeException} and throws that. Otherwise, {@code RuntimeException}s and
     * {@link Error}s are rethrown as they are.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param defaultValue the default item to return if this Maybe is empty
     * @return the success value
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public final T blockingGet(T defaultValue) {
<span class="fc" id="L2341">        ObjectHelper.requireNonNull(defaultValue, &quot;defaultValue is null&quot;);</span>
<span class="fc" id="L2342">        BlockingMultiObserver&lt;T&gt; observer = new BlockingMultiObserver&lt;T&gt;();</span>
<span class="fc" id="L2343">        subscribe(observer);</span>
<span class="fc" id="L2344">        return observer.blockingGet(defaultValue);</span>
    }

    /**
     * Returns a Maybe that subscribes to this Maybe lazily, caches its event
     * and replays it, to all the downstream subscribers.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;410&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/cache.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * The operator subscribes only when the first downstream subscriber subscribes and maintains
     * a single subscription towards this Maybe.
     * &lt;p&gt;
     * &lt;em&gt;Note:&lt;/em&gt; You sacrifice the ability to dispose the origin when you use the {@code cache}.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code cache} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @return a Maybe that, when first subscribed to, caches all of its items and notifications for the
     *         benefit of subsequent subscribers
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/replay.html&quot;&gt;ReactiveX operators documentation: Replay&lt;/a&gt;
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Maybe&lt;T&gt; cache() {
<span class="fc" id="L2369">        return RxJavaPlugins.onAssembly(new MaybeCache&lt;T&gt;(this));</span>
    }

    /**
     * Casts the success value of the current Maybe into the target type or signals a
     * ClassCastException if not compatible.
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code cast} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;U&gt; the target type
     * @param clazz the type token to use for casting the success result from the current Maybe
     * @return the new Maybe instance
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;U&gt; Maybe&lt;U&gt; cast(final Class&lt;? extends U&gt; clazz) {
<span class="fc" id="L2387">        ObjectHelper.requireNonNull(clazz, &quot;clazz is null&quot;);</span>
<span class="fc" id="L2388">        return map(Functions.castFunction(clazz));</span>
    }

    /**
     * Transform a Maybe by applying a particular Transformer function to it.
     * &lt;p&gt;
     * This method operates on the Maybe itself whereas {@link #lift} operates on the Maybe's MaybeObservers.
     * &lt;p&gt;
     * If the operator you are creating is designed to act on the individual item emitted by a Maybe, use
     * {@link #lift}. If your operator is designed to transform the source Maybe as a whole (for instance, by
     * applying a particular set of existing RxJava operators to it) use {@code compose}.
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code compose} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;R&gt; the value type of the Maybe returned by the transformer function
     * @param transformer the transformer function, not null
     * @return a Maybe, transformed by the transformer function
     * @see &lt;a href=&quot;https://github.com/ReactiveX/RxJava/wiki/Implementing-Your-Own-Operators&quot;&gt;RxJava wiki: Implementing Your Own Operators&lt;/a&gt;
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;R&gt; Maybe&lt;R&gt; compose(MaybeTransformer&lt;? super T, ? extends R&gt; transformer) {
<span class="fc" id="L2413">        return wrap(((MaybeTransformer&lt;T, R&gt;) ObjectHelper.requireNonNull(transformer, &quot;transformer is null&quot;)).apply(this));</span>
    }

    /**
     * Returns a Maybe that is based on applying a specified function to the item emitted by the source Maybe,
     * where that function returns a MaybeSource.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;356&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.flatMap.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code concatMap} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * &lt;p&gt;Note that flatMap and concatMap for Maybe is the same operation.
     * @param &lt;R&gt; the result value type
     * @param mapper
     *            a function that, when applied to the item emitted by the source Maybe, returns a MaybeSource
     * @return the Maybe returned from {@code func} when applied to the item emitted by the source Maybe
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/flatmap.html&quot;&gt;ReactiveX operators documentation: FlatMap&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;R&gt; Maybe&lt;R&gt; concatMap(Function&lt;? super T, ? extends MaybeSource&lt;? extends R&gt;&gt; mapper) {
<span class="fc" id="L2436">        ObjectHelper.requireNonNull(mapper, &quot;mapper is null&quot;);</span>
<span class="fc" id="L2437">        return RxJavaPlugins.onAssembly(new MaybeFlatten&lt;T, R&gt;(this, mapper));</span>
    }

    /**
     * Returns a Flowable that emits the items emitted from the current MaybeSource, then the next, one after
     * the other, without interleaving them.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concat.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code concatWith} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param other
     *            a MaybeSource to be concatenated after the current
     * @return a Flowable that emits items emitted by the two source MaybeSources, one after the other,
     *         without interleaving them
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/concat.html&quot;&gt;ReactiveX operators documentation: Concat&lt;/a&gt;
     */
    @BackpressureSupport(BackpressureKind.FULL)
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;T&gt; concatWith(MaybeSource&lt;? extends T&gt; other) {
<span class="fc" id="L2463">        ObjectHelper.requireNonNull(other, &quot;other is null&quot;);</span>
<span class="fc" id="L2464">        return concat(this, other);</span>
    }

    /**
     * Returns a Single that emits a Boolean that indicates whether the source Maybe emitted a
     * specified item.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;320&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/contains.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code contains} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param item
     *            the item to search for in the emissions from the source Maybe, not null
     * @return a Single that emits {@code true} if the specified item is emitted by the source Maybe,
     *         or {@code false} if the source Maybe completes without emitting that item
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/contains.html&quot;&gt;ReactiveX operators documentation: Contains&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Single&lt;Boolean&gt; contains(final Object item) {
<span class="fc" id="L2487">        ObjectHelper.requireNonNull(item, &quot;item is null&quot;);</span>
<span class="fc" id="L2488">        return RxJavaPlugins.onAssembly(new MaybeContains&lt;T&gt;(this, item));</span>
    }

    /**
     * Returns a Single that counts the total number of items emitted (0 or 1) by the source Maybe and emits
     * this count as a 64-bit Long.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/longCount.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code count} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @return a Single that emits a single item: the number of items emitted by the source Maybe as a
     *         64-bit Long item
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/count.html&quot;&gt;ReactiveX operators documentation: Count&lt;/a&gt;
     * @see #count()
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Single&lt;Long&gt; count() {
<span class="fc" id="L2509">        return RxJavaPlugins.onAssembly(new MaybeCount&lt;T&gt;(this));</span>
    }

    /**
     * Returns a Maybe that emits the item emitted by the source Maybe or a specified default item
     * if the source Maybe is empty.
     * &lt;p&gt;
     * Note that the result Maybe is semantically equivalent to a {@code Single}, since it's guaranteed
     * to emit exactly one item or an error. See {@link #toSingle(Object)} for a method with equivalent
     * behavior which returns a {@code Single}.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/defaultIfEmpty.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code defaultIfEmpty} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param defaultItem
     *            the item to emit if the source Maybe emits no items
     * @return a Maybe that emits either the specified default item if the source Maybe emits no
     *         items, or the items emitted by the source Maybe
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/defaultifempty.html&quot;&gt;ReactiveX operators documentation: DefaultIfEmpty&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Maybe&lt;T&gt; defaultIfEmpty(T defaultItem) {
<span class="fc" id="L2536">        ObjectHelper.requireNonNull(defaultItem, &quot;defaultItem is null&quot;);</span>
<span class="fc" id="L2537">        return switchIfEmpty(just(defaultItem));</span>
    }

    /**
     * Returns a Maybe that signals the events emitted by the source Maybe shifted forward in time by a
     * specified delay.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/delay.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code delay} operates by default on the {@code computation} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param delay
     *            the delay to shift the source by
     * @param unit
     *            the {@link TimeUnit} in which {@code period} is defined
     * @return the new Maybe instance
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/delay.html&quot;&gt;ReactiveX operators documentation: Delay&lt;/a&gt;
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.COMPUTATION)
    public final Maybe&lt;T&gt; delay(long delay, TimeUnit unit) {
<span class="fc" id="L2560">        return delay(delay, unit, Schedulers.computation());</span>
    }

    /**
     * Returns a Maybe that signals the events emitted by the source Maybe shifted forward in time by a
     * specified delay running on the specified Scheduler.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/delay.s.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;you specify which {@link Scheduler} this operator will use.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param delay
     *            the delay to shift the source by
     * @param unit
     *            the time unit of {@code delay}
     * @param scheduler
     *            the {@link Scheduler} to use for delaying
     * @return the new Maybe instance
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/delay.html&quot;&gt;ReactiveX operators documentation: Delay&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Maybe&lt;T&gt; delay(long delay, TimeUnit unit, Scheduler scheduler) {
<span class="fc" id="L2586">        ObjectHelper.requireNonNull(unit, &quot;unit is null&quot;);</span>
<span class="fc" id="L2587">        ObjectHelper.requireNonNull(scheduler, &quot;scheduler is null&quot;);</span>
<span class="fc" id="L2588">        return RxJavaPlugins.onAssembly(new MaybeDelay&lt;T&gt;(this, Math.max(0L, delay), unit, scheduler));</span>
    }

    /**
     * Delays the emission of this Maybe until the given Publisher signals an item or completes.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;450&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/delay.oo.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The {@code delayIndicator} is consumed in an unbounded manner but is cancelled after
     *  the first item it produces.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code delay} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;U&gt;
     *            the subscription delay value type (ignored)
     * @param &lt;V&gt;
     *            the item delay value type (ignored)
     * @param delayIndicator
     *            the Publisher that gets subscribed to when this Maybe signals an event and that
     *            signal is emitted when the Publisher signals an item or completes
     * @return the new Maybe instance
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/delay.html&quot;&gt;ReactiveX operators documentation: Delay&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    public final &lt;U, V&gt; Maybe&lt;T&gt; delay(Publisher&lt;U&gt; delayIndicator) {
<span class="fc" id="L2618">        ObjectHelper.requireNonNull(delayIndicator, &quot;delayIndicator is null&quot;);</span>
<span class="fc" id="L2619">        return RxJavaPlugins.onAssembly(new MaybeDelayOtherPublisher&lt;T, U&gt;(this, delayIndicator));</span>
    }

    /**
     * Returns a Maybe that delays the subscription to this Maybe
     * until the other Publisher emits an element or completes normally.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The {@code Publisher} source is consumed in an unbounded fashion (without applying backpressure).&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This method does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;U&gt; the value type of the other Publisher, irrelevant
     * @param subscriptionIndicator the other Publisher that should trigger the subscription
     *        to this Publisher.
     * @return a Maybe that delays the subscription to this Maybe
     *         until the other Publisher emits an element or completes normally.
     */
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;U&gt; Maybe&lt;T&gt; delaySubscription(Publisher&lt;U&gt; subscriptionIndicator) {
<span class="fc" id="L2643">        ObjectHelper.requireNonNull(subscriptionIndicator, &quot;subscriptionIndicator is null&quot;);</span>
<span class="fc" id="L2644">        return RxJavaPlugins.onAssembly(new MaybeDelaySubscriptionOtherPublisher&lt;T, U&gt;(this, subscriptionIndicator));</span>
    }

    /**
     * Returns a Maybe that delays the subscription to the source Maybe by a given amount of time.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/delaySubscription.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code delaySubscription} operates by default on the {@code computation} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param delay
     *            the time to delay the subscription
     * @param unit
     *            the time unit of {@code delay}
     * @return a Maybe that delays the subscription to the source Maybe by the given amount
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/delay.html&quot;&gt;ReactiveX operators documentation: Delay&lt;/a&gt;
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.COMPUTATION)
    public final Maybe&lt;T&gt; delaySubscription(long delay, TimeUnit unit) {
<span class="fc" id="L2666">        return delaySubscription(delay, unit, Schedulers.computation());</span>
    }

    /**
     * Returns a Maybe that delays the subscription to the source Maybe by a given amount of time,
     * both waiting and subscribing on a given Scheduler.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/delaySubscription.s.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;You specify which {@link Scheduler} this operator will use.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param delay
     *            the time to delay the subscription
     * @param unit
     *            the time unit of {@code delay}
     * @param scheduler
     *            the Scheduler on which the waiting and subscription will happen
     * @return a Maybe that delays the subscription to the source Maybe by a given
     *         amount, waiting and subscribing on the given Scheduler
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/delay.html&quot;&gt;ReactiveX operators documentation: Delay&lt;/a&gt;
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Maybe&lt;T&gt; delaySubscription(long delay, TimeUnit unit, Scheduler scheduler) {
<span class="fc" id="L2692">        return delaySubscription(Flowable.timer(delay, unit, scheduler));</span>
    }

    /**
     * Calls the specified consumer with the success item after this item has been emitted to the downstream.
     * &lt;p&gt;Note that the {@code onAfterNext} action is shared between subscriptions and as such
     * should be thread-safe.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code doAfterSuccess} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * &lt;p&gt;History: 2.0.1 - experimental
     * @param onAfterSuccess the Consumer that will be called after emitting an item from upstream to the downstream
     * @return the new Maybe instance
     * @since 2.1
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Maybe&lt;T&gt; doAfterSuccess(Consumer&lt;? super T&gt; onAfterSuccess) {
<span class="fc" id="L2712">        ObjectHelper.requireNonNull(onAfterSuccess, &quot;onAfterSuccess is null&quot;);</span>
<span class="fc" id="L2713">        return RxJavaPlugins.onAssembly(new MaybeDoAfterSuccess&lt;T&gt;(this, onAfterSuccess));</span>
    }

    /**
     * Registers an {@link Action} to be called when this Maybe invokes either
     * {@link MaybeObserver#onComplete onSuccess},
     * {@link MaybeObserver#onComplete onComplete} or {@link MaybeObserver#onError onError}.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/finallyDo.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code doAfterTerminate} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param onAfterTerminate
     *            an {@link Action} to be invoked when the source Maybe finishes
     * @return a Maybe that emits the same items as the source Maybe, then invokes the
     *         {@link Action}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/do.html&quot;&gt;ReactiveX operators documentation: Do&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Maybe&lt;T&gt; doAfterTerminate(Action onAfterTerminate) {
<span class="fc" id="L2737">        return RxJavaPlugins.onAssembly(new MaybePeek&lt;T&gt;(this,</span>
<span class="fc" id="L2738">                Functions.emptyConsumer(), // onSubscribe</span>
<span class="fc" id="L2739">                Functions.emptyConsumer(), // onSuccess</span>
<span class="fc" id="L2740">                Functions.emptyConsumer(), // onError</span>
                Functions.EMPTY_ACTION,    // onComplete
<span class="fc" id="L2742">                ObjectHelper.requireNonNull(onAfterTerminate, &quot;onAfterTerminate is null&quot;),</span>
                Functions.EMPTY_ACTION     // dispose
        ));
    }

    /**
     * Calls the specified action after this Maybe signals onSuccess, onError or onComplete or gets disposed by
     * the downstream.
     * &lt;p&gt;In case of a race between a terminal event and a dispose call, the provided {@code onFinally} action
     * is executed once per subscription.
     * &lt;p&gt;Note that the {@code onFinally} action is shared between subscriptions and as such
     * should be thread-safe.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code doFinally} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * &lt;p&gt;History: 2.0.1 - experimental
     * @param onFinally the action called when this Maybe terminates or gets disposed
     * @return the new Maybe instance
     * @since 2.1
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Maybe&lt;T&gt; doFinally(Action onFinally) {
<span class="fc" id="L2767">        ObjectHelper.requireNonNull(onFinally, &quot;onFinally is null&quot;);</span>
<span class="fc" id="L2768">        return RxJavaPlugins.onAssembly(new MaybeDoFinally&lt;T&gt;(this, onFinally));</span>
    }

    /**
     * Calls the shared {@code Action} if a MaybeObserver subscribed to the current Maybe
     * disposes the common Disposable it received via onSubscribe.
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code doOnDispose} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param onDispose the action called when the subscription is disposed
     * @throws NullPointerException if onDispose is null
     * @return the new Maybe instance
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Maybe&lt;T&gt; doOnDispose(Action onDispose) {
<span class="fc" id="L2786">        return RxJavaPlugins.onAssembly(new MaybePeek&lt;T&gt;(this,</span>
<span class="fc" id="L2787">                Functions.emptyConsumer(), // onSubscribe</span>
<span class="fc" id="L2788">                Functions.emptyConsumer(), // onSuccess</span>
<span class="fc" id="L2789">                Functions.emptyConsumer(), // onError</span>
                Functions.EMPTY_ACTION,    // onComplete
                Functions.EMPTY_ACTION,    // (onSuccess | onError | onComplete) after
<span class="fc" id="L2792">                ObjectHelper.requireNonNull(onDispose, &quot;onDispose is null&quot;)</span>
        ));
    }

    /**
     * Modifies the source Maybe so that it invokes an action when it calls {@code onComplete}.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;358&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnComplete.m.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code doOnComplete} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param onComplete
     *            the action to invoke when the source Maybe calls {@code onComplete}
     * @return the new Maybe with the side-effecting behavior applied
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/do.html&quot;&gt;ReactiveX operators documentation: Do&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Maybe&lt;T&gt; doOnComplete(Action onComplete) {
<span class="fc" id="L2814">        return RxJavaPlugins.onAssembly(new MaybePeek&lt;T&gt;(this,</span>
<span class="fc" id="L2815">                Functions.emptyConsumer(), // onSubscribe</span>
<span class="fc" id="L2816">                Functions.emptyConsumer(), // onSuccess</span>
<span class="fc" id="L2817">                Functions.emptyConsumer(), // onError</span>
<span class="fc" id="L2818">                ObjectHelper.requireNonNull(onComplete, &quot;onComplete is null&quot;),</span>
                Functions.EMPTY_ACTION,    // (onSuccess | onError | onComplete)
                Functions.EMPTY_ACTION     // dispose
        ));
    }

    /**
     * Calls the shared consumer with the error sent via onError for each
     * MaybeObserver that subscribes to the current Maybe.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;358&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnError.m.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code doOnError} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param onError the consumer called with the success value of onError
     * @return the new Maybe instance
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Maybe&lt;T&gt; doOnError(Consumer&lt;? super Throwable&gt; onError) {
<span class="fc" id="L2840">        return RxJavaPlugins.onAssembly(new MaybePeek&lt;T&gt;(this,</span>
<span class="fc" id="L2841">                Functions.emptyConsumer(), // onSubscribe</span>
<span class="fc" id="L2842">                Functions.emptyConsumer(), // onSuccess</span>
<span class="fc" id="L2843">                ObjectHelper.requireNonNull(onError, &quot;onError is null&quot;),</span>
                Functions.EMPTY_ACTION,    // onComplete
                Functions.EMPTY_ACTION,    // (onSuccess | onError | onComplete)
                Functions.EMPTY_ACTION     // dispose
        ));
    }

    /**
     * Calls the given onEvent callback with the (success value, null) for an onSuccess, (null, throwable) for
     * an onError or (null, null) for an onComplete signal from this Maybe before delivering said
     * signal to the downstream.
     * &lt;p&gt;
     * Exceptions thrown from the callback will override the event so the downstream receives the
     * error instead of the original signal.
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code doOnEvent} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param onEvent the callback to call with the terminal event tuple
     * @return the new Maybe instance
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Maybe&lt;T&gt; doOnEvent(BiConsumer&lt;? super T, ? super Throwable&gt; onEvent) {
<span class="fc" id="L2867">        ObjectHelper.requireNonNull(onEvent, &quot;onEvent is null&quot;);</span>
<span class="fc" id="L2868">        return RxJavaPlugins.onAssembly(new MaybeDoOnEvent&lt;T&gt;(this, onEvent));</span>
    }

    /**
     * Calls the shared consumer with the Disposable sent through the onSubscribe for each
     * MaybeObserver that subscribes to the current Maybe.
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code doOnSubscribe} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param onSubscribe the consumer called with the Disposable sent via onSubscribe
     * @return the new Maybe instance
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Maybe&lt;T&gt; doOnSubscribe(Consumer&lt;? super Disposable&gt; onSubscribe) {
<span class="fc" id="L2885">        return RxJavaPlugins.onAssembly(new MaybePeek&lt;T&gt;(this,</span>
<span class="fc" id="L2886">                ObjectHelper.requireNonNull(onSubscribe, &quot;onSubscribe is null&quot;),</span>
<span class="fc" id="L2887">                Functions.emptyConsumer(), // onSuccess</span>
<span class="fc" id="L2888">                Functions.emptyConsumer(), // onError</span>
                Functions.EMPTY_ACTION,    // onComplete
                Functions.EMPTY_ACTION,    // (onSuccess | onError | onComplete)
                Functions.EMPTY_ACTION     // dispose
        ));
    }

    /**
     * Returns a Maybe instance that calls the given onTerminate callback
     * just before this Maybe completes normally or with an exception.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnTerminate.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * This differs from {@code doAfterTerminate} in that this happens &lt;em&gt;before&lt;/em&gt; the {@code onComplete} or
     * {@code onError} notification.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code doOnTerminate} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param onTerminate the action to invoke when the consumer calls {@code onComplete} or {@code onError}
     * @return the new Maybe instance
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/do.html&quot;&gt;ReactiveX operators documentation: Do&lt;/a&gt;
     * @see #doOnTerminate(Action)
     * @since 2.2.7 - experimental
     */
    @Experimental
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Maybe&lt;T&gt; doOnTerminate(final Action onTerminate) {
<span class="fc" id="L2918">        ObjectHelper.requireNonNull(onTerminate, &quot;onTerminate is null&quot;);</span>
<span class="fc" id="L2919">        return RxJavaPlugins.onAssembly(new MaybeDoOnTerminate&lt;T&gt;(this, onTerminate));</span>
    }

    /**
     * Calls the shared consumer with the success value sent via onSuccess for each
     * MaybeObserver that subscribes to the current Maybe.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;358&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnSuccess.m.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code doOnSuccess} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param onSuccess the consumer called with the success value of onSuccess
     * @return the new Maybe instance
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Maybe&lt;T&gt; doOnSuccess(Consumer&lt;? super T&gt; onSuccess) {
<span class="fc" id="L2938">        return RxJavaPlugins.onAssembly(new MaybePeek&lt;T&gt;(this,</span>
<span class="fc" id="L2939">                Functions.emptyConsumer(), // onSubscribe</span>
<span class="fc" id="L2940">                ObjectHelper.requireNonNull(onSuccess, &quot;onSuccess is null&quot;),</span>
<span class="fc" id="L2941">                Functions.emptyConsumer(), // onError</span>
                Functions.EMPTY_ACTION,    // onComplete
                Functions.EMPTY_ACTION,    // (onSuccess | onError | onComplete)
                Functions.EMPTY_ACTION     // dispose
        ));
    }

    /**
     * Filters the success item of the Maybe via a predicate function and emitting it if the predicate
     * returns true, completing otherwise.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/filter.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code filter} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param predicate
     *            a function that evaluates the item emitted by the source Maybe, returning {@code true}
     *            if it passes the filter
     * @return a Maybe that emit the item emitted by the source Maybe that the filter
     *         evaluates as {@code true}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/filter.html&quot;&gt;ReactiveX operators documentation: Filter&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Maybe&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate) {
<span class="fc" id="L2969">        ObjectHelper.requireNonNull(predicate, &quot;predicate is null&quot;);</span>
<span class="fc" id="L2970">        return RxJavaPlugins.onAssembly(new MaybeFilter&lt;T&gt;(this, predicate));</span>
    }

    /**
     * Returns a Maybe that is based on applying a specified function to the item emitted by the source Maybe,
     * where that function returns a MaybeSource.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;356&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.flatMap.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code flatMap} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * &lt;p&gt;Note that flatMap and concatMap for Maybe is the same operation.
     *
     * @param &lt;R&gt; the result value type
     * @param mapper
     *            a function that, when applied to the item emitted by the source Maybe, returns a MaybeSource
     * @return the Maybe returned from {@code func} when applied to the item emitted by the source Maybe
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/flatmap.html&quot;&gt;ReactiveX operators documentation: FlatMap&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;R&gt; Maybe&lt;R&gt; flatMap(Function&lt;? super T, ? extends MaybeSource&lt;? extends R&gt;&gt; mapper) {
<span class="fc" id="L2994">        ObjectHelper.requireNonNull(mapper, &quot;mapper is null&quot;);</span>
<span class="fc" id="L2995">        return RxJavaPlugins.onAssembly(new MaybeFlatten&lt;T, R&gt;(this, mapper));</span>
    }

    /**
     * Maps the onSuccess, onError or onComplete signals of this Maybe into MaybeSource and emits that
     * MaybeSource's signals.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;354&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.flatMap.mmm.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code flatMap} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;R&gt;
     *            the result type
     * @param onSuccessMapper
     *            a function that returns a MaybeSource to merge for the onSuccess item emitted by this Maybe
     * @param onErrorMapper
     *            a function that returns a MaybeSource to merge for an onError notification from this Maybe
     * @param onCompleteSupplier
     *            a function that returns a MaybeSource to merge for an onComplete notification this Maybe
     * @return the new Maybe instance
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/flatmap.html&quot;&gt;ReactiveX operators documentation: FlatMap&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;R&gt; Maybe&lt;R&gt; flatMap(
            Function&lt;? super T, ? extends MaybeSource&lt;? extends R&gt;&gt; onSuccessMapper,
            Function&lt;? super Throwable, ? extends MaybeSource&lt;? extends R&gt;&gt; onErrorMapper,
            Callable&lt;? extends MaybeSource&lt;? extends R&gt;&gt; onCompleteSupplier) {
<span class="fc" id="L3026">        ObjectHelper.requireNonNull(onSuccessMapper, &quot;onSuccessMapper is null&quot;);</span>
<span class="fc" id="L3027">        ObjectHelper.requireNonNull(onErrorMapper, &quot;onErrorMapper is null&quot;);</span>
<span class="fc" id="L3028">        ObjectHelper.requireNonNull(onCompleteSupplier, &quot;onCompleteSupplier is null&quot;);</span>
<span class="fc" id="L3029">        return RxJavaPlugins.onAssembly(new MaybeFlatMapNotification&lt;T, R&gt;(this, onSuccessMapper, onErrorMapper, onCompleteSupplier));</span>
    }

    /**
     * Returns a Maybe that emits the results of a specified function to the pair of values emitted by the
     * source Maybe and a specified mapped MaybeSource.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;390&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/mergeMap.r.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code flatMap} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;U&gt;
     *            the type of items emitted by the MaybeSource returned by the {@code mapper} function
     * @param &lt;R&gt;
     *            the type of items emitted by the resulting Maybe
     * @param mapper
     *            a function that returns a MaybeSource for the item emitted by the source Maybe
     * @param resultSelector
     *            a function that combines one item emitted by each of the source and collection MaybeSource and
     *            returns an item to be emitted by the resulting MaybeSource
     * @return the new Maybe instance
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/flatmap.html&quot;&gt;ReactiveX operators documentation: FlatMap&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;U, R&gt; Maybe&lt;R&gt; flatMap(Function&lt;? super T, ? extends MaybeSource&lt;? extends U&gt;&gt; mapper,
            BiFunction&lt;? super T, ? super U, ? extends R&gt; resultSelector) {
<span class="fc" id="L3059">        ObjectHelper.requireNonNull(mapper, &quot;mapper is null&quot;);</span>
<span class="fc" id="L3060">        ObjectHelper.requireNonNull(resultSelector, &quot;resultSelector is null&quot;);</span>
<span class="fc" id="L3061">        return RxJavaPlugins.onAssembly(new MaybeFlatMapBiSelector&lt;T, U, R&gt;(this, mapper, resultSelector));</span>
    }

    /**
     * Maps the success value of the upstream {@link Maybe} into an {@link Iterable} and emits its items as a
     * {@link Flowable} sequence.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;373&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flattenAsFlowable.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code flattenAsFlowable} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;U&gt;
     *            the type of item emitted by the resulting Iterable
     * @param mapper
     *            a function that returns an Iterable sequence of values for when given an item emitted by the
     *            source Maybe
     * @return the new Flowable instance
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/flatmap.html&quot;&gt;ReactiveX operators documentation: FlatMap&lt;/a&gt;
     */
    @BackpressureSupport(BackpressureKind.FULL)
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;U&gt; Flowable&lt;U&gt; flattenAsFlowable(final Function&lt;? super T, ? extends Iterable&lt;? extends U&gt;&gt; mapper) {
<span class="fc" id="L3089">        ObjectHelper.requireNonNull(mapper, &quot;mapper is null&quot;);</span>
<span class="fc" id="L3090">        return RxJavaPlugins.onAssembly(new MaybeFlatMapIterableFlowable&lt;T, U&gt;(this, mapper));</span>
    }

    /**
     * Maps the success value of the upstream {@link Maybe} into an {@link Iterable} and emits its items as an
     * {@link Observable} sequence.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;373&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flattenAsObservable.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code flattenAsObservable} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;U&gt;
     *            the type of item emitted by the resulting Iterable
     * @param mapper
     *            a function that returns an Iterable sequence of values for when given an item emitted by the
     *            source Maybe
     * @return the new Observable instance
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/flatmap.html&quot;&gt;ReactiveX operators documentation: FlatMap&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;U&gt; Observable&lt;U&gt; flattenAsObservable(final Function&lt;? super T, ? extends Iterable&lt;? extends U&gt;&gt; mapper) {
<span class="fc" id="L3115">        ObjectHelper.requireNonNull(mapper, &quot;mapper is null&quot;);</span>
<span class="fc" id="L3116">        return RxJavaPlugins.onAssembly(new MaybeFlatMapIterableObservable&lt;T, U&gt;(this, mapper));</span>
    }

    /**
     * Returns an Observable that is based on applying a specified function to the item emitted by the source Maybe,
     * where that function returns an ObservableSource.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;356&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.flatMap.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code flatMapObservable} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;R&gt; the result value type
     * @param mapper
     *            a function that, when applied to the item emitted by the source Maybe, returns an ObservableSource
     * @return the Observable returned from {@code func} when applied to the item emitted by the source Maybe
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/flatmap.html&quot;&gt;ReactiveX operators documentation: FlatMap&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;R&gt; Observable&lt;R&gt; flatMapObservable(Function&lt;? super T, ? extends ObservableSource&lt;? extends R&gt;&gt; mapper) {
<span class="fc" id="L3139">        ObjectHelper.requireNonNull(mapper, &quot;mapper is null&quot;);</span>
<span class="fc" id="L3140">        return RxJavaPlugins.onAssembly(new MaybeFlatMapObservable&lt;T, R&gt;(this, mapper));</span>
    }

    /**
     * Returns a Flowable that emits items based on applying a specified function to the item emitted by the
     * source Maybe, where that function returns a Publisher.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;260&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.flatMapPublisher.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The returned Flowable honors the downstream backpressure.&lt;/dd&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code flatMapPublisher} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;R&gt; the result value type
     * @param mapper
     *            a function that, when applied to the item emitted by the source Maybe, returns a
     *            Flowable
     * @return the Flowable returned from {@code func} when applied to the item emitted by the source Maybe
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/flatmap.html&quot;&gt;ReactiveX operators documentation: FlatMap&lt;/a&gt;
     */
    @BackpressureSupport(BackpressureKind.FULL)
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;R&gt; Flowable&lt;R&gt; flatMapPublisher(Function&lt;? super T, ? extends Publisher&lt;? extends R&gt;&gt; mapper) {
<span class="fc" id="L3167">        ObjectHelper.requireNonNull(mapper, &quot;mapper is null&quot;);</span>
<span class="fc" id="L3168">        return RxJavaPlugins.onAssembly(new MaybeFlatMapPublisher&lt;T, R&gt;(this, mapper));</span>
    }

    /**
     * Returns a {@link Single} based on applying a specified function to the item emitted by the
     * source {@link Maybe}, where that function returns a {@link Single}.
     * When this Maybe completes a {@link NoSuchElementException} will be thrown.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;356&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.flatMapSingle.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code flatMapSingle} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;R&gt; the result value type
     * @param mapper
     *            a function that, when applied to the item emitted by the source Maybe, returns a
     *            Single
     * @return the Single returned from {@code mapper} when applied to the item emitted by the source Maybe
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/flatmap.html&quot;&gt;ReactiveX operators documentation: FlatMap&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;R&gt; Single&lt;R&gt; flatMapSingle(final Function&lt;? super T, ? extends SingleSource&lt;? extends R&gt;&gt; mapper) {
<span class="fc" id="L3193">        ObjectHelper.requireNonNull(mapper, &quot;mapper is null&quot;);</span>
<span class="fc" id="L3194">        return RxJavaPlugins.onAssembly(new MaybeFlatMapSingle&lt;T, R&gt;(this, mapper));</span>
    }

    /**
     * Returns a {@link Maybe} based on applying a specified function to the item emitted by the
     * source {@link Maybe}, where that function returns a {@link Single}.
     * When this Maybe just completes the resulting {@code Maybe} completes as well.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;356&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.flatMapSingle.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code flatMapSingleElement} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * &lt;p&gt;History: 2.0.2 - experimental
     * @param &lt;R&gt; the result value type
     * @param mapper
     *            a function that, when applied to the item emitted by the source Maybe, returns a
     *            Single
     * @return the new Maybe instance
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/flatmap.html&quot;&gt;ReactiveX operators documentation: FlatMap&lt;/a&gt;
     * @since 2.1
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;R&gt; Maybe&lt;R&gt; flatMapSingleElement(final Function&lt;? super T, ? extends SingleSource&lt;? extends R&gt;&gt; mapper) {
<span class="fc" id="L3221">        ObjectHelper.requireNonNull(mapper, &quot;mapper is null&quot;);</span>
<span class="fc" id="L3222">        return RxJavaPlugins.onAssembly(new MaybeFlatMapSingleElement&lt;T, R&gt;(this, mapper));</span>
    }

    /**
     * Returns a {@link Completable} that completes based on applying a specified function to the item emitted by the
     * source {@link Maybe}, where that function returns a {@link Completable}.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;267&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.flatMapCompletable.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code flatMapCompletable} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param mapper
     *            a function that, when applied to the item emitted by the source Maybe, returns a
     *            Completable
     * @return the Completable returned from {@code mapper} when applied to the item emitted by the source Maybe
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/flatmap.html&quot;&gt;ReactiveX operators documentation: FlatMap&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Completable flatMapCompletable(final Function&lt;? super T, ? extends CompletableSource&gt; mapper) {
<span class="fc" id="L3245">        ObjectHelper.requireNonNull(mapper, &quot;mapper is null&quot;);</span>
<span class="fc" id="L3246">        return RxJavaPlugins.onAssembly(new MaybeFlatMapCompletable&lt;T&gt;(this, mapper));</span>
    }

    /**
     * Hides the identity of this Maybe and its Disposable.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;300&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.hide.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;Allows preventing certain identity-based
     * optimizations (fusion).
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code hide} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @return the new Maybe instance
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Maybe&lt;T&gt; hide() {
<span class="fc" id="L3264">        return RxJavaPlugins.onAssembly(new MaybeHide&lt;T&gt;(this));</span>
    }

    /**
     * Ignores the item emitted by the source Maybe and only calls {@code onComplete} or {@code onError}.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;389&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.ignoreElement.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code ignoreElement} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @return an empty Completable that only calls {@code onComplete} or {@code onError}, based on which one is
     *         called by the source Maybe
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/ignoreelements.html&quot;&gt;ReactiveX operators documentation: IgnoreElements&lt;/a&gt;
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Completable ignoreElement() {
<span class="fc" id="L3283">        return RxJavaPlugins.onAssembly(new MaybeIgnoreElementCompletable&lt;T&gt;(this));</span>
    }

    /**
     * Returns a Single that emits {@code true} if the source Maybe is empty, otherwise {@code false}.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;320&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/isEmpty.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code isEmpty} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @return a Single that emits a Boolean
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/contains.html&quot;&gt;ReactiveX operators documentation: Contains&lt;/a&gt;
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Single&lt;Boolean&gt; isEmpty() {
<span class="fc" id="L3301">        return RxJavaPlugins.onAssembly(new MaybeIsEmptySingle&lt;T&gt;(this));</span>
    }

    /**
     * &lt;strong&gt;This method requires advanced knowledge about building operators, please consider
     * other standard composition methods first;&lt;/strong&gt;
     * Returns a {@code Maybe} which, when subscribed to, invokes the {@link MaybeOperator#apply(MaybeObserver) apply(MaybeObserver)} method
     * of the provided {@link MaybeOperator} for each individual downstream {@link Maybe} and allows the
     * insertion of a custom operator by accessing the downstream's {@link MaybeObserver} during this subscription phase
     * and providing a new {@code MaybeObserver}, containing the custom operator's intended business logic, that will be
     * used in the subscription process going further upstream.
     * &lt;p&gt;
     * Generally, such a new {@code MaybeObserver} will wrap the downstream's {@code MaybeObserver} and forwards the
     * {@code onSuccess}, {@code onError} and {@code onComplete} events from the upstream directly or according to the
     * emission pattern the custom operator's business logic requires. In addition, such operator can intercept the
     * flow control calls of {@code dispose} and {@code isDisposed} that would have traveled upstream and perform
     * additional actions depending on the same business logic requirements.
     * &lt;p&gt;
     * Example:
     * &lt;pre&gt;&lt;code&gt;
     * // Step 1: Create the consumer type that will be returned by the MaybeOperator.apply():
     * 
     * public final class CustomMaybeObserver&amp;lt;T&amp;gt; implements MaybeObserver&amp;lt;T&amp;gt;, Disposable {
     *
     *     // The downstream's MaybeObserver that will receive the onXXX events
     *     final MaybeObserver&amp;lt;? super String&amp;gt; downstream;
     *
     *     // The connection to the upstream source that will call this class' onXXX methods
     *     Disposable upstream;
     *
     *     // The constructor takes the downstream subscriber and usually any other parameters
     *     public CustomMaybeObserver(MaybeObserver&amp;lt;? super String&amp;gt; downstream) {
     *         this.downstream = downstream;
     *     }
     *
     *     // In the subscription phase, the upstream sends a Disposable to this class
     *     // and subsequently this class has to send a Disposable to the downstream.
     *     // Note that relaying the upstream's Disposable directly is not allowed in RxJava
     *     &amp;#64;Override
     *     public void onSubscribe(Disposable d) {
     *         if (upstream != null) {
     *             d.dispose();
     *         } else {
     *             upstream = d;
     *             downstream.onSubscribe(this);
     *         }
     *     }
     *
     *     // The upstream calls this with the next item and the implementation's
     *     // responsibility is to emit an item to the downstream based on the intended
     *     // business logic, or if it can't do so for the particular item,
     *     // request more from the upstream
     *     &amp;#64;Override
     *     public void onSuccess(T item) {
     *         String str = item.toString();
     *         if (str.length() &amp;lt; 2) {
     *             downstream.onSuccess(str);
     *         } else {
     *             // Maybe is usually expected to produce one of the onXXX events
     *             downstream.onComplete();
     *         }
     *     }
     *
     *     // Some operators may handle the upstream's error while others
     *     // could just forward it to the downstream.
     *     &amp;#64;Override
     *     public void onError(Throwable throwable) {
     *         downstream.onError(throwable);
     *     }
     *
     *     // When the upstream completes, usually the downstream should complete as well.
     *     &amp;#64;Override
     *     public void onComplete() {
     *         downstream.onComplete();
     *     }
     *
     *     // Some operators may use their own resources which should be cleaned up if
     *     // the downstream disposes the flow before it completed. Operators without
     *     // resources can simply forward the dispose to the upstream.
     *     // In some cases, a disposed flag may be set by this method so that other parts
     *     // of this class may detect the dispose and stop sending events
     *     // to the downstream.
     *     &amp;#64;Override
     *     public void dispose() {
     *         upstream.dispose();
     *     }
     *
     *     // Some operators may simply forward the call to the upstream while others
     *     // can return the disposed flag set in dispose().
     *     &amp;#64;Override
     *     public boolean isDisposed() {
     *         return upstream.isDisposed();
     *     }
     * }
     *
     * // Step 2: Create a class that implements the MaybeOperator interface and
     * //         returns the custom consumer type from above in its apply() method.
     * //         Such class may define additional parameters to be submitted to
     * //         the custom consumer type.
     *
     * final class CustomMaybeOperator&amp;lt;T&amp;gt; implements MaybeOperator&amp;lt;String&amp;gt; {
     *     &amp;#64;Override
     *     public MaybeObserver&amp;lt;? super String&amp;gt; apply(MaybeObserver&amp;lt;? super T&amp;gt; upstream) {
     *         return new CustomMaybeObserver&amp;lt;T&amp;gt;(upstream);
     *     }
     * }
     *
     * // Step 3: Apply the custom operator via lift() in a flow by creating an instance of it
     * //         or reusing an existing one.
     *
     * Maybe.just(5)
     * .lift(new CustomMaybeOperator&amp;lt;Integer&amp;gt;())
     * .test()
     * .assertResult(&quot;5&quot;);
     *
     * Maybe.just(15)
     * .lift(new CustomMaybeOperator&amp;lt;Integer&amp;gt;())
     * .test()
     * .assertResult();
     * &lt;/code&gt;&lt;/pre&gt;
     * &lt;p&gt;
     * Creating custom operators can be complicated and it is recommended one consults the
     * &lt;a href=&quot;https://github.com/ReactiveX/RxJava/wiki/Writing-operators-for-2.0&quot;&gt;RxJava wiki: Writing operators&lt;/a&gt; page about
     * the tools, requirements, rules, considerations and pitfalls of implementing them.
     * &lt;p&gt;
     * Note that implementing custom operators via this {@code lift()} method adds slightly more overhead by requiring
     * an additional allocation and indirection per assembled flows. Instead, extending the abstract {@code Maybe}
     * class and creating a {@link MaybeTransformer} with it is recommended.
     * &lt;p&gt;
     * Note also that it is not possible to stop the subscription phase in {@code lift()} as the {@code apply()} method
     * requires a non-null {@code MaybeObserver} instance to be returned, which is then unconditionally subscribed to
     * the upstream {@code Maybe}. For example, if the operator decided there is no reason to subscribe to the
     * upstream source because of some optimization possibility or a failure to prepare the operator, it still has to
     * return a {@code MaybeObserver} that should immediately dispose the upstream's {@code Disposable} in its
     * {@code onSubscribe} method. Again, using a {@code MaybeTransformer} and extending the {@code Maybe} is
     * a better option as {@link #subscribeActual} can decide to not subscribe to its upstream after all.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code lift} does not operate by default on a particular {@link Scheduler}, however, the
     *  {@link MaybeOperator} may use a {@code Scheduler} to support its own asynchronous behavior.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;R&gt; the output value type
     * @param lift the {@link MaybeOperator} that receives the downstream's {@code MaybeObserver} and should return
     *               a {@code MaybeObserver} with custom behavior to be used as the consumer for the current
     *               {@code Maybe}.
     * @return the new Maybe instance
     * @see &lt;a href=&quot;https://github.com/ReactiveX/RxJava/wiki/Writing-operators-for-2.0&quot;&gt;RxJava wiki: Writing operators&lt;/a&gt;
     * @see #compose(MaybeTransformer)
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;R&gt; Maybe&lt;R&gt; lift(final MaybeOperator&lt;? extends R, ? super T&gt; lift) {
<span class="fc" id="L3455">        ObjectHelper.requireNonNull(lift, &quot;lift is null&quot;);</span>
<span class="fc" id="L3456">        return RxJavaPlugins.onAssembly(new MaybeLift&lt;T, R&gt;(this, lift));</span>
    }

    /**
     * Returns a Maybe that applies a specified function to the item emitted by the source Maybe and
     * emits the result of this function application.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;515&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.map.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code map} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;R&gt; the result value type
     * @param mapper
     *            a function to apply to the item emitted by the Maybe
     * @return a Maybe that emits the item from the source Maybe, transformed by the specified function
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/map.html&quot;&gt;ReactiveX operators documentation: Map&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;R&gt; Maybe&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper) {
<span class="fc" id="L3479">        ObjectHelper.requireNonNull(mapper, &quot;mapper is null&quot;);</span>
<span class="fc" id="L3480">        return RxJavaPlugins.onAssembly(new MaybeMap&lt;T, R&gt;(this, mapper));</span>
    }

    /**
     * Maps the signal types of this Maybe into a {@link Notification} of the same kind
     * and emits it as a single success value to downstream.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/materialize.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code materialize} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @return the new Single instance
     * @since 2.2.4 - experimental
     * @see Single#dematerialize(Function)
     */
    @Experimental
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Single&lt;Notification&lt;T&gt;&gt; materialize() {
<span class="fc" id="L3500">        return RxJavaPlugins.onAssembly(new MaybeMaterialize&lt;T&gt;(this));</span>
    }

    /**
     * Flattens this and another Maybe into a single Flowable, without any transformation.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/merge.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * You can combine items emitted by multiple Maybes so that they appear as a single Flowable, by
     * using the {@code mergeWith} method.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code mergeWith} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param other
     *            a MaybeSource to be merged
     * @return a new Flowable instance
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/merge.html&quot;&gt;ReactiveX operators documentation: Merge&lt;/a&gt;
     */
    @BackpressureSupport(BackpressureKind.FULL)
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;T&gt; mergeWith(MaybeSource&lt;? extends T&gt; other) {
<span class="fc" id="L3527">        ObjectHelper.requireNonNull(other, &quot;other is null&quot;);</span>
<span class="fc" id="L3528">        return merge(this, other);</span>
    }

    /**
     * Wraps a Maybe to emit its item (or notify of its error) on a specified {@link Scheduler},
     * asynchronously.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;182&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.observeOn.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;you specify which {@link Scheduler} this operator will use.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param scheduler
     *            the {@link Scheduler} to notify subscribers on
     * @return the new Maybe instance that its subscribers are notified on the specified
     *         {@link Scheduler}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/observeon.html&quot;&gt;ReactiveX operators documentation: ObserveOn&lt;/a&gt;
     * @see &lt;a href=&quot;http://www.grahamlea.com/2014/07/rxjava-threading-examples/&quot;&gt;RxJava Threading Examples&lt;/a&gt;
     * @see #subscribeOn
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Maybe&lt;T&gt; observeOn(final Scheduler scheduler) {
<span class="fc" id="L3553">        ObjectHelper.requireNonNull(scheduler, &quot;scheduler is null&quot;);</span>
<span class="fc" id="L3554">        return RxJavaPlugins.onAssembly(new MaybeObserveOn&lt;T&gt;(this, scheduler));</span>
    }

    /**
     * Filters the items emitted by a Maybe, only emitting its success value if that
     * is an instance of the supplied Class.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/ofClass.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code ofType} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;U&gt; the output type
     * @param clazz
     *            the class type to filter the items emitted by the source Maybe
     * @return the new Maybe instance
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/filter.html&quot;&gt;ReactiveX operators documentation: Filter&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;U&gt; Maybe&lt;U&gt; ofType(final Class&lt;U&gt; clazz) {
<span class="fc" id="L3577">        ObjectHelper.requireNonNull(clazz, &quot;clazz is null&quot;);</span>
<span class="fc" id="L3578">        return filter(Functions.isInstanceOf(clazz)).cast(clazz);</span>
    }

    /**
     * Calls the specified converter function with the current Maybe instance
     * during assembly time and returns its result.
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code to} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;R&gt; the result type
     * @param convert the function that is called with the current Maybe instance during
     *                assembly time that should return some value to be the result
     *
     * @return the value returned by the convert function
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;R&gt; R to(Function&lt;? super Maybe&lt;T&gt;, R&gt; convert) {
        try {
<span class="fc" id="L3599">            return ObjectHelper.requireNonNull(convert, &quot;convert is null&quot;).apply(this);</span>
<span class="fc" id="L3600">        } catch (Throwable ex) {</span>
<span class="fc" id="L3601">            Exceptions.throwIfFatal(ex);</span>
<span class="fc" id="L3602">            throw ExceptionHelper.wrapOrThrow(ex);</span>
        }
    }

    /**
     * Converts this Maybe into a backpressure-aware Flowable instance composing cancellation
     * through.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The returned Flowable honors the backpressure of the downstream.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code toFlowable} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @return the new Flowable instance
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    @BackpressureSupport(BackpressureKind.FULL)
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;T&gt; toFlowable() {
<span class="fc bfc" id="L3622" title="All 2 branches covered.">        if (this instanceof FuseToFlowable) {</span>
<span class="fc" id="L3623">            return ((FuseToFlowable&lt;T&gt;)this).fuseToFlowable();</span>
        }
<span class="fc" id="L3625">        return RxJavaPlugins.onAssembly(new MaybeToFlowable&lt;T&gt;(this));</span>
    }

    /**
     * Converts this Maybe into an Observable instance composing disposal
     * through.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code toObservable} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @return the new Observable instance
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Observable&lt;T&gt; toObservable() {
<span class="fc bfc" id="L3641" title="All 2 branches covered.">        if (this instanceof FuseToObservable) {</span>
<span class="fc" id="L3642">            return ((FuseToObservable&lt;T&gt;)this).fuseToObservable();</span>
        }
<span class="fc" id="L3644">        return RxJavaPlugins.onAssembly(new MaybeToObservable&lt;T&gt;(this));</span>
    }

    /**
     * Converts this Maybe into a Single instance composing disposal
     * through and turning an empty Maybe into a Single that emits the given
     * value through onSuccess.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code toSingle} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param defaultValue the default item to signal in Single if this Maybe is empty
     * @return the new Single instance
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Single&lt;T&gt; toSingle(T defaultValue) {
<span class="fc" id="L3662">        ObjectHelper.requireNonNull(defaultValue, &quot;defaultValue is null&quot;);</span>
<span class="fc" id="L3663">        return RxJavaPlugins.onAssembly(new MaybeToSingle&lt;T&gt;(this, defaultValue));</span>
    }

    /**
     * Converts this Maybe into a Single instance composing disposal
     * through and turning an empty Maybe into a signal of NoSuchElementException.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code toSingle} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @return the new Single instance
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Single&lt;T&gt; toSingle() {
<span class="fc" id="L3678">        return RxJavaPlugins.onAssembly(new MaybeToSingle&lt;T&gt;(this, null));</span>
    }

    /**
     * Returns a Maybe instance that if this Maybe emits an error, it will emit an onComplete
     * and swallow the throwable.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code onErrorComplete} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @return the new Maybe instance
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Maybe&lt;T&gt; onErrorComplete() {
<span class="fc" id="L3693">        return onErrorComplete(Functions.alwaysTrue());</span>
    }

    /**
     * Returns a Maybe instance that if this Maybe emits an error and the predicate returns
     * true, it will emit an onComplete and swallow the throwable.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code onErrorComplete} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param predicate the predicate to call when an Throwable is emitted which should return true
     * if the Throwable should be swallowed and replaced with an onComplete.
     * @return the new Maybe instance
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Maybe&lt;T&gt; onErrorComplete(final Predicate&lt;? super Throwable&gt; predicate) {
<span class="fc" id="L3711">        ObjectHelper.requireNonNull(predicate, &quot;predicate is null&quot;);</span>

<span class="fc" id="L3713">        return RxJavaPlugins.onAssembly(new MaybeOnErrorComplete&lt;T&gt;(this, predicate));</span>
    }

    /**
     * Instructs a Maybe to pass control to another {@link MaybeSource} rather than invoking
     * {@link MaybeObserver#onError onError} if it encounters an error.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/onErrorResumeNext.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * You can use this to prevent errors from propagating or to supply fallback data should errors be
     * encountered.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code onErrorResumeNext} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param next
     *            the next {@code MaybeSource} that will take over if the source Maybe encounters
     *            an error
     * @return the new Maybe instance
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/catch.html&quot;&gt;ReactiveX operators documentation: Catch&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Maybe&lt;T&gt; onErrorResumeNext(final MaybeSource&lt;? extends T&gt; next) {
<span class="fc" id="L3739">        ObjectHelper.requireNonNull(next, &quot;next is null&quot;);</span>
<span class="fc" id="L3740">        return onErrorResumeNext(Functions.justFunction(next));</span>
    }

    /**
     * Instructs a Maybe to pass control to another Maybe rather than invoking
     * {@link MaybeObserver#onError onError} if it encounters an error.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/onErrorResumeNext.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * You can use this to prevent errors from propagating or to supply fallback data should errors be
     * encountered.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code onErrorResumeNext} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param resumeFunction
     *            a function that returns a MaybeSource that will take over if the source Maybe encounters
     *            an error
     * @return the new Maybe instance
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/catch.html&quot;&gt;ReactiveX operators documentation: Catch&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Maybe&lt;T&gt; onErrorResumeNext(Function&lt;? super Throwable, ? extends MaybeSource&lt;? extends T&gt;&gt; resumeFunction) {
<span class="fc" id="L3766">        ObjectHelper.requireNonNull(resumeFunction, &quot;resumeFunction is null&quot;);</span>
<span class="fc" id="L3767">        return RxJavaPlugins.onAssembly(new MaybeOnErrorNext&lt;T&gt;(this, resumeFunction, true));</span>
    }

    /**
     * Instructs a Maybe to emit an item (returned by a specified function) rather than invoking
     * {@link MaybeObserver#onError onError} if it encounters an error.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/onErrorReturn.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * You can use this to prevent errors from propagating or to supply fallback data should errors be
     * encountered.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code onErrorReturn} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param valueSupplier
     *            a function that returns a single value that will be emitted as success value
     *            the current Maybe signals an onError event
     * @return the new Maybe instance
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/catch.html&quot;&gt;ReactiveX operators documentation: Catch&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Maybe&lt;T&gt; onErrorReturn(Function&lt;? super Throwable, ? extends T&gt; valueSupplier) {
<span class="fc" id="L3793">        ObjectHelper.requireNonNull(valueSupplier, &quot;valueSupplier is null&quot;);</span>
<span class="fc" id="L3794">        return RxJavaPlugins.onAssembly(new MaybeOnErrorReturn&lt;T&gt;(this, valueSupplier));</span>
    }

    /**
     * Instructs a Maybe to emit an item (returned by a specified function) rather than invoking
     * {@link MaybeObserver#onError onError} if it encounters an error.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/onErrorReturn.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * You can use this to prevent errors from propagating or to supply fallback data should errors be
     * encountered.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code onErrorReturnItem} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param item
     *            the value that is emitted as onSuccess in case this Maybe signals an onError
     * @return the new Maybe instance
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/catch.html&quot;&gt;ReactiveX operators documentation: Catch&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Maybe&lt;T&gt; onErrorReturnItem(final T item) {
<span class="fc" id="L3819">        ObjectHelper.requireNonNull(item, &quot;item is null&quot;);</span>
<span class="fc" id="L3820">        return onErrorReturn(Functions.justFunction(item));</span>
    }

    /**
     * Instructs a Maybe to pass control to another MaybeSource rather than invoking
     * {@link MaybeObserver#onError onError} if it encounters an {@link java.lang.Exception}.
     * &lt;p&gt;
     * This differs from {@link #onErrorResumeNext} in that this one does not handle {@link java.lang.Throwable}
     * or {@link java.lang.Error} but lets those continue through.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;333&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/onExceptionResumeNextViaMaybe.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * You can use this to prevent exceptions from propagating or to supply fallback data should exceptions be
     * encountered.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code onExceptionResumeNext} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param next
     *            the next MaybeSource that will take over if the source Maybe encounters
     *            an exception
     * @return the new Maybe instance
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/catch.html&quot;&gt;ReactiveX operators documentation: Catch&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Maybe&lt;T&gt; onExceptionResumeNext(final MaybeSource&lt;? extends T&gt; next) {
<span class="fc" id="L3849">        ObjectHelper.requireNonNull(next, &quot;next is null&quot;);</span>
<span class="fc" id="L3850">        return RxJavaPlugins.onAssembly(new MaybeOnErrorNext&lt;T&gt;(this, Functions.justFunction(next), false));</span>
    }

    /**
     * Nulls out references to the upstream producer and downstream MaybeObserver if
     * the sequence is terminated or downstream calls dispose().
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code onTerminateDetach} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @return a Maybe which nulls out references to the upstream producer and downstream MaybeObserver if
     * the sequence is terminated or downstream calls dispose()
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Maybe&lt;T&gt; onTerminateDetach() {
<span class="fc" id="L3866">        return RxJavaPlugins.onAssembly(new MaybeDetach&lt;T&gt;(this));</span>
    }

    /**
     * Returns a Flowable that repeats the sequence of items emitted by the source Maybe indefinitely.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;309&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/repeat.o.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors downstream backpressure.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code repeat} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @return a Flowable that emits the items emitted by the source Maybe repeatedly and in sequence
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/repeat.html&quot;&gt;ReactiveX operators documentation: Repeat&lt;/a&gt;
     */
    @BackpressureSupport(BackpressureKind.FULL)
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;T&gt; repeat() {
<span class="fc" id="L3887">        return repeat(Long.MAX_VALUE);</span>
    }

    /**
     * Returns a Flowable that repeats the sequence of items emitted by the source Maybe at most
     * {@code count} times.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/repeat.on.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator honors downstream backpressure.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code repeat} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param times
     *            the number of times the source Maybe items are repeated, a count of 0 will yield an empty
     *            sequence
     * @return a Flowable that repeats the sequence of items emitted by the source Maybe at most
     *         {@code count} times
     * @throws IllegalArgumentException
     *             if {@code count} is less than zero
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/repeat.html&quot;&gt;ReactiveX operators documentation: Repeat&lt;/a&gt;
     */
    @BackpressureSupport(BackpressureKind.FULL)
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;T&gt; repeat(long times) {
<span class="fc" id="L3915">        return toFlowable().repeat(times);</span>
    }

    /**
     * Returns a Flowable that repeats the sequence of items emitted by the source Maybe until
     * the provided stop function returns true.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/repeat.on.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This operator honors downstream backpressure.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code repeatUntil} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param stop
     *                a boolean supplier that is called when the current Flowable completes and unless it returns
     *                false, the current Flowable is resubscribed
     * @return the new Flowable instance
     * @throws NullPointerException
     *             if {@code stop} is null
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/repeat.html&quot;&gt;ReactiveX operators documentation: Repeat&lt;/a&gt;
     */
    @BackpressureSupport(BackpressureKind.FULL)
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;T&gt; repeatUntil(BooleanSupplier stop) {
<span class="fc" id="L3942">        return toFlowable().repeatUntil(stop);</span>
    }

    /**
     * Returns a Flowable that emits the same values as the source Publisher with the exception of an
     * {@code onComplete}. An {@code onComplete} notification from the source will result in the emission of
     * a {@code void} item to the Publisher provided as an argument to the {@code notificationHandler}
     * function. If that Publisher calls {@code onComplete} or {@code onError} then {@code repeatWhen} will
     * call {@code onComplete} or {@code onError} on the child subscription. Otherwise, this Publisher will
     * resubscribe to the source Publisher.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;430&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/repeatWhen.f.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors downstream backpressure and expects the source {@code Publisher} to honor backpressure as well.
     *  If this expectation is violated, the operator &lt;em&gt;may&lt;/em&gt; throw an {@code IllegalStateException}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code repeatWhen} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param handler
     *            receives a Publisher of notifications with which a user can complete or error, aborting the repeat.
     * @return the source Publisher modified with repeat logic
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/repeat.html&quot;&gt;ReactiveX operators documentation: Repeat&lt;/a&gt;
     */
    @BackpressureSupport(BackpressureKind.FULL)
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;T&gt; repeatWhen(final Function&lt;? super Flowable&lt;Object&gt;, ? extends Publisher&lt;?&gt;&gt; handler) {
<span class="fc" id="L3971">        return toFlowable().repeatWhen(handler);</span>
    }

    /**
     * Returns a Maybe that mirrors the source Maybe, resubscribing to it if it calls {@code onError}
     * (infinite retry count).
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;315&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/retry.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * If the source Maybe calls {@link MaybeObserver#onError}, this method will resubscribe to the source
     * Maybe rather than propagating the {@code onError} call.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code retry} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @return the new Maybe instance
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/retry.html&quot;&gt;ReactiveX operators documentation: Retry&lt;/a&gt;
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Maybe&lt;T&gt; retry() {
<span class="fc" id="L3993">        return retry(Long.MAX_VALUE, Functions.alwaysTrue());</span>
    }

    /**
     * Returns a Maybe that mirrors the source Maybe, resubscribing to it if it calls {@code onError}
     * and the predicate returns true for that specific exception and retry count.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;315&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/retry.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code retry} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param predicate
     *            the predicate that determines if a resubscription may happen in case of a specific exception
     *            and retry count
     * @return the new Maybe instance
     * @see #retry()
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/retry.html&quot;&gt;ReactiveX operators documentation: Retry&lt;/a&gt;
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Maybe&lt;T&gt; retry(BiPredicate&lt;? super Integer, ? super Throwable&gt; predicate) {
<span class="fc" id="L4016">        return toFlowable().retry(predicate).singleElement();</span>
    }

    /**
     * Returns a Maybe that mirrors the source Maybe, resubscribing to it if it calls {@code onError}
     * up to a specified number of retries.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;315&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/retry.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * If the source Maybe calls {@link MaybeObserver#onError}, this method will resubscribe to the source
     * Maybe for a maximum of {@code count} resubscriptions rather than propagating the
     * {@code onError} call.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code retry} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param count
     *            the number of times to resubscribe if the current Maybe fails
     * @return the new Maybe instance
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/retry.html&quot;&gt;ReactiveX operators documentation: Retry&lt;/a&gt;
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Maybe&lt;T&gt; retry(long count) {
<span class="fc" id="L4041">        return retry(count, Functions.alwaysTrue());</span>
    }

    /**
     * Retries at most times or until the predicate returns false, whichever happens first.
     *
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code retry} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param times the number of times to resubscribe if the current Maybe fails
     * @param predicate the predicate called with the failure Throwable and should return true to trigger a retry.
     * @return the new Maybe instance
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Maybe&lt;T&gt; retry(long times, Predicate&lt;? super Throwable&gt; predicate) {
<span class="fc" id="L4058">        return toFlowable().retry(times, predicate).singleElement();</span>
    }

    /**
     * Retries the current Maybe if it fails and the predicate returns true.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code retry} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param predicate the predicate that receives the failure Throwable and should return true to trigger a retry.
     * @return the new Maybe instance
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Maybe&lt;T&gt; retry(Predicate&lt;? super Throwable&gt; predicate) {
<span class="fc" id="L4074">        return retry(Long.MAX_VALUE, predicate);</span>
    }

    /**
     * Retries until the given stop function returns true.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code retryUntil} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param stop the function that should return true to stop retrying
     * @return the new Maybe instance
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Maybe&lt;T&gt; retryUntil(final BooleanSupplier stop) {
<span class="fc" id="L4090">        ObjectHelper.requireNonNull(stop, &quot;stop is null&quot;);</span>
<span class="fc" id="L4091">        return retry(Long.MAX_VALUE, Functions.predicateReverseFor(stop));</span>
    }

    /**
     * Returns a Maybe that emits the same values as the source Maybe with the exception of an
     * {@code onError}. An {@code onError} notification from the source will result in the emission of a
     * {@link Throwable} item to the Publisher provided as an argument to the {@code notificationHandler}
     * function. If that Publisher calls {@code onComplete} or {@code onError} then {@code retry} will call
     * {@code onComplete} or {@code onError} on the child subscription. Otherwise, this Publisher will
     * resubscribe to the source Publisher.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;430&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/retryWhen.f.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * Example:
     *
     * This retries 3 times, each time incrementing the number of seconds it waits.
     *
     * &lt;pre&gt;&lt;code&gt;
     *  Maybe.create((MaybeEmitter&amp;lt;? super String&amp;gt; s) -&amp;gt; {
     *      System.out.println(&quot;subscribing&quot;);
     *      s.onError(new RuntimeException(&quot;always fails&quot;));
     *  }, BackpressureStrategy.BUFFER).retryWhen(attempts -&amp;gt; {
     *      return attempts.zipWith(Publisher.range(1, 3), (n, i) -&amp;gt; i).flatMap(i -&amp;gt; {
     *          System.out.println(&quot;delay retry by &quot; + i + &quot; second(s)&quot;);
     *          return Flowable.timer(i, TimeUnit.SECONDS);
     *      });
     *  }).blockingForEach(System.out::println);
     * &lt;/code&gt;&lt;/pre&gt;
     *
     * Output is:
     *
     * &lt;pre&gt; {@code
     * subscribing
     * delay retry by 1 second(s)
     * subscribing
     * delay retry by 2 second(s)
     * subscribing
     * delay retry by 3 second(s)
     * subscribing
     * } &lt;/pre&gt;
     * &lt;p&gt;
     * Note that the inner {@code Publisher} returned by the handler function should signal
     * either {@code onNext}, {@code onError} or {@code onComplete} in response to the received
     * {@code Throwable} to indicate the operator should retry or terminate. If the upstream to
     * the operator is asynchronous, signalling onNext followed by onComplete immediately may
     * result in the sequence to be completed immediately. Similarly, if this inner
     * {@code Publisher} signals {@code onError} or {@code onComplete} while the upstream is
     * active, the sequence is terminated with the same signal immediately.
     * &lt;p&gt;
     * The following example demonstrates how to retry an asynchronous source with a delay:
     * &lt;pre&gt;&lt;code&gt;
     * Maybe.timer(1, TimeUnit.SECONDS)
     *     .doOnSubscribe(s -&amp;gt; System.out.println(&quot;subscribing&quot;))
     *     .map(v -&amp;gt; { throw new RuntimeException(); })
     *     .retryWhen(errors -&amp;gt; {
     *         AtomicInteger counter = new AtomicInteger();
     *         return errors
     *                   .takeWhile(e -&amp;gt; counter.getAndIncrement() != 3)
     *                   .flatMap(e -&amp;gt; {
     *                       System.out.println(&quot;delay retry by &quot; + counter.get() + &quot; second(s)&quot;);
     *                       return Flowable.timer(counter.get(), TimeUnit.SECONDS);
     *                   });
     *     })
     *     .blockingGet();
     * &lt;/code&gt;&lt;/pre&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code retryWhen} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param handler
     *            receives a Publisher of notifications with which a user can complete or error, aborting the
     *            retry
     * @return the new Maybe instance
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/retry.html&quot;&gt;ReactiveX operators documentation: Retry&lt;/a&gt;
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Maybe&lt;T&gt; retryWhen(
            final Function&lt;? super Flowable&lt;Throwable&gt;, ? extends Publisher&lt;?&gt;&gt; handler) {
<span class="fc" id="L4171">        return toFlowable().retryWhen(handler).singleElement();</span>
    }

    /**
     * Subscribes to a Maybe and ignores {@code onSuccess} and {@code onComplete} emissions.
     * &lt;p&gt;
     * If the Maybe emits an error, it is wrapped into an
     * {@link io.reactivex.exceptions.OnErrorNotImplementedException OnErrorNotImplementedException}
     * and routed to the RxJavaPlugins.onError handler.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code subscribe} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @return a {@link Disposable} reference with which the caller can stop receiving items before
     *         the Maybe has finished sending them
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/subscribe.html&quot;&gt;ReactiveX operators documentation: Subscribe&lt;/a&gt;
     */
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Disposable subscribe() {
<span class="fc" id="L4191">        return subscribe(Functions.emptyConsumer(), Functions.ON_ERROR_MISSING, Functions.EMPTY_ACTION);</span>
    }

    /**
     * Subscribes to a Maybe and provides a callback to handle the items it emits.
     * &lt;p&gt;
     * If the Maybe emits an error, it is wrapped into an
     * {@link io.reactivex.exceptions.OnErrorNotImplementedException OnErrorNotImplementedException}
     * and routed to the RxJavaPlugins.onError handler.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code subscribe} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param onSuccess
     *             the {@code Consumer&lt;T&gt;} you have designed to accept a success value from the Maybe
     * @return a {@link Disposable} reference with which the caller can stop receiving items before
     *         the Maybe has finished sending them
     * @throws NullPointerException
     *             if {@code onSuccess} is null
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/subscribe.html&quot;&gt;ReactiveX operators documentation: Subscribe&lt;/a&gt;
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Disposable subscribe(Consumer&lt;? super T&gt; onSuccess) {
<span class="fc" id="L4216">        return subscribe(onSuccess, Functions.ON_ERROR_MISSING, Functions.EMPTY_ACTION);</span>
    }

    /**
     * Subscribes to a Maybe and provides callbacks to handle the items it emits and any error
     * notification it issues.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code subscribe} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param onSuccess
     *             the {@code Consumer&lt;T&gt;} you have designed to accept a success value from the Maybe
     * @param onError
     *             the {@code Consumer&lt;Throwable&gt;} you have designed to accept any error notification from the
     *             Maybe
     * @return a {@link Disposable} reference with which the caller can stop receiving items before
     *         the Maybe has finished sending them
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/subscribe.html&quot;&gt;ReactiveX operators documentation: Subscribe&lt;/a&gt;
     * @throws NullPointerException
     *             if {@code onSuccess} is null, or
     *             if {@code onError} is null
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Disposable subscribe(Consumer&lt;? super T&gt; onSuccess, Consumer&lt;? super Throwable&gt; onError) {
<span class="fc" id="L4242">        return subscribe(onSuccess, onError, Functions.EMPTY_ACTION);</span>
    }

    /**
     * Subscribes to a Maybe and provides callbacks to handle the items it emits and any error or
     * completion notification it issues.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code subscribe} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param onSuccess
     *             the {@code Consumer&lt;T&gt;} you have designed to accept a success value from the Maybe
     * @param onError
     *             the {@code Consumer&lt;Throwable&gt;} you have designed to accept any error notification from the
     *             Maybe
     * @param onComplete
     *             the {@code Action} you have designed to accept a completion notification from the
     *             Maybe
     * @return a {@link Disposable} reference with which the caller can stop receiving items before
     *         the Maybe has finished sending them
     * @throws NullPointerException
     *             if {@code onSuccess} is null, or
     *             if {@code onError} is null, or
     *             if {@code onComplete} is null
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/subscribe.html&quot;&gt;ReactiveX operators documentation: Subscribe&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Disposable subscribe(Consumer&lt;? super T&gt; onSuccess, Consumer&lt;? super Throwable&gt; onError,
            Action onComplete) {
<span class="fc" id="L4274">        ObjectHelper.requireNonNull(onSuccess, &quot;onSuccess is null&quot;);</span>
<span class="fc" id="L4275">        ObjectHelper.requireNonNull(onError, &quot;onError is null&quot;);</span>
<span class="fc" id="L4276">        ObjectHelper.requireNonNull(onComplete, &quot;onComplete is null&quot;);</span>
<span class="fc" id="L4277">        return subscribeWith(new MaybeCallbackObserver&lt;T&gt;(onSuccess, onError, onComplete));</span>
    }

    @SchedulerSupport(SchedulerSupport.NONE)
    @Override
    public final void subscribe(MaybeObserver&lt;? super T&gt; observer) {
<span class="fc" id="L4283">        ObjectHelper.requireNonNull(observer, &quot;observer is null&quot;);</span>

<span class="fc" id="L4285">        observer = RxJavaPlugins.onSubscribe(this, observer);</span>

<span class="fc" id="L4287">        ObjectHelper.requireNonNull(observer, &quot;The RxJavaPlugins.onSubscribe hook returned a null MaybeObserver. Please check the handler provided to RxJavaPlugins.setOnMaybeSubscribe for invalid null returns. Further reading: https://github.com/ReactiveX/RxJava/wiki/Plugins&quot;);</span>

        try {
<span class="fc" id="L4290">            subscribeActual(observer);</span>
<span class="fc" id="L4291">        } catch (NullPointerException ex) {</span>
<span class="fc" id="L4292">            throw ex;</span>
<span class="fc" id="L4293">        } catch (Throwable ex) {</span>
<span class="fc" id="L4294">            Exceptions.throwIfFatal(ex);</span>
<span class="fc" id="L4295">            NullPointerException npe = new NullPointerException(&quot;subscribeActual failed&quot;);</span>
<span class="fc" id="L4296">            npe.initCause(ex);</span>
<span class="fc" id="L4297">            throw npe;</span>
<span class="fc" id="L4298">        }</span>
<span class="fc" id="L4299">    }</span>

    /**
     * Implement this method in subclasses to handle the incoming {@link MaybeObserver}s.
     * &lt;p&gt;There is no need to call any of the plugin hooks on the current {@code Maybe} instance or
     * the {@code MaybeObserver}; all hooks and basic safeguards have been
     * applied by {@link #subscribe(MaybeObserver)} before this method gets called.
     * @param observer the MaybeObserver to handle, not null
     */
    protected abstract void subscribeActual(MaybeObserver&lt;? super T&gt; observer);

    /**
     * Asynchronously subscribes subscribers to this Maybe on the specified {@link Scheduler}.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;752&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.subscribeOn.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;you specify which {@link Scheduler} this operator will use.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param scheduler
     *            the {@link Scheduler} to perform subscription actions on
     * @return the new Maybe instance that its subscriptions happen on the specified {@link Scheduler}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/subscribeon.html&quot;&gt;ReactiveX operators documentation: SubscribeOn&lt;/a&gt;
     * @see &lt;a href=&quot;http://www.grahamlea.com/2014/07/rxjava-threading-examples/&quot;&gt;RxJava Threading Examples&lt;/a&gt;
     * @see #observeOn
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Maybe&lt;T&gt; subscribeOn(Scheduler scheduler) {
<span class="fc" id="L4330">        ObjectHelper.requireNonNull(scheduler, &quot;scheduler is null&quot;);</span>
<span class="fc" id="L4331">        return RxJavaPlugins.onAssembly(new MaybeSubscribeOn&lt;T&gt;(this, scheduler));</span>
    }

    /**
     * Subscribes a given MaybeObserver (subclass) to this Maybe and returns the given
     * MaybeObserver as is.
     * &lt;p&gt;Usage example:
     * &lt;pre&gt;&lt;code&gt;
     * Maybe&amp;lt;Integer&amp;gt; source = Maybe.just(1);
     * CompositeDisposable composite = new CompositeDisposable();
     *
     * DisposableMaybeObserver&amp;lt;Integer&amp;gt; ds = new DisposableMaybeObserver&amp;lt;&amp;gt;() {
     *     // ...
     * };
     *
     * composite.add(source.subscribeWith(ds));
     * &lt;/code&gt;&lt;/pre&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code subscribeWith} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;E&gt; the type of the MaybeObserver to use and return
     * @param observer the MaybeObserver (subclass) to use and return, not null
     * @return the input {@code subscriber}
     * @throws NullPointerException if {@code subscriber} is null
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;E extends MaybeObserver&lt;? super T&gt;&gt; E subscribeWith(E observer) {
<span class="fc" id="L4360">        subscribe(observer);</span>
<span class="fc" id="L4361">        return observer;</span>
    }

    /**
     * Returns a Maybe that emits the items emitted by the source Maybe or the items of an alternate
     * MaybeSource if the current Maybe is empty.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;445&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/switchifempty.m.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code switchIfEmpty} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param other
     *              the alternate MaybeSource to subscribe to if the main does not emit any items
     * @return  a Maybe that emits the items emitted by the source Maybe or the items of an
     *          alternate MaybeSource if the source Maybe is empty.
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Maybe&lt;T&gt; switchIfEmpty(MaybeSource&lt;? extends T&gt; other) {
<span class="fc" id="L4383">        ObjectHelper.requireNonNull(other, &quot;other is null&quot;);</span>
<span class="fc" id="L4384">        return RxJavaPlugins.onAssembly(new MaybeSwitchIfEmpty&lt;T&gt;(this, other));</span>
    }

    /**
     * Returns a Single that emits the items emitted by the source Maybe or the item of an alternate
     * SingleSource if the current Maybe is empty.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;445&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/switchifempty.m.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code switchIfEmpty} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * &lt;p&gt;History: 2.1.4 - experimental
     * @param other
     *              the alternate SingleSource to subscribe to if the main does not emit any items
     * @return  a Single that emits the items emitted by the source Maybe or the item of an
     *          alternate SingleSource if the source Maybe is empty.
     * @since 2.2
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Single&lt;T&gt; switchIfEmpty(SingleSource&lt;? extends T&gt; other) {
<span class="fc" id="L4407">        ObjectHelper.requireNonNull(other, &quot;other is null&quot;);</span>
<span class="fc" id="L4408">        return RxJavaPlugins.onAssembly(new MaybeSwitchIfEmptySingle&lt;T&gt;(this, other));</span>
    }

    /**
     * Returns a Maybe that emits the items emitted by the source Maybe until a second MaybeSource
     * emits an item.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/takeUntil.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code takeUntil} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param other
     *            the MaybeSource whose first emitted item will cause {@code takeUntil} to stop emitting items
     *            from the source Maybe
     * @param &lt;U&gt;
     *            the type of items emitted by {@code other}
     * @return a Maybe that emits the items emitted by the source Maybe until such time as {@code other} emits its first item
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/takeuntil.html&quot;&gt;ReactiveX operators documentation: TakeUntil&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;U&gt; Maybe&lt;T&gt; takeUntil(MaybeSource&lt;U&gt; other) {
<span class="fc" id="L4433">        ObjectHelper.requireNonNull(other, &quot;other is null&quot;);</span>
<span class="fc" id="L4434">        return RxJavaPlugins.onAssembly(new MaybeTakeUntilMaybe&lt;T, U&gt;(this, other));</span>
    }

    /**
     * Returns a Maybe that emits the item emitted by the source Maybe until a second Publisher
     * emits an item.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/takeUntil.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The {@code Publisher} is consumed in an unbounded fashion and is cancelled after the first item
     *  emitted.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code takeUntil} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param other
     *            the Publisher whose first emitted item will cause {@code takeUntil} to stop emitting items
     *            from the source Publisher
     * @param &lt;U&gt;
     *            the type of items emitted by {@code other}
     * @return a Maybe that emits the items emitted by the source Maybe until such time as {@code other} emits its first item
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/takeuntil.html&quot;&gt;ReactiveX operators documentation: TakeUntil&lt;/a&gt;
     */
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;U&gt; Maybe&lt;T&gt; takeUntil(Publisher&lt;U&gt; other) {
<span class="fc" id="L4463">        ObjectHelper.requireNonNull(other, &quot;other is null&quot;);</span>
<span class="fc" id="L4464">        return RxJavaPlugins.onAssembly(new MaybeTakeUntilPublisher&lt;T, U&gt;(this, other));</span>
    }

    /**
     * Returns a Maybe that mirrors the source Maybe but applies a timeout policy for each emitted
     * item. If the next item isn't emitted within the specified timeout duration starting from its predecessor,
     * the resulting Maybe terminates and notifies MaybeObservers of a {@code TimeoutException}.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/timeout.1.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code timeout} operates by default on the {@code computation} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param timeout
     *            maximum duration between emitted items before a timeout occurs
     * @param timeUnit
     *            the unit of time that applies to the {@code timeout} argument.
     * @return the new Maybe instance
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/timeout.html&quot;&gt;ReactiveX operators documentation: Timeout&lt;/a&gt;
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.COMPUTATION)
    public final Maybe&lt;T&gt; timeout(long timeout, TimeUnit timeUnit) {
<span class="fc" id="L4488">        return timeout(timeout, timeUnit, Schedulers.computation());</span>
    }

    /**
     * Returns a Maybe that mirrors the source Maybe but applies a timeout policy for each emitted
     * item. If the next item isn't emitted within the specified timeout duration starting from its predecessor,
     * the source MaybeSource is disposed and resulting Maybe begins instead to mirror a fallback MaybeSource.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/timeout.2.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This version of {@code timeout} operates by default on the {@code computation} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param timeout
     *            maximum duration between items before a timeout occurs
     * @param timeUnit
     *            the unit of time that applies to the {@code timeout} argument
     * @param fallback
     *            the fallback MaybeSource to use in case of a timeout
     * @return the new Maybe instance
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/timeout.html&quot;&gt;ReactiveX operators documentation: Timeout&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.COMPUTATION)
    public final Maybe&lt;T&gt; timeout(long timeout, TimeUnit timeUnit, MaybeSource&lt;? extends T&gt; fallback) {
<span class="fc" id="L4515">        ObjectHelper.requireNonNull(fallback, &quot;fallback is null&quot;);</span>
<span class="fc" id="L4516">        return timeout(timeout, timeUnit, Schedulers.computation(), fallback);</span>
    }

    /**
     * Returns a Maybe that mirrors the source Maybe but applies a timeout policy for each emitted
     * item using a specified Scheduler. If the next item isn't emitted within the specified timeout duration
     * starting from its predecessor, the source MaybeSource is disposed and resulting Maybe begins instead
     * to mirror a fallback MaybeSource.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/timeout.2s.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;You specify which {@link Scheduler} this operator will use.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param timeout
     *            maximum duration between items before a timeout occurs
     * @param timeUnit
     *            the unit of time that applies to the {@code timeout} argument
     * @param fallback
     *            the MaybeSource to use as the fallback in case of a timeout
     * @param scheduler
     *            the {@link Scheduler} to run the timeout timers on
     * @return the new Maybe instance
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/timeout.html&quot;&gt;ReactiveX operators documentation: Timeout&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Maybe&lt;T&gt; timeout(long timeout, TimeUnit timeUnit, Scheduler scheduler, MaybeSource&lt;? extends T&gt; fallback) {
<span class="fc" id="L4546">        ObjectHelper.requireNonNull(fallback, &quot;fallback is null&quot;);</span>
<span class="fc" id="L4547">        return timeout(timer(timeout, timeUnit, scheduler), fallback);</span>
    }

    /**
     * Returns a Maybe that mirrors the source Maybe but applies a timeout policy for each emitted
     * item, where this policy is governed on a specified Scheduler. If the next item isn't emitted within the
     * specified timeout duration starting from its predecessor, the resulting Maybe terminates and
     * notifies MaybeObservers of a {@code TimeoutException}.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/timeout.1s.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;You specify which {@link Scheduler} this operator will use.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param timeout
     *            maximum duration between items before a timeout occurs
     * @param timeUnit
     *            the unit of time that applies to the {@code timeout} argument
     * @param scheduler
     *            the Scheduler to run the timeout timers on
     * @return the new Maybe instance
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/timeout.html&quot;&gt;ReactiveX operators documentation: Timeout&lt;/a&gt;
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Maybe&lt;T&gt; timeout(long timeout, TimeUnit timeUnit, Scheduler scheduler) {
<span class="fc" id="L4574">        return timeout(timer(timeout, timeUnit, scheduler));</span>
    }

    /**
     * If the current {@code Maybe} didn't signal an event before the {@code timeoutIndicator} {@link MaybeSource} signals, a
     * {@link TimeoutException} is signaled instead.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code timeout} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;U&gt; the value type of the
     * @param timeoutIndicator the {@code MaybeSource} that indicates the timeout by signaling onSuccess
     * or onComplete.
     * @return the new Maybe instance
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;U&gt; Maybe&lt;T&gt; timeout(MaybeSource&lt;U&gt; timeoutIndicator) {
<span class="fc" id="L4593">        ObjectHelper.requireNonNull(timeoutIndicator, &quot;timeoutIndicator is null&quot;);</span>
<span class="fc" id="L4594">        return RxJavaPlugins.onAssembly(new MaybeTimeoutMaybe&lt;T, U&gt;(this, timeoutIndicator, null));</span>
    }

    /**
     * If the current {@code Maybe} didn't signal an event before the {@code timeoutIndicator} {@link MaybeSource} signals,
     * the current {@code Maybe} is disposed and the {@code fallback} {@code MaybeSource} subscribed to
     * as a continuation.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code timeout} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;U&gt; the value type of the
     * @param timeoutIndicator the {@code MaybeSource} that indicates the timeout by signaling {@code onSuccess}
     * or {@code onComplete}.
     * @param fallback the {@code MaybeSource} that is subscribed to if the current {@code Maybe} times out
     * @return the new Maybe instance
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;U&gt; Maybe&lt;T&gt; timeout(MaybeSource&lt;U&gt; timeoutIndicator, MaybeSource&lt;? extends T&gt; fallback) {
<span class="fc" id="L4615">        ObjectHelper.requireNonNull(timeoutIndicator, &quot;timeoutIndicator is null&quot;);</span>
<span class="fc" id="L4616">        ObjectHelper.requireNonNull(fallback, &quot;fallback is null&quot;);</span>
<span class="fc" id="L4617">        return RxJavaPlugins.onAssembly(new MaybeTimeoutMaybe&lt;T, U&gt;(this, timeoutIndicator, fallback));</span>
    }

    /**
     * If the current {@code Maybe} source didn't signal an event before the {@code timeoutIndicator} {@link Publisher} signals, a
     * {@link TimeoutException} is signaled instead.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The {@code timeoutIndicator} {@link Publisher} is consumed in an unbounded manner and
     *  is cancelled after its first item.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code timeout} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;U&gt; the value type of the
     * @param timeoutIndicator the {@code MaybeSource} that indicates the timeout by signaling {@code onSuccess}
     * or {@code onComplete}.
     * @return the new Maybe instance
     */
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;U&gt; Maybe&lt;T&gt; timeout(Publisher&lt;U&gt; timeoutIndicator) {
<span class="fc" id="L4640">        ObjectHelper.requireNonNull(timeoutIndicator, &quot;timeoutIndicator is null&quot;);</span>
<span class="fc" id="L4641">        return RxJavaPlugins.onAssembly(new MaybeTimeoutPublisher&lt;T, U&gt;(this, timeoutIndicator, null));</span>
    }

    /**
     * If the current {@code Maybe} didn't signal an event before the {@code timeoutIndicator} {@link Publisher} signals,
     * the current {@code Maybe} is disposed and the {@code fallback} {@code MaybeSource} subscribed to
     * as a continuation.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The {@code timeoutIndicator} {@link Publisher} is consumed in an unbounded manner and
     *  is cancelled after its first item.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code timeout} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;U&gt; the value type of the
     * @param timeoutIndicator the {@code MaybeSource} that indicates the timeout by signaling {@code onSuccess}
     * or {@code onComplete}
     * @param fallback the {@code MaybeSource} that is subscribed to if the current {@code Maybe} times out
     * @return the new Maybe instance
     */
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;U&gt; Maybe&lt;T&gt; timeout(Publisher&lt;U&gt; timeoutIndicator, MaybeSource&lt;? extends T&gt; fallback) {
<span class="fc" id="L4666">        ObjectHelper.requireNonNull(timeoutIndicator, &quot;timeoutIndicator is null&quot;);</span>
<span class="fc" id="L4667">        ObjectHelper.requireNonNull(fallback, &quot;fallback is null&quot;);</span>
<span class="fc" id="L4668">        return RxJavaPlugins.onAssembly(new MaybeTimeoutPublisher&lt;T, U&gt;(this, timeoutIndicator, fallback));</span>
    }

    /**
     * Returns a Maybe which makes sure when a MaybeObserver disposes the Disposable,
     * that call is propagated up on the specified scheduler.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code unsubscribeOn} calls dispose() of the upstream on the {@link Scheduler} you specify.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param scheduler the target scheduler where to execute the disposal
     * @return the new Maybe instance
     * @throws NullPointerException if scheduler is null
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Maybe&lt;T&gt; unsubscribeOn(final Scheduler scheduler) {
<span class="fc" id="L4686">        ObjectHelper.requireNonNull(scheduler, &quot;scheduler is null&quot;);</span>
<span class="fc" id="L4687">        return RxJavaPlugins.onAssembly(new MaybeUnsubscribeOn&lt;T&gt;(this, scheduler));</span>
    }

    /**
     * Waits until this and the other MaybeSource signal a success value then applies the given BiFunction
     * to those values and emits the BiFunction's resulting value to downstream.
     *
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/zip.png&quot; alt=&quot;&quot;&gt;
     *
     * &lt;p&gt;If either this or the other MaybeSource is empty or signals an error, the resulting Maybe will
     * terminate immediately and dispose the other source.
     *
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code zipWith} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;U&gt;
     *            the type of items emitted by the {@code other} MaybeSource
     * @param &lt;R&gt;
     *            the type of items emitted by the resulting Maybe
     * @param other
     *            the other MaybeSource
     * @param zipper
     *            a function that combines the pairs of items from the two MaybeSources to generate the items to
     *            be emitted by the resulting Maybe
     * @return the new Maybe instance
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/zip.html&quot;&gt;ReactiveX operators documentation: Zip&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;U, R&gt; Maybe&lt;R&gt; zipWith(MaybeSource&lt;? extends U&gt; other, BiFunction&lt;? super T, ? super U, ? extends R&gt; zipper) {
<span class="fc" id="L4720">        ObjectHelper.requireNonNull(other, &quot;other is null&quot;);</span>
<span class="fc" id="L4721">        return zip(this, other, zipper);</span>
    }

    // ------------------------------------------------------------------
    // Test helper
    // ------------------------------------------------------------------

    /**
     * Creates a TestObserver and subscribes
     * it to this Maybe.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code test} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @return the new TestObserver instance
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public final TestObserver&lt;T&gt; test() {
<span class="fc" id="L4740">        TestObserver&lt;T&gt; to = new TestObserver&lt;T&gt;();</span>
<span class="fc" id="L4741">        subscribe(to);</span>
<span class="fc" id="L4742">        return to;</span>
    }

    /**
     * Creates a TestObserver optionally in cancelled state, then subscribes it to this Maybe.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code test} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param cancelled if true, the TestObserver will be cancelled before subscribing to this
     * Maybe.
     * @return the new TestObserver instance
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public final TestObserver&lt;T&gt; test(boolean cancelled) {
<span class="fc" id="L4758">        TestObserver&lt;T&gt; to = new TestObserver&lt;T&gt;();</span>

<span class="fc bfc" id="L4760" title="All 2 branches covered.">        if (cancelled) {</span>
<span class="fc" id="L4761">            to.cancel();</span>
        }

<span class="fc" id="L4764">        subscribe(to);</span>
<span class="fc" id="L4765">        return to;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>