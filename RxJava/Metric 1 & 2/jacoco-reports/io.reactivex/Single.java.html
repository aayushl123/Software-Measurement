<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Single.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">RxJava_2_x$Unnamed.exec</a> &gt; <a href="index.source.html" class="el_package">io.reactivex</a> &gt; <span class="el_source">Single.java</span></div><h1>Single.java</h1><pre class="source lang-java linenums">/**
 * Copyright (c) 2016-present, RxJava Contributors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is
 * distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See
 * the License for the specific language governing permissions and limitations under the License.
 */

package io.reactivex;

import java.util.NoSuchElementException;
import java.util.concurrent.*;

import org.reactivestreams.Publisher;

import io.reactivex.annotations.*;
import io.reactivex.disposables.Disposable;
import io.reactivex.exceptions.Exceptions;
import io.reactivex.functions.*;
import io.reactivex.internal.functions.*;
import io.reactivex.internal.fuseable.*;
import io.reactivex.internal.observers.*;
import io.reactivex.internal.operators.completable.*;
import io.reactivex.internal.operators.flowable.*;
import io.reactivex.internal.operators.maybe.*;
import io.reactivex.internal.operators.mixed.*;
import io.reactivex.internal.operators.observable.*;
import io.reactivex.internal.operators.single.*;
import io.reactivex.internal.util.*;
import io.reactivex.observers.TestObserver;
import io.reactivex.plugins.RxJavaPlugins;
import io.reactivex.schedulers.Schedulers;

/**
 * The {@code Single} class implements the Reactive Pattern for a single value response.
 * &lt;p&gt;
 * {@code Single} behaves similarly to {@link Observable} except that it can only emit either a single successful
 * value or an error (there is no &quot;onComplete&quot; notification as there is for an {@link Observable}).
 * &lt;p&gt;
 * The {@code Single} class implements the {@link SingleSource} base interface and the default consumer
 * type it interacts with is the {@link SingleObserver} via the {@link #subscribe(SingleObserver)} method.
 * &lt;p&gt;
 * The {@code Single} operates with the following sequential protocol:
 * &lt;pre&gt;
 *     &lt;code&gt;onSubscribe (onSuccess | onError)?&lt;/code&gt;
 * &lt;/pre&gt;
 * &lt;p&gt;
 * Note that {@code onSuccess} and {@code onError} are mutually exclusive events; unlike {@code Observable},
 * {@code onSuccess} is never followed by {@code onError}.
 * &lt;p&gt;
 * Like {@code Observable}, a running {@code Single} can be stopped through the {@link Disposable} instance
 * provided to consumers through {@link SingleObserver#onSubscribe}.
 * &lt;p&gt;
 * Like an {@code Observable}, a {@code Single} is lazy, can be either &quot;hot&quot; or &quot;cold&quot;, synchronous or
 * asynchronous. {@code Single} instances returned by the methods of this class are &lt;em&gt;cold&lt;/em&gt;
 * and there is a standard &lt;em&gt;hot&lt;/em&gt; implementation in the form of a subject:
 * {@link io.reactivex.subjects.SingleSubject SingleSubject}.
 * &lt;p&gt;
 * The documentation for this class makes use of marble diagrams. The following legend explains these diagrams:
 * &lt;p&gt;
 * &lt;img width=&quot;640&quot; height=&quot;301&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.legend.png&quot; alt=&quot;&quot;&gt;
 * &lt;p&gt;
 * See {@link Flowable} or {@link Observable} for the
 * implementation of the Reactive Pattern for a stream or vector of values.
 * &lt;p&gt;
 * For more information see the &lt;a href=&quot;http://reactivex.io/documentation/single.html&quot;&gt;ReactiveX
 * documentation&lt;/a&gt;.
 * &lt;p&gt;
 * Example:
 * &lt;pre&gt;&lt;code&gt;
 * Disposable d = Single.just(&quot;Hello World&quot;)
 *    .delay(10, TimeUnit.SECONDS, Schedulers.io())
 *    .subscribeWith(new DisposableSingleObserver&amp;lt;String&amp;gt;() {
 *        &amp;#64;Override
 *        public void onStart() {
 *            System.out.println(&quot;Started&quot;);
 *        }
 *
 *        &amp;#64;Override
 *        public void onSuccess(String value) {
 *            System.out.println(&quot;Success: &quot; + value);
 *        }
 *
 *        &amp;#64;Override
 *        public void onError(Throwable error) {
 *            error.printStackTrace();
 *        }
 *    });
 * 
 * Thread.sleep(5000);
 * 
 * d.dispose();
 * &lt;/code&gt;&lt;/pre&gt;
 * &lt;p&gt;
 * Note that by design, subscriptions via {@link #subscribe(SingleObserver)} can't be disposed
 * from the outside (hence the
 * {@code void} return of the {@link #subscribe(SingleObserver)} method) and it is the
 * responsibility of the implementor of the {@code SingleObserver} to allow this to happen.
 * RxJava supports such usage with the standard
 * {@link io.reactivex.observers.DisposableSingleObserver DisposableSingleObserver} instance.
 * For convenience, the {@link #subscribeWith(SingleObserver)} method is provided as well to
 * allow working with a {@code SingleObserver} (or subclass) instance to be applied with in
 * a fluent manner (such as in the example above).
 * @param &lt;T&gt;
 *            the type of the item emitted by the Single
 * @since 2.0
 * @see io.reactivex.observers.DisposableSingleObserver
 */
<span class="fc" id="L114">public abstract class Single&lt;T&gt; implements SingleSource&lt;T&gt; {</span>

    /**
     * Runs multiple SingleSources and signals the events of the first one that signals (disposing
     * the rest).
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;515&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.amb.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code amb} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;T&gt; the value type
     * @param sources the Iterable sequence of sources. A subscription to each source will
     *            occur in the same order as in this Iterable.
     * @return the new Single instance
     * @since 2.0
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Single&lt;T&gt; amb(final Iterable&lt;? extends SingleSource&lt;? extends T&gt;&gt; sources) {
<span class="fc" id="L135">        ObjectHelper.requireNonNull(sources, &quot;sources is null&quot;);</span>
<span class="fc" id="L136">        return RxJavaPlugins.onAssembly(new SingleAmb&lt;T&gt;(null, sources));</span>
    }

    /**
     * Runs multiple SingleSources and signals the events of the first one that signals (disposing
     * the rest).
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;515&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.ambArray.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code ambArray} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;T&gt; the value type
     * @param sources the array of sources. A subscription to each source will
     *            occur in the same order as in this array.
     * @return the new Single instance
     * @since 2.0
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; Single&lt;T&gt; ambArray(final SingleSource&lt;? extends T&gt;... sources) {
<span class="fc bfc" id="L158" title="All 2 branches covered.">        if (sources.length == 0) {</span>
<span class="fc" id="L159">            return error(SingleInternalHelper.&lt;T&gt;emptyThrower());</span>
        }
<span class="fc bfc" id="L161" title="All 2 branches covered.">        if (sources.length == 1) {</span>
<span class="fc" id="L162">            return wrap((SingleSource&lt;T&gt;)sources[0]);</span>
        }
<span class="fc" id="L164">        return RxJavaPlugins.onAssembly(new SingleAmb&lt;T&gt;(sources, null));</span>
    }

    /**
     * Concatenate the single values, in a non-overlapping fashion, of the SingleSources provided by
     * an Iterable sequence.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;319&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.concat.i.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The returned {@code Flowable} honors the backpressure of the downstream consumer.&lt;/dd&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code concat} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;T&gt; the value type
     * @param sources the Iterable sequence of SingleSource instances
     * @return the new Flowable instance
     * @since 2.0
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    @BackpressureSupport(BackpressureKind.FULL)
    public static &lt;T&gt; Flowable&lt;T&gt; concat(Iterable&lt;? extends SingleSource&lt;? extends T&gt;&gt; sources) {
<span class="fc" id="L188">        return concat(Flowable.fromIterable(sources));</span>
    }

    /**
     * Concatenate the single values, in a non-overlapping fashion, of the SingleSources provided by
     * an Observable sequence.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;319&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.concat.o.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code concat} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;T&gt; the value type
     * @param sources the ObservableSource of SingleSource instances
     * @return the new Observable instance
     * @since 2.0
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    @SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
    public static &lt;T&gt; Observable&lt;T&gt; concat(ObservableSource&lt;? extends SingleSource&lt;? extends T&gt;&gt; sources) {
<span class="fc" id="L210">        ObjectHelper.requireNonNull(sources, &quot;sources is null&quot;);</span>
<span class="fc" id="L211">        return RxJavaPlugins.onAssembly(new ObservableConcatMap(sources, SingleInternalHelper.toObservable(), 2, ErrorMode.IMMEDIATE));</span>
    }

    /**
     * Concatenate the single values, in a non-overlapping fashion, of the SingleSources provided by
     * a Publisher sequence.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;308&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.concat.p.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The returned {@code Flowable} honors the backpressure of the downstream consumer
     *  and the sources {@code Publisher} is expected to honor it as well.&lt;/dd&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code concat} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;T&gt; the value type
     * @param sources the Publisher of SingleSource instances
     * @return the new Flowable instance
     * @since 2.0
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Flowable&lt;T&gt; concat(Publisher&lt;? extends SingleSource&lt;? extends T&gt;&gt; sources) {
<span class="fc" id="L236">        return concat(sources, 2);</span>
    }

    /**
     * Concatenate the single values, in a non-overlapping fashion, of the SingleSources provided by
     * a Publisher sequence and prefetched by the specified amount.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.concat.pn.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The returned {@code Flowable} honors the backpressure of the downstream consumer
     *  and the sources {@code Publisher} is expected to honor it as well.&lt;/dd&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code concat} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;T&gt; the value type
     * @param sources the Publisher of SingleSource instances
     * @param prefetch the number of SingleSources to prefetch from the Publisher
     * @return the new Flowable instance
     * @since 2.0
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    @SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
    public static &lt;T&gt; Flowable&lt;T&gt; concat(Publisher&lt;? extends SingleSource&lt;? extends T&gt;&gt; sources, int prefetch) {
<span class="fc" id="L263">        ObjectHelper.requireNonNull(sources, &quot;sources is null&quot;);</span>
<span class="fc" id="L264">        ObjectHelper.verifyPositive(prefetch, &quot;prefetch&quot;);</span>
<span class="fc" id="L265">        return RxJavaPlugins.onAssembly(new FlowableConcatMapPublisher(sources, SingleInternalHelper.toFlowable(), prefetch, ErrorMode.IMMEDIATE));</span>
    }

    /**
     * Returns a Flowable that emits the items emitted by two Singles, one after the other.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;366&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.concat.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The returned {@code Flowable} honors the backpressure of the downstream consumer.&lt;/dd&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code concat} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T&gt; the common value type
     * @param source1
     *            a Single to be concatenated
     * @param source2
     *            a Single to be concatenated
     * @return a Flowable that emits items emitted by the two source Singles, one after the other.
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/concat.html&quot;&gt;ReactiveX operators documentation: Concat&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; Flowable&lt;T&gt; concat(
            SingleSource&lt;? extends T&gt; source1, SingleSource&lt;? extends T&gt; source2
     ) {
<span class="fc" id="L295">        ObjectHelper.requireNonNull(source1, &quot;source1 is null&quot;);</span>
<span class="fc" id="L296">        ObjectHelper.requireNonNull(source2, &quot;source2 is null&quot;);</span>
<span class="fc" id="L297">        return concat(Flowable.fromArray(source1, source2));</span>
    }

    /**
     * Returns a Flowable that emits the items emitted by three Singles, one after the other.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;366&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.concat.o3.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The returned {@code Flowable} honors the backpressure of the downstream consumer.&lt;/dd&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code concat} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T&gt; the common value type
     * @param source1
     *            a Single to be concatenated
     * @param source2
     *            a Single to be concatenated
     * @param source3
     *            a Single to be concatenated
     * @return a Flowable that emits items emitted by the three source Singles, one after the other.
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/concat.html&quot;&gt;ReactiveX operators documentation: Concat&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; Flowable&lt;T&gt; concat(
            SingleSource&lt;? extends T&gt; source1, SingleSource&lt;? extends T&gt; source2,
            SingleSource&lt;? extends T&gt; source3
     ) {
<span class="fc" id="L330">        ObjectHelper.requireNonNull(source1, &quot;source1 is null&quot;);</span>
<span class="fc" id="L331">        ObjectHelper.requireNonNull(source2, &quot;source2 is null&quot;);</span>
<span class="fc" id="L332">        ObjectHelper.requireNonNull(source3, &quot;source3 is null&quot;);</span>
<span class="fc" id="L333">        return concat(Flowable.fromArray(source1, source2, source3));</span>
    }

    /**
     * Returns a Flowable that emits the items emitted by four Singles, one after the other.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;362&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.concat.o4.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The returned {@code Flowable} honors the backpressure of the downstream consumer.&lt;/dd&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code concat} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T&gt; the common value type
     * @param source1
     *            a Single to be concatenated
     * @param source2
     *            a Single to be concatenated
     * @param source3
     *            a Single to be concatenated
     * @param source4
     *            a Single to be concatenated
     * @return a Flowable that emits items emitted by the four source Singles, one after the other.
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/concat.html&quot;&gt;ReactiveX operators documentation: Concat&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; Flowable&lt;T&gt; concat(
            SingleSource&lt;? extends T&gt; source1, SingleSource&lt;? extends T&gt; source2,
            SingleSource&lt;? extends T&gt; source3, SingleSource&lt;? extends T&gt; source4
     ) {
<span class="fc" id="L368">        ObjectHelper.requireNonNull(source1, &quot;source1 is null&quot;);</span>
<span class="fc" id="L369">        ObjectHelper.requireNonNull(source2, &quot;source2 is null&quot;);</span>
<span class="fc" id="L370">        ObjectHelper.requireNonNull(source3, &quot;source3 is null&quot;);</span>
<span class="fc" id="L371">        ObjectHelper.requireNonNull(source4, &quot;source4 is null&quot;);</span>
<span class="fc" id="L372">        return concat(Flowable.fromArray(source1, source2, source3, source4));</span>
    }

    /**
     * Concatenate the single values, in a non-overlapping fashion, of the SingleSources provided in
     * an array.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;319&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.concatArray.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The returned {@code Flowable} honors the backpressure of the downstream consumer.&lt;/dd&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code concatArray} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;T&gt; the value type
     * @param sources the array of SingleSource instances
     * @return the new Flowable instance
     * @since 2.0
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    @SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
    public static &lt;T&gt; Flowable&lt;T&gt; concatArray(SingleSource&lt;? extends T&gt;... sources) {
<span class="fc" id="L397">        return RxJavaPlugins.onAssembly(new FlowableConcatMap(Flowable.fromArray(sources), SingleInternalHelper.toFlowable(), 2, ErrorMode.BOUNDARY));</span>
    }

    /**
     * Concatenates a sequence of SingleSource eagerly into a single stream of values.
     * &lt;p&gt;
     * Eager concatenation means that once a subscriber subscribes, this operator subscribes to all of the
     * source SingleSources. The operator buffers the value emitted by these SingleSources and then drains them
     * in order, each one after the previous one completes.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This method does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;T&gt; the value type
     * @param sources a sequence of Single that need to be eagerly concatenated
     * @return the new Flowable instance with the specified concatenation behavior
     */
    @BackpressureSupport(BackpressureKind.FULL)
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Flowable&lt;T&gt; concatArrayEager(SingleSource&lt;? extends T&gt;... sources) {
<span class="fc" id="L421">        return Flowable.fromArray(sources).concatMapEager(SingleInternalHelper.&lt;T&gt;toFlowable());</span>
    }

    /**
     * Concatenates a Publisher sequence of SingleSources eagerly into a single stream of values.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;307&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.concatEager.p.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * Eager concatenation means that once a subscriber subscribes, this operator subscribes to all of the
     * emitted source Publishers as they are observed. The operator buffers the values emitted by these
     * Publishers and then drains them in order, each one after the previous one completes.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;Backpressure is honored towards the downstream and the outer Publisher is
     *  expected to support backpressure. Violating this assumption, the operator will
     *  signal {@link io.reactivex.exceptions.MissingBackpressureException}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This method does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;T&gt; the value type
     * @param sources a sequence of Publishers that need to be eagerly concatenated
     * @return the new Publisher instance with the specified concatenation behavior
     */
    @BackpressureSupport(BackpressureKind.FULL)
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Flowable&lt;T&gt; concatEager(Publisher&lt;? extends SingleSource&lt;? extends T&gt;&gt; sources) {
<span class="fc" id="L449">        return Flowable.fromPublisher(sources).concatMapEager(SingleInternalHelper.&lt;T&gt;toFlowable());</span>
    }

    /**
     * Concatenates a sequence of SingleSources eagerly into a single stream of values.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;319&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.concatEager.i.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * Eager concatenation means that once a subscriber subscribes, this operator subscribes to all of the
     * source SingleSources. The operator buffers the values emitted by these SingleSources and then drains them
     * in order, each one after the previous one completes.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;Backpressure is honored towards the downstream.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;This method does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;T&gt; the value type
     * @param sources a sequence of SingleSource that need to be eagerly concatenated
     * @return the new Flowable instance with the specified concatenation behavior
     */
    @BackpressureSupport(BackpressureKind.FULL)
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Flowable&lt;T&gt; concatEager(Iterable&lt;? extends SingleSource&lt;? extends T&gt;&gt; sources) {
<span class="fc" id="L475">        return Flowable.fromIterable(sources).concatMapEager(SingleInternalHelper.&lt;T&gt;toFlowable());</span>
    }

    /**
     * Provides an API (via a cold Single) that bridges the reactive world with the callback-style world.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;454&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.create.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * Example:
     * &lt;pre&gt;&lt;code&gt;
     * Single.&amp;lt;Event&amp;gt;create(emitter -&amp;gt; {
     *     Callback listener = new Callback() {
     *         &amp;#64;Override
     *         public void onEvent(Event e) {
     *             emitter.onSuccess(e);
     *         }
     *
     *         &amp;#64;Override
     *         public void onFailure(Exception e) {
     *             emitter.onError(e);
     *         }
     *     };
     *
     *     AutoCloseable c = api.someMethod(listener);
     *
     *     emitter.setCancellable(c::close);
     *
     * });
     * &lt;/code&gt;&lt;/pre&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code create} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;T&gt; the value type
     * @param source the emitter that is called when a SingleObserver subscribes to the returned {@code Single}
     * @return the new Single instance
     * @see SingleOnSubscribe
     * @see Cancellable
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Single&lt;T&gt; create(SingleOnSubscribe&lt;T&gt; source) {
<span class="fc" id="L518">        ObjectHelper.requireNonNull(source, &quot;source is null&quot;);</span>
<span class="fc" id="L519">        return RxJavaPlugins.onAssembly(new SingleCreate&lt;T&gt;(source));</span>
    }

    /**
     * Calls a {@link Callable} for each individual {@link SingleObserver} to return the actual {@link SingleSource} to
     * be subscribed to.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;515&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.defer.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code defer} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;T&gt; the value type
     * @param singleSupplier the {@code Callable} that is called for each individual {@code SingleObserver} and
     * returns a SingleSource instance to subscribe to
     * @return the new Single instance
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Single&lt;T&gt; defer(final Callable&lt;? extends SingleSource&lt;? extends T&gt;&gt; singleSupplier) {
<span class="fc" id="L540">        ObjectHelper.requireNonNull(singleSupplier, &quot;singleSupplier is null&quot;);</span>
<span class="fc" id="L541">        return RxJavaPlugins.onAssembly(new SingleDefer&lt;T&gt;(singleSupplier));</span>
    }

    /**
     * Signals a Throwable returned by the callback function for each individual SingleObserver.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;283&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.error.c.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code error} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;T&gt; the value type
     * @param errorSupplier the callable that is called for each individual SingleObserver and
     * returns a Throwable instance to be emitted.
     * @return the new Single instance
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Single&lt;T&gt; error(final Callable&lt;? extends Throwable&gt; errorSupplier) {
<span class="fc" id="L561">        ObjectHelper.requireNonNull(errorSupplier, &quot;errorSupplier is null&quot;);</span>
<span class="fc" id="L562">        return RxJavaPlugins.onAssembly(new SingleError&lt;T&gt;(errorSupplier));</span>
    }

    /**
     * Returns a Single that invokes a subscriber's {@link SingleObserver#onError onError} method when the
     * subscriber subscribes to it.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;283&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.error.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code error} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param exception
     *            the particular Throwable to pass to {@link SingleObserver#onError onError}
     * @param &lt;T&gt;
     *            the type of the item (ostensibly) emitted by the Single
     * @return a Single that invokes the subscriber's {@link SingleObserver#onError onError} method when
     *         the subscriber subscribes to it
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/empty-never-throw.html&quot;&gt;ReactiveX operators documentation: Throw&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Single&lt;T&gt; error(final Throwable exception) {
<span class="fc" id="L587">        ObjectHelper.requireNonNull(exception, &quot;exception is null&quot;);</span>
<span class="fc" id="L588">        return error(Functions.justCallable(exception));</span>
    }

    /**
     * Returns a {@link Single} that invokes passed function and emits its result for each new SingleObserver that subscribes.
     * &lt;p&gt;
     * Allows you to defer execution of passed function until SingleObserver subscribes to the {@link Single}.
     * It makes passed function &quot;lazy&quot;.
     * Result of the function invocation will be emitted by the {@link Single}.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;467&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.fromCallable.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *   &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *   &lt;dd&gt;{@code fromCallable} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     *   &lt;dt&gt;&lt;b&gt;Error handling:&lt;/b&gt;&lt;/dt&gt;
     *   &lt;dd&gt; If the {@link Callable} throws an exception, the respective {@link Throwable} is
     *   delivered to the downstream via {@link SingleObserver#onError(Throwable)},
     *   except when the downstream has disposed this {@code Single} source.
     *   In this latter case, the {@code Throwable} is delivered to the global error handler via
     *   {@link RxJavaPlugins#onError(Throwable)} as an {@link io.reactivex.exceptions.UndeliverableException UndeliverableException}.
     *   &lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param callable
     *         function which execution should be deferred, it will be invoked when SingleObserver will subscribe to the {@link Single}.
     * @param &lt;T&gt;
     *         the type of the item emitted by the {@link Single}.
     * @return a {@link Single} whose {@link SingleObserver}s' subscriptions trigger an invocation of the given function.
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Single&lt;T&gt; fromCallable(final Callable&lt;? extends T&gt; callable) {
<span class="fc" id="L621">        ObjectHelper.requireNonNull(callable, &quot;callable is null&quot;);</span>
<span class="fc" id="L622">        return RxJavaPlugins.onAssembly(new SingleFromCallable&lt;T&gt;(callable));</span>
    }

    /**
     * Converts a {@link Future} into a {@code Single}.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;315&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.from.Future.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * You can convert any object that supports the {@link Future} interface into a Single that emits the return
     * value of the {@link Future#get} method of that object, by passing the object into the {@code from}
     * method.
     * &lt;p&gt;
     * &lt;em&gt;Important note:&lt;/em&gt; This Single is blocking; you cannot dispose it.
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code fromFuture} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param future
     *            the source {@link Future}
     * @param &lt;T&gt;
     *            the type of object that the {@link Future} returns, and also the type of item to be emitted by
     *            the resulting {@code Single}
     * @return a {@code Single} that emits the item from the source {@link Future}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/from.html&quot;&gt;ReactiveX operators documentation: From&lt;/a&gt;
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Single&lt;T&gt; fromFuture(Future&lt;? extends T&gt; future) {
<span class="fc" id="L651">        return toSingle(Flowable.&lt;T&gt;fromFuture(future));</span>
    }

    /**
     * Converts a {@link Future} into a {@code Single}, with a timeout on the Future.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;315&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.from.Future.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * You can convert any object that supports the {@link Future} interface into a {@code Single} that emits
     * the return value of the {@link Future#get} method of that object, by passing the object into the
     * {@code from} method.
     * &lt;p&gt;
     * &lt;em&gt;Important note:&lt;/em&gt; This {@code Single} is blocking; you cannot dispose it.
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code fromFuture} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param future
     *            the source {@link Future}
     * @param timeout
     *            the maximum time to wait before calling {@code get}
     * @param unit
     *            the {@link TimeUnit} of the {@code timeout} argument
     * @param &lt;T&gt;
     *            the type of object that the {@link Future} returns, and also the type of item to be emitted by
     *            the resulting {@code Single}
     * @return a {@code Single} that emits the item from the source {@link Future}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/from.html&quot;&gt;ReactiveX operators documentation: From&lt;/a&gt;
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Single&lt;T&gt; fromFuture(Future&lt;? extends T&gt; future, long timeout, TimeUnit unit) {
<span class="fc" id="L684">        return toSingle(Flowable.&lt;T&gt;fromFuture(future, timeout, unit));</span>
    }

    /**
     * Converts a {@link Future} into a {@code Single}, with a timeout on the Future.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;315&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.from.Future.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * You can convert any object that supports the {@link Future} interface into a {@code Single} that emits
     * the return value of the {@link Future#get} method of that object, by passing the object into the
     * {@code from} method.
     * &lt;p&gt;
     * &lt;em&gt;Important note:&lt;/em&gt; This {@code Single} is blocking; you cannot dispose it.
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;You specify the {@link Scheduler} where the blocking wait will happen.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param future
     *            the source {@link Future}
     * @param timeout
     *            the maximum time to wait before calling {@code get}
     * @param unit
     *            the {@link TimeUnit} of the {@code timeout} argument
     * @param scheduler
     *            the Scheduler to use for the blocking wait
     * @param &lt;T&gt;
     *            the type of object that the {@link Future} returns, and also the type of item to be emitted by
     *            the resulting {@code Single}
     * @return a {@code Single} that emits the item from the source {@link Future}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/from.html&quot;&gt;ReactiveX operators documentation: From&lt;/a&gt;
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public static &lt;T&gt; Single&lt;T&gt; fromFuture(Future&lt;? extends T&gt; future, long timeout, TimeUnit unit, Scheduler scheduler) {
<span class="fc" id="L719">        return toSingle(Flowable.&lt;T&gt;fromFuture(future, timeout, unit, scheduler));</span>
    }

    /**
     * Converts a {@link Future}, operating on a specified {@link Scheduler}, into a {@code Single}.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;315&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.from.Future.s.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * You can convert any object that supports the {@link Future} interface into a {@code Single} that emits
     * the return value of the {@link Future#get} method of that object, by passing the object into the
     * {@code from} method.
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;You specify which {@link Scheduler} this operator will use.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param future
     *            the source {@link Future}
     * @param scheduler
     *            the {@link Scheduler} to wait for the Future on. Use a Scheduler such as
     *            {@link Schedulers#io()} that can block and wait on the Future
     * @param &lt;T&gt;
     *            the type of object that the {@link Future} returns, and also the type of item to be emitted by
     *            the resulting {@code Single}
     * @return a {@code Single} that emits the item from the source {@link Future}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/from.html&quot;&gt;ReactiveX operators documentation: From&lt;/a&gt;
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public static &lt;T&gt; Single&lt;T&gt; fromFuture(Future&lt;? extends T&gt; future, Scheduler scheduler) {
<span class="fc" id="L749">        return toSingle(Flowable.&lt;T&gt;fromFuture(future, scheduler));</span>
    }

    /**
     * Wraps a specific Publisher into a Single and signals its single element or error.
     * &lt;p&gt;If the source Publisher is empty, a NoSuchElementException is signalled. If
     * the source has more than one element, an IndexOutOfBoundsException is signalled.
     * &lt;p&gt;
     * The {@link Publisher} must follow the
     * &lt;a href=&quot;https://github.com/reactive-streams/reactive-streams-jvm#reactive-streams&quot;&gt;Reactive-Streams specification&lt;/a&gt;.
     * Violating the specification may result in undefined behavior.
     * &lt;p&gt;
     * If possible, use {@link #create(SingleOnSubscribe)} to create a
     * source-like {@code Single} instead.
     * &lt;p&gt;
     * Note that even though {@link Publisher} appears to be a functional interface, it
     * is not recommended to implement it through a lambda as the specification requires
     * state management that is not achievable with a stateless lambda.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;322&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.fromPublisher.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;The {@code publisher} is consumed in an unbounded fashion but will be cancelled
     * if it produced more than one item.&lt;/dd&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code fromPublisher} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;T&gt; the value type
     * @param publisher the source Publisher instance, not null
     * @return the new Single instance
     * @see #create(SingleOnSubscribe)
     */
    @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Single&lt;T&gt; fromPublisher(final Publisher&lt;? extends T&gt; publisher) {
<span class="fc" id="L786">        ObjectHelper.requireNonNull(publisher, &quot;publisher is null&quot;);</span>
<span class="fc" id="L787">        return RxJavaPlugins.onAssembly(new SingleFromPublisher&lt;T&gt;(publisher));</span>
    }

    /**
     * Wraps a specific ObservableSource into a Single and signals its single element or error.
     * &lt;p&gt;If the ObservableSource is empty, a NoSuchElementException is signalled.
     * If the source has more than one element, an IndexOutOfBoundsException is signalled.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;343&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.fromObservable.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *   &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *   &lt;dd&gt;{@code fromObservable} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param observableSource the source Observable, not null
     * @param &lt;T&gt;
     *         the type of the item emitted by the {@link Single}.
     * @return the new Single instance
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Single&lt;T&gt; fromObservable(ObservableSource&lt;? extends T&gt; observableSource) {
<span class="fc" id="L810">        ObjectHelper.requireNonNull(observableSource, &quot;observableSource is null&quot;);</span>
<span class="fc" id="L811">        return RxJavaPlugins.onAssembly(new ObservableSingleSingle&lt;T&gt;(observableSource, null));</span>
    }

    /**
     * Returns a {@code Single} that emits a specified item.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;310&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.just.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * To convert any object into a {@code Single} that emits that object, pass that object into the
     * {@code just} method.
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code just} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param item
     *            the item to emit
     * @param &lt;T&gt;
     *            the type of that item
     * @return a {@code Single} that emits {@code item}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/just.html&quot;&gt;ReactiveX operators documentation: Just&lt;/a&gt;
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    @NonNull
    public static &lt;T&gt; Single&lt;T&gt; just(final T item) {
<span class="fc" id="L837">        ObjectHelper.requireNonNull(item, &quot;item is null&quot;);</span>
<span class="fc" id="L838">        return RxJavaPlugins.onAssembly(new SingleJust&lt;T&gt;(item));</span>
    }

    /**
     * Merges an Iterable sequence of SingleSource instances into a single Flowable sequence,
     * running all SingleSources at once.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;319&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.merge.i.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The returned {@code Flowable} honors the backpressure of the downstream consumer.&lt;/dd&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code merge} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Error handling:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;If any of the source {@code SingleSource}s signal a {@code Throwable} via {@code onError}, the resulting
     *  {@code Flowable} terminates with that {@code Throwable} and all other source {@code SingleSource}s are disposed.
     *  If more than one {@code SingleSource} signals an error, the resulting {@code Flowable} may terminate with the
     *  first one's error or, depending on the concurrency of the sources, may terminate with a
     *  {@code CompositeException} containing two or more of the various error signals.
     *  {@code Throwable}s that didn't make into the composite will be sent (individually) to the global error handler via
     *  {@link RxJavaPlugins#onError(Throwable)} method as {@code UndeliverableException} errors. Similarly, {@code Throwable}s
     *  signaled by source(s) after the returned {@code Flowable} has been cancelled or terminated with a
     *  (composite) error will be sent to the same global error handler.
     *  Use {@link #mergeDelayError(Iterable)} to merge sources and terminate only when all source {@code SingleSource}s
     *  have completed or failed with an error.
     *  &lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;T&gt; the common and resulting value type
     * @param sources the Iterable sequence of SingleSource sources
     * @return the new Flowable instance
     * @since 2.0
     * @see #mergeDelayError(Iterable)
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Flowable&lt;T&gt; merge(Iterable&lt;? extends SingleSource&lt;? extends T&gt;&gt; sources) {
<span class="fc" id="L876">        return merge(Flowable.fromIterable(sources));</span>
    }

    /**
     * Merges a Flowable sequence of SingleSource instances into a single Flowable sequence,
     * running all SingleSources at once.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;307&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.merge.p.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The returned {@code Flowable} honors the backpressure of the downstream consumer.&lt;/dd&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code merge} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Error handling:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;If any of the source {@code SingleSource}s signal a {@code Throwable} via {@code onError}, the resulting
     *  {@code Flowable} terminates with that {@code Throwable} and all other source {@code SingleSource}s are disposed.
     *  If more than one {@code SingleSource} signals an error, the resulting {@code Flowable} may terminate with the
     *  first one's error or, depending on the concurrency of the sources, may terminate with a
     *  {@code CompositeException} containing two or more of the various error signals.
     *  {@code Throwable}s that didn't make into the composite will be sent (individually) to the global error handler via
     *  {@link RxJavaPlugins#onError(Throwable)} method as {@code UndeliverableException} errors. Similarly, {@code Throwable}s
     *  signaled by source(s) after the returned {@code Flowable} has been cancelled or terminated with a
     *  (composite) error will be sent to the same global error handler.
     *  Use {@link #mergeDelayError(Publisher)} to merge sources and terminate only when all source {@code SingleSource}s
     *  have completed or failed with an error.
     *  &lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;T&gt; the common and resulting value type
     * @param sources the Flowable sequence of SingleSource sources
     * @return the new Flowable instance
     * @see #mergeDelayError(Publisher)
     * @since 2.0
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    @SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
    public static &lt;T&gt; Flowable&lt;T&gt; merge(Publisher&lt;? extends SingleSource&lt;? extends T&gt;&gt; sources) {
<span class="fc" id="L915">        ObjectHelper.requireNonNull(sources, &quot;sources is null&quot;);</span>
<span class="fc" id="L916">        return RxJavaPlugins.onAssembly(new FlowableFlatMapPublisher(sources, SingleInternalHelper.toFlowable(), false, Integer.MAX_VALUE, Flowable.bufferSize()));</span>
    }

    /**
     * Flattens a {@code Single} that emits a {@code Single} into a single {@code Single} that emits the item
     * emitted by the nested {@code Single}, without any transformation.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;412&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.merge.oo.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code merge} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;dd&gt;The resulting {@code Single} emits the outer source's or the inner {@code SingleSource}'s {@code Throwable} as is.
     * Unlike the other {@code merge()} operators, this operator won't and can't produce a {@code CompositeException} because there is
     * only one possibility for the outer or the inner {@code SingleSource} to emit an {@code onError} signal.
     * Therefore, there is no need for a {@code mergeDelayError(SingleSource&lt;SingleSource&lt;T&gt;&gt;)} operator.
     * &lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T&gt; the value type of the sources and the output
     * @param source
     *            a {@code Single} that emits a {@code Single}
     * @return a {@code Single} that emits the item that is the result of flattening the {@code Single} emitted
     *         by {@code source}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/merge.html&quot;&gt;ReactiveX operators documentation: Merge&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    @SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
    public static &lt;T&gt; Single&lt;T&gt; merge(SingleSource&lt;? extends SingleSource&lt;? extends T&gt;&gt; source) {
<span class="fc" id="L946">        ObjectHelper.requireNonNull(source, &quot;source is null&quot;);</span>
<span class="fc" id="L947">        return RxJavaPlugins.onAssembly(new SingleFlatMap&lt;SingleSource&lt;? extends T&gt;, T&gt;(source, (Function)Functions.identity()));</span>
    }

    /**
     * Flattens two Singles into a single Flowable, without any transformation.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;414&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.merge.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * You can combine items emitted by multiple Singles so that they appear as a single Flowable, by
     * using the {@code merge} method.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The returned {@code Flowable} honors the backpressure of the downstream consumer.&lt;/dd&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code merge} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Error handling:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;If any of the source {@code SingleSource}s signal a {@code Throwable} via {@code onError}, the resulting
     *  {@code Flowable} terminates with that {@code Throwable} and all other source {@code SingleSource}s are disposed.
     *  If more than one {@code SingleSource} signals an error, the resulting {@code Flowable} may terminate with the
     *  first one's error or, depending on the concurrency of the sources, may terminate with a
     *  {@code CompositeException} containing two or more of the various error signals.
     *  {@code Throwable}s that didn't make into the composite will be sent (individually) to the global error handler via
     *  {@link RxJavaPlugins#onError(Throwable)} method as {@code UndeliverableException} errors. Similarly, {@code Throwable}s
     *  signaled by source(s) after the returned {@code Flowable} has been cancelled or terminated with a
     *  (composite) error will be sent to the same global error handler.
     *  Use {@link #mergeDelayError(SingleSource, SingleSource)} to merge sources and terminate only when all source {@code SingleSource}s
     *  have completed or failed with an error.
     *  &lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T&gt; the common value type
     * @param source1
     *            a SingleSource to be merged
     * @param source2
     *            a SingleSource to be merged
     * @return a Flowable that emits all of the items emitted by the source Singles
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/merge.html&quot;&gt;ReactiveX operators documentation: Merge&lt;/a&gt;
     * @see #mergeDelayError(SingleSource, SingleSource)
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; Flowable&lt;T&gt; merge(
            SingleSource&lt;? extends T&gt; source1, SingleSource&lt;? extends T&gt; source2
     ) {
<span class="fc" id="L994">        ObjectHelper.requireNonNull(source1, &quot;source1 is null&quot;);</span>
<span class="fc" id="L995">        ObjectHelper.requireNonNull(source2, &quot;source2 is null&quot;);</span>
<span class="fc" id="L996">        return merge(Flowable.fromArray(source1, source2));</span>
    }

    /**
     * Flattens three Singles into a single Flowable, without any transformation.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;366&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.merge.o3.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * You can combine items emitted by multiple Singles so that they appear as a single Flowable, by using
     * the {@code merge} method.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The returned {@code Flowable} honors the backpressure of the downstream consumer.&lt;/dd&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code merge} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Error handling:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;If any of the source {@code SingleSource}s signal a {@code Throwable} via {@code onError}, the resulting
     *  {@code Flowable} terminates with that {@code Throwable} and all other source {@code SingleSource}s are disposed.
     *  If more than one {@code SingleSource} signals an error, the resulting {@code Flowable} may terminate with the
     *  first one's error or, depending on the concurrency of the sources, may terminate with a
     *  {@code CompositeException} containing two or more of the various error signals.
     *  {@code Throwable}s that didn't make into the composite will be sent (individually) to the global error handler via
     *  {@link RxJavaPlugins#onError(Throwable)} method as {@code UndeliverableException} errors. Similarly, {@code Throwable}s
     *  signaled by source(s) after the returned {@code Flowable} has been cancelled or terminated with a
     *  (composite) error will be sent to the same global error handler.
     *  Use {@link #mergeDelayError(SingleSource, SingleSource, SingleSource)} to merge sources and terminate only when all source {@code SingleSource}s
     *  have completed or failed with an error.
     *  &lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T&gt; the common value type
     * @param source1
     *            a SingleSource to be merged
     * @param source2
     *            a SingleSource to be merged
     * @param source3
     *            a SingleSource to be merged
     * @return a Flowable that emits all of the items emitted by the source Singles
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/merge.html&quot;&gt;ReactiveX operators documentation: Merge&lt;/a&gt;
     * @see #mergeDelayError(SingleSource, SingleSource, SingleSource)
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; Flowable&lt;T&gt; merge(
            SingleSource&lt;? extends T&gt; source1, SingleSource&lt;? extends T&gt; source2,
            SingleSource&lt;? extends T&gt; source3
     ) {
<span class="fc" id="L1046">        ObjectHelper.requireNonNull(source1, &quot;source1 is null&quot;);</span>
<span class="fc" id="L1047">        ObjectHelper.requireNonNull(source2, &quot;source2 is null&quot;);</span>
<span class="fc" id="L1048">        ObjectHelper.requireNonNull(source3, &quot;source3 is null&quot;);</span>
<span class="fc" id="L1049">        return merge(Flowable.fromArray(source1, source2, source3));</span>
    }

    /**
     * Flattens four Singles into a single Flowable, without any transformation.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;362&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.merge.o4.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * You can combine items emitted by multiple Singles so that they appear as a single Flowable, by using
     * the {@code merge} method.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The returned {@code Flowable} honors the backpressure of the downstream consumer.&lt;/dd&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code merge} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Error handling:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;If any of the source {@code SingleSource}s signal a {@code Throwable} via {@code onError}, the resulting
     *  {@code Flowable} terminates with that {@code Throwable} and all other source {@code SingleSource}s are disposed.
     *  If more than one {@code SingleSource} signals an error, the resulting {@code Flowable} may terminate with the
     *  first one's error or, depending on the concurrency of the sources, may terminate with a
     *  {@code CompositeException} containing two or more of the various error signals.
     *  {@code Throwable}s that didn't make into the composite will be sent (individually) to the global error handler via
     *  {@link RxJavaPlugins#onError(Throwable)} method as {@code UndeliverableException} errors. Similarly, {@code Throwable}s
     *  signaled by source(s) after the returned {@code Flowable} has been cancelled or terminated with a
     *  (composite) error will be sent to the same global error handler.
     *  Use {@link #mergeDelayError(SingleSource, SingleSource, SingleSource, SingleSource)} to merge sources and terminate only when all source {@code SingleSource}s
     *  have completed or failed with an error.
     *  &lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T&gt; the common value type
     * @param source1
     *            a SingleSource to be merged
     * @param source2
     *            a SingleSource to be merged
     * @param source3
     *            a SingleSource to be merged
     * @param source4
     *            a SingleSource to be merged
     * @return a Flowable that emits all of the items emitted by the source Singles
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/merge.html&quot;&gt;ReactiveX operators documentation: Merge&lt;/a&gt;
     * @see #mergeDelayError(SingleSource, SingleSource, SingleSource, SingleSource)
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; Flowable&lt;T&gt; merge(
            SingleSource&lt;? extends T&gt; source1, SingleSource&lt;? extends T&gt; source2,
            SingleSource&lt;? extends T&gt; source3, SingleSource&lt;? extends T&gt; source4
     ) {
<span class="fc" id="L1101">        ObjectHelper.requireNonNull(source1, &quot;source1 is null&quot;);</span>
<span class="fc" id="L1102">        ObjectHelper.requireNonNull(source2, &quot;source2 is null&quot;);</span>
<span class="fc" id="L1103">        ObjectHelper.requireNonNull(source3, &quot;source3 is null&quot;);</span>
<span class="fc" id="L1104">        ObjectHelper.requireNonNull(source4, &quot;source4 is null&quot;);</span>
<span class="fc" id="L1105">        return merge(Flowable.fromArray(source1, source2, source3, source4));</span>
    }

    /**
     * Merges an Iterable sequence of SingleSource instances into a single Flowable sequence,
     * running all SingleSources at once and delaying any error(s) until all sources succeed or fail.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The returned {@code Flowable} honors the backpressure of the downstream consumer.&lt;/dd&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code mergeDelayError} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * &lt;p&gt;History: 2.1.9 - experimental
     * @param &lt;T&gt; the common and resulting value type
     * @param sources the Iterable sequence of SingleSource sources
     * @return the new Flowable instance
     * @see #merge(Iterable)
     * @since 2.2
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Flowable&lt;T&gt; mergeDelayError(Iterable&lt;? extends SingleSource&lt;? extends T&gt;&gt; sources) {
<span class="fc" id="L1129">        return mergeDelayError(Flowable.fromIterable(sources));</span>
    }

    /**
     * Merges a Flowable sequence of SingleSource instances into a single Flowable sequence,
     * running all SingleSources at once and delaying any error(s) until all sources succeed or fail.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The returned {@code Flowable} honors the backpressure of the downstream consumer.&lt;/dd&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code mergeDelayError} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * &lt;p&gt;History: 2.1.9 - experimental
     * @param &lt;T&gt; the common and resulting value type
     * @param sources the Flowable sequence of SingleSource sources
     * @return the new Flowable instance
     * @see #merge(Publisher)
     * @since 2.2
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    @SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
    public static &lt;T&gt; Flowable&lt;T&gt; mergeDelayError(Publisher&lt;? extends SingleSource&lt;? extends T&gt;&gt; sources) {
<span class="fc" id="L1154">        ObjectHelper.requireNonNull(sources, &quot;sources is null&quot;);</span>
<span class="fc" id="L1155">        return RxJavaPlugins.onAssembly(new FlowableFlatMapPublisher(sources, SingleInternalHelper.toFlowable(), true, Integer.MAX_VALUE, Flowable.bufferSize()));</span>
    }

    /**
     * Flattens two Singles into a single Flowable, without any transformation, delaying
     * any error(s) until all sources succeed or fail.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.merge.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * You can combine items emitted by multiple Singles so that they appear as a single Flowable, by
     * using the {@code mergeDelayError} method.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The returned {@code Flowable} honors the backpressure of the downstream consumer.&lt;/dd&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code mergeDelayError} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * &lt;p&gt;History: 2.1.9 - experimental
     * @param &lt;T&gt; the common value type
     * @param source1
     *            a SingleSource to be merged
     * @param source2
     *            a SingleSource to be merged
     * @return a Flowable that emits all of the items emitted by the source Singles
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/merge.html&quot;&gt;ReactiveX operators documentation: Merge&lt;/a&gt;
     * @see #merge(SingleSource, SingleSource)
     * @since 2.2
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; Flowable&lt;T&gt; mergeDelayError(
            SingleSource&lt;? extends T&gt; source1, SingleSource&lt;? extends T&gt; source2
     ) {
<span class="fc" id="L1191">        ObjectHelper.requireNonNull(source1, &quot;source1 is null&quot;);</span>
<span class="fc" id="L1192">        ObjectHelper.requireNonNull(source2, &quot;source2 is null&quot;);</span>
<span class="fc" id="L1193">        return mergeDelayError(Flowable.fromArray(source1, source2));</span>
    }

    /**
     * Flattens three Singles into a single Flowable, without any transformation, delaying
     * any error(s) until all sources succeed or fail.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.merge.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * You can combine items emitted by multiple Singles so that they appear as a single Flowable, by using
     * the {@code mergeDelayError} method.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The returned {@code Flowable} honors the backpressure of the downstream consumer.&lt;/dd&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code mergeDelayError} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * &lt;p&gt;History: 2.1.9 - experimental
     * @param &lt;T&gt; the common value type
     * @param source1
     *            a SingleSource to be merged
     * @param source2
     *            a SingleSource to be merged
     * @param source3
     *            a SingleSource to be merged
     * @return a Flowable that emits all of the items emitted by the source Singles
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/merge.html&quot;&gt;ReactiveX operators documentation: Merge&lt;/a&gt;
     * @see #merge(SingleSource, SingleSource, SingleSource)
     * @since 2.2
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; Flowable&lt;T&gt; mergeDelayError(
            SingleSource&lt;? extends T&gt; source1, SingleSource&lt;? extends T&gt; source2,
            SingleSource&lt;? extends T&gt; source3
     ) {
<span class="fc" id="L1232">        ObjectHelper.requireNonNull(source1, &quot;source1 is null&quot;);</span>
<span class="fc" id="L1233">        ObjectHelper.requireNonNull(source2, &quot;source2 is null&quot;);</span>
<span class="fc" id="L1234">        ObjectHelper.requireNonNull(source3, &quot;source3 is null&quot;);</span>
<span class="fc" id="L1235">        return mergeDelayError(Flowable.fromArray(source1, source2, source3));</span>
    }

    /**
     * Flattens four Singles into a single Flowable, without any transformation, delaying
     * any error(s) until all sources succeed or fail.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.merge.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * You can combine items emitted by multiple Singles so that they appear as a single Flowable, by using
     * the {@code mergeDelayError} method.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The returned {@code Flowable} honors the backpressure of the downstream consumer.&lt;/dd&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code mergeDelayError} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * &lt;p&gt;History: 2.1.9 - experimental
     * @param &lt;T&gt; the common value type
     * @param source1
     *            a SingleSource to be merged
     * @param source2
     *            a SingleSource to be merged
     * @param source3
     *            a SingleSource to be merged
     * @param source4
     *            a SingleSource to be merged
     * @return a Flowable that emits all of the items emitted by the source Singles
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/merge.html&quot;&gt;ReactiveX operators documentation: Merge&lt;/a&gt;
     * @see #merge(SingleSource, SingleSource, SingleSource, SingleSource)
     * @since 2.2
     */
    @CheckReturnValue
    @NonNull
    @BackpressureSupport(BackpressureKind.FULL)
    @SchedulerSupport(SchedulerSupport.NONE)
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; Flowable&lt;T&gt; mergeDelayError(
            SingleSource&lt;? extends T&gt; source1, SingleSource&lt;? extends T&gt; source2,
            SingleSource&lt;? extends T&gt; source3, SingleSource&lt;? extends T&gt; source4
     ) {
<span class="fc" id="L1276">        ObjectHelper.requireNonNull(source1, &quot;source1 is null&quot;);</span>
<span class="fc" id="L1277">        ObjectHelper.requireNonNull(source2, &quot;source2 is null&quot;);</span>
<span class="fc" id="L1278">        ObjectHelper.requireNonNull(source3, &quot;source3 is null&quot;);</span>
<span class="fc" id="L1279">        ObjectHelper.requireNonNull(source4, &quot;source4 is null&quot;);</span>
<span class="fc" id="L1280">        return mergeDelayError(Flowable.fromArray(source1, source2, source3, source4));</span>
    }

    /**
     * Returns a singleton instance of a never-signalling Single (only calls onSubscribe).
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;244&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.never.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code never} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;T&gt; the target value type
     * @return the singleton never instance
     * @since 2.0
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; Single&lt;T&gt; never() {
<span class="fc" id="L1299">        return RxJavaPlugins.onAssembly((Single&lt;T&gt;) SingleNever.INSTANCE);</span>
    }

    /**
     * Signals success with 0L value after the given delay for each SingleObserver.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;292&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.timer.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code timer} operates by default on the {@code computation} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param delay the delay amount
     * @param unit the time unit of the delay
     * @return the new Single instance
     * @since 2.0
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.COMPUTATION)
    public static Single&lt;Long&gt; timer(long delay, TimeUnit unit) {
<span class="fc" id="L1318">        return timer(delay, unit, Schedulers.computation());</span>
    }

    /**
     * Signals success with 0L value after the given delay for each SingleObserver.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;292&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.timer.s.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;you specify the {@link Scheduler} to signal on.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param delay the delay amount
     * @param unit the time unit of the delay
     * @param scheduler the scheduler where the single 0L will be emitted
     * @return the new Single instance
     * @throws NullPointerException
     *             if unit is null, or
     *             if scheduler is null
     * @since 2.0
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public static Single&lt;Long&gt; timer(final long delay, final TimeUnit unit, final Scheduler scheduler) {
<span class="fc" id="L1342">        ObjectHelper.requireNonNull(unit, &quot;unit is null&quot;);</span>
<span class="fc" id="L1343">        ObjectHelper.requireNonNull(scheduler, &quot;scheduler is null&quot;);</span>
<span class="fc" id="L1344">        return RxJavaPlugins.onAssembly(new SingleTimer(delay, unit, scheduler));</span>
    }

    /**
     * Compares two SingleSources and emits true if they emit the same value (compared via Object.equals).
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;465&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.equals.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code equals} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;T&gt; the common value type
     * @param first the first SingleSource instance
     * @param second the second SingleSource instance
     * @return the new Single instance
     * @since 2.0
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Single&lt;Boolean&gt; equals(final SingleSource&lt;? extends T&gt; first, final SingleSource&lt;? extends T&gt; second) { // NOPMD
<span class="fc" id="L1365">        ObjectHelper.requireNonNull(first, &quot;first is null&quot;);</span>
<span class="fc" id="L1366">        ObjectHelper.requireNonNull(second, &quot;second is null&quot;);</span>
<span class="fc" id="L1367">        return RxJavaPlugins.onAssembly(new SingleEquals&lt;T&gt;(first, second));</span>
    }

    /**
     * &lt;strong&gt;Advanced use only:&lt;/strong&gt; creates a Single instance without
     * any safeguards by using a callback that is called with a SingleObserver.
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code unsafeCreate} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;T&gt; the value type
     * @param onSubscribe the function that is called with the subscribing SingleObserver
     * @return the new Single instance
     * @throws IllegalArgumentException if {@code source} is a subclass of {@code Single}; such
     * instances don't need conversion and is possibly a port remnant from 1.x or one should use {@link #hide()}
     * instead.
     * @since 2.0
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Single&lt;T&gt; unsafeCreate(SingleSource&lt;T&gt; onSubscribe) {
<span class="fc" id="L1389">        ObjectHelper.requireNonNull(onSubscribe, &quot;onSubscribe is null&quot;);</span>
<span class="fc bfc" id="L1390" title="All 2 branches covered.">        if (onSubscribe instanceof Single) {</span>
<span class="fc" id="L1391">            throw new IllegalArgumentException(&quot;unsafeCreate(Single) should be upgraded&quot;);</span>
        }
<span class="fc" id="L1393">        return RxJavaPlugins.onAssembly(new SingleFromUnsafeSource&lt;T&gt;(onSubscribe));</span>
    }

    /**
     * Allows using and disposing a resource while running a SingleSource instance generated from
     * that resource (similar to a try-with-resources).
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code using} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;T&gt; the value type of the SingleSource generated
     * @param &lt;U&gt; the resource type
     * @param resourceSupplier the Callable called for each SingleObserver to generate a resource Object
     * @param singleFunction the function called with the returned resource
     *                  Object from {@code resourceSupplier} and should return a SingleSource instance
     *                  to be run by the operator
     * @param disposer the consumer of the generated resource that is called exactly once for
     *                  that particular resource when the generated SingleSource terminates
     *                  (successfully or with an error) or gets disposed.
     * @return the new Single instance
     * @since 2.0
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T, U&gt; Single&lt;T&gt; using(Callable&lt;U&gt; resourceSupplier,
                                         Function&lt;? super U, ? extends SingleSource&lt;? extends T&gt;&gt; singleFunction,
                                         Consumer&lt;? super U&gt; disposer) {
<span class="fc" id="L1420">        return using(resourceSupplier, singleFunction, disposer, true);</span>
    }

    /**
     * Allows using and disposing a resource while running a SingleSource instance generated from
     * that resource (similar to a try-with-resources).
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code using} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;T&gt; the value type of the SingleSource generated
     * @param &lt;U&gt; the resource type
     * @param resourceSupplier the Callable called for each SingleObserver to generate a resource Object
     * @param singleFunction the function called with the returned resource
     *                  Object from {@code resourceSupplier} and should return a SingleSource instance
     *                  to be run by the operator
     * @param disposer the consumer of the generated resource that is called exactly once for
     *                  that particular resource when the generated SingleSource terminates
     *                  (successfully or with an error) or gets disposed.
     * @param eager
     *                 if true, the disposer is called before the terminal event is signalled
     *                 if false, the disposer is called after the terminal event is delivered to downstream
     * @return the new Single instance
     * @since 2.0
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T, U&gt; Single&lt;T&gt; using(
            final Callable&lt;U&gt; resourceSupplier,
            final Function&lt;? super U, ? extends SingleSource&lt;? extends T&gt;&gt; singleFunction,
            final Consumer&lt;? super U&gt; disposer,
            final boolean eager) {
<span class="fc" id="L1453">        ObjectHelper.requireNonNull(resourceSupplier, &quot;resourceSupplier is null&quot;);</span>
<span class="fc" id="L1454">        ObjectHelper.requireNonNull(singleFunction, &quot;singleFunction is null&quot;);</span>
<span class="fc" id="L1455">        ObjectHelper.requireNonNull(disposer, &quot;disposer is null&quot;);</span>

<span class="fc" id="L1457">        return RxJavaPlugins.onAssembly(new SingleUsing&lt;T, U&gt;(resourceSupplier, singleFunction, disposer, eager));</span>
    }

    /**
     * Wraps a SingleSource instance into a new Single instance if not already a Single
     * instance.
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code wrap} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;T&gt; the value type
     * @param source the source to wrap
     * @return the Single wrapper or the source cast to Single (if possible)
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T&gt; Single&lt;T&gt; wrap(SingleSource&lt;T&gt; source) {
<span class="fc" id="L1475">        ObjectHelper.requireNonNull(source, &quot;source is null&quot;);</span>
<span class="fc bfc" id="L1476" title="All 2 branches covered.">        if (source instanceof Single) {</span>
<span class="fc" id="L1477">            return RxJavaPlugins.onAssembly((Single&lt;T&gt;)source);</span>
        }
<span class="fc" id="L1479">        return RxJavaPlugins.onAssembly(new SingleFromUnsafeSource&lt;T&gt;(source));</span>
    }

    /**
     * Waits until all SingleSource sources provided by the Iterable sequence signal a success
     * value and calls a zipper function with an array of these values to return a result
     * to be emitted to downstream.
     * &lt;p&gt;
     * If the {@code Iterable} of {@link SingleSource}s is empty a {@link NoSuchElementException} error is signalled after subscription.
     * &lt;p&gt;
     * Note on method signature: since Java doesn't allow creating a generic array with {@code new T[]}, the
     * implementation of this operator has to create an {@code Object[]} instead. Unfortunately, a
     * {@code Function&lt;Integer[], R&gt;} passed to the method would trigger a {@code ClassCastException}.
     *
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/zip.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * If any of the SingleSources signal an error, all other SingleSources get disposed and the
     * error emitted to downstream immediately.
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code zip} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;T&gt; the common value type
     * @param &lt;R&gt; the result value type
     * @param sources the Iterable sequence of SingleSource instances. An empty sequence will result in an
     *                {@code onError} signal of {@link NoSuchElementException}.
     * @param zipper the function that receives an array with values from each SingleSource
     *               and should return a value to be emitted to downstream
     * @return the new Single instance
     * @since 2.0
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T, R&gt; Single&lt;R&gt; zip(final Iterable&lt;? extends SingleSource&lt;? extends T&gt;&gt; sources, Function&lt;? super Object[], ? extends R&gt; zipper) {
<span class="fc" id="L1515">        ObjectHelper.requireNonNull(zipper, &quot;zipper is null&quot;);</span>
<span class="fc" id="L1516">        ObjectHelper.requireNonNull(sources, &quot;sources is null&quot;);</span>
<span class="fc" id="L1517">        return RxJavaPlugins.onAssembly(new SingleZipIterable&lt;T, R&gt;(sources, zipper));</span>
    }

    /**
     * Returns a Single that emits the results of a specified combiner function applied to two items emitted by
     * two other Singles.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.zip.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code zip} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T1&gt; the first source Single's value type
     * @param &lt;T2&gt; the second source Single's value type
     * @param &lt;R&gt; the result value type
     * @param source1
     *            the first source Single
     * @param source2
     *            a second source Single
     * @param zipper
     *            a function that, when applied to the item emitted by each of the source Singles, results in an
     *            item that will be emitted by the resulting Single
     * @return a Single that emits the zipped results
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/zip.html&quot;&gt;ReactiveX operators documentation: Zip&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T1, T2, R&gt; Single&lt;R&gt; zip(
            SingleSource&lt;? extends T1&gt; source1, SingleSource&lt;? extends T2&gt; source2,
            BiFunction&lt;? super T1, ? super T2, ? extends R&gt; zipper
     ) {
<span class="fc" id="L1551">        ObjectHelper.requireNonNull(source1, &quot;source1 is null&quot;);</span>
<span class="fc" id="L1552">        ObjectHelper.requireNonNull(source2, &quot;source2 is null&quot;);</span>
<span class="fc" id="L1553">        return zipArray(Functions.toFunction(zipper), source1, source2);</span>
    }

    /**
     * Returns a Single that emits the results of a specified combiner function applied to three items emitted
     * by three other Singles.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.zip.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code zip} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T1&gt; the first source Single's value type
     * @param &lt;T2&gt; the second source Single's value type
     * @param &lt;T3&gt; the third source Single's value type
     * @param &lt;R&gt; the result value type
     * @param source1
     *            the first source Single
     * @param source2
     *            a second source Single
     * @param source3
     *            a third source Single
     * @param zipper
     *            a function that, when applied to the item emitted by each of the source Singles, results in an
     *            item that will be emitted by the resulting Single
     * @return a Single that emits the zipped results
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/zip.html&quot;&gt;ReactiveX operators documentation: Zip&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T1, T2, T3, R&gt; Single&lt;R&gt; zip(
            SingleSource&lt;? extends T1&gt; source1, SingleSource&lt;? extends T2&gt; source2,
            SingleSource&lt;? extends T3&gt; source3,
            Function3&lt;? super T1, ? super T2, ? super T3, ? extends R&gt; zipper
     ) {
<span class="fc" id="L1591">        ObjectHelper.requireNonNull(source1, &quot;source1 is null&quot;);</span>
<span class="fc" id="L1592">        ObjectHelper.requireNonNull(source2, &quot;source2 is null&quot;);</span>
<span class="fc" id="L1593">        ObjectHelper.requireNonNull(source3, &quot;source3 is null&quot;);</span>
<span class="fc" id="L1594">        return zipArray(Functions.toFunction(zipper), source1, source2, source3);</span>
    }

    /**
     * Returns a Single that emits the results of a specified combiner function applied to four items
     * emitted by four other Singles.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.zip.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code zip} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T1&gt; the first source Single's value type
     * @param &lt;T2&gt; the second source Single's value type
     * @param &lt;T3&gt; the third source Single's value type
     * @param &lt;T4&gt; the fourth source Single's value type
     * @param &lt;R&gt; the result value type
     * @param source1
     *            the first source Single
     * @param source2
     *            a second source Single
     * @param source3
     *            a third source Single
     * @param source4
     *            a fourth source Single
     * @param zipper
     *            a function that, when applied to the item emitted by each of the source Singles, results in an
     *            item that will be emitted by the resulting Single
     * @return a Single that emits the zipped results
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/zip.html&quot;&gt;ReactiveX operators documentation: Zip&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T1, T2, T3, T4, R&gt; Single&lt;R&gt; zip(
            SingleSource&lt;? extends T1&gt; source1, SingleSource&lt;? extends T2&gt; source2,
            SingleSource&lt;? extends T3&gt; source3, SingleSource&lt;? extends T4&gt; source4,
            Function4&lt;? super T1, ? super T2, ? super T3, ? super T4, ? extends R&gt; zipper
     ) {
<span class="fc" id="L1635">        ObjectHelper.requireNonNull(source1, &quot;source1 is null&quot;);</span>
<span class="fc" id="L1636">        ObjectHelper.requireNonNull(source2, &quot;source2 is null&quot;);</span>
<span class="fc" id="L1637">        ObjectHelper.requireNonNull(source3, &quot;source3 is null&quot;);</span>
<span class="fc" id="L1638">        ObjectHelper.requireNonNull(source4, &quot;source4 is null&quot;);</span>
<span class="fc" id="L1639">        return zipArray(Functions.toFunction(zipper), source1, source2, source3, source4);</span>
    }

    /**
     * Returns a Single that emits the results of a specified combiner function applied to five items
     * emitted by five other Singles.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.zip.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code zip} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T1&gt; the first source Single's value type
     * @param &lt;T2&gt; the second source Single's value type
     * @param &lt;T3&gt; the third source Single's value type
     * @param &lt;T4&gt; the fourth source Single's value type
     * @param &lt;T5&gt; the fifth source Single's value type
     * @param &lt;R&gt; the result value type
     * @param source1
     *            the first source Single
     * @param source2
     *            a second source Single
     * @param source3
     *            a third source Single
     * @param source4
     *            a fourth source Single
     * @param source5
     *            a fifth source Single
     * @param zipper
     *            a function that, when applied to the item emitted by each of the source Singles, results in an
     *            item that will be emitted by the resulting Single
     * @return a Single that emits the zipped results
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/zip.html&quot;&gt;ReactiveX operators documentation: Zip&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T1, T2, T3, T4, T5, R&gt; Single&lt;R&gt; zip(
            SingleSource&lt;? extends T1&gt; source1, SingleSource&lt;? extends T2&gt; source2,
            SingleSource&lt;? extends T3&gt; source3, SingleSource&lt;? extends T4&gt; source4,
            SingleSource&lt;? extends T5&gt; source5,
            Function5&lt;? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? extends R&gt; zipper
     ) {
<span class="fc" id="L1684">        ObjectHelper.requireNonNull(source1, &quot;source1 is null&quot;);</span>
<span class="fc" id="L1685">        ObjectHelper.requireNonNull(source2, &quot;source2 is null&quot;);</span>
<span class="fc" id="L1686">        ObjectHelper.requireNonNull(source3, &quot;source3 is null&quot;);</span>
<span class="fc" id="L1687">        ObjectHelper.requireNonNull(source4, &quot;source4 is null&quot;);</span>
<span class="fc" id="L1688">        ObjectHelper.requireNonNull(source5, &quot;source5 is null&quot;);</span>
<span class="fc" id="L1689">        return zipArray(Functions.toFunction(zipper), source1, source2, source3, source4, source5);</span>
    }

    /**
     * Returns a Single that emits the results of a specified combiner function applied to six items
     * emitted by six other Singles.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.zip.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code zip} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T1&gt; the first source Single's value type
     * @param &lt;T2&gt; the second source Single's value type
     * @param &lt;T3&gt; the third source Single's value type
     * @param &lt;T4&gt; the fourth source Single's value type
     * @param &lt;T5&gt; the fifth source Single's value type
     * @param &lt;T6&gt; the sixth source Single's value type
     * @param &lt;R&gt; the result value type
     * @param source1
     *            the first source Single
     * @param source2
     *            a second source Single
     * @param source3
     *            a third source Single
     * @param source4
     *            a fourth source Single
     * @param source5
     *            a fifth source Single
     * @param source6
     *            a sixth source Single
     * @param zipper
     *            a function that, when applied to the item emitted by each of the source Singles, results in an
     *            item that will be emitted by the resulting Single
     * @return a Single that emits the zipped results
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/zip.html&quot;&gt;ReactiveX operators documentation: Zip&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T1, T2, T3, T4, T5, T6, R&gt; Single&lt;R&gt; zip(
            SingleSource&lt;? extends T1&gt; source1, SingleSource&lt;? extends T2&gt; source2,
            SingleSource&lt;? extends T3&gt; source3, SingleSource&lt;? extends T4&gt; source4,
            SingleSource&lt;? extends T5&gt; source5, SingleSource&lt;? extends T6&gt; source6,
            Function6&lt;? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? extends R&gt; zipper
     ) {
<span class="fc" id="L1737">        ObjectHelper.requireNonNull(source1, &quot;source1 is null&quot;);</span>
<span class="fc" id="L1738">        ObjectHelper.requireNonNull(source2, &quot;source2 is null&quot;);</span>
<span class="fc" id="L1739">        ObjectHelper.requireNonNull(source3, &quot;source3 is null&quot;);</span>
<span class="fc" id="L1740">        ObjectHelper.requireNonNull(source4, &quot;source4 is null&quot;);</span>
<span class="fc" id="L1741">        ObjectHelper.requireNonNull(source5, &quot;source5 is null&quot;);</span>
<span class="fc" id="L1742">        ObjectHelper.requireNonNull(source6, &quot;source6 is null&quot;);</span>
<span class="fc" id="L1743">        return zipArray(Functions.toFunction(zipper), source1, source2, source3, source4, source5, source6);</span>
    }

    /**
     * Returns a Single that emits the results of a specified combiner function applied to seven items
     * emitted by seven other Singles.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.zip.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code zip} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T1&gt; the first source Single's value type
     * @param &lt;T2&gt; the second source Single's value type
     * @param &lt;T3&gt; the third source Single's value type
     * @param &lt;T4&gt; the fourth source Single's value type
     * @param &lt;T5&gt; the fifth source Single's value type
     * @param &lt;T6&gt; the sixth source Single's value type
     * @param &lt;T7&gt; the seventh source Single's value type
     * @param &lt;R&gt; the result value type
     * @param source1
     *            the first source Single
     * @param source2
     *            a second source Single
     * @param source3
     *            a third source Single
     * @param source4
     *            a fourth source Single
     * @param source5
     *            a fifth source Single
     * @param source6
     *            a sixth source Single
     * @param source7
     *            a seventh source Single
     * @param zipper
     *            a function that, when applied to the item emitted by each of the source Singles, results in an
     *            item that will be emitted by the resulting Single
     * @return a Single that emits the zipped results
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/zip.html&quot;&gt;ReactiveX operators documentation: Zip&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T1, T2, T3, T4, T5, T6, T7, R&gt; Single&lt;R&gt; zip(
            SingleSource&lt;? extends T1&gt; source1, SingleSource&lt;? extends T2&gt; source2,
            SingleSource&lt;? extends T3&gt; source3, SingleSource&lt;? extends T4&gt; source4,
            SingleSource&lt;? extends T5&gt; source5, SingleSource&lt;? extends T6&gt; source6,
            SingleSource&lt;? extends T7&gt; source7,
            Function7&lt;? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? extends R&gt; zipper
     ) {
<span class="fc" id="L1795">        ObjectHelper.requireNonNull(source1, &quot;source1 is null&quot;);</span>
<span class="fc" id="L1796">        ObjectHelper.requireNonNull(source2, &quot;source2 is null&quot;);</span>
<span class="fc" id="L1797">        ObjectHelper.requireNonNull(source3, &quot;source3 is null&quot;);</span>
<span class="fc" id="L1798">        ObjectHelper.requireNonNull(source4, &quot;source4 is null&quot;);</span>
<span class="fc" id="L1799">        ObjectHelper.requireNonNull(source5, &quot;source5 is null&quot;);</span>
<span class="fc" id="L1800">        ObjectHelper.requireNonNull(source6, &quot;source6 is null&quot;);</span>
<span class="fc" id="L1801">        ObjectHelper.requireNonNull(source7, &quot;source7 is null&quot;);</span>
<span class="fc" id="L1802">        return zipArray(Functions.toFunction(zipper), source1, source2, source3, source4, source5, source6, source7);</span>
    }

    /**
     * Returns a Single that emits the results of a specified combiner function applied to eight items
     * emitted by eight other Singles.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.zip.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code zip} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T1&gt; the first source Single's value type
     * @param &lt;T2&gt; the second source Single's value type
     * @param &lt;T3&gt; the third source Single's value type
     * @param &lt;T4&gt; the fourth source Single's value type
     * @param &lt;T5&gt; the fifth source Single's value type
     * @param &lt;T6&gt; the sixth source Single's value type
     * @param &lt;T7&gt; the seventh source Single's value type
     * @param &lt;T8&gt; the eighth source Single's value type
     * @param &lt;R&gt; the result value type
     * @param source1
     *            the first source Single
     * @param source2
     *            a second source Single
     * @param source3
     *            a third source Single
     * @param source4
     *            a fourth source Single
     * @param source5
     *            a fifth source Single
     * @param source6
     *            a sixth source Single
     * @param source7
     *            a seventh source Single
     * @param source8
     *            an eighth source Single
     * @param zipper
     *            a function that, when applied to the item emitted by each of the source Singles, results in an
     *            item that will be emitted by the resulting Single
     * @return a Single that emits the zipped results
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/zip.html&quot;&gt;ReactiveX operators documentation: Zip&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T1, T2, T3, T4, T5, T6, T7, T8, R&gt; Single&lt;R&gt; zip(
            SingleSource&lt;? extends T1&gt; source1, SingleSource&lt;? extends T2&gt; source2,
            SingleSource&lt;? extends T3&gt; source3, SingleSource&lt;? extends T4&gt; source4,
            SingleSource&lt;? extends T5&gt; source5, SingleSource&lt;? extends T6&gt; source6,
            SingleSource&lt;? extends T7&gt; source7, SingleSource&lt;? extends T8&gt; source8,
            Function8&lt;? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? super T8, ? extends R&gt; zipper
     ) {
<span class="fc" id="L1857">        ObjectHelper.requireNonNull(source1, &quot;source1 is null&quot;);</span>
<span class="fc" id="L1858">        ObjectHelper.requireNonNull(source2, &quot;source2 is null&quot;);</span>
<span class="fc" id="L1859">        ObjectHelper.requireNonNull(source3, &quot;source3 is null&quot;);</span>
<span class="fc" id="L1860">        ObjectHelper.requireNonNull(source4, &quot;source4 is null&quot;);</span>
<span class="fc" id="L1861">        ObjectHelper.requireNonNull(source5, &quot;source5 is null&quot;);</span>
<span class="fc" id="L1862">        ObjectHelper.requireNonNull(source6, &quot;source6 is null&quot;);</span>
<span class="fc" id="L1863">        ObjectHelper.requireNonNull(source7, &quot;source7 is null&quot;);</span>
<span class="fc" id="L1864">        ObjectHelper.requireNonNull(source8, &quot;source8 is null&quot;);</span>
<span class="fc" id="L1865">        return zipArray(Functions.toFunction(zipper), source1, source2, source3, source4, source5, source6, source7, source8);</span>
    }

    /**
     * Returns a Single that emits the results of a specified combiner function applied to nine items
     * emitted by nine other Singles.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.zip.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code zip} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;T1&gt; the first source Single's value type
     * @param &lt;T2&gt; the second source Single's value type
     * @param &lt;T3&gt; the third source Single's value type
     * @param &lt;T4&gt; the fourth source Single's value type
     * @param &lt;T5&gt; the fifth source Single's value type
     * @param &lt;T6&gt; the sixth source Single's value type
     * @param &lt;T7&gt; the seventh source Single's value type
     * @param &lt;T8&gt; the eighth source Single's value type
     * @param &lt;T9&gt; the ninth source Single's value type
     * @param &lt;R&gt; the result value type
     * @param source1
     *            the first source Single
     * @param source2
     *            a second source Single
     * @param source3
     *            a third source Single
     * @param source4
     *            a fourth source Single
     * @param source5
     *            a fifth source Single
     * @param source6
     *            a sixth source Single
     * @param source7
     *            a seventh source Single
     * @param source8
     *            an eighth source Single
     * @param source9
     *            a ninth source Single
     * @param zipper
     *            a function that, when applied to the item emitted by each of the source Singles, results in an
     *            item that will be emitted by the resulting Single
     * @return a Single that emits the zipped results
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/zip.html&quot;&gt;ReactiveX operators documentation: Zip&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T1, T2, T3, T4, T5, T6, T7, T8, T9, R&gt; Single&lt;R&gt; zip(
            SingleSource&lt;? extends T1&gt; source1, SingleSource&lt;? extends T2&gt; source2,
            SingleSource&lt;? extends T3&gt; source3, SingleSource&lt;? extends T4&gt; source4,
            SingleSource&lt;? extends T5&gt; source5, SingleSource&lt;? extends T6&gt; source6,
            SingleSource&lt;? extends T7&gt; source7, SingleSource&lt;? extends T8&gt; source8,
            SingleSource&lt;? extends T9&gt; source9,
            Function9&lt;? super T1, ? super T2, ? super T3, ? super T4, ? super T5, ? super T6, ? super T7, ? super T8, ? super T9, ? extends R&gt; zipper
     ) {
<span class="fc" id="L1924">        ObjectHelper.requireNonNull(source1, &quot;source1 is null&quot;);</span>
<span class="fc" id="L1925">        ObjectHelper.requireNonNull(source2, &quot;source2 is null&quot;);</span>
<span class="fc" id="L1926">        ObjectHelper.requireNonNull(source3, &quot;source3 is null&quot;);</span>
<span class="fc" id="L1927">        ObjectHelper.requireNonNull(source4, &quot;source4 is null&quot;);</span>
<span class="fc" id="L1928">        ObjectHelper.requireNonNull(source5, &quot;source5 is null&quot;);</span>
<span class="fc" id="L1929">        ObjectHelper.requireNonNull(source6, &quot;source6 is null&quot;);</span>
<span class="fc" id="L1930">        ObjectHelper.requireNonNull(source7, &quot;source7 is null&quot;);</span>
<span class="fc" id="L1931">        ObjectHelper.requireNonNull(source8, &quot;source8 is null&quot;);</span>
<span class="fc" id="L1932">        ObjectHelper.requireNonNull(source9, &quot;source9 is null&quot;);</span>
<span class="fc" id="L1933">        return zipArray(Functions.toFunction(zipper), source1, source2, source3, source4, source5, source6, source7, source8, source9);</span>
    }

    /**
     * Waits until all SingleSource sources provided via an array signal a success
     * value and calls a zipper function with an array of these values to return a result
     * to be emitted to downstream.
     * &lt;p&gt;
     * If the array of {@link SingleSource}s is empty a {@link NoSuchElementException} error is signalled immediately.
     * &lt;p&gt;
     * Note on method signature: since Java doesn't allow creating a generic array with {@code new T[]}, the
     * implementation of this operator has to create an {@code Object[]} instead. Unfortunately, a
     * {@code Function&lt;Integer[], R&gt;} passed to the method would trigger a {@code ClassCastException}.
     *
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/zip.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * If any of the SingleSources signal an error, all other SingleSources get disposed and the
     * error emitted to downstream immediately.
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code zipArray} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;T&gt; the common value type
     * @param &lt;R&gt; the result value type
     * @param sources the array of SingleSource instances. An empty sequence will result in an
     *                {@code onError} signal of {@link NoSuchElementException}.
     * @param zipper the function that receives an array with values from each SingleSource
     *               and should return a value to be emitted to downstream
     * @return the new Single instance
     * @since 2.0
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public static &lt;T, R&gt; Single&lt;R&gt; zipArray(Function&lt;? super Object[], ? extends R&gt; zipper, SingleSource&lt;? extends T&gt;... sources) {
<span class="fc" id="L1969">        ObjectHelper.requireNonNull(zipper, &quot;zipper is null&quot;);</span>
<span class="fc" id="L1970">        ObjectHelper.requireNonNull(sources, &quot;sources is null&quot;);</span>
<span class="fc bfc" id="L1971" title="All 2 branches covered.">        if (sources.length == 0) {</span>
<span class="fc" id="L1972">            return error(new NoSuchElementException());</span>
        }
<span class="fc" id="L1974">        return RxJavaPlugins.onAssembly(new SingleZipArray&lt;T, R&gt;(sources, zipper));</span>
    }

    /**
     * Signals the event of this or the other SingleSource whichever signals first.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;463&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.ambWith.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code ambWith} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param other the other SingleSource to race for the first emission of success or error
     * @return the new Single instance. A subscription to this provided source will occur after subscribing
     *            to the current source.
     * @since 2.0
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    @SuppressWarnings(&quot;unchecked&quot;)
    public final Single&lt;T&gt; ambWith(SingleSource&lt;? extends T&gt; other) {
<span class="fc" id="L1995">        ObjectHelper.requireNonNull(other, &quot;other is null&quot;);</span>
<span class="fc" id="L1996">        return ambArray(this, other);</span>
    }

    /**
     * Calls the specified converter function during assembly time and returns its resulting value.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;553&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.as.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * This allows fluent conversion to any other type.
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code as} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * &lt;p&gt;History: 2.1.7 - experimental
     * @param &lt;R&gt; the resulting object type
     * @param converter the function that receives the current Single instance and returns a value
     * @return the converted value
     * @throws NullPointerException if converter is null
     * @since 2.2
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;R&gt; R as(@NonNull SingleConverter&lt;T, ? extends R&gt; converter) {
<span class="fc" id="L2019">        return ObjectHelper.requireNonNull(converter, &quot;converter is null&quot;).apply(this);</span>
    }

    /**
     * Hides the identity of the current Single, including the Disposable that is sent
     * to the downstream via {@code onSubscribe()}.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;458&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.hide.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code hide} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @return the new Single instance
     * @since 2.0
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Single&lt;T&gt; hide() {
<span class="fc" id="L2037">        return RxJavaPlugins.onAssembly(new SingleHide&lt;T&gt;(this));</span>
    }

    /**
     * Transform a Single by applying a particular Transformer function to it.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;612&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.compose.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * This method operates on the Single itself whereas {@link #lift} operates on the Single's SingleObservers.
     * &lt;p&gt;
     * If the operator you are creating is designed to act on the individual item emitted by a Single, use
     * {@link #lift}. If your operator is designed to transform the source Single as a whole (for instance, by
     * applying a particular set of existing RxJava operators to it) use {@code compose}.
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code compose} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;R&gt; the value type of the single returned by the transformer function
     * @param transformer the transformer function, not null
     * @return the source Single, transformed by the transformer function
     * @see &lt;a href=&quot;https://github.com/ReactiveX/RxJava/wiki/Implementing-Your-Own-Operators&quot;&gt;RxJava wiki: Implementing Your Own Operators&lt;/a&gt;
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;R&gt; Single&lt;R&gt; compose(SingleTransformer&lt;? super T, ? extends R&gt; transformer) {
<span class="fc" id="L2064">        return wrap(((SingleTransformer&lt;T, R&gt;) ObjectHelper.requireNonNull(transformer, &quot;transformer is null&quot;)).apply(this));</span>
    }

    /**
     * Stores the success value or exception from the current Single and replays it to late SingleObservers.
     * &lt;p&gt;
     * The returned Single subscribes to the current Single when the first SingleObserver subscribes.
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code cache} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @return the new Single instance
     * @since 2.0
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Single&lt;T&gt; cache() {
<span class="fc" id="L2082">        return RxJavaPlugins.onAssembly(new SingleCache&lt;T&gt;(this));</span>
    }

    /**
     * Casts the success value of the current Single into the target type or signals a
     * ClassCastException if not compatible.
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code cast} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;U&gt; the target type
     * @param clazz the type token to use for casting the success result from the current Single
     * @return the new Single instance
     * @since 2.0
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;U&gt; Single&lt;U&gt; cast(final Class&lt;? extends U&gt; clazz) {
<span class="fc" id="L2101">        ObjectHelper.requireNonNull(clazz, &quot;clazz is null&quot;);</span>
<span class="fc" id="L2102">        return map(Functions.castFunction(clazz));</span>
    }

    /**
     * Returns a Flowable that emits the item emitted by the source Single, then the item emitted by the
     * specified Single.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;335&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.concatWith.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The returned {@code Flowable} honors the backpressure of the downstream consumer.&lt;/dd&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code concatWith} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param other
     *            a Single to be concatenated after the current
     * @return a Flowable that emits the item emitted by the source Single, followed by the item emitted by
     *         {@code t1}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/concat.html&quot;&gt;ReactiveX operators documentation: Concat&lt;/a&gt;
     */
    @BackpressureSupport(BackpressureKind.FULL)
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;T&gt; concatWith(SingleSource&lt;? extends T&gt; other) {
<span class="fc" id="L2127">        return concat(this, other);</span>
    }

    /**
     * Delays the emission of the success signal from the current Single by the specified amount.
     * An error signal will not be delayed.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;457&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.delay.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code delay} operates by default on the {@code computation} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param time the amount of time the success signal should be delayed for
     * @param unit the time unit
     * @return the new Single instance
     * @since 2.0
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.COMPUTATION)
    public final Single&lt;T&gt; delay(long time, TimeUnit unit) {
<span class="fc" id="L2148">        return delay(time, unit, Schedulers.computation(), false);</span>
    }

    /**
     * Delays the emission of the success or error signal from the current Single by the specified amount.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;457&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.delay.e.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code delay} operates by default on the {@code computation} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * &lt;p&gt;History: 2.1.5 - experimental
     * @param time the amount of time the success or error signal should be delayed for
     * @param unit the time unit
     * @param delayError if true, both success and error signals are delayed. if false, only success signals are delayed.
     * @return the new Single instance
     * @since 2.2
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.COMPUTATION)
    public final Single&lt;T&gt; delay(long time, TimeUnit unit, boolean delayError) {
<span class="fc" id="L2169">        return delay(time, unit, Schedulers.computation(), delayError);</span>
    }

    /**
     * Delays the emission of the success signal from the current Single by the specified amount.
     * An error signal will not be delayed.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;457&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.delay.s.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;you specify the {@link Scheduler} where the non-blocking wait and emission happens&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param time the amount of time the success signal should be delayed for
     * @param unit the time unit
     * @param scheduler the target scheduler to use for the non-blocking wait and emission
     * @return the new Single instance
     * @throws NullPointerException
     *             if unit is null, or
     *             if scheduler is null
     * @since 2.0
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Single&lt;T&gt; delay(final long time, final TimeUnit unit, final Scheduler scheduler) {
<span class="fc" id="L2194">        return delay(time, unit, scheduler, false);</span>
    }

    /**
     * Delays the emission of the success or error signal from the current Single by the specified amount.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;457&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.delay.se.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;you specify the {@link Scheduler} where the non-blocking wait and emission happens&lt;/dd&gt;
     * &lt;/dl&gt;
     * &lt;p&gt;History: 2.1.5 - experimental
     * @param time the amount of time the success or error signal should be delayed for
     * @param unit the time unit
     * @param scheduler the target scheduler to use for the non-blocking wait and emission
     * @param delayError if true, both success and error signals are delayed. if false, only success signals are delayed.
     * @return the new Single instance
     * @throws NullPointerException
     *             if unit is null, or
     *             if scheduler is null
     * @since 2.2
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Single&lt;T&gt; delay(final long time, final TimeUnit unit, final Scheduler scheduler, boolean delayError) {
<span class="fc" id="L2220">        ObjectHelper.requireNonNull(unit, &quot;unit is null&quot;);</span>
<span class="fc" id="L2221">        ObjectHelper.requireNonNull(scheduler, &quot;scheduler is null&quot;);</span>
<span class="fc" id="L2222">        return RxJavaPlugins.onAssembly(new SingleDelay&lt;T&gt;(this, time, unit, scheduler, delayError));</span>
    }

    /**
     * Delays the actual subscription to the current Single until the given other CompletableSource
     * completes.
     * &lt;p&gt;If the delaying source signals an error, that error is re-emitted and no subscription
     * to the current Single happens.
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code delaySubscription} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param other the CompletableSource that has to complete before the subscription to the
     *              current Single happens
     * @return the new Single instance
     * @since 2.0
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Single&lt;T&gt; delaySubscription(CompletableSource other) {
<span class="fc" id="L2243">        ObjectHelper.requireNonNull(other, &quot;other is null&quot;);</span>
<span class="fc" id="L2244">        return RxJavaPlugins.onAssembly(new SingleDelayWithCompletable&lt;T&gt;(this, other));</span>
    }

    /**
     * Delays the actual subscription to the current Single until the given other SingleSource
     * signals success.
     * &lt;p&gt;If the delaying source signals an error, that error is re-emitted and no subscription
     * to the current Single happens.
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code delaySubscription} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;U&gt; the element type of the other source
     * @param other the SingleSource that has to complete before the subscription to the
     *              current Single happens
     * @return the new Single instance
     * @since 2.0
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;U&gt; Single&lt;T&gt; delaySubscription(SingleSource&lt;U&gt; other) {
<span class="fc" id="L2266">        ObjectHelper.requireNonNull(other, &quot;other is null&quot;);</span>
<span class="fc" id="L2267">        return RxJavaPlugins.onAssembly(new SingleDelayWithSingle&lt;T, U&gt;(this, other));</span>
    }

    /**
     * Delays the actual subscription to the current Single until the given other ObservableSource
     * signals its first value or completes.
     * &lt;p&gt;If the delaying source signals an error, that error is re-emitted and no subscription
     * to the current Single happens.
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code delaySubscription} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;U&gt; the element type of the other source
     * @param other the ObservableSource that has to signal a value or complete before the
     *              subscription to the current Single happens
     * @return the new Single instance
     * @since 2.0
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;U&gt; Single&lt;T&gt; delaySubscription(ObservableSource&lt;U&gt; other) {
<span class="fc" id="L2289">        ObjectHelper.requireNonNull(other, &quot;other is null&quot;);</span>
<span class="fc" id="L2290">        return RxJavaPlugins.onAssembly(new SingleDelayWithObservable&lt;T, U&gt;(this, other));</span>
    }

    /**
     * Delays the actual subscription to the current Single until the given other Publisher
     * signals its first value or completes.
     * &lt;p&gt;If the delaying source signals an error, that error is re-emitted and no subscription
     * to the current Single happens.
     * &lt;p&gt;The other source is consumed in an unbounded manner (requesting Long.MAX_VALUE from it).
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;The {@code other} publisher is consumed in an unbounded fashion but will be
     * cancelled after the first item it produced.&lt;/dd&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code delaySubscription} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;U&gt; the element type of the other source
     * @param other the Publisher that has to signal a value or complete before the
     *              subscription to the current Single happens
     * @return the new Single instance
     * @since 2.0
     */
    @BackpressureSupport(BackpressureKind.FULL)
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;U&gt; Single&lt;T&gt; delaySubscription(Publisher&lt;U&gt; other) {
<span class="fc" id="L2317">        ObjectHelper.requireNonNull(other, &quot;other is null&quot;);</span>
<span class="fc" id="L2318">        return RxJavaPlugins.onAssembly(new SingleDelayWithPublisher&lt;T, U&gt;(this, other));</span>
    }

    /**
     * Delays the actual subscription to the current Single until the given time delay elapsed.
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code delaySubscription} does by default subscribe to the current Single
     * on the {@code computation} {@link Scheduler} after the delay.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param time the time amount to wait with the subscription
     * @param unit the time unit of the waiting
     * @return the new Single instance
     * @since 2.0
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.COMPUTATION)
    public final Single&lt;T&gt; delaySubscription(long time, TimeUnit unit) {
<span class="fc" id="L2336">        return delaySubscription(time, unit, Schedulers.computation());</span>
    }

    /**
     * Delays the actual subscription to the current Single until the given time delay elapsed.
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code delaySubscription} does by default subscribe to the current Single
     * on the {@link Scheduler} you provided, after the delay.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param time the time amount to wait with the subscription
     * @param unit the time unit of the waiting
     * @param scheduler the scheduler to wait on and subscribe on to the current Single
     * @return the new Single instance
     * @since 2.0
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Single&lt;T&gt; delaySubscription(long time, TimeUnit unit, Scheduler scheduler) {
<span class="fc" id="L2355">        return delaySubscription(Observable.timer(time, unit, scheduler));</span>
    }

    /**
     * Maps the {@link Notification} success value of this Single back into normal
     * {@code onSuccess}, {@code onError} or {@code onComplete} signals as a
     * {@link Maybe} source.
     * &lt;p&gt;
     * The intended use of the {@code selector} function is to perform a
     * type-safe identity mapping (see example) on a source that is already of type
     * {@code Notification&lt;T&gt;}. The Java language doesn't allow
     * limiting instance methods to a certain generic argument shape, therefore,
     * a function is used to ensure the conversion remains type safe.
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code dematerialize} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * &lt;p&gt;
     * Example:
     * &lt;pre&gt;&lt;code&gt;
     * Single.just(Notification.createOnNext(1))
     * .dematerialize(notification -&amp;gt; notification)
     * .test()
     * .assertResult(1);
     * &lt;/code&gt;&lt;/pre&gt;
     * @param &lt;R&gt; the result type
     * @param selector the function called with the success item and should
     * return a {@link Notification} instance.
     * @return the new Maybe instance
     * @since 2.2.4 - experimental
     * @see #materialize()
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    @Experimental
    public final &lt;R&gt; Maybe&lt;R&gt; dematerialize(Function&lt;? super T, Notification&lt;R&gt;&gt; selector) {
<span class="fc" id="L2392">        ObjectHelper.requireNonNull(selector, &quot;selector is null&quot;);</span>
<span class="fc" id="L2393">        return RxJavaPlugins.onAssembly(new SingleDematerialize&lt;T, R&gt;(this, selector));</span>
    }

    /**
     * Calls the specified consumer with the success item after this item has been emitted to the downstream.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;460&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doAfterSuccess.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * Note that the {@code doAfterSuccess} action is shared between subscriptions and as such
     * should be thread-safe.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code doAfterSuccess} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * &lt;p&gt;History: 2.0.1 - experimental
     * @param onAfterSuccess the Consumer that will be called after emitting an item from upstream to the downstream
     * @return the new Single instance
     * @since 2.1
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Single&lt;T&gt; doAfterSuccess(Consumer&lt;? super T&gt; onAfterSuccess) {
<span class="fc" id="L2416">        ObjectHelper.requireNonNull(onAfterSuccess, &quot;onAfterSuccess is null&quot;);</span>
<span class="fc" id="L2417">        return RxJavaPlugins.onAssembly(new SingleDoAfterSuccess&lt;T&gt;(this, onAfterSuccess));</span>
    }

    /**
     * Registers an {@link Action} to be called after this Single invokes either onSuccess or onError.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;460&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doAfterTerminate.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * Note that the {@code doAfterTerminate} action is shared between subscriptions and as such
     * should be thread-safe.&lt;/p&gt;
     *
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code doAfterTerminate} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * &lt;p&gt;History: 2.0.6 - experimental
     * @param onAfterTerminate
     *            an {@link Action} to be invoked when the source Single finishes
     * @return a Single that emits the same items as the source Single, then invokes the
     *         {@link Action}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/do.html&quot;&gt;ReactiveX operators documentation: Do&lt;/a&gt;
     * @since 2.1
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Single&lt;T&gt; doAfterTerminate(Action onAfterTerminate) {
<span class="fc" id="L2445">        ObjectHelper.requireNonNull(onAfterTerminate, &quot;onAfterTerminate is null&quot;);</span>
<span class="fc" id="L2446">        return RxJavaPlugins.onAssembly(new SingleDoAfterTerminate&lt;T&gt;(this, onAfterTerminate));</span>
    }

    /**
     * Calls the specified action after this Single signals onSuccess or onError or gets disposed by
     * the downstream.
     * &lt;p&gt;In case of a race between a terminal event and a dispose call, the provided {@code onFinally} action
     * is executed once per subscription.
     * &lt;p&gt;Note that the {@code onFinally} action is shared between subscriptions and as such
     * should be thread-safe.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;291&quot; src=&quot;https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doFinally.png&quot; alt=&quot;&quot;&gt;
     * &lt;/p&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code doFinally} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * &lt;p&gt;History: 2.0.1 - experimental
     * @param onFinally the action called when this Single terminates or gets disposed
     * @return the new Single instance
     * @since 2.1
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Single&lt;T&gt; doFinally(Action onFinally) {
<span class="fc" id="L2472">        ObjectHelper.requireNonNull(onFinally, &quot;onFinally is null&quot;);</span>
<span class="fc" id="L2473">        return RxJavaPlugins.onAssembly(new SingleDoFinally&lt;T&gt;(this, onFinally));</span>
    }

    /**
     * Calls the shared consumer with the Disposable sent through the onSubscribe for each
     * SingleObserver that subscribes to the current Single.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;347&quot; src=&quot;https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doOnSubscribe.png&quot; alt=&quot;&quot;&gt;
     * &lt;/p&gt;
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code doOnSubscribe} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param onSubscribe the consumer called with the Disposable sent via onSubscribe
     * @return the new Single instance
     * @since 2.0
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Single&lt;T&gt; doOnSubscribe(final Consumer&lt;? super Disposable&gt; onSubscribe) {
<span class="fc" id="L2494">        ObjectHelper.requireNonNull(onSubscribe, &quot;onSubscribe is null&quot;);</span>
<span class="fc" id="L2495">        return RxJavaPlugins.onAssembly(new SingleDoOnSubscribe&lt;T&gt;(this, onSubscribe));</span>
    }

    /**
     * Returns a Single instance that calls the given onTerminate callback
     * just before this Single completes normally or with an exception.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnTerminate.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * This differs from {@code doAfterTerminate} in that this happens &lt;em&gt;before&lt;/em&gt; the {@code onComplete} or
     * {@code onError} notification.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code doOnTerminate} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param onTerminate the action to invoke when the consumer calls {@code onComplete} or {@code onError}
     * @return the new Single instance
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/do.html&quot;&gt;ReactiveX operators documentation: Do&lt;/a&gt;
     * @see #doOnTerminate(Action)
     * @since 2.2.7 - experimental
     */
    @Experimental
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Single&lt;T&gt; doOnTerminate(final Action onTerminate) {
<span class="fc" id="L2521">        ObjectHelper.requireNonNull(onTerminate, &quot;onTerminate is null&quot;);</span>
<span class="fc" id="L2522">        return RxJavaPlugins.onAssembly(new SingleDoOnTerminate&lt;T&gt;(this, onTerminate));</span>
    }

    /**
     * Calls the shared consumer with the success value sent via onSuccess for each
     * SingleObserver that subscribes to the current Single.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;347&quot; src=&quot;https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doOnSuccess.2.png&quot; alt=&quot;&quot;&gt;
     * &lt;/p&gt;
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code doOnSuccess} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param onSuccess the consumer called with the success value of onSuccess
     * @return the new Single instance
     * @since 2.0
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Single&lt;T&gt; doOnSuccess(final Consumer&lt;? super T&gt; onSuccess) {
<span class="fc" id="L2543">        ObjectHelper.requireNonNull(onSuccess, &quot;onSuccess is null&quot;);</span>
<span class="fc" id="L2544">        return RxJavaPlugins.onAssembly(new SingleDoOnSuccess&lt;T&gt;(this, onSuccess));</span>
    }

    /**
     * Calls the shared consumer with the error sent via onError or the value
     * via onSuccess for each SingleObserver that subscribes to the current Single.
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code doOnEvent} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param onEvent the consumer called with the success value of onEvent
     * @return the new Single instance
     * @since 2.0
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Single&lt;T&gt; doOnEvent(final BiConsumer&lt;? super T, ? super Throwable&gt; onEvent) {
<span class="fc" id="L2562">        ObjectHelper.requireNonNull(onEvent, &quot;onEvent is null&quot;);</span>
<span class="fc" id="L2563">        return RxJavaPlugins.onAssembly(new SingleDoOnEvent&lt;T&gt;(this, onEvent));</span>
    }

    /**
     * Calls the shared consumer with the error sent via onError for each
     * SingleObserver that subscribes to the current Single.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;349&quot; src=&quot;https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doOnError.2.png&quot; alt=&quot;&quot;&gt;
     * &lt;/p&gt;
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code doOnError} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param onError the consumer called with the success value of onError
     * @return the new Single instance
     * @since 2.0
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Single&lt;T&gt; doOnError(final Consumer&lt;? super Throwable&gt; onError) {
<span class="fc" id="L2584">        ObjectHelper.requireNonNull(onError, &quot;onError is null&quot;);</span>
<span class="fc" id="L2585">        return RxJavaPlugins.onAssembly(new SingleDoOnError&lt;T&gt;(this, onError));</span>
    }

    /**
     * Calls the shared {@code Action} if a SingleObserver subscribed to the current Single
     * disposes the common Disposable it received via onSubscribe.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;332&quot; src=&quot;https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doOnDispose.png&quot; alt=&quot;&quot;&gt;
     * &lt;/p&gt;
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code doOnDispose} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param onDispose the action called when the subscription is disposed
     * @return the new Single instance
     * @throws NullPointerException if onDispose is null
     * @since 2.0
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Single&lt;T&gt; doOnDispose(final Action onDispose) {
<span class="fc" id="L2607">        ObjectHelper.requireNonNull(onDispose, &quot;onDispose is null&quot;);</span>
<span class="fc" id="L2608">        return RxJavaPlugins.onAssembly(new SingleDoOnDispose&lt;T&gt;(this, onDispose));</span>
    }

    /**
     * Filters the success item of the Single via a predicate function and emitting it if the predicate
     * returns true, completing otherwise.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;457&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.filter.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code filter} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param predicate
     *            a function that evaluates the item emitted by the source Maybe, returning {@code true}
     *            if it passes the filter
     * @return a Maybe that emit the item emitted by the source Maybe that the filter
     *         evaluates as {@code true}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/filter.html&quot;&gt;ReactiveX operators documentation: Filter&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Maybe&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate) {
<span class="fc" id="L2632">        ObjectHelper.requireNonNull(predicate, &quot;predicate is null&quot;);</span>
<span class="fc" id="L2633">        return RxJavaPlugins.onAssembly(new MaybeFilterSingle&lt;T&gt;(this, predicate));</span>
    }

    /**
     * Returns a Single that is based on applying a specified function to the item emitted by the source Single,
     * where that function returns a SingleSource.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;300&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.flatMap.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code flatMap} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;R&gt; the result value type
     * @param mapper
     *            a function that, when applied to the item emitted by the source Single, returns a SingleSource
     * @return the Single returned from {@code mapper} when applied to the item emitted by the source Single
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/flatmap.html&quot;&gt;ReactiveX operators documentation: FlatMap&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;R&gt; Single&lt;R&gt; flatMap(Function&lt;? super T, ? extends SingleSource&lt;? extends R&gt;&gt; mapper) {
<span class="fc" id="L2656">        ObjectHelper.requireNonNull(mapper, &quot;mapper is null&quot;);</span>
<span class="fc" id="L2657">        return RxJavaPlugins.onAssembly(new SingleFlatMap&lt;T, R&gt;(this, mapper));</span>
    }

    /**
     * Returns a Maybe that is based on applying a specified function to the item emitted by the source Single,
     * where that function returns a MaybeSource.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;191&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.flatMapMaybe.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code flatMapMaybe} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;R&gt; the result value type
     * @param mapper
     *            a function that, when applied to the item emitted by the source Single, returns a MaybeSource
     * @return the Maybe returned from {@code mapper} when applied to the item emitted by the source Single
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/flatmap.html&quot;&gt;ReactiveX operators documentation: FlatMap&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;R&gt; Maybe&lt;R&gt; flatMapMaybe(final Function&lt;? super T, ? extends MaybeSource&lt;? extends R&gt;&gt; mapper) {
<span class="fc" id="L2680">        ObjectHelper.requireNonNull(mapper, &quot;mapper is null&quot;);</span>
<span class="fc" id="L2681">        return RxJavaPlugins.onAssembly(new SingleFlatMapMaybe&lt;T, R&gt;(this, mapper));</span>
    }

    /**
     * Returns a Flowable that emits items based on applying a specified function to the item emitted by the
     * source Single, where that function returns a Publisher.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.flatMapPublisher.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The returned {@code Flowable} honors the backpressure of the downstream consumer
     *  and the {@code Publisher} returned by the mapper function is expected to honor it as well.&lt;/dd&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code flatMapPublisher} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;R&gt; the result value type
     * @param mapper
     *            a function that, when applied to the item emitted by the source Single, returns a
     *            Flowable
     * @return the Flowable returned from {@code func} when applied to the item emitted by the source Single
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/flatmap.html&quot;&gt;ReactiveX operators documentation: FlatMap&lt;/a&gt;
     */
    @BackpressureSupport(BackpressureKind.FULL)
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;R&gt; Flowable&lt;R&gt; flatMapPublisher(Function&lt;? super T, ? extends Publisher&lt;? extends R&gt;&gt; mapper) {
<span class="fc" id="L2709">        ObjectHelper.requireNonNull(mapper, &quot;mapper is null&quot;);</span>
<span class="fc" id="L2710">        return RxJavaPlugins.onAssembly(new SingleFlatMapPublisher&lt;T, R&gt;(this, mapper));</span>
    }

    /**
     * Maps the success value of the upstream {@link Single} into an {@link Iterable} and emits its items as a
     * {@link Flowable} sequence.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;373&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flattenAsFlowable.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The operator honors backpressure from downstream.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code flattenAsFlowable} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;U&gt;
     *            the type of item emitted by the resulting Iterable
     * @param mapper
     *            a function that returns an Iterable sequence of values for when given an item emitted by the
     *            source Single
     * @return the new Flowable instance
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/flatmap.html&quot;&gt;ReactiveX operators documentation: FlatMap&lt;/a&gt;
     */
    @BackpressureSupport(BackpressureKind.FULL)
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;U&gt; Flowable&lt;U&gt; flattenAsFlowable(final Function&lt;? super T, ? extends Iterable&lt;? extends U&gt;&gt; mapper) {
<span class="fc" id="L2738">        ObjectHelper.requireNonNull(mapper, &quot;mapper is null&quot;);</span>
<span class="fc" id="L2739">        return RxJavaPlugins.onAssembly(new SingleFlatMapIterableFlowable&lt;T, U&gt;(this, mapper));</span>
    }

    /**
     * Maps the success value of the upstream {@link Single} into an {@link Iterable} and emits its items as an
     * {@link Observable} sequence.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;373&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flattenAsObservable.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code flattenAsObservable} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;U&gt;
     *            the type of item emitted by the resulting Iterable
     * @param mapper
     *            a function that returns an Iterable sequence of values for when given an item emitted by the
     *            source Single
     * @return the new Observable instance
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/flatmap.html&quot;&gt;ReactiveX operators documentation: FlatMap&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;U&gt; Observable&lt;U&gt; flattenAsObservable(final Function&lt;? super T, ? extends Iterable&lt;? extends U&gt;&gt; mapper) {
<span class="fc" id="L2764">        ObjectHelper.requireNonNull(mapper, &quot;mapper is null&quot;);</span>
<span class="fc" id="L2765">        return RxJavaPlugins.onAssembly(new SingleFlatMapIterableObservable&lt;T, U&gt;(this, mapper));</span>
    }

    /**
     * Returns an Observable that is based on applying a specified function to the item emitted by the source Single,
     * where that function returns an ObservableSource.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;300&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.flatMapObservable.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code flatMapObservable} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;R&gt; the result value type
     * @param mapper
     *            a function that, when applied to the item emitted by the source Single, returns an ObservableSource
     * @return the Observable returned from {@code func} when applied to the item emitted by the source Single
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/flatmap.html&quot;&gt;ReactiveX operators documentation: FlatMap&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;R&gt; Observable&lt;R&gt; flatMapObservable(Function&lt;? super T, ? extends ObservableSource&lt;? extends R&gt;&gt; mapper) {
<span class="fc" id="L2788">        ObjectHelper.requireNonNull(mapper, &quot;mapper is null&quot;);</span>
<span class="fc" id="L2789">        return RxJavaPlugins.onAssembly(new SingleFlatMapObservable&lt;T, R&gt;(this, mapper));</span>
    }

    /**
     * Returns a {@link Completable} that completes based on applying a specified function to the item emitted by the
     * source {@link Single}, where that function returns a {@link Completable}.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;267&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.flatMapCompletable.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code flatMapCompletable} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param mapper
     *            a function that, when applied to the item emitted by the source Single, returns a
     *            Completable
     * @return the Completable returned from {@code func} when applied to the item emitted by the source Single
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/flatmap.html&quot;&gt;ReactiveX operators documentation: FlatMap&lt;/a&gt;
     * @since 2.0
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Completable flatMapCompletable(final Function&lt;? super T, ? extends CompletableSource&gt; mapper) {
<span class="fc" id="L2813">        ObjectHelper.requireNonNull(mapper, &quot;mapper is null&quot;);</span>
<span class="fc" id="L2814">        return RxJavaPlugins.onAssembly(new SingleFlatMapCompletable&lt;T&gt;(this, mapper));</span>
    }

    /**
     * Waits in a blocking fashion until the current Single signals a success value (which is returned) or
     * an exception (which is propagated).
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code blockingGet} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;dt&gt;&lt;b&gt;Error handling:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;If the source signals an error, the operator wraps a checked {@link Exception}
     * into {@link RuntimeException} and throws that. Otherwise, {@code RuntimeException}s and
     * {@link Error}s are rethrown as they are.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @return the success value
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public final T blockingGet() {
<span class="fc" id="L2833">        BlockingMultiObserver&lt;T&gt; observer = new BlockingMultiObserver&lt;T&gt;();</span>
<span class="fc" id="L2834">        subscribe(observer);</span>
<span class="fc" id="L2835">        return observer.blockingGet();</span>
    }

    /**
     * &lt;strong&gt;This method requires advanced knowledge about building operators, please consider
     * other standard composition methods first;&lt;/strong&gt;
     * Returns a {@code Single} which, when subscribed to, invokes the {@link SingleOperator#apply(SingleObserver) apply(SingleObserver)} method
     * of the provided {@link SingleOperator} for each individual downstream {@link Single} and allows the
     * insertion of a custom operator by accessing the downstream's {@link SingleObserver} during this subscription phase
     * and providing a new {@code SingleObserver}, containing the custom operator's intended business logic, that will be
     * used in the subscription process going further upstream.
     * &lt;p&gt;
     * Generally, such a new {@code SingleObserver} will wrap the downstream's {@code SingleObserver} and forwards the
     * {@code onSuccess} and {@code onError} events from the upstream directly or according to the
     * emission pattern the custom operator's business logic requires. In addition, such operator can intercept the
     * flow control calls of {@code dispose} and {@code isDisposed} that would have traveled upstream and perform
     * additional actions depending on the same business logic requirements.
     * &lt;p&gt;
     * Example:
     * &lt;pre&gt;&lt;code&gt;
     * // Step 1: Create the consumer type that will be returned by the SingleOperator.apply():
     *
     * public final class CustomSingleObserver&amp;lt;T&amp;gt; implements SingleObserver&amp;lt;T&amp;gt;, Disposable {
     *
     *     // The downstream's SingleObserver that will receive the onXXX events
     *     final SingleObserver&amp;lt;? super String&amp;gt; downstream;
     *
     *     // The connection to the upstream source that will call this class' onXXX methods
     *     Disposable upstream;
     *
     *     // The constructor takes the downstream subscriber and usually any other parameters
     *     public CustomSingleObserver(SingleObserver&amp;lt;? super String&amp;gt; downstream) {
     *         this.downstream = downstream;
     *     }
     *
     *     // In the subscription phase, the upstream sends a Disposable to this class
     *     // and subsequently this class has to send a Disposable to the downstream.
     *     // Note that relaying the upstream's Disposable directly is not allowed in RxJava
     *     &amp;#64;Override
     *     public void onSubscribe(Disposable d) {
     *         if (upstream != null) {
     *             d.dispose();
     *         } else {
     *             upstream = d;
     *             downstream.onSubscribe(this);
     *         }
     *     }
     *
     *     // The upstream calls this with the next item and the implementation's
     *     // responsibility is to emit an item to the downstream based on the intended
     *     // business logic, or if it can't do so for the particular item,
     *     // request more from the upstream
     *     &amp;#64;Override
     *     public void onSuccess(T item) {
     *         String str = item.toString();
     *         if (str.length() &amp;lt; 2) {
     *             downstream.onSuccess(str);
     *         } else {
     *             // Single is usually expected to produce one of the onXXX events
     *             downstream.onError(new NoSuchElementException());
     *         }
     *     }
     *
     *     // Some operators may handle the upstream's error while others
     *     // could just forward it to the downstream.
     *     &amp;#64;Override
     *     public void onError(Throwable throwable) {
     *         downstream.onError(throwable);
     *     }
     *
     *     // Some operators may use their own resources which should be cleaned up if
     *     // the downstream disposes the flow before it completed. Operators without
     *     // resources can simply forward the dispose to the upstream.
     *     // In some cases, a disposed flag may be set by this method so that other parts
     *     // of this class may detect the dispose and stop sending events
     *     // to the downstream.
     *     &amp;#64;Override
     *     public void dispose() {
     *         upstream.dispose();
     *     }
     *
     *     // Some operators may simply forward the call to the upstream while others
     *     // can return the disposed flag set in dispose().
     *     &amp;#64;Override
     *     public boolean isDisposed() {
     *         return upstream.isDisposed();
     *     }
     * }
     *
     * // Step 2: Create a class that implements the SingleOperator interface and
     * //         returns the custom consumer type from above in its apply() method.
     * //         Such class may define additional parameters to be submitted to
     * //         the custom consumer type.
     *
     * final class CustomSingleOperator&amp;lt;T&amp;gt; implements SingleOperator&amp;lt;String&amp;gt; {
     *     &amp;#64;Override
     *     public SingleObserver&amp;lt;? super String&amp;gt; apply(SingleObserver&amp;lt;? super T&amp;gt; upstream) {
     *         return new CustomSingleObserver&amp;lt;T&amp;gt;(upstream);
     *     }
     * }
     *
     * // Step 3: Apply the custom operator via lift() in a flow by creating an instance of it
     * //         or reusing an existing one.
     *
     * Single.just(5)
     * .lift(new CustomSingleOperator&amp;lt;Integer&amp;gt;())
     * .test()
     * .assertResult(&quot;5&quot;);
     *
     * Single.just(15)
     * .lift(new CustomSingleOperator&amp;lt;Integer&amp;gt;())
     * .test()
     * .assertFailure(NoSuchElementException.class);
     * &lt;/code&gt;&lt;/pre&gt;
     * &lt;p&gt;
     * Creating custom operators can be complicated and it is recommended one consults the
     * &lt;a href=&quot;https://github.com/ReactiveX/RxJava/wiki/Writing-operators-for-2.0&quot;&gt;RxJava wiki: Writing operators&lt;/a&gt; page about
     * the tools, requirements, rules, considerations and pitfalls of implementing them.
     * &lt;p&gt;
     * Note that implementing custom operators via this {@code lift()} method adds slightly more overhead by requiring
     * an additional allocation and indirection per assembled flows. Instead, extending the abstract {@code Single}
     * class and creating a {@link SingleTransformer} with it is recommended.
     * &lt;p&gt;
     * Note also that it is not possible to stop the subscription phase in {@code lift()} as the {@code apply()} method
     * requires a non-null {@code SingleObserver} instance to be returned, which is then unconditionally subscribed to
     * the upstream {@code Single}. For example, if the operator decided there is no reason to subscribe to the
     * upstream source because of some optimization possibility or a failure to prepare the operator, it still has to
     * return a {@code SingleObserver} that should immediately dispose the upstream's {@code Disposable} in its
     * {@code onSubscribe} method. Again, using a {@code SingleTransformer} and extending the {@code Single} is
     * a better option as {@link #subscribeActual} can decide to not subscribe to its upstream after all.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code lift} does not operate by default on a particular {@link Scheduler}, however, the
     *  {@link SingleOperator} may use a {@code Scheduler} to support its own asynchronous behavior.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;R&gt; the output value type
     * @param lift the {@link SingleOperator} that receives the downstream's {@code SingleObserver} and should return
     *               a {@code SingleObserver} with custom behavior to be used as the consumer for the current
     *               {@code Single}.
     * @return the new Single instance
     * @see &lt;a href=&quot;https://github.com/ReactiveX/RxJava/wiki/Writing-operators-for-2.0&quot;&gt;RxJava wiki: Writing operators&lt;/a&gt;
     * @see #compose(SingleTransformer)
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;R&gt; Single&lt;R&gt; lift(final SingleOperator&lt;? extends R, ? super T&gt; lift) {
<span class="fc" id="L2983">        ObjectHelper.requireNonNull(lift, &quot;lift is null&quot;);</span>
<span class="fc" id="L2984">        return RxJavaPlugins.onAssembly(new SingleLift&lt;T, R&gt;(this, lift));</span>
    }

    /**
     * Returns a Single that applies a specified function to the item emitted by the source Single and
     * emits the result of this function application.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.map.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code map} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;R&gt; the result value type
     * @param mapper
     *            a function to apply to the item emitted by the Single
     * @return a Single that emits the item from the source Single, transformed by the specified function
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/map.html&quot;&gt;ReactiveX operators documentation: Map&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;R&gt; Single&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper) {
<span class="fc" id="L3007">        ObjectHelper.requireNonNull(mapper, &quot;mapper is null&quot;);</span>
<span class="fc" id="L3008">        return RxJavaPlugins.onAssembly(new SingleMap&lt;T, R&gt;(this, mapper));</span>
    }

    /**
     * Maps the signal types of this Single into a {@link Notification} of the same kind
     * and emits it as a single success value to downstream.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/materialize.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code materialize} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @return the new Single instance
     * @since 2.2.4 - experimental
     * @see #dematerialize(Function)
     */
    @Experimental
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Single&lt;Notification&lt;T&gt;&gt; materialize() {
<span class="fc" id="L3028">        return RxJavaPlugins.onAssembly(new SingleMaterialize&lt;T&gt;(this));</span>
    }

    /**
     * Signals true if the current Single signals a success value that is Object-equals with the value
     * provided.
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code contains} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param value the value to compare against the success value of this Single
     * @return the new Single instance
     * @since 2.0
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Single&lt;Boolean&gt; contains(Object value) {
<span class="fc" id="L3045">        return contains(value, ObjectHelper.equalsPredicate());</span>
    }

    /**
     * Signals true if the current Single signals a success value that is equal with
     * the value provided by calling a bi-predicate.
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code contains} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param value the value to compare against the success value of this Single
     * @param comparer the function that receives the success value of this Single, the value provided
     *                 and should return true if they are considered equal
     * @return the new Single instance
     * @since 2.0
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Single&lt;Boolean&gt; contains(final Object value, final BiPredicate&lt;Object, Object&gt; comparer) {
<span class="fc" id="L3065">        ObjectHelper.requireNonNull(value, &quot;value is null&quot;);</span>
<span class="fc" id="L3066">        ObjectHelper.requireNonNull(comparer, &quot;comparer is null&quot;);</span>
<span class="fc" id="L3067">        return RxJavaPlugins.onAssembly(new SingleContains&lt;T&gt;(this, value, comparer));</span>
    }

    /**
     * Flattens this and another Single into a single Flowable, without any transformation.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;415&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.mergeWith.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * You can combine items emitted by multiple Singles so that they appear as a single Flowable, by using
     * the {@code mergeWith} method.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The returned {@code Flowable} honors the backpressure of the downstream consumer.&lt;/dd&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code mergeWith} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param other
     *            a SingleSource to be merged
     * @return  that emits all of the items emitted by the source Singles
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/merge.html&quot;&gt;ReactiveX operators documentation: Merge&lt;/a&gt;
     */
    @BackpressureSupport(BackpressureKind.FULL)
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;T&gt; mergeWith(SingleSource&lt;? extends T&gt; other) {
<span class="fc" id="L3093">        return merge(this, other);</span>
    }

    /**
     * Modifies a Single to emit its item (or notify of its error) on a specified {@link Scheduler},
     * asynchronously.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.observeOn.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;you specify which {@link Scheduler} this operator will use.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param scheduler
     *            the {@link Scheduler} to notify subscribers on
     * @return the source Single modified so that its subscribers are notified on the specified
     *         {@link Scheduler}
     * @throws NullPointerException if scheduler is null
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/observeon.html&quot;&gt;ReactiveX operators documentation: ObserveOn&lt;/a&gt;
     * @see &lt;a href=&quot;http://www.grahamlea.com/2014/07/rxjava-threading-examples/&quot;&gt;RxJava Threading Examples&lt;/a&gt;
     * @see #subscribeOn
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Single&lt;T&gt; observeOn(final Scheduler scheduler) {
<span class="fc" id="L3119">        ObjectHelper.requireNonNull(scheduler, &quot;scheduler is null&quot;);</span>
<span class="fc" id="L3120">        return RxJavaPlugins.onAssembly(new SingleObserveOn&lt;T&gt;(this, scheduler));</span>
    }

    /**
     * Instructs a Single to emit an item (returned by a specified function) rather than invoking
     * {@link SingleObserver#onError onError} if it encounters an error.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;451&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.onErrorReturn.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * By default, when a Single encounters an error that prevents it from emitting the expected item to its
     * subscriber, the Single invokes its subscriber's {@link SingleObserver#onError} method, and then quits
     * without invoking any more of its subscriber's methods. The {@code onErrorReturn} method changes this
     * behavior. If you pass a function ({@code resumeFunction}) to a Single's {@code onErrorReturn} method, if
     * the original Single encounters an error, instead of invoking its subscriber's
     * {@link SingleObserver#onError} method, it will instead emit the return value of {@code resumeFunction}.
     * &lt;p&gt;
     * You can use this to prevent errors from propagating or to supply fallback data should errors be
     * encountered.
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code onErrorReturn} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param resumeFunction
     *            a function that returns an item that the new Single will emit if the source Single encounters
     *            an error
     * @return the original Single with appropriately modified behavior
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/catch.html&quot;&gt;ReactiveX operators documentation: Catch&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Single&lt;T&gt; onErrorReturn(final Function&lt;Throwable, ? extends T&gt; resumeFunction) {
<span class="fc" id="L3153">        ObjectHelper.requireNonNull(resumeFunction, &quot;resumeFunction is null&quot;);</span>
<span class="fc" id="L3154">        return RxJavaPlugins.onAssembly(new SingleOnErrorReturn&lt;T&gt;(this, resumeFunction, null));</span>
    }

    /**
     * Signals the specified value as success in case the current Single signals an error.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;451&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.onErrorReturnItem.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code onErrorReturnItem} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param value the value to signal if the current Single fails
     * @return the new Single instance
     * @since 2.0
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Single&lt;T&gt; onErrorReturnItem(final T value) {
<span class="fc" id="L3173">        ObjectHelper.requireNonNull(value, &quot;value is null&quot;);</span>
<span class="fc" id="L3174">        return RxJavaPlugins.onAssembly(new SingleOnErrorReturn&lt;T&gt;(this, null, value));</span>
    }

    /**
     * Instructs a Single to pass control to another Single rather than invoking
     * {@link SingleObserver#onError(Throwable)} if it encounters an error.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;451&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.onErrorResumeNext.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * By default, when a Single encounters an error that prevents it from emitting the expected item to
     * its {@link SingleObserver}, the Single invokes its SingleObserver's {@code onError} method, and then quits
     * without invoking any more of its SingleObserver's methods. The {@code onErrorResumeNext} method changes this
     * behavior. If you pass another Single ({@code resumeSingleInCaseOfError}) to a Single's
     * {@code onErrorResumeNext} method, if the original Single encounters an error, instead of invoking its
     * SingleObserver's {@code onError} method, it will instead relinquish control to {@code resumeSingleInCaseOfError} which
     * will invoke the SingleObserver's {@link SingleObserver#onSuccess onSuccess} method if it is able to do so. In such a case,
     * because no Single necessarily invokes {@code onError}, the SingleObserver may never know that an error
     * happened.
     * &lt;p&gt;
     * You can use this to prevent errors from propagating or to supply fallback data should errors be
     * encountered.
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code onErrorResumeNext} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param resumeSingleInCaseOfError a Single that will take control if source Single encounters an error.
     * @return the original Single, with appropriately modified behavior.
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/catch.html&quot;&gt;ReactiveX operators documentation: Catch&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Single&lt;T&gt; onErrorResumeNext(final Single&lt;? extends T&gt; resumeSingleInCaseOfError) {
<span class="fc" id="L3208">        ObjectHelper.requireNonNull(resumeSingleInCaseOfError, &quot;resumeSingleInCaseOfError is null&quot;);</span>
<span class="fc" id="L3209">        return onErrorResumeNext(Functions.justFunction(resumeSingleInCaseOfError));</span>
    }

    /**
     * Instructs a Single to pass control to another Single rather than invoking
     * {@link SingleObserver#onError(Throwable)} if it encounters an error.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;451&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.onErrorResumeNext.f.png&quot; alt=&quot;&quot;&gt;
     * &lt;p&gt;
     * By default, when a Single encounters an error that prevents it from emitting the expected item to
     * its {@link SingleObserver}, the Single invokes its SingleObserver's {@code onError} method, and then quits
     * without invoking any more of its SingleObserver's methods. The {@code onErrorResumeNext} method changes this
     * behavior. If you pass a function that will return another Single ({@code resumeFunctionInCaseOfError}) to a Single's
     * {@code onErrorResumeNext} method, if the original Single encounters an error, instead of invoking its
     * SingleObserver's {@code onError} method, it will instead relinquish control to {@code resumeSingleInCaseOfError} which
     * will invoke the SingleObserver's {@link SingleObserver#onSuccess onSuccess} method if it is able to do so. In such a case,
     * because no Single necessarily invokes {@code onError}, the SingleObserver may never know that an error
     * happened.
     * &lt;p&gt;
     * You can use this to prevent errors from propagating or to supply fallback data should errors be
     * encountered.
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code onErrorResumeNext} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param resumeFunctionInCaseOfError a function that returns a Single that will take control if source Single encounters an error.
     * @return the original Single, with appropriately modified behavior.
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/catch.html&quot;&gt;ReactiveX operators documentation: Catch&lt;/a&gt;
     * @since .20
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Single&lt;T&gt; onErrorResumeNext(
            final Function&lt;? super Throwable, ? extends SingleSource&lt;? extends T&gt;&gt; resumeFunctionInCaseOfError) {
<span class="fc" id="L3245">        ObjectHelper.requireNonNull(resumeFunctionInCaseOfError, &quot;resumeFunctionInCaseOfError is null&quot;);</span>
<span class="fc" id="L3246">        return RxJavaPlugins.onAssembly(new SingleResumeNext&lt;T&gt;(this, resumeFunctionInCaseOfError));</span>
    }

    /**
     * Nulls out references to the upstream producer and downstream SingleObserver if
     * the sequence is terminated or downstream calls dispose().
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code onTerminateDetach} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * &lt;p&gt;History: 2.1.5 - experimental
     * @return a Single which nulls out references to the upstream producer and downstream SingleObserver if
     * the sequence is terminated or downstream calls dispose()
     * @since 2.2
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Single&lt;T&gt; onTerminateDetach() {
<span class="fc" id="L3264">        return RxJavaPlugins.onAssembly(new SingleDetach&lt;T&gt;(this));</span>
    }

    /**
     * Repeatedly re-subscribes to the current Single and emits each success value.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;457&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.repeat.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The returned {@code Flowable} honors the backpressure of the downstream consumer.&lt;/dd&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code repeat} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @return the new Flowable instance
     * @since 2.0
     */
    @BackpressureSupport(BackpressureKind.FULL)
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;T&gt; repeat() {
<span class="fc" id="L3284">        return toFlowable().repeat();</span>
    }

    /**
     * Re-subscribes to the current Single at most the given number of times and emits each success value.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;457&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.repeat.n.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The returned {@code Flowable} honors the backpressure of the downstream consumer.&lt;/dd&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code repeat} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param times the number of times to re-subscribe to the current Single
     * @return the new Flowable instance
     * @since 2.0
     */
    @BackpressureSupport(BackpressureKind.FULL)
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;T&gt; repeat(long times) {
<span class="fc" id="L3305">        return toFlowable().repeat(times);</span>
    }

    /**
     * Re-subscribes to the current Single if
     * the Publisher returned by the handler function signals a value in response to a
     * value signalled through the Flowable the handle receives.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;1478&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.repeatWhen.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The returned {@code Flowable} honors the backpressure of the downstream consumer.
     *  The {@code Publisher} returned by the handler function is expected to honor backpressure as well.&lt;/dd&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code repeatWhen} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param handler the function that is called with a Flowable that signals a value when the Single
     *                signalled a success value and returns a Publisher that has to signal a value to
     *                trigger a resubscription to the current Single, otherwise the terminal signal of
     *                the Publisher will be the terminal signal of the sequence as well.
     * @return the new Flowable instance
     * @since 2.0
     */
    @BackpressureSupport(BackpressureKind.FULL)
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;T&gt; repeatWhen(Function&lt;? super Flowable&lt;Object&gt;, ? extends Publisher&lt;?&gt;&gt; handler) {
<span class="fc" id="L3332">        return toFlowable().repeatWhen(handler);</span>
    }

    /**
     * Re-subscribes to the current Single until the given BooleanSupplier returns true.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;463&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.repeatUntil.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The returned {@code Flowable} honors the backpressure of the downstream consumer.&lt;/dd&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code repeatUntil} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param stop the BooleanSupplier called after the current Single succeeds and if returns false,
     *             the Single is re-subscribed; otherwise the sequence completes.
     * @return the new Flowable instance
     * @since 2.0
     */
    @BackpressureSupport(BackpressureKind.FULL)
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Flowable&lt;T&gt; repeatUntil(BooleanSupplier stop) {
<span class="fc" id="L3354">        return toFlowable().repeatUntil(stop);</span>
    }

    /**
     * Repeatedly re-subscribes to the current Single indefinitely if it fails with an onError.
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code retry} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @return the new Single instance
     * @since 2.0
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Single&lt;T&gt; retry() {
<span class="fc" id="L3369">        return toSingle(toFlowable().retry());</span>
    }

    /**
     * Repeatedly re-subscribe at most the specified times to the current Single
     * if it fails with an onError.
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code retry} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param times the number of times to resubscribe if the current Single fails
     * @return the new Single instance
     * @since 2.0
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Single&lt;T&gt; retry(long times) {
<span class="fc" id="L3386">        return toSingle(toFlowable().retry(times));</span>
    }

    /**
     * Re-subscribe to the current Single if the given predicate returns true when the Single fails
     * with an onError.
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code retry} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param predicate the predicate called with the resubscription count and the failure Throwable
     *                  and should return true if a resubscription should happen
     * @return the new Single instance
     * @since 2.0
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Single&lt;T&gt; retry(BiPredicate&lt;? super Integer, ? super Throwable&gt; predicate) {
<span class="fc" id="L3404">        return toSingle(toFlowable().retry(predicate));</span>
    }

    /**
     * Repeatedly re-subscribe at most times or until the predicate returns false, whichever happens first
     * if it fails with an onError.
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code retry} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * &lt;p&gt;History: 2.1.8 - experimental
     * @param times the number of times to resubscribe if the current Single fails
     * @param predicate the predicate called with the failure Throwable
     *                  and should return true if a resubscription should happen
     * @return the new Single instance
     * @since 2.2
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Single&lt;T&gt; retry(long times, Predicate&lt;? super Throwable&gt; predicate) {
<span class="fc" id="L3424">        return toSingle(toFlowable().retry(times, predicate));</span>
    }

    /**
     * Re-subscribe to the current Single if the given predicate returns true when the Single fails
     * with an onError.
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code retry} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param predicate the predicate called with the failure Throwable
     *                  and should return true if a resubscription should happen
     * @return the new Single instance
     * @since 2.0
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Single&lt;T&gt; retry(Predicate&lt;? super Throwable&gt; predicate) {
<span class="fc" id="L3442">        return toSingle(toFlowable().retry(predicate));</span>
    }

    /**
     * Re-subscribes to the current Single if and when the Publisher returned by the handler
     * function signals a value.
     * &lt;p&gt;
     * If the Publisher signals an onComplete, the resulting Single will signal a NoSuchElementException.
     * &lt;p&gt;
     * Note that the inner {@code Publisher} returned by the handler function should signal
     * either {@code onNext}, {@code onError} or {@code onComplete} in response to the received
     * {@code Throwable} to indicate the operator should retry or terminate. If the upstream to
     * the operator is asynchronous, signalling onNext followed by onComplete immediately may
     * result in the sequence to be completed immediately. Similarly, if this inner
     * {@code Publisher} signals {@code onError} or {@code onComplete} while the upstream is
     * active, the sequence is terminated with the same signal immediately.
     * &lt;p&gt;
     * The following example demonstrates how to retry an asynchronous source with a delay:
     * &lt;pre&gt;&lt;code&gt;
     * Single.timer(1, TimeUnit.SECONDS)
     *     .doOnSubscribe(s -&amp;gt; System.out.println(&quot;subscribing&quot;))
     *     .map(v -&amp;gt; { throw new RuntimeException(); })
     *     .retryWhen(errors -&amp;gt; {
     *         AtomicInteger counter = new AtomicInteger();
     *         return errors
     *                   .takeWhile(e -&amp;gt; counter.getAndIncrement() != 3)
     *                   .flatMap(e -&amp;gt; {
     *                       System.out.println(&quot;delay retry by &quot; + counter.get() + &quot; second(s)&quot;);
     *                       return Flowable.timer(counter.get(), TimeUnit.SECONDS);
     *                   });
     *     })
     *     .blockingGet();
     * &lt;/code&gt;&lt;/pre&gt;
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code retryWhen} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param handler the function that receives a Flowable of the error the Single emits and should
     *                return a Publisher that should signal a normal value (in response to the
     *                throwable the Flowable emits) to trigger a resubscription or signal an error to
     *                be the output of the resulting Single
     * @return the new Single instance
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Single&lt;T&gt; retryWhen(Function&lt;? super Flowable&lt;Throwable&gt;, ? extends Publisher&lt;?&gt;&gt; handler) {
<span class="fc" id="L3489">        return toSingle(toFlowable().retryWhen(handler));</span>
    }

    /**
     * Subscribes to a Single but ignore its emission or notification.
     * &lt;p&gt;
     * If the Single emits an error, it is wrapped into an
     * {@link io.reactivex.exceptions.OnErrorNotImplementedException OnErrorNotImplementedException}
     * and routed to the RxJavaPlugins.onError handler.
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code subscribe} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @return a {@link Disposable} reference can request the {@link Single} stop work.
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/subscribe.html&quot;&gt;ReactiveX operators documentation: Subscribe&lt;/a&gt;
     */
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Disposable subscribe() {
<span class="fc" id="L3508">        return subscribe(Functions.emptyConsumer(), Functions.ON_ERROR_MISSING);</span>
    }

    /**
     * Subscribes to a Single and provides a composite callback to handle the item it emits
     * or any error notification it issues.
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code subscribe} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param onCallback
     *            the callback that receives either the success value or the failure Throwable
     *            (whichever is not null)
     * @return a {@link Disposable} reference can request the {@link Single} stop work.
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/subscribe.html&quot;&gt;ReactiveX operators documentation: Subscribe&lt;/a&gt;
     * @throws NullPointerException
     *             if {@code onCallback} is null
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Disposable subscribe(final BiConsumer&lt;? super T, ? super Throwable&gt; onCallback) {
<span class="fc" id="L3531">        ObjectHelper.requireNonNull(onCallback, &quot;onCallback is null&quot;);</span>

<span class="fc" id="L3533">        BiConsumerSingleObserver&lt;T&gt; observer = new BiConsumerSingleObserver&lt;T&gt;(onCallback);</span>
<span class="fc" id="L3534">        subscribe(observer);</span>
<span class="fc" id="L3535">        return observer;</span>
    }

    /**
     * Subscribes to a Single and provides a callback to handle the item it emits.
     * &lt;p&gt;
     * If the Single emits an error, it is wrapped into an
     * {@link io.reactivex.exceptions.OnErrorNotImplementedException OnErrorNotImplementedException}
     * and routed to the RxJavaPlugins.onError handler.
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code subscribe} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param onSuccess
     *            the {@code Consumer&lt;T&gt;} you have designed to accept the emission from the Single
     * @return a {@link Disposable} reference can request the {@link Single} stop work.
     * @throws NullPointerException
     *             if {@code onSuccess} is null
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/subscribe.html&quot;&gt;ReactiveX operators documentation: Subscribe&lt;/a&gt;
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Disposable subscribe(Consumer&lt;? super T&gt; onSuccess) {
<span class="fc" id="L3559">        return subscribe(onSuccess, Functions.ON_ERROR_MISSING);</span>
    }

    /**
     * Subscribes to a Single and provides callbacks to handle the item it emits or any error notification it
     * issues.
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code subscribe} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param onSuccess
     *            the {@code Consumer&lt;T&gt;} you have designed to accept the emission from the Single
     * @param onError
     *            the {@code Consumer&lt;Throwable&gt;} you have designed to accept any error notification from the
     *            Single
     * @return a {@link Disposable} reference can request the {@link Single} stop work.
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/subscribe.html&quot;&gt;ReactiveX operators documentation: Subscribe&lt;/a&gt;
     * @throws NullPointerException
     *             if {@code onSuccess} is null, or
     *             if {@code onError} is null
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Disposable subscribe(final Consumer&lt;? super T&gt; onSuccess, final Consumer&lt;? super Throwable&gt; onError) {
<span class="fc" id="L3585">        ObjectHelper.requireNonNull(onSuccess, &quot;onSuccess is null&quot;);</span>
<span class="fc" id="L3586">        ObjectHelper.requireNonNull(onError, &quot;onError is null&quot;);</span>

<span class="fc" id="L3588">        ConsumerSingleObserver&lt;T&gt; observer = new ConsumerSingleObserver&lt;T&gt;(onSuccess, onError);</span>
<span class="fc" id="L3589">        subscribe(observer);</span>
<span class="fc" id="L3590">        return observer;</span>
    }

    @SchedulerSupport(SchedulerSupport.NONE)
    @Override
    public final void subscribe(SingleObserver&lt;? super T&gt; observer) {
<span class="fc" id="L3596">        ObjectHelper.requireNonNull(observer, &quot;observer is null&quot;);</span>

<span class="fc" id="L3598">        observer = RxJavaPlugins.onSubscribe(this, observer);</span>

<span class="fc" id="L3600">        ObjectHelper.requireNonNull(observer, &quot;The RxJavaPlugins.onSubscribe hook returned a null SingleObserver. Please check the handler provided to RxJavaPlugins.setOnSingleSubscribe for invalid null returns. Further reading: https://github.com/ReactiveX/RxJava/wiki/Plugins&quot;);</span>

        try {
<span class="fc" id="L3603">            subscribeActual(observer);</span>
<span class="fc" id="L3604">        } catch (NullPointerException ex) {</span>
<span class="fc" id="L3605">            throw ex;</span>
<span class="fc" id="L3606">        } catch (Throwable ex) {</span>
<span class="fc" id="L3607">            Exceptions.throwIfFatal(ex);</span>
<span class="fc" id="L3608">            NullPointerException npe = new NullPointerException(&quot;subscribeActual failed&quot;);</span>
<span class="fc" id="L3609">            npe.initCause(ex);</span>
<span class="fc" id="L3610">            throw npe;</span>
<span class="fc" id="L3611">        }</span>
<span class="fc" id="L3612">    }</span>

    /**
     * Implement this method in subclasses to handle the incoming {@link SingleObserver}s.
     * &lt;p&gt;There is no need to call any of the plugin hooks on the current {@code Single} instance or
     * the {@code SingleObserver}; all hooks and basic safeguards have been
     * applied by {@link #subscribe(SingleObserver)} before this method gets called.
     * @param observer the SingleObserver to handle, not null
     */
    protected abstract void subscribeActual(@NonNull SingleObserver&lt;? super T&gt; observer);

    /**
     * Subscribes a given SingleObserver (subclass) to this Single and returns the given
     * SingleObserver as is.
     * &lt;p&gt;Usage example:
     * &lt;pre&gt;&lt;code&gt;
     * Single&amp;lt;Integer&amp;gt; source = Single.just(1);
     * CompositeDisposable composite = new CompositeDisposable();
     *
     * DisposableSingleObserver&amp;lt;Integer&amp;gt; ds = new DisposableSingleObserver&amp;lt;&amp;gt;() {
     *     // ...
     * };
     *
     * composite.add(source.subscribeWith(ds));
     * &lt;/code&gt;&lt;/pre&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code subscribeWith} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;E&gt; the type of the SingleObserver to use and return
     * @param observer the SingleObserver (subclass) to use and return, not null
     * @return the input {@code observer}
     * @throws NullPointerException if {@code observer} is null
     * @since 2.0
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;E extends SingleObserver&lt;? super T&gt;&gt; E subscribeWith(E observer) {
<span class="fc" id="L3650">        subscribe(observer);</span>
<span class="fc" id="L3651">        return observer;</span>
    }

    /**
     * Asynchronously subscribes subscribers to this Single on the specified {@link Scheduler}.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.subscribeOn.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;You specify which {@link Scheduler} this operator will use.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param scheduler
     *            the {@link Scheduler} to perform subscription actions on
     * @return the source Single modified so that its subscriptions happen on the specified {@link Scheduler}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/subscribeon.html&quot;&gt;ReactiveX operators documentation: SubscribeOn&lt;/a&gt;
     * @see &lt;a href=&quot;http://www.grahamlea.com/2014/07/rxjava-threading-examples/&quot;&gt;RxJava Threading Examples&lt;/a&gt;
     * @see #observeOn
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Single&lt;T&gt; subscribeOn(final Scheduler scheduler) {
<span class="fc" id="L3674">        ObjectHelper.requireNonNull(scheduler, &quot;scheduler is null&quot;);</span>
<span class="fc" id="L3675">        return RxJavaPlugins.onAssembly(new SingleSubscribeOn&lt;T&gt;(this, scheduler));</span>
    }

    /**
     * Returns a Single that emits the item emitted by the source Single until a Completable terminates. Upon
     * termination of {@code other}, this will emit a {@link CancellationException} rather than go to
     * {@link SingleObserver#onSuccess(Object)}.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/takeUntil.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code takeUntil} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param other
     *            the Completable whose termination will cause {@code takeUntil} to emit the item from the source
     *            Single
     * @return a Single that emits the item emitted by the source Single until such time as {@code other} terminates.
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/takeuntil.html&quot;&gt;ReactiveX operators documentation: TakeUntil&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Single&lt;T&gt; takeUntil(final CompletableSource other) {
<span class="fc" id="L3699">        ObjectHelper.requireNonNull(other, &quot;other is null&quot;);</span>
<span class="fc" id="L3700">        return takeUntil(new CompletableToFlowable&lt;T&gt;(other));</span>
    }

    /**
     * Returns a Single that emits the item emitted by the source Single until a Publisher emits an item. Upon
     * emission of an item from {@code other}, this will emit a {@link CancellationException} rather than go to
     * {@link SingleObserver#onSuccess(Object)}.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/takeUntil.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The {@code other} publisher is consumed in an unbounded fashion but will be
     *  cancelled after the first item it produced.&lt;/dd&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code takeUntil} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param other
     *            the Publisher whose first emitted item will cause {@code takeUntil} to emit the item from the source
     *            Single
     * @param &lt;E&gt;
     *            the type of items emitted by {@code other}
     * @return a Single that emits the item emitted by the source Single until such time as {@code other} emits
     * its first item
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/takeuntil.html&quot;&gt;ReactiveX operators documentation: TakeUntil&lt;/a&gt;
     */
    @BackpressureSupport(BackpressureKind.FULL)
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;E&gt; Single&lt;T&gt; takeUntil(final Publisher&lt;E&gt; other) {
<span class="fc" id="L3731">        ObjectHelper.requireNonNull(other, &quot;other is null&quot;);</span>
<span class="fc" id="L3732">        return RxJavaPlugins.onAssembly(new SingleTakeUntil&lt;T, E&gt;(this, other));</span>
    }

    /**
     * Returns a Single that emits the item emitted by the source Single until a second Single emits an item. Upon
     * emission of an item from {@code other}, this will emit a {@link CancellationException} rather than go to
     * {@link SingleObserver#onSuccess(Object)}.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/takeUntil.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code takeUntil} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param other
     *            the Single whose emitted item will cause {@code takeUntil} to emit the item from the source Single
     * @param &lt;E&gt;
     *            the type of item emitted by {@code other}
     * @return a Single that emits the item emitted by the source Single until such time as {@code other} emits its item
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/takeuntil.html&quot;&gt;ReactiveX operators documentation: TakeUntil&lt;/a&gt;
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;E&gt; Single&lt;T&gt; takeUntil(final SingleSource&lt;? extends E&gt; other) {
<span class="fc" id="L3757">        ObjectHelper.requireNonNull(other, &quot;other is null&quot;);</span>
<span class="fc" id="L3758">        return takeUntil(new SingleToFlowable&lt;E&gt;(other));</span>
    }

    /**
     * Signals a TimeoutException if the current Single doesn't signal a success value within the
     * specified timeout window.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code timeout} signals the TimeoutException on the {@code computation} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param timeout the timeout amount
     * @param unit the time unit
     * @return the new Single instance
     * @since 2.0
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.COMPUTATION)
    public final Single&lt;T&gt; timeout(long timeout, TimeUnit unit) {
<span class="fc" id="L3776">        return timeout0(timeout, unit, Schedulers.computation(), null);</span>
    }

    /**
     * Signals a TimeoutException if the current Single doesn't signal a success value within the
     * specified timeout window.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code timeout} signals the TimeoutException on the {@link Scheduler} you specify.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param timeout the timeout amount
     * @param unit the time unit
     * @param scheduler the target scheduler where the timeout is awaited and the TimeoutException
     *                  signalled
     * @return the new Single instance
     * @since 2.0
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Single&lt;T&gt; timeout(long timeout, TimeUnit unit, Scheduler scheduler) {
<span class="fc" id="L3796">        return timeout0(timeout, unit, scheduler, null);</span>
    }

    /**
     * Runs the current Single and if it doesn't signal within the specified timeout window, it is
     * disposed and the other SingleSource subscribed to.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code timeout} subscribes to the other SingleSource on the {@link Scheduler} you specify.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param timeout the timeout amount
     * @param unit the time unit
     * @param scheduler the scheduler where the timeout is awaited and the subscription to other happens
     * @param other the other SingleSource that gets subscribed to if the current Single times out
     * @return the new Single instance
     * @since 2.0
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Single&lt;T&gt; timeout(long timeout, TimeUnit unit, Scheduler scheduler, SingleSource&lt;? extends T&gt; other) {
<span class="fc" id="L3817">        ObjectHelper.requireNonNull(other, &quot;other is null&quot;);</span>
<span class="fc" id="L3818">        return timeout0(timeout, unit, scheduler, other);</span>
    }

    /**
     * Runs the current Single and if it doesn't signal within the specified timeout window, it is
     * disposed and the other SingleSource subscribed to.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code timeout} subscribes to the other SingleSource on
     *  the {@code computation} {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param timeout the timeout amount
     * @param unit the time unit
     * @param other the other SingleSource that gets subscribed to if the current Single times out
     * @return the new Single instance
     * @throws NullPointerException
     *             if other is null, or
     *             if unit is null, or
     *             if scheduler is null
     * @since 2.0
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.COMPUTATION)
    public final Single&lt;T&gt; timeout(long timeout, TimeUnit unit, SingleSource&lt;? extends T&gt; other) {
<span class="fc" id="L3843">        ObjectHelper.requireNonNull(other, &quot;other is null&quot;);</span>
<span class="fc" id="L3844">        return timeout0(timeout, unit, Schedulers.computation(), other);</span>
    }

    private Single&lt;T&gt; timeout0(final long timeout, final TimeUnit unit, final Scheduler scheduler, final SingleSource&lt;? extends T&gt; other) {
<span class="fc" id="L3848">        ObjectHelper.requireNonNull(unit, &quot;unit is null&quot;);</span>
<span class="fc" id="L3849">        ObjectHelper.requireNonNull(scheduler, &quot;scheduler is null&quot;);</span>
<span class="fc" id="L3850">        return RxJavaPlugins.onAssembly(new SingleTimeout&lt;T&gt;(this, timeout, unit, scheduler, other));</span>
    }

    /**
     * Calls the specified converter function with the current Single instance
     * during assembly time and returns its result.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;553&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.to.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code to} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param &lt;R&gt; the result type
     * @param convert the function that is called with the current Single instance during
     *                assembly time that should return some value to be the result
     *
     * @return the value returned by the convert function
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;R&gt; R to(Function&lt;? super Single&lt;T&gt;, R&gt; convert) {
        try {
<span class="fc" id="L3872">            return ObjectHelper.requireNonNull(convert, &quot;convert is null&quot;).apply(this);</span>
<span class="fc" id="L3873">        } catch (Throwable ex) {</span>
<span class="fc" id="L3874">            Exceptions.throwIfFatal(ex);</span>
<span class="fc" id="L3875">            throw ExceptionHelper.wrapOrThrow(ex);</span>
        }
    }

    /**
     * Returns a {@link Completable} that discards result of the {@link Single}
     * and calls {@code onComplete} when this source {@link Single} calls
     * {@code onSuccess}. Error terminal event is propagated.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;436&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.toCompletable.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code toCompletable} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @return a {@link Completable} that calls {@code onComplete} on it's subscriber when the source {@link Single}
     *         calls {@code onSuccess}.
     * @since 2.0
     * @deprecated see {@link #ignoreElement()} instead, will be removed in 3.0
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    @Deprecated
    public final Completable toCompletable() {
<span class="fc" id="L3899">        return RxJavaPlugins.onAssembly(new CompletableFromSingle&lt;T&gt;(this));</span>
    }

    /**
     * Returns a {@link Completable} that ignores the success value of this {@link Single}
     * and calls {@code onComplete} instead on the returned {@code Completable}.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;436&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.ignoreElement.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code ignoreElement} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @return a {@link Completable} that calls {@code onComplete} on it's observer when the source {@link Single}
     *         calls {@code onSuccess}.
     * @since 2.1.13
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Completable ignoreElement() {
<span class="fc" id="L3919">        return RxJavaPlugins.onAssembly(new CompletableFromSingle&lt;T&gt;(this));</span>
    }

    /**
     * Converts this Single into a {@link Flowable}.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;462&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.toFlowable.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Backpressure:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;The returned {@code Flowable} honors the backpressure of the downstream consumer.&lt;/dd&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code toFlowable} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @return a {@link Flowable} that emits a single item T or an error.
     */
    @BackpressureSupport(BackpressureKind.FULL)
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    @SuppressWarnings(&quot;unchecked&quot;)
    public final Flowable&lt;T&gt; toFlowable() {
<span class="fc bfc" id="L3940" title="All 2 branches covered.">        if (this instanceof FuseToFlowable) {</span>
<span class="fc" id="L3941">            return ((FuseToFlowable&lt;T&gt;)this).fuseToFlowable();</span>
        }
<span class="fc" id="L3943">        return RxJavaPlugins.onAssembly(new SingleToFlowable&lt;T&gt;(this));</span>
    }

    /**
     * Returns a {@link Future} representing the single value emitted by this {@code Single}.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;467&quot; src=&quot;https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/Single.toFuture.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code toFuture} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @return a {@link Future} that expects a single item to be emitted by this {@code Single}
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/to.html&quot;&gt;ReactiveX documentation: To&lt;/a&gt;
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public final Future&lt;T&gt; toFuture() {
<span class="fc" id="L3961">        return subscribeWith(new FutureSingleObserver&lt;T&gt;());</span>
    }

    /**
     * Converts this Single into a {@link Maybe}.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;463&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.toMaybe.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code toMaybe} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @return a {@link Maybe} that emits a single item T or an error.
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    @SuppressWarnings(&quot;unchecked&quot;)
    public final Maybe&lt;T&gt; toMaybe() {
<span class="fc bfc" id="L3979" title="All 2 branches covered.">        if (this instanceof FuseToMaybe) {</span>
<span class="fc" id="L3980">            return ((FuseToMaybe&lt;T&gt;)this).fuseToMaybe();</span>
        }
<span class="fc" id="L3982">        return RxJavaPlugins.onAssembly(new MaybeFromSingle&lt;T&gt;(this));</span>
    }
    /**
     * Converts this Single into an {@link Observable}.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;305&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.toObservable.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code toObservable} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @return an {@link Observable} that emits a single item T or an error.
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    @SuppressWarnings(&quot;unchecked&quot;)
    public final Observable&lt;T&gt; toObservable() {
<span class="fc bfc" id="L3999" title="All 2 branches covered.">        if (this instanceof FuseToObservable) {</span>
<span class="fc" id="L4000">            return ((FuseToObservable&lt;T&gt;)this).fuseToObservable();</span>
        }
<span class="fc" id="L4002">        return RxJavaPlugins.onAssembly(new SingleToObservable&lt;T&gt;(this));</span>
    }

    /**
     * Returns a Single which makes sure when a SingleObserver disposes the Disposable,
     * that call is propagated up on the specified scheduler.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code unsubscribeOn} calls dispose() of the upstream on the {@link Scheduler} you specify.&lt;/dd&gt;
     * &lt;/dl&gt;
     * &lt;p&gt;History: 2.0.9 - experimental
     * @param scheduler the target scheduler where to execute the disposal
     * @return the new Single instance
     * @throws NullPointerException if scheduler is null
     * @since 2.2
     */
    @CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.CUSTOM)
    public final Single&lt;T&gt; unsubscribeOn(final Scheduler scheduler) {
<span class="fc" id="L4022">        ObjectHelper.requireNonNull(scheduler, &quot;scheduler is null&quot;);</span>
<span class="fc" id="L4023">        return RxJavaPlugins.onAssembly(new SingleUnsubscribeOn&lt;T&gt;(this, scheduler));</span>
    }

    /**
     * Returns a Single that emits the result of applying a specified function to the pair of items emitted by
     * the source Single and another specified Single.
     * &lt;p&gt;
     * &lt;img width=&quot;640&quot; height=&quot;380&quot; src=&quot;https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.zip.png&quot; alt=&quot;&quot;&gt;
     * &lt;dl&gt;
     * &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     * &lt;dd&gt;{@code zipWith} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     *
     * @param &lt;U&gt;
     *            the type of items emitted by the {@code other} Single
     * @param &lt;R&gt;
     *            the type of items emitted by the resulting Single
     * @param other
     *            the other SingleSource
     * @param zipper
     *            a function that combines the pairs of items from the two SingleSources to generate the items to
     *            be emitted by the resulting Single
     * @return a Single that pairs up values from the source Single and the {@code other} SingleSource
     *         and emits the results of {@code zipFunction} applied to these pairs
     * @see &lt;a href=&quot;http://reactivex.io/documentation/operators/zip.html&quot;&gt;ReactiveX operators documentation: Zip&lt;/a&gt;
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public final &lt;U, R&gt; Single&lt;R&gt; zipWith(SingleSource&lt;U&gt; other, BiFunction&lt;? super T, ? super U, ? extends R&gt; zipper) {
<span class="fc" id="L4052">        return zip(this, other, zipper);</span>
    }

    // -------------------------------------------------------------------------
    // Fluent test support, super handy and reduces test preparation boilerplate
    // -------------------------------------------------------------------------
    /**
     * Creates a TestObserver and subscribes
     * it to this Single.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code test} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @return the new TestObserver instance
     * @since 2.0
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public final TestObserver&lt;T&gt; test() {
<span class="fc" id="L4071">        TestObserver&lt;T&gt; to = new TestObserver&lt;T&gt;();</span>
<span class="fc" id="L4072">        subscribe(to);</span>
<span class="fc" id="L4073">        return to;</span>
    }

    /**
     * Creates a TestObserver optionally in cancelled state, then subscribes it to this Single.
     * &lt;dl&gt;
     *  &lt;dt&gt;&lt;b&gt;Scheduler:&lt;/b&gt;&lt;/dt&gt;
     *  &lt;dd&gt;{@code test} does not operate by default on a particular {@link Scheduler}.&lt;/dd&gt;
     * &lt;/dl&gt;
     * @param cancelled if true, the TestObserver will be cancelled before subscribing to this
     * Single.
     * @return the new TestObserver instance
     * @since 2.0
     */
    @CheckReturnValue
    @SchedulerSupport(SchedulerSupport.NONE)
    public final TestObserver&lt;T&gt; test(boolean cancelled) {
<span class="fc" id="L4090">        TestObserver&lt;T&gt; to = new TestObserver&lt;T&gt;();</span>

<span class="fc bfc" id="L4092" title="All 2 branches covered.">        if (cancelled) {</span>
<span class="fc" id="L4093">            to.cancel();</span>
        }

<span class="fc" id="L4096">        subscribe(to);</span>
<span class="fc" id="L4097">        return to;</span>
    }

    private static &lt;T&gt; Single&lt;T&gt; toSingle(Flowable&lt;T&gt; source) {
<span class="fc" id="L4101">        return RxJavaPlugins.onAssembly(new FlowableSingleSingle&lt;T&gt;(source, null));</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>